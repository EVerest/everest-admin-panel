var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var require_index_001 = __commonJS({
  "assets/index-pJ1XnDhS.js"(exports, module) {
    var _a;
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link2 of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link2);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node of mutation.addedNodes) {
            if (node.tagName === "LINK" && node.rel === "modulepreload")
              processPreload(node);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link2) {
        const fetchOpts = {};
        if (link2.integrity)
          fetchOpts.integrity = link2.integrity;
        if (link2.referrerPolicy)
          fetchOpts.referrerPolicy = link2.referrerPolicy;
        if (link2.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link2.crossOrigin === "anonymous")
          fetchOpts.credentials = "omit";
        else
          fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link2) {
        if (link2.ep)
          return;
        link2.ep = true;
        const fetchOpts = getFetchOpts(link2);
        fetch(link2.href, fetchOpts);
      }
    })();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
    
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
    
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    var __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
          s = arguments[i2];
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2))
              t[p2] = s[p2];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var NotyfNotification = (
      /** @class */
      function() {
        function NotyfNotification2(options) {
          this.options = options;
          this.listeners = {};
        }
        NotyfNotification2.prototype.on = function(eventType, cb) {
          var callbacks = this.listeners[eventType] || [];
          this.listeners[eventType] = callbacks.concat([cb]);
        };
        NotyfNotification2.prototype.triggerEvent = function(eventType, event) {
          var _this = this;
          var callbacks = this.listeners[eventType] || [];
          callbacks.forEach(function(cb) {
            return cb({ target: _this, event });
          });
        };
        return NotyfNotification2;
      }()
    );
    var NotyfArrayEvent;
    (function(NotyfArrayEvent2) {
      NotyfArrayEvent2[NotyfArrayEvent2["Add"] = 0] = "Add";
      NotyfArrayEvent2[NotyfArrayEvent2["Remove"] = 1] = "Remove";
    })(NotyfArrayEvent || (NotyfArrayEvent = {}));
    var NotyfArray = (
      /** @class */
      function() {
        function NotyfArray2() {
          this.notifications = [];
        }
        NotyfArray2.prototype.push = function(elem) {
          this.notifications.push(elem);
          this.updateFn(elem, NotyfArrayEvent.Add, this.notifications);
        };
        NotyfArray2.prototype.splice = function(index, num2) {
          var elem = this.notifications.splice(index, num2)[0];
          this.updateFn(elem, NotyfArrayEvent.Remove, this.notifications);
          return elem;
        };
        NotyfArray2.prototype.indexOf = function(elem) {
          return this.notifications.indexOf(elem);
        };
        NotyfArray2.prototype.onUpdate = function(fn) {
          this.updateFn = fn;
        };
        return NotyfArray2;
      }()
    );
    var NotyfEvent;
    (function(NotyfEvent2) {
      NotyfEvent2["Dismiss"] = "dismiss";
      NotyfEvent2["Click"] = "click";
    })(NotyfEvent || (NotyfEvent = {}));
    var DEFAULT_OPTIONS = {
      types: [
        {
          type: "success",
          className: "notyf__toast--success",
          backgroundColor: "#3dc763",
          icon: {
            className: "notyf__icon--success",
            tagName: "i"
          }
        },
        {
          type: "error",
          className: "notyf__toast--error",
          backgroundColor: "#ed3d3d",
          icon: {
            className: "notyf__icon--error",
            tagName: "i"
          }
        }
      ],
      duration: 2e3,
      ripple: true,
      position: {
        x: "right",
        y: "bottom"
      },
      dismissible: false
    };
    var NotyfView = (
      /** @class */
      function() {
        function NotyfView2() {
          this.notifications = [];
          this.events = {};
          this.X_POSITION_FLEX_MAP = {
            left: "flex-start",
            center: "center",
            right: "flex-end"
          };
          this.Y_POSITION_FLEX_MAP = {
            top: "flex-start",
            center: "center",
            bottom: "flex-end"
          };
          var docFrag = document.createDocumentFragment();
          var notyfContainer = this._createHTMLElement({ tagName: "div", className: "notyf" });
          docFrag.appendChild(notyfContainer);
          document.body.appendChild(docFrag);
          this.container = notyfContainer;
          this.animationEndEventName = this._getAnimationEndEventName();
          this._createA11yContainer();
        }
        NotyfView2.prototype.on = function(event, cb) {
          var _a2;
          this.events = __assign(__assign({}, this.events), (_a2 = {}, _a2[event] = cb, _a2));
        };
        NotyfView2.prototype.update = function(notification, type2) {
          if (type2 === NotyfArrayEvent.Add) {
            this.addNotification(notification);
          } else if (type2 === NotyfArrayEvent.Remove) {
            this.removeNotification(notification);
          }
        };
        NotyfView2.prototype.removeNotification = function(notification) {
          var _this = this;
          var renderedNotification = this._popRenderedNotification(notification);
          var node;
          if (!renderedNotification) {
            return;
          }
          node = renderedNotification.node;
          node.classList.add("notyf__toast--disappear");
          var handleEvent;
          node.addEventListener(this.animationEndEventName, handleEvent = function(event) {
            if (event.target === node) {
              node.removeEventListener(_this.animationEndEventName, handleEvent);
              _this.container.removeChild(node);
            }
          });
        };
        NotyfView2.prototype.addNotification = function(notification) {
          var node = this._renderNotification(notification);
          this.notifications.push({ notification, node });
          this._announce(notification.options.message || "Notification");
        };
        NotyfView2.prototype._renderNotification = function(notification) {
          var _a2;
          var card = this._buildNotificationCard(notification);
          var className = notification.options.className;
          if (className) {
            (_a2 = card.classList).add.apply(_a2, className.split(" "));
          }
          this.container.appendChild(card);
          return card;
        };
        NotyfView2.prototype._popRenderedNotification = function(notification) {
          var idx = -1;
          for (var i2 = 0; i2 < this.notifications.length && idx < 0; i2++) {
            if (this.notifications[i2].notification === notification) {
              idx = i2;
            }
          }
          if (idx !== -1) {
            return this.notifications.splice(idx, 1)[0];
          }
          return;
        };
        NotyfView2.prototype.getXPosition = function(options) {
          var _a2;
          return ((_a2 = options === null || options === void 0 ? void 0 : options.position) === null || _a2 === void 0 ? void 0 : _a2.x) || "right";
        };
        NotyfView2.prototype.getYPosition = function(options) {
          var _a2;
          return ((_a2 = options === null || options === void 0 ? void 0 : options.position) === null || _a2 === void 0 ? void 0 : _a2.y) || "bottom";
        };
        NotyfView2.prototype.adjustContainerAlignment = function(options) {
          var align = this.X_POSITION_FLEX_MAP[this.getXPosition(options)];
          var justify = this.Y_POSITION_FLEX_MAP[this.getYPosition(options)];
          var style = this.container.style;
          style.setProperty("justify-content", justify);
          style.setProperty("align-items", align);
        };
        NotyfView2.prototype._buildNotificationCard = function(notification) {
          var _this = this;
          var options = notification.options;
          var iconOpts = options.icon;
          this.adjustContainerAlignment(options);
          var notificationElem = this._createHTMLElement({ tagName: "div", className: "notyf__toast" });
          var ripple = this._createHTMLElement({ tagName: "div", className: "notyf__ripple" });
          var wrapper = this._createHTMLElement({ tagName: "div", className: "notyf__wrapper" });
          var message = this._createHTMLElement({ tagName: "div", className: "notyf__message" });
          message.innerHTML = options.message || "";
          var mainColor = options.background || options.backgroundColor;
          if (iconOpts) {
            var iconContainer = this._createHTMLElement({ tagName: "div", className: "notyf__icon" });
            if (typeof iconOpts === "string" || iconOpts instanceof String)
              iconContainer.innerHTML = new String(iconOpts).valueOf();
            if (typeof iconOpts === "object") {
              var _a2 = iconOpts.tagName, tagName = _a2 === void 0 ? "i" : _a2, className_1 = iconOpts.className, text2 = iconOpts.text, _b = iconOpts.color, color = _b === void 0 ? mainColor : _b;
              var iconElement = this._createHTMLElement({ tagName, className: className_1, text: text2 });
              if (color)
                iconElement.style.color = color;
              iconContainer.appendChild(iconElement);
            }
            wrapper.appendChild(iconContainer);
          }
          wrapper.appendChild(message);
          notificationElem.appendChild(wrapper);
          if (mainColor) {
            if (options.ripple) {
              ripple.style.background = mainColor;
              notificationElem.appendChild(ripple);
            } else {
              notificationElem.style.background = mainColor;
            }
          }
          if (options.dismissible) {
            var dismissWrapper = this._createHTMLElement({ tagName: "div", className: "notyf__dismiss" });
            var dismissButton = this._createHTMLElement({
              tagName: "button",
              className: "notyf__dismiss-btn"
            });
            dismissWrapper.appendChild(dismissButton);
            wrapper.appendChild(dismissWrapper);
            notificationElem.classList.add("notyf__toast--dismissible");
            dismissButton.addEventListener("click", function(event) {
              var _a3, _b2;
              (_b2 = (_a3 = _this.events)[NotyfEvent.Dismiss]) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, { target: notification, event });
              event.stopPropagation();
            });
          }
          notificationElem.addEventListener("click", function(event) {
            var _a3, _b2;
            return (_b2 = (_a3 = _this.events)[NotyfEvent.Click]) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, { target: notification, event });
          });
          var className = this.getYPosition(options) === "top" ? "upper" : "lower";
          notificationElem.classList.add("notyf__toast--" + className);
          return notificationElem;
        };
        NotyfView2.prototype._createHTMLElement = function(_a2) {
          var tagName = _a2.tagName, className = _a2.className, text2 = _a2.text;
          var elem = document.createElement(tagName);
          if (className) {
            elem.className = className;
          }
          elem.textContent = text2 || null;
          return elem;
        };
        NotyfView2.prototype._createA11yContainer = function() {
          var a11yContainer = this._createHTMLElement({ tagName: "div", className: "notyf-announcer" });
          a11yContainer.setAttribute("aria-atomic", "true");
          a11yContainer.setAttribute("aria-live", "polite");
          a11yContainer.style.border = "0";
          a11yContainer.style.clip = "rect(0 0 0 0)";
          a11yContainer.style.height = "1px";
          a11yContainer.style.margin = "-1px";
          a11yContainer.style.overflow = "hidden";
          a11yContainer.style.padding = "0";
          a11yContainer.style.position = "absolute";
          a11yContainer.style.width = "1px";
          a11yContainer.style.outline = "0";
          document.body.appendChild(a11yContainer);
          this.a11yContainer = a11yContainer;
        };
        NotyfView2.prototype._announce = function(message) {
          var _this = this;
          this.a11yContainer.textContent = "";
          setTimeout(function() {
            _this.a11yContainer.textContent = message;
          }, 100);
        };
        NotyfView2.prototype._getAnimationEndEventName = function() {
          var el2 = document.createElement("_fake");
          var transitions = {
            MozTransition: "animationend",
            OTransition: "oAnimationEnd",
            WebkitTransition: "webkitAnimationEnd",
            transition: "animationend"
          };
          var t;
          for (t in transitions) {
            if (el2.style[t] !== void 0) {
              return transitions[t];
            }
          }
          return "animationend";
        };
        return NotyfView2;
      }()
    );
    var Notyf = (
      /** @class */
      function() {
        function Notyf2(opts) {
          var _this = this;
          this.dismiss = this._removeNotification;
          this.notifications = new NotyfArray();
          this.view = new NotyfView();
          var types2 = this.registerTypes(opts);
          this.options = __assign(__assign({}, DEFAULT_OPTIONS), opts);
          this.options.types = types2;
          this.notifications.onUpdate(function(elem, type2) {
            return _this.view.update(elem, type2);
          });
          this.view.on(NotyfEvent.Dismiss, function(_a2) {
            var target2 = _a2.target, event = _a2.event;
            _this._removeNotification(target2);
            target2["triggerEvent"](NotyfEvent.Dismiss, event);
          });
          this.view.on(NotyfEvent.Click, function(_a2) {
            var target2 = _a2.target, event = _a2.event;
            return target2["triggerEvent"](NotyfEvent.Click, event);
          });
        }
        Notyf2.prototype.error = function(payload) {
          var options = this.normalizeOptions("error", payload);
          return this.open(options);
        };
        Notyf2.prototype.success = function(payload) {
          var options = this.normalizeOptions("success", payload);
          return this.open(options);
        };
        Notyf2.prototype.open = function(options) {
          var defaultOpts = this.options.types.find(function(_a2) {
            var type2 = _a2.type;
            return type2 === options.type;
          }) || {};
          var config2 = __assign(__assign({}, defaultOpts), options);
          this.assignProps(["ripple", "position", "dismissible"], config2);
          var notification = new NotyfNotification(config2);
          this._pushNotification(notification);
          return notification;
        };
        Notyf2.prototype.dismissAll = function() {
          while (this.notifications.splice(0, 1))
            ;
        };
        Notyf2.prototype.assignProps = function(props, config2) {
          var _this = this;
          props.forEach(function(prop2) {
            config2[prop2] = config2[prop2] == null ? _this.options[prop2] : config2[prop2];
          });
        };
        Notyf2.prototype._pushNotification = function(notification) {
          var _this = this;
          this.notifications.push(notification);
          var duration = notification.options.duration !== void 0 ? notification.options.duration : this.options.duration;
          if (duration) {
            setTimeout(function() {
              return _this._removeNotification(notification);
            }, duration);
          }
        };
        Notyf2.prototype._removeNotification = function(notification) {
          var index = this.notifications.indexOf(notification);
          if (index !== -1) {
            this.notifications.splice(index, 1);
          }
        };
        Notyf2.prototype.normalizeOptions = function(type2, payload) {
          var options = { type: type2 };
          if (typeof payload === "string") {
            options.message = payload;
          } else if (typeof payload === "object") {
            options = __assign(__assign({}, options), payload);
          }
          return options;
        };
        Notyf2.prototype.registerTypes = function(opts) {
          var incomingTypes = (opts && opts.types || []).slice();
          var finalDefaultTypes = DEFAULT_OPTIONS.types.map(function(defaultType) {
            var userTypeIdx = -1;
            incomingTypes.forEach(function(t, idx) {
              if (t.type === defaultType.type)
                userTypeIdx = idx;
            });
            var userType = userTypeIdx !== -1 ? incomingTypes.splice(userTypeIdx, 1)[0] : {};
            return __assign(__assign({}, defaultType), userType);
          });
          return finalDefaultTypes.concat(incomingTypes);
        };
        return Notyf2;
      }()
    );
    /**
    * @vue/shared v3.4.19
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    function makeMap(str, expectsLowerCase) {
      const set2 = new Set(str.split(","));
      return expectsLowerCase ? (val) => set2.has(val.toLowerCase()) : (val) => set2.has(val);
    }
    const EMPTY_OBJ = {};
    const EMPTY_ARR = [];
    const NOOP = () => {
    };
    const NO = () => false;
    const isOn$1 = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
    (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
    const isModelListener = (key) => key.startsWith("onUpdate:");
    const extend = Object.assign;
    const remove = (arr, el2) => {
      const i2 = arr.indexOf(el2);
      if (i2 > -1) {
        arr.splice(i2, 1);
      }
    };
    const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
    const isArray$1 = Array.isArray;
    const isMap$1 = (val) => toTypeString(val) === "[object Map]";
    const isSet$1 = (val) => toTypeString(val) === "[object Set]";
    const isFunction$1 = (val) => typeof val === "function";
    const isString$1 = (val) => typeof val === "string";
    const isSymbol = (val) => typeof val === "symbol";
    const isObject$3 = (val) => val !== null && typeof val === "object";
    const isPromise = (val) => {
      return (isObject$3(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
    };
    const objectToString = Object.prototype.toString;
    const toTypeString = (value) => objectToString.call(value);
    const toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    const isPlainObject$3 = (val) => toTypeString(val) === "[object Object]";
    const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
    const isReservedProp = /* @__PURE__ */ makeMap(
      // the leading comma is intentional so empty string "" is also included
      ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    );
    const cacheStringFunction = (fn) => {
      const cache = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
      };
    };
    const camelizeRE = /-(\w)/g;
    const camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
    });
    const hyphenateRE = /\B([A-Z])/g;
    const hyphenate = cacheStringFunction(
      (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
    );
    const capitalize = cacheStringFunction((str) => {
      return str.charAt(0).toUpperCase() + str.slice(1);
    });
    const toHandlerKey = cacheStringFunction((str) => {
      const s = str ? `on${capitalize(str)}` : ``;
      return s;
    });
    const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    const invokeArrayFns = (fns, arg) => {
      for (let i2 = 0; i2 < fns.length; i2++) {
        fns[i2](arg);
      }
    };
    const def$C = (obj, key, value) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
      });
    };
    const looseToNumber = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    };
    const toNumber$1 = (val) => {
      const n = isString$1(val) ? Number(val) : NaN;
      return isNaN(n) ? val : n;
    };
    let _globalThis;
    const getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    function normalizeStyle(value) {
      if (isArray$1(value)) {
        const res = {};
        for (let i2 = 0; i2 < value.length; i2++) {
          const item = value[i2];
          const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isString$1(value) || isObject$3(value)) {
        return value;
      }
    }
    const listDelimiterRE = /;(?![^(]*\))/g;
    const propertyDelimiterRE = /:([^]+)/;
    const styleCommentRE = /\/\*[^]*?\*\//g;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString$1(value)) {
        res = value;
      } else if (isArray$1(value)) {
        for (let i2 = 0; i2 < value.length; i2++) {
          const normalized = normalizeClass(value[i2]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject$3(value)) {
        for (const name in value) {
          if (value[name]) {
            res += name + " ";
          }
        }
      }
      return res.trim();
    }
    function normalizeProps(props) {
      if (!props)
        return null;
      let { class: klass, style } = props;
      if (klass && !isString$1(klass)) {
        props.class = normalizeClass(klass);
      }
      if (style) {
        props.style = normalizeStyle(style);
      }
      return props;
    }
    const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    const toDisplayString = (val) => {
      return isString$1(val) ? val : val == null ? "" : isArray$1(val) || isObject$3(val) && (val.toString === objectToString || !isFunction$1(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
    };
    const replacer = (_key, val) => {
      if (val && val.__v_isRef) {
        return replacer(_key, val.value);
      } else if (isMap$1(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce(
            (entries, [key, val2], i2) => {
              entries[stringifySymbol(key, i2) + " =>"] = val2;
              return entries;
            },
            {}
          )
        };
      } else if (isSet$1(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
        };
      } else if (isSymbol(val)) {
        return stringifySymbol(val);
      } else if (isObject$3(val) && !isArray$1(val) && !isPlainObject$3(val)) {
        return String(val);
      }
      return val;
    };
    const stringifySymbol = (v, i2 = "") => {
      var _a2;
      return isSymbol(v) ? `Symbol(${(_a2 = v.description) != null ? _a2 : i2})` : v;
    };
    /**
    * @vue/reactivity v3.4.19
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    let activeEffectScope;
    class EffectScope {
      constructor(detached = false) {
        this.detached = detached;
        this._active = true;
        this.effects = [];
        this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
          this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
            this
          ) - 1;
        }
      }
      get active() {
        return this._active;
      }
      run(fn) {
        if (this._active) {
          const currentEffectScope = activeEffectScope;
          try {
            activeEffectScope = this;
            return fn();
          } finally {
            activeEffectScope = currentEffectScope;
          }
        }
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      on() {
        activeEffectScope = this;
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      off() {
        activeEffectScope = this.parent;
      }
      stop(fromParent) {
        if (this._active) {
          let i2, l;
          for (i2 = 0, l = this.effects.length; i2 < l; i2++) {
            this.effects[i2].stop();
          }
          for (i2 = 0, l = this.cleanups.length; i2 < l; i2++) {
            this.cleanups[i2]();
          }
          if (this.scopes) {
            for (i2 = 0, l = this.scopes.length; i2 < l; i2++) {
              this.scopes[i2].stop(true);
            }
          }
          if (!this.detached && this.parent && !fromParent) {
            const last = this.parent.scopes.pop();
            if (last && last !== this) {
              this.parent.scopes[this.index] = last;
              last.index = this.index;
            }
          }
          this.parent = void 0;
          this._active = false;
        }
      }
    }
    function effectScope(detached) {
      return new EffectScope(detached);
    }
    function recordEffectScope(effect2, scope2 = activeEffectScope) {
      if (scope2 && scope2.active) {
        scope2.effects.push(effect2);
      }
    }
    function getCurrentScope$1() {
      return activeEffectScope;
    }
    function onScopeDispose(fn) {
      if (activeEffectScope) {
        activeEffectScope.cleanups.push(fn);
      }
    }
    let activeEffect;
    class ReactiveEffect {
      constructor(fn, trigger2, scheduler, scope2) {
        this.fn = fn;
        this.trigger = trigger2;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        this._dirtyLevel = 4;
        this._trackId = 0;
        this._runnings = 0;
        this._shouldSchedule = false;
        this._depsLength = 0;
        recordEffectScope(this, scope2);
      }
      get dirty() {
        if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
          this._dirtyLevel = 1;
          pauseTracking();
          for (let i2 = 0; i2 < this._depsLength; i2++) {
            const dep = this.deps[i2];
            if (dep.computed) {
              triggerComputed(dep.computed);
              if (this._dirtyLevel >= 4) {
                break;
              }
            }
          }
          if (this._dirtyLevel === 1) {
            this._dirtyLevel = 0;
          }
          resetTracking();
        }
        return this._dirtyLevel >= 4;
      }
      set dirty(v) {
        this._dirtyLevel = v ? 4 : 0;
      }
      run() {
        this._dirtyLevel = 0;
        if (!this.active) {
          return this.fn();
        }
        let lastShouldTrack = shouldTrack;
        let lastEffect = activeEffect;
        try {
          shouldTrack = true;
          activeEffect = this;
          this._runnings++;
          preCleanupEffect(this);
          return this.fn();
        } finally {
          postCleanupEffect(this);
          this._runnings--;
          activeEffect = lastEffect;
          shouldTrack = lastShouldTrack;
        }
      }
      stop() {
        var _a2;
        if (this.active) {
          preCleanupEffect(this);
          postCleanupEffect(this);
          (_a2 = this.onStop) == null ? void 0 : _a2.call(this);
          this.active = false;
        }
      }
    }
    function triggerComputed(computed2) {
      return computed2.value;
    }
    function preCleanupEffect(effect2) {
      effect2._trackId++;
      effect2._depsLength = 0;
    }
    function postCleanupEffect(effect2) {
      if (effect2.deps.length > effect2._depsLength) {
        for (let i2 = effect2._depsLength; i2 < effect2.deps.length; i2++) {
          cleanupDepEffect(effect2.deps[i2], effect2);
        }
        effect2.deps.length = effect2._depsLength;
      }
    }
    function cleanupDepEffect(dep, effect2) {
      const trackId = dep.get(effect2);
      if (trackId !== void 0 && effect2._trackId !== trackId) {
        dep.delete(effect2);
        if (dep.size === 0) {
          dep.cleanup();
        }
      }
    }
    let shouldTrack = true;
    let pauseScheduleStack = 0;
    const trackStack = [];
    function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
    }
    function resetTracking() {
      const last = trackStack.pop();
      shouldTrack = last === void 0 ? true : last;
    }
    function pauseScheduling() {
      pauseScheduleStack++;
    }
    function resetScheduling() {
      pauseScheduleStack--;
      while (!pauseScheduleStack && queueEffectSchedulers.length) {
        queueEffectSchedulers.shift()();
      }
    }
    function trackEffect(effect2, dep, debuggerEventExtraInfo) {
      if (dep.get(effect2) !== effect2._trackId) {
        dep.set(effect2, effect2._trackId);
        const oldDep = effect2.deps[effect2._depsLength];
        if (oldDep !== dep) {
          if (oldDep) {
            cleanupDepEffect(oldDep, effect2);
          }
          effect2.deps[effect2._depsLength++] = dep;
        } else {
          effect2._depsLength++;
        }
      }
    }
    const queueEffectSchedulers = [];
    function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
      pauseScheduling();
      for (const effect2 of dep.keys()) {
        let tracking;
        if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
          effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
          effect2._dirtyLevel = dirtyLevel;
        }
        if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
          effect2.trigger();
          if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
            effect2._shouldSchedule = false;
            if (effect2.scheduler) {
              queueEffectSchedulers.push(effect2.scheduler);
            }
          }
        }
      }
      resetScheduling();
    }
    const createDep = (cleanup, computed2) => {
      const dep = /* @__PURE__ */ new Map();
      dep.cleanup = cleanup;
      dep.computed = computed2;
      return dep;
    };
    const targetMap = /* @__PURE__ */ new WeakMap();
    const ITERATE_KEY = Symbol("");
    const MAP_KEY_ITERATE_KEY = Symbol("");
    function track(target2, type2, key) {
      if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target2);
        if (!depsMap) {
          targetMap.set(target2, depsMap = /* @__PURE__ */ new Map());
        }
        let dep = depsMap.get(key);
        if (!dep) {
          depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
        }
        trackEffect(
          activeEffect,
          dep
        );
      }
    }
    function trigger(target2, type2, key, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target2);
      if (!depsMap) {
        return;
      }
      let deps = [];
      if (type2 === "clear") {
        deps = [...depsMap.values()];
      } else if (key === "length" && isArray$1(target2)) {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || !isSymbol(key2) && key2 >= newLength) {
            deps.push(dep);
          }
        });
      } else {
        if (key !== void 0) {
          deps.push(depsMap.get(key));
        }
        switch (type2) {
          case "add":
            if (!isArray$1(target2)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap$1(target2)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isIntegerKey(key)) {
              deps.push(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!isArray$1(target2)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap$1(target2)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap$1(target2)) {
              deps.push(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
      pauseScheduling();
      for (const dep of deps) {
        if (dep) {
          triggerEffects(
            dep,
            4
          );
        }
      }
      resetScheduling();
    }
    function getDepFromReactive(object, key) {
      var _a2;
      return (_a2 = targetMap.get(object)) == null ? void 0 : _a2.get(key);
    }
    const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
    const builtInSymbols = new Set(
      /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
    );
    const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
    function createArrayInstrumentations() {
      const instrumentations = {};
      ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
        instrumentations[key] = function(...args) {
          const arr = toRaw(this);
          for (let i2 = 0, l = this.length; i2 < l; i2++) {
            track(arr, "get", i2 + "");
          }
          const res = arr[key](...args);
          if (res === -1 || res === false) {
            return arr[key](...args.map(toRaw));
          } else {
            return res;
          }
        };
      });
      ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
        instrumentations[key] = function(...args) {
          pauseTracking();
          pauseScheduling();
          const res = toRaw(this)[key].apply(this, args);
          resetScheduling();
          resetTracking();
          return res;
        };
      });
      return instrumentations;
    }
    function hasOwnProperty(key) {
      const obj = toRaw(this);
      track(obj, "has", key);
      return obj.hasOwnProperty(key);
    }
    class BaseReactiveHandler {
      constructor(_isReadonly = false, _shallow = false) {
        this._isReadonly = _isReadonly;
        this._shallow = _shallow;
      }
      get(target2, key, receiver) {
        const isReadonly2 = this._isReadonly, shallow = this._shallow;
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_isShallow") {
          return shallow;
        } else if (key === "__v_raw") {
          if (receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target2) || // receiver is not the reactive proxy, but has the same prototype
          // this means the reciever is a user proxy of the reactive proxy
          Object.getPrototypeOf(target2) === Object.getPrototypeOf(receiver)) {
            return target2;
          }
          return;
        }
        const targetIsArray = isArray$1(target2);
        if (!isReadonly2) {
          if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
            return Reflect.get(arrayInstrumentations, key, receiver);
          }
          if (key === "hasOwnProperty") {
            return hasOwnProperty;
          }
        }
        const res = Reflect.get(target2, key, receiver);
        if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
          return res;
        }
        if (!isReadonly2) {
          track(target2, "get", key);
        }
        if (shallow) {
          return res;
        }
        if (isRef(res)) {
          return targetIsArray && isIntegerKey(key) ? res : res.value;
        }
        if (isObject$3(res)) {
          return isReadonly2 ? readonly(res) : reactive(res);
        }
        return res;
      }
    }
    class MutableReactiveHandler extends BaseReactiveHandler {
      constructor(shallow = false) {
        super(false, shallow);
      }
      set(target2, key, value, receiver) {
        let oldValue = target2[key];
        if (!this._shallow) {
          const isOldValueReadonly = isReadonly(oldValue);
          if (!isShallow(value) && !isReadonly(value)) {
            oldValue = toRaw(oldValue);
            value = toRaw(value);
          }
          if (!isArray$1(target2) && isRef(oldValue) && !isRef(value)) {
            if (isOldValueReadonly) {
              return false;
            } else {
              oldValue.value = value;
              return true;
            }
          }
        }
        const hadKey = isArray$1(target2) && isIntegerKey(key) ? Number(key) < target2.length : hasOwn(target2, key);
        const result = Reflect.set(target2, key, value, receiver);
        if (target2 === toRaw(receiver)) {
          if (!hadKey) {
            trigger(target2, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger(target2, "set", key, value);
          }
        }
        return result;
      }
      deleteProperty(target2, key) {
        const hadKey = hasOwn(target2, key);
        target2[key];
        const result = Reflect.deleteProperty(target2, key);
        if (result && hadKey) {
          trigger(target2, "delete", key, void 0);
        }
        return result;
      }
      has(target2, key) {
        const result = Reflect.has(target2, key);
        if (!isSymbol(key) || !builtInSymbols.has(key)) {
          track(target2, "has", key);
        }
        return result;
      }
      ownKeys(target2) {
        track(
          target2,
          "iterate",
          isArray$1(target2) ? "length" : ITERATE_KEY
        );
        return Reflect.ownKeys(target2);
      }
    }
    class ReadonlyReactiveHandler extends BaseReactiveHandler {
      constructor(shallow = false) {
        super(true, shallow);
      }
      set(target2, key) {
        return true;
      }
      deleteProperty(target2, key) {
        return true;
      }
    }
    const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
    const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
    const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
      true
    );
    const toShallow = (value) => value;
    const getProto = (v) => Reflect.getPrototypeOf(v);
    function get(target2, key, isReadonly2 = false, isShallow2 = false) {
      target2 = target2["__v_raw"];
      const rawTarget = toRaw(target2);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has: has2 } = getProto(rawTarget);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      if (has2.call(rawTarget, key)) {
        return wrap(target2.get(key));
      } else if (has2.call(rawTarget, rawKey)) {
        return wrap(target2.get(rawKey));
      } else if (target2 !== rawTarget) {
        target2.get(key);
      }
    }
    function has$3(key, isReadonly2 = false) {
      const target2 = this["__v_raw"];
      const rawTarget = toRaw(target2);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target2.has(key) : target2.has(key) || target2.has(rawKey);
    }
    function size(target2, isReadonly2 = false) {
      target2 = target2["__v_raw"];
      !isReadonly2 && track(toRaw(target2), "iterate", ITERATE_KEY);
      return Reflect.get(target2, "size", target2);
    }
    function add(value) {
      value = toRaw(value);
      const target2 = toRaw(this);
      const proto = getProto(target2);
      const hadKey = proto.has.call(target2, value);
      if (!hadKey) {
        target2.add(value);
        trigger(target2, "add", value, value);
      }
      return this;
    }
    function set$2(key, value) {
      value = toRaw(value);
      const target2 = toRaw(this);
      const { has: has2, get: get2 } = getProto(target2);
      let hadKey = has2.call(target2, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target2, key);
      }
      const oldValue = get2.call(target2, key);
      target2.set(key, value);
      if (!hadKey) {
        trigger(target2, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target2, "set", key, value);
      }
      return this;
    }
    function deleteEntry(key) {
      const target2 = toRaw(this);
      const { has: has2, get: get2 } = getProto(target2);
      let hadKey = has2.call(target2, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target2, key);
      }
      get2 ? get2.call(target2, key) : void 0;
      const result = target2.delete(key);
      if (hadKey) {
        trigger(target2, "delete", key, void 0);
      }
      return result;
    }
    function clear() {
      const target2 = toRaw(this);
      const hadItems = target2.size !== 0;
      const result = target2.clear();
      if (hadItems) {
        trigger(target2, "clear", void 0, void 0);
      }
      return result;
    }
    function createForEach(isReadonly2, isShallow2) {
      return function forEach(callback, thisArg) {
        const observed = this;
        const target2 = observed["__v_raw"];
        const rawTarget = toRaw(target2);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target2.forEach((value, key) => {
          return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
      };
    }
    function createIterableMethod(method, isReadonly2, isShallow2) {
      return function(...args) {
        const target2 = this["__v_raw"];
        const rawTarget = toRaw(target2);
        const targetIsMap = isMap$1(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target2[method](...args);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(
          rawTarget,
          "iterate",
          isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
        );
        return {
          // iterator protocol
          next() {
            const { value, done } = innerIterator.next();
            return done ? { value, done } : {
              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
              done
            };
          },
          // iterable protocol
          [Symbol.iterator]() {
            return this;
          }
        };
      };
    }
    function createReadonlyMethod(type2) {
      return function(...args) {
        return type2 === "delete" ? false : type2 === "clear" ? void 0 : this;
      };
    }
    function createInstrumentations() {
      const mutableInstrumentations2 = {
        get(key) {
          return get(this, key);
        },
        get size() {
          return size(this);
        },
        has: has$3,
        add,
        set: set$2,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
      };
      const shallowInstrumentations2 = {
        get(key) {
          return get(this, key, false, true);
        },
        get size() {
          return size(this);
        },
        has: has$3,
        add,
        set: set$2,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
      };
      const readonlyInstrumentations2 = {
        get(key) {
          return get(this, key, true);
        },
        get size() {
          return size(this, true);
        },
        has(key) {
          return has$3.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, false)
      };
      const shallowReadonlyInstrumentations2 = {
        get(key) {
          return get(this, key, true, true);
        },
        get size() {
          return size(this, true);
        },
        has(key) {
          return has$3.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, true)
      };
      const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
      iteratorMethods.forEach((method) => {
        mutableInstrumentations2[method] = createIterableMethod(
          method,
          false,
          false
        );
        readonlyInstrumentations2[method] = createIterableMethod(
          method,
          true,
          false
        );
        shallowInstrumentations2[method] = createIterableMethod(
          method,
          false,
          true
        );
        shallowReadonlyInstrumentations2[method] = createIterableMethod(
          method,
          true,
          true
        );
      });
      return [
        mutableInstrumentations2,
        readonlyInstrumentations2,
        shallowInstrumentations2,
        shallowReadonlyInstrumentations2
      ];
    }
    const [
      mutableInstrumentations,
      readonlyInstrumentations,
      shallowInstrumentations,
      shallowReadonlyInstrumentations
    ] = /* @__PURE__ */ createInstrumentations();
    function createInstrumentationGetter(isReadonly2, shallow) {
      const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
      return (target2, key, receiver) => {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_raw") {
          return target2;
        }
        return Reflect.get(
          hasOwn(instrumentations, key) && key in target2 ? instrumentations : target2,
          key,
          receiver
        );
      };
    }
    const mutableCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, false)
    };
    const shallowCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, true)
    };
    const readonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, false)
    };
    const reactiveMap = /* @__PURE__ */ new WeakMap();
    const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
    const readonlyMap = /* @__PURE__ */ new WeakMap();
    const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
    function targetTypeMap(rawType) {
      switch (rawType) {
        case "Object":
        case "Array":
          return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
          return 2;
        default:
          return 0;
      }
    }
    function getTargetType(value) {
      return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
    }
    function reactive(target2) {
      if (isReadonly(target2)) {
        return target2;
      }
      return createReactiveObject(
        target2,
        false,
        mutableHandlers,
        mutableCollectionHandlers,
        reactiveMap
      );
    }
    function shallowReactive(target2) {
      return createReactiveObject(
        target2,
        false,
        shallowReactiveHandlers,
        shallowCollectionHandlers,
        shallowReactiveMap
      );
    }
    function readonly(target2) {
      return createReactiveObject(
        target2,
        true,
        readonlyHandlers,
        readonlyCollectionHandlers,
        readonlyMap
      );
    }
    function createReactiveObject(target2, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
      if (!isObject$3(target2)) {
        return target2;
      }
      if (target2["__v_raw"] && !(isReadonly2 && target2["__v_isReactive"])) {
        return target2;
      }
      const existingProxy = proxyMap.get(target2);
      if (existingProxy) {
        return existingProxy;
      }
      const targetType = getTargetType(target2);
      if (targetType === 0) {
        return target2;
      }
      const proxy = new Proxy(
        target2,
        targetType === 2 ? collectionHandlers : baseHandlers
      );
      proxyMap.set(target2, proxy);
      return proxy;
    }
    function isReactive(value) {
      if (isReadonly(value)) {
        return isReactive(value["__v_raw"]);
      }
      return !!(value && value["__v_isReactive"]);
    }
    function isReadonly(value) {
      return !!(value && value["__v_isReadonly"]);
    }
    function isShallow(value) {
      return !!(value && value["__v_isShallow"]);
    }
    function isProxy(value) {
      return isReactive(value) || isReadonly(value);
    }
    function toRaw(observed) {
      const raw = observed && observed["__v_raw"];
      return raw ? toRaw(raw) : observed;
    }
    function markRaw(value) {
      if (Object.isExtensible(value)) {
        def$C(value, "__v_skip", true);
      }
      return value;
    }
    const toReactive = (value) => isObject$3(value) ? reactive(value) : value;
    const toReadonly = (value) => isObject$3(value) ? readonly(value) : value;
    class ComputedRefImpl {
      constructor(getter, _setter, isReadonly2, isSSR) {
        this._setter = _setter;
        this.dep = void 0;
        this.__v_isRef = true;
        this["__v_isReadonly"] = false;
        this.effect = new ReactiveEffect(
          () => getter(this._value),
          () => triggerRefValue(
            this,
            this.effect._dirtyLevel === 2 ? 2 : 3
          )
        );
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly"] = isReadonly2;
      }
      get value() {
        const self2 = toRaw(this);
        if ((!self2._cacheable || self2.effect.dirty) && hasChanged(self2._value, self2._value = self2.effect.run())) {
          triggerRefValue(self2, 4);
        }
        trackRefValue(self2);
        if (self2.effect._dirtyLevel >= 2) {
          triggerRefValue(self2, 2);
        }
        return self2._value;
      }
      set value(newValue) {
        this._setter(newValue);
      }
      // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
      get _dirty() {
        return this.effect.dirty;
      }
      set _dirty(v) {
        this.effect.dirty = v;
      }
      // #endregion
    }
    function computed$1(getterOrOptions, debugOptions, isSSR = false) {
      let getter;
      let setter;
      const onlyGetter = isFunction$1(getterOrOptions);
      if (onlyGetter) {
        getter = getterOrOptions;
        setter = NOOP;
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
      return cRef;
    }
    function trackRefValue(ref2) {
      var _a2;
      if (shouldTrack && activeEffect) {
        ref2 = toRaw(ref2);
        trackEffect(
          activeEffect,
          (_a2 = ref2.dep) != null ? _a2 : ref2.dep = createDep(
            () => ref2.dep = void 0,
            ref2 instanceof ComputedRefImpl ? ref2 : void 0
          )
        );
      }
    }
    function triggerRefValue(ref2, dirtyLevel = 4, newVal) {
      ref2 = toRaw(ref2);
      const dep = ref2.dep;
      if (dep) {
        triggerEffects(
          dep,
          dirtyLevel
        );
      }
    }
    function isRef(r) {
      return !!(r && r.__v_isRef === true);
    }
    function ref$1(value) {
      return createRef(value, false);
    }
    function shallowRef(value) {
      return createRef(value, true);
    }
    function createRef(rawValue, shallow) {
      if (isRef(rawValue)) {
        return rawValue;
      }
      return new RefImpl(rawValue, shallow);
    }
    class RefImpl {
      constructor(value, __v_isShallow) {
        this.__v_isShallow = __v_isShallow;
        this.dep = void 0;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
      }
      get value() {
        trackRefValue(this);
        return this._value;
      }
      set value(newVal) {
        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
        newVal = useDirectValue ? newVal : toRaw(newVal);
        if (hasChanged(newVal, this._rawValue)) {
          this._rawValue = newVal;
          this._value = useDirectValue ? newVal : toReactive(newVal);
          triggerRefValue(this, 4);
        }
      }
    }
    function unref(ref2) {
      return isRef(ref2) ? ref2.value : ref2;
    }
    function toValue$1(source) {
      return isFunction$1(source) ? source() : unref(source);
    }
    const shallowUnwrapHandlers = {
      get: (target2, key, receiver) => unref(Reflect.get(target2, key, receiver)),
      set: (target2, key, value, receiver) => {
        const oldValue = target2[key];
        if (isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target2, key, value, receiver);
        }
      }
    };
    function proxyRefs(objectWithRefs) {
      return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
    }
    function toRefs(object) {
      const ret = isArray$1(object) ? new Array(object.length) : {};
      for (const key in object) {
        ret[key] = propertyToRef(object, key);
      }
      return ret;
    }
    class ObjectRefImpl {
      constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
      }
      get value() {
        const val = this._object[this._key];
        return val === void 0 ? this._defaultValue : val;
      }
      set value(newVal) {
        this._object[this._key] = newVal;
      }
      get dep() {
        return getDepFromReactive(toRaw(this._object), this._key);
      }
    }
    class GetterRefImpl {
      constructor(_getter) {
        this._getter = _getter;
        this.__v_isRef = true;
        this.__v_isReadonly = true;
      }
      get value() {
        return this._getter();
      }
    }
    function toRef(source, key, defaultValue) {
      if (isRef(source)) {
        return source;
      } else if (isFunction$1(source)) {
        return new GetterRefImpl(source);
      } else if (isObject$3(source) && arguments.length > 1) {
        return propertyToRef(source, key, defaultValue);
      } else {
        return ref$1(source);
      }
    }
    function propertyToRef(source, key, defaultValue) {
      const val = source[key];
      return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
    }
    /**
    * @vue/runtime-core v3.4.19
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    const stack = [];
    function warn$1(msg, ...args) {
      pauseTracking();
      const instance = stack.length ? stack[stack.length - 1].component : null;
      const appWarnHandler = instance && instance.appContext.config.warnHandler;
      const trace = getComponentTrace();
      if (appWarnHandler) {
        callWithErrorHandling(
          appWarnHandler,
          instance,
          11,
          [
            msg + args.join(""),
            instance && instance.proxy,
            trace.map(
              ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
            ).join("\n"),
            trace
          ]
        );
      } else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        if (trace.length && // avoid spamming console during tests
        true) {
          warnArgs.push(`
`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
      }
      resetTracking();
    }
    function getComponentTrace() {
      let currentVNode = stack[stack.length - 1];
      if (!currentVNode) {
        return [];
      }
      const normalizedStack = [];
      while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
          last.recurseCount++;
        } else {
          normalizedStack.push({
            vnode: currentVNode,
            recurseCount: 0
          });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
      }
      return normalizedStack;
    }
    function formatTrace(trace) {
      const logs = [];
      trace.forEach((entry, i2) => {
        logs.push(...i2 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
      });
      return logs;
    }
    function formatTraceEntry({ vnode, recurseCount }) {
      const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
      const isRoot = vnode.component ? vnode.component.parent == null : false;
      const open = ` at <${formatComponentName(
        vnode.component,
        vnode.type,
        isRoot
      )}`;
      const close = `>` + postfix;
      return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
    }
    function formatProps(props) {
      const res = [];
      const keys2 = Object.keys(props);
      keys2.slice(0, 3).forEach((key) => {
        res.push(...formatProp(key, props[key]));
      });
      if (keys2.length > 3) {
        res.push(` ...`);
      }
      return res;
    }
    function formatProp(key, value, raw) {
      if (isString$1(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
      } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
        return raw ? value : [`${key}=${value}`];
      } else if (isRef(value)) {
        value = formatProp(key, toRaw(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
      } else if (isFunction$1(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
      } else {
        value = toRaw(value);
        return raw ? value : [`${key}=`, value];
      }
    }
    function callWithErrorHandling(fn, instance, type2, args) {
      try {
        return args ? fn(...args) : fn();
      } catch (err) {
        handleError(err, instance, type2);
      }
    }
    function callWithAsyncErrorHandling(fn, instance, type2, args) {
      if (isFunction$1(fn)) {
        const res = callWithErrorHandling(fn, instance, type2, args);
        if (res && isPromise(res)) {
          res.catch((err) => {
            handleError(err, instance, type2);
          });
        }
        return res;
      }
      const values = [];
      for (let i2 = 0; i2 < fn.length; i2++) {
        values.push(callWithAsyncErrorHandling(fn[i2], instance, type2, args));
      }
      return values;
    }
    function handleError(err, instance, type2, throwInDev = true) {
      const contextVNode = instance ? instance.vnode : null;
      if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = `https://vuejs.org/error-reference/#runtime-${type2}`;
        while (cur) {
          const errorCapturedHooks = cur.ec;
          if (errorCapturedHooks) {
            for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
              if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
                return;
              }
            }
          }
          cur = cur.parent;
        }
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
          callWithErrorHandling(
            appErrorHandler,
            null,
            10,
            [err, exposedInstance, errorInfo]
          );
          return;
        }
      }
      logError(err, type2, contextVNode, throwInDev);
    }
    function logError(err, type2, contextVNode, throwInDev = true) {
      {
        console.error(err);
      }
    }
    let isFlushing = false;
    let isFlushPending = false;
    const queue = [];
    let flushIndex = 0;
    const pendingPostFlushCbs = [];
    let activePostFlushCbs = null;
    let postFlushIndex = 0;
    const resolvedPromise = /* @__PURE__ */ Promise.resolve();
    let currentFlushPromise = null;
    function nextTick(fn) {
      const p2 = currentFlushPromise || resolvedPromise;
      return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
    }
    function findInsertionIndex(id2) {
      let start = flushIndex + 1;
      let end = queue.length;
      while (start < end) {
        const middle = start + end >>> 1;
        const middleJob = queue[middle];
        const middleJobId = getId(middleJob);
        if (middleJobId < id2 || middleJobId === id2 && middleJob.pre) {
          start = middle + 1;
        } else {
          end = middle;
        }
      }
      return start;
    }
    function queueJob(job) {
      if (!queue.length || !queue.includes(
        job,
        isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
      )) {
        if (job.id == null) {
          queue.push(job);
        } else {
          queue.splice(findInsertionIndex(job.id), 0, job);
        }
        queueFlush();
      }
    }
    function queueFlush() {
      if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
      }
    }
    function invalidateJob(job) {
      const i2 = queue.indexOf(job);
      if (i2 > flushIndex) {
        queue.splice(i2, 1);
      }
    }
    function queuePostFlushCb(cb) {
      if (!isArray$1(cb)) {
        if (!activePostFlushCbs || !activePostFlushCbs.includes(
          cb,
          cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
        )) {
          pendingPostFlushCbs.push(cb);
        }
      } else {
        pendingPostFlushCbs.push(...cb);
      }
      queueFlush();
    }
    function flushPreFlushCbs(instance, seen, i2 = isFlushing ? flushIndex + 1 : 0) {
      for (; i2 < queue.length; i2++) {
        const cb = queue[i2];
        if (cb && cb.pre) {
          if (instance && cb.id !== instance.uid) {
            continue;
          }
          queue.splice(i2, 1);
          i2--;
          cb();
        }
      }
    }
    function flushPostFlushCbs(seen) {
      if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)].sort(
          (a, b) => getId(a) - getId(b)
        );
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
          activePostFlushCbs.push(...deduped);
          return;
        }
        activePostFlushCbs = deduped;
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
          activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
      }
    }
    const getId = (job) => job.id == null ? Infinity : job.id;
    const comparator = (a, b) => {
      const diff = getId(a) - getId(b);
      if (diff === 0) {
        if (a.pre && !b.pre)
          return -1;
        if (b.pre && !a.pre)
          return 1;
      }
      return diff;
    };
    function flushJobs(seen) {
      isFlushPending = false;
      isFlushing = true;
      queue.sort(comparator);
      try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job && job.active !== false) {
            if (false)
              ;
            callWithErrorHandling(job, null, 14);
          }
        }
      } finally {
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs();
        isFlushing = false;
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) {
          flushJobs();
        }
      }
    }
    function emit(instance, event, ...rawArgs) {
      if (instance.isUnmounted)
        return;
      const props = instance.vnode.props || EMPTY_OBJ;
      let args = rawArgs;
      const isModelListener2 = event.startsWith("update:");
      const modelArg = isModelListener2 && event.slice(7);
      if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
        const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
        if (trim) {
          args = rawArgs.map((a) => isString$1(a) ? a.trim() : a);
        }
        if (number) {
          args = rawArgs.map(looseToNumber);
        }
      }
      let handlerName;
      let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
      props[handlerName = toHandlerKey(camelize(event))];
      if (!handler && isModelListener2) {
        handler = props[handlerName = toHandlerKey(hyphenate(event))];
      }
      if (handler) {
        callWithAsyncErrorHandling(
          handler,
          instance,
          6,
          args
        );
      }
      const onceHandler = props[handlerName + `Once`];
      if (onceHandler) {
        if (!instance.emitted) {
          instance.emitted = {};
        } else if (instance.emitted[handlerName]) {
          return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(
          onceHandler,
          instance,
          6,
          args
        );
      }
    }
    function normalizeEmitsOptions(comp2, appContext, asMixin = false) {
      const cache = appContext.emitsCache;
      const cached = cache.get(comp2);
      if (cached !== void 0) {
        return cached;
      }
      const raw = comp2.emits;
      let normalized = {};
      let hasExtends = false;
      if (!isFunction$1(comp2)) {
        const extendEmits = (raw2) => {
          const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
          if (normalizedFromExtend) {
            hasExtends = true;
            extend(normalized, normalizedFromExtend);
          }
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendEmits);
        }
        if (comp2.extends) {
          extendEmits(comp2.extends);
        }
        if (comp2.mixins) {
          comp2.mixins.forEach(extendEmits);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$3(comp2)) {
          cache.set(comp2, null);
        }
        return null;
      }
      if (isArray$1(raw)) {
        raw.forEach((key) => normalized[key] = null);
      } else {
        extend(normalized, raw);
      }
      if (isObject$3(comp2)) {
        cache.set(comp2, normalized);
      }
      return normalized;
    }
    function isEmitListener(options, key) {
      if (!options || !isOn$1(key)) {
        return false;
      }
      key = key.slice(2).replace(/Once$/, "");
      return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
    }
    let currentRenderingInstance = null;
    let currentScopeId = null;
    function setCurrentRenderingInstance(instance) {
      const prev = currentRenderingInstance;
      currentRenderingInstance = instance;
      currentScopeId = instance && instance.type.__scopeId || null;
      return prev;
    }
    function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
      if (!ctx)
        return fn;
      if (fn._n) {
        return fn;
      }
      const renderFnWithContext = (...args) => {
        if (renderFnWithContext._d) {
          setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx);
        let res;
        try {
          res = fn(...args);
        } finally {
          setCurrentRenderingInstance(prevInstance);
          if (renderFnWithContext._d) {
            setBlockTracking(1);
          }
        }
        return res;
      };
      renderFnWithContext._n = true;
      renderFnWithContext._c = true;
      renderFnWithContext._d = true;
      return renderFnWithContext;
    }
    function markAttrsAccessed() {
    }
    function renderComponentRoot(instance) {
      const {
        type: Component,
        vnode,
        proxy,
        withProxy,
        props,
        propsOptions: [propsOptions],
        slots,
        attrs,
        emit: emit2,
        render,
        renderCache,
        data,
        setupState,
        ctx,
        inheritAttrs
      } = instance;
      let result;
      let fallthroughAttrs;
      const prev = setCurrentRenderingInstance(instance);
      try {
        if (vnode.shapeFlag & 4) {
          const proxyToUse = withProxy || proxy;
          const thisProxy = false ? new Proxy(proxyToUse, {
            get(target2, key, receiver) {
              warn$1(
                `Property '${String(
                  key
                )}' was accessed via 'this'. Avoid using 'this' in templates.`
              );
              return Reflect.get(target2, key, receiver);
            }
          }) : proxyToUse;
          result = normalizeVNode(
            render.call(
              thisProxy,
              proxyToUse,
              renderCache,
              props,
              setupState,
              data,
              ctx
            )
          );
          fallthroughAttrs = attrs;
        } else {
          const render2 = Component;
          if (false)
            ;
          result = normalizeVNode(
            render2.length > 1 ? render2(
              props,
              false ? {
                get attrs() {
                  markAttrsAccessed();
                  return attrs;
                },
                slots,
                emit: emit2
              } : { attrs, slots, emit: emit2 }
            ) : render2(
              props,
              null
              /* we know it doesn't need it */
            )
          );
          fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
      } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
      }
      let root = result;
      if (fallthroughAttrs && inheritAttrs !== false) {
        const keys2 = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root;
        if (keys2.length) {
          if (shapeFlag & (1 | 6)) {
            if (propsOptions && keys2.some(isModelListener)) {
              fallthroughAttrs = filterModelListeners(
                fallthroughAttrs,
                propsOptions
              );
            }
            root = cloneVNode(root, fallthroughAttrs);
          }
        }
      }
      if (vnode.dirs) {
        root = cloneVNode(root);
        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
      }
      if (vnode.transition) {
        root.transition = vnode.transition;
      }
      {
        result = root;
      }
      setCurrentRenderingInstance(prev);
      return result;
    }
    const getFunctionalFallthrough = (attrs) => {
      let res;
      for (const key in attrs) {
        if (key === "class" || key === "style" || isOn$1(key)) {
          (res || (res = {}))[key] = attrs[key];
        }
      }
      return res;
    };
    const filterModelListeners = (attrs, props) => {
      const res = {};
      for (const key in attrs) {
        if (!isModelListener(key) || !(key.slice(9) in props)) {
          res[key] = attrs[key];
        }
      }
      return res;
    };
    function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
      const { props: prevProps, children: prevChildren, component } = prevVNode;
      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
      const emits2 = component.emitsOptions;
      if (nextVNode.dirs || nextVNode.transition) {
        return true;
      }
      if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) {
          return true;
        }
        if (patchFlag & 16) {
          if (!prevProps) {
            return !!nextProps;
          }
          return hasPropsChanged(prevProps, nextProps, emits2);
        } else if (patchFlag & 8) {
          const dynamicProps = nextVNode.dynamicProps;
          for (let i2 = 0; i2 < dynamicProps.length; i2++) {
            const key = dynamicProps[i2];
            if (nextProps[key] !== prevProps[key] && !isEmitListener(emits2, key)) {
              return true;
            }
          }
        }
      } else {
        if (prevChildren || nextChildren) {
          if (!nextChildren || !nextChildren.$stable) {
            return true;
          }
        }
        if (prevProps === nextProps) {
          return false;
        }
        if (!prevProps) {
          return !!nextProps;
        }
        if (!nextProps) {
          return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits2);
      }
      return false;
    }
    function hasPropsChanged(prevProps, nextProps, emitsOptions) {
      const nextKeys = Object.keys(nextProps);
      if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
      }
      for (let i2 = 0; i2 < nextKeys.length; i2++) {
        const key = nextKeys[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
          return true;
        }
      }
      return false;
    }
    function updateHOCHostEl({ vnode, parent }, el2) {
      while (parent) {
        const root = parent.subTree;
        if (root.suspense && root.suspense.activeBranch === vnode) {
          root.el = vnode.el;
        }
        if (root === vnode) {
          (vnode = parent.vnode).el = el2;
          parent = parent.parent;
        } else {
          break;
        }
      }
    }
    const COMPONENTS = "components";
    const DIRECTIVES = "directives";
    function resolveComponent(name, maybeSelfReference) {
      return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
    }
    const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
    function resolveDynamicComponent(component) {
      if (isString$1(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
      } else {
        return component || NULL_DYNAMIC_COMPONENT;
      }
    }
    function resolveDirective(name) {
      return resolveAsset(DIRECTIVES, name);
    }
    function resolveAsset(type2, name, warnMissing = true, maybeSelfReference = false) {
      const instance = currentRenderingInstance || currentInstance;
      if (instance) {
        const Component = instance.type;
        if (type2 === COMPONENTS) {
          const selfName = getComponentName(
            Component,
            false
          );
          if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
            return Component;
          }
        }
        const res = (
          // local registration
          // check instance[type] first which is resolved for options API
          resolve$2(instance[type2] || Component[type2], name) || // global registration
          resolve$2(instance.appContext[type2], name)
        );
        if (!res && maybeSelfReference) {
          return Component;
        }
        return res;
      }
    }
    function resolve$2(registry, name) {
      return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
    }
    const isSuspense = (type2) => type2.__isSuspense;
    function queueEffectWithSuspense(fn, suspense) {
      if (suspense && suspense.pendingBranch) {
        if (isArray$1(fn)) {
          suspense.effects.push(...fn);
        } else {
          suspense.effects.push(fn);
        }
      } else {
        queuePostFlushCb(fn);
      }
    }
    const ssrContextKey = Symbol.for("v-scx");
    const useSSRContext = () => {
      {
        const ctx = inject$1(ssrContextKey);
        return ctx;
      }
    };
    function watchEffect(effect2, options) {
      return doWatch(effect2, null, options);
    }
    const INITIAL_WATCHER_VALUE = {};
    function watch(source, cb, options) {
      return doWatch(source, cb, options);
    }
    function doWatch(source, cb, {
      immediate,
      deep,
      flush,
      once,
      onTrack,
      onTrigger
    } = EMPTY_OBJ) {
      if (cb && once) {
        const _cb = cb;
        cb = (...args) => {
          _cb(...args);
          unwatch();
        };
      }
      const instance = currentInstance;
      const reactiveGetter = (source2) => deep === true ? source2 : (
        // for deep: false, only traverse root-level properties
        traverse$2(source2, deep === false ? 1 : void 0)
      );
      let getter;
      let forceTrigger = false;
      let isMultiSource = false;
      if (isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
      } else if (isReactive(source)) {
        getter = () => reactiveGetter(source);
        forceTrigger = true;
      } else if (isArray$1(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
        getter = () => source.map((s) => {
          if (isRef(s)) {
            return s.value;
          } else if (isReactive(s)) {
            return reactiveGetter(s);
          } else if (isFunction$1(s)) {
            return callWithErrorHandling(s, instance, 2);
          } else
            ;
        });
      } else if (isFunction$1(source)) {
        if (cb) {
          getter = () => callWithErrorHandling(source, instance, 2);
        } else {
          getter = () => {
            if (cleanup) {
              cleanup();
            }
            return callWithAsyncErrorHandling(
              source,
              instance,
              3,
              [onCleanup]
            );
          };
        }
      } else {
        getter = NOOP;
      }
      if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse$2(baseGetter());
      }
      let cleanup;
      let onCleanup = (fn) => {
        cleanup = effect2.onStop = () => {
          callWithErrorHandling(fn, instance, 4);
          cleanup = effect2.onStop = void 0;
        };
      };
      let ssrCleanup;
      if (isInSSRComponentSetup) {
        onCleanup = NOOP;
        if (!cb) {
          getter();
        } else if (immediate) {
          callWithAsyncErrorHandling(cb, instance, 3, [
            getter(),
            isMultiSource ? [] : void 0,
            onCleanup
          ]);
        }
        if (flush === "sync") {
          const ctx = useSSRContext();
          ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
        } else {
          return NOOP;
        }
      }
      let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
      const job = () => {
        if (!effect2.active || !effect2.dirty) {
          return;
        }
        if (cb) {
          const newValue = effect2.run();
          if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i2) => hasChanged(v, oldValue[i2])) : hasChanged(newValue, oldValue)) || false) {
            if (cleanup) {
              cleanup();
            }
            callWithAsyncErrorHandling(cb, instance, 3, [
              newValue,
              // pass undefined as the old value when it's changed for the first time
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              onCleanup
            ]);
            oldValue = newValue;
          }
        } else {
          effect2.run();
        }
      };
      job.allowRecurse = !!cb;
      let scheduler;
      if (flush === "sync") {
        scheduler = job;
      } else if (flush === "post") {
        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
      } else {
        job.pre = true;
        if (instance)
          job.id = instance.uid;
        scheduler = () => queueJob(job);
      }
      const effect2 = new ReactiveEffect(getter, NOOP, scheduler);
      const scope2 = getCurrentScope$1();
      const unwatch = () => {
        effect2.stop();
        if (scope2) {
          remove(scope2.effects, effect2);
        }
      };
      if (cb) {
        if (immediate) {
          job();
        } else {
          oldValue = effect2.run();
        }
      } else if (flush === "post") {
        queuePostRenderEffect(
          effect2.run.bind(effect2),
          instance && instance.suspense
        );
      } else {
        effect2.run();
      }
      if (ssrCleanup)
        ssrCleanup.push(unwatch);
      return unwatch;
    }
    function instanceWatch(source, value, options) {
      const publicThis = this.proxy;
      const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
      let cb;
      if (isFunction$1(value)) {
        cb = value;
      } else {
        cb = value.handler;
        options = value;
      }
      const reset = setCurrentInstance(this);
      const res = doWatch(getter, cb.bind(publicThis), options);
      reset();
      return res;
    }
    function createPathGetter(ctx, path) {
      const segments = path.split(".");
      return () => {
        let cur = ctx;
        for (let i2 = 0; i2 < segments.length && cur; i2++) {
          cur = cur[segments[i2]];
        }
        return cur;
      };
    }
    function traverse$2(value, depth, currentDepth = 0, seen) {
      if (!isObject$3(value) || value["__v_skip"]) {
        return value;
      }
      if (depth && depth > 0) {
        if (currentDepth >= depth) {
          return value;
        }
        currentDepth++;
      }
      seen = seen || /* @__PURE__ */ new Set();
      if (seen.has(value)) {
        return value;
      }
      seen.add(value);
      if (isRef(value)) {
        traverse$2(value.value, depth, currentDepth, seen);
      } else if (isArray$1(value)) {
        for (let i2 = 0; i2 < value.length; i2++) {
          traverse$2(value[i2], depth, currentDepth, seen);
        }
      } else if (isSet$1(value) || isMap$1(value)) {
        value.forEach((v) => {
          traverse$2(v, depth, currentDepth, seen);
        });
      } else if (isPlainObject$3(value)) {
        for (const key in value) {
          traverse$2(value[key], depth, currentDepth, seen);
        }
      }
      return value;
    }
    function withDirectives(vnode, directives) {
      if (currentRenderingInstance === null) {
        return vnode;
      }
      const instance = getExposeProxy(currentRenderingInstance) || currentRenderingInstance.proxy;
      const bindings = vnode.dirs || (vnode.dirs = []);
      for (let i2 = 0; i2 < directives.length; i2++) {
        let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i2];
        if (dir) {
          if (isFunction$1(dir)) {
            dir = {
              mounted: dir,
              updated: dir
            };
          }
          if (dir.deep) {
            traverse$2(value);
          }
          bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
          });
        }
      }
      return vnode;
    }
    function invokeDirectiveHook(vnode, prevVNode, instance, name) {
      const bindings = vnode.dirs;
      const oldBindings = prevVNode && prevVNode.dirs;
      for (let i2 = 0; i2 < bindings.length; i2++) {
        const binding = bindings[i2];
        if (oldBindings) {
          binding.oldValue = oldBindings[i2].value;
        }
        let hook = binding.dir[name];
        if (hook) {
          pauseTracking();
          callWithAsyncErrorHandling(hook, instance, 8, [
            vnode.el,
            binding,
            vnode,
            prevVNode
          ]);
          resetTracking();
        }
      }
    }
    const leaveCbKey = Symbol("_leaveCb");
    const enterCbKey$1 = Symbol("_enterCb");
    function useTransitionState() {
      const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
      };
      onMounted(() => {
        state.isMounted = true;
      });
      onBeforeUnmount(() => {
        state.isUnmounting = true;
      });
      return state;
    }
    const TransitionHookValidator = [Function, Array];
    const BaseTransitionPropsValidators = {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      // enter
      onBeforeEnter: TransitionHookValidator,
      onEnter: TransitionHookValidator,
      onAfterEnter: TransitionHookValidator,
      onEnterCancelled: TransitionHookValidator,
      // leave
      onBeforeLeave: TransitionHookValidator,
      onLeave: TransitionHookValidator,
      onAfterLeave: TransitionHookValidator,
      onLeaveCancelled: TransitionHookValidator,
      // appear
      onBeforeAppear: TransitionHookValidator,
      onAppear: TransitionHookValidator,
      onAfterAppear: TransitionHookValidator,
      onAppearCancelled: TransitionHookValidator
    };
    const BaseTransitionImpl = {
      name: `BaseTransition`,
      props: BaseTransitionPropsValidators,
      setup(props, { slots }) {
        const instance = getCurrentInstance$1();
        const state = useTransitionState();
        let prevTransitionKey;
        return () => {
          const children = slots.default && getTransitionRawChildren(slots.default(), true);
          if (!children || !children.length) {
            return;
          }
          let child = children[0];
          if (children.length > 1) {
            for (const c of children) {
              if (c.type !== Comment) {
                child = c;
                break;
              }
            }
          }
          const rawProps = toRaw(props);
          const { mode } = rawProps;
          if (state.isLeaving) {
            return emptyPlaceholder(child);
          }
          const innerChild = getKeepAliveChild(child);
          if (!innerChild) {
            return emptyPlaceholder(child);
          }
          const enterHooks = resolveTransitionHooks(
            innerChild,
            rawProps,
            state,
            instance
          );
          setTransitionHooks(innerChild, enterHooks);
          const oldChild = instance.subTree;
          const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
          let transitionKeyChanged = false;
          const { getTransitionKey } = innerChild.type;
          if (getTransitionKey) {
            const key = getTransitionKey();
            if (prevTransitionKey === void 0) {
              prevTransitionKey = key;
            } else if (key !== prevTransitionKey) {
              prevTransitionKey = key;
              transitionKeyChanged = true;
            }
          }
          if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
            const leavingHooks = resolveTransitionHooks(
              oldInnerChild,
              rawProps,
              state,
              instance
            );
            setTransitionHooks(oldInnerChild, leavingHooks);
            if (mode === "out-in") {
              state.isLeaving = true;
              leavingHooks.afterLeave = () => {
                state.isLeaving = false;
                if (instance.update.active !== false) {
                  instance.effect.dirty = true;
                  instance.update();
                }
              };
              return emptyPlaceholder(child);
            } else if (mode === "in-out" && innerChild.type !== Comment) {
              leavingHooks.delayLeave = (el2, earlyRemove, delayedLeave) => {
                const leavingVNodesCache = getLeavingNodesForType(
                  state,
                  oldInnerChild
                );
                leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                el2[leaveCbKey] = () => {
                  earlyRemove();
                  el2[leaveCbKey] = void 0;
                  delete enterHooks.delayedLeave;
                };
                enterHooks.delayedLeave = delayedLeave;
              };
            }
          }
          return child;
        };
      }
    };
    const BaseTransition = BaseTransitionImpl;
    function getLeavingNodesForType(state, vnode) {
      const { leavingVNodes } = state;
      let leavingVNodesCache = leavingVNodes.get(vnode.type);
      if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
      }
      return leavingVNodesCache;
    }
    function resolveTransitionHooks(vnode, props, state, instance) {
      const {
        appear,
        mode,
        persisted = false,
        onBeforeEnter,
        onEnter,
        onAfterEnter,
        onEnterCancelled,
        onBeforeLeave,
        onLeave,
        onAfterLeave,
        onLeaveCancelled,
        onBeforeAppear,
        onAppear,
        onAfterAppear,
        onAppearCancelled
      } = props;
      const key = String(vnode.key);
      const leavingVNodesCache = getLeavingNodesForType(state, vnode);
      const callHook2 = (hook, args) => {
        hook && callWithAsyncErrorHandling(
          hook,
          instance,
          9,
          args
        );
      };
      const callAsyncHook = (hook, args) => {
        const done = args[1];
        callHook2(hook, args);
        if (isArray$1(hook)) {
          if (hook.every((hook2) => hook2.length <= 1))
            done();
        } else if (hook.length <= 1) {
          done();
        }
      };
      const hooks = {
        mode,
        persisted,
        beforeEnter(el2) {
          let hook = onBeforeEnter;
          if (!state.isMounted) {
            if (appear) {
              hook = onBeforeAppear || onBeforeEnter;
            } else {
              return;
            }
          }
          if (el2[leaveCbKey]) {
            el2[leaveCbKey](
              true
              /* cancelled */
            );
          }
          const leavingVNode = leavingVNodesCache[key];
          if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
            leavingVNode.el[leaveCbKey]();
          }
          callHook2(hook, [el2]);
        },
        enter(el2) {
          let hook = onEnter;
          let afterHook = onAfterEnter;
          let cancelHook = onEnterCancelled;
          if (!state.isMounted) {
            if (appear) {
              hook = onAppear || onEnter;
              afterHook = onAfterAppear || onAfterEnter;
              cancelHook = onAppearCancelled || onEnterCancelled;
            } else {
              return;
            }
          }
          let called = false;
          const done = el2[enterCbKey$1] = (cancelled) => {
            if (called)
              return;
            called = true;
            if (cancelled) {
              callHook2(cancelHook, [el2]);
            } else {
              callHook2(afterHook, [el2]);
            }
            if (hooks.delayedLeave) {
              hooks.delayedLeave();
            }
            el2[enterCbKey$1] = void 0;
          };
          if (hook) {
            callAsyncHook(hook, [el2, done]);
          } else {
            done();
          }
        },
        leave(el2, remove2) {
          const key2 = String(vnode.key);
          if (el2[enterCbKey$1]) {
            el2[enterCbKey$1](
              true
              /* cancelled */
            );
          }
          if (state.isUnmounting) {
            return remove2();
          }
          callHook2(onBeforeLeave, [el2]);
          let called = false;
          const done = el2[leaveCbKey] = (cancelled) => {
            if (called)
              return;
            called = true;
            remove2();
            if (cancelled) {
              callHook2(onLeaveCancelled, [el2]);
            } else {
              callHook2(onAfterLeave, [el2]);
            }
            el2[leaveCbKey] = void 0;
            if (leavingVNodesCache[key2] === vnode) {
              delete leavingVNodesCache[key2];
            }
          };
          leavingVNodesCache[key2] = vnode;
          if (onLeave) {
            callAsyncHook(onLeave, [el2, done]);
          } else {
            done();
          }
        },
        clone(vnode2) {
          return resolveTransitionHooks(vnode2, props, state, instance);
        }
      };
      return hooks;
    }
    function emptyPlaceholder(vnode) {
      if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
      }
    }
    function getKeepAliveChild(vnode) {
      return isKeepAlive(vnode) ? (
        // #7121 ensure get the child component subtree in case
        // it's been replaced during HMR
        vnode.children ? vnode.children[0] : void 0
      ) : vnode;
    }
    function setTransitionHooks(vnode, hooks) {
      if (vnode.shapeFlag & 6 && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks);
      } else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
      } else {
        vnode.transition = hooks;
      }
    }
    function getTransitionRawChildren(children, keepComment = false, parentKey) {
      let ret = [];
      let keyedFragmentCount = 0;
      for (let i2 = 0; i2 < children.length; i2++) {
        let child = children[i2];
        const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
        if (child.type === Fragment) {
          if (child.patchFlag & 128)
            keyedFragmentCount++;
          ret = ret.concat(
            getTransitionRawChildren(child.children, keepComment, key)
          );
        } else if (keepComment || child.type !== Comment) {
          ret.push(key != null ? cloneVNode(child, { key }) : child);
        }
      }
      if (keyedFragmentCount > 1) {
        for (let i2 = 0; i2 < ret.length; i2++) {
          ret[i2].patchFlag = -2;
        }
      }
      return ret;
    }
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function defineComponent$1(options, extraOptions) {
      return isFunction$1(options) ? (
        // #8326: extend call and options.name access are considered side-effects
        // by Rollup, so we have to wrap it in a pure-annotated IIFE.
        /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
      ) : options;
    }
    const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
    const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
    function onActivated(hook, target2) {
      registerKeepAliveHook(hook, "a", target2);
    }
    function onDeactivated(hook, target2) {
      registerKeepAliveHook(hook, "da", target2);
    }
    function registerKeepAliveHook(hook, type2, target2 = currentInstance) {
      const wrappedHook = hook.__wdc || (hook.__wdc = () => {
        let current2 = target2;
        while (current2) {
          if (current2.isDeactivated) {
            return;
          }
          current2 = current2.parent;
        }
        return hook();
      });
      injectHook(type2, wrappedHook, target2);
      if (target2) {
        let current2 = target2.parent;
        while (current2 && current2.parent) {
          if (isKeepAlive(current2.parent.vnode)) {
            injectToKeepAliveRoot(wrappedHook, type2, target2, current2);
          }
          current2 = current2.parent;
        }
      }
    }
    function injectToKeepAliveRoot(hook, type2, target2, keepAliveRoot) {
      const injected = injectHook(
        type2,
        hook,
        keepAliveRoot,
        true
        /* prepend */
      );
      onUnmounted(() => {
        remove(keepAliveRoot[type2], injected);
      }, target2);
    }
    function injectHook(type2, hook, target2 = currentInstance, prepend = false) {
      if (target2) {
        const hooks = target2[type2] || (target2[type2] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
          if (target2.isUnmounted) {
            return;
          }
          pauseTracking();
          const reset = setCurrentInstance(target2);
          const res = callWithAsyncErrorHandling(hook, target2, type2, args);
          reset();
          resetTracking();
          return res;
        });
        if (prepend) {
          hooks.unshift(wrappedHook);
        } else {
          hooks.push(wrappedHook);
        }
        return wrappedHook;
      }
    }
    const createHook = (lifecycle) => (hook, target2 = currentInstance) => (
      // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
      (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target2)
    );
    const onBeforeMount = createHook("bm");
    const onMounted = createHook("m");
    const onBeforeUpdate = createHook("bu");
    const onUpdated = createHook("u");
    const onBeforeUnmount = createHook("bum");
    const onUnmounted = createHook("um");
    const onServerPrefetch = createHook("sp");
    const onRenderTriggered = createHook(
      "rtg"
    );
    const onRenderTracked = createHook(
      "rtc"
    );
    function onErrorCaptured(hook, target2 = currentInstance) {
      injectHook("ec", hook, target2);
    }
    function renderList(source, renderItem, cache, index) {
      let ret;
      const cached = cache && cache[index];
      if (isArray$1(source) || isString$1(source)) {
        ret = new Array(source.length);
        for (let i2 = 0, l = source.length; i2 < l; i2++) {
          ret[i2] = renderItem(source[i2], i2, void 0, cached && cached[i2]);
        }
      } else if (typeof source === "number") {
        ret = new Array(source);
        for (let i2 = 0; i2 < source; i2++) {
          ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
        }
      } else if (isObject$3(source)) {
        if (source[Symbol.iterator]) {
          ret = Array.from(
            source,
            (item, i2) => renderItem(item, i2, void 0, cached && cached[i2])
          );
        } else {
          const keys2 = Object.keys(source);
          ret = new Array(keys2.length);
          for (let i2 = 0, l = keys2.length; i2 < l; i2++) {
            const key = keys2[i2];
            ret[i2] = renderItem(source[key], key, i2, cached && cached[i2]);
          }
        }
      } else {
        ret = [];
      }
      if (cache) {
        cache[index] = ret;
      }
      return ret;
    }
    function createSlots(slots, dynamicSlots) {
      for (let i2 = 0; i2 < dynamicSlots.length; i2++) {
        const slot = dynamicSlots[i2];
        if (isArray$1(slot)) {
          for (let j = 0; j < slot.length; j++) {
            slots[slot[j].name] = slot[j].fn;
          }
        } else if (slot) {
          slots[slot.name] = slot.key ? (...args) => {
            const res = slot.fn(...args);
            if (res)
              res.key = slot.key;
            return res;
          } : slot.fn;
        }
      }
      return slots;
    }
    function renderSlot(slots, name, props = {}, fallback, noSlotted) {
      if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
        if (name !== "default")
          props.name = name;
        return createVNode("slot", props, fallback && fallback());
      }
      let slot = slots[name];
      if (slot && slot._c) {
        slot._d = false;
      }
      openBlock();
      const validSlotContent = slot && ensureValidVNode$1(slot(props));
      const rendered = createBlock(
        Fragment,
        {
          key: props.key || // slot content array of a dynamic conditional slot may have a branch
          // key attached in the `createSlots` helper, respect that
          validSlotContent && validSlotContent.key || `_${name}`
        },
        validSlotContent || (fallback ? fallback() : []),
        validSlotContent && slots._ === 1 ? 64 : -2
      );
      if (!noSlotted && rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + "-s"];
      }
      if (slot && slot._c) {
        slot._d = true;
      }
      return rendered;
    }
    function ensureValidVNode$1(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child))
          return true;
        if (child.type === Comment)
          return false;
        if (child.type === Fragment && !ensureValidVNode$1(child.children))
          return false;
        return true;
      }) ? vnodes : null;
    }
    const getPublicInstance = (i2) => {
      if (!i2)
        return null;
      if (isStatefulComponent(i2))
        return getExposeProxy(i2) || i2.proxy;
      return getPublicInstance(i2.parent);
    };
    const publicPropertiesMap = (
      // Move PURE marker to new line to workaround compiler discarding it
      // due to type annotation
      /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
        $: (i2) => i2,
        $el: (i2) => i2.vnode.el,
        $data: (i2) => i2.data,
        $props: (i2) => i2.props,
        $attrs: (i2) => i2.attrs,
        $slots: (i2) => i2.slots,
        $refs: (i2) => i2.refs,
        $parent: (i2) => getPublicInstance(i2.parent),
        $root: (i2) => getPublicInstance(i2.root),
        $emit: (i2) => i2.emit,
        $options: (i2) => resolveMergedOptions(i2),
        $forceUpdate: (i2) => i2.f || (i2.f = () => {
          i2.effect.dirty = true;
          queueJob(i2.update);
        }),
        $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
        $watch: (i2) => instanceWatch.bind(i2)
      })
    );
    const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
    const PublicInstanceProxyHandlers = {
      get({ _: instance }, key) {
        const { ctx, setupState, data, props, accessCache, type: type2, appContext } = instance;
        let normalizedProps;
        if (key[0] !== "$") {
          const n = accessCache[key];
          if (n !== void 0) {
            switch (n) {
              case 1:
                return setupState[key];
              case 2:
                return data[key];
              case 4:
                return ctx[key];
              case 3:
                return props[key];
            }
          } else if (hasSetupBinding(setupState, key)) {
            accessCache[key] = 1;
            return setupState[key];
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            accessCache[key] = 2;
            return data[key];
          } else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
          ) {
            accessCache[key] = 3;
            return props[key];
          } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (shouldCacheAccess) {
            accessCache[key] = 0;
          }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
          if (key === "$attrs") {
            track(instance, "get", key);
          }
          return publicGetter(instance);
        } else if (
          // css module (injected by vue-loader)
          (cssModule = type2.__cssModules) && (cssModule = cssModule[key])
        ) {
          return cssModule;
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (
          // global properties
          globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
        ) {
          {
            return globalProperties[key];
          }
        } else
          ;
      },
      set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (hasSetupBinding(setupState, key)) {
          setupState[key] = value;
          return true;
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          data[key] = value;
          return true;
        } else if (hasOwn(instance.props, key)) {
          return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
          return false;
        } else {
          {
            ctx[key] = value;
          }
        }
        return true;
      },
      has({
        _: { data, setupState, accessCache, ctx, appContext, propsOptions }
      }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
      },
      defineProperty(target2, key, descriptor) {
        if (descriptor.get != null) {
          target2._.accessCache[key] = 0;
        } else if (hasOwn(descriptor, "value")) {
          this.set(target2, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target2, key, descriptor);
      }
    };
    function useSlots() {
      return getContext().slots;
    }
    function getContext() {
      const i2 = getCurrentInstance$1();
      return i2.setupContext || (i2.setupContext = createSetupContext(i2));
    }
    function normalizePropsOrEmits(props) {
      return isArray$1(props) ? props.reduce(
        (normalized, p2) => (normalized[p2] = null, normalized),
        {}
      ) : props;
    }
    let shouldCacheAccess = true;
    function applyOptions(instance) {
      const options = resolveMergedOptions(instance);
      const publicThis = instance.proxy;
      const ctx = instance.ctx;
      shouldCacheAccess = false;
      if (options.beforeCreate) {
        callHook$1(options.beforeCreate, instance, "bc");
      }
      const {
        // state
        data: dataOptions,
        computed: computedOptions,
        methods,
        watch: watchOptions,
        provide: provideOptions,
        inject: injectOptions,
        // lifecycle
        created,
        beforeMount,
        mounted: mounted2,
        beforeUpdate,
        updated: updated2,
        activated,
        deactivated,
        beforeDestroy,
        beforeUnmount,
        destroyed,
        unmounted: unmounted2,
        render,
        renderTracked,
        renderTriggered,
        errorCaptured,
        serverPrefetch,
        // public API
        expose,
        inheritAttrs,
        // assets
        components,
        directives,
        filters
      } = options;
      const checkDuplicateProperties = null;
      if (injectOptions) {
        resolveInjections(injectOptions, ctx, checkDuplicateProperties);
      }
      if (methods) {
        for (const key in methods) {
          const methodHandler = methods[key];
          if (isFunction$1(methodHandler)) {
            {
              ctx[key] = methodHandler.bind(publicThis);
            }
          }
        }
      }
      if (dataOptions) {
        const data = dataOptions.call(publicThis, publicThis);
        if (!isObject$3(data))
          ;
        else {
          instance.data = reactive(data);
        }
      }
      shouldCacheAccess = true;
      if (computedOptions) {
        for (const key in computedOptions) {
          const opt = computedOptions[key];
          const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
          const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
          const c = computed({
            get: get2,
            set: set2
          });
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => c.value,
            set: (v) => c.value = v
          });
        }
      }
      if (watchOptions) {
        for (const key in watchOptions) {
          createWatcher(watchOptions[key], ctx, publicThis, key);
        }
      }
      if (provideOptions) {
        const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key) => {
          provide(key, provides[key]);
        });
      }
      if (created) {
        callHook$1(created, instance, "c");
      }
      function registerLifecycleHook(register, hook) {
        if (isArray$1(hook)) {
          hook.forEach((_hook) => register(_hook.bind(publicThis)));
        } else if (hook) {
          register(hook.bind(publicThis));
        }
      }
      registerLifecycleHook(onBeforeMount, beforeMount);
      registerLifecycleHook(onMounted, mounted2);
      registerLifecycleHook(onBeforeUpdate, beforeUpdate);
      registerLifecycleHook(onUpdated, updated2);
      registerLifecycleHook(onActivated, activated);
      registerLifecycleHook(onDeactivated, deactivated);
      registerLifecycleHook(onErrorCaptured, errorCaptured);
      registerLifecycleHook(onRenderTracked, renderTracked);
      registerLifecycleHook(onRenderTriggered, renderTriggered);
      registerLifecycleHook(onBeforeUnmount, beforeUnmount);
      registerLifecycleHook(onUnmounted, unmounted2);
      registerLifecycleHook(onServerPrefetch, serverPrefetch);
      if (isArray$1(expose)) {
        if (expose.length) {
          const exposed = instance.exposed || (instance.exposed = {});
          expose.forEach((key) => {
            Object.defineProperty(exposed, key, {
              get: () => publicThis[key],
              set: (val) => publicThis[key] = val
            });
          });
        } else if (!instance.exposed) {
          instance.exposed = {};
        }
      }
      if (render && instance.render === NOOP) {
        instance.render = render;
      }
      if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
      }
      if (components)
        instance.components = components;
      if (directives)
        instance.directives = directives;
    }
    function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
      if (isArray$1(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
      }
      for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if (isObject$3(opt)) {
          if ("default" in opt) {
            injected = inject$1(
              opt.from || key,
              opt.default,
              true
            );
          } else {
            injected = inject$1(opt.from || key);
          }
        } else {
          injected = inject$1(opt);
        }
        if (isRef(injected)) {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => injected.value,
            set: (v) => injected.value = v
          });
        } else {
          ctx[key] = injected;
        }
      }
    }
    function callHook$1(hook, instance, type2) {
      callWithAsyncErrorHandling(
        isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
        instance,
        type2
      );
    }
    function createWatcher(raw, ctx, publicThis, key) {
      const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
      if (isString$1(raw)) {
        const handler = ctx[raw];
        if (isFunction$1(handler)) {
          watch(getter, handler);
        }
      } else if (isFunction$1(raw)) {
        watch(getter, raw.bind(publicThis));
      } else if (isObject$3(raw)) {
        if (isArray$1(raw)) {
          raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
        } else {
          const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
          if (isFunction$1(handler)) {
            watch(getter, handler, raw);
          }
        }
      } else
        ;
    }
    function resolveMergedOptions(instance) {
      const base2 = instance.type;
      const { mixins, extends: extendsOptions } = base2;
      const {
        mixins: globalMixins,
        optionsCache: cache,
        config: { optionMergeStrategies }
      } = instance.appContext;
      const cached = cache.get(base2);
      let resolved;
      if (cached) {
        resolved = cached;
      } else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
          resolved = base2;
        }
      } else {
        resolved = {};
        if (globalMixins.length) {
          globalMixins.forEach(
            (m) => mergeOptions$1(resolved, m, optionMergeStrategies, true)
          );
        }
        mergeOptions$1(resolved, base2, optionMergeStrategies);
      }
      if (isObject$3(base2)) {
        cache.set(base2, resolved);
      }
      return resolved;
    }
    function mergeOptions$1(to, from, strats, asMixin = false) {
      const { mixins, extends: extendsOptions } = from;
      if (extendsOptions) {
        mergeOptions$1(to, extendsOptions, strats, true);
      }
      if (mixins) {
        mixins.forEach(
          (m) => mergeOptions$1(to, m, strats, true)
        );
      }
      for (const key in from) {
        if (asMixin && key === "expose")
          ;
        else {
          const strat = internalOptionMergeStrats[key] || strats && strats[key];
          to[key] = strat ? strat(to[key], from[key]) : from[key];
        }
      }
      return to;
    }
    const internalOptionMergeStrats = {
      data: mergeDataFn,
      props: mergeEmitsOrPropsOptions,
      emits: mergeEmitsOrPropsOptions,
      // objects
      methods: mergeObjectOptions,
      computed: mergeObjectOptions,
      // lifecycle
      beforeCreate: mergeAsArray,
      created: mergeAsArray,
      beforeMount: mergeAsArray,
      mounted: mergeAsArray,
      beforeUpdate: mergeAsArray,
      updated: mergeAsArray,
      beforeDestroy: mergeAsArray,
      beforeUnmount: mergeAsArray,
      destroyed: mergeAsArray,
      unmounted: mergeAsArray,
      activated: mergeAsArray,
      deactivated: mergeAsArray,
      errorCaptured: mergeAsArray,
      serverPrefetch: mergeAsArray,
      // assets
      components: mergeObjectOptions,
      directives: mergeObjectOptions,
      // watch
      watch: mergeWatchOptions,
      // provide / inject
      provide: mergeDataFn,
      inject: mergeInject
    };
    function mergeDataFn(to, from) {
      if (!from) {
        return to;
      }
      if (!to) {
        return from;
      }
      return function mergedDataFn() {
        return extend(
          isFunction$1(to) ? to.call(this, this) : to,
          isFunction$1(from) ? from.call(this, this) : from
        );
      };
    }
    function mergeInject(to, from) {
      return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
    }
    function normalizeInject(raw) {
      if (isArray$1(raw)) {
        const res = {};
        for (let i2 = 0; i2 < raw.length; i2++) {
          res[raw[i2]] = raw[i2];
        }
        return res;
      }
      return raw;
    }
    function mergeAsArray(to, from) {
      return to ? [...new Set([].concat(to, from))] : from;
    }
    function mergeObjectOptions(to, from) {
      return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
    }
    function mergeEmitsOrPropsOptions(to, from) {
      if (to) {
        if (isArray$1(to) && isArray$1(from)) {
          return [.../* @__PURE__ */ new Set([...to, ...from])];
        }
        return extend(
          /* @__PURE__ */ Object.create(null),
          normalizePropsOrEmits(to),
          normalizePropsOrEmits(from != null ? from : {})
        );
      } else {
        return from;
      }
    }
    function mergeWatchOptions(to, from) {
      if (!to)
        return from;
      if (!from)
        return to;
      const merged = extend(/* @__PURE__ */ Object.create(null), to);
      for (const key in from) {
        merged[key] = mergeAsArray(to[key], from[key]);
      }
      return merged;
    }
    function createAppContext() {
      return {
        app: null,
        config: {
          isNativeTag: NO,
          performance: false,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
      };
    }
    let uid$1 = 0;
    function createAppAPI(render, hydrate) {
      return function createApp2(rootComponent, rootProps = null) {
        if (!isFunction$1(rootComponent)) {
          rootComponent = extend({}, rootComponent);
        }
        if (rootProps != null && !isObject$3(rootProps)) {
          rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = /* @__PURE__ */ new WeakSet();
        let isMounted = false;
        const app2 = context.app = {
          _uid: uid$1++,
          _component: rootComponent,
          _props: rootProps,
          _container: null,
          _context: context,
          _instance: null,
          version: version$1,
          get config() {
            return context.config;
          },
          set config(v) {
          },
          use(plugin, ...options) {
            if (installedPlugins.has(plugin))
              ;
            else if (plugin && isFunction$1(plugin.install)) {
              installedPlugins.add(plugin);
              plugin.install(app2, ...options);
            } else if (isFunction$1(plugin)) {
              installedPlugins.add(plugin);
              plugin(app2, ...options);
            } else
              ;
            return app2;
          },
          mixin(mixin) {
            {
              if (!context.mixins.includes(mixin)) {
                context.mixins.push(mixin);
              }
            }
            return app2;
          },
          component(name, component) {
            if (!component) {
              return context.components[name];
            }
            context.components[name] = component;
            return app2;
          },
          directive(name, directive2) {
            if (!directive2) {
              return context.directives[name];
            }
            context.directives[name] = directive2;
            return app2;
          },
          mount(rootContainer, isHydrate, namespace) {
            if (!isMounted) {
              const vnode = createVNode(rootComponent, rootProps);
              vnode.appContext = context;
              if (namespace === true) {
                namespace = "svg";
              } else if (namespace === false) {
                namespace = void 0;
              }
              if (isHydrate && hydrate) {
                hydrate(vnode, rootContainer);
              } else {
                render(vnode, rootContainer, namespace);
              }
              isMounted = true;
              app2._container = rootContainer;
              rootContainer.__vue_app__ = app2;
              return getExposeProxy(vnode.component) || vnode.component.proxy;
            }
          },
          unmount() {
            if (isMounted) {
              render(null, app2._container);
              delete app2._container.__vue_app__;
            }
          },
          provide(key, value) {
            context.provides[key] = value;
            return app2;
          },
          runWithContext(fn) {
            const lastApp = currentApp;
            currentApp = app2;
            try {
              return fn();
            } finally {
              currentApp = lastApp;
            }
          }
        };
        return app2;
      };
    }
    let currentApp = null;
    function provide(key, value) {
      if (!currentInstance)
        ;
      else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
          provides = currentInstance.provides = Object.create(parentProvides);
        }
        provides[key] = value;
      }
    }
    function inject$1(key, defaultValue, treatDefaultAsFactory = false) {
      const instance = currentInstance || currentRenderingInstance;
      if (instance || currentApp) {
        const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
        if (provides && key in provides) {
          return provides[key];
        } else if (arguments.length > 1) {
          return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        } else
          ;
      }
    }
    function hasInjectionContext() {
      return !!(currentInstance || currentRenderingInstance || currentApp);
    }
    function initProps(instance, rawProps, isStateful, isSSR = false) {
      const props = {};
      const attrs = {};
      def$C(attrs, InternalObjectKey, 1);
      instance.propsDefaults = /* @__PURE__ */ Object.create(null);
      setFullProps(instance, rawProps, props, attrs);
      for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
          props[key] = void 0;
        }
      }
      if (isStateful) {
        instance.props = isSSR ? props : shallowReactive(props);
      } else {
        if (!instance.type.props) {
          instance.props = attrs;
        } else {
          instance.props = props;
        }
      }
      instance.attrs = attrs;
    }
    function updateProps(instance, rawProps, rawPrevProps, optimized) {
      const {
        props,
        attrs,
        vnode: { patchFlag }
      } = instance;
      const rawCurrentProps = toRaw(props);
      const [options] = instance.propsOptions;
      let hasAttrsChanged = false;
      if (
        // always force full diff in dev
        // - #1942 if hmr is enabled with sfc component
        // - vite#872 non-sfc component used by sfc component
        (optimized || patchFlag > 0) && !(patchFlag & 16)
      ) {
        if (patchFlag & 8) {
          const propsToUpdate = instance.vnode.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            let key = propsToUpdate[i2];
            if (isEmitListener(instance.emitsOptions, key)) {
              continue;
            }
            const value = rawProps[key];
            if (options) {
              if (hasOwn(attrs, key)) {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              } else {
                const camelizedKey = camelize(key);
                props[camelizedKey] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  camelizedKey,
                  value,
                  instance,
                  false
                );
              }
            } else {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
      } else {
        if (setFullProps(instance, rawProps, props, attrs)) {
          hasAttrsChanged = true;
        }
        let kebabKey;
        for (const key in rawCurrentProps) {
          if (!rawProps || // for camelCase
          !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
          // and converted to camelCase (#955)
          ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
            if (options) {
              if (rawPrevProps && // for camelCase
              (rawPrevProps[key] !== void 0 || // for kebab-case
              rawPrevProps[kebabKey] !== void 0)) {
                props[key] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  key,
                  void 0,
                  instance,
                  true
                );
              }
            } else {
              delete props[key];
            }
          }
        }
        if (attrs !== rawCurrentProps) {
          for (const key in attrs) {
            if (!rawProps || !hasOwn(rawProps, key) && true) {
              delete attrs[key];
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (hasAttrsChanged) {
        trigger(instance, "set", "$attrs");
      }
    }
    function setFullProps(instance, rawProps, props, attrs) {
      const [options, needCastKeys] = instance.propsOptions;
      let hasAttrsChanged = false;
      let rawCastValues;
      if (rawProps) {
        for (let key in rawProps) {
          if (isReservedProp(key)) {
            continue;
          }
          const value = rawProps[key];
          let camelKey;
          if (options && hasOwn(options, camelKey = camelize(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) {
              props[camelKey] = value;
            } else {
              (rawCastValues || (rawCastValues = {}))[camelKey] = value;
            }
          } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (needCastKeys) {
        const rawCurrentProps = toRaw(props);
        const castValues = rawCastValues || EMPTY_OBJ;
        for (let i2 = 0; i2 < needCastKeys.length; i2++) {
          const key = needCastKeys[i2];
          props[key] = resolvePropValue(
            options,
            rawCurrentProps,
            key,
            castValues[key],
            instance,
            !hasOwn(castValues, key)
          );
        }
      }
      return hasAttrsChanged;
    }
    function resolvePropValue(options, props, key, value, instance, isAbsent) {
      const opt = options[key];
      if (opt != null) {
        const hasDefault = hasOwn(opt, "default");
        if (hasDefault && value === void 0) {
          const defaultValue = opt.default;
          if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
            const { propsDefaults } = instance;
            if (key in propsDefaults) {
              value = propsDefaults[key];
            } else {
              const reset = setCurrentInstance(instance);
              value = propsDefaults[key] = defaultValue.call(
                null,
                props
              );
              reset();
            }
          } else {
            value = defaultValue;
          }
        }
        if (opt[
          0
          /* shouldCast */
        ]) {
          if (isAbsent && !hasDefault) {
            value = false;
          } else if (opt[
            1
            /* shouldCastTrue */
          ] && (value === "" || value === hyphenate(key))) {
            value = true;
          }
        }
      }
      return value;
    }
    function normalizePropsOptions(comp2, appContext, asMixin = false) {
      const cache = appContext.propsCache;
      const cached = cache.get(comp2);
      if (cached) {
        return cached;
      }
      const raw = comp2.props;
      const normalized = {};
      const needCastKeys = [];
      let hasExtends = false;
      if (!isFunction$1(comp2)) {
        const extendProps = (raw2) => {
          hasExtends = true;
          const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
          extend(normalized, props);
          if (keys2)
            needCastKeys.push(...keys2);
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendProps);
        }
        if (comp2.extends) {
          extendProps(comp2.extends);
        }
        if (comp2.mixins) {
          comp2.mixins.forEach(extendProps);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$3(comp2)) {
          cache.set(comp2, EMPTY_ARR);
        }
        return EMPTY_ARR;
      }
      if (isArray$1(raw)) {
        for (let i2 = 0; i2 < raw.length; i2++) {
          const normalizedKey = camelize(raw[i2]);
          if (validatePropName(normalizedKey)) {
            normalized[normalizedKey] = EMPTY_OBJ;
          }
        }
      } else if (raw) {
        for (const key in raw) {
          const normalizedKey = camelize(key);
          if (validatePropName(normalizedKey)) {
            const opt = raw[key];
            const prop2 = normalized[normalizedKey] = isArray$1(opt) || isFunction$1(opt) ? { type: opt } : extend({}, opt);
            if (prop2) {
              const booleanIndex = getTypeIndex(Boolean, prop2.type);
              const stringIndex = getTypeIndex(String, prop2.type);
              prop2[
                0
                /* shouldCast */
              ] = booleanIndex > -1;
              prop2[
                1
                /* shouldCastTrue */
              ] = stringIndex < 0 || booleanIndex < stringIndex;
              if (booleanIndex > -1 || hasOwn(prop2, "default")) {
                needCastKeys.push(normalizedKey);
              }
            }
          }
        }
      }
      const res = [normalized, needCastKeys];
      if (isObject$3(comp2)) {
        cache.set(comp2, res);
      }
      return res;
    }
    function validatePropName(key) {
      if (key[0] !== "$" && !isReservedProp(key)) {
        return true;
      }
      return false;
    }
    function getType$1(ctor) {
      if (ctor === null) {
        return "null";
      }
      if (typeof ctor === "function") {
        return ctor.name || "";
      } else if (typeof ctor === "object") {
        const name = ctor.constructor && ctor.constructor.name;
        return name || "";
      }
      return "";
    }
    function isSameType(a, b) {
      return getType$1(a) === getType$1(b);
    }
    function getTypeIndex(type2, expectedTypes) {
      if (isArray$1(expectedTypes)) {
        return expectedTypes.findIndex((t) => isSameType(t, type2));
      } else if (isFunction$1(expectedTypes)) {
        return isSameType(expectedTypes, type2) ? 0 : -1;
      }
      return -1;
    }
    const isInternalKey = (key) => key[0] === "_" || key === "$stable";
    const normalizeSlotValue = (value) => isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
    const normalizeSlot$1 = (key, rawSlot, ctx) => {
      if (rawSlot._n) {
        return rawSlot;
      }
      const normalized = withCtx((...args) => {
        if (false)
          ;
        return normalizeSlotValue(rawSlot(...args));
      }, ctx);
      normalized._c = false;
      return normalized;
    };
    const normalizeObjectSlots = (rawSlots, slots, instance) => {
      const ctx = rawSlots._ctx;
      for (const key in rawSlots) {
        if (isInternalKey(key))
          continue;
        const value = rawSlots[key];
        if (isFunction$1(value)) {
          slots[key] = normalizeSlot$1(key, value, ctx);
        } else if (value != null) {
          const normalized = normalizeSlotValue(value);
          slots[key] = () => normalized;
        }
      }
    };
    const normalizeVNodeSlots = (instance, children) => {
      const normalized = normalizeSlotValue(children);
      instance.slots.default = () => normalized;
    };
    const initSlots = (instance, children) => {
      if (instance.vnode.shapeFlag & 32) {
        const type2 = children._;
        if (type2) {
          instance.slots = toRaw(children);
          def$C(children, "_", type2);
        } else {
          normalizeObjectSlots(
            children,
            instance.slots = {}
          );
        }
      } else {
        instance.slots = {};
        if (children) {
          normalizeVNodeSlots(instance, children);
        }
      }
      def$C(instance.slots, InternalObjectKey, 1);
    };
    const updateSlots = (instance, children, optimized) => {
      const { vnode, slots } = instance;
      let needDeletionCheck = true;
      let deletionComparisonTarget = EMPTY_OBJ;
      if (vnode.shapeFlag & 32) {
        const type2 = children._;
        if (type2) {
          if (optimized && type2 === 1) {
            needDeletionCheck = false;
          } else {
            extend(slots, children);
            if (!optimized && type2 === 1) {
              delete slots._;
            }
          }
        } else {
          needDeletionCheck = !children.$stable;
          normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
      } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
      }
      if (needDeletionCheck) {
        for (const key in slots) {
          if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
            delete slots[key];
          }
        }
      }
    };
    function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
      if (isArray$1(rawRef)) {
        rawRef.forEach(
          (r, i2) => setRef(
            r,
            oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i2] : oldRawRef),
            parentSuspense,
            vnode,
            isUnmount
          )
        );
        return;
      }
      if (isAsyncWrapper(vnode) && !isUnmount) {
        return;
      }
      const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
      const value = isUnmount ? null : refValue;
      const { i: owner, r: ref3 } = rawRef;
      const oldRef = oldRawRef && oldRawRef.r;
      const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
      const setupState = owner.setupState;
      if (oldRef != null && oldRef !== ref3) {
        if (isString$1(oldRef)) {
          refs[oldRef] = null;
          if (hasOwn(setupState, oldRef)) {
            setupState[oldRef] = null;
          }
        } else if (isRef(oldRef)) {
          oldRef.value = null;
        }
      }
      if (isFunction$1(ref3)) {
        callWithErrorHandling(ref3, owner, 12, [value, refs]);
      } else {
        const _isString = isString$1(ref3);
        const _isRef = isRef(ref3);
        if (_isString || _isRef) {
          const doSet = () => {
            if (rawRef.f) {
              const existing = _isString ? hasOwn(setupState, ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
              if (isUnmount) {
                isArray$1(existing) && remove(existing, refValue);
              } else {
                if (!isArray$1(existing)) {
                  if (_isString) {
                    refs[ref3] = [refValue];
                    if (hasOwn(setupState, ref3)) {
                      setupState[ref3] = refs[ref3];
                    }
                  } else {
                    ref3.value = [refValue];
                    if (rawRef.k)
                      refs[rawRef.k] = ref3.value;
                  }
                } else if (!existing.includes(refValue)) {
                  existing.push(refValue);
                }
              }
            } else if (_isString) {
              refs[ref3] = value;
              if (hasOwn(setupState, ref3)) {
                setupState[ref3] = value;
              }
            } else if (_isRef) {
              ref3.value = value;
              if (rawRef.k)
                refs[rawRef.k] = value;
            } else
              ;
          };
          if (value) {
            doSet.id = -1;
            queuePostRenderEffect(doSet, parentSuspense);
          } else {
            doSet();
          }
        }
      }
    }
    const queuePostRenderEffect = queueEffectWithSuspense;
    function createRenderer(options) {
      return baseCreateRenderer(options);
    }
    function baseCreateRenderer(options, createHydrationFns) {
      const target2 = getGlobalThis();
      target2.__VUE__ = true;
      const {
        insert: hostInsert,
        remove: hostRemove,
        patchProp: hostPatchProp,
        createElement: hostCreateElement,
        createText: hostCreateText,
        createComment: hostCreateComment,
        setText: hostSetText,
        setElementText: hostSetElementText,
        parentNode: hostParentNode,
        nextSibling: hostNextSibling,
        setScopeId: hostSetScopeId = NOOP,
        insertStaticContent: hostInsertStaticContent
      } = options;
      const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
        if (n1 === n2) {
          return;
        }
        if (n1 && !isSameVNodeType(n1, n2)) {
          anchor = getNextHostNode(n1);
          unmount(n1, parentComponent, parentSuspense, true);
          n1 = null;
        }
        if (n2.patchFlag === -2) {
          optimized = false;
          n2.dynamicChildren = null;
        }
        const { type: type2, ref: ref3, shapeFlag } = n2;
        switch (type2) {
          case Text$1:
            processText(n1, n2, container, anchor);
            break;
          case Comment:
            processCommentNode(n1, n2, container, anchor);
            break;
          case Static:
            if (n1 == null) {
              mountStaticNode(n2, container, anchor, namespace);
            }
            break;
          case Fragment:
            processFragment(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            break;
          default:
            if (shapeFlag & 1) {
              processElement(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 6) {
              processComponent(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 64) {
              type2.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                internals
              );
            } else if (shapeFlag & 128) {
              type2.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                internals
              );
            } else
              ;
        }
        if (ref3 != null && parentComponent) {
          setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
        }
      };
      const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateText(n2.children),
            container,
            anchor
          );
        } else {
          const el2 = n2.el = n1.el;
          if (n2.children !== n1.children) {
            hostSetText(el2, n2.children);
          }
        }
      };
      const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateComment(n2.children || ""),
            container,
            anchor
          );
        } else {
          n2.el = n1.el;
        }
      };
      const mountStaticNode = (n2, container, anchor, namespace) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          namespace,
          n2.el,
          n2.anchor
        );
      };
      const moveStaticNode = ({ el: el2, anchor }, container, nextSibling) => {
        let next2;
        while (el2 && el2 !== anchor) {
          next2 = hostNextSibling(el2);
          hostInsert(el2, container, nextSibling);
          el2 = next2;
        }
        hostInsert(anchor, container, nextSibling);
      };
      const removeStaticNode = ({ el: el2, anchor }) => {
        let next2;
        while (el2 && el2 !== anchor) {
          next2 = hostNextSibling(el2);
          hostRemove(el2);
          el2 = next2;
        }
        hostRemove(anchor);
      };
      const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        if (n2.type === "svg") {
          namespace = "svg";
        } else if (n2.type === "math") {
          namespace = "mathml";
        }
        if (n1 == null) {
          mountElement(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          patchElement(
            n1,
            n2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        let el2;
        let vnodeHook;
        const { props, shapeFlag, transition, dirs } = vnode;
        el2 = vnode.el = hostCreateElement(
          vnode.type,
          namespace,
          props && props.is,
          props
        );
        if (shapeFlag & 8) {
          hostSetElementText(el2, vnode.children);
        } else if (shapeFlag & 16) {
          mountChildren(
            vnode.children,
            el2,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(vnode, namespace),
            slotScopeIds,
            optimized
          );
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        setScopeId(el2, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
          for (const key in props) {
            if (key !== "value" && !isReservedProp(key)) {
              hostPatchProp(
                el2,
                key,
                null,
                props[key],
                namespace,
                vnode.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
          if ("value" in props) {
            hostPatchProp(el2, "value", null, props.value, namespace);
          }
          if (vnodeHook = props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        const needCallTransitionHooks = needTransition(parentSuspense, transition);
        if (needCallTransitionHooks) {
          transition.beforeEnter(el2);
        }
        hostInsert(el2, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el2);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
      };
      const setScopeId = (el2, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
          hostSetScopeId(el2, scopeId);
        }
        if (slotScopeIds) {
          for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
            hostSetScopeId(el2, slotScopeIds[i2]);
          }
        }
        if (parentComponent) {
          let subTree = parentComponent.subTree;
          if (vnode === subTree) {
            const parentVNode = parentComponent.vnode;
            setScopeId(
              el2,
              parentVNode,
              parentVNode.scopeId,
              parentVNode.slotScopeIds,
              parentComponent.parent
            );
          }
        }
      };
      const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
        for (let i2 = start; i2 < children.length; i2++) {
          const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
          patch(
            null,
            child,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        const el2 = n2.el = n1.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n1.patchFlag & 16;
        const oldProps = n1.props || EMPTY_OBJ;
        const newProps = n2.props || EMPTY_OBJ;
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
          invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
        }
        parentComponent && toggleRecurse(parentComponent, true);
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            el2,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace),
            slotScopeIds
          );
        } else if (!optimized) {
          patchChildren(
            n1,
            n2,
            el2,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace),
            slotScopeIds,
            false
          );
        }
        if (patchFlag > 0) {
          if (patchFlag & 16) {
            patchProps(
              el2,
              n2,
              oldProps,
              newProps,
              parentComponent,
              parentSuspense,
              namespace
            );
          } else {
            if (patchFlag & 2) {
              if (oldProps.class !== newProps.class) {
                hostPatchProp(el2, "class", null, newProps.class, namespace);
              }
            }
            if (patchFlag & 4) {
              hostPatchProp(el2, "style", oldProps.style, newProps.style, namespace);
            }
            if (patchFlag & 8) {
              const propsToUpdate = n2.dynamicProps;
              for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
                const key = propsToUpdate[i2];
                const prev = oldProps[key];
                const next2 = newProps[key];
                if (next2 !== prev || key === "value") {
                  hostPatchProp(
                    el2,
                    key,
                    prev,
                    next2,
                    namespace,
                    n1.children,
                    parentComponent,
                    parentSuspense,
                    unmountChildren
                  );
                }
              }
            }
          }
          if (patchFlag & 1) {
            if (n1.children !== n2.children) {
              hostSetElementText(el2, n2.children);
            }
          }
        } else if (!optimized && dynamicChildren == null) {
          patchProps(
            el2,
            n2,
            oldProps,
            newProps,
            parentComponent,
            parentSuspense,
            namespace
          );
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
          }, parentSuspense);
        }
      };
      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
        for (let i2 = 0; i2 < newChildren.length; i2++) {
          const oldVNode = oldChildren[i2];
          const newVNode = newChildren[i2];
          const container = (
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
              // In other cases, the parent container is not actually used so we
              // just pass the block element here to avoid a DOM parentNode call.
              fallbackContainer
            )
          );
          patch(
            oldVNode,
            newVNode,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            true
          );
        }
      };
      const patchProps = (el2, vnode, oldProps, newProps, parentComponent, parentSuspense, namespace) => {
        if (oldProps !== newProps) {
          if (oldProps !== EMPTY_OBJ) {
            for (const key in oldProps) {
              if (!isReservedProp(key) && !(key in newProps)) {
                hostPatchProp(
                  el2,
                  key,
                  oldProps[key],
                  null,
                  namespace,
                  vnode.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
          }
          for (const key in newProps) {
            if (isReservedProp(key))
              continue;
            const next2 = newProps[key];
            const prev = oldProps[key];
            if (next2 !== prev && key !== "value") {
              hostPatchProp(
                el2,
                key,
                prev,
                next2,
                namespace,
                vnode.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
          if ("value" in newProps) {
            hostPatchProp(el2, "value", oldProps.value, newProps.value, namespace);
          }
        }
      };
      const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        if (n1 == null) {
          hostInsert(fragmentStartAnchor, container, anchor);
          hostInsert(fragmentEndAnchor, container, anchor);
          mountChildren(
            // #10007
            // such fragment like `<></>` will be compiled into
            // a fragment which doesn't have a children.
            // In this case fallback to an empty array
            n2.children || [],
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
          // of renderSlot() with no valid children
          n1.dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              container,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds
            );
            if (
              // #2080 if the stable fragment has a key, it's a <template v-for> that may
              //  get moved around. Make sure all root level vnodes inherit el.
              // #2134 or if it's a component root, it may also get moved around
              // as the component is being moved.
              n2.key != null || parentComponent && n2 === parentComponent.subTree
            ) {
              traverseStaticChildren(
                n1,
                n2,
                true
                /* shallow */
              );
            }
          } else {
            patchChildren(
              n1,
              n2,
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      };
      const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
          if (n2.shapeFlag & 512) {
            parentComponent.ctx.activate(
              n2,
              container,
              anchor,
              namespace,
              optimized
            );
          } else {
            mountComponent(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              optimized
            );
          }
        } else {
          updateComponent(n1, n2, optimized);
        }
      };
      const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
        const instance = initialVNode.component = createComponentInstance(
          initialVNode,
          parentComponent,
          parentSuspense
        );
        if (isKeepAlive(initialVNode)) {
          instance.ctx.renderer = internals;
        }
        {
          setupComponent(instance);
        }
        if (instance.asyncDep) {
          parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
          if (!initialVNode.el) {
            const placeholder = instance.subTree = createVNode(Comment);
            processCommentNode(null, placeholder, container, anchor);
          }
        } else {
          setupRenderEffect(
            instance,
            initialVNode,
            container,
            anchor,
            parentSuspense,
            namespace,
            optimized
          );
        }
      };
      const updateComponent = (n1, n2, optimized) => {
        const instance = n2.component = n1.component;
        if (shouldUpdateComponent(n1, n2, optimized)) {
          if (instance.asyncDep && !instance.asyncResolved) {
            updateComponentPreRender(instance, n2, optimized);
            return;
          } else {
            instance.next = n2;
            invalidateJob(instance.update);
            instance.effect.dirty = true;
            instance.update();
          }
        } else {
          n2.el = n1.el;
          instance.vnode = n2;
        }
      };
      const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
        const componentUpdateFn = () => {
          if (!instance.isMounted) {
            let vnodeHook;
            const { el: el2, props } = initialVNode;
            const { bm, m, parent } = instance;
            const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
            toggleRecurse(instance, false);
            if (bm) {
              invokeArrayFns(bm);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
              invokeVNodeHook(vnodeHook, parent, initialVNode);
            }
            toggleRecurse(instance, true);
            if (el2 && hydrateNode) {
              const hydrateSubTree = () => {
                instance.subTree = renderComponentRoot(instance);
                hydrateNode(
                  el2,
                  instance.subTree,
                  instance,
                  parentSuspense,
                  null
                );
              };
              if (isAsyncWrapperVNode) {
                initialVNode.type.__asyncLoader().then(
                  // note: we are moving the render call into an async callback,
                  // which means it won't track dependencies - but it's ok because
                  // a server-rendered async wrapper is already in resolved state
                  // and it will never need to change.
                  () => !instance.isUnmounted && hydrateSubTree()
                );
              } else {
                hydrateSubTree();
              }
            } else {
              const subTree = instance.subTree = renderComponentRoot(instance);
              patch(
                null,
                subTree,
                container,
                anchor,
                instance,
                parentSuspense,
                namespace
              );
              initialVNode.el = subTree.el;
            }
            if (m) {
              queuePostRenderEffect(m, parentSuspense);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
              const scopedInitialVNode = initialVNode;
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                parentSuspense
              );
            }
            if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
              instance.a && queuePostRenderEffect(instance.a, parentSuspense);
            }
            instance.isMounted = true;
            initialVNode = container = anchor = null;
          } else {
            let { next: next2, bu, u, parent, vnode } = instance;
            {
              const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
              if (nonHydratedAsyncRoot) {
                if (next2) {
                  next2.el = vnode.el;
                  updateComponentPreRender(instance, next2, optimized);
                }
                nonHydratedAsyncRoot.asyncDep.then(() => {
                  if (!instance.isUnmounted) {
                    componentUpdateFn();
                  }
                });
                return;
              }
            }
            let originNext = next2;
            let vnodeHook;
            toggleRecurse(instance, false);
            if (next2) {
              next2.el = vnode.el;
              updateComponentPreRender(instance, next2, optimized);
            } else {
              next2 = vnode;
            }
            if (bu) {
              invokeArrayFns(bu);
            }
            if (vnodeHook = next2.props && next2.props.onVnodeBeforeUpdate) {
              invokeVNodeHook(vnodeHook, parent, next2, vnode);
            }
            toggleRecurse(instance, true);
            const nextTree = renderComponentRoot(instance);
            const prevTree = instance.subTree;
            instance.subTree = nextTree;
            patch(
              prevTree,
              nextTree,
              // parent may have changed if it's in a teleport
              hostParentNode(prevTree.el),
              // anchor may have changed if it's in a fragment
              getNextHostNode(prevTree),
              instance,
              parentSuspense,
              namespace
            );
            next2.el = nextTree.el;
            if (originNext === null) {
              updateHOCHostEl(instance, nextTree.el);
            }
            if (u) {
              queuePostRenderEffect(u, parentSuspense);
            }
            if (vnodeHook = next2.props && next2.props.onVnodeUpdated) {
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, next2, vnode),
                parentSuspense
              );
            }
          }
        };
        const effect2 = instance.effect = new ReactiveEffect(
          componentUpdateFn,
          NOOP,
          () => queueJob(update),
          instance.scope
          // track it in component's effect scope
        );
        const update = instance.update = () => {
          if (effect2.dirty) {
            effect2.run();
          }
        };
        update.id = instance.uid;
        toggleRecurse(instance, true);
        update();
      };
      const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        pauseTracking();
        flushPreFlushCbs(instance);
        resetTracking();
      };
      const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
          if (patchFlag & 128) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            return;
          } else if (patchFlag & 256) {
            patchUnkeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            return;
          }
        }
        if (shapeFlag & 8) {
          if (prevShapeFlag & 16) {
            unmountChildren(c1, parentComponent, parentSuspense);
          }
          if (c2 !== c1) {
            hostSetElementText(container, c2);
          }
        } else {
          if (prevShapeFlag & 16) {
            if (shapeFlag & 16) {
              patchKeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else {
              unmountChildren(c1, parentComponent, parentSuspense, true);
            }
          } else {
            if (prevShapeFlag & 8) {
              hostSetElementText(container, "");
            }
            if (shapeFlag & 16) {
              mountChildren(
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            }
          }
        }
      };
      const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        c1 = c1 || EMPTY_ARR;
        c2 = c2 || EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i2;
        for (i2 = 0; i2 < commonLength; i2++) {
          const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
          patch(
            c1[i2],
            nextChild,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
        if (oldLength > newLength) {
          unmountChildren(
            c1,
            parentComponent,
            parentSuspense,
            true,
            false,
            commonLength
          );
        } else {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            commonLength
          );
        }
      };
      const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        let i2 = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1;
        let e2 = l2 - 1;
        while (i2 <= e1 && i2 <= e2) {
          const n1 = c1[i2];
          const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          i2++;
        }
        while (i2 <= e1 && i2 <= e2) {
          const n1 = c1[e1];
          const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          e1--;
          e2--;
        }
        if (i2 > e1) {
          if (i2 <= e2) {
            const nextPos = e2 + 1;
            const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
            while (i2 <= e2) {
              patch(
                null,
                c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]),
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              i2++;
            }
          }
        } else if (i2 > e2) {
          while (i2 <= e1) {
            unmount(c1[i2], parentComponent, parentSuspense, true);
            i2++;
          }
        } else {
          const s1 = i2;
          const s2 = i2;
          const keyToNewIndexMap = /* @__PURE__ */ new Map();
          for (i2 = s2; i2 <= e2; i2++) {
            const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
            if (nextChild.key != null) {
              keyToNewIndexMap.set(nextChild.key, i2);
            }
          }
          let j;
          let patched = 0;
          const toBePatched = e2 - s2 + 1;
          let moved = false;
          let maxNewIndexSoFar = 0;
          const newIndexToOldIndexMap = new Array(toBePatched);
          for (i2 = 0; i2 < toBePatched; i2++)
            newIndexToOldIndexMap[i2] = 0;
          for (i2 = s1; i2 <= e1; i2++) {
            const prevChild = c1[i2];
            if (patched >= toBePatched) {
              unmount(prevChild, parentComponent, parentSuspense, true);
              continue;
            }
            let newIndex;
            if (prevChild.key != null) {
              newIndex = keyToNewIndexMap.get(prevChild.key);
            } else {
              for (j = s2; j <= e2; j++) {
                if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                  newIndex = j;
                  break;
                }
              }
            }
            if (newIndex === void 0) {
              unmount(prevChild, parentComponent, parentSuspense, true);
            } else {
              newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
              if (newIndex >= maxNewIndexSoFar) {
                maxNewIndexSoFar = newIndex;
              } else {
                moved = true;
              }
              patch(
                prevChild,
                c2[newIndex],
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              patched++;
            }
          }
          const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
          j = increasingNewIndexSequence.length - 1;
          for (i2 = toBePatched - 1; i2 >= 0; i2--) {
            const nextIndex = s2 + i2;
            const nextChild = c2[nextIndex];
            const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
            if (newIndexToOldIndexMap[i2] === 0) {
              patch(
                null,
                nextChild,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (moved) {
              if (j < 0 || i2 !== increasingNewIndexSequence[j]) {
                move(nextChild, container, anchor, 2);
              } else {
                j--;
              }
            }
          }
        }
      };
      const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el: el2, type: type2, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
          move(vnode.component.subTree, container, anchor, moveType);
          return;
        }
        if (shapeFlag & 128) {
          vnode.suspense.move(container, anchor, moveType);
          return;
        }
        if (shapeFlag & 64) {
          type2.move(vnode, container, anchor, internals);
          return;
        }
        if (type2 === Fragment) {
          hostInsert(el2, container, anchor);
          for (let i2 = 0; i2 < children.length; i2++) {
            move(children[i2], container, anchor, moveType);
          }
          hostInsert(vnode.anchor, container, anchor);
          return;
        }
        if (type2 === Static) {
          moveStaticNode(vnode, container, anchor);
          return;
        }
        const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition2) {
          if (moveType === 0) {
            transition.beforeEnter(el2);
            hostInsert(el2, container, anchor);
            queuePostRenderEffect(() => transition.enter(el2), parentSuspense);
          } else {
            const { leave, delayLeave, afterLeave } = transition;
            const remove22 = () => hostInsert(el2, container, anchor);
            const performLeave = () => {
              leave(el2, () => {
                remove22();
                afterLeave && afterLeave();
              });
            };
            if (delayLeave) {
              delayLeave(el2, remove22, performLeave);
            } else {
              performLeave();
            }
          }
        } else {
          hostInsert(el2, container, anchor);
        }
      };
      const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const {
          type: type2,
          props,
          ref: ref3,
          children,
          dynamicChildren,
          shapeFlag,
          patchFlag,
          dirs
        } = vnode;
        if (ref3 != null) {
          setRef(ref3, null, parentSuspense, vnode, true);
        }
        if (shapeFlag & 256) {
          parentComponent.ctx.deactivate(vnode);
          return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6) {
          unmountComponent(vnode.component, parentSuspense, doRemove);
        } else {
          if (shapeFlag & 128) {
            vnode.suspense.unmount(parentSuspense, doRemove);
            return;
          }
          if (shouldInvokeDirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
          }
          if (shapeFlag & 64) {
            vnode.type.remove(
              vnode,
              parentComponent,
              parentSuspense,
              optimized,
              internals,
              doRemove
            );
          } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
          (type2 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
            unmountChildren(
              dynamicChildren,
              parentComponent,
              parentSuspense,
              false,
              true
            );
          } else if (type2 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
            unmountChildren(children, parentComponent, parentSuspense);
          }
          if (doRemove) {
            remove2(vnode);
          }
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
          }, parentSuspense);
        }
      };
      const remove2 = (vnode) => {
        const { type: type2, el: el2, anchor, transition } = vnode;
        if (type2 === Fragment) {
          {
            removeFragment(el2, anchor);
          }
          return;
        }
        if (type2 === Static) {
          removeStaticNode(vnode);
          return;
        }
        const performRemove = () => {
          hostRemove(el2);
          if (transition && !transition.persisted && transition.afterLeave) {
            transition.afterLeave();
          }
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
          const { leave, delayLeave } = transition;
          const performLeave = () => leave(el2, performRemove);
          if (delayLeave) {
            delayLeave(vnode.el, performRemove, performLeave);
          } else {
            performLeave();
          }
        } else {
          performRemove();
        }
      };
      const removeFragment = (cur, end) => {
        let next2;
        while (cur !== end) {
          next2 = hostNextSibling(cur);
          hostRemove(cur);
          cur = next2;
        }
        hostRemove(end);
      };
      const unmountComponent = (instance, parentSuspense, doRemove) => {
        const { bum, scope: scope2, update, subTree, um } = instance;
        if (bum) {
          invokeArrayFns(bum);
        }
        scope2.stop();
        if (update) {
          update.active = false;
          unmount(subTree, instance, parentSuspense, doRemove);
        }
        if (um) {
          queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
          instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0) {
            parentSuspense.resolve();
          }
        }
      };
      const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
        for (let i2 = start; i2 < children.length; i2++) {
          unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
        }
      };
      const getNextHostNode = (vnode) => {
        if (vnode.shapeFlag & 6) {
          return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128) {
          return vnode.suspense.next();
        }
        return hostNextSibling(vnode.anchor || vnode.el);
      };
      let isFlushing2 = false;
      const render = (vnode, container, namespace) => {
        if (vnode == null) {
          if (container._vnode) {
            unmount(container._vnode, null, null, true);
          }
        } else {
          patch(
            container._vnode || null,
            vnode,
            container,
            null,
            null,
            null,
            namespace
          );
        }
        if (!isFlushing2) {
          isFlushing2 = true;
          flushPreFlushCbs();
          flushPostFlushCbs();
          isFlushing2 = false;
        }
        container._vnode = vnode;
      };
      const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove2,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
      };
      let hydrate;
      let hydrateNode;
      if (createHydrationFns) {
        [hydrate, hydrateNode] = createHydrationFns(
          internals
        );
      }
      return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
      };
    }
    function resolveChildrenNamespace({ type: type2, props }, currentNamespace) {
      return currentNamespace === "svg" && type2 === "foreignObject" || currentNamespace === "mathml" && type2 === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
    }
    function toggleRecurse({ effect: effect2, update }, allowed) {
      effect2.allowRecurse = update.allowRecurse = allowed;
    }
    function needTransition(parentSuspense, transition) {
      return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    }
    function traverseStaticChildren(n1, n2, shallow = false) {
      const ch1 = n1.children;
      const ch2 = n2.children;
      if (isArray$1(ch1) && isArray$1(ch2)) {
        for (let i2 = 0; i2 < ch1.length; i2++) {
          const c1 = ch1[i2];
          let c2 = ch2[i2];
          if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
              c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
              c2.el = c1.el;
            }
            if (!shallow)
              traverseStaticChildren(c1, c2);
          }
          if (c2.type === Text$1) {
            c2.el = c1.el;
          }
        }
      }
    }
    function getSequence(arr) {
      const p2 = arr.slice();
      const result = [0];
      let i2, j, u, v, c;
      const len = arr.length;
      for (i2 = 0; i2 < len; i2++) {
        const arrI = arr[i2];
        if (arrI !== 0) {
          j = result[result.length - 1];
          if (arr[j] < arrI) {
            p2[i2] = j;
            result.push(i2);
            continue;
          }
          u = 0;
          v = result.length - 1;
          while (u < v) {
            c = u + v >> 1;
            if (arr[result[c]] < arrI) {
              u = c + 1;
            } else {
              v = c;
            }
          }
          if (arrI < arr[result[u]]) {
            if (u > 0) {
              p2[i2] = result[u - 1];
            }
            result[u] = i2;
          }
        }
      }
      u = result.length;
      v = result[u - 1];
      while (u-- > 0) {
        result[u] = v;
        v = p2[v];
      }
      return result;
    }
    function locateNonHydratedAsyncRoot(instance) {
      const subComponent = instance.subTree.component;
      if (subComponent) {
        if (subComponent.asyncDep && !subComponent.asyncResolved) {
          return subComponent;
        } else {
          return locateNonHydratedAsyncRoot(subComponent);
        }
      }
    }
    const isTeleport = (type2) => type2.__isTeleport;
    const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
    const isTargetSVG = (target2) => typeof SVGElement !== "undefined" && target2 instanceof SVGElement;
    const isTargetMathML = (target2) => typeof MathMLElement === "function" && target2 instanceof MathMLElement;
    const resolveTarget = (props, select) => {
      const targetSelector = props && props.to;
      if (isString$1(targetSelector)) {
        if (!select) {
          return null;
        } else {
          const target2 = select(targetSelector);
          return target2;
        }
      } else {
        return targetSelector;
      }
    };
    const TeleportImpl = {
      name: "Teleport",
      __isTeleport: true,
      process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
        const {
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          o: { insert, querySelector, createText, createComment }
        } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        if (n1 == null) {
          const placeholder = n2.el = createText("");
          const mainAnchor = n2.anchor = createText("");
          insert(placeholder, container, anchor);
          insert(mainAnchor, container, anchor);
          const target2 = n2.target = resolveTarget(n2.props, querySelector);
          const targetAnchor = n2.targetAnchor = createText("");
          if (target2) {
            insert(targetAnchor, target2);
            if (namespace === "svg" || isTargetSVG(target2)) {
              namespace = "svg";
            } else if (namespace === "mathml" || isTargetMathML(target2)) {
              namespace = "mathml";
            }
          }
          const mount = (container2, anchor2) => {
            if (shapeFlag & 16) {
              mountChildren(
                children,
                container2,
                anchor2,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            }
          };
          if (disabled) {
            mount(container, mainAnchor);
          } else if (target2) {
            mount(target2, targetAnchor);
          }
        } else {
          n2.el = n1.el;
          const mainAnchor = n2.anchor = n1.anchor;
          const target2 = n2.target = n1.target;
          const targetAnchor = n2.targetAnchor = n1.targetAnchor;
          const wasDisabled = isTeleportDisabled(n1.props);
          const currentContainer = wasDisabled ? container : target2;
          const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
          if (namespace === "svg" || isTargetSVG(target2)) {
            namespace = "svg";
          } else if (namespace === "mathml" || isTargetMathML(target2)) {
            namespace = "mathml";
          }
          if (dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              currentContainer,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds
            );
            traverseStaticChildren(n1, n2, true);
          } else if (!optimized) {
            patchChildren(
              n1,
              n2,
              currentContainer,
              currentAnchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              false
            );
          }
          if (disabled) {
            if (!wasDisabled) {
              moveTeleport(
                n2,
                container,
                mainAnchor,
                internals,
                1
              );
            } else {
              if (n2.props && n1.props && n2.props.to !== n1.props.to) {
                n2.props.to = n1.props.to;
              }
            }
          } else {
            if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
              const nextTarget = n2.target = resolveTarget(
                n2.props,
                querySelector
              );
              if (nextTarget) {
                moveTeleport(
                  n2,
                  nextTarget,
                  null,
                  internals,
                  0
                );
              }
            } else if (wasDisabled) {
              moveTeleport(
                n2,
                target2,
                targetAnchor,
                internals,
                1
              );
            }
          }
        }
        updateCssVars(n2);
      },
      remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const { shapeFlag, children, anchor, targetAnchor, target: target2, props } = vnode;
        if (target2) {
          hostRemove(targetAnchor);
        }
        doRemove && hostRemove(anchor);
        if (shapeFlag & 16) {
          const shouldRemove = doRemove || !isTeleportDisabled(props);
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            unmount(
              child,
              parentComponent,
              parentSuspense,
              shouldRemove,
              !!child.dynamicChildren
            );
          }
        }
      },
      move: moveTeleport,
      hydrate: hydrateTeleport
    };
    function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
      if (moveType === 0) {
        insert(vnode.targetAnchor, container, parentAnchor);
      }
      const { el: el2, anchor, shapeFlag, children, props } = vnode;
      const isReorder = moveType === 2;
      if (isReorder) {
        insert(el2, container, parentAnchor);
      }
      if (!isReorder || isTeleportDisabled(props)) {
        if (shapeFlag & 16) {
          for (let i2 = 0; i2 < children.length; i2++) {
            move(
              children[i2],
              container,
              parentAnchor,
              2
            );
          }
        }
      }
      if (isReorder) {
        insert(anchor, container, parentAnchor);
      }
    }
    function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
      o: { nextSibling, parentNode, querySelector }
    }, hydrateChildren) {
      const target2 = vnode.target = resolveTarget(
        vnode.props,
        querySelector
      );
      if (target2) {
        const targetNode = target2._lpa || target2.firstChild;
        if (vnode.shapeFlag & 16) {
          if (isTeleportDisabled(vnode.props)) {
            vnode.anchor = hydrateChildren(
              nextSibling(node),
              vnode,
              parentNode(node),
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
            vnode.targetAnchor = targetNode;
          } else {
            vnode.anchor = nextSibling(node);
            let targetAnchor = targetNode;
            while (targetAnchor) {
              targetAnchor = nextSibling(targetAnchor);
              if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
                vnode.targetAnchor = targetAnchor;
                target2._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                break;
              }
            }
            hydrateChildren(
              targetNode,
              vnode,
              target2,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        }
        updateCssVars(vnode);
      }
      return vnode.anchor && nextSibling(vnode.anchor);
    }
    const Teleport = TeleportImpl;
    function updateCssVars(vnode) {
      const ctx = vnode.ctx;
      if (ctx && ctx.ut) {
        let node = vnode.children[0].el;
        while (node && node !== vnode.targetAnchor) {
          if (node.nodeType === 1)
            node.setAttribute("data-v-owner", ctx.uid);
          node = node.nextSibling;
        }
        ctx.ut();
      }
    }
    const Fragment = Symbol.for("v-fgt");
    const Text$1 = Symbol.for("v-txt");
    const Comment = Symbol.for("v-cmt");
    const Static = Symbol.for("v-stc");
    const blockStack = [];
    let currentBlock = null;
    function openBlock(disableTracking = false) {
      blockStack.push(currentBlock = disableTracking ? null : []);
    }
    function closeBlock() {
      blockStack.pop();
      currentBlock = blockStack[blockStack.length - 1] || null;
    }
    let isBlockTreeEnabled = 1;
    function setBlockTracking(value) {
      isBlockTreeEnabled += value;
    }
    function setupBlock(vnode) {
      vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
      closeBlock();
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    function createElementBlock(type2, props, children, patchFlag, dynamicProps, shapeFlag) {
      return setupBlock(
        createBaseVNode(
          type2,
          props,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag,
          true
        )
      );
    }
    function createBlock(type2, props, children, patchFlag, dynamicProps) {
      return setupBlock(
        createVNode(
          type2,
          props,
          children,
          patchFlag,
          dynamicProps,
          true
        )
      );
    }
    function isVNode(value) {
      return value ? value.__v_isVNode === true : false;
    }
    function isSameVNodeType(n1, n2) {
      return n1.type === n2.type && n1.key === n2.key;
    }
    const InternalObjectKey = `__vInternal`;
    const normalizeKey = ({ key }) => key != null ? key : null;
    const normalizeRef = ({
      ref: ref3,
      ref_key,
      ref_for
    }) => {
      if (typeof ref3 === "number") {
        ref3 = "" + ref3;
      }
      return ref3 != null ? isString$1(ref3) || isRef(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
    };
    function createBaseVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type2 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
      const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type: type2,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
      };
      if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) {
          type2.normalize(vnode);
        }
      } else if (children) {
        vnode.shapeFlag |= isString$1(children) ? 8 : 16;
      }
      if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
      !isBlockNode && // has current parent block
      currentBlock && // presence of a patch flag indicates this node needs patching on updates.
      // component nodes also should always be patched, because even if the
      // component doesn't need to update, it needs to persist the instance on to
      // the next vnode so that it can be properly unmounted later.
      (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
      // vnode should not be considered dynamic due to handler caching.
      vnode.patchFlag !== 32) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    const createVNode = _createVNode;
    function _createVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
      if (!type2 || type2 === NULL_DYNAMIC_COMPONENT) {
        type2 = Comment;
      }
      if (isVNode(type2)) {
        const cloned = cloneVNode(
          type2,
          props,
          true
          /* mergeRef: true */
        );
        if (children) {
          normalizeChildren(cloned, children);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
          if (cloned.shapeFlag & 6) {
            currentBlock[currentBlock.indexOf(type2)] = cloned;
          } else {
            currentBlock.push(cloned);
          }
        }
        cloned.patchFlag |= -2;
        return cloned;
      }
      if (isClassComponent(type2)) {
        type2 = type2.__vccOpts;
      }
      if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !isString$1(klass)) {
          props.class = normalizeClass(klass);
        }
        if (isObject$3(style)) {
          if (isProxy(style) && !isArray$1(style)) {
            style = extend({}, style);
          }
          props.style = normalizeStyle(style);
        }
      }
      const shapeFlag = isString$1(type2) ? 1 : isSuspense(type2) ? 128 : isTeleport(type2) ? 64 : isObject$3(type2) ? 4 : isFunction$1(type2) ? 2 : 0;
      return createBaseVNode(
        type2,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        isBlockNode,
        true
      );
    }
    function guardReactiveProps(props) {
      if (!props)
        return null;
      return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
    }
    function cloneVNode(vnode, extraProps, mergeRef = false) {
      const { props, ref: ref3, patchFlag, children } = vnode;
      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
      const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? (
          // #2078 in the case of <component :is="vnode" ref="extra"/>
          // if the vnode itself already has a ref, cloneVNode will need to merge
          // the refs so the single vnode can be set on multiple refs
          mergeRef && ref3 ? isArray$1(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
        ) : ref3,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
      };
      return cloned;
    }
    function createTextVNode(text2 = " ", flag = 0) {
      return createVNode(Text$1, null, text2, flag);
    }
    function createCommentVNode(text2 = "", asBlock = false) {
      return asBlock ? (openBlock(), createBlock(Comment, null, text2)) : createVNode(Comment, null, text2);
    }
    function normalizeVNode(child) {
      if (child == null || typeof child === "boolean") {
        return createVNode(Comment);
      } else if (isArray$1(child)) {
        return createVNode(
          Fragment,
          null,
          // #3666, avoid reference pollution when reusing vnode
          child.slice()
        );
      } else if (typeof child === "object") {
        return cloneIfMounted(child);
      } else {
        return createVNode(Text$1, null, String(child));
      }
    }
    function cloneIfMounted(child) {
      return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
    }
    function normalizeChildren(vnode, children) {
      let type2 = 0;
      const { shapeFlag } = vnode;
      if (children == null) {
        children = null;
      } else if (isArray$1(children)) {
        type2 = 16;
      } else if (typeof children === "object") {
        if (shapeFlag & (1 | 64)) {
          const slot = children.default;
          if (slot) {
            slot._c && (slot._d = false);
            normalizeChildren(vnode, slot());
            slot._c && (slot._d = true);
          }
          return;
        } else {
          type2 = 32;
          const slotFlag = children._;
          if (!slotFlag && !(InternalObjectKey in children)) {
            children._ctx = currentRenderingInstance;
          } else if (slotFlag === 3 && currentRenderingInstance) {
            if (currentRenderingInstance.slots._ === 1) {
              children._ = 1;
            } else {
              children._ = 2;
              vnode.patchFlag |= 1024;
            }
          }
        }
      } else if (isFunction$1(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type2 = 32;
      } else {
        children = String(children);
        if (shapeFlag & 64) {
          type2 = 16;
          children = [createTextVNode(children)];
        } else {
          type2 = 8;
        }
      }
      vnode.children = children;
      vnode.shapeFlag |= type2;
    }
    function mergeProps(...args) {
      const ret = {};
      for (let i2 = 0; i2 < args.length; i2++) {
        const toMerge = args[i2];
        for (const key in toMerge) {
          if (key === "class") {
            if (ret.class !== toMerge.class) {
              ret.class = normalizeClass([ret.class, toMerge.class]);
            }
          } else if (key === "style") {
            ret.style = normalizeStyle([ret.style, toMerge.style]);
          } else if (isOn$1(key)) {
            const existing = ret[key];
            const incoming = toMerge[key];
            if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
              ret[key] = existing ? [].concat(existing, incoming) : incoming;
            }
          } else if (key !== "") {
            ret[key] = toMerge[key];
          }
        }
      }
      return ret;
    }
    function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
      callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
      ]);
    }
    const emptyAppContext = createAppContext();
    let uid = 0;
    function createComponentInstance(vnode, parent, suspense) {
      const type2 = vnode.type;
      const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
      const instance = {
        uid: uid++,
        vnode,
        type: type2,
        parent,
        appContext,
        root: null,
        // to be immediately set
        next: null,
        subTree: null,
        // will be set synchronously right after creation
        effect: null,
        update: null,
        // will be set synchronously right after creation
        scope: new EffectScope(
          true
          /* detached */
        ),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type2, appContext),
        emitsOptions: normalizeEmitsOptions(type2, appContext),
        // emit
        emit: null,
        // to be set immediately
        emitted: null,
        // props default value
        propsDefaults: EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type2.inheritAttrs,
        // state
        ctx: EMPTY_OBJ,
        data: EMPTY_OBJ,
        props: EMPTY_OBJ,
        attrs: EMPTY_OBJ,
        slots: EMPTY_OBJ,
        refs: EMPTY_OBJ,
        setupState: EMPTY_OBJ,
        setupContext: null,
        attrsProxy: null,
        slotsProxy: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
      };
      {
        instance.ctx = { _: instance };
      }
      instance.root = parent ? parent.root : instance;
      instance.emit = emit.bind(null, instance);
      if (vnode.ce) {
        vnode.ce(instance);
      }
      return instance;
    }
    let currentInstance = null;
    const getCurrentInstance$1 = () => currentInstance || currentRenderingInstance;
    let internalSetCurrentInstance;
    let setInSSRSetupState;
    {
      const g = getGlobalThis();
      const registerGlobalSetter = (key, setter) => {
        let setters;
        if (!(setters = g[key]))
          setters = g[key] = [];
        setters.push(setter);
        return (v) => {
          if (setters.length > 1)
            setters.forEach((set2) => set2(v));
          else
            setters[0](v);
        };
      };
      internalSetCurrentInstance = registerGlobalSetter(
        `__VUE_INSTANCE_SETTERS__`,
        (v) => currentInstance = v
      );
      setInSSRSetupState = registerGlobalSetter(
        `__VUE_SSR_SETTERS__`,
        (v) => isInSSRComponentSetup = v
      );
    }
    const setCurrentInstance = (instance) => {
      const prev = currentInstance;
      internalSetCurrentInstance(instance);
      instance.scope.on();
      return () => {
        instance.scope.off();
        internalSetCurrentInstance(prev);
      };
    };
    const unsetCurrentInstance = () => {
      currentInstance && currentInstance.scope.off();
      internalSetCurrentInstance(null);
    };
    function isStatefulComponent(instance) {
      return instance.vnode.shapeFlag & 4;
    }
    let isInSSRComponentSetup = false;
    function setupComponent(instance, isSSR = false) {
      isSSR && setInSSRSetupState(isSSR);
      const { props, children } = instance.vnode;
      const isStateful = isStatefulComponent(instance);
      initProps(instance, props, isStateful, isSSR);
      initSlots(instance, children);
      const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
      isSSR && setInSSRSetupState(false);
      return setupResult;
    }
    function setupStatefulComponent(instance, isSSR) {
      const Component = instance.type;
      instance.accessCache = /* @__PURE__ */ Object.create(null);
      instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
      const { setup: setup2 } = Component;
      if (setup2) {
        const setupContext = instance.setupContext = setup2.length > 1 ? createSetupContext(instance) : null;
        const reset = setCurrentInstance(instance);
        pauseTracking();
        const setupResult = callWithErrorHandling(
          setup2,
          instance,
          0,
          [
            instance.props,
            setupContext
          ]
        );
        resetTracking();
        reset();
        if (isPromise(setupResult)) {
          setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
          if (isSSR) {
            return setupResult.then((resolvedResult) => {
              handleSetupResult(instance, resolvedResult, isSSR);
            }).catch((e) => {
              handleError(e, instance, 0);
            });
          } else {
            instance.asyncDep = setupResult;
          }
        } else {
          handleSetupResult(instance, setupResult, isSSR);
        }
      } else {
        finishComponentSetup(instance, isSSR);
      }
    }
    function handleSetupResult(instance, setupResult, isSSR) {
      if (isFunction$1(setupResult)) {
        if (instance.type.__ssrInlineRender) {
          instance.ssrRender = setupResult;
        } else {
          instance.render = setupResult;
        }
      } else if (isObject$3(setupResult)) {
        instance.setupState = proxyRefs(setupResult);
      } else
        ;
      finishComponentSetup(instance, isSSR);
    }
    let compile$3;
    function finishComponentSetup(instance, isSSR, skipOptions) {
      const Component = instance.type;
      if (!instance.render) {
        if (!isSSR && compile$3 && !Component.render) {
          const template = Component.template || resolveMergedOptions(instance).template;
          if (template) {
            const { isCustomElement, compilerOptions } = instance.appContext.config;
            const { delimiters, compilerOptions: componentCompilerOptions } = Component;
            const finalCompilerOptions = extend(
              extend(
                {
                  isCustomElement,
                  delimiters
                },
                compilerOptions
              ),
              componentCompilerOptions
            );
            Component.render = compile$3(template, finalCompilerOptions);
          }
        }
        instance.render = Component.render || NOOP;
      }
      {
        const reset = setCurrentInstance(instance);
        pauseTracking();
        try {
          applyOptions(instance);
        } finally {
          resetTracking();
          reset();
        }
      }
    }
    function getAttrsProxy(instance) {
      return instance.attrsProxy || (instance.attrsProxy = new Proxy(
        instance.attrs,
        {
          get(target2, key) {
            track(instance, "get", "$attrs");
            return target2[key];
          }
        }
      ));
    }
    function createSetupContext(instance) {
      const expose = (exposed) => {
        instance.exposed = exposed || {};
      };
      {
        return {
          get attrs() {
            return getAttrsProxy(instance);
          },
          slots: instance.slots,
          emit: instance.emit,
          expose
        };
      }
    }
    function getExposeProxy(instance) {
      if (instance.exposed) {
        return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
          get(target2, key) {
            if (key in target2) {
              return target2[key];
            } else if (key in publicPropertiesMap) {
              return publicPropertiesMap[key](instance);
            }
          },
          has(target2, key) {
            return key in target2 || key in publicPropertiesMap;
          }
        }));
      }
    }
    const classifyRE = /(?:^|[-_])(\w)/g;
    const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
    function getComponentName(Component, includeInferred = true) {
      return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
    }
    function formatComponentName(instance, Component, isRoot = false) {
      let name = getComponentName(Component);
      if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
          name = match[1];
        }
      }
      if (!name && instance && instance.parent) {
        const inferFromRegistry = (registry) => {
          for (const key in registry) {
            if (registry[key] === Component) {
              return key;
            }
          }
        };
        name = inferFromRegistry(
          instance.components || instance.parent.type.components
        ) || inferFromRegistry(instance.appContext.components);
      }
      return name ? classify(name) : isRoot ? `App` : `Anonymous`;
    }
    function isClassComponent(value) {
      return isFunction$1(value) && "__vccOpts" in value;
    }
    const computed = (getterOrOptions, debugOptions) => {
      return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    };
    function h(type2, propsOrChildren, children) {
      const l = arguments.length;
      if (l === 2) {
        if (isObject$3(propsOrChildren) && !isArray$1(propsOrChildren)) {
          if (isVNode(propsOrChildren)) {
            return createVNode(type2, null, [propsOrChildren]);
          }
          return createVNode(type2, propsOrChildren);
        } else {
          return createVNode(type2, null, propsOrChildren);
        }
      } else {
        if (l > 3) {
          children = Array.prototype.slice.call(arguments, 2);
        } else if (l === 3 && isVNode(children)) {
          children = [children];
        }
        return createVNode(type2, propsOrChildren, children);
      }
    }
    const version$1 = "3.4.19";
    /**
    * @vue/runtime-dom v3.4.19
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    const svgNS = "http://www.w3.org/2000/svg";
    const mathmlNS = "http://www.w3.org/1998/Math/MathML";
    const doc = typeof document !== "undefined" ? document : null;
    const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
    const nodeOps = {
      insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
      },
      remove: (child) => {
        const parent = child.parentNode;
        if (parent) {
          parent.removeChild(child);
        }
      },
      createElement: (tag, namespace, is2, props) => {
        const el2 = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : doc.createElement(tag, is2 ? { is: is2 } : void 0);
        if (tag === "select" && props && props.multiple != null) {
          el2.setAttribute("multiple", props.multiple);
        }
        return el2;
      },
      createText: (text2) => doc.createTextNode(text2),
      createComment: (text2) => doc.createComment(text2),
      setText: (node, text2) => {
        node.nodeValue = text2;
      },
      setElementText: (el2, text2) => {
        el2.textContent = text2;
      },
      parentNode: (node) => node.parentNode,
      nextSibling: (node) => node.nextSibling,
      querySelector: (selector) => doc.querySelector(selector),
      setScopeId(el2, id2) {
        el2.setAttribute(id2, "");
      },
      // __UNSAFE__
      // Reason: innerHTML.
      // Static content here can only come from compiled templates.
      // As long as the user only uses trusted templates, this is safe.
      insertStaticContent(content2, parent, anchor, namespace, start, end) {
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        if (start && (start === end || start.nextSibling)) {
          while (true) {
            parent.insertBefore(start.cloneNode(true), anchor);
            if (start === end || !(start = start.nextSibling))
              break;
          }
        } else {
          templateContainer.innerHTML = namespace === "svg" ? `<svg>${content2}</svg>` : namespace === "mathml" ? `<math>${content2}</math>` : content2;
          const template = templateContainer.content;
          if (namespace === "svg" || namespace === "mathml") {
            const wrapper = template.firstChild;
            while (wrapper.firstChild) {
              template.appendChild(wrapper.firstChild);
            }
            template.removeChild(wrapper);
          }
          parent.insertBefore(template, anchor);
        }
        return [
          // first
          before ? before.nextSibling : parent.firstChild,
          // last
          anchor ? anchor.previousSibling : parent.lastChild
        ];
      }
    };
    const TRANSITION = "transition";
    const ANIMATION = "animation";
    const vtcKey = Symbol("_vtc");
    const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
    Transition.displayName = "Transition";
    const DOMTransitionPropsValidators = {
      name: String,
      type: String,
      css: {
        type: Boolean,
        default: true
      },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String
    };
    const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend(
      {},
      BaseTransitionPropsValidators,
      DOMTransitionPropsValidators
    );
    const callHook = (hook, args = []) => {
      if (isArray$1(hook)) {
        hook.forEach((h2) => h2(...args));
      } else if (hook) {
        hook(...args);
      }
    };
    const hasExplicitCallback = (hook) => {
      return hook ? isArray$1(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
    };
    function resolveTransitionProps(rawProps) {
      const baseProps = {};
      for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
          baseProps[key] = rawProps[key];
        }
      }
      if (rawProps.css === false) {
        return baseProps;
      }
      const {
        name = "v",
        type: type2,
        duration,
        enterFromClass = `${name}-enter-from`,
        enterActiveClass = `${name}-enter-active`,
        enterToClass = `${name}-enter-to`,
        appearFromClass = enterFromClass,
        appearActiveClass = enterActiveClass,
        appearToClass = enterToClass,
        leaveFromClass = `${name}-leave-from`,
        leaveActiveClass = `${name}-leave-active`,
        leaveToClass = `${name}-leave-to`
      } = rawProps;
      const durations = normalizeDuration(duration);
      const enterDuration = durations && durations[0];
      const leaveDuration = durations && durations[1];
      const {
        onBeforeEnter,
        onEnter,
        onEnterCancelled,
        onLeave,
        onLeaveCancelled,
        onBeforeAppear = onBeforeEnter,
        onAppear = onEnter,
        onAppearCancelled = onEnterCancelled
      } = baseProps;
      const finishEnter = (el2, isAppear, done) => {
        removeTransitionClass(el2, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el2, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
      };
      const finishLeave = (el2, done) => {
        el2._isLeaving = false;
        removeTransitionClass(el2, leaveFromClass);
        removeTransitionClass(el2, leaveToClass);
        removeTransitionClass(el2, leaveActiveClass);
        done && done();
      };
      const makeEnterHook = (isAppear) => {
        return (el2, done) => {
          const hook = isAppear ? onAppear : onEnter;
          const resolve2 = () => finishEnter(el2, isAppear, done);
          callHook(hook, [el2, resolve2]);
          nextFrame(() => {
            removeTransitionClass(el2, isAppear ? appearFromClass : enterFromClass);
            addTransitionClass(el2, isAppear ? appearToClass : enterToClass);
            if (!hasExplicitCallback(hook)) {
              whenTransitionEnds(el2, type2, enterDuration, resolve2);
            }
          });
        };
      };
      return extend(baseProps, {
        onBeforeEnter(el2) {
          callHook(onBeforeEnter, [el2]);
          addTransitionClass(el2, enterFromClass);
          addTransitionClass(el2, enterActiveClass);
        },
        onBeforeAppear(el2) {
          callHook(onBeforeAppear, [el2]);
          addTransitionClass(el2, appearFromClass);
          addTransitionClass(el2, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el2, done) {
          el2._isLeaving = true;
          const resolve2 = () => finishLeave(el2, done);
          addTransitionClass(el2, leaveFromClass);
          forceReflow();
          addTransitionClass(el2, leaveActiveClass);
          nextFrame(() => {
            if (!el2._isLeaving) {
              return;
            }
            removeTransitionClass(el2, leaveFromClass);
            addTransitionClass(el2, leaveToClass);
            if (!hasExplicitCallback(onLeave)) {
              whenTransitionEnds(el2, type2, leaveDuration, resolve2);
            }
          });
          callHook(onLeave, [el2, resolve2]);
        },
        onEnterCancelled(el2) {
          finishEnter(el2, false);
          callHook(onEnterCancelled, [el2]);
        },
        onAppearCancelled(el2) {
          finishEnter(el2, true);
          callHook(onAppearCancelled, [el2]);
        },
        onLeaveCancelled(el2) {
          finishLeave(el2);
          callHook(onLeaveCancelled, [el2]);
        }
      });
    }
    function normalizeDuration(duration) {
      if (duration == null) {
        return null;
      } else if (isObject$3(duration)) {
        return [NumberOf(duration.enter), NumberOf(duration.leave)];
      } else {
        const n = NumberOf(duration);
        return [n, n];
      }
    }
    function NumberOf(val) {
      const res = toNumber$1(val);
      return res;
    }
    function addTransitionClass(el2, cls) {
      cls.split(/\s+/).forEach((c) => c && el2.classList.add(c));
      (el2[vtcKey] || (el2[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
    }
    function removeTransitionClass(el2, cls) {
      cls.split(/\s+/).forEach((c) => c && el2.classList.remove(c));
      const _vtc = el2[vtcKey];
      if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
          el2[vtcKey] = void 0;
        }
      }
    }
    function nextFrame(cb) {
      requestAnimationFrame(() => {
        requestAnimationFrame(cb);
      });
    }
    let endId = 0;
    function whenTransitionEnds(el2, expectedType, explicitTimeout, resolve2) {
      const id2 = el2._endId = ++endId;
      const resolveIfNotStale = () => {
        if (id2 === el2._endId) {
          resolve2();
        }
      };
      if (explicitTimeout) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
      }
      const { type: type2, timeout, propCount } = getTransitionInfo(el2, expectedType);
      if (!type2) {
        return resolve2();
      }
      const endEvent = type2 + "end";
      let ended = 0;
      const end = () => {
        el2.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
      };
      const onEnd = (e) => {
        if (e.target === el2 && ++ended >= propCount) {
          end();
        }
      };
      setTimeout(() => {
        if (ended < propCount) {
          end();
        }
      }, timeout + 1);
      el2.addEventListener(endEvent, onEnd);
    }
    function getTransitionInfo(el2, expectedType) {
      const styles = window.getComputedStyle(el2);
      const getStyleProperties = (key) => (styles[key] || "").split(", ");
      const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
      const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
      const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
      const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
      const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
      const animationTimeout = getTimeout(animationDelays, animationDurations);
      let type2 = null;
      let timeout = 0;
      let propCount = 0;
      if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
          type2 = TRANSITION;
          timeout = transitionTimeout;
          propCount = transitionDurations.length;
        }
      } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
          type2 = ANIMATION;
          timeout = animationTimeout;
          propCount = animationDurations.length;
        }
      } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type2 = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type2 ? type2 === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
      }
      const hasTransform = type2 === TRANSITION && /\b(transform|all)(,|$)/.test(
        getStyleProperties(`${TRANSITION}Property`).toString()
      );
      return {
        type: type2,
        timeout,
        propCount,
        hasTransform
      };
    }
    function getTimeout(delays, durations) {
      while (delays.length < durations.length) {
        delays = delays.concat(delays);
      }
      return Math.max(...durations.map((d, i2) => toMs(d) + toMs(delays[i2])));
    }
    function toMs(s) {
      if (s === "auto")
        return 0;
      return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
    }
    function forceReflow() {
      return document.body.offsetHeight;
    }
    function patchClass(el2, value, isSVG) {
      const transitionClasses = el2[vtcKey];
      if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
      }
      if (value == null) {
        el2.removeAttribute("class");
      } else if (isSVG) {
        el2.setAttribute("class", value);
      } else {
        el2.className = value;
      }
    }
    const vShowOldKey = Symbol("_vod");
    const vShow = {
      beforeMount(el2, { value }, { transition }) {
        el2[vShowOldKey] = el2.style.display === "none" ? "" : el2.style.display;
        if (transition && value) {
          transition.beforeEnter(el2);
        } else {
          setDisplay(el2, value);
        }
      },
      mounted(el2, { value }, { transition }) {
        if (transition && value) {
          transition.enter(el2);
        }
      },
      updated(el2, { value, oldValue }, { transition }) {
        if (!value === !oldValue && (el2.style.display === el2[vShowOldKey] || !value))
          return;
        if (transition) {
          if (value) {
            transition.beforeEnter(el2);
            setDisplay(el2, true);
            transition.enter(el2);
          } else {
            transition.leave(el2, () => {
              setDisplay(el2, false);
            });
          }
        } else {
          setDisplay(el2, value);
        }
      },
      beforeUnmount(el2, { value }) {
        setDisplay(el2, value);
      }
    };
    function setDisplay(el2, value) {
      el2.style.display = value ? el2[vShowOldKey] : "none";
    }
    const CSS_VAR_TEXT = Symbol("");
    const displayRE = /(^|;)\s*display\s*:/;
    function patchStyle(el2, prev, next2) {
      const style = el2.style;
      const isCssString = isString$1(next2);
      const currentDisplay = style.display;
      let hasControlledDisplay = false;
      if (next2 && !isCssString) {
        if (prev && !isString$1(prev)) {
          for (const key in prev) {
            if (next2[key] == null) {
              setStyle(style, key, "");
            }
          }
        }
        for (const key in next2) {
          if (key === "display") {
            hasControlledDisplay = true;
          }
          setStyle(style, key, next2[key]);
        }
      } else {
        if (isCssString) {
          if (prev !== next2) {
            const cssVarText = style[CSS_VAR_TEXT];
            if (cssVarText) {
              next2 += ";" + cssVarText;
            }
            style.cssText = next2;
            hasControlledDisplay = displayRE.test(next2);
          }
        } else if (prev) {
          el2.removeAttribute("style");
        }
      }
      if (vShowOldKey in el2) {
        el2[vShowOldKey] = hasControlledDisplay ? style.display : "";
        style.display = currentDisplay;
      }
    }
    const importantRE = /\s*!important$/;
    function setStyle(style, name, val) {
      if (isArray$1(val)) {
        val.forEach((v) => setStyle(style, name, v));
      } else {
        if (val == null)
          val = "";
        if (name.startsWith("--")) {
          style.setProperty(name, val);
        } else {
          const prefixed = autoPrefix(style, name);
          if (importantRE.test(val)) {
            style.setProperty(
              hyphenate(prefixed),
              val.replace(importantRE, ""),
              "important"
            );
          } else {
            style[prefixed] = val;
          }
        }
      }
    }
    const prefixes = ["Webkit", "Moz", "ms"];
    const prefixCache = {};
    function autoPrefix(style, rawName) {
      const cached = prefixCache[rawName];
      if (cached) {
        return cached;
      }
      let name = camelize(rawName);
      if (name !== "filter" && name in style) {
        return prefixCache[rawName] = name;
      }
      name = capitalize(name);
      for (let i2 = 0; i2 < prefixes.length; i2++) {
        const prefixed = prefixes[i2] + name;
        if (prefixed in style) {
          return prefixCache[rawName] = prefixed;
        }
      }
      return rawName;
    }
    const xlinkNS = "http://www.w3.org/1999/xlink";
    function patchAttr(el2, key, value, isSVG, instance) {
      if (isSVG && key.startsWith("xlink:")) {
        if (value == null) {
          el2.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        } else {
          el2.setAttributeNS(xlinkNS, key, value);
        }
      } else {
        const isBoolean = isSpecialBooleanAttr(key);
        if (value == null || isBoolean && !includeBooleanAttr(value)) {
          el2.removeAttribute(key);
        } else {
          el2.setAttribute(key, isBoolean ? "" : value);
        }
      }
    }
    function patchDOMProp(el2, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
      if (key === "innerHTML" || key === "textContent") {
        if (prevChildren) {
          unmountChildren(prevChildren, parentComponent, parentSuspense);
        }
        el2[key] = value == null ? "" : value;
        return;
      }
      const tag = el2.tagName;
      if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
      !tag.includes("-")) {
        el2._value = value;
        const oldValue = tag === "OPTION" ? el2.getAttribute("value") : el2.value;
        const newValue = value == null ? "" : value;
        if (oldValue !== newValue) {
          el2.value = newValue;
        }
        if (value == null) {
          el2.removeAttribute(key);
        }
        return;
      }
      let needRemove = false;
      if (value === "" || value == null) {
        const type2 = typeof el2[key];
        if (type2 === "boolean") {
          value = includeBooleanAttr(value);
        } else if (value == null && type2 === "string") {
          value = "";
          needRemove = true;
        } else if (type2 === "number") {
          value = 0;
          needRemove = true;
        }
      }
      try {
        el2[key] = value;
      } catch (e) {
      }
      needRemove && el2.removeAttribute(key);
    }
    function addEventListener(el2, event, handler, options) {
      el2.addEventListener(event, handler, options);
    }
    function removeEventListener(el2, event, handler, options) {
      el2.removeEventListener(event, handler, options);
    }
    const veiKey = Symbol("_vei");
    function patchEvent(el2, rawName, prevValue, nextValue, instance = null) {
      const invokers = el2[veiKey] || (el2[veiKey] = {});
      const existingInvoker = invokers[rawName];
      if (nextValue && existingInvoker) {
        existingInvoker.value = nextValue;
      } else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
          const invoker = invokers[rawName] = createInvoker(nextValue, instance);
          addEventListener(el2, name, invoker, options);
        } else if (existingInvoker) {
          removeEventListener(el2, name, existingInvoker, options);
          invokers[rawName] = void 0;
        }
      }
    }
    const optionsModifierRE = /(?:Once|Passive|Capture)$/;
    function parseName(name) {
      let options;
      if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while (m = name.match(optionsModifierRE)) {
          name = name.slice(0, name.length - m[0].length);
          options[m[0].toLowerCase()] = true;
        }
      }
      const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
      return [event, options];
    }
    let cachedNow = 0;
    const p = /* @__PURE__ */ Promise.resolve();
    const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
    function createInvoker(initialValue, instance) {
      const invoker = (e) => {
        if (!e._vts) {
          e._vts = Date.now();
        } else if (e._vts <= invoker.attached) {
          return;
        }
        callWithAsyncErrorHandling(
          patchStopImmediatePropagation(e, invoker.value),
          instance,
          5,
          [e]
        );
      };
      invoker.value = initialValue;
      invoker.attached = getNow();
      return invoker;
    }
    function patchStopImmediatePropagation(e, value) {
      if (isArray$1(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
          originalStop.call(e);
          e._stopped = true;
        };
        return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
      } else {
        return value;
      }
    }
    const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
    key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
    const patchProp = (el2, key, prevValue, nextValue, namespace, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
      const isSVG = namespace === "svg";
      if (key === "class") {
        patchClass(el2, nextValue, isSVG);
      } else if (key === "style") {
        patchStyle(el2, prevValue, nextValue);
      } else if (isOn$1(key)) {
        if (!isModelListener(key)) {
          patchEvent(el2, key, prevValue, nextValue, parentComponent);
        }
      } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el2, key, nextValue, isSVG)) {
        patchDOMProp(
          el2,
          key,
          nextValue,
          prevChildren,
          parentComponent,
          parentSuspense,
          unmountChildren
        );
      } else {
        if (key === "true-value") {
          el2._trueValue = nextValue;
        } else if (key === "false-value") {
          el2._falseValue = nextValue;
        }
        patchAttr(el2, key, nextValue, isSVG);
      }
    };
    function shouldSetAsProp(el2, key, value, isSVG) {
      if (isSVG) {
        if (key === "innerHTML" || key === "textContent") {
          return true;
        }
        if (key in el2 && isNativeOn(key) && isFunction$1(value)) {
          return true;
        }
        return false;
      }
      if (key === "spellcheck" || key === "draggable" || key === "translate") {
        return false;
      }
      if (key === "form") {
        return false;
      }
      if (key === "list" && el2.tagName === "INPUT") {
        return false;
      }
      if (key === "type" && el2.tagName === "TEXTAREA") {
        return false;
      }
      if (key === "width" || key === "height") {
        const tag = el2.tagName;
        if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
          return false;
        }
      }
      if (isNativeOn(key) && isString$1(value)) {
        return false;
      }
      return key in el2;
    }
    const positionMap = /* @__PURE__ */ new WeakMap();
    const newPositionMap = /* @__PURE__ */ new WeakMap();
    const moveCbKey = Symbol("_moveCb");
    const enterCbKey = Symbol("_enterCb");
    const TransitionGroupImpl = {
      name: "TransitionGroup",
      props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
      }),
      setup(props, { slots }) {
        const instance = getCurrentInstance$1();
        const state = useTransitionState();
        let prevChildren;
        let children;
        onUpdated(() => {
          if (!prevChildren.length) {
            return;
          }
          const moveClass = props.moveClass || `${props.name || "v"}-move`;
          if (!hasCSSTransform(
            prevChildren[0].el,
            instance.vnode.el,
            moveClass
          )) {
            return;
          }
          prevChildren.forEach(callPendingCbs);
          prevChildren.forEach(recordPosition);
          const movedChildren = prevChildren.filter(applyTranslation);
          forceReflow();
          movedChildren.forEach((c) => {
            const el2 = c.el;
            const style = el2.style;
            addTransitionClass(el2, moveClass);
            style.transform = style.webkitTransform = style.transitionDuration = "";
            const cb = el2[moveCbKey] = (e) => {
              if (e && e.target !== el2) {
                return;
              }
              if (!e || /transform$/.test(e.propertyName)) {
                el2.removeEventListener("transitionend", cb);
                el2[moveCbKey] = null;
                removeTransitionClass(el2, moveClass);
              }
            };
            el2.addEventListener("transitionend", cb);
          });
        });
        return () => {
          const rawProps = toRaw(props);
          const cssTransitionProps = resolveTransitionProps(rawProps);
          let tag = rawProps.tag || Fragment;
          prevChildren = children;
          children = slots.default ? getTransitionRawChildren(slots.default()) : [];
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            if (child.key != null) {
              setTransitionHooks(
                child,
                resolveTransitionHooks(child, cssTransitionProps, state, instance)
              );
            }
          }
          if (prevChildren) {
            for (let i2 = 0; i2 < prevChildren.length; i2++) {
              const child = prevChildren[i2];
              setTransitionHooks(
                child,
                resolveTransitionHooks(child, cssTransitionProps, state, instance)
              );
              positionMap.set(child, child.el.getBoundingClientRect());
            }
          }
          return createVNode(tag, null, children);
        };
      }
    };
    const removeMode = (props) => delete props.mode;
    /* @__PURE__ */ removeMode(TransitionGroupImpl.props);
    const TransitionGroup = TransitionGroupImpl;
    function callPendingCbs(c) {
      const el2 = c.el;
      if (el2[moveCbKey]) {
        el2[moveCbKey]();
      }
      if (el2[enterCbKey]) {
        el2[enterCbKey]();
      }
    }
    function recordPosition(c) {
      newPositionMap.set(c, c.el.getBoundingClientRect());
    }
    function applyTranslation(c) {
      const oldPos = positionMap.get(c);
      const newPos = newPositionMap.get(c);
      const dx = oldPos.left - newPos.left;
      const dy = oldPos.top - newPos.top;
      if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = "0s";
        return c;
      }
    }
    function hasCSSTransform(el2, root, moveClass) {
      const clone2 = el2.cloneNode();
      const _vtc = el2[vtcKey];
      if (_vtc) {
        _vtc.forEach((cls) => {
          cls.split(/\s+/).forEach((c) => c && clone2.classList.remove(c));
        });
      }
      moveClass.split(/\s+/).forEach((c) => c && clone2.classList.add(c));
      clone2.style.display = "none";
      const container = root.nodeType === 1 ? root : root.parentNode;
      container.appendChild(clone2);
      const { hasTransform } = getTransitionInfo(clone2);
      container.removeChild(clone2);
      return hasTransform;
    }
    const getModelAssigner = (vnode) => {
      const fn = vnode.props["onUpdate:modelValue"] || false;
      return isArray$1(fn) ? (value) => invokeArrayFns(fn, value) : fn;
    };
    function onCompositionStart(e) {
      e.target.composing = true;
    }
    function onCompositionEnd(e) {
      const target2 = e.target;
      if (target2.composing) {
        target2.composing = false;
        target2.dispatchEvent(new Event("input"));
      }
    }
    const assignKey = Symbol("_assign");
    const vModelText = {
      created(el2, { modifiers: { lazy, trim, number } }, vnode) {
        el2[assignKey] = getModelAssigner(vnode);
        const castToNumber = number || vnode.props && vnode.props.type === "number";
        addEventListener(el2, lazy ? "change" : "input", (e) => {
          if (e.target.composing)
            return;
          let domValue = el2.value;
          if (trim) {
            domValue = domValue.trim();
          }
          if (castToNumber) {
            domValue = looseToNumber(domValue);
          }
          el2[assignKey](domValue);
        });
        if (trim) {
          addEventListener(el2, "change", () => {
            el2.value = el2.value.trim();
          });
        }
        if (!lazy) {
          addEventListener(el2, "compositionstart", onCompositionStart);
          addEventListener(el2, "compositionend", onCompositionEnd);
          addEventListener(el2, "change", onCompositionEnd);
        }
      },
      // set value on mounted so it's after min/max for type="range"
      mounted(el2, { value }) {
        el2.value = value == null ? "" : value;
      },
      beforeUpdate(el2, { value, modifiers: { lazy, trim, number } }, vnode) {
        el2[assignKey] = getModelAssigner(vnode);
        if (el2.composing)
          return;
        const elValue = number || el2.type === "number" ? looseToNumber(el2.value) : el2.value;
        const newValue = value == null ? "" : value;
        if (elValue === newValue) {
          return;
        }
        if (document.activeElement === el2 && el2.type !== "range") {
          if (lazy) {
            return;
          }
          if (trim && el2.value.trim() === newValue) {
            return;
          }
        }
        el2.value = newValue;
      }
    };
    const systemModifiers = ["ctrl", "shift", "alt", "meta"];
    const modifierGuards = {
      stop: (e) => e.stopPropagation(),
      prevent: (e) => e.preventDefault(),
      self: (e) => e.target !== e.currentTarget,
      ctrl: (e) => !e.ctrlKey,
      shift: (e) => !e.shiftKey,
      alt: (e) => !e.altKey,
      meta: (e) => !e.metaKey,
      left: (e) => "button" in e && e.button !== 0,
      middle: (e) => "button" in e && e.button !== 1,
      right: (e) => "button" in e && e.button !== 2,
      exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
    };
    const withModifiers = (fn, modifiers) => {
      const cache = fn._withMods || (fn._withMods = {});
      const cacheKey = modifiers.join(".");
      return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
        for (let i2 = 0; i2 < modifiers.length; i2++) {
          const guard = modifierGuards[modifiers[i2]];
          if (guard && guard(event, modifiers))
            return;
        }
        return fn(event, ...args);
      });
    };
    const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
    let renderer$1;
    function ensureRenderer() {
      return renderer$1 || (renderer$1 = createRenderer(rendererOptions));
    }
    const createApp = (...args) => {
      const app2 = ensureRenderer().createApp(...args);
      const { mount } = app2;
      app2.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container)
          return;
        const component = app2._component;
        if (!isFunction$1(component) && !component.render && !component.template) {
          component.template = container.innerHTML;
        }
        container.innerHTML = "";
        const proxy = mount(container, false, resolveRootNamespace(container));
        if (container instanceof Element) {
          container.removeAttribute("v-cloak");
          container.setAttribute("data-v-app", "");
        }
        return proxy;
      };
      return app2;
    };
    function resolveRootNamespace(container) {
      if (container instanceof SVGElement) {
        return "svg";
      }
      if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
        return "mathml";
      }
    }
    function normalizeContainer(container) {
      if (isString$1(container)) {
        const res = document.querySelector(container);
        return res;
      }
      return container;
    }
    const _sfc_main$D = {
      name: "App"
    };
    const _export_sfc = (sfc, props) => {
      const target2 = sfc.__vccOpts || sfc;
      for (const [key, val] of props) {
        target2[key] = val;
      }
      return target2;
    };
    function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_router_view = resolveComponent("router-view");
      return openBlock(), createBlock(_component_router_view);
    }
    const App = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$7]]);
    /*!
      * vue-router v4.2.5
      * (c) 2023 Eduardo San Martin Morote
      * @license MIT
      */
    const isBrowser = typeof window !== "undefined";
    function isESModule(obj) {
      return obj.__esModule || obj[Symbol.toStringTag] === "Module";
    }
    const assign$3 = Object.assign;
    function applyToParams(fn, params) {
      const newParams = {};
      for (const key in params) {
        const value = params[key];
        newParams[key] = isArray(value) ? value.map(fn) : fn(value);
      }
      return newParams;
    }
    const noop$2 = () => {
    };
    const isArray = Array.isArray;
    const TRAILING_SLASH_RE = /\/$/;
    const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
    function parseURL(parseQuery2, location2, currentLocation = "/") {
      let path, query = {}, searchString = "", hash = "";
      const hashPos = location2.indexOf("#");
      let searchPos = location2.indexOf("?");
      if (hashPos < searchPos && hashPos >= 0) {
        searchPos = -1;
      }
      if (searchPos > -1) {
        path = location2.slice(0, searchPos);
        searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
        query = parseQuery2(searchString);
      }
      if (hashPos > -1) {
        path = path || location2.slice(0, hashPos);
        hash = location2.slice(hashPos, location2.length);
      }
      path = resolveRelativePath(path != null ? path : location2, currentLocation);
      return {
        fullPath: path + (searchString && "?") + searchString + hash,
        path,
        query,
        hash
      };
    }
    function stringifyURL(stringifyQuery2, location2) {
      const query = location2.query ? stringifyQuery2(location2.query) : "";
      return location2.path + (query && "?") + query + (location2.hash || "");
    }
    function stripBase(pathname, base2) {
      if (!base2 || !pathname.toLowerCase().startsWith(base2.toLowerCase()))
        return pathname;
      return pathname.slice(base2.length) || "/";
    }
    function isSameRouteLocation(stringifyQuery2, a, b) {
      const aLastIndex = a.matched.length - 1;
      const bLastIndex = b.matched.length - 1;
      return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery2(a.query) === stringifyQuery2(b.query) && a.hash === b.hash;
    }
    function isSameRouteRecord(a, b) {
      return (a.aliasOf || a) === (b.aliasOf || b);
    }
    function isSameRouteLocationParams(a, b) {
      if (Object.keys(a).length !== Object.keys(b).length)
        return false;
      for (const key in a) {
        if (!isSameRouteLocationParamsValue(a[key], b[key]))
          return false;
      }
      return true;
    }
    function isSameRouteLocationParamsValue(a, b) {
      return isArray(a) ? isEquivalentArray(a, b) : isArray(b) ? isEquivalentArray(b, a) : a === b;
    }
    function isEquivalentArray(a, b) {
      return isArray(b) ? a.length === b.length && a.every((value, i2) => value === b[i2]) : a.length === 1 && a[0] === b;
    }
    function resolveRelativePath(to, from) {
      if (to.startsWith("/"))
        return to;
      if (!to)
        return from;
      const fromSegments = from.split("/");
      const toSegments = to.split("/");
      const lastToSegment = toSegments[toSegments.length - 1];
      if (lastToSegment === ".." || lastToSegment === ".") {
        toSegments.push("");
      }
      let position = fromSegments.length - 1;
      let toPosition;
      let segment;
      for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
        segment = toSegments[toPosition];
        if (segment === ".")
          continue;
        if (segment === "..") {
          if (position > 1)
            position--;
        } else
          break;
      }
      return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join("/");
    }
    var NavigationType;
    (function(NavigationType2) {
      NavigationType2["pop"] = "pop";
      NavigationType2["push"] = "push";
    })(NavigationType || (NavigationType = {}));
    var NavigationDirection;
    (function(NavigationDirection2) {
      NavigationDirection2["back"] = "back";
      NavigationDirection2["forward"] = "forward";
      NavigationDirection2["unknown"] = "";
    })(NavigationDirection || (NavigationDirection = {}));
    function normalizeBase(base2) {
      if (!base2) {
        if (isBrowser) {
          const baseEl = document.querySelector("base");
          base2 = baseEl && baseEl.getAttribute("href") || "/";
          base2 = base2.replace(/^\w+:\/\/[^\/]+/, "");
        } else {
          base2 = "/";
        }
      }
      if (base2[0] !== "/" && base2[0] !== "#")
        base2 = "/" + base2;
      return removeTrailingSlash(base2);
    }
    const BEFORE_HASH_RE = /^[^#]+#/;
    function createHref(base2, location2) {
      return base2.replace(BEFORE_HASH_RE, "#") + location2;
    }
    function getElementPosition(el2, offset) {
      const docRect = document.documentElement.getBoundingClientRect();
      const elRect = el2.getBoundingClientRect();
      return {
        behavior: offset.behavior,
        left: elRect.left - docRect.left - (offset.left || 0),
        top: elRect.top - docRect.top - (offset.top || 0)
      };
    }
    const computeScrollPosition = () => ({
      left: window.pageXOffset,
      top: window.pageYOffset
    });
    function scrollToPosition(position) {
      let scrollToOptions;
      if ("el" in position) {
        const positionEl = position.el;
        const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
        const el2 = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
        if (!el2) {
          return;
        }
        scrollToOptions = getElementPosition(el2, position);
      } else {
        scrollToOptions = position;
      }
      if ("scrollBehavior" in document.documentElement.style)
        window.scrollTo(scrollToOptions);
      else {
        window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
      }
    }
    function getScrollKey(path, delta2) {
      const position = history.state ? history.state.position - delta2 : -1;
      return position + path;
    }
    const scrollPositions = /* @__PURE__ */ new Map();
    function saveScrollPosition(key, scrollPosition) {
      scrollPositions.set(key, scrollPosition);
    }
    function getSavedScrollPosition(key) {
      const scroll = scrollPositions.get(key);
      scrollPositions.delete(key);
      return scroll;
    }
    let createBaseLocation = () => location.protocol + "//" + location.host;
    function createCurrentLocation(base2, location2) {
      const { pathname, search, hash } = location2;
      const hashPos = base2.indexOf("#");
      if (hashPos > -1) {
        let slicePos = hash.includes(base2.slice(hashPos)) ? base2.slice(hashPos).length : 1;
        let pathFromHash = hash.slice(slicePos);
        if (pathFromHash[0] !== "/")
          pathFromHash = "/" + pathFromHash;
        return stripBase(pathFromHash, "");
      }
      const path = stripBase(pathname, base2);
      return path + search + hash;
    }
    function useHistoryListeners(base2, historyState, currentLocation, replace2) {
      let listeners = [];
      let teardowns = [];
      let pauseState = null;
      const popStateHandler = ({ state }) => {
        const to = createCurrentLocation(base2, location);
        const from = currentLocation.value;
        const fromState = historyState.value;
        let delta2 = 0;
        if (state) {
          currentLocation.value = to;
          historyState.value = state;
          if (pauseState && pauseState === from) {
            pauseState = null;
            return;
          }
          delta2 = fromState ? state.position - fromState.position : 0;
        } else {
          replace2(to);
        }
        listeners.forEach((listener) => {
          listener(currentLocation.value, from, {
            delta: delta2,
            type: NavigationType.pop,
            direction: delta2 ? delta2 > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
          });
        });
      };
      function pauseListeners() {
        pauseState = currentLocation.value;
      }
      function listen(callback) {
        listeners.push(callback);
        const teardown = () => {
          const index = listeners.indexOf(callback);
          if (index > -1)
            listeners.splice(index, 1);
        };
        teardowns.push(teardown);
        return teardown;
      }
      function beforeUnloadListener() {
        const { history: history2 } = window;
        if (!history2.state)
          return;
        history2.replaceState(assign$3({}, history2.state, { scroll: computeScrollPosition() }), "");
      }
      function destroy() {
        for (const teardown of teardowns)
          teardown();
        teardowns = [];
        window.removeEventListener("popstate", popStateHandler);
        window.removeEventListener("beforeunload", beforeUnloadListener);
      }
      window.addEventListener("popstate", popStateHandler);
      window.addEventListener("beforeunload", beforeUnloadListener, {
        passive: true
      });
      return {
        pauseListeners,
        listen,
        destroy
      };
    }
    function buildState(back, current2, forward, replaced = false, computeScroll = false) {
      return {
        back,
        current: current2,
        forward,
        replaced,
        position: window.history.length,
        scroll: computeScroll ? computeScrollPosition() : null
      };
    }
    function useHistoryStateNavigation(base2) {
      const { history: history2, location: location2 } = window;
      const currentLocation = {
        value: createCurrentLocation(base2, location2)
      };
      const historyState = { value: history2.state };
      if (!historyState.value) {
        changeLocation(currentLocation.value, {
          back: null,
          current: currentLocation.value,
          forward: null,
          // the length is off by one, we need to decrease it
          position: history2.length - 1,
          replaced: true,
          // don't add a scroll as the user may have an anchor, and we want
          // scrollBehavior to be triggered without a saved position
          scroll: null
        }, true);
      }
      function changeLocation(to, state, replace22) {
        const hashIndex = base2.indexOf("#");
        const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base2 : base2.slice(hashIndex)) + to : createBaseLocation() + base2 + to;
        try {
          history2[replace22 ? "replaceState" : "pushState"](state, "", url);
          historyState.value = state;
        } catch (err) {
          {
            console.error(err);
          }
          location2[replace22 ? "replace" : "assign"](url);
        }
      }
      function replace2(to, data) {
        const state = assign$3({}, history2.state, buildState(
          historyState.value.back,
          // keep back and forward entries but override current position
          to,
          historyState.value.forward,
          true
        ), data, { position: historyState.value.position });
        changeLocation(to, state, true);
        currentLocation.value = to;
      }
      function push(to, data) {
        const currentState = assign$3(
          {},
          // use current history state to gracefully handle a wrong call to
          // history.replaceState
          // https://github.com/vuejs/router/issues/366
          historyState.value,
          history2.state,
          {
            forward: to,
            scroll: computeScrollPosition()
          }
        );
        changeLocation(currentState.current, currentState, true);
        const state = assign$3({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);
        changeLocation(to, state, false);
        currentLocation.value = to;
      }
      return {
        location: currentLocation,
        state: historyState,
        push,
        replace: replace2
      };
    }
    function createWebHistory(base2) {
      base2 = normalizeBase(base2);
      const historyNavigation = useHistoryStateNavigation(base2);
      const historyListeners = useHistoryListeners(base2, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
      function go(delta2, triggerListeners = true) {
        if (!triggerListeners)
          historyListeners.pauseListeners();
        history.go(delta2);
      }
      const routerHistory = assign$3({
        // it's overridden right after
        location: "",
        base: base2,
        go,
        createHref: createHref.bind(null, base2)
      }, historyNavigation, historyListeners);
      Object.defineProperty(routerHistory, "location", {
        enumerable: true,
        get: () => historyNavigation.location.value
      });
      Object.defineProperty(routerHistory, "state", {
        enumerable: true,
        get: () => historyNavigation.state.value
      });
      return routerHistory;
    }
    function createWebHashHistory(base2) {
      base2 = location.host ? base2 || location.pathname + location.search : "";
      if (!base2.includes("#"))
        base2 += "#";
      return createWebHistory(base2);
    }
    function isRouteLocation(route) {
      return typeof route === "string" || route && typeof route === "object";
    }
    function isRouteName(name) {
      return typeof name === "string" || typeof name === "symbol";
    }
    const START_LOCATION_NORMALIZED = {
      path: "/",
      name: void 0,
      params: {},
      query: {},
      hash: "",
      fullPath: "/",
      matched: [],
      meta: {},
      redirectedFrom: void 0
    };
    const NavigationFailureSymbol = Symbol("");
    var NavigationFailureType;
    (function(NavigationFailureType2) {
      NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
      NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
      NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
    })(NavigationFailureType || (NavigationFailureType = {}));
    function createRouterError(type2, params) {
      {
        return assign$3(new Error(), {
          type: type2,
          [NavigationFailureSymbol]: true
        }, params);
      }
    }
    function isNavigationFailure(error2, type2) {
      return error2 instanceof Error && NavigationFailureSymbol in error2 && (type2 == null || !!(error2.type & type2));
    }
    const BASE_PARAM_PATTERN = "[^/]+?";
    const BASE_PATH_PARSER_OPTIONS = {
      sensitive: false,
      strict: false,
      start: true,
      end: true
    };
    const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
    function tokensToParser(segments, extraOptions) {
      const options = assign$3({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
      const score = [];
      let pattern3 = options.start ? "^" : "";
      const keys2 = [];
      for (const segment of segments) {
        const segmentScores = segment.length ? [] : [
          90
          /* PathScore.Root */
        ];
        if (options.strict && !segment.length)
          pattern3 += "/";
        for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
          const token2 = segment[tokenIndex];
          let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
          if (token2.type === 0) {
            if (!tokenIndex)
              pattern3 += "/";
            pattern3 += token2.value.replace(REGEX_CHARS_RE, "\\$&");
            subSegmentScore += 40;
          } else if (token2.type === 1) {
            const { value, repeatable, optional, regexp } = token2;
            keys2.push({
              name: value,
              repeatable,
              optional
            });
            const re22 = regexp ? regexp : BASE_PARAM_PATTERN;
            if (re22 !== BASE_PARAM_PATTERN) {
              subSegmentScore += 10;
              try {
                new RegExp(`(${re22})`);
              } catch (err) {
                throw new Error(`Invalid custom RegExp for param "${value}" (${re22}): ` + err.message);
              }
            }
            let subPattern = repeatable ? `((?:${re22})(?:/(?:${re22}))*)` : `(${re22})`;
            if (!tokenIndex)
              subPattern = // avoid an optional / if there are more segments e.g. /:p?-static
              // or /:p?-:p2
              optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
            if (optional)
              subPattern += "?";
            pattern3 += subPattern;
            subSegmentScore += 20;
            if (optional)
              subSegmentScore += -8;
            if (repeatable)
              subSegmentScore += -20;
            if (re22 === ".*")
              subSegmentScore += -50;
          }
          segmentScores.push(subSegmentScore);
        }
        score.push(segmentScores);
      }
      if (options.strict && options.end) {
        const i2 = score.length - 1;
        score[i2][score[i2].length - 1] += 0.7000000000000001;
      }
      if (!options.strict)
        pattern3 += "/?";
      if (options.end)
        pattern3 += "$";
      else if (options.strict)
        pattern3 += "(?:/|$)";
      const re2 = new RegExp(pattern3, options.sensitive ? "" : "i");
      function parse2(path) {
        const match = path.match(re2);
        const params = {};
        if (!match)
          return null;
        for (let i2 = 1; i2 < match.length; i2++) {
          const value = match[i2] || "";
          const key = keys2[i2 - 1];
          params[key.name] = value && key.repeatable ? value.split("/") : value;
        }
        return params;
      }
      function stringify(params) {
        let path = "";
        let avoidDuplicatedSlash = false;
        for (const segment of segments) {
          if (!avoidDuplicatedSlash || !path.endsWith("/"))
            path += "/";
          avoidDuplicatedSlash = false;
          for (const token2 of segment) {
            if (token2.type === 0) {
              path += token2.value;
            } else if (token2.type === 1) {
              const { value, repeatable, optional } = token2;
              const param = value in params ? params[value] : "";
              if (isArray(param) && !repeatable) {
                throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
              }
              const text2 = isArray(param) ? param.join("/") : param;
              if (!text2) {
                if (optional) {
                  if (segment.length < 2) {
                    if (path.endsWith("/"))
                      path = path.slice(0, -1);
                    else
                      avoidDuplicatedSlash = true;
                  }
                } else
                  throw new Error(`Missing required param "${value}"`);
              }
              path += text2;
            }
          }
        }
        return path || "/";
      }
      return {
        re: re2,
        score,
        keys: keys2,
        parse: parse2,
        stringify
      };
    }
    function compareScoreArray(a, b) {
      let i2 = 0;
      while (i2 < a.length && i2 < b.length) {
        const diff = b[i2] - a[i2];
        if (diff)
          return diff;
        i2++;
      }
      if (a.length < b.length) {
        return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;
      } else if (a.length > b.length) {
        return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;
      }
      return 0;
    }
    function comparePathParserScore(a, b) {
      let i2 = 0;
      const aScore = a.score;
      const bScore = b.score;
      while (i2 < aScore.length && i2 < bScore.length) {
        const comp2 = compareScoreArray(aScore[i2], bScore[i2]);
        if (comp2)
          return comp2;
        i2++;
      }
      if (Math.abs(bScore.length - aScore.length) === 1) {
        if (isLastScoreNegative(aScore))
          return 1;
        if (isLastScoreNegative(bScore))
          return -1;
      }
      return bScore.length - aScore.length;
    }
    function isLastScoreNegative(score) {
      const last = score[score.length - 1];
      return score.length > 0 && last[last.length - 1] < 0;
    }
    const ROOT_TOKEN = {
      type: 0,
      value: ""
    };
    const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
    function tokenizePath(path) {
      if (!path)
        return [[]];
      if (path === "/")
        return [[ROOT_TOKEN]];
      if (!path.startsWith("/")) {
        throw new Error(`Invalid path "${path}"`);
      }
      function crash(message) {
        throw new Error(`ERR (${state})/"${buffer}": ${message}`);
      }
      let state = 0;
      let previousState = state;
      const tokens = [];
      let segment;
      function finalizeSegment() {
        if (segment)
          tokens.push(segment);
        segment = [];
      }
      let i2 = 0;
      let char;
      let buffer = "";
      let customRe = "";
      function consumeBuffer() {
        if (!buffer)
          return;
        if (state === 0) {
          segment.push({
            type: 0,
            value: buffer
          });
        } else if (state === 1 || state === 2 || state === 3) {
          if (segment.length > 1 && (char === "*" || char === "+"))
            crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
          segment.push({
            type: 1,
            value: buffer,
            regexp: customRe,
            repeatable: char === "*" || char === "+",
            optional: char === "*" || char === "?"
          });
        } else {
          crash("Invalid state to consume buffer");
        }
        buffer = "";
      }
      function addCharToBuffer() {
        buffer += char;
      }
      while (i2 < path.length) {
        char = path[i2++];
        if (char === "\\" && state !== 2) {
          previousState = state;
          state = 4;
          continue;
        }
        switch (state) {
          case 0:
            if (char === "/") {
              if (buffer) {
                consumeBuffer();
              }
              finalizeSegment();
            } else if (char === ":") {
              consumeBuffer();
              state = 1;
            } else {
              addCharToBuffer();
            }
            break;
          case 4:
            addCharToBuffer();
            state = previousState;
            break;
          case 1:
            if (char === "(") {
              state = 2;
            } else if (VALID_PARAM_RE.test(char)) {
              addCharToBuffer();
            } else {
              consumeBuffer();
              state = 0;
              if (char !== "*" && char !== "?" && char !== "+")
                i2--;
            }
            break;
          case 2:
            if (char === ")") {
              if (customRe[customRe.length - 1] == "\\")
                customRe = customRe.slice(0, -1) + char;
              else
                state = 3;
            } else {
              customRe += char;
            }
            break;
          case 3:
            consumeBuffer();
            state = 0;
            if (char !== "*" && char !== "?" && char !== "+")
              i2--;
            customRe = "";
            break;
          default:
            crash("Unknown state");
            break;
        }
      }
      if (state === 2)
        crash(`Unfinished custom RegExp for param "${buffer}"`);
      consumeBuffer();
      finalizeSegment();
      return tokens;
    }
    function createRouteRecordMatcher(record, parent, options) {
      const parser = tokensToParser(tokenizePath(record.path), options);
      const matcher = assign$3(parser, {
        record,
        parent,
        // these needs to be populated by the parent
        children: [],
        alias: []
      });
      if (parent) {
        if (!matcher.record.aliasOf === !parent.record.aliasOf)
          parent.children.push(matcher);
      }
      return matcher;
    }
    function createRouterMatcher(routes2, globalOptions) {
      const matchers = [];
      const matcherMap = /* @__PURE__ */ new Map();
      globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
      function getRecordMatcher(name) {
        return matcherMap.get(name);
      }
      function addRoute(record, parent, originalRecord) {
        const isRootAdd = !originalRecord;
        const mainNormalizedRecord = normalizeRouteRecord(record);
        mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
        const options = mergeOptions(globalOptions, record);
        const normalizedRecords = [
          mainNormalizedRecord
        ];
        if ("alias" in record) {
          const aliases2 = typeof record.alias === "string" ? [record.alias] : record.alias;
          for (const alias of aliases2) {
            normalizedRecords.push(assign$3({}, mainNormalizedRecord, {
              // this allows us to hold a copy of the `components` option
              // so that async components cache is hold on the original record
              components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
              path: alias,
              // we might be the child of an alias
              aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
              // the aliases are always of the same kind as the original since they
              // are defined on the same record
            }));
          }
        }
        let matcher;
        let originalMatcher;
        for (const normalizedRecord of normalizedRecords) {
          const { path } = normalizedRecord;
          if (parent && path[0] !== "/") {
            const parentPath = parent.record.path;
            const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
            normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
          }
          matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
          if (originalRecord) {
            originalRecord.alias.push(matcher);
          } else {
            originalMatcher = originalMatcher || matcher;
            if (originalMatcher !== matcher)
              originalMatcher.alias.push(matcher);
            if (isRootAdd && record.name && !isAliasRecord(matcher))
              removeRoute(record.name);
          }
          if (mainNormalizedRecord.children) {
            const children = mainNormalizedRecord.children;
            for (let i2 = 0; i2 < children.length; i2++) {
              addRoute(children[i2], matcher, originalRecord && originalRecord.children[i2]);
            }
          }
          originalRecord = originalRecord || matcher;
          if (matcher.record.components && Object.keys(matcher.record.components).length || matcher.record.name || matcher.record.redirect) {
            insertMatcher(matcher);
          }
        }
        return originalMatcher ? () => {
          removeRoute(originalMatcher);
        } : noop$2;
      }
      function removeRoute(matcherRef) {
        if (isRouteName(matcherRef)) {
          const matcher = matcherMap.get(matcherRef);
          if (matcher) {
            matcherMap.delete(matcherRef);
            matchers.splice(matchers.indexOf(matcher), 1);
            matcher.children.forEach(removeRoute);
            matcher.alias.forEach(removeRoute);
          }
        } else {
          const index = matchers.indexOf(matcherRef);
          if (index > -1) {
            matchers.splice(index, 1);
            if (matcherRef.record.name)
              matcherMap.delete(matcherRef.record.name);
            matcherRef.children.forEach(removeRoute);
            matcherRef.alias.forEach(removeRoute);
          }
        }
      }
      function getRoutes() {
        return matchers;
      }
      function insertMatcher(matcher) {
        let i2 = 0;
        while (i2 < matchers.length && comparePathParserScore(matcher, matchers[i2]) >= 0 && // Adding children with empty path should still appear before the parent
        // https://github.com/vuejs/router/issues/1124
        (matcher.record.path !== matchers[i2].record.path || !isRecordChildOf(matcher, matchers[i2])))
          i2++;
        matchers.splice(i2, 0, matcher);
        if (matcher.record.name && !isAliasRecord(matcher))
          matcherMap.set(matcher.record.name, matcher);
      }
      function resolve2(location2, currentLocation) {
        let matcher;
        let params = {};
        let path;
        let name;
        if ("name" in location2 && location2.name) {
          matcher = matcherMap.get(location2.name);
          if (!matcher)
            throw createRouterError(1, {
              location: location2
            });
          name = matcher.record.name;
          params = assign$3(
            // paramsFromLocation is a new object
            paramsFromLocation(
              currentLocation.params,
              // only keep params that exist in the resolved location
              // TODO: only keep optional params coming from a parent record
              matcher.keys.filter((k) => !k.optional).map((k) => k.name)
            ),
            // discard any existing params in the current location that do not exist here
            // #1497 this ensures better active/exact matching
            location2.params && paramsFromLocation(location2.params, matcher.keys.map((k) => k.name))
          );
          path = matcher.stringify(params);
        } else if ("path" in location2) {
          path = location2.path;
          matcher = matchers.find((m) => m.re.test(path));
          if (matcher) {
            params = matcher.parse(path);
            name = matcher.record.name;
          }
        } else {
          matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m) => m.re.test(currentLocation.path));
          if (!matcher)
            throw createRouterError(1, {
              location: location2,
              currentLocation
            });
          name = matcher.record.name;
          params = assign$3({}, currentLocation.params, location2.params);
          path = matcher.stringify(params);
        }
        const matched = [];
        let parentMatcher = matcher;
        while (parentMatcher) {
          matched.unshift(parentMatcher.record);
          parentMatcher = parentMatcher.parent;
        }
        return {
          name,
          path,
          params,
          matched,
          meta: mergeMetaFields(matched)
        };
      }
      routes2.forEach((route) => addRoute(route));
      return { addRoute, resolve: resolve2, removeRoute, getRoutes, getRecordMatcher };
    }
    function paramsFromLocation(params, keys2) {
      const newParams = {};
      for (const key of keys2) {
        if (key in params)
          newParams[key] = params[key];
      }
      return newParams;
    }
    function normalizeRouteRecord(record) {
      return {
        path: record.path,
        redirect: record.redirect,
        name: record.name,
        meta: record.meta || {},
        aliasOf: void 0,
        beforeEnter: record.beforeEnter,
        props: normalizeRecordProps(record),
        children: record.children || [],
        instances: {},
        leaveGuards: /* @__PURE__ */ new Set(),
        updateGuards: /* @__PURE__ */ new Set(),
        enterCallbacks: {},
        components: "components" in record ? record.components || null : record.component && { default: record.component }
      };
    }
    function normalizeRecordProps(record) {
      const propsObject = {};
      const props = record.props || false;
      if ("component" in record) {
        propsObject.default = props;
      } else {
        for (const name in record.components)
          propsObject[name] = typeof props === "object" ? props[name] : props;
      }
      return propsObject;
    }
    function isAliasRecord(record) {
      while (record) {
        if (record.record.aliasOf)
          return true;
        record = record.parent;
      }
      return false;
    }
    function mergeMetaFields(matched) {
      return matched.reduce((meta, record) => assign$3(meta, record.meta), {});
    }
    function mergeOptions(defaults2, partialOptions) {
      const options = {};
      for (const key in defaults2) {
        options[key] = key in partialOptions ? partialOptions[key] : defaults2[key];
      }
      return options;
    }
    function isRecordChildOf(record, parent) {
      return parent.children.some((child) => child === record || isRecordChildOf(record, child));
    }
    const HASH_RE = /#/g;
    const AMPERSAND_RE = /&/g;
    const SLASH_RE = /\//g;
    const EQUAL_RE = /=/g;
    const IM_RE = /\?/g;
    const PLUS_RE = /\+/g;
    const ENC_BRACKET_OPEN_RE = /%5B/g;
    const ENC_BRACKET_CLOSE_RE = /%5D/g;
    const ENC_CARET_RE = /%5E/g;
    const ENC_BACKTICK_RE = /%60/g;
    const ENC_CURLY_OPEN_RE = /%7B/g;
    const ENC_PIPE_RE = /%7C/g;
    const ENC_CURLY_CLOSE_RE = /%7D/g;
    const ENC_SPACE_RE = /%20/g;
    function commonEncode(text2) {
      return encodeURI("" + text2).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
    }
    function encodeHash(text2) {
      return commonEncode(text2).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
    }
    function encodeQueryValue(text2) {
      return commonEncode(text2).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
    }
    function encodeQueryKey(text2) {
      return encodeQueryValue(text2).replace(EQUAL_RE, "%3D");
    }
    function encodePath(text2) {
      return commonEncode(text2).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
    }
    function encodeParam(text2) {
      return text2 == null ? "" : encodePath(text2).replace(SLASH_RE, "%2F");
    }
    function decode$2(text2) {
      try {
        return decodeURIComponent("" + text2);
      } catch (err) {
      }
      return "" + text2;
    }
    function parseQuery(search) {
      const query = {};
      if (search === "" || search === "?")
        return query;
      const hasLeadingIM = search[0] === "?";
      const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
      for (let i2 = 0; i2 < searchParams.length; ++i2) {
        const searchParam = searchParams[i2].replace(PLUS_RE, " ");
        const eqPos = searchParam.indexOf("=");
        const key = decode$2(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
        const value = eqPos < 0 ? null : decode$2(searchParam.slice(eqPos + 1));
        if (key in query) {
          let currentValue = query[key];
          if (!isArray(currentValue)) {
            currentValue = query[key] = [currentValue];
          }
          currentValue.push(value);
        } else {
          query[key] = value;
        }
      }
      return query;
    }
    function stringifyQuery(query) {
      let search = "";
      for (let key in query) {
        const value = query[key];
        key = encodeQueryKey(key);
        if (value == null) {
          if (value !== void 0) {
            search += (search.length ? "&" : "") + key;
          }
          continue;
        }
        const values = isArray(value) ? value.map((v) => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)];
        values.forEach((value2) => {
          if (value2 !== void 0) {
            search += (search.length ? "&" : "") + key;
            if (value2 != null)
              search += "=" + value2;
          }
        });
      }
      return search;
    }
    function normalizeQuery(query) {
      const normalizedQuery = {};
      for (const key in query) {
        const value = query[key];
        if (value !== void 0) {
          normalizedQuery[key] = isArray(value) ? value.map((v) => v == null ? null : "" + v) : value == null ? value : "" + value;
        }
      }
      return normalizedQuery;
    }
    const matchedRouteKey = Symbol("");
    const viewDepthKey = Symbol("");
    const routerKey = Symbol("");
    const routeLocationKey = Symbol("");
    const routerViewLocationKey = Symbol("");
    function useCallbacks() {
      let handlers2 = [];
      function add2(handler) {
        handlers2.push(handler);
        return () => {
          const i2 = handlers2.indexOf(handler);
          if (i2 > -1)
            handlers2.splice(i2, 1);
        };
      }
      function reset() {
        handlers2 = [];
      }
      return {
        add: add2,
        list: () => handlers2.slice(),
        reset
      };
    }
    function guardToPromiseFn(guard, to, from, record, name) {
      const enterCallbackArray = record && // name is defined if record is because of the function overload
      (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
      return () => new Promise((resolve2, reject) => {
        const next2 = (valid) => {
          if (valid === false) {
            reject(createRouterError(4, {
              from,
              to
            }));
          } else if (valid instanceof Error) {
            reject(valid);
          } else if (isRouteLocation(valid)) {
            reject(createRouterError(2, {
              from: to,
              to: valid
            }));
          } else {
            if (enterCallbackArray && // since enterCallbackArray is truthy, both record and name also are
            record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function") {
              enterCallbackArray.push(valid);
            }
            resolve2();
          }
        };
        const guardReturn = guard.call(record && record.instances[name], to, from, next2);
        let guardCall = Promise.resolve(guardReturn);
        if (guard.length < 3)
          guardCall = guardCall.then(next2);
        guardCall.catch((err) => reject(err));
      });
    }
    function extractComponentsGuards(matched, guardType, to, from) {
      const guards = [];
      for (const record of matched) {
        for (const name in record.components) {
          let rawComponent = record.components[name];
          if (guardType !== "beforeRouteEnter" && !record.instances[name])
            continue;
          if (isRouteComponent(rawComponent)) {
            const options = rawComponent.__vccOpts || rawComponent;
            const guard = options[guardType];
            guard && guards.push(guardToPromiseFn(guard, to, from, record, name));
          } else {
            let componentPromise = rawComponent();
            guards.push(() => componentPromise.then((resolved) => {
              if (!resolved)
                return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
              const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
              record.components[name] = resolvedComponent;
              const options = resolvedComponent.__vccOpts || resolvedComponent;
              const guard = options[guardType];
              return guard && guardToPromiseFn(guard, to, from, record, name)();
            }));
          }
        }
      }
      return guards;
    }
    function isRouteComponent(component) {
      return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
    }
    function useLink$1(props) {
      const router2 = inject$1(routerKey);
      const currentRoute = inject$1(routeLocationKey);
      const route = computed(() => router2.resolve(unref(props.to)));
      const activeRecordIndex = computed(() => {
        const { matched } = route.value;
        const { length } = matched;
        const routeMatched = matched[length - 1];
        const currentMatched = currentRoute.matched;
        if (!routeMatched || !currentMatched.length)
          return -1;
        const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
        if (index > -1)
          return index;
        const parentRecordPath = getOriginalPath(matched[length - 2]);
        return (
          // we are dealing with nested routes
          length > 1 && // if the parent and matched route have the same path, this link is
          // referring to the empty child. Or we currently are on a different
          // child of the same parent
          getOriginalPath(routeMatched) === parentRecordPath && // avoid comparing the child with its parent
          currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index
        );
      });
      const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
      const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
      function navigate(e = {}) {
        if (guardEvent(e)) {
          return router2[unref(props.replace) ? "replace" : "push"](
            unref(props.to)
            // avoid uncaught errors are they are logged anyway
          ).catch(noop$2);
        }
        return Promise.resolve();
      }
      return {
        route,
        href: computed(() => route.value.href),
        isActive,
        isExactActive,
        navigate
      };
    }
    const RouterLinkImpl = /* @__PURE__ */ defineComponent$1({
      name: "RouterLink",
      compatConfig: { MODE: 3 },
      props: {
        to: {
          type: [String, Object],
          required: true
        },
        replace: Boolean,
        activeClass: String,
        // inactiveClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
          type: String,
          default: "page"
        }
      },
      useLink: useLink$1,
      setup(props, { slots }) {
        const link2 = reactive(useLink$1(props));
        const { options } = inject$1(routerKey);
        const elClass = computed(() => ({
          [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link2.isActive,
          // [getLinkClass(
          //   props.inactiveClass,
          //   options.linkInactiveClass,
          //   'router-link-inactive'
          // )]: !link.isExactActive,
          [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link2.isExactActive
        }));
        return () => {
          const children = slots.default && slots.default(link2);
          return props.custom ? children : h("a", {
            "aria-current": link2.isExactActive ? props.ariaCurrentValue : null,
            href: link2.href,
            // this would override user added attrs but Vue will still add
            // the listener, so we end up triggering both
            onClick: link2.navigate,
            class: elClass.value
          }, children);
        };
      }
    });
    const RouterLink = RouterLinkImpl;
    function guardEvent(e) {
      if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
        return;
      if (e.defaultPrevented)
        return;
      if (e.button !== void 0 && e.button !== 0)
        return;
      if (e.currentTarget && e.currentTarget.getAttribute) {
        const target2 = e.currentTarget.getAttribute("target");
        if (/\b_blank\b/i.test(target2))
          return;
      }
      if (e.preventDefault)
        e.preventDefault();
      return true;
    }
    function includesParams(outer, inner) {
      for (const key in inner) {
        const innerValue = inner[key];
        const outerValue = outer[key];
        if (typeof innerValue === "string") {
          if (innerValue !== outerValue)
            return false;
        } else {
          if (!isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i2) => value !== outerValue[i2]))
            return false;
        }
      }
      return true;
    }
    function getOriginalPath(record) {
      return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
    }
    const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
    const RouterViewImpl = /* @__PURE__ */ defineComponent$1({
      name: "RouterView",
      // #674 we manually inherit them
      inheritAttrs: false,
      props: {
        name: {
          type: String,
          default: "default"
        },
        route: Object
      },
      // Better compat for @vue/compat users
      // https://github.com/vuejs/router/issues/1315
      compatConfig: { MODE: 3 },
      setup(props, { attrs, slots }) {
        const injectedRoute = inject$1(routerViewLocationKey);
        const routeToDisplay = computed(() => props.route || injectedRoute.value);
        const injectedDepth = inject$1(viewDepthKey, 0);
        const depth = computed(() => {
          let initialDepth = unref(injectedDepth);
          const { matched } = routeToDisplay.value;
          let matchedRoute;
          while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
            initialDepth++;
          }
          return initialDepth;
        });
        const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);
        provide(viewDepthKey, computed(() => depth.value + 1));
        provide(matchedRouteKey, matchedRouteRef);
        provide(routerViewLocationKey, routeToDisplay);
        const viewRef = ref$1();
        watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {
          if (to) {
            to.instances[name] = instance;
            if (from && from !== to && instance && instance === oldInstance) {
              if (!to.leaveGuards.size) {
                to.leaveGuards = from.leaveGuards;
              }
              if (!to.updateGuards.size) {
                to.updateGuards = from.updateGuards;
              }
            }
          }
          if (instance && to && // if there is no instance but to and from are the same this might be
          // the first visit
          (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
            (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));
          }
        }, { flush: "post" });
        return () => {
          const route = routeToDisplay.value;
          const currentName = props.name;
          const matchedRoute = matchedRouteRef.value;
          const ViewComponent = matchedRoute && matchedRoute.components[currentName];
          if (!ViewComponent) {
            return normalizeSlot(slots.default, { Component: ViewComponent, route });
          }
          const routePropsOption = matchedRoute.props[currentName];
          const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
          const onVnodeUnmounted = (vnode) => {
            if (vnode.component.isUnmounted) {
              matchedRoute.instances[currentName] = null;
            }
          };
          const component = h(ViewComponent, assign$3({}, routeProps, attrs, {
            onVnodeUnmounted,
            ref: viewRef
          }));
          return (
            // pass the vnode to the slot as a prop.
            // h and <component :is="..."> both accept vnodes
            normalizeSlot(slots.default, { Component: component, route }) || component
          );
        };
      }
    });
    function normalizeSlot(slot, data) {
      if (!slot)
        return null;
      const slotContent = slot(data);
      return slotContent.length === 1 ? slotContent[0] : slotContent;
    }
    const RouterView = RouterViewImpl;
    function createRouter(options) {
      const matcher = createRouterMatcher(options.routes, options);
      const parseQuery$1 = options.parseQuery || parseQuery;
      const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
      const routerHistory = options.history;
      const beforeGuards = useCallbacks();
      const beforeResolveGuards = useCallbacks();
      const afterGuards = useCallbacks();
      const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
      let pendingLocation = START_LOCATION_NORMALIZED;
      if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
        history.scrollRestoration = "manual";
      }
      const normalizeParams2 = applyToParams.bind(null, (paramValue) => "" + paramValue);
      const encodeParams = applyToParams.bind(null, encodeParam);
      const decodeParams = (
        // @ts-expect-error: intentionally avoid the type check
        applyToParams.bind(null, decode$2)
      );
      function addRoute(parentOrRoute, route) {
        let parent;
        let record;
        if (isRouteName(parentOrRoute)) {
          parent = matcher.getRecordMatcher(parentOrRoute);
          record = route;
        } else {
          record = parentOrRoute;
        }
        return matcher.addRoute(record, parent);
      }
      function removeRoute(name) {
        const recordMatcher = matcher.getRecordMatcher(name);
        if (recordMatcher) {
          matcher.removeRoute(recordMatcher);
        }
      }
      function getRoutes() {
        return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
      }
      function hasRoute(name) {
        return !!matcher.getRecordMatcher(name);
      }
      function resolve2(rawLocation, currentLocation) {
        currentLocation = assign$3({}, currentLocation || currentRoute.value);
        if (typeof rawLocation === "string") {
          const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
          const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
          const href2 = routerHistory.createHref(locationNormalized.fullPath);
          return assign$3(locationNormalized, matchedRoute2, {
            params: decodeParams(matchedRoute2.params),
            hash: decode$2(locationNormalized.hash),
            redirectedFrom: void 0,
            href: href2
          });
        }
        let matcherLocation;
        if ("path" in rawLocation) {
          matcherLocation = assign$3({}, rawLocation, {
            path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
          });
        } else {
          const targetParams = assign$3({}, rawLocation.params);
          for (const key in targetParams) {
            if (targetParams[key] == null) {
              delete targetParams[key];
            }
          }
          matcherLocation = assign$3({}, rawLocation, {
            params: encodeParams(targetParams)
          });
          currentLocation.params = encodeParams(currentLocation.params);
        }
        const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
        const hash = rawLocation.hash || "";
        matchedRoute.params = normalizeParams2(decodeParams(matchedRoute.params));
        const fullPath = stringifyURL(stringifyQuery$1, assign$3({}, rawLocation, {
          hash: encodeHash(hash),
          path: matchedRoute.path
        }));
        const href = routerHistory.createHref(fullPath);
        return assign$3({
          fullPath,
          // keep the hash encoded so fullPath is effectively path + encodedQuery +
          // hash
          hash,
          query: (
            // if the user is using a custom query lib like qs, we might have
            // nested objects, so we keep the query as is, meaning it can contain
            // numbers at `$route.query`, but at the point, the user will have to
            // use their own type anyway.
            // https://github.com/vuejs/router/issues/328#issuecomment-649481567
            stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
          )
        }, matchedRoute, {
          redirectedFrom: void 0,
          href
        });
      }
      function locationAsObject(to) {
        return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign$3({}, to);
      }
      function checkCanceledNavigation(to, from) {
        if (pendingLocation !== to) {
          return createRouterError(8, {
            from,
            to
          });
        }
      }
      function push(to) {
        return pushWithRedirect(to);
      }
      function replace2(to) {
        return push(assign$3(locationAsObject(to), { replace: true }));
      }
      function handleRedirectRecord(to) {
        const lastMatched = to.matched[to.matched.length - 1];
        if (lastMatched && lastMatched.redirect) {
          const { redirect } = lastMatched;
          let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
          if (typeof newTargetLocation === "string") {
            newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : (
              // force empty params
              { path: newTargetLocation }
            );
            newTargetLocation.params = {};
          }
          return assign$3({
            query: to.query,
            hash: to.hash,
            // avoid transferring params if the redirect has a path
            params: "path" in newTargetLocation ? {} : to.params
          }, newTargetLocation);
        }
      }
      function pushWithRedirect(to, redirectedFrom) {
        const targetLocation = pendingLocation = resolve2(to);
        const from = currentRoute.value;
        const data = to.state;
        const force = to.force;
        const replace22 = to.replace === true;
        const shouldRedirect = handleRedirectRecord(targetLocation);
        if (shouldRedirect)
          return pushWithRedirect(
            assign$3(locationAsObject(shouldRedirect), {
              state: typeof shouldRedirect === "object" ? assign$3({}, data, shouldRedirect.state) : data,
              force,
              replace: replace22
            }),
            // keep original redirectedFrom if it exists
            redirectedFrom || targetLocation
          );
        const toLocation = targetLocation;
        toLocation.redirectedFrom = redirectedFrom;
        let failure;
        if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
          failure = createRouterError(16, { to: toLocation, from });
          handleScroll(
            from,
            from,
            // this is a push, the only way for it to be triggered from a
            // history.listen is with a redirect, which makes it become a push
            true,
            // This cannot be the first navigation because the initial location
            // cannot be manually navigated to
            false
          );
        }
        return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error2) => isNavigationFailure(error2) ? (
          // navigation redirects still mark the router as ready
          isNavigationFailure(
            error2,
            2
            /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
          ) ? error2 : markAsReady(error2)
        ) : (
          // reject any unknown error
          triggerError(error2, toLocation, from)
        )).then((failure2) => {
          if (failure2) {
            if (isNavigationFailure(
              failure2,
              2
              /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
            )) {
              return pushWithRedirect(
                // keep options
                assign$3({
                  // preserve an existing replacement but allow the redirect to override it
                  replace: replace22
                }, locationAsObject(failure2.to), {
                  state: typeof failure2.to === "object" ? assign$3({}, data, failure2.to.state) : data,
                  force
                }),
                // preserve the original redirectedFrom if any
                redirectedFrom || toLocation
              );
            }
          } else {
            failure2 = finalizeNavigation(toLocation, from, true, replace22, data);
          }
          triggerAfterEach(toLocation, from, failure2);
          return failure2;
        });
      }
      function checkCanceledNavigationAndReject(to, from) {
        const error2 = checkCanceledNavigation(to, from);
        return error2 ? Promise.reject(error2) : Promise.resolve();
      }
      function runWithContext(fn) {
        const app2 = installedApps.values().next().value;
        return app2 && typeof app2.runWithContext === "function" ? app2.runWithContext(fn) : fn();
      }
      function navigate(to, from) {
        let guards;
        const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
        guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from);
        for (const record of leavingRecords) {
          record.leaveGuards.forEach((guard) => {
            guards.push(guardToPromiseFn(guard, to, from));
          });
        }
        const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards).then(() => {
          guards = [];
          for (const guard of beforeGuards.list()) {
            guards.push(guardToPromiseFn(guard, to, from));
          }
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).then(() => {
          guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from);
          for (const record of updatingRecords) {
            record.updateGuards.forEach((guard) => {
              guards.push(guardToPromiseFn(guard, to, from));
            });
          }
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).then(() => {
          guards = [];
          for (const record of enteringRecords) {
            if (record.beforeEnter) {
              if (isArray(record.beforeEnter)) {
                for (const beforeEnter of record.beforeEnter)
                  guards.push(guardToPromiseFn(beforeEnter, to, from));
              } else {
                guards.push(guardToPromiseFn(record.beforeEnter, to, from));
              }
            }
          }
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).then(() => {
          to.matched.forEach((record) => record.enterCallbacks = {});
          guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from);
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).then(() => {
          guards = [];
          for (const guard of beforeResolveGuards.list()) {
            guards.push(guardToPromiseFn(guard, to, from));
          }
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).catch((err) => isNavigationFailure(
          err,
          8
          /* ErrorTypes.NAVIGATION_CANCELLED */
        ) ? err : Promise.reject(err));
      }
      function triggerAfterEach(to, from, failure) {
        afterGuards.list().forEach((guard) => runWithContext(() => guard(to, from, failure)));
      }
      function finalizeNavigation(toLocation, from, isPush, replace22, data) {
        const error2 = checkCanceledNavigation(toLocation, from);
        if (error2)
          return error2;
        const isFirstNavigation = from === START_LOCATION_NORMALIZED;
        const state = !isBrowser ? {} : history.state;
        if (isPush) {
          if (replace22 || isFirstNavigation)
            routerHistory.replace(toLocation.fullPath, assign$3({
              scroll: isFirstNavigation && state && state.scroll
            }, data));
          else
            routerHistory.push(toLocation.fullPath, data);
        }
        currentRoute.value = toLocation;
        handleScroll(toLocation, from, isPush, isFirstNavigation);
        markAsReady();
      }
      let removeHistoryListener;
      function setupListeners() {
        if (removeHistoryListener)
          return;
        removeHistoryListener = routerHistory.listen((to, _from, info) => {
          if (!router2.listening)
            return;
          const toLocation = resolve2(to);
          const shouldRedirect = handleRedirectRecord(toLocation);
          if (shouldRedirect) {
            pushWithRedirect(assign$3(shouldRedirect, { replace: true }), toLocation).catch(noop$2);
            return;
          }
          pendingLocation = toLocation;
          const from = currentRoute.value;
          if (isBrowser) {
            saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
          }
          navigate(toLocation, from).catch((error2) => {
            if (isNavigationFailure(
              error2,
              4 | 8
              /* ErrorTypes.NAVIGATION_CANCELLED */
            )) {
              return error2;
            }
            if (isNavigationFailure(
              error2,
              2
              /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
            )) {
              pushWithRedirect(
                error2.to,
                toLocation
                // avoid an uncaught rejection, let push call triggerError
              ).then((failure) => {
                if (isNavigationFailure(
                  failure,
                  4 | 16
                  /* ErrorTypes.NAVIGATION_DUPLICATED */
                ) && !info.delta && info.type === NavigationType.pop) {
                  routerHistory.go(-1, false);
                }
              }).catch(noop$2);
              return Promise.reject();
            }
            if (info.delta) {
              routerHistory.go(-info.delta, false);
            }
            return triggerError(error2, toLocation, from);
          }).then((failure) => {
            failure = failure || finalizeNavigation(
              // after navigation, all matched components are resolved
              toLocation,
              from,
              false
            );
            if (failure) {
              if (info.delta && // a new navigation has been triggered, so we do not want to revert, that will change the current history
              // entry while a different route is displayed
              !isNavigationFailure(
                failure,
                8
                /* ErrorTypes.NAVIGATION_CANCELLED */
              )) {
                routerHistory.go(-info.delta, false);
              } else if (info.type === NavigationType.pop && isNavigationFailure(
                failure,
                4 | 16
                /* ErrorTypes.NAVIGATION_DUPLICATED */
              )) {
                routerHistory.go(-1, false);
              }
            }
            triggerAfterEach(toLocation, from, failure);
          }).catch(noop$2);
        });
      }
      let readyHandlers = useCallbacks();
      let errorListeners = useCallbacks();
      let ready;
      function triggerError(error2, to, from) {
        markAsReady(error2);
        const list2 = errorListeners.list();
        if (list2.length) {
          list2.forEach((handler) => handler(error2, to, from));
        } else {
          console.error(error2);
        }
        return Promise.reject(error2);
      }
      function isReady() {
        if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
          return Promise.resolve();
        return new Promise((resolve22, reject) => {
          readyHandlers.add([resolve22, reject]);
        });
      }
      function markAsReady(err) {
        if (!ready) {
          ready = !err;
          setupListeners();
          readyHandlers.list().forEach(([resolve22, reject]) => err ? reject(err) : resolve22());
          readyHandlers.reset();
        }
        return err;
      }
      function handleScroll(to, from, isPush, isFirstNavigation) {
        const { scrollBehavior } = options;
        if (!isBrowser || !scrollBehavior)
          return Promise.resolve();
        const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
        return nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to, from));
      }
      const go = (delta2) => routerHistory.go(delta2);
      let started;
      const installedApps = /* @__PURE__ */ new Set();
      const router2 = {
        currentRoute,
        listening: true,
        addRoute,
        removeRoute,
        hasRoute,
        getRoutes,
        resolve: resolve2,
        options,
        push,
        replace: replace2,
        go,
        back: () => go(-1),
        forward: () => go(1),
        beforeEach: beforeGuards.add,
        beforeResolve: beforeResolveGuards.add,
        afterEach: afterGuards.add,
        onError: errorListeners.add,
        isReady,
        install(app2) {
          const router22 = this;
          app2.component("RouterLink", RouterLink);
          app2.component("RouterView", RouterView);
          app2.config.globalProperties.$router = router22;
          Object.defineProperty(app2.config.globalProperties, "$route", {
            enumerable: true,
            get: () => unref(currentRoute)
          });
          if (isBrowser && // used for the initial navigation client side to avoid pushing
          // multiple times when the router is used in multiple apps
          !started && currentRoute.value === START_LOCATION_NORMALIZED) {
            started = true;
            push(routerHistory.location).catch((err) => {
            });
          }
          const reactiveRoute = {};
          for (const key in START_LOCATION_NORMALIZED) {
            Object.defineProperty(reactiveRoute, key, {
              get: () => currentRoute.value[key],
              enumerable: true
            });
          }
          app2.provide(routerKey, router22);
          app2.provide(routeLocationKey, shallowReactive(reactiveRoute));
          app2.provide(routerViewLocationKey, currentRoute);
          const unmountApp = app2.unmount;
          installedApps.add(app2);
          app2.unmount = function() {
            installedApps.delete(app2);
            if (installedApps.size < 1) {
              pendingLocation = START_LOCATION_NORMALIZED;
              removeHistoryListener && removeHistoryListener();
              removeHistoryListener = null;
              currentRoute.value = START_LOCATION_NORMALIZED;
              started = false;
              ready = false;
            }
            unmountApp();
          };
        }
      };
      function runGuardQueue(guards) {
        return guards.reduce((promise, guard) => promise.then(() => runWithContext(guard)), Promise.resolve());
      }
      return router2;
    }
    function extractChangingRecords(to, from) {
      const leavingRecords = [];
      const updatingRecords = [];
      const enteringRecords = [];
      const len = Math.max(from.matched.length, to.matched.length);
      for (let i2 = 0; i2 < len; i2++) {
        const recordFrom = from.matched[i2];
        if (recordFrom) {
          if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))
            updatingRecords.push(recordFrom);
          else
            leavingRecords.push(recordFrom);
        }
        const recordTo = to.matched[i2];
        if (recordTo) {
          if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) {
            enteringRecords.push(recordTo);
          }
        }
      }
      return [leavingRecords, updatingRecords, enteringRecords];
    }
    function useRouter$1() {
      return inject$1(routerKey);
    }
    let evbc$2;
    let router$1;
    let notyf;
    const _sfc_main$C = /* @__PURE__ */ defineComponent$1({
      data: () => ({
        drawer: false,
        evbc_disconnected: false,
        evbc_status: "",
        version: "0.1.0"
      }),
      computed: {
        connectionUrl() {
          var _a2;
          return ((_a2 = evbc$2 == null ? void 0 : evbc$2._cxn) == null ? void 0 : _a2._url) ?? "nothing";
        }
      },
      methods: {
        async changeInstance() {
          let notification;
          const timeout = setTimeout(() => {
            notification = notyf.open({ type: "warning", message: "Disconnecting from EVerest backend ...", ripple: false });
          }, 250);
          await evbc$2.disconnect();
          clearTimeout(timeout);
          if (notification) {
            notyf.dismiss(notification);
          }
          await router$1.push({ path: "/login", query: { auto_connect: "false" } });
        }
      },
      created() {
        evbc$2 = inject$1("evbc");
        router$1 = useRouter$1();
        notyf = inject$1("notyf");
        evbc$2.on("connection_state", (ev) => {
          this.evbc_status = ev.text;
          if (ev.type === "RECONNECT" || ev.type === "IDLE") {
            this.evbc_disconnected = true;
          } else if (ev.type === "INITIALIZED") {
            this.evbc_disconnected = false;
          }
        });
      }
    });
    const _imports_0 = "/everest-admin-panel/pr-86/img/icons/everest_lf_logo_white.svg";
    function propsFactory(props, source) {
      return (defaults2) => {
        return Object.keys(props).reduce((obj, prop2) => {
          const isObjectDefinition = typeof props[prop2] === "object" && props[prop2] != null && !Array.isArray(props[prop2]);
          const definition = isObjectDefinition ? props[prop2] : {
            type: props[prop2]
          };
          if (defaults2 && prop2 in defaults2) {
            obj[prop2] = {
              ...definition,
              default: defaults2[prop2]
            };
          } else {
            obj[prop2] = definition;
          }
          if (source && !obj[prop2].source) {
            obj[prop2].source = source;
          }
          return obj;
        }, {});
      };
    }
    const makeComponentProps = propsFactory({
      class: [String, Array],
      style: {
        type: [String, Array, Object],
        default: null
      }
    }, "component");
    const IN_BROWSER = typeof window !== "undefined";
    const SUPPORTS_INTERSECTION = IN_BROWSER && "IntersectionObserver" in window;
    const SUPPORTS_TOUCH = IN_BROWSER && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0);
    const SUPPORTS_EYE_DROPPER = IN_BROWSER && "EyeDropper" in window;
    function _classPrivateFieldInitSpec(obj, privateMap, value) {
      _checkPrivateRedeclaration(obj, privateMap);
      privateMap.set(obj, value);
    }
    function _checkPrivateRedeclaration(obj, privateCollection) {
      if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
      }
    }
    function _classPrivateFieldSet(receiver, privateMap, value) {
      var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
      _classApplyDescriptorSet(receiver, descriptor, value);
      return value;
    }
    function _classApplyDescriptorSet(receiver, descriptor, value) {
      if (descriptor.set) {
        descriptor.set.call(receiver, value);
      } else {
        if (!descriptor.writable) {
          throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
      }
    }
    function _classPrivateFieldGet(receiver, privateMap) {
      var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
      return _classApplyDescriptorGet(receiver, descriptor);
    }
    function _classExtractFieldDescriptor(receiver, privateMap, action) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
      }
      return privateMap.get(receiver);
    }
    function _classApplyDescriptorGet(receiver, descriptor) {
      if (descriptor.get) {
        return descriptor.get.call(receiver);
      }
      return descriptor.value;
    }
    function getNestedValue(obj, path, fallback) {
      const last = path.length - 1;
      if (last < 0)
        return obj === void 0 ? fallback : obj;
      for (let i2 = 0; i2 < last; i2++) {
        if (obj == null) {
          return fallback;
        }
        obj = obj[path[i2]];
      }
      if (obj == null)
        return fallback;
      return obj[path[last]] === void 0 ? fallback : obj[path[last]];
    }
    function deepEqual(a, b) {
      if (a === b)
        return true;
      if (a instanceof Date && b instanceof Date && a.getTime() !== b.getTime()) {
        return false;
      }
      if (a !== Object(a) || b !== Object(b)) {
        return false;
      }
      const props = Object.keys(a);
      if (props.length !== Object.keys(b).length) {
        return false;
      }
      return props.every((p2) => deepEqual(a[p2], b[p2]));
    }
    function getObjectValueByPath(obj, path, fallback) {
      if (obj == null || !path || typeof path !== "string")
        return fallback;
      if (obj[path] !== void 0)
        return obj[path];
      path = path.replace(/\[(\w+)\]/g, ".$1");
      path = path.replace(/^\./, "");
      return getNestedValue(obj, path.split("."), fallback);
    }
    function getPropertyFromItem(item, property, fallback) {
      if (property === true)
        return item === void 0 ? fallback : item;
      if (property == null || typeof property === "boolean")
        return fallback;
      if (item !== Object(item)) {
        if (typeof property !== "function")
          return fallback;
        const value2 = property(item, fallback);
        return typeof value2 === "undefined" ? fallback : value2;
      }
      if (typeof property === "string")
        return getObjectValueByPath(item, property, fallback);
      if (Array.isArray(property))
        return getNestedValue(item, property, fallback);
      if (typeof property !== "function")
        return fallback;
      const value = property(item, fallback);
      return typeof value === "undefined" ? fallback : value;
    }
    function createRange(length) {
      let start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      return Array.from({
        length
      }, (v, k) => start + k);
    }
    function convertToUnit(str) {
      let unit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "px";
      if (str == null || str === "") {
        return void 0;
      } else if (isNaN(+str)) {
        return String(str);
      } else if (!isFinite(+str)) {
        return void 0;
      } else {
        return `${Number(str)}${unit}`;
      }
    }
    function isObject$2(obj) {
      return obj !== null && typeof obj === "object" && !Array.isArray(obj);
    }
    function refElement(obj) {
      if (obj && "$el" in obj) {
        const el2 = obj.$el;
        if ((el2 == null ? void 0 : el2.nodeType) === Node.TEXT_NODE) {
          return el2.nextElementSibling;
        }
        return el2;
      }
      return obj;
    }
    const keyCodes = Object.freeze({
      enter: 13,
      tab: 9,
      delete: 46,
      esc: 27,
      space: 32,
      up: 38,
      down: 40,
      left: 37,
      right: 39,
      end: 35,
      home: 36,
      del: 46,
      backspace: 8,
      insert: 45,
      pageup: 33,
      pagedown: 34,
      shift: 16
    });
    const keyValues = Object.freeze({
      enter: "Enter",
      tab: "Tab",
      delete: "Delete",
      esc: "Escape",
      space: "Space",
      up: "ArrowUp",
      down: "ArrowDown",
      left: "ArrowLeft",
      right: "ArrowRight",
      end: "End",
      home: "Home",
      del: "Delete",
      backspace: "Backspace",
      insert: "Insert",
      pageup: "PageUp",
      pagedown: "PageDown",
      shift: "Shift"
    });
    function keys(o) {
      return Object.keys(o);
    }
    function has$2(obj, key) {
      return key.every((k) => obj.hasOwnProperty(k));
    }
    function pick(obj, paths) {
      const found = {};
      const keys2 = new Set(Object.keys(obj));
      for (const path of paths) {
        if (keys2.has(path)) {
          found[path] = obj[path];
        }
      }
      return found;
    }
    function pickWithRest(obj, paths, exclude) {
      const found = /* @__PURE__ */ Object.create(null);
      const rest = /* @__PURE__ */ Object.create(null);
      for (const key in obj) {
        if (paths.some((path) => path instanceof RegExp ? path.test(key) : path === key) && !(exclude == null ? void 0 : exclude.some((path) => path === key))) {
          found[key] = obj[key];
        } else {
          rest[key] = obj[key];
        }
      }
      return [found, rest];
    }
    function omit$1(obj, exclude) {
      const clone2 = {
        ...obj
      };
      exclude.forEach((prop2) => delete clone2[prop2]);
      return clone2;
    }
    function only(obj, include) {
      const clone2 = {};
      include.forEach((prop2) => clone2[prop2] = obj[prop2]);
      return clone2;
    }
    const onRE = /^on[^a-z]/;
    const isOn = (key) => onRE.test(key);
    const bubblingEvents = ["onAfterscriptexecute", "onAnimationcancel", "onAnimationend", "onAnimationiteration", "onAnimationstart", "onAuxclick", "onBeforeinput", "onBeforescriptexecute", "onChange", "onClick", "onCompositionend", "onCompositionstart", "onCompositionupdate", "onContextmenu", "onCopy", "onCut", "onDblclick", "onFocusin", "onFocusout", "onFullscreenchange", "onFullscreenerror", "onGesturechange", "onGestureend", "onGesturestart", "onGotpointercapture", "onInput", "onKeydown", "onKeypress", "onKeyup", "onLostpointercapture", "onMousedown", "onMousemove", "onMouseout", "onMouseover", "onMouseup", "onMousewheel", "onPaste", "onPointercancel", "onPointerdown", "onPointerenter", "onPointerleave", "onPointermove", "onPointerout", "onPointerover", "onPointerup", "onReset", "onSelect", "onSubmit", "onTouchcancel", "onTouchend", "onTouchmove", "onTouchstart", "onTransitioncancel", "onTransitionend", "onTransitionrun", "onTransitionstart", "onWheel"];
    const compositionIgnoreKeys = ["ArrowUp", "ArrowDown", "ArrowRight", "ArrowLeft", "Enter", "Escape", "Tab", " "];
    function isComposingIgnoreKey(e) {
      return e.isComposing && compositionIgnoreKeys.includes(e.key);
    }
    function filterInputAttrs(attrs) {
      const [events, props] = pickWithRest(attrs, [onRE]);
      const inputEvents = omit$1(events, bubblingEvents);
      const [rootAttrs, inputAttrs] = pickWithRest(props, ["class", "style", "id", /^data-/]);
      Object.assign(rootAttrs, events);
      Object.assign(inputAttrs, inputEvents);
      return [rootAttrs, inputAttrs];
    }
    function wrapInArray(v) {
      return v == null ? [] : Array.isArray(v) ? v : [v];
    }
    function debounce(fn, delay) {
      let timeoutId = 0;
      const wrap = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => fn(...args), unref(delay));
      };
      wrap.clear = () => {
        clearTimeout(timeoutId);
      };
      wrap.immediate = fn;
      return wrap;
    }
    function clamp(value) {
      let min = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      let max = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      return Math.max(min, Math.min(max, value));
    }
    function getDecimals(value) {
      const trimmedStr = value.toString().trim();
      return trimmedStr.includes(".") ? trimmedStr.length - trimmedStr.indexOf(".") - 1 : 0;
    }
    function padEnd(str, length) {
      let char = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
      return str + char.repeat(Math.max(0, length - str.length));
    }
    function padStart(str, length) {
      let char = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
      return char.repeat(Math.max(0, length - str.length)) + str;
    }
    function chunk(str) {
      let size2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      const chunked = [];
      let index = 0;
      while (index < str.length) {
        chunked.push(str.substr(index, size2));
        index += size2;
      }
      return chunked;
    }
    function humanReadableFileSize(bytes) {
      let base2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
      if (bytes < base2) {
        return `${bytes} B`;
      }
      const prefix = base2 === 1024 ? ["Ki", "Mi", "Gi"] : ["k", "M", "G"];
      let unit = -1;
      while (Math.abs(bytes) >= base2 && unit < prefix.length - 1) {
        bytes /= base2;
        ++unit;
      }
      return `${bytes.toFixed(1)} ${prefix[unit]}B`;
    }
    function mergeDeep() {
      let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let target2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let arrayFn = arguments.length > 2 ? arguments[2] : void 0;
      const out = {};
      for (const key in source) {
        out[key] = source[key];
      }
      for (const key in target2) {
        const sourceProperty = source[key];
        const targetProperty = target2[key];
        if (isObject$2(sourceProperty) && isObject$2(targetProperty)) {
          out[key] = mergeDeep(sourceProperty, targetProperty, arrayFn);
          continue;
        }
        if (Array.isArray(sourceProperty) && Array.isArray(targetProperty) && arrayFn) {
          out[key] = arrayFn(sourceProperty, targetProperty);
          continue;
        }
        out[key] = targetProperty;
      }
      return out;
    }
    function flattenFragments(nodes) {
      return nodes.map((node) => {
        if (node.type === Fragment) {
          return flattenFragments(node.children);
        } else {
          return node;
        }
      }).flat();
    }
    function toKebabCase() {
      let str = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      if (toKebabCase.cache.has(str))
        return toKebabCase.cache.get(str);
      const kebab = str.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
      toKebabCase.cache.set(str, kebab);
      return kebab;
    }
    toKebabCase.cache = /* @__PURE__ */ new Map();
    function findChildrenWithProvide(key, vnode) {
      if (!vnode || typeof vnode !== "object")
        return [];
      if (Array.isArray(vnode)) {
        return vnode.map((child) => findChildrenWithProvide(key, child)).flat(1);
      } else if (Array.isArray(vnode.children)) {
        return vnode.children.map((child) => findChildrenWithProvide(key, child)).flat(1);
      } else if (vnode.component) {
        if (Object.getOwnPropertySymbols(vnode.component.provides).includes(key)) {
          return [vnode.component];
        } else if (vnode.component.subTree) {
          return findChildrenWithProvide(key, vnode.component.subTree).flat(1);
        }
      }
      return [];
    }
    var _arr = /* @__PURE__ */ new WeakMap();
    var _pointer = /* @__PURE__ */ new WeakMap();
    class CircularBuffer {
      constructor(size2) {
        _classPrivateFieldInitSpec(this, _arr, {
          writable: true,
          value: []
        });
        _classPrivateFieldInitSpec(this, _pointer, {
          writable: true,
          value: 0
        });
        this.size = size2;
      }
      push(val) {
        _classPrivateFieldGet(this, _arr)[_classPrivateFieldGet(this, _pointer)] = val;
        _classPrivateFieldSet(this, _pointer, (_classPrivateFieldGet(this, _pointer) + 1) % this.size);
      }
      values() {
        return _classPrivateFieldGet(this, _arr).slice(_classPrivateFieldGet(this, _pointer)).concat(_classPrivateFieldGet(this, _arr).slice(0, _classPrivateFieldGet(this, _pointer)));
      }
    }
    function getEventCoordinates(e) {
      if ("touches" in e) {
        return {
          clientX: e.touches[0].clientX,
          clientY: e.touches[0].clientY
        };
      }
      return {
        clientX: e.clientX,
        clientY: e.clientY
      };
    }
    function destructComputed(getter) {
      const refs = reactive({});
      const base2 = computed(getter);
      watchEffect(() => {
        for (const key in base2.value) {
          refs[key] = base2.value[key];
        }
      }, {
        flush: "sync"
      });
      return toRefs(refs);
    }
    function includes(arr, val) {
      return arr.includes(val);
    }
    function eventName(propName) {
      return propName[2].toLowerCase() + propName.slice(3);
    }
    const EventProp = () => [Function, Array];
    function hasEvent(props, name) {
      name = "on" + capitalize(name);
      return !!(props[name] || props[`${name}Once`] || props[`${name}Capture`] || props[`${name}OnceCapture`] || props[`${name}CaptureOnce`]);
    }
    function callEvent(handler) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      if (Array.isArray(handler)) {
        for (const h2 of handler) {
          h2(...args);
        }
      } else if (typeof handler === "function") {
        handler(...args);
      }
    }
    function focusableChildren(el2) {
      let filterByTabIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      const targets = ["button", "[href]", 'input:not([type="hidden"])', "select", "textarea", "[tabindex]"].map((s) => `${s}${filterByTabIndex ? ':not([tabindex="-1"])' : ""}:not([disabled])`).join(", ");
      return [...el2.querySelectorAll(targets)];
    }
    function getNextElement(elements, location2, condition) {
      let _el;
      let idx = elements.indexOf(document.activeElement);
      const inc = location2 === "next" ? 1 : -1;
      do {
        idx += inc;
        _el = elements[idx];
      } while ((!_el || _el.offsetParent == null || !((condition == null ? void 0 : condition(_el)) ?? true)) && idx < elements.length && idx >= 0);
      return _el;
    }
    function focusChild(el2, location2) {
      var _a2, _b, _c, _d;
      const focusable = focusableChildren(el2);
      if (!location2) {
        if (el2 === document.activeElement || !el2.contains(document.activeElement)) {
          (_a2 = focusable[0]) == null ? void 0 : _a2.focus();
        }
      } else if (location2 === "first") {
        (_b = focusable[0]) == null ? void 0 : _b.focus();
      } else if (location2 === "last") {
        (_c = focusable.at(-1)) == null ? void 0 : _c.focus();
      } else if (typeof location2 === "number") {
        (_d = focusable[location2]) == null ? void 0 : _d.focus();
      } else {
        const _el = getNextElement(focusable, location2);
        if (_el)
          _el.focus();
        else
          focusChild(el2, location2 === "next" ? "first" : "last");
      }
    }
    function noop$1() {
    }
    function matchesSelector(el2, selector) {
      const supportsSelector = IN_BROWSER && typeof CSS !== "undefined" && typeof CSS.supports !== "undefined" && CSS.supports(`selector(${selector})`);
      if (!supportsSelector)
        return null;
      try {
        return !!el2 && el2.matches(selector);
      } catch (err) {
        return null;
      }
    }
    function ensureValidVNode(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child))
          return true;
        if (child.type === Comment)
          return false;
        return child.type !== Fragment || ensureValidVNode(child.children);
      }) ? vnodes : null;
    }
    function defer(timeout, cb) {
      if (!IN_BROWSER || timeout === 0) {
        cb();
        return () => {
        };
      }
      const timeoutId = window.setTimeout(cb, timeout);
      return () => window.clearTimeout(timeoutId);
    }
    function isClickInsideElement(event, targetDiv) {
      const mouseX = event.clientX;
      const mouseY = event.clientY;
      const divRect = targetDiv.getBoundingClientRect();
      const divLeft = divRect.left;
      const divTop = divRect.top;
      const divRight = divRect.right;
      const divBottom = divRect.bottom;
      return mouseX >= divLeft && mouseX <= divRight && mouseY >= divTop && mouseY <= divBottom;
    }
    const block$2 = ["top", "bottom"];
    const inline$1 = ["start", "end", "left", "right"];
    function parseAnchor(anchor, isRtl) {
      let [side, align] = anchor.split(" ");
      if (!align) {
        align = includes(block$2, side) ? "start" : includes(inline$1, side) ? "top" : "center";
      }
      return {
        side: toPhysical(side, isRtl),
        align: toPhysical(align, isRtl)
      };
    }
    function toPhysical(str, isRtl) {
      if (str === "start")
        return isRtl ? "right" : "left";
      if (str === "end")
        return isRtl ? "left" : "right";
      return str;
    }
    function flipSide(anchor) {
      return {
        side: {
          center: "center",
          top: "bottom",
          bottom: "top",
          left: "right",
          right: "left"
        }[anchor.side],
        align: anchor.align
      };
    }
    function flipAlign(anchor) {
      return {
        side: anchor.side,
        align: {
          center: "center",
          top: "bottom",
          bottom: "top",
          left: "right",
          right: "left"
        }[anchor.align]
      };
    }
    function flipCorner(anchor) {
      return {
        side: anchor.align,
        align: anchor.side
      };
    }
    function getAxis(anchor) {
      return includes(block$2, anchor.side) ? "y" : "x";
    }
    class Box {
      constructor(_ref) {
        let {
          x,
          y,
          width,
          height
        } = _ref;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
      }
      get top() {
        return this.y;
      }
      get bottom() {
        return this.y + this.height;
      }
      get left() {
        return this.x;
      }
      get right() {
        return this.x + this.width;
      }
    }
    function getOverflow(a, b) {
      return {
        x: {
          before: Math.max(0, b.left - a.left),
          after: Math.max(0, a.right - b.right)
        },
        y: {
          before: Math.max(0, b.top - a.top),
          after: Math.max(0, a.bottom - b.bottom)
        }
      };
    }
    function getTargetBox(target2) {
      if (Array.isArray(target2)) {
        return new Box({
          x: target2[0],
          y: target2[1],
          width: 0,
          height: 0
        });
      } else {
        return target2.getBoundingClientRect();
      }
    }
    function nullifyTransforms(el2) {
      const rect2 = el2.getBoundingClientRect();
      const style = getComputedStyle(el2);
      const tx = style.transform;
      if (tx) {
        let ta, sx, sy, dx, dy;
        if (tx.startsWith("matrix3d(")) {
          ta = tx.slice(9, -1).split(/, /);
          sx = +ta[0];
          sy = +ta[5];
          dx = +ta[12];
          dy = +ta[13];
        } else if (tx.startsWith("matrix(")) {
          ta = tx.slice(7, -1).split(/, /);
          sx = +ta[0];
          sy = +ta[3];
          dx = +ta[4];
          dy = +ta[5];
        } else {
          return new Box(rect2);
        }
        const to = style.transformOrigin;
        const x = rect2.x - dx - (1 - sx) * parseFloat(to);
        const y = rect2.y - dy - (1 - sy) * parseFloat(to.slice(to.indexOf(" ") + 1));
        const w = sx ? rect2.width / sx : el2.offsetWidth + 1;
        const h2 = sy ? rect2.height / sy : el2.offsetHeight + 1;
        return new Box({
          x,
          y,
          width: w,
          height: h2
        });
      } else {
        return new Box(rect2);
      }
    }
    function animate(el2, keyframes, options) {
      if (typeof el2.animate === "undefined")
        return {
          finished: Promise.resolve()
        };
      let animation;
      try {
        animation = el2.animate(keyframes, options);
      } catch (err) {
        return {
          finished: Promise.resolve()
        };
      }
      if (typeof animation.finished === "undefined") {
        animation.finished = new Promise((resolve2) => {
          animation.onfinish = () => {
            resolve2(animation);
          };
        });
      }
      return animation;
    }
    const handlers = /* @__PURE__ */ new WeakMap();
    function bindProps(el2, props) {
      Object.keys(props).forEach((k) => {
        var _a2;
        if (isOn(k)) {
          const name = eventName(k);
          const handler = handlers.get(el2);
          if (props[k] == null) {
            handler == null ? void 0 : handler.forEach((v) => {
              const [n, fn] = v;
              if (n === name) {
                el2.removeEventListener(name, fn);
                handler.delete(v);
              }
            });
          } else if (!handler || !((_a2 = [...handler]) == null ? void 0 : _a2.some((v) => v[0] === name && v[1] === props[k]))) {
            el2.addEventListener(name, props[k]);
            const _handler = handler || /* @__PURE__ */ new Set();
            _handler.add([name, props[k]]);
            if (!handlers.has(el2))
              handlers.set(el2, _handler);
          }
        } else {
          if (props[k] == null) {
            el2.removeAttribute(k);
          } else {
            el2.setAttribute(k, props[k]);
          }
        }
      });
    }
    function unbindProps(el2, props) {
      Object.keys(props).forEach((k) => {
        if (isOn(k)) {
          const name = eventName(k);
          const handler = handlers.get(el2);
          handler == null ? void 0 : handler.forEach((v) => {
            const [n, fn] = v;
            if (n === name) {
              el2.removeEventListener(name, fn);
              handler.delete(v);
            }
          });
        } else {
          el2.removeAttribute(k);
        }
      });
    }
    const mainTRC = 2.4;
    const Rco = 0.2126729;
    const Gco = 0.7151522;
    const Bco = 0.072175;
    const normBG = 0.55;
    const normTXT = 0.58;
    const revTXT = 0.57;
    const revBG = 0.62;
    const blkThrs = 0.03;
    const blkClmp = 1.45;
    const deltaYmin = 5e-4;
    const scaleBoW = 1.25;
    const scaleWoB = 1.25;
    const loConThresh = 0.078;
    const loConFactor = 12.82051282051282;
    const loConOffset = 0.06;
    const loClip = 1e-3;
    function APCAcontrast(text2, background) {
      const Rtxt = (text2.r / 255) ** mainTRC;
      const Gtxt = (text2.g / 255) ** mainTRC;
      const Btxt = (text2.b / 255) ** mainTRC;
      const Rbg = (background.r / 255) ** mainTRC;
      const Gbg = (background.g / 255) ** mainTRC;
      const Bbg = (background.b / 255) ** mainTRC;
      let Ytxt = Rtxt * Rco + Gtxt * Gco + Btxt * Bco;
      let Ybg = Rbg * Rco + Gbg * Gco + Bbg * Bco;
      if (Ytxt <= blkThrs)
        Ytxt += (blkThrs - Ytxt) ** blkClmp;
      if (Ybg <= blkThrs)
        Ybg += (blkThrs - Ybg) ** blkClmp;
      if (Math.abs(Ybg - Ytxt) < deltaYmin)
        return 0;
      let outputContrast;
      if (Ybg > Ytxt) {
        const SAPC = (Ybg ** normBG - Ytxt ** normTXT) * scaleBoW;
        outputContrast = SAPC < loClip ? 0 : SAPC < loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC - loConOffset;
      } else {
        const SAPC = (Ybg ** revBG - Ytxt ** revTXT) * scaleWoB;
        outputContrast = SAPC > -loClip ? 0 : SAPC > -loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC + loConOffset;
      }
      return outputContrast * 100;
    }
    function consoleWarn(message) {
    }
    function deprecate(original, replacement) {
      replacement = Array.isArray(replacement) ? replacement.slice(0, -1).map((s) => `'${s}'`).join(", ") + ` or '${replacement.at(-1)}'` : `'${replacement}'`;
    }
    const delta$1 = 0.20689655172413793;
    const cielabForwardTransform = (t) => t > delta$1 ** 3 ? Math.cbrt(t) : t / (3 * delta$1 ** 2) + 4 / 29;
    const cielabReverseTransform = (t) => t > delta$1 ? t ** 3 : 3 * delta$1 ** 2 * (t - 4 / 29);
    function fromXYZ$1(xyz) {
      const transform2 = cielabForwardTransform;
      const transformedY = transform2(xyz[1]);
      return [116 * transformedY - 16, 500 * (transform2(xyz[0] / 0.95047) - transformedY), 200 * (transformedY - transform2(xyz[2] / 1.08883))];
    }
    function toXYZ$1(lab) {
      const transform2 = cielabReverseTransform;
      const Ln = (lab[0] + 16) / 116;
      return [transform2(Ln + lab[1] / 500) * 0.95047, transform2(Ln), transform2(Ln - lab[2] / 200) * 1.08883];
    }
    const srgbForwardMatrix = [[3.2406, -1.5372, -0.4986], [-0.9689, 1.8758, 0.0415], [0.0557, -0.204, 1.057]];
    const srgbForwardTransform = (C) => C <= 31308e-7 ? C * 12.92 : 1.055 * C ** (1 / 2.4) - 0.055;
    const srgbReverseMatrix = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, 0.1192, 0.9505]];
    const srgbReverseTransform = (C) => C <= 0.04045 ? C / 12.92 : ((C + 0.055) / 1.055) ** 2.4;
    function fromXYZ(xyz) {
      const rgb2 = Array(3);
      const transform2 = srgbForwardTransform;
      const matrix = srgbForwardMatrix;
      for (let i2 = 0; i2 < 3; ++i2) {
        rgb2[i2] = Math.round(clamp(transform2(matrix[i2][0] * xyz[0] + matrix[i2][1] * xyz[1] + matrix[i2][2] * xyz[2])) * 255);
      }
      return {
        r: rgb2[0],
        g: rgb2[1],
        b: rgb2[2]
      };
    }
    function toXYZ(_ref) {
      let {
        r,
        g,
        b
      } = _ref;
      const xyz = [0, 0, 0];
      const transform2 = srgbReverseTransform;
      const matrix = srgbReverseMatrix;
      r = transform2(r / 255);
      g = transform2(g / 255);
      b = transform2(b / 255);
      for (let i2 = 0; i2 < 3; ++i2) {
        xyz[i2] = matrix[i2][0] * r + matrix[i2][1] * g + matrix[i2][2] * b;
      }
      return xyz;
    }
    function isCssColor(color) {
      return !!color && /^(#|var\(--|(rgb|hsl)a?\()/.test(color);
    }
    function isParsableColor(color) {
      return isCssColor(color) && !/^((rgb|hsl)a?\()?var\(--/.test(color);
    }
    const cssColorRe = /^(?<fn>(?:rgb|hsl)a?)\((?<values>.+)\)/;
    const mappers = {
      rgb: (r, g, b, a) => ({
        r,
        g,
        b,
        a
      }),
      rgba: (r, g, b, a) => ({
        r,
        g,
        b,
        a
      }),
      hsl: (h2, s, l, a) => HSLtoRGB({
        h: h2,
        s,
        l,
        a
      }),
      hsla: (h2, s, l, a) => HSLtoRGB({
        h: h2,
        s,
        l,
        a
      }),
      hsv: (h2, s, v, a) => HSVtoRGB({
        h: h2,
        s,
        v,
        a
      }),
      hsva: (h2, s, v, a) => HSVtoRGB({
        h: h2,
        s,
        v,
        a
      })
    };
    function parseColor(color) {
      if (typeof color === "number") {
        return {
          r: (color & 16711680) >> 16,
          g: (color & 65280) >> 8,
          b: color & 255
        };
      } else if (typeof color === "string" && cssColorRe.test(color)) {
        const {
          groups
        } = color.match(cssColorRe);
        const {
          fn,
          values
        } = groups;
        const realValues = values.split(/,\s*/).map((v) => {
          if (v.endsWith("%") && ["hsl", "hsla", "hsv", "hsva"].includes(fn)) {
            return parseFloat(v) / 100;
          } else {
            return parseFloat(v);
          }
        });
        return mappers[fn](...realValues);
      } else if (typeof color === "string") {
        let hex2 = color.startsWith("#") ? color.slice(1) : color;
        if ([3, 4].includes(hex2.length)) {
          hex2 = hex2.split("").map((char) => char + char).join("");
        } else if (![6, 8].includes(hex2.length))
          ;
        return HexToRGB(hex2);
      } else if (typeof color === "object") {
        if (has$2(color, ["r", "g", "b"])) {
          return color;
        } else if (has$2(color, ["h", "s", "l"])) {
          return HSVtoRGB(HSLtoHSV(color));
        } else if (has$2(color, ["h", "s", "v"])) {
          return HSVtoRGB(color);
        }
      }
      throw new TypeError(`Invalid color: ${color == null ? color : String(color) || color.constructor.name}
Expected #hex, #hexa, rgb(), rgba(), hsl(), hsla(), object or number`);
    }
    function HSVtoRGB(hsva) {
      const {
        h: h2,
        s,
        v,
        a
      } = hsva;
      const f = (n) => {
        const k = (n + h2 / 60) % 6;
        return v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
      };
      const rgb2 = [f(5), f(3), f(1)].map((v2) => Math.round(v2 * 255));
      return {
        r: rgb2[0],
        g: rgb2[1],
        b: rgb2[2],
        a
      };
    }
    function HSLtoRGB(hsla2) {
      return HSVtoRGB(HSLtoHSV(hsla2));
    }
    function RGBtoHSV(rgba2) {
      if (!rgba2)
        return {
          h: 0,
          s: 1,
          v: 1,
          a: 1
        };
      const r = rgba2.r / 255;
      const g = rgba2.g / 255;
      const b = rgba2.b / 255;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let h2 = 0;
      if (max !== min) {
        if (max === r) {
          h2 = 60 * (0 + (g - b) / (max - min));
        } else if (max === g) {
          h2 = 60 * (2 + (b - r) / (max - min));
        } else if (max === b) {
          h2 = 60 * (4 + (r - g) / (max - min));
        }
      }
      if (h2 < 0)
        h2 = h2 + 360;
      const s = max === 0 ? 0 : (max - min) / max;
      const hsv = [h2, s, max];
      return {
        h: hsv[0],
        s: hsv[1],
        v: hsv[2],
        a: rgba2.a
      };
    }
    function HSVtoHSL(hsva) {
      const {
        h: h2,
        s,
        v,
        a
      } = hsva;
      const l = v - v * s / 2;
      const sprime = l === 1 || l === 0 ? 0 : (v - l) / Math.min(l, 1 - l);
      return {
        h: h2,
        s: sprime,
        l,
        a
      };
    }
    function HSLtoHSV(hsl2) {
      const {
        h: h2,
        s,
        l,
        a
      } = hsl2;
      const v = l + s * Math.min(l, 1 - l);
      const sprime = v === 0 ? 0 : 2 - 2 * l / v;
      return {
        h: h2,
        s: sprime,
        v,
        a
      };
    }
    function RGBtoCSS(_ref) {
      let {
        r,
        g,
        b,
        a
      } = _ref;
      return a === void 0 ? `rgb(${r}, ${g}, ${b})` : `rgba(${r}, ${g}, ${b}, ${a})`;
    }
    function HSVtoCSS(hsva) {
      return RGBtoCSS(HSVtoRGB(hsva));
    }
    function toHex(v) {
      const h2 = Math.round(v).toString(16);
      return ("00".substr(0, 2 - h2.length) + h2).toUpperCase();
    }
    function RGBtoHex(_ref2) {
      let {
        r,
        g,
        b,
        a
      } = _ref2;
      return `#${[toHex(r), toHex(g), toHex(b), a !== void 0 ? toHex(Math.round(a * 255)) : ""].join("")}`;
    }
    function HexToRGB(hex2) {
      hex2 = parseHex(hex2);
      let [r, g, b, a] = chunk(hex2, 2).map((c) => parseInt(c, 16));
      a = a === void 0 ? a : a / 255;
      return {
        r,
        g,
        b,
        a
      };
    }
    function HexToHSV(hex2) {
      const rgb2 = HexToRGB(hex2);
      return RGBtoHSV(rgb2);
    }
    function HSVtoHex(hsva) {
      return RGBtoHex(HSVtoRGB(hsva));
    }
    function parseHex(hex2) {
      if (hex2.startsWith("#")) {
        hex2 = hex2.slice(1);
      }
      hex2 = hex2.replace(/([^0-9a-f])/gi, "F");
      if (hex2.length === 3 || hex2.length === 4) {
        hex2 = hex2.split("").map((x) => x + x).join("");
      }
      if (hex2.length !== 6) {
        hex2 = padEnd(padEnd(hex2, 6), 8, "F");
      }
      return hex2;
    }
    function lighten(value, amount) {
      const lab = fromXYZ$1(toXYZ(value));
      lab[0] = lab[0] + amount * 10;
      return fromXYZ(toXYZ$1(lab));
    }
    function darken(value, amount) {
      const lab = fromXYZ$1(toXYZ(value));
      lab[0] = lab[0] - amount * 10;
      return fromXYZ(toXYZ$1(lab));
    }
    function getLuma(color) {
      const rgb2 = parseColor(color);
      return toXYZ(rgb2)[1];
    }
    function getContrast(first, second) {
      const l1 = getLuma(first);
      const l2 = getLuma(second);
      const light = Math.max(l1, l2);
      const dark = Math.min(l1, l2);
      return (light + 0.05) / (dark + 0.05);
    }
    function getForeground(color) {
      const blackContrast = Math.abs(APCAcontrast(parseColor(0), parseColor(color)));
      const whiteContrast = Math.abs(APCAcontrast(parseColor(16777215), parseColor(color)));
      return whiteContrast > Math.min(blackContrast, 50) ? "#fff" : "#000";
    }
    const DefaultsSymbol = Symbol.for("vuetify:defaults");
    function createDefaults(options) {
      return ref$1(options);
    }
    function injectDefaults() {
      const defaults2 = inject$1(DefaultsSymbol);
      if (!defaults2)
        throw new Error("[Vuetify] Could not find defaults instance");
      return defaults2;
    }
    function provideDefaults(defaults2, options) {
      const injectedDefaults = injectDefaults();
      const providedDefaults = ref$1(defaults2);
      const newDefaults = computed(() => {
        const disabled = unref(options == null ? void 0 : options.disabled);
        if (disabled)
          return injectedDefaults.value;
        const scoped = unref(options == null ? void 0 : options.scoped);
        const reset = unref(options == null ? void 0 : options.reset);
        const root = unref(options == null ? void 0 : options.root);
        if (providedDefaults.value == null && !(scoped || reset || root))
          return injectedDefaults.value;
        let properties2 = mergeDeep(providedDefaults.value, {
          prev: injectedDefaults.value
        });
        if (scoped)
          return properties2;
        if (reset || root) {
          const len = Number(reset || Infinity);
          for (let i2 = 0; i2 <= len; i2++) {
            if (!properties2 || !("prev" in properties2)) {
              break;
            }
            properties2 = properties2.prev;
          }
          if (properties2 && typeof root === "string" && root in properties2) {
            properties2 = mergeDeep(mergeDeep(properties2, {
              prev: properties2
            }), properties2[root]);
          }
          return properties2;
        }
        return properties2.prev ? mergeDeep(properties2.prev, properties2) : properties2;
      });
      provide(DefaultsSymbol, newDefaults);
      return newDefaults;
    }
    function propIsDefined(vnode, prop2) {
      var _a2, _b;
      return typeof ((_a2 = vnode.props) == null ? void 0 : _a2[prop2]) !== "undefined" || typeof ((_b = vnode.props) == null ? void 0 : _b[toKebabCase(prop2)]) !== "undefined";
    }
    function internalUseDefaults() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let name = arguments.length > 1 ? arguments[1] : void 0;
      let defaults2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : injectDefaults();
      const vm = getCurrentInstance("useDefaults");
      name = name ?? vm.type.name ?? vm.type.__name;
      if (!name) {
        throw new Error("[Vuetify] Could not determine component name");
      }
      const componentDefaults = computed(() => {
        var _a2;
        return (_a2 = defaults2.value) == null ? void 0 : _a2[props._as ?? name];
      });
      const _props = new Proxy(props, {
        get(target2, prop2) {
          var _a2, _b, _c, _d;
          const propValue = Reflect.get(target2, prop2);
          if (prop2 === "class" || prop2 === "style") {
            return [(_a2 = componentDefaults.value) == null ? void 0 : _a2[prop2], propValue].filter((v) => v != null);
          } else if (typeof prop2 === "string" && !propIsDefined(vm.vnode, prop2)) {
            return ((_b = componentDefaults.value) == null ? void 0 : _b[prop2]) ?? ((_d = (_c = defaults2.value) == null ? void 0 : _c.global) == null ? void 0 : _d[prop2]) ?? propValue;
          }
          return propValue;
        }
      });
      const _subcomponentDefaults = shallowRef();
      watchEffect(() => {
        if (componentDefaults.value) {
          const subComponents = Object.entries(componentDefaults.value).filter((_ref) => {
            let [key] = _ref;
            return key.startsWith(key[0].toUpperCase());
          });
          _subcomponentDefaults.value = subComponents.length ? Object.fromEntries(subComponents) : void 0;
        } else {
          _subcomponentDefaults.value = void 0;
        }
      });
      function provideSubDefaults() {
        const injected = injectSelf(DefaultsSymbol, vm);
        provide(DefaultsSymbol, computed(() => {
          return _subcomponentDefaults.value ? mergeDeep((injected == null ? void 0 : injected.value) ?? {}, _subcomponentDefaults.value) : injected == null ? void 0 : injected.value;
        }));
      }
      return {
        props: _props,
        provideSubDefaults
      };
    }
    function defineComponent(options) {
      options._setup = options._setup ?? options.setup;
      if (!options.name) {
        return options;
      }
      if (options._setup) {
        options.props = propsFactory(options.props ?? {}, options.name)();
        const propKeys = Object.keys(options.props).filter((key) => key !== "class" && key !== "style");
        options.filterProps = function filterProps(props) {
          return pick(props, propKeys);
        };
        options.props._as = String;
        options.setup = function setup2(props, ctx) {
          const defaults2 = injectDefaults();
          if (!defaults2.value)
            return options._setup(props, ctx);
          const {
            props: _props,
            provideSubDefaults
          } = internalUseDefaults(props, props._as ?? options.name, defaults2);
          const setupBindings = options._setup(_props, ctx);
          provideSubDefaults();
          return setupBindings;
        };
      }
      return options;
    }
    function genericComponent() {
      let exposeDefaults = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      return (options) => (exposeDefaults ? defineComponent : defineComponent$1)(options);
    }
    function createSimpleFunctional(klass) {
      let tag = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "div";
      let name = arguments.length > 2 ? arguments[2] : void 0;
      return genericComponent()({
        name: name ?? capitalize(camelize(klass.replace(/__/g, "-"))),
        props: {
          tag: {
            type: String,
            default: tag
          },
          ...makeComponentProps()
        },
        setup(props, _ref) {
          let {
            slots
          } = _ref;
          return () => {
            var _a2;
            return h(props.tag, {
              class: [klass, props.class],
              style: props.style
            }, (_a2 = slots.default) == null ? void 0 : _a2.call(slots));
          };
        }
      });
    }
    function attachedRoot(node) {
      if (typeof node.getRootNode !== "function") {
        while (node.parentNode)
          node = node.parentNode;
        if (node !== document)
          return null;
        return document;
      }
      const root = node.getRootNode();
      if (root !== document && root.getRootNode({
        composed: true
      }) !== document)
        return null;
      return root;
    }
    const standardEasing = "cubic-bezier(0.4, 0, 0.2, 1)";
    const deceleratedEasing = "cubic-bezier(0.0, 0, 0.2, 1)";
    const acceleratedEasing = "cubic-bezier(0.4, 0, 1, 1)";
    function getCurrentInstance(name, message) {
      const vm = getCurrentInstance$1();
      if (!vm) {
        throw new Error(`[Vuetify] ${name} ${message || "must be called from inside a setup function"}`);
      }
      return vm;
    }
    function getCurrentInstanceName() {
      let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "composables";
      const vm = getCurrentInstance(name).type;
      return toKebabCase((vm == null ? void 0 : vm.aliasName) || (vm == null ? void 0 : vm.name));
    }
    let _uid = 0;
    let _map = /* @__PURE__ */ new WeakMap();
    function getUid() {
      const vm = getCurrentInstance("getUid");
      if (_map.has(vm))
        return _map.get(vm);
      else {
        const uid2 = _uid++;
        _map.set(vm, uid2);
        return uid2;
      }
    }
    getUid.reset = () => {
      _uid = 0;
      _map = /* @__PURE__ */ new WeakMap();
    };
    function getScrollParent(el2) {
      let includeHidden = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      while (el2) {
        if (includeHidden ? isPotentiallyScrollable(el2) : hasScrollbar(el2))
          return el2;
        el2 = el2.parentElement;
      }
      return document.scrollingElement;
    }
    function getScrollParents(el2, stopAt) {
      const elements = [];
      if (stopAt && el2 && !stopAt.contains(el2))
        return elements;
      while (el2) {
        if (hasScrollbar(el2))
          elements.push(el2);
        if (el2 === stopAt)
          break;
        el2 = el2.parentElement;
      }
      return elements;
    }
    function hasScrollbar(el2) {
      if (!el2 || el2.nodeType !== Node.ELEMENT_NODE)
        return false;
      const style = window.getComputedStyle(el2);
      return style.overflowY === "scroll" || style.overflowY === "auto" && el2.scrollHeight > el2.clientHeight;
    }
    function isPotentiallyScrollable(el2) {
      if (!el2 || el2.nodeType !== Node.ELEMENT_NODE)
        return false;
      const style = window.getComputedStyle(el2);
      return ["scroll", "auto"].includes(style.overflowY);
    }
    function injectSelf(key) {
      let vm = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstance("injectSelf");
      const {
        provides
      } = vm;
      if (provides && key in provides) {
        return provides[key];
      }
      return void 0;
    }
    function isFixedPosition(el2) {
      while (el2) {
        if (window.getComputedStyle(el2).position === "fixed") {
          return true;
        }
        el2 = el2.offsetParent;
      }
      return false;
    }
    function useRender(render) {
      const vm = getCurrentInstance("useRender");
      vm.render = render;
    }
    function useResizeObserver$1(callback) {
      let box = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "content";
      const resizeRef = ref$1();
      const contentRect = ref$1();
      if (IN_BROWSER) {
        const observer = new ResizeObserver((entries) => {
          callback == null ? void 0 : callback(entries, observer);
          if (!entries.length)
            return;
          if (box === "content") {
            contentRect.value = entries[0].contentRect;
          } else {
            contentRect.value = entries[0].target.getBoundingClientRect();
          }
        });
        onBeforeUnmount(() => {
          observer.disconnect();
        });
        watch(resizeRef, (newValue, oldValue) => {
          if (oldValue) {
            observer.unobserve(refElement(oldValue));
            contentRect.value = void 0;
          }
          if (newValue)
            observer.observe(refElement(newValue));
        }, {
          flush: "post"
        });
      }
      return {
        resizeRef,
        contentRect: readonly(contentRect)
      };
    }
    const VuetifyLayoutKey = Symbol.for("vuetify:layout");
    const VuetifyLayoutItemKey = Symbol.for("vuetify:layout-item");
    const ROOT_ZINDEX = 1e3;
    const makeLayoutProps = propsFactory({
      overlaps: {
        type: Array,
        default: () => []
      },
      fullHeight: Boolean
    }, "layout");
    const makeLayoutItemProps = propsFactory({
      name: {
        type: String
      },
      order: {
        type: [Number, String],
        default: 0
      },
      absolute: Boolean
    }, "layout-item");
    function useLayout() {
      const layout = inject$1(VuetifyLayoutKey);
      if (!layout)
        throw new Error("[Vuetify] Could not find injected layout");
      return {
        getLayoutItem: layout.getLayoutItem,
        mainRect: layout.mainRect,
        mainStyles: layout.mainStyles
      };
    }
    function useLayoutItem(options) {
      const layout = inject$1(VuetifyLayoutKey);
      if (!layout)
        throw new Error("[Vuetify] Could not find injected layout");
      const id2 = options.id ?? `layout-item-${getUid()}`;
      const vm = getCurrentInstance("useLayoutItem");
      provide(VuetifyLayoutItemKey, {
        id: id2
      });
      const isKeptAlive = shallowRef(false);
      onDeactivated(() => isKeptAlive.value = true);
      onActivated(() => isKeptAlive.value = false);
      const {
        layoutItemStyles,
        layoutItemScrimStyles
      } = layout.register(vm, {
        ...options,
        active: computed(() => isKeptAlive.value ? false : options.active.value),
        id: id2
      });
      onBeforeUnmount(() => layout.unregister(id2));
      return {
        layoutItemStyles,
        layoutRect: layout.layoutRect,
        layoutItemScrimStyles
      };
    }
    const generateLayers = (layout, positions, layoutSizes, activeItems) => {
      let previousLayer = {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      };
      const layers = [{
        id: "",
        layer: {
          ...previousLayer
        }
      }];
      for (const id2 of layout) {
        const position = positions.get(id2);
        const amount = layoutSizes.get(id2);
        const active = activeItems.get(id2);
        if (!position || !amount || !active)
          continue;
        const layer = {
          ...previousLayer,
          [position.value]: parseInt(previousLayer[position.value], 10) + (active.value ? parseInt(amount.value, 10) : 0)
        };
        layers.push({
          id: id2,
          layer
        });
        previousLayer = layer;
      }
      return layers;
    };
    function createLayout(props) {
      const parentLayout = inject$1(VuetifyLayoutKey, null);
      const rootZIndex = computed(() => parentLayout ? parentLayout.rootZIndex.value - 100 : ROOT_ZINDEX);
      const registered = ref$1([]);
      const positions = reactive(/* @__PURE__ */ new Map());
      const layoutSizes = reactive(/* @__PURE__ */ new Map());
      const priorities = reactive(/* @__PURE__ */ new Map());
      const activeItems = reactive(/* @__PURE__ */ new Map());
      const disabledTransitions = reactive(/* @__PURE__ */ new Map());
      const {
        resizeRef,
        contentRect: layoutRect
      } = useResizeObserver$1();
      const computedOverlaps = computed(() => {
        const map2 = /* @__PURE__ */ new Map();
        const overlaps = props.overlaps ?? [];
        for (const overlap of overlaps.filter((item) => item.includes(":"))) {
          const [top2, bottom2] = overlap.split(":");
          if (!registered.value.includes(top2) || !registered.value.includes(bottom2))
            continue;
          const topPosition = positions.get(top2);
          const bottomPosition = positions.get(bottom2);
          const topAmount = layoutSizes.get(top2);
          const bottomAmount = layoutSizes.get(bottom2);
          if (!topPosition || !bottomPosition || !topAmount || !bottomAmount)
            continue;
          map2.set(bottom2, {
            position: topPosition.value,
            amount: parseInt(topAmount.value, 10)
          });
          map2.set(top2, {
            position: bottomPosition.value,
            amount: -parseInt(bottomAmount.value, 10)
          });
        }
        return map2;
      });
      const layers = computed(() => {
        const uniquePriorities = [...new Set([...priorities.values()].map((p2) => p2.value))].sort((a, b) => a - b);
        const layout = [];
        for (const p2 of uniquePriorities) {
          const items3 = registered.value.filter((id2) => {
            var _a2;
            return ((_a2 = priorities.get(id2)) == null ? void 0 : _a2.value) === p2;
          });
          layout.push(...items3);
        }
        return generateLayers(layout, positions, layoutSizes, activeItems);
      });
      const transitionsEnabled = computed(() => {
        return !Array.from(disabledTransitions.values()).some((ref2) => ref2.value);
      });
      const mainRect = computed(() => {
        return layers.value[layers.value.length - 1].layer;
      });
      const mainStyles = computed(() => {
        return {
          "--v-layout-left": convertToUnit(mainRect.value.left),
          "--v-layout-right": convertToUnit(mainRect.value.right),
          "--v-layout-top": convertToUnit(mainRect.value.top),
          "--v-layout-bottom": convertToUnit(mainRect.value.bottom),
          ...transitionsEnabled.value ? void 0 : {
            transition: "none"
          }
        };
      });
      const items2 = computed(() => {
        return layers.value.slice(1).map((_ref, index) => {
          let {
            id: id2
          } = _ref;
          const {
            layer
          } = layers.value[index];
          const size2 = layoutSizes.get(id2);
          const position = positions.get(id2);
          return {
            id: id2,
            ...layer,
            size: Number(size2.value),
            position: position.value
          };
        });
      });
      const getLayoutItem = (id2) => {
        return items2.value.find((item) => item.id === id2);
      };
      const rootVm = getCurrentInstance("createLayout");
      const isMounted = shallowRef(false);
      onMounted(() => {
        isMounted.value = true;
      });
      provide(VuetifyLayoutKey, {
        register: (vm, _ref2) => {
          let {
            id: id2,
            order: order2,
            position,
            layoutSize,
            elementSize,
            active,
            disableTransitions,
            absolute
          } = _ref2;
          priorities.set(id2, order2);
          positions.set(id2, position);
          layoutSizes.set(id2, layoutSize);
          activeItems.set(id2, active);
          disableTransitions && disabledTransitions.set(id2, disableTransitions);
          const instances = findChildrenWithProvide(VuetifyLayoutItemKey, rootVm == null ? void 0 : rootVm.vnode);
          const instanceIndex = instances.indexOf(vm);
          if (instanceIndex > -1)
            registered.value.splice(instanceIndex, 0, id2);
          else
            registered.value.push(id2);
          const index = computed(() => items2.value.findIndex((i2) => i2.id === id2));
          const zIndex = computed(() => rootZIndex.value + layers.value.length * 2 - index.value * 2);
          const layoutItemStyles = computed(() => {
            const isHorizontal = position.value === "left" || position.value === "right";
            const isOppositeHorizontal = position.value === "right";
            const isOppositeVertical = position.value === "bottom";
            const styles = {
              [position.value]: 0,
              zIndex: zIndex.value,
              transform: `translate${isHorizontal ? "X" : "Y"}(${(active.value ? 0 : -110) * (isOppositeHorizontal || isOppositeVertical ? -1 : 1)}%)`,
              position: absolute.value || rootZIndex.value !== ROOT_ZINDEX ? "absolute" : "fixed",
              ...transitionsEnabled.value ? void 0 : {
                transition: "none"
              }
            };
            if (!isMounted.value)
              return styles;
            const item = items2.value[index.value];
            if (!item)
              throw new Error(`[Vuetify] Could not find layout item "${id2}"`);
            const overlap = computedOverlaps.value.get(id2);
            if (overlap) {
              item[overlap.position] += overlap.amount;
            }
            return {
              ...styles,
              height: isHorizontal ? `calc(100% - ${item.top}px - ${item.bottom}px)` : elementSize.value ? `${elementSize.value}px` : void 0,
              left: isOppositeHorizontal ? void 0 : `${item.left}px`,
              right: isOppositeHorizontal ? `${item.right}px` : void 0,
              top: position.value !== "bottom" ? `${item.top}px` : void 0,
              bottom: position.value !== "top" ? `${item.bottom}px` : void 0,
              width: !isHorizontal ? `calc(100% - ${item.left}px - ${item.right}px)` : elementSize.value ? `${elementSize.value}px` : void 0
            };
          });
          const layoutItemScrimStyles = computed(() => ({
            zIndex: zIndex.value - 1
          }));
          return {
            layoutItemStyles,
            layoutItemScrimStyles,
            zIndex
          };
        },
        unregister: (id2) => {
          priorities.delete(id2);
          positions.delete(id2);
          layoutSizes.delete(id2);
          activeItems.delete(id2);
          disabledTransitions.delete(id2);
          registered.value = registered.value.filter((v) => v !== id2);
        },
        mainRect,
        mainStyles,
        getLayoutItem,
        items: items2,
        layoutRect,
        rootZIndex
      });
      const layoutClasses = computed(() => ["v-layout", {
        "v-layout--full-height": props.fullHeight
      }]);
      const layoutStyles = computed(() => ({
        zIndex: parentLayout ? rootZIndex.value : void 0,
        position: parentLayout ? "relative" : void 0,
        overflow: parentLayout ? "hidden" : void 0
      }));
      return {
        layoutClasses,
        layoutStyles,
        getLayoutItem,
        items: items2,
        layoutRect,
        layoutRef: resizeRef
      };
    }
    function useToggleScope(source, fn) {
      let scope2;
      function start() {
        scope2 = effectScope();
        scope2.run(() => fn.length ? fn(() => {
          scope2 == null ? void 0 : scope2.stop();
          start();
        }) : fn());
      }
      watch(source, (active) => {
        if (active && !scope2) {
          start();
        } else if (!active) {
          scope2 == null ? void 0 : scope2.stop();
          scope2 = void 0;
        }
      }, {
        immediate: true
      });
      onScopeDispose(() => {
        scope2 == null ? void 0 : scope2.stop();
      });
    }
    function useProxiedModel(props, prop2, defaultValue) {
      let transformIn = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : (v) => v;
      let transformOut = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : (v) => v;
      const vm = getCurrentInstance("useProxiedModel");
      const internal = ref$1(props[prop2] !== void 0 ? props[prop2] : defaultValue);
      const kebabProp = toKebabCase(prop2);
      const checkKebab = kebabProp !== prop2;
      const isControlled = checkKebab ? computed(() => {
        var _a2, _b, _c, _d;
        void props[prop2];
        return !!((((_a2 = vm.vnode.props) == null ? void 0 : _a2.hasOwnProperty(prop2)) || ((_b = vm.vnode.props) == null ? void 0 : _b.hasOwnProperty(kebabProp))) && (((_c = vm.vnode.props) == null ? void 0 : _c.hasOwnProperty(`onUpdate:${prop2}`)) || ((_d = vm.vnode.props) == null ? void 0 : _d.hasOwnProperty(`onUpdate:${kebabProp}`))));
      }) : computed(() => {
        var _a2, _b;
        void props[prop2];
        return !!(((_a2 = vm.vnode.props) == null ? void 0 : _a2.hasOwnProperty(prop2)) && ((_b = vm.vnode.props) == null ? void 0 : _b.hasOwnProperty(`onUpdate:${prop2}`)));
      });
      useToggleScope(() => !isControlled.value, () => {
        watch(() => props[prop2], (val) => {
          internal.value = val;
        });
      });
      const model = computed({
        get() {
          const externalValue = props[prop2];
          return transformIn(isControlled.value ? externalValue : internal.value);
        },
        set(internalValue) {
          const newValue = transformOut(internalValue);
          const value = toRaw(isControlled.value ? props[prop2] : internal.value);
          if (value === newValue || transformIn(value) === internalValue) {
            return;
          }
          internal.value = newValue;
          vm == null ? void 0 : vm.emit(`update:${prop2}`, newValue);
        }
      });
      Object.defineProperty(model, "externalValue", {
        get: () => isControlled.value ? props[prop2] : internal.value
      });
      return model;
    }
    const en$2 = {
      badge: "Badge",
      open: "Open",
      close: "Close",
      confirmEdit: {
        ok: "OK",
        cancel: "Cancel"
      },
      dataIterator: {
        noResultsText: "No matching records found",
        loadingText: "Loading items..."
      },
      dataTable: {
        itemsPerPageText: "Rows per page:",
        ariaLabel: {
          sortDescending: "Sorted descending.",
          sortAscending: "Sorted ascending.",
          sortNone: "Not sorted.",
          activateNone: "Activate to remove sorting.",
          activateDescending: "Activate to sort descending.",
          activateAscending: "Activate to sort ascending."
        },
        sortBy: "Sort by"
      },
      dataFooter: {
        itemsPerPageText: "Items per page:",
        itemsPerPageAll: "All",
        nextPage: "Next page",
        prevPage: "Previous page",
        firstPage: "First page",
        lastPage: "Last page",
        pageText: "{0}-{1} of {2}"
      },
      dateRangeInput: {
        divider: "to"
      },
      datePicker: {
        itemsSelected: "{0} selected",
        range: {
          title: "Select dates",
          header: "Enter dates"
        },
        title: "Select date",
        header: "Enter date",
        input: {
          placeholder: "Enter date"
        }
      },
      noDataText: "No data available",
      carousel: {
        prev: "Previous visual",
        next: "Next visual",
        ariaLabel: {
          delimiter: "Carousel slide {0} of {1}"
        }
      },
      calendar: {
        moreEvents: "{0} more",
        today: "Today"
      },
      input: {
        clear: "Clear {0}",
        prependAction: "{0} prepended action",
        appendAction: "{0} appended action",
        otp: "Please enter OTP character {0}"
      },
      fileInput: {
        counter: "{0} files",
        counterSize: "{0} files ({1} in total)"
      },
      timePicker: {
        am: "AM",
        pm: "PM"
      },
      pagination: {
        ariaLabel: {
          root: "Pagination Navigation",
          next: "Next page",
          previous: "Previous page",
          page: "Go to page {0}",
          currentPage: "Page {0}, Current page",
          first: "First page",
          last: "Last page"
        }
      },
      stepper: {
        next: "Next",
        prev: "Previous"
      },
      rating: {
        ariaLabel: {
          item: "Rating {0} of {1}"
        }
      },
      loading: "Loading...",
      infiniteScroll: {
        loadMore: "Load more",
        empty: "No more"
      }
    };
    const LANG_PREFIX = "$vuetify.";
    const replace = (str, params) => {
      return str.replace(/\{(\d+)\}/g, (match, index) => {
        return String(params[+index]);
      });
    };
    const createTranslateFunction = (current2, fallback, messages) => {
      return function(key) {
        for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          params[_key - 1] = arguments[_key];
        }
        if (!key.startsWith(LANG_PREFIX)) {
          return replace(key, params);
        }
        const shortKey = key.replace(LANG_PREFIX, "");
        const currentLocale = current2.value && messages.value[current2.value];
        const fallbackLocale = fallback.value && messages.value[fallback.value];
        let str = getObjectValueByPath(currentLocale, shortKey, null);
        if (!str) {
          consoleWarn(`Translation key "${key}" not found in "${current2.value}", trying fallback locale`);
          str = getObjectValueByPath(fallbackLocale, shortKey, null);
        }
        if (!str) {
          str = key;
        }
        if (typeof str !== "string") {
          str = key;
        }
        return replace(str, params);
      };
    };
    function createNumberFunction(current2, fallback) {
      return (value, options) => {
        const numberFormat = new Intl.NumberFormat([current2.value, fallback.value], options);
        return numberFormat.format(value);
      };
    }
    function useProvided(props, prop2, provided) {
      const internal = useProxiedModel(props, prop2, props[prop2] ?? provided.value);
      internal.value = props[prop2] ?? provided.value;
      watch(provided, (v) => {
        if (props[prop2] == null) {
          internal.value = provided.value;
        }
      });
      return internal;
    }
    function createProvideFunction(state) {
      return (props) => {
        const current2 = useProvided(props, "locale", state.current);
        const fallback = useProvided(props, "fallback", state.fallback);
        const messages = useProvided(props, "messages", state.messages);
        return {
          name: "vuetify",
          current: current2,
          fallback,
          messages,
          t: createTranslateFunction(current2, fallback, messages),
          n: createNumberFunction(current2, fallback),
          provide: createProvideFunction({
            current: current2,
            fallback,
            messages
          })
        };
      };
    }
    function createVuetifyAdapter(options) {
      const current2 = shallowRef((options == null ? void 0 : options.locale) ?? "en");
      const fallback = shallowRef((options == null ? void 0 : options.fallback) ?? "en");
      const messages = ref$1({
        en: en$2,
        ...options == null ? void 0 : options.messages
      });
      return {
        name: "vuetify",
        current: current2,
        fallback,
        messages,
        t: createTranslateFunction(current2, fallback, messages),
        n: createNumberFunction(current2, fallback),
        provide: createProvideFunction({
          current: current2,
          fallback,
          messages
        })
      };
    }
    const LocaleSymbol = Symbol.for("vuetify:locale");
    function isLocaleInstance(obj) {
      return obj.name != null;
    }
    function createLocale(options) {
      const i18n2 = (options == null ? void 0 : options.adapter) && isLocaleInstance(options == null ? void 0 : options.adapter) ? options == null ? void 0 : options.adapter : createVuetifyAdapter(options);
      const rtl = createRtl(i18n2, options);
      return {
        ...i18n2,
        ...rtl
      };
    }
    function useLocale() {
      const locale = inject$1(LocaleSymbol);
      if (!locale)
        throw new Error("[Vuetify] Could not find injected locale instance");
      return locale;
    }
    function genDefaults$3() {
      return {
        af: false,
        ar: true,
        bg: false,
        ca: false,
        ckb: false,
        cs: false,
        de: false,
        el: false,
        en: false,
        es: false,
        et: false,
        fa: true,
        fi: false,
        fr: false,
        hr: false,
        hu: false,
        he: true,
        id: false,
        it: false,
        ja: false,
        km: false,
        ko: false,
        lv: false,
        lt: false,
        nl: false,
        no: false,
        pl: false,
        pt: false,
        ro: false,
        ru: false,
        sk: false,
        sl: false,
        srCyrl: false,
        srLatn: false,
        sv: false,
        th: false,
        tr: false,
        az: false,
        uk: false,
        vi: false,
        zhHans: false,
        zhHant: false
      };
    }
    function createRtl(i18n2, options) {
      const rtl = ref$1((options == null ? void 0 : options.rtl) ?? genDefaults$3());
      const isRtl = computed(() => rtl.value[i18n2.current.value] ?? false);
      return {
        isRtl,
        rtl,
        rtlClasses: computed(() => `v-locale--is-${isRtl.value ? "rtl" : "ltr"}`)
      };
    }
    function useRtl() {
      const locale = inject$1(LocaleSymbol);
      if (!locale)
        throw new Error("[Vuetify] Could not find injected rtl instance");
      return {
        isRtl: locale.isRtl,
        rtlClasses: locale.rtlClasses
      };
    }
    const ThemeSymbol = Symbol.for("vuetify:theme");
    const makeThemeProps = propsFactory({
      theme: String
    }, "theme");
    function genDefaults$2() {
      return {
        defaultTheme: "light",
        variations: {
          colors: [],
          lighten: 0,
          darken: 0
        },
        themes: {
          light: {
            dark: false,
            colors: {
              background: "#FFFFFF",
              surface: "#FFFFFF",
              "surface-bright": "#FFFFFF",
              "surface-light": "#EEEEEE",
              "surface-variant": "#424242",
              "on-surface-variant": "#EEEEEE",
              primary: "#1867C0",
              "primary-darken-1": "#1F5592",
              secondary: "#48A9A6",
              "secondary-darken-1": "#018786",
              error: "#B00020",
              info: "#2196F3",
              success: "#4CAF50",
              warning: "#FB8C00"
            },
            variables: {
              "border-color": "#000000",
              "border-opacity": 0.12,
              "high-emphasis-opacity": 0.87,
              "medium-emphasis-opacity": 0.6,
              "disabled-opacity": 0.38,
              "idle-opacity": 0.04,
              "hover-opacity": 0.04,
              "focus-opacity": 0.12,
              "selected-opacity": 0.08,
              "activated-opacity": 0.12,
              "pressed-opacity": 0.12,
              "dragged-opacity": 0.08,
              "theme-kbd": "#212529",
              "theme-on-kbd": "#FFFFFF",
              "theme-code": "#F5F5F5",
              "theme-on-code": "#000000"
            }
          },
          dark: {
            dark: true,
            colors: {
              background: "#121212",
              surface: "#212121",
              "surface-bright": "#ccbfd6",
              "surface-light": "#424242",
              "surface-variant": "#a3a3a3",
              "on-surface-variant": "#424242",
              primary: "#2196F3",
              "primary-darken-1": "#277CC1",
              secondary: "#54B6B2",
              "secondary-darken-1": "#48A9A6",
              error: "#CF6679",
              info: "#2196F3",
              success: "#4CAF50",
              warning: "#FB8C00"
            },
            variables: {
              "border-color": "#FFFFFF",
              "border-opacity": 0.12,
              "high-emphasis-opacity": 1,
              "medium-emphasis-opacity": 0.7,
              "disabled-opacity": 0.5,
              "idle-opacity": 0.1,
              "hover-opacity": 0.04,
              "focus-opacity": 0.12,
              "selected-opacity": 0.08,
              "activated-opacity": 0.12,
              "pressed-opacity": 0.16,
              "dragged-opacity": 0.08,
              "theme-kbd": "#212529",
              "theme-on-kbd": "#FFFFFF",
              "theme-code": "#343434",
              "theme-on-code": "#CCCCCC"
            }
          }
        }
      };
    }
    function parseThemeOptions() {
      var _a2, _b;
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : genDefaults$2();
      const defaults2 = genDefaults$2();
      if (!options)
        return {
          ...defaults2,
          isDisabled: true
        };
      const themes = {};
      for (const [key, theme] of Object.entries(options.themes ?? {})) {
        const defaultTheme = theme.dark || key === "dark" ? (_a2 = defaults2.themes) == null ? void 0 : _a2.dark : (_b = defaults2.themes) == null ? void 0 : _b.light;
        themes[key] = mergeDeep(defaultTheme, theme);
      }
      return mergeDeep(defaults2, {
        ...options,
        themes
      });
    }
    function createTheme(options) {
      const parsedOptions = parseThemeOptions(options);
      const name = ref$1(parsedOptions.defaultTheme);
      const themes = ref$1(parsedOptions.themes);
      const computedThemes = computed(() => {
        const acc = {};
        for (const [name2, original] of Object.entries(themes.value)) {
          const theme = acc[name2] = {
            ...original,
            colors: {
              ...original.colors
            }
          };
          if (parsedOptions.variations) {
            for (const name3 of parsedOptions.variations.colors) {
              const color = theme.colors[name3];
              if (!color)
                continue;
              for (const variation of ["lighten", "darken"]) {
                const fn = variation === "lighten" ? lighten : darken;
                for (const amount of createRange(parsedOptions.variations[variation], 1)) {
                  theme.colors[`${name3}-${variation}-${amount}`] = RGBtoHex(fn(parseColor(color), amount));
                }
              }
            }
          }
          for (const color of Object.keys(theme.colors)) {
            if (/^on-[a-z]/.test(color) || theme.colors[`on-${color}`])
              continue;
            const onColor = `on-${color}`;
            const colorVal = parseColor(theme.colors[color]);
            theme.colors[onColor] = getForeground(colorVal);
          }
        }
        return acc;
      });
      const current2 = computed(() => computedThemes.value[name.value]);
      const styles = computed(() => {
        const lines = [];
        if (current2.value.dark) {
          createCssClass(lines, ":root", ["color-scheme: dark"]);
        }
        createCssClass(lines, ":root", genCssVariables(current2.value));
        for (const [themeName, theme] of Object.entries(computedThemes.value)) {
          createCssClass(lines, `.v-theme--${themeName}`, [`color-scheme: ${theme.dark ? "dark" : "normal"}`, ...genCssVariables(theme)]);
        }
        const bgLines = [];
        const fgLines = [];
        const colors2 = new Set(Object.values(computedThemes.value).flatMap((theme) => Object.keys(theme.colors)));
        for (const key of colors2) {
          if (/^on-[a-z]/.test(key)) {
            createCssClass(fgLines, `.${key}`, [`color: rgb(var(--v-theme-${key})) !important`]);
          } else {
            createCssClass(bgLines, `.bg-${key}`, [`--v-theme-overlay-multiplier: var(--v-theme-${key}-overlay-multiplier)`, `background-color: rgb(var(--v-theme-${key})) !important`, `color: rgb(var(--v-theme-on-${key})) !important`]);
            createCssClass(fgLines, `.text-${key}`, [`color: rgb(var(--v-theme-${key})) !important`]);
            createCssClass(fgLines, `.border-${key}`, [`--v-border-color: var(--v-theme-${key})`]);
          }
        }
        lines.push(...bgLines, ...fgLines);
        return lines.map((str, i2) => i2 === 0 ? str : `    ${str}`).join("");
      });
      function getHead() {
        return {
          style: [{
            children: styles.value,
            id: "vuetify-theme-stylesheet",
            nonce: parsedOptions.cspNonce || false
          }]
        };
      }
      function install(app2) {
        if (parsedOptions.isDisabled)
          return;
        const head = app2._context.provides.usehead;
        if (head) {
          if (head.push) {
            const entry = head.push(getHead);
            if (IN_BROWSER) {
              watch(styles, () => {
                entry.patch(getHead);
              });
            }
          } else {
            if (IN_BROWSER) {
              head.addHeadObjs(computed(getHead));
              watchEffect(() => head.updateDOM());
            } else {
              head.addHeadObjs(getHead());
            }
          }
        } else {
          let updateStyles2 = function() {
            if (typeof document !== "undefined" && !styleEl) {
              const el2 = document.createElement("style");
              el2.type = "text/css";
              el2.id = "vuetify-theme-stylesheet";
              if (parsedOptions.cspNonce)
                el2.setAttribute("nonce", parsedOptions.cspNonce);
              styleEl = el2;
              document.head.appendChild(styleEl);
            }
            if (styleEl)
              styleEl.innerHTML = styles.value;
          };
          var updateStyles = updateStyles2;
          let styleEl = IN_BROWSER ? document.getElementById("vuetify-theme-stylesheet") : null;
          if (IN_BROWSER) {
            watch(styles, updateStyles2, {
              immediate: true
            });
          } else {
            updateStyles2();
          }
        }
      }
      const themeClasses = computed(() => parsedOptions.isDisabled ? void 0 : `v-theme--${name.value}`);
      return {
        install,
        isDisabled: parsedOptions.isDisabled,
        name,
        themes,
        current: current2,
        computedThemes,
        themeClasses,
        styles,
        global: {
          name,
          current: current2
        }
      };
    }
    function provideTheme(props) {
      getCurrentInstance("provideTheme");
      const theme = inject$1(ThemeSymbol, null);
      if (!theme)
        throw new Error("Could not find Vuetify theme injection");
      const name = computed(() => {
        return props.theme ?? theme.name.value;
      });
      const current2 = computed(() => theme.themes.value[name.value]);
      const themeClasses = computed(() => theme.isDisabled ? void 0 : `v-theme--${name.value}`);
      const newTheme = {
        ...theme,
        name,
        current: current2,
        themeClasses
      };
      provide(ThemeSymbol, newTheme);
      return newTheme;
    }
    function useTheme() {
      getCurrentInstance("useTheme");
      const theme = inject$1(ThemeSymbol, null);
      if (!theme)
        throw new Error("Could not find Vuetify theme injection");
      return theme;
    }
    function createCssClass(lines, selector, content2) {
      lines.push(`${selector} {
`, ...content2.map((line) => `  ${line};
`), "}\n");
    }
    function genCssVariables(theme) {
      const lightOverlay = theme.dark ? 2 : 1;
      const darkOverlay = theme.dark ? 1 : 2;
      const variables = [];
      for (const [key, value] of Object.entries(theme.colors)) {
        const rgb2 = parseColor(value);
        variables.push(`--v-theme-${key}: ${rgb2.r},${rgb2.g},${rgb2.b}`);
        if (!key.startsWith("on-")) {
          variables.push(`--v-theme-${key}-overlay-multiplier: ${getLuma(value) > 0.18 ? lightOverlay : darkOverlay}`);
        }
      }
      for (const [key, value] of Object.entries(theme.variables)) {
        const color = typeof value === "string" && value.startsWith("#") ? parseColor(value) : void 0;
        const rgb2 = color ? `${color.r}, ${color.g}, ${color.b}` : void 0;
        variables.push(`--v-${key}: ${rgb2 ?? value}`);
      }
      return variables;
    }
    const makeVAppProps = propsFactory({
      ...makeComponentProps(),
      ...makeLayoutProps({
        fullHeight: true
      }),
      ...makeThemeProps()
    }, "VApp");
    const VApp = genericComponent()({
      name: "VApp",
      props: makeVAppProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const theme = provideTheme(props);
        const {
          layoutClasses,
          getLayoutItem,
          items: items2,
          layoutRef
        } = createLayout(props);
        const {
          rtlClasses
        } = useRtl();
        useRender(() => {
          var _a2;
          return createVNode("div", {
            "ref": layoutRef,
            "class": ["v-application", theme.themeClasses.value, layoutClasses.value, rtlClasses.value, props.class],
            "style": [props.style]
          }, [createVNode("div", {
            "class": "v-application__wrap"
          }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)])]);
        });
        return {
          getLayoutItem,
          items: items2,
          theme
        };
      }
    });
    const makeTagProps = propsFactory({
      tag: {
        type: String,
        default: "div"
      }
    }, "tag");
    const makeVToolbarTitleProps = propsFactory({
      text: String,
      ...makeComponentProps(),
      ...makeTagProps()
    }, "VToolbarTitle");
    const VToolbarTitle = genericComponent()({
      name: "VToolbarTitle",
      props: makeVToolbarTitleProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        useRender(() => {
          const hasText = !!(slots.default || slots.text || props.text);
          return createVNode(props.tag, {
            "class": ["v-toolbar-title", props.class],
            "style": props.style
          }, {
            default: () => {
              var _a2;
              return [hasText && createVNode("div", {
                "class": "v-toolbar-title__placeholder"
              }, [slots.text ? slots.text() : props.text, (_a2 = slots.default) == null ? void 0 : _a2.call(slots)])];
            }
          });
        });
        return {};
      }
    });
    const makeTransitionProps$1 = propsFactory({
      disabled: Boolean,
      group: Boolean,
      hideOnLeave: Boolean,
      leaveAbsolute: Boolean,
      mode: String,
      origin: String
    }, "transition");
    function createCssTransition(name, origin, mode) {
      return genericComponent()({
        name,
        props: makeTransitionProps$1({
          mode,
          origin
        }),
        setup(props, _ref) {
          let {
            slots
          } = _ref;
          const functions = {
            onBeforeEnter(el2) {
              if (props.origin) {
                el2.style.transformOrigin = props.origin;
              }
            },
            onLeave(el2) {
              if (props.leaveAbsolute) {
                const {
                  offsetTop,
                  offsetLeft,
                  offsetWidth,
                  offsetHeight
                } = el2;
                el2._transitionInitialStyles = {
                  position: el2.style.position,
                  top: el2.style.top,
                  left: el2.style.left,
                  width: el2.style.width,
                  height: el2.style.height
                };
                el2.style.position = "absolute";
                el2.style.top = `${offsetTop}px`;
                el2.style.left = `${offsetLeft}px`;
                el2.style.width = `${offsetWidth}px`;
                el2.style.height = `${offsetHeight}px`;
              }
              if (props.hideOnLeave) {
                el2.style.setProperty("display", "none", "important");
              }
            },
            onAfterLeave(el2) {
              if (props.leaveAbsolute && (el2 == null ? void 0 : el2._transitionInitialStyles)) {
                const {
                  position,
                  top: top2,
                  left,
                  width,
                  height
                } = el2._transitionInitialStyles;
                delete el2._transitionInitialStyles;
                el2.style.position = position || "";
                el2.style.top = top2 || "";
                el2.style.left = left || "";
                el2.style.width = width || "";
                el2.style.height = height || "";
              }
            }
          };
          return () => {
            const tag = props.group ? TransitionGroup : Transition;
            return h(tag, {
              name: props.disabled ? "" : name,
              css: !props.disabled,
              ...props.group ? void 0 : {
                mode: props.mode
              },
              ...props.disabled ? {} : functions
            }, slots.default);
          };
        }
      });
    }
    function createJavascriptTransition(name, functions) {
      let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "in-out";
      return genericComponent()({
        name,
        props: {
          mode: {
            type: String,
            default: mode
          },
          disabled: Boolean
        },
        setup(props, _ref2) {
          let {
            slots
          } = _ref2;
          return () => {
            return h(Transition, {
              name: props.disabled ? "" : name,
              css: !props.disabled,
              // mode: props.mode, // TODO: vuejs/vue-next#3104
              ...props.disabled ? {} : functions
            }, slots.default);
          };
        }
      });
    }
    function ExpandTransitionGenerator() {
      let expandedParentClass = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      let x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      const sizeProperty = x ? "width" : "height";
      const offsetProperty = camelize(`offset-${sizeProperty}`);
      return {
        onBeforeEnter(el2) {
          el2._parent = el2.parentNode;
          el2._initialStyle = {
            transition: el2.style.transition,
            overflow: el2.style.overflow,
            [sizeProperty]: el2.style[sizeProperty]
          };
        },
        onEnter(el2) {
          const initialStyle = el2._initialStyle;
          el2.style.setProperty("transition", "none", "important");
          el2.style.overflow = "hidden";
          const offset = `${el2[offsetProperty]}px`;
          el2.style[sizeProperty] = "0";
          void el2.offsetHeight;
          el2.style.transition = initialStyle.transition;
          if (expandedParentClass && el2._parent) {
            el2._parent.classList.add(expandedParentClass);
          }
          requestAnimationFrame(() => {
            el2.style[sizeProperty] = offset;
          });
        },
        onAfterEnter: resetStyles,
        onEnterCancelled: resetStyles,
        onLeave(el2) {
          el2._initialStyle = {
            transition: "",
            overflow: el2.style.overflow,
            [sizeProperty]: el2.style[sizeProperty]
          };
          el2.style.overflow = "hidden";
          el2.style[sizeProperty] = `${el2[offsetProperty]}px`;
          void el2.offsetHeight;
          requestAnimationFrame(() => el2.style[sizeProperty] = "0");
        },
        onAfterLeave,
        onLeaveCancelled: onAfterLeave
      };
      function onAfterLeave(el2) {
        if (expandedParentClass && el2._parent) {
          el2._parent.classList.remove(expandedParentClass);
        }
        resetStyles(el2);
      }
      function resetStyles(el2) {
        const size2 = el2._initialStyle[sizeProperty];
        el2.style.overflow = el2._initialStyle.overflow;
        if (size2 != null)
          el2.style[sizeProperty] = size2;
        delete el2._initialStyle;
      }
    }
    const makeVDialogTransitionProps = propsFactory({
      target: [Object, Array]
    }, "v-dialog-transition");
    const VDialogTransition = genericComponent()({
      name: "VDialogTransition",
      props: makeVDialogTransitionProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const functions = {
          onBeforeEnter(el2) {
            el2.style.pointerEvents = "none";
            el2.style.visibility = "hidden";
          },
          async onEnter(el2, done) {
            var _a2;
            await new Promise((resolve2) => requestAnimationFrame(resolve2));
            await new Promise((resolve2) => requestAnimationFrame(resolve2));
            el2.style.visibility = "";
            const {
              x,
              y,
              sx,
              sy,
              speed
            } = getDimensions(props.target, el2);
            const animation = animate(el2, [{
              transform: `translate(${x}px, ${y}px) scale(${sx}, ${sy})`,
              opacity: 0
            }, {}], {
              duration: 225 * speed,
              easing: deceleratedEasing
            });
            (_a2 = getChildren$1(el2)) == null ? void 0 : _a2.forEach((el3) => {
              animate(el3, [{
                opacity: 0
              }, {
                opacity: 0,
                offset: 0.33
              }, {}], {
                duration: 225 * 2 * speed,
                easing: standardEasing
              });
            });
            animation.finished.then(() => done());
          },
          onAfterEnter(el2) {
            el2.style.removeProperty("pointer-events");
          },
          onBeforeLeave(el2) {
            el2.style.pointerEvents = "none";
          },
          async onLeave(el2, done) {
            var _a2;
            await new Promise((resolve2) => requestAnimationFrame(resolve2));
            const {
              x,
              y,
              sx,
              sy,
              speed
            } = getDimensions(props.target, el2);
            const animation = animate(el2, [{}, {
              transform: `translate(${x}px, ${y}px) scale(${sx}, ${sy})`,
              opacity: 0
            }], {
              duration: 125 * speed,
              easing: acceleratedEasing
            });
            animation.finished.then(() => done());
            (_a2 = getChildren$1(el2)) == null ? void 0 : _a2.forEach((el3) => {
              animate(el3, [{}, {
                opacity: 0,
                offset: 0.2
              }, {
                opacity: 0
              }], {
                duration: 125 * 2 * speed,
                easing: standardEasing
              });
            });
          },
          onAfterLeave(el2) {
            el2.style.removeProperty("pointer-events");
          }
        };
        return () => {
          return props.target ? createVNode(Transition, mergeProps({
            "name": "dialog-transition"
          }, functions, {
            "css": false
          }), slots) : createVNode(Transition, {
            "name": "dialog-transition"
          }, slots);
        };
      }
    });
    function getChildren$1(el2) {
      var _a2;
      const els2 = (_a2 = el2.querySelector(":scope > .v-card, :scope > .v-sheet, :scope > .v-list")) == null ? void 0 : _a2.children;
      return els2 && [...els2];
    }
    function getDimensions(target2, el2) {
      const targetBox = getTargetBox(target2);
      const elBox = nullifyTransforms(el2);
      const [originX, originY] = getComputedStyle(el2).transformOrigin.split(" ").map((v) => parseFloat(v));
      const [anchorSide, anchorOffset] = getComputedStyle(el2).getPropertyValue("--v-overlay-anchor-origin").split(" ");
      let offsetX = targetBox.left + targetBox.width / 2;
      if (anchorSide === "left" || anchorOffset === "left") {
        offsetX -= targetBox.width / 2;
      } else if (anchorSide === "right" || anchorOffset === "right") {
        offsetX += targetBox.width / 2;
      }
      let offsetY = targetBox.top + targetBox.height / 2;
      if (anchorSide === "top" || anchorOffset === "top") {
        offsetY -= targetBox.height / 2;
      } else if (anchorSide === "bottom" || anchorOffset === "bottom") {
        offsetY += targetBox.height / 2;
      }
      const tsx = targetBox.width / elBox.width;
      const tsy = targetBox.height / elBox.height;
      const maxs = Math.max(1, tsx, tsy);
      const sx = tsx / maxs || 0;
      const sy = tsy / maxs || 0;
      const asa = elBox.width * elBox.height / (window.innerWidth * window.innerHeight);
      const speed = asa > 0.12 ? Math.min(1.5, (asa - 0.12) * 10 + 1) : 1;
      return {
        x: offsetX - (originX + elBox.left),
        y: offsetY - (originY + elBox.top),
        sx,
        sy,
        speed
      };
    }
    createCssTransition("fab-transition", "center center", "out-in");
    createCssTransition("dialog-bottom-transition");
    createCssTransition("dialog-top-transition");
    const VFadeTransition = createCssTransition("fade-transition");
    const VScaleTransition = createCssTransition("scale-transition");
    createCssTransition("scroll-x-transition");
    createCssTransition("scroll-x-reverse-transition");
    createCssTransition("scroll-y-transition");
    createCssTransition("scroll-y-reverse-transition");
    createCssTransition("slide-x-transition");
    const VSlideXReverseTransition = createCssTransition("slide-x-reverse-transition");
    const VSlideYTransition = createCssTransition("slide-y-transition");
    createCssTransition("slide-y-reverse-transition");
    const VExpandTransition = createJavascriptTransition("expand-transition", ExpandTransitionGenerator());
    const VExpandXTransition = createJavascriptTransition("expand-x-transition", ExpandTransitionGenerator("", true));
    const makeVDefaultsProviderProps = propsFactory({
      defaults: Object,
      disabled: Boolean,
      reset: [Number, String],
      root: [Boolean, String],
      scoped: Boolean
    }, "VDefaultsProvider");
    const VDefaultsProvider = genericComponent(false)({
      name: "VDefaultsProvider",
      props: makeVDefaultsProviderProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          defaults: defaults2,
          disabled,
          reset,
          root,
          scoped
        } = toRefs(props);
        provideDefaults(defaults2, {
          reset,
          root,
          scoped,
          disabled
        });
        return () => {
          var _a2;
          return (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
        };
      }
    });
    const makeDimensionProps = propsFactory({
      height: [Number, String],
      maxHeight: [Number, String],
      maxWidth: [Number, String],
      minHeight: [Number, String],
      minWidth: [Number, String],
      width: [Number, String]
    }, "dimension");
    function useDimension(props) {
      const dimensionStyles = computed(() => ({
        height: convertToUnit(props.height),
        maxHeight: convertToUnit(props.maxHeight),
        maxWidth: convertToUnit(props.maxWidth),
        minHeight: convertToUnit(props.minHeight),
        minWidth: convertToUnit(props.minWidth),
        width: convertToUnit(props.width)
      }));
      return {
        dimensionStyles
      };
    }
    function useAspectStyles(props) {
      return {
        aspectStyles: computed(() => {
          const ratio2 = Number(props.aspectRatio);
          return ratio2 ? {
            paddingBottom: String(1 / ratio2 * 100) + "%"
          } : void 0;
        })
      };
    }
    const makeVResponsiveProps = propsFactory({
      aspectRatio: [String, Number],
      contentClass: String,
      inline: Boolean,
      ...makeComponentProps(),
      ...makeDimensionProps()
    }, "VResponsive");
    const VResponsive = genericComponent()({
      name: "VResponsive",
      props: makeVResponsiveProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          aspectStyles
        } = useAspectStyles(props);
        const {
          dimensionStyles
        } = useDimension(props);
        useRender(() => {
          var _a2;
          return createVNode("div", {
            "class": ["v-responsive", {
              "v-responsive--inline": props.inline
            }, props.class],
            "style": [dimensionStyles.value, props.style]
          }, [createVNode("div", {
            "class": "v-responsive__sizer",
            "style": aspectStyles.value
          }, null), (_a2 = slots.additional) == null ? void 0 : _a2.call(slots), slots.default && createVNode("div", {
            "class": ["v-responsive__content", props.contentClass]
          }, [slots.default()])]);
        });
        return {};
      }
    });
    function useColor(colors2) {
      return destructComputed(() => {
        const classes = [];
        const styles = {};
        if (colors2.value.background) {
          if (isCssColor(colors2.value.background)) {
            styles.backgroundColor = colors2.value.background;
            if (!colors2.value.text && isParsableColor(colors2.value.background)) {
              const backgroundColor = parseColor(colors2.value.background);
              if (backgroundColor.a == null || backgroundColor.a === 1) {
                const textColor = getForeground(backgroundColor);
                styles.color = textColor;
                styles.caretColor = textColor;
              }
            }
          } else {
            classes.push(`bg-${colors2.value.background}`);
          }
        }
        if (colors2.value.text) {
          if (isCssColor(colors2.value.text)) {
            styles.color = colors2.value.text;
            styles.caretColor = colors2.value.text;
          } else {
            classes.push(`text-${colors2.value.text}`);
          }
        }
        return {
          colorClasses: classes,
          colorStyles: styles
        };
      });
    }
    function useTextColor(props, name) {
      const colors2 = computed(() => ({
        text: isRef(props) ? props.value : name ? props[name] : null
      }));
      const {
        colorClasses: textColorClasses,
        colorStyles: textColorStyles
      } = useColor(colors2);
      return {
        textColorClasses,
        textColorStyles
      };
    }
    function useBackgroundColor(props, name) {
      const colors2 = computed(() => ({
        background: isRef(props) ? props.value : name ? props[name] : null
      }));
      const {
        colorClasses: backgroundColorClasses,
        colorStyles: backgroundColorStyles
      } = useColor(colors2);
      return {
        backgroundColorClasses,
        backgroundColorStyles
      };
    }
    const makeRoundedProps = propsFactory({
      rounded: {
        type: [Boolean, Number, String],
        default: void 0
      },
      tile: Boolean
    }, "rounded");
    function useRounded(props) {
      let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
      const roundedClasses = computed(() => {
        const rounded = isRef(props) ? props.value : props.rounded;
        const tile = isRef(props) ? props.value : props.tile;
        const classes = [];
        if (rounded === true || rounded === "") {
          classes.push(`${name}--rounded`);
        } else if (typeof rounded === "string" || rounded === 0) {
          for (const value of String(rounded).split(" ")) {
            classes.push(`rounded-${value}`);
          }
        } else if (tile) {
          classes.push("rounded-0");
        }
        return classes;
      });
      return {
        roundedClasses
      };
    }
    const makeTransitionProps = propsFactory({
      transition: {
        type: [Boolean, String, Object],
        default: "fade-transition",
        validator: (val) => val !== true
      }
    }, "transition");
    const MaybeTransition = (props, _ref) => {
      let {
        slots
      } = _ref;
      const {
        transition,
        disabled,
        ...rest
      } = props;
      const {
        component = Transition,
        ...customProps
      } = typeof transition === "object" ? transition : {};
      return h(component, mergeProps(typeof transition === "string" ? {
        name: disabled ? "" : transition
      } : customProps, rest, {
        disabled
      }), slots);
    };
    function mounted$2(el2, binding) {
      if (!SUPPORTS_INTERSECTION)
        return;
      const modifiers = binding.modifiers || {};
      const value = binding.value;
      const {
        handler,
        options
      } = typeof value === "object" ? value : {
        handler: value,
        options: {}
      };
      const observer = new IntersectionObserver(function() {
        var _a2;
        let entries = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        let observer2 = arguments.length > 1 ? arguments[1] : void 0;
        const _observe = (_a2 = el2._observe) == null ? void 0 : _a2[binding.instance.$.uid];
        if (!_observe)
          return;
        const isIntersecting = entries.some((entry) => entry.isIntersecting);
        if (handler && (!modifiers.quiet || _observe.init) && (!modifiers.once || isIntersecting || _observe.init)) {
          handler(isIntersecting, entries, observer2);
        }
        if (isIntersecting && modifiers.once)
          unmounted$2(el2, binding);
        else
          _observe.init = true;
      }, options);
      el2._observe = Object(el2._observe);
      el2._observe[binding.instance.$.uid] = {
        init: false,
        observer
      };
      observer.observe(el2);
    }
    function unmounted$2(el2, binding) {
      var _a2;
      const observe = (_a2 = el2._observe) == null ? void 0 : _a2[binding.instance.$.uid];
      if (!observe)
        return;
      observe.observer.unobserve(el2);
      delete el2._observe[binding.instance.$.uid];
    }
    const Intersect = {
      mounted: mounted$2,
      unmounted: unmounted$2
    };
    const Intersect$1 = Intersect;
    const makeVImgProps = propsFactory({
      alt: String,
      cover: Boolean,
      color: String,
      draggable: {
        type: [Boolean, String],
        default: void 0
      },
      eager: Boolean,
      gradient: String,
      lazySrc: String,
      options: {
        type: Object,
        // For more information on types, navigate to:
        // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
        default: () => ({
          root: void 0,
          rootMargin: void 0,
          threshold: void 0
        })
      },
      sizes: String,
      src: {
        type: [String, Object],
        default: ""
      },
      crossorigin: String,
      referrerpolicy: String,
      srcset: String,
      position: String,
      ...makeVResponsiveProps(),
      ...makeComponentProps(),
      ...makeRoundedProps(),
      ...makeTransitionProps()
    }, "VImg");
    const VImg = genericComponent()({
      name: "VImg",
      directives: {
        intersect: Intersect$1
      },
      props: makeVImgProps(),
      emits: {
        loadstart: (value) => true,
        load: (value) => true,
        error: (value) => true
      },
      setup(props, _ref) {
        let {
          emit: emit2,
          slots
        } = _ref;
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(toRef(props, "color"));
        const {
          roundedClasses
        } = useRounded(props);
        const vm = getCurrentInstance("VImg");
        const currentSrc = shallowRef("");
        const image2 = ref$1();
        const state = shallowRef(props.eager ? "loading" : "idle");
        const naturalWidth = shallowRef();
        const naturalHeight = shallowRef();
        const normalisedSrc = computed(() => {
          return props.src && typeof props.src === "object" ? {
            src: props.src.src,
            srcset: props.srcset || props.src.srcset,
            lazySrc: props.lazySrc || props.src.lazySrc,
            aspect: Number(props.aspectRatio || props.src.aspect || 0)
          } : {
            src: props.src,
            srcset: props.srcset,
            lazySrc: props.lazySrc,
            aspect: Number(props.aspectRatio || 0)
          };
        });
        const aspectRatio = computed(() => {
          return normalisedSrc.value.aspect || naturalWidth.value / naturalHeight.value || 0;
        });
        watch(() => props.src, () => {
          init(state.value !== "idle");
        });
        watch(aspectRatio, (val, oldVal) => {
          if (!val && oldVal && image2.value) {
            pollForSize(image2.value);
          }
        });
        onBeforeMount(() => init());
        function init(isIntersecting) {
          if (props.eager && isIntersecting)
            return;
          if (SUPPORTS_INTERSECTION && !isIntersecting && !props.eager)
            return;
          state.value = "loading";
          if (normalisedSrc.value.lazySrc) {
            const lazyImg = new Image();
            lazyImg.src = normalisedSrc.value.lazySrc;
            pollForSize(lazyImg, null);
          }
          if (!normalisedSrc.value.src)
            return;
          nextTick(() => {
            var _a2;
            emit2("loadstart", ((_a2 = image2.value) == null ? void 0 : _a2.currentSrc) || normalisedSrc.value.src);
            setTimeout(() => {
              var _a3;
              if (vm.isUnmounted)
                return;
              if ((_a3 = image2.value) == null ? void 0 : _a3.complete) {
                if (!image2.value.naturalWidth) {
                  onError();
                }
                if (state.value === "error")
                  return;
                if (!aspectRatio.value)
                  pollForSize(image2.value, null);
                if (state.value === "loading")
                  onLoad();
              } else {
                if (!aspectRatio.value)
                  pollForSize(image2.value);
                getSrc();
              }
            });
          });
        }
        function onLoad() {
          var _a2;
          if (vm.isUnmounted)
            return;
          getSrc();
          pollForSize(image2.value);
          state.value = "loaded";
          emit2("load", ((_a2 = image2.value) == null ? void 0 : _a2.currentSrc) || normalisedSrc.value.src);
        }
        function onError() {
          var _a2;
          if (vm.isUnmounted)
            return;
          state.value = "error";
          emit2("error", ((_a2 = image2.value) == null ? void 0 : _a2.currentSrc) || normalisedSrc.value.src);
        }
        function getSrc() {
          const img = image2.value;
          if (img)
            currentSrc.value = img.currentSrc || img.src;
        }
        let timer = -1;
        onBeforeUnmount(() => {
          clearTimeout(timer);
        });
        function pollForSize(img) {
          let timeout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
          const poll = () => {
            clearTimeout(timer);
            if (vm.isUnmounted)
              return;
            const {
              naturalHeight: imgHeight,
              naturalWidth: imgWidth
            } = img;
            if (imgHeight || imgWidth) {
              naturalWidth.value = imgWidth;
              naturalHeight.value = imgHeight;
            } else if (!img.complete && state.value === "loading" && timeout != null) {
              timer = window.setTimeout(poll, timeout);
            } else if (img.currentSrc.endsWith(".svg") || img.currentSrc.startsWith("data:image/svg+xml")) {
              naturalWidth.value = 1;
              naturalHeight.value = 1;
            }
          };
          poll();
        }
        const containClasses = computed(() => ({
          "v-img__img--cover": props.cover,
          "v-img__img--contain": !props.cover
        }));
        const __image = () => {
          var _a2;
          if (!normalisedSrc.value.src || state.value === "idle")
            return null;
          const img = createVNode("img", {
            "class": ["v-img__img", containClasses.value],
            "style": {
              objectPosition: props.position
            },
            "src": normalisedSrc.value.src,
            "srcset": normalisedSrc.value.srcset,
            "alt": props.alt,
            "crossorigin": props.crossorigin,
            "referrerpolicy": props.referrerpolicy,
            "draggable": props.draggable,
            "sizes": props.sizes,
            "ref": image2,
            "onLoad": onLoad,
            "onError": onError
          }, null);
          const sources = (_a2 = slots.sources) == null ? void 0 : _a2.call(slots);
          return createVNode(MaybeTransition, {
            "transition": props.transition,
            "appear": true
          }, {
            default: () => [withDirectives(sources ? createVNode("picture", {
              "class": "v-img__picture"
            }, [sources, img]) : img, [[vShow, state.value === "loaded"]])]
          });
        };
        const __preloadImage = () => createVNode(MaybeTransition, {
          "transition": props.transition
        }, {
          default: () => [normalisedSrc.value.lazySrc && state.value !== "loaded" && createVNode("img", {
            "class": ["v-img__img", "v-img__img--preload", containClasses.value],
            "style": {
              objectPosition: props.position
            },
            "src": normalisedSrc.value.lazySrc,
            "alt": props.alt,
            "crossorigin": props.crossorigin,
            "referrerpolicy": props.referrerpolicy,
            "draggable": props.draggable
          }, null)]
        });
        const __placeholder = () => {
          if (!slots.placeholder)
            return null;
          return createVNode(MaybeTransition, {
            "transition": props.transition,
            "appear": true
          }, {
            default: () => [(state.value === "loading" || state.value === "error" && !slots.error) && createVNode("div", {
              "class": "v-img__placeholder"
            }, [slots.placeholder()])]
          });
        };
        const __error = () => {
          if (!slots.error)
            return null;
          return createVNode(MaybeTransition, {
            "transition": props.transition,
            "appear": true
          }, {
            default: () => [state.value === "error" && createVNode("div", {
              "class": "v-img__error"
            }, [slots.error()])]
          });
        };
        const __gradient = () => {
          if (!props.gradient)
            return null;
          return createVNode("div", {
            "class": "v-img__gradient",
            "style": {
              backgroundImage: `linear-gradient(${props.gradient})`
            }
          }, null);
        };
        const isBooted = shallowRef(false);
        {
          const stop = watch(aspectRatio, (val) => {
            if (val) {
              requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                  isBooted.value = true;
                });
              });
              stop();
            }
          });
        }
        useRender(() => {
          const responsiveProps = VResponsive.filterProps(props);
          return withDirectives(createVNode(VResponsive, mergeProps({
            "class": ["v-img", {
              "v-img--booting": !isBooted.value
            }, backgroundColorClasses.value, roundedClasses.value, props.class],
            "style": [{
              width: convertToUnit(props.width === "auto" ? naturalWidth.value : props.width)
            }, backgroundColorStyles.value, props.style]
          }, responsiveProps, {
            "aspectRatio": aspectRatio.value,
            "aria-label": props.alt,
            "role": props.alt ? "img" : void 0
          }), {
            additional: () => createVNode(Fragment, null, [createVNode(__image, null, null), createVNode(__preloadImage, null, null), createVNode(__gradient, null, null), createVNode(__placeholder, null, null), createVNode(__error, null, null)]),
            default: slots.default
          }), [[resolveDirective("intersect"), {
            handler: init,
            options: props.options
          }, null, {
            once: true
          }]]);
        });
        return {
          currentSrc,
          image: image2,
          state,
          naturalWidth,
          naturalHeight
        };
      }
    });
    const makeBorderProps = propsFactory({
      border: [Boolean, Number, String]
    }, "border");
    function useBorder(props) {
      let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
      const borderClasses = computed(() => {
        const border = isRef(props) ? props.value : props.border;
        const classes = [];
        if (border === true || border === "") {
          classes.push(`${name}--border`);
        } else if (typeof border === "string" || border === 0) {
          for (const value of String(border).split(" ")) {
            classes.push(`border-${value}`);
          }
        }
        return classes;
      });
      return {
        borderClasses
      };
    }
    const makeElevationProps = propsFactory({
      elevation: {
        type: [Number, String],
        validator(v) {
          const value = parseInt(v);
          return !isNaN(value) && value >= 0 && // Material Design has a maximum elevation of 24
          // https://material.io/design/environment/elevation.html#default-elevations
          value <= 24;
        }
      }
    }, "elevation");
    function useElevation(props) {
      const elevationClasses = computed(() => {
        const elevation = isRef(props) ? props.value : props.elevation;
        const classes = [];
        if (elevation == null)
          return classes;
        classes.push(`elevation-${elevation}`);
        return classes;
      });
      return {
        elevationClasses
      };
    }
    const allowedDensities$1 = [null, "prominent", "default", "comfortable", "compact"];
    const makeVToolbarProps = propsFactory({
      absolute: Boolean,
      collapse: Boolean,
      color: String,
      density: {
        type: String,
        default: "default",
        validator: (v) => allowedDensities$1.includes(v)
      },
      extended: Boolean,
      extensionHeight: {
        type: [Number, String],
        default: 48
      },
      flat: Boolean,
      floating: Boolean,
      height: {
        type: [Number, String],
        default: 64
      },
      image: String,
      title: String,
      ...makeBorderProps(),
      ...makeComponentProps(),
      ...makeElevationProps(),
      ...makeRoundedProps(),
      ...makeTagProps({
        tag: "header"
      }),
      ...makeThemeProps()
    }, "VToolbar");
    const VToolbar = genericComponent()({
      name: "VToolbar",
      props: makeVToolbarProps(),
      setup(props, _ref) {
        var _a2;
        let {
          slots
        } = _ref;
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(toRef(props, "color"));
        const {
          borderClasses
        } = useBorder(props);
        const {
          elevationClasses
        } = useElevation(props);
        const {
          roundedClasses
        } = useRounded(props);
        const {
          themeClasses
        } = provideTheme(props);
        const {
          rtlClasses
        } = useRtl();
        const isExtended = shallowRef(!!(props.extended || ((_a2 = slots.extension) == null ? void 0 : _a2.call(slots))));
        const contentHeight = computed(() => parseInt(Number(props.height) + (props.density === "prominent" ? Number(props.height) : 0) - (props.density === "comfortable" ? 8 : 0) - (props.density === "compact" ? 16 : 0), 10));
        const extensionHeight = computed(() => isExtended.value ? parseInt(Number(props.extensionHeight) + (props.density === "prominent" ? Number(props.extensionHeight) : 0) - (props.density === "comfortable" ? 4 : 0) - (props.density === "compact" ? 8 : 0), 10) : 0);
        provideDefaults({
          VBtn: {
            variant: "text"
          }
        });
        useRender(() => {
          var _a3;
          const hasTitle = !!(props.title || slots.title);
          const hasImage = !!(slots.image || props.image);
          const extension = (_a3 = slots.extension) == null ? void 0 : _a3.call(slots);
          isExtended.value = !!(props.extended || extension);
          return createVNode(props.tag, {
            "class": ["v-toolbar", {
              "v-toolbar--absolute": props.absolute,
              "v-toolbar--collapse": props.collapse,
              "v-toolbar--flat": props.flat,
              "v-toolbar--floating": props.floating,
              [`v-toolbar--density-${props.density}`]: true
            }, backgroundColorClasses.value, borderClasses.value, elevationClasses.value, roundedClasses.value, themeClasses.value, rtlClasses.value, props.class],
            "style": [backgroundColorStyles.value, props.style]
          }, {
            default: () => [hasImage && createVNode("div", {
              "key": "image",
              "class": "v-toolbar__image"
            }, [!slots.image ? createVNode(VImg, {
              "key": "image-img",
              "cover": true,
              "src": props.image
            }, null) : createVNode(VDefaultsProvider, {
              "key": "image-defaults",
              "disabled": !props.image,
              "defaults": {
                VImg: {
                  cover: true,
                  src: props.image
                }
              }
            }, slots.image)]), createVNode(VDefaultsProvider, {
              "defaults": {
                VTabs: {
                  height: convertToUnit(contentHeight.value)
                }
              }
            }, {
              default: () => {
                var _a4, _b, _c;
                return [createVNode("div", {
                  "class": "v-toolbar__content",
                  "style": {
                    height: convertToUnit(contentHeight.value)
                  }
                }, [slots.prepend && createVNode("div", {
                  "class": "v-toolbar__prepend"
                }, [(_a4 = slots.prepend) == null ? void 0 : _a4.call(slots)]), hasTitle && createVNode(VToolbarTitle, {
                  "key": "title",
                  "text": props.title
                }, {
                  text: slots.title
                }), (_b = slots.default) == null ? void 0 : _b.call(slots), slots.append && createVNode("div", {
                  "class": "v-toolbar__append"
                }, [(_c = slots.append) == null ? void 0 : _c.call(slots)])])];
              }
            }), createVNode(VDefaultsProvider, {
              "defaults": {
                VTabs: {
                  height: convertToUnit(extensionHeight.value)
                }
              }
            }, {
              default: () => [createVNode(VExpandTransition, null, {
                default: () => [isExtended.value && createVNode("div", {
                  "class": "v-toolbar__extension",
                  "style": {
                    height: convertToUnit(extensionHeight.value)
                  }
                }, [extension])]
              })]
            })]
          });
        });
        return {
          contentHeight,
          extensionHeight
        };
      }
    });
    const makeScrollProps = propsFactory({
      scrollTarget: {
        type: String
      },
      scrollThreshold: {
        type: [String, Number],
        default: 300
      }
    }, "scroll");
    function useScroll(props) {
      let args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const {
        canScroll
      } = args;
      let previousScroll = 0;
      const target2 = ref$1(null);
      const currentScroll = shallowRef(0);
      const savedScroll = shallowRef(0);
      const currentThreshold = shallowRef(0);
      const isScrollActive = shallowRef(false);
      const isScrollingUp = shallowRef(false);
      const scrollThreshold = computed(() => {
        return Number(props.scrollThreshold);
      });
      const scrollRatio = computed(() => {
        return clamp((scrollThreshold.value - currentScroll.value) / scrollThreshold.value || 0);
      });
      const onScroll = () => {
        const targetEl = target2.value;
        if (!targetEl || canScroll && !canScroll.value)
          return;
        previousScroll = currentScroll.value;
        currentScroll.value = "window" in targetEl ? targetEl.pageYOffset : targetEl.scrollTop;
        isScrollingUp.value = currentScroll.value < previousScroll;
        currentThreshold.value = Math.abs(currentScroll.value - scrollThreshold.value);
      };
      watch(isScrollingUp, () => {
        savedScroll.value = savedScroll.value || currentScroll.value;
      });
      watch(isScrollActive, () => {
        savedScroll.value = 0;
      });
      onMounted(() => {
        watch(() => props.scrollTarget, (scrollTarget) => {
          var _a2;
          const newTarget = scrollTarget ? document.querySelector(scrollTarget) : window;
          if (!newTarget) {
            return;
          }
          if (newTarget === target2.value)
            return;
          (_a2 = target2.value) == null ? void 0 : _a2.removeEventListener("scroll", onScroll);
          target2.value = newTarget;
          target2.value.addEventListener("scroll", onScroll, {
            passive: true
          });
        }, {
          immediate: true
        });
      });
      onBeforeUnmount(() => {
        var _a2;
        (_a2 = target2.value) == null ? void 0 : _a2.removeEventListener("scroll", onScroll);
      });
      canScroll && watch(canScroll, onScroll, {
        immediate: true
      });
      return {
        scrollThreshold,
        currentScroll,
        currentThreshold,
        isScrollActive,
        scrollRatio,
        // required only for testing
        // probably can be removed
        // later (2 chars chlng)
        isScrollingUp,
        savedScroll
      };
    }
    function useSsrBoot() {
      const isBooted = shallowRef(false);
      onMounted(() => {
        window.requestAnimationFrame(() => {
          isBooted.value = true;
        });
      });
      const ssrBootStyles = computed(() => !isBooted.value ? {
        transition: "none !important"
      } : void 0);
      return {
        ssrBootStyles,
        isBooted: readonly(isBooted)
      };
    }
    const makeVAppBarProps = propsFactory({
      scrollBehavior: String,
      modelValue: {
        type: Boolean,
        default: true
      },
      location: {
        type: String,
        default: "top",
        validator: (value) => ["top", "bottom"].includes(value)
      },
      ...makeVToolbarProps(),
      ...makeLayoutItemProps(),
      ...makeScrollProps(),
      height: {
        type: [Number, String],
        default: 64
      }
    }, "VAppBar");
    const VAppBar = genericComponent()({
      name: "VAppBar",
      props: makeVAppBarProps(),
      emits: {
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const vToolbarRef = ref$1();
        const isActive = useProxiedModel(props, "modelValue");
        const scrollBehavior = computed(() => {
          var _a2;
          const behavior = new Set(((_a2 = props.scrollBehavior) == null ? void 0 : _a2.split(" ")) ?? []);
          return {
            hide: behavior.has("hide"),
            // fullyHide: behavior.has('fully-hide'),
            inverted: behavior.has("inverted"),
            collapse: behavior.has("collapse"),
            elevate: behavior.has("elevate"),
            fadeImage: behavior.has("fade-image")
            // shrink: behavior.has('shrink'),
          };
        });
        const canScroll = computed(() => {
          const behavior = scrollBehavior.value;
          return behavior.hide || // behavior.fullyHide ||
          behavior.inverted || behavior.collapse || behavior.elevate || behavior.fadeImage || // behavior.shrink ||
          !isActive.value;
        });
        const {
          currentScroll,
          scrollThreshold,
          isScrollingUp,
          scrollRatio
        } = useScroll(props, {
          canScroll
        });
        const isCollapsed = computed(() => props.collapse || scrollBehavior.value.collapse && (scrollBehavior.value.inverted ? scrollRatio.value > 0 : scrollRatio.value === 0));
        const isFlat = computed(() => props.flat || scrollBehavior.value.elevate && (scrollBehavior.value.inverted ? currentScroll.value > 0 : currentScroll.value === 0));
        const opacity = computed(() => scrollBehavior.value.fadeImage ? scrollBehavior.value.inverted ? 1 - scrollRatio.value : scrollRatio.value : void 0);
        const height = computed(() => {
          var _a2, _b;
          if (scrollBehavior.value.hide && scrollBehavior.value.inverted)
            return 0;
          const height2 = ((_a2 = vToolbarRef.value) == null ? void 0 : _a2.contentHeight) ?? 0;
          const extensionHeight = ((_b = vToolbarRef.value) == null ? void 0 : _b.extensionHeight) ?? 0;
          return height2 + extensionHeight;
        });
        useToggleScope(computed(() => !!props.scrollBehavior), () => {
          watchEffect(() => {
            if (scrollBehavior.value.hide) {
              if (scrollBehavior.value.inverted) {
                isActive.value = currentScroll.value > scrollThreshold.value;
              } else {
                isActive.value = isScrollingUp.value || currentScroll.value < scrollThreshold.value;
              }
            } else {
              isActive.value = true;
            }
          });
        });
        const {
          ssrBootStyles
        } = useSsrBoot();
        const {
          layoutItemStyles
        } = useLayoutItem({
          id: props.name,
          order: computed(() => parseInt(props.order, 10)),
          position: toRef(props, "location"),
          layoutSize: height,
          elementSize: shallowRef(void 0),
          active: isActive,
          absolute: toRef(props, "absolute")
        });
        useRender(() => {
          const toolbarProps = VToolbar.filterProps(props);
          return createVNode(VToolbar, mergeProps({
            "ref": vToolbarRef,
            "class": ["v-app-bar", {
              "v-app-bar--bottom": props.location === "bottom"
            }, props.class],
            "style": [{
              ...layoutItemStyles.value,
              "--v-toolbar-image-opacity": opacity.value,
              height: void 0,
              ...ssrBootStyles.value
            }, props.style]
          }, toolbarProps, {
            "collapse": isCollapsed.value,
            "flat": isFlat.value
          }), slots);
        });
        return {};
      }
    });
    const allowedDensities = [null, "default", "comfortable", "compact"];
    const makeDensityProps = propsFactory({
      density: {
        type: String,
        default: "default",
        validator: (v) => allowedDensities.includes(v)
      }
    }, "density");
    function useDensity(props) {
      let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
      const densityClasses = computed(() => {
        return `${name}--density-${props.density}`;
      });
      return {
        densityClasses
      };
    }
    const allowedVariants$2 = ["elevated", "flat", "tonal", "outlined", "text", "plain"];
    function genOverlays(isClickable, name) {
      return createVNode(Fragment, null, [isClickable && createVNode("span", {
        "key": "overlay",
        "class": `${name}__overlay`
      }, null), createVNode("span", {
        "key": "underlay",
        "class": `${name}__underlay`
      }, null)]);
    }
    const makeVariantProps = propsFactory({
      color: String,
      variant: {
        type: String,
        default: "elevated",
        validator: (v) => allowedVariants$2.includes(v)
      }
    }, "variant");
    function useVariant(props) {
      let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
      const variantClasses = computed(() => {
        const {
          variant
        } = unref(props);
        return `${name}--variant-${variant}`;
      });
      const {
        colorClasses,
        colorStyles
      } = useColor(computed(() => {
        const {
          variant,
          color
        } = unref(props);
        return {
          [["elevated", "flat"].includes(variant) ? "background" : "text"]: color
        };
      }));
      return {
        colorClasses,
        colorStyles,
        variantClasses
      };
    }
    const makeVBtnGroupProps = propsFactory({
      divided: Boolean,
      ...makeBorderProps(),
      ...makeComponentProps(),
      ...makeDensityProps(),
      ...makeElevationProps(),
      ...makeRoundedProps(),
      ...makeTagProps(),
      ...makeThemeProps(),
      ...makeVariantProps()
    }, "VBtnGroup");
    const VBtnGroup = genericComponent()({
      name: "VBtnGroup",
      props: makeVBtnGroupProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          themeClasses
        } = provideTheme(props);
        const {
          densityClasses
        } = useDensity(props);
        const {
          borderClasses
        } = useBorder(props);
        const {
          elevationClasses
        } = useElevation(props);
        const {
          roundedClasses
        } = useRounded(props);
        provideDefaults({
          VBtn: {
            height: "auto",
            color: toRef(props, "color"),
            density: toRef(props, "density"),
            flat: true,
            variant: toRef(props, "variant")
          }
        });
        useRender(() => {
          return createVNode(props.tag, {
            "class": ["v-btn-group", {
              "v-btn-group--divided": props.divided
            }, themeClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value, props.class],
            "style": props.style
          }, slots);
        });
      }
    });
    const makeGroupProps = propsFactory({
      modelValue: {
        type: null,
        default: void 0
      },
      multiple: Boolean,
      mandatory: [Boolean, String],
      max: Number,
      selectedClass: String,
      disabled: Boolean
    }, "group");
    const makeGroupItemProps = propsFactory({
      value: null,
      disabled: Boolean,
      selectedClass: String
    }, "group-item");
    function useGroupItem(props, injectKey) {
      let required2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      const vm = getCurrentInstance("useGroupItem");
      if (!vm) {
        throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");
      }
      const id2 = getUid();
      provide(Symbol.for(`${injectKey.description}:id`), id2);
      const group = inject$1(injectKey, null);
      if (!group) {
        if (!required2)
          return group;
        throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${injectKey.description}`);
      }
      const value = toRef(props, "value");
      const disabled = computed(() => !!(group.disabled.value || props.disabled));
      group.register({
        id: id2,
        value,
        disabled
      }, vm);
      onBeforeUnmount(() => {
        group.unregister(id2);
      });
      const isSelected = computed(() => {
        return group.isSelected(id2);
      });
      const selectedClass = computed(() => isSelected.value && [group.selectedClass.value, props.selectedClass]);
      watch(isSelected, (value2) => {
        vm.emit("group:selected", {
          value: value2
        });
      }, {
        flush: "sync"
      });
      return {
        id: id2,
        isSelected,
        toggle: () => group.select(id2, !isSelected.value),
        select: (value2) => group.select(id2, value2),
        selectedClass,
        value,
        disabled,
        group
      };
    }
    function useGroup(props, injectKey) {
      let isUnmounted = false;
      const items2 = reactive([]);
      const selected = useProxiedModel(props, "modelValue", [], (v) => {
        if (v == null)
          return [];
        return getIds(items2, wrapInArray(v));
      }, (v) => {
        const arr = getValues(items2, v);
        return props.multiple ? arr : arr[0];
      });
      const groupVm = getCurrentInstance("useGroup");
      function register(item, vm) {
        const unwrapped = item;
        const key = Symbol.for(`${injectKey.description}:id`);
        const children = findChildrenWithProvide(key, groupVm == null ? void 0 : groupVm.vnode);
        const index = children.indexOf(vm);
        if (unref(unwrapped.value) == null) {
          unwrapped.value = index;
        }
        if (index > -1) {
          items2.splice(index, 0, unwrapped);
        } else {
          items2.push(unwrapped);
        }
      }
      function unregister(id2) {
        if (isUnmounted)
          return;
        forceMandatoryValue();
        const index = items2.findIndex((item) => item.id === id2);
        items2.splice(index, 1);
      }
      function forceMandatoryValue() {
        const item = items2.find((item2) => !item2.disabled);
        if (item && props.mandatory === "force" && !selected.value.length) {
          selected.value = [item.id];
        }
      }
      onMounted(() => {
        forceMandatoryValue();
      });
      onBeforeUnmount(() => {
        isUnmounted = true;
      });
      function select(id2, value) {
        const item = items2.find((item2) => item2.id === id2);
        if (value && (item == null ? void 0 : item.disabled))
          return;
        if (props.multiple) {
          const internalValue = selected.value.slice();
          const index = internalValue.findIndex((v) => v === id2);
          const isSelected = ~index;
          value = value ?? !isSelected;
          if (isSelected && props.mandatory && internalValue.length <= 1)
            return;
          if (!isSelected && props.max != null && internalValue.length + 1 > props.max)
            return;
          if (index < 0 && value)
            internalValue.push(id2);
          else if (index >= 0 && !value)
            internalValue.splice(index, 1);
          selected.value = internalValue;
        } else {
          const isSelected = selected.value.includes(id2);
          if (props.mandatory && isSelected)
            return;
          selected.value = value ?? !isSelected ? [id2] : [];
        }
      }
      function step(offset) {
        if (props.multiple)
          ;
        if (!selected.value.length) {
          const item = items2.find((item2) => !item2.disabled);
          item && (selected.value = [item.id]);
        } else {
          const currentId = selected.value[0];
          const currentIndex = items2.findIndex((i2) => i2.id === currentId);
          let newIndex = (currentIndex + offset) % items2.length;
          let newItem = items2[newIndex];
          while (newItem.disabled && newIndex !== currentIndex) {
            newIndex = (newIndex + offset) % items2.length;
            newItem = items2[newIndex];
          }
          if (newItem.disabled)
            return;
          selected.value = [items2[newIndex].id];
        }
      }
      const state = {
        register,
        unregister,
        selected,
        select,
        disabled: toRef(props, "disabled"),
        prev: () => step(items2.length - 1),
        next: () => step(1),
        isSelected: (id2) => selected.value.includes(id2),
        selectedClass: computed(() => props.selectedClass),
        items: computed(() => items2),
        getItemIndex: (value) => getItemIndex(items2, value)
      };
      provide(injectKey, state);
      return state;
    }
    function getItemIndex(items2, value) {
      const ids = getIds(items2, [value]);
      if (!ids.length)
        return -1;
      return items2.findIndex((item) => item.id === ids[0]);
    }
    function getIds(items2, modelValue) {
      const ids = [];
      modelValue.forEach((value) => {
        const item = items2.find((item2) => deepEqual(value, item2.value));
        const itemByIndex = items2[value];
        if ((item == null ? void 0 : item.value) != null) {
          ids.push(item.id);
        } else if (itemByIndex != null) {
          ids.push(itemByIndex.id);
        }
      });
      return ids;
    }
    function getValues(items2, ids) {
      const values = [];
      ids.forEach((id2) => {
        const itemIndex = items2.findIndex((item) => item.id === id2);
        if (~itemIndex) {
          const item = items2[itemIndex];
          values.push(item.value != null ? item.value : itemIndex);
        }
      });
      return values;
    }
    const VBtnToggleSymbol = Symbol.for("vuetify:v-btn-toggle");
    const makeVBtnToggleProps = propsFactory({
      ...makeVBtnGroupProps(),
      ...makeGroupProps()
    }, "VBtnToggle");
    genericComponent()({
      name: "VBtnToggle",
      props: makeVBtnToggleProps(),
      emits: {
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          isSelected,
          next: next2,
          prev,
          select,
          selected
        } = useGroup(props, VBtnToggleSymbol);
        useRender(() => {
          const btnGroupProps = VBtnGroup.filterProps(props);
          return createVNode(VBtnGroup, mergeProps({
            "class": ["v-btn-toggle", props.class]
          }, btnGroupProps, {
            "style": props.style
          }), {
            default: () => {
              var _a2;
              return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
                isSelected,
                next: next2,
                prev,
                select,
                selected
              })];
            }
          });
        });
        return {
          next: next2,
          prev,
          select
        };
      }
    });
    const aliases = {
      collapse: "mdi-chevron-up",
      complete: "mdi-check",
      cancel: "mdi-close-circle",
      close: "mdi-close",
      delete: "mdi-close-circle",
      // delete (e.g. v-chip close)
      clear: "mdi-close-circle",
      success: "mdi-check-circle",
      info: "mdi-information",
      warning: "mdi-alert-circle",
      error: "mdi-close-circle",
      prev: "mdi-chevron-left",
      next: "mdi-chevron-right",
      checkboxOn: "mdi-checkbox-marked",
      checkboxOff: "mdi-checkbox-blank-outline",
      checkboxIndeterminate: "mdi-minus-box",
      delimiter: "mdi-circle",
      // for carousel
      sortAsc: "mdi-arrow-up",
      sortDesc: "mdi-arrow-down",
      expand: "mdi-chevron-down",
      menu: "mdi-menu",
      subgroup: "mdi-menu-down",
      dropdown: "mdi-menu-down",
      radioOn: "mdi-radiobox-marked",
      radioOff: "mdi-radiobox-blank",
      edit: "mdi-pencil",
      ratingEmpty: "mdi-star-outline",
      ratingFull: "mdi-star",
      ratingHalf: "mdi-star-half-full",
      loading: "mdi-cached",
      first: "mdi-page-first",
      last: "mdi-page-last",
      unfold: "mdi-unfold-more-horizontal",
      file: "mdi-paperclip",
      plus: "mdi-plus",
      minus: "mdi-minus",
      calendar: "mdi-calendar",
      eyeDropper: "mdi-eyedropper"
    };
    const mdi = {
      // Not using mergeProps here, functional components merge props by default (?)
      component: (props) => h(VClassIcon, {
        ...props,
        class: "mdi"
      })
    };
    const IconValue = [String, Function, Object, Array];
    const IconSymbol = Symbol.for("vuetify:icons");
    const makeIconProps = propsFactory({
      icon: {
        type: IconValue
      },
      // Could not remove this and use makeTagProps, types complained because it is not required
      tag: {
        type: String,
        required: true
      }
    }, "icon");
    const VComponentIcon = genericComponent()({
      name: "VComponentIcon",
      props: makeIconProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        return () => {
          const Icon = props.icon;
          return createVNode(props.tag, null, {
            default: () => {
              var _a2;
              return [props.icon ? createVNode(Icon, null, null) : (_a2 = slots.default) == null ? void 0 : _a2.call(slots)];
            }
          });
        };
      }
    });
    const VSvgIcon = defineComponent({
      name: "VSvgIcon",
      inheritAttrs: false,
      props: makeIconProps(),
      setup(props, _ref2) {
        let {
          attrs
        } = _ref2;
        return () => {
          return createVNode(props.tag, mergeProps(attrs, {
            "style": null
          }), {
            default: () => [createVNode("svg", {
              "class": "v-icon__svg",
              "xmlns": "http://www.w3.org/2000/svg",
              "viewBox": "0 0 24 24",
              "role": "img",
              "aria-hidden": "true"
            }, [Array.isArray(props.icon) ? props.icon.map((path) => Array.isArray(path) ? createVNode("path", {
              "d": path[0],
              "fill-opacity": path[1]
            }, null) : createVNode("path", {
              "d": path
            }, null)) : createVNode("path", {
              "d": props.icon
            }, null)])]
          });
        };
      }
    });
    defineComponent({
      name: "VLigatureIcon",
      props: makeIconProps(),
      setup(props) {
        return () => {
          return createVNode(props.tag, null, {
            default: () => [props.icon]
          });
        };
      }
    });
    const VClassIcon = defineComponent({
      name: "VClassIcon",
      props: makeIconProps(),
      setup(props) {
        return () => {
          return createVNode(props.tag, {
            "class": props.icon
          }, null);
        };
      }
    });
    function genDefaults$1() {
      return {
        svg: {
          component: VSvgIcon
        },
        class: {
          component: VClassIcon
        }
      };
    }
    function createIcons(options) {
      const sets = genDefaults$1();
      const defaultSet = (options == null ? void 0 : options.defaultSet) ?? "mdi";
      if (defaultSet === "mdi" && !sets.mdi) {
        sets.mdi = mdi;
      }
      return mergeDeep({
        defaultSet,
        sets,
        aliases: {
          ...aliases,
          /* eslint-disable max-len */
          vuetify: ["M8.2241 14.2009L12 21L22 3H14.4459L8.2241 14.2009Z", ["M7.26303 12.4733L7.00113 12L2 3H12.5261C12.5261 3 12.5261 3 12.5261 3L7.26303 12.4733Z", 0.6]],
          "vuetify-outline": "svg:M7.26 12.47 12.53 3H2L7.26 12.47ZM14.45 3 8.22 14.2 12 21 22 3H14.45ZM18.6 5 12 16.88 10.51 14.2 15.62 5ZM7.26 8.35 5.4 5H9.13L7.26 8.35Z"
          /* eslint-enable max-len */
        }
      }, options);
    }
    const useIcon = (props) => {
      const icons = inject$1(IconSymbol);
      if (!icons)
        throw new Error("Missing Vuetify Icons provide!");
      const iconData = computed(() => {
        var _a2;
        const iconAlias = unref(props);
        if (!iconAlias)
          return {
            component: VComponentIcon
          };
        let icon = iconAlias;
        if (typeof icon === "string") {
          icon = icon.trim();
          if (icon.startsWith("$")) {
            icon = (_a2 = icons.aliases) == null ? void 0 : _a2[icon.slice(1)];
          }
        }
        if (!icon)
          throw new Error(`Could not find aliased icon "${iconAlias}"`);
        if (Array.isArray(icon)) {
          return {
            component: VSvgIcon,
            icon
          };
        } else if (typeof icon !== "string") {
          return {
            component: VComponentIcon,
            icon
          };
        }
        const iconSetName = Object.keys(icons.sets).find((setName) => typeof icon === "string" && icon.startsWith(`${setName}:`));
        const iconName = iconSetName ? icon.slice(iconSetName.length + 1) : icon;
        const iconSet = icons.sets[iconSetName ?? icons.defaultSet];
        return {
          component: iconSet.component,
          icon: iconName
        };
      });
      return {
        iconData
      };
    };
    const predefinedSizes = ["x-small", "small", "default", "large", "x-large"];
    const makeSizeProps = propsFactory({
      size: {
        type: [String, Number],
        default: "default"
      }
    }, "size");
    function useSize(props) {
      let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
      return destructComputed(() => {
        let sizeClasses;
        let sizeStyles;
        if (includes(predefinedSizes, props.size)) {
          sizeClasses = `${name}--size-${props.size}`;
        } else if (props.size) {
          sizeStyles = {
            width: convertToUnit(props.size),
            height: convertToUnit(props.size)
          };
        }
        return {
          sizeClasses,
          sizeStyles
        };
      });
    }
    const makeVIconProps = propsFactory({
      color: String,
      start: Boolean,
      end: Boolean,
      icon: IconValue,
      ...makeComponentProps(),
      ...makeSizeProps(),
      ...makeTagProps({
        tag: "i"
      }),
      ...makeThemeProps()
    }, "VIcon");
    const VIcon = genericComponent()({
      name: "VIcon",
      props: makeVIconProps(),
      setup(props, _ref) {
        let {
          attrs,
          slots
        } = _ref;
        const slotIcon = ref$1();
        const {
          themeClasses
        } = provideTheme(props);
        const {
          iconData
        } = useIcon(computed(() => slotIcon.value || props.icon));
        const {
          sizeClasses
        } = useSize(props);
        const {
          textColorClasses,
          textColorStyles
        } = useTextColor(toRef(props, "color"));
        useRender(() => {
          var _a2, _b;
          const slotValue = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
          if (slotValue) {
            slotIcon.value = (_b = flattenFragments(slotValue).filter((node) => node.type === Text$1 && node.children && typeof node.children === "string")[0]) == null ? void 0 : _b.children;
          }
          return createVNode(iconData.value.component, {
            "tag": props.tag,
            "icon": iconData.value.icon,
            "class": ["v-icon", "notranslate", themeClasses.value, sizeClasses.value, textColorClasses.value, {
              "v-icon--clickable": !!attrs.onClick,
              "v-icon--start": props.start,
              "v-icon--end": props.end
            }, props.class],
            "style": [!sizeClasses.value ? {
              fontSize: convertToUnit(props.size),
              height: convertToUnit(props.size),
              width: convertToUnit(props.size)
            } : void 0, textColorStyles.value, props.style],
            "role": attrs.onClick ? "button" : void 0,
            "aria-hidden": !attrs.onClick
          }, {
            default: () => [slotValue]
          });
        });
        return {};
      }
    });
    function useIntersectionObserver(callback, options) {
      const intersectionRef = ref$1();
      const isIntersecting = shallowRef(false);
      if (SUPPORTS_INTERSECTION) {
        const observer = new IntersectionObserver((entries) => {
          callback == null ? void 0 : callback(entries, observer);
          isIntersecting.value = !!entries.find((entry) => entry.isIntersecting);
        }, options);
        onBeforeUnmount(() => {
          observer.disconnect();
        });
        watch(intersectionRef, (newValue, oldValue) => {
          if (oldValue) {
            observer.unobserve(oldValue);
            isIntersecting.value = false;
          }
          if (newValue)
            observer.observe(newValue);
        }, {
          flush: "post"
        });
      }
      return {
        intersectionRef,
        isIntersecting
      };
    }
    const makeVProgressCircularProps = propsFactory({
      bgColor: String,
      color: String,
      indeterminate: [Boolean, String],
      modelValue: {
        type: [Number, String],
        default: 0
      },
      rotate: {
        type: [Number, String],
        default: 0
      },
      width: {
        type: [Number, String],
        default: 4
      },
      ...makeComponentProps(),
      ...makeSizeProps(),
      ...makeTagProps({
        tag: "div"
      }),
      ...makeThemeProps()
    }, "VProgressCircular");
    const VProgressCircular = genericComponent()({
      name: "VProgressCircular",
      props: makeVProgressCircularProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const MAGIC_RADIUS_CONSTANT = 20;
        const CIRCUMFERENCE = 2 * Math.PI * MAGIC_RADIUS_CONSTANT;
        const root = ref$1();
        const {
          themeClasses
        } = provideTheme(props);
        const {
          sizeClasses,
          sizeStyles
        } = useSize(props);
        const {
          textColorClasses,
          textColorStyles
        } = useTextColor(toRef(props, "color"));
        const {
          textColorClasses: underlayColorClasses,
          textColorStyles: underlayColorStyles
        } = useTextColor(toRef(props, "bgColor"));
        const {
          intersectionRef,
          isIntersecting
        } = useIntersectionObserver();
        const {
          resizeRef,
          contentRect
        } = useResizeObserver$1();
        const normalizedValue = computed(() => Math.max(0, Math.min(100, parseFloat(props.modelValue))));
        const width = computed(() => Number(props.width));
        const size2 = computed(() => {
          return sizeStyles.value ? Number(props.size) : contentRect.value ? contentRect.value.width : Math.max(width.value, 32);
        });
        const diameter = computed(() => MAGIC_RADIUS_CONSTANT / (1 - width.value / size2.value) * 2);
        const strokeWidth = computed(() => width.value / size2.value * diameter.value);
        const strokeDashOffset = computed(() => convertToUnit((100 - normalizedValue.value) / 100 * CIRCUMFERENCE));
        watchEffect(() => {
          intersectionRef.value = root.value;
          resizeRef.value = root.value;
        });
        useRender(() => createVNode(props.tag, {
          "ref": root,
          "class": ["v-progress-circular", {
            "v-progress-circular--indeterminate": !!props.indeterminate,
            "v-progress-circular--visible": isIntersecting.value,
            "v-progress-circular--disable-shrink": props.indeterminate === "disable-shrink"
          }, themeClasses.value, sizeClasses.value, textColorClasses.value, props.class],
          "style": [sizeStyles.value, textColorStyles.value, props.style],
          "role": "progressbar",
          "aria-valuemin": "0",
          "aria-valuemax": "100",
          "aria-valuenow": props.indeterminate ? void 0 : normalizedValue.value
        }, {
          default: () => [createVNode("svg", {
            "style": {
              transform: `rotate(calc(-90deg + ${Number(props.rotate)}deg))`
            },
            "xmlns": "http://www.w3.org/2000/svg",
            "viewBox": `0 0 ${diameter.value} ${diameter.value}`
          }, [createVNode("circle", {
            "class": ["v-progress-circular__underlay", underlayColorClasses.value],
            "style": underlayColorStyles.value,
            "fill": "transparent",
            "cx": "50%",
            "cy": "50%",
            "r": MAGIC_RADIUS_CONSTANT,
            "stroke-width": strokeWidth.value,
            "stroke-dasharray": CIRCUMFERENCE,
            "stroke-dashoffset": 0
          }, null), createVNode("circle", {
            "class": "v-progress-circular__overlay",
            "fill": "transparent",
            "cx": "50%",
            "cy": "50%",
            "r": MAGIC_RADIUS_CONSTANT,
            "stroke-width": strokeWidth.value,
            "stroke-dasharray": CIRCUMFERENCE,
            "stroke-dashoffset": strokeDashOffset.value
          }, null)]), slots.default && createVNode("div", {
            "class": "v-progress-circular__content"
          }, [slots.default({
            value: normalizedValue.value
          })])]
        }));
        return {};
      }
    });
    const oppositeMap = {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    };
    const makeLocationProps = propsFactory({
      location: String
    }, "location");
    function useLocation(props) {
      let opposite = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      let offset = arguments.length > 2 ? arguments[2] : void 0;
      const {
        isRtl
      } = useRtl();
      const locationStyles = computed(() => {
        if (!props.location)
          return {};
        const {
          side,
          align
        } = parseAnchor(props.location.split(" ").length > 1 ? props.location : `${props.location} center`, isRtl.value);
        function getOffset2(side2) {
          return offset ? offset(side2) : 0;
        }
        const styles = {};
        if (side !== "center") {
          if (opposite)
            styles[oppositeMap[side]] = `calc(100% - ${getOffset2(side)}px)`;
          else
            styles[side] = 0;
        }
        if (align !== "center") {
          if (opposite)
            styles[oppositeMap[align]] = `calc(100% - ${getOffset2(align)}px)`;
          else
            styles[align] = 0;
        } else {
          if (side === "center")
            styles.top = styles.left = "50%";
          else {
            styles[{
              top: "left",
              bottom: "left",
              left: "top",
              right: "top"
            }[side]] = "50%";
          }
          styles.transform = {
            top: "translateX(-50%)",
            bottom: "translateX(-50%)",
            left: "translateY(-50%)",
            right: "translateY(-50%)",
            center: "translate(-50%, -50%)"
          }[side];
        }
        return styles;
      });
      return {
        locationStyles
      };
    }
    const makeVProgressLinearProps = propsFactory({
      absolute: Boolean,
      active: {
        type: Boolean,
        default: true
      },
      bgColor: String,
      bgOpacity: [Number, String],
      bufferValue: {
        type: [Number, String],
        default: 0
      },
      clickable: Boolean,
      color: String,
      height: {
        type: [Number, String],
        default: 4
      },
      indeterminate: Boolean,
      max: {
        type: [Number, String],
        default: 100
      },
      modelValue: {
        type: [Number, String],
        default: 0
      },
      reverse: Boolean,
      stream: Boolean,
      striped: Boolean,
      roundedBar: Boolean,
      ...makeComponentProps(),
      ...makeLocationProps({
        location: "top"
      }),
      ...makeRoundedProps(),
      ...makeTagProps(),
      ...makeThemeProps()
    }, "VProgressLinear");
    const VProgressLinear = genericComponent()({
      name: "VProgressLinear",
      props: makeVProgressLinearProps(),
      emits: {
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const progress = useProxiedModel(props, "modelValue");
        const {
          isRtl,
          rtlClasses
        } = useRtl();
        const {
          themeClasses
        } = provideTheme(props);
        const {
          locationStyles
        } = useLocation(props);
        const {
          textColorClasses,
          textColorStyles
        } = useTextColor(props, "color");
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(computed(() => props.bgColor || props.color));
        const {
          backgroundColorClasses: barColorClasses,
          backgroundColorStyles: barColorStyles
        } = useBackgroundColor(props, "color");
        const {
          roundedClasses
        } = useRounded(props);
        const {
          intersectionRef,
          isIntersecting
        } = useIntersectionObserver();
        const max = computed(() => parseInt(props.max, 10));
        const height = computed(() => parseInt(props.height, 10));
        const normalizedBuffer = computed(() => parseFloat(props.bufferValue) / max.value * 100);
        const normalizedValue = computed(() => parseFloat(progress.value) / max.value * 100);
        const isReversed = computed(() => isRtl.value !== props.reverse);
        const transition = computed(() => props.indeterminate ? "fade-transition" : "slide-x-transition");
        const opacity = computed(() => {
          return props.bgOpacity == null ? props.bgOpacity : parseFloat(props.bgOpacity);
        });
        function handleClick(e) {
          if (!intersectionRef.value)
            return;
          const {
            left,
            right,
            width
          } = intersectionRef.value.getBoundingClientRect();
          const value = isReversed.value ? width - e.clientX + (right - width) : e.clientX - left;
          progress.value = Math.round(value / width * max.value);
        }
        useRender(() => createVNode(props.tag, {
          "ref": intersectionRef,
          "class": ["v-progress-linear", {
            "v-progress-linear--absolute": props.absolute,
            "v-progress-linear--active": props.active && isIntersecting.value,
            "v-progress-linear--reverse": isReversed.value,
            "v-progress-linear--rounded": props.rounded,
            "v-progress-linear--rounded-bar": props.roundedBar,
            "v-progress-linear--striped": props.striped
          }, roundedClasses.value, themeClasses.value, rtlClasses.value, props.class],
          "style": [{
            bottom: props.location === "bottom" ? 0 : void 0,
            top: props.location === "top" ? 0 : void 0,
            height: props.active ? convertToUnit(height.value) : 0,
            "--v-progress-linear-height": convertToUnit(height.value),
            ...locationStyles.value
          }, props.style],
          "role": "progressbar",
          "aria-hidden": props.active ? "false" : "true",
          "aria-valuemin": "0",
          "aria-valuemax": props.max,
          "aria-valuenow": props.indeterminate ? void 0 : normalizedValue.value,
          "onClick": props.clickable && handleClick
        }, {
          default: () => [props.stream && createVNode("div", {
            "key": "stream",
            "class": ["v-progress-linear__stream", textColorClasses.value],
            "style": {
              ...textColorStyles.value,
              [isReversed.value ? "left" : "right"]: convertToUnit(-height.value),
              borderTop: `${convertToUnit(height.value / 2)} dotted`,
              opacity: opacity.value,
              top: `calc(50% - ${convertToUnit(height.value / 4)})`,
              width: convertToUnit(100 - normalizedBuffer.value, "%"),
              "--v-progress-linear-stream-to": convertToUnit(height.value * (isReversed.value ? 1 : -1))
            }
          }, null), createVNode("div", {
            "class": ["v-progress-linear__background", backgroundColorClasses.value],
            "style": [backgroundColorStyles.value, {
              opacity: opacity.value,
              width: convertToUnit(!props.stream ? 100 : normalizedBuffer.value, "%")
            }]
          }, null), createVNode(Transition, {
            "name": transition.value
          }, {
            default: () => [!props.indeterminate ? createVNode("div", {
              "class": ["v-progress-linear__determinate", barColorClasses.value],
              "style": [barColorStyles.value, {
                width: convertToUnit(normalizedValue.value, "%")
              }]
            }, null) : createVNode("div", {
              "class": "v-progress-linear__indeterminate"
            }, [["long", "short"].map((bar) => createVNode("div", {
              "key": bar,
              "class": ["v-progress-linear__indeterminate", bar, barColorClasses.value],
              "style": barColorStyles.value
            }, null))])]
          }), slots.default && createVNode("div", {
            "class": "v-progress-linear__content"
          }, [slots.default({
            value: normalizedValue.value,
            buffer: normalizedBuffer.value
          })])]
        }));
        return {};
      }
    });
    const makeLoaderProps = propsFactory({
      loading: [Boolean, String]
    }, "loader");
    function useLoader(props) {
      let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
      const loaderClasses = computed(() => ({
        [`${name}--loading`]: props.loading
      }));
      return {
        loaderClasses
      };
    }
    function LoaderSlot(props, _ref) {
      var _a2;
      let {
        slots
      } = _ref;
      return createVNode("div", {
        "class": `${props.name}__loader`
      }, [((_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
        color: props.color,
        isActive: props.active
      })) || createVNode(VProgressLinear, {
        "absolute": props.absolute,
        "active": props.active,
        "color": props.color,
        "height": "2",
        "indeterminate": true
      }, null)]);
    }
    const positionValues = ["static", "relative", "fixed", "absolute", "sticky"];
    const makePositionProps = propsFactory({
      position: {
        type: String,
        validator: (
          /* istanbul ignore next */
          (v) => positionValues.includes(v)
        )
      }
    }, "position");
    function usePosition(props) {
      let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
      const positionClasses = computed(() => {
        return props.position ? `${name}--${props.position}` : void 0;
      });
      return {
        positionClasses
      };
    }
    function useRoute() {
      const vm = getCurrentInstance("useRoute");
      return computed(() => {
        var _a2;
        return (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$route;
      });
    }
    function useRouter() {
      var _a2, _b;
      return (_b = (_a2 = getCurrentInstance("useRouter")) == null ? void 0 : _a2.proxy) == null ? void 0 : _b.$router;
    }
    function useLink(props, attrs) {
      const RouterLink2 = resolveDynamicComponent("RouterLink");
      const isLink = computed(() => !!(props.href || props.to));
      const isClickable = computed(() => {
        return (isLink == null ? void 0 : isLink.value) || hasEvent(attrs, "click") || hasEvent(props, "click");
      });
      if (typeof RouterLink2 === "string") {
        return {
          isLink,
          isClickable,
          href: toRef(props, "href")
        };
      }
      const link2 = props.to ? RouterLink2.useLink(props) : void 0;
      const route = useRoute();
      return {
        isLink,
        isClickable,
        route: link2 == null ? void 0 : link2.route,
        navigate: link2 == null ? void 0 : link2.navigate,
        isActive: link2 && computed(() => {
          var _a2, _b, _c;
          if (!props.exact)
            return (_a2 = link2.isActive) == null ? void 0 : _a2.value;
          if (!route.value)
            return (_b = link2.isExactActive) == null ? void 0 : _b.value;
          return ((_c = link2.isExactActive) == null ? void 0 : _c.value) && deepEqual(link2.route.value.query, route.value.query);
        }),
        href: computed(() => props.to ? link2 == null ? void 0 : link2.route.value.href : props.href)
      };
    }
    const makeRouterProps = propsFactory({
      href: String,
      replace: Boolean,
      to: [String, Object],
      exact: Boolean
    }, "router");
    let inTransition = false;
    function useBackButton(router2, cb) {
      let popped = false;
      let removeBefore;
      let removeAfter;
      if (IN_BROWSER) {
        nextTick(() => {
          window.addEventListener("popstate", onPopstate);
          removeBefore = router2 == null ? void 0 : router2.beforeEach((to, from, next2) => {
            if (!inTransition) {
              setTimeout(() => popped ? cb(next2) : next2());
            } else {
              popped ? cb(next2) : next2();
            }
            inTransition = true;
          });
          removeAfter = router2 == null ? void 0 : router2.afterEach(() => {
            inTransition = false;
          });
        });
        onScopeDispose(() => {
          window.removeEventListener("popstate", onPopstate);
          removeBefore == null ? void 0 : removeBefore();
          removeAfter == null ? void 0 : removeAfter();
        });
      }
      function onPopstate(e) {
        var _a2;
        if ((_a2 = e.state) == null ? void 0 : _a2.replaced)
          return;
        popped = true;
        setTimeout(() => popped = false);
      }
    }
    function useSelectLink(link2, select) {
      watch(() => {
        var _a2;
        return (_a2 = link2.isActive) == null ? void 0 : _a2.value;
      }, (isActive) => {
        if (link2.isLink.value && isActive && select) {
          nextTick(() => {
            select(true);
          });
        }
      }, {
        immediate: true
      });
    }
    const stopSymbol = Symbol("rippleStop");
    const DELAY_RIPPLE = 80;
    function transform(el2, value) {
      el2.style.transform = value;
      el2.style.webkitTransform = value;
    }
    function isTouchEvent(e) {
      return e.constructor.name === "TouchEvent";
    }
    function isKeyboardEvent(e) {
      return e.constructor.name === "KeyboardEvent";
    }
    const calculate = function(e, el2) {
      var _a2;
      let value = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      let localX = 0;
      let localY = 0;
      if (!isKeyboardEvent(e)) {
        const offset = el2.getBoundingClientRect();
        const target2 = isTouchEvent(e) ? e.touches[e.touches.length - 1] : e;
        localX = target2.clientX - offset.left;
        localY = target2.clientY - offset.top;
      }
      let radius = 0;
      let scale = 0.3;
      if ((_a2 = el2._ripple) == null ? void 0 : _a2.circle) {
        scale = 0.15;
        radius = el2.clientWidth / 2;
        radius = value.center ? radius : radius + Math.sqrt((localX - radius) ** 2 + (localY - radius) ** 2) / 4;
      } else {
        radius = Math.sqrt(el2.clientWidth ** 2 + el2.clientHeight ** 2) / 2;
      }
      const centerX = `${(el2.clientWidth - radius * 2) / 2}px`;
      const centerY = `${(el2.clientHeight - radius * 2) / 2}px`;
      const x = value.center ? centerX : `${localX - radius}px`;
      const y = value.center ? centerY : `${localY - radius}px`;
      return {
        radius,
        scale,
        x,
        y,
        centerX,
        centerY
      };
    };
    const ripples = {
      /* eslint-disable max-statements */
      show(e, el2) {
        var _a2;
        let value = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (!((_a2 = el2 == null ? void 0 : el2._ripple) == null ? void 0 : _a2.enabled)) {
          return;
        }
        const container = document.createElement("span");
        const animation = document.createElement("span");
        container.appendChild(animation);
        container.className = "v-ripple__container";
        if (value.class) {
          container.className += ` ${value.class}`;
        }
        const {
          radius,
          scale,
          x,
          y,
          centerX,
          centerY
        } = calculate(e, el2, value);
        const size2 = `${radius * 2}px`;
        animation.className = "v-ripple__animation";
        animation.style.width = size2;
        animation.style.height = size2;
        el2.appendChild(container);
        const computed2 = window.getComputedStyle(el2);
        if (computed2 && computed2.position === "static") {
          el2.style.position = "relative";
          el2.dataset.previousPosition = "static";
        }
        animation.classList.add("v-ripple__animation--enter");
        animation.classList.add("v-ripple__animation--visible");
        transform(animation, `translate(${x}, ${y}) scale3d(${scale},${scale},${scale})`);
        animation.dataset.activated = String(performance.now());
        setTimeout(() => {
          animation.classList.remove("v-ripple__animation--enter");
          animation.classList.add("v-ripple__animation--in");
          transform(animation, `translate(${centerX}, ${centerY}) scale3d(1,1,1)`);
        }, 0);
      },
      hide(el2) {
        var _a2;
        if (!((_a2 = el2 == null ? void 0 : el2._ripple) == null ? void 0 : _a2.enabled))
          return;
        const ripples2 = el2.getElementsByClassName("v-ripple__animation");
        if (ripples2.length === 0)
          return;
        const animation = ripples2[ripples2.length - 1];
        if (animation.dataset.isHiding)
          return;
        else
          animation.dataset.isHiding = "true";
        const diff = performance.now() - Number(animation.dataset.activated);
        const delay = Math.max(250 - diff, 0);
        setTimeout(() => {
          animation.classList.remove("v-ripple__animation--in");
          animation.classList.add("v-ripple__animation--out");
          setTimeout(() => {
            var _a3;
            const ripples3 = el2.getElementsByClassName("v-ripple__animation");
            if (ripples3.length === 1 && el2.dataset.previousPosition) {
              el2.style.position = el2.dataset.previousPosition;
              delete el2.dataset.previousPosition;
            }
            if (((_a3 = animation.parentNode) == null ? void 0 : _a3.parentNode) === el2)
              el2.removeChild(animation.parentNode);
          }, 300);
        }, delay);
      }
    };
    function isRippleEnabled(value) {
      return typeof value === "undefined" || !!value;
    }
    function rippleShow(e) {
      const value = {};
      const element = e.currentTarget;
      if (!(element == null ? void 0 : element._ripple) || element._ripple.touched || e[stopSymbol])
        return;
      e[stopSymbol] = true;
      if (isTouchEvent(e)) {
        element._ripple.touched = true;
        element._ripple.isTouch = true;
      } else {
        if (element._ripple.isTouch)
          return;
      }
      value.center = element._ripple.centered || isKeyboardEvent(e);
      if (element._ripple.class) {
        value.class = element._ripple.class;
      }
      if (isTouchEvent(e)) {
        if (element._ripple.showTimerCommit)
          return;
        element._ripple.showTimerCommit = () => {
          ripples.show(e, element, value);
        };
        element._ripple.showTimer = window.setTimeout(() => {
          var _a2;
          if ((_a2 = element == null ? void 0 : element._ripple) == null ? void 0 : _a2.showTimerCommit) {
            element._ripple.showTimerCommit();
            element._ripple.showTimerCommit = null;
          }
        }, DELAY_RIPPLE);
      } else {
        ripples.show(e, element, value);
      }
    }
    function rippleStop(e) {
      e[stopSymbol] = true;
    }
    function rippleHide(e) {
      const element = e.currentTarget;
      if (!(element == null ? void 0 : element._ripple))
        return;
      window.clearTimeout(element._ripple.showTimer);
      if (e.type === "touchend" && element._ripple.showTimerCommit) {
        element._ripple.showTimerCommit();
        element._ripple.showTimerCommit = null;
        element._ripple.showTimer = window.setTimeout(() => {
          rippleHide(e);
        });
        return;
      }
      window.setTimeout(() => {
        if (element._ripple) {
          element._ripple.touched = false;
        }
      });
      ripples.hide(element);
    }
    function rippleCancelShow(e) {
      const element = e.currentTarget;
      if (!(element == null ? void 0 : element._ripple))
        return;
      if (element._ripple.showTimerCommit) {
        element._ripple.showTimerCommit = null;
      }
      window.clearTimeout(element._ripple.showTimer);
    }
    let keyboardRipple = false;
    function keyboardRippleShow(e) {
      if (!keyboardRipple && (e.keyCode === keyCodes.enter || e.keyCode === keyCodes.space)) {
        keyboardRipple = true;
        rippleShow(e);
      }
    }
    function keyboardRippleHide(e) {
      keyboardRipple = false;
      rippleHide(e);
    }
    function focusRippleHide(e) {
      if (keyboardRipple) {
        keyboardRipple = false;
        rippleHide(e);
      }
    }
    function updateRipple(el2, binding, wasEnabled) {
      const {
        value,
        modifiers
      } = binding;
      const enabled = isRippleEnabled(value);
      if (!enabled) {
        ripples.hide(el2);
      }
      el2._ripple = el2._ripple ?? {};
      el2._ripple.enabled = enabled;
      el2._ripple.centered = modifiers.center;
      el2._ripple.circle = modifiers.circle;
      if (isObject$2(value) && value.class) {
        el2._ripple.class = value.class;
      }
      if (enabled && !wasEnabled) {
        if (modifiers.stop) {
          el2.addEventListener("touchstart", rippleStop, {
            passive: true
          });
          el2.addEventListener("mousedown", rippleStop);
          return;
        }
        el2.addEventListener("touchstart", rippleShow, {
          passive: true
        });
        el2.addEventListener("touchend", rippleHide, {
          passive: true
        });
        el2.addEventListener("touchmove", rippleCancelShow, {
          passive: true
        });
        el2.addEventListener("touchcancel", rippleHide);
        el2.addEventListener("mousedown", rippleShow);
        el2.addEventListener("mouseup", rippleHide);
        el2.addEventListener("mouseleave", rippleHide);
        el2.addEventListener("keydown", keyboardRippleShow);
        el2.addEventListener("keyup", keyboardRippleHide);
        el2.addEventListener("blur", focusRippleHide);
        el2.addEventListener("dragstart", rippleHide, {
          passive: true
        });
      } else if (!enabled && wasEnabled) {
        removeListeners(el2);
      }
    }
    function removeListeners(el2) {
      el2.removeEventListener("mousedown", rippleShow);
      el2.removeEventListener("touchstart", rippleShow);
      el2.removeEventListener("touchend", rippleHide);
      el2.removeEventListener("touchmove", rippleCancelShow);
      el2.removeEventListener("touchcancel", rippleHide);
      el2.removeEventListener("mouseup", rippleHide);
      el2.removeEventListener("mouseleave", rippleHide);
      el2.removeEventListener("keydown", keyboardRippleShow);
      el2.removeEventListener("keyup", keyboardRippleHide);
      el2.removeEventListener("dragstart", rippleHide);
      el2.removeEventListener("blur", focusRippleHide);
    }
    function mounted$1(el2, binding) {
      updateRipple(el2, binding, false);
    }
    function unmounted$1(el2) {
      delete el2._ripple;
      removeListeners(el2);
    }
    function updated(el2, binding) {
      if (binding.value === binding.oldValue) {
        return;
      }
      const wasEnabled = isRippleEnabled(binding.oldValue);
      updateRipple(el2, binding, wasEnabled);
    }
    const Ripple = {
      mounted: mounted$1,
      unmounted: unmounted$1,
      updated
    };
    const makeVBtnProps = propsFactory({
      active: {
        type: Boolean,
        default: void 0
      },
      symbol: {
        type: null,
        default: VBtnToggleSymbol
      },
      flat: Boolean,
      icon: [Boolean, String, Function, Object],
      prependIcon: IconValue,
      appendIcon: IconValue,
      block: Boolean,
      slim: Boolean,
      stacked: Boolean,
      ripple: {
        type: [Boolean, Object],
        default: true
      },
      text: String,
      ...makeBorderProps(),
      ...makeComponentProps(),
      ...makeDensityProps(),
      ...makeDimensionProps(),
      ...makeElevationProps(),
      ...makeGroupItemProps(),
      ...makeLoaderProps(),
      ...makeLocationProps(),
      ...makePositionProps(),
      ...makeRoundedProps(),
      ...makeRouterProps(),
      ...makeSizeProps(),
      ...makeTagProps({
        tag: "button"
      }),
      ...makeThemeProps(),
      ...makeVariantProps({
        variant: "elevated"
      })
    }, "VBtn");
    const VBtn = genericComponent()({
      name: "VBtn",
      directives: {
        Ripple
      },
      props: makeVBtnProps(),
      emits: {
        "group:selected": (val) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          slots
        } = _ref;
        const {
          themeClasses
        } = provideTheme(props);
        const {
          borderClasses
        } = useBorder(props);
        const {
          colorClasses,
          colorStyles,
          variantClasses
        } = useVariant(props);
        const {
          densityClasses
        } = useDensity(props);
        const {
          dimensionStyles
        } = useDimension(props);
        const {
          elevationClasses
        } = useElevation(props);
        const {
          loaderClasses
        } = useLoader(props);
        const {
          locationStyles
        } = useLocation(props);
        const {
          positionClasses
        } = usePosition(props);
        const {
          roundedClasses
        } = useRounded(props);
        const {
          sizeClasses,
          sizeStyles
        } = useSize(props);
        const group = useGroupItem(props, props.symbol, false);
        const link2 = useLink(props, attrs);
        const isActive = computed(() => {
          var _a2;
          if (props.active !== void 0) {
            return props.active;
          }
          if (link2.isLink.value) {
            return (_a2 = link2.isActive) == null ? void 0 : _a2.value;
          }
          return group == null ? void 0 : group.isSelected.value;
        });
        const isDisabled = computed(() => (group == null ? void 0 : group.disabled.value) || props.disabled);
        const isElevated = computed(() => {
          return props.variant === "elevated" && !(props.disabled || props.flat || props.border);
        });
        const valueAttr = computed(() => {
          if (props.value === void 0 || typeof props.value === "symbol")
            return void 0;
          return Object(props.value) === props.value ? JSON.stringify(props.value, null, 0) : props.value;
        });
        function onClick(e) {
          var _a2;
          if (isDisabled.value || link2.isLink.value && (e.metaKey || e.ctrlKey || e.shiftKey || e.button !== 0 || attrs.target === "_blank"))
            return;
          (_a2 = link2.navigate) == null ? void 0 : _a2.call(link2, e);
          group == null ? void 0 : group.toggle();
        }
        useSelectLink(link2, group == null ? void 0 : group.select);
        useRender(() => {
          var _a2, _b;
          const Tag2 = link2.isLink.value ? "a" : props.tag;
          const hasPrepend = !!(props.prependIcon || slots.prepend);
          const hasAppend = !!(props.appendIcon || slots.append);
          const hasIcon = !!(props.icon && props.icon !== true);
          const hasColor = (group == null ? void 0 : group.isSelected.value) && (!link2.isLink.value || ((_a2 = link2.isActive) == null ? void 0 : _a2.value)) || !group || ((_b = link2.isActive) == null ? void 0 : _b.value);
          return withDirectives(createVNode(Tag2, {
            "type": Tag2 === "a" ? void 0 : "button",
            "class": ["v-btn", group == null ? void 0 : group.selectedClass.value, {
              "v-btn--active": isActive.value,
              "v-btn--block": props.block,
              "v-btn--disabled": isDisabled.value,
              "v-btn--elevated": isElevated.value,
              "v-btn--flat": props.flat,
              "v-btn--icon": !!props.icon,
              "v-btn--loading": props.loading,
              "v-btn--slim": props.slim,
              "v-btn--stacked": props.stacked
            }, themeClasses.value, borderClasses.value, hasColor ? colorClasses.value : void 0, densityClasses.value, elevationClasses.value, loaderClasses.value, positionClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, props.class],
            "style": [hasColor ? colorStyles.value : void 0, dimensionStyles.value, locationStyles.value, sizeStyles.value, props.style],
            "disabled": isDisabled.value || void 0,
            "href": link2.href.value,
            "onClick": onClick,
            "value": valueAttr.value
          }, {
            default: () => {
              var _a3;
              return [genOverlays(true, "v-btn"), !props.icon && hasPrepend && createVNode("span", {
                "key": "prepend",
                "class": "v-btn__prepend"
              }, [!slots.prepend ? createVNode(VIcon, {
                "key": "prepend-icon",
                "icon": props.prependIcon
              }, null) : createVNode(VDefaultsProvider, {
                "key": "prepend-defaults",
                "disabled": !props.prependIcon,
                "defaults": {
                  VIcon: {
                    icon: props.prependIcon
                  }
                }
              }, slots.prepend)]), createVNode("span", {
                "class": "v-btn__content",
                "data-no-activator": ""
              }, [!slots.default && hasIcon ? createVNode(VIcon, {
                "key": "content-icon",
                "icon": props.icon
              }, null) : createVNode(VDefaultsProvider, {
                "key": "content-defaults",
                "disabled": !hasIcon,
                "defaults": {
                  VIcon: {
                    icon: props.icon
                  }
                }
              }, {
                default: () => {
                  var _a4;
                  return [((_a4 = slots.default) == null ? void 0 : _a4.call(slots)) ?? props.text];
                }
              })]), !props.icon && hasAppend && createVNode("span", {
                "key": "append",
                "class": "v-btn__append"
              }, [!slots.append ? createVNode(VIcon, {
                "key": "append-icon",
                "icon": props.appendIcon
              }, null) : createVNode(VDefaultsProvider, {
                "key": "append-defaults",
                "disabled": !props.appendIcon,
                "defaults": {
                  VIcon: {
                    icon: props.appendIcon
                  }
                }
              }, slots.append)]), !!props.loading && createVNode("span", {
                "key": "loader",
                "class": "v-btn__loader"
              }, [((_a3 = slots.loader) == null ? void 0 : _a3.call(slots)) ?? createVNode(VProgressCircular, {
                "color": typeof props.loading === "boolean" ? void 0 : props.loading,
                "indeterminate": true,
                "size": "23",
                "width": "2"
              }, null)])];
            }
          }), [[resolveDirective("ripple"), !isDisabled.value && props.ripple, null]]);
        });
        return {
          group
        };
      }
    });
    const makeVAppBarNavIconProps = propsFactory({
      ...makeVBtnProps({
        icon: "$menu",
        variant: "text"
      })
    }, "VAppBarNavIcon");
    const VAppBarNavIcon = genericComponent()({
      name: "VAppBarNavIcon",
      props: makeVAppBarNavIconProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        useRender(() => createVNode(VBtn, mergeProps(props, {
          "class": ["v-app-bar-nav-icon"]
        }), slots));
        return {};
      }
    });
    const VCardActions = genericComponent()({
      name: "VCardActions",
      props: makeComponentProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        provideDefaults({
          VBtn: {
            slim: true,
            variant: "text"
          }
        });
        useRender(() => {
          var _a2;
          return createVNode("div", {
            "class": ["v-card-actions", props.class],
            "style": props.style
          }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
        });
        return {};
      }
    });
    const VCardSubtitle = createSimpleFunctional("v-card-subtitle");
    const VCardTitle = createSimpleFunctional("v-card-title");
    const makeVAvatarProps = propsFactory({
      start: Boolean,
      end: Boolean,
      icon: IconValue,
      image: String,
      text: String,
      ...makeComponentProps(),
      ...makeDensityProps(),
      ...makeRoundedProps(),
      ...makeSizeProps(),
      ...makeTagProps(),
      ...makeThemeProps(),
      ...makeVariantProps({
        variant: "flat"
      })
    }, "VAvatar");
    const VAvatar = genericComponent()({
      name: "VAvatar",
      props: makeVAvatarProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          themeClasses
        } = provideTheme(props);
        const {
          colorClasses,
          colorStyles,
          variantClasses
        } = useVariant(props);
        const {
          densityClasses
        } = useDensity(props);
        const {
          roundedClasses
        } = useRounded(props);
        const {
          sizeClasses,
          sizeStyles
        } = useSize(props);
        useRender(() => createVNode(props.tag, {
          "class": ["v-avatar", {
            "v-avatar--start": props.start,
            "v-avatar--end": props.end
          }, themeClasses.value, colorClasses.value, densityClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, props.class],
          "style": [colorStyles.value, sizeStyles.value, props.style]
        }, {
          default: () => [!slots.default ? props.image ? createVNode(VImg, {
            "key": "image",
            "src": props.image,
            "alt": "",
            "cover": true
          }, null) : props.icon ? createVNode(VIcon, {
            "key": "icon",
            "icon": props.icon
          }, null) : props.text : createVNode(VDefaultsProvider, {
            "key": "content-defaults",
            "defaults": {
              VImg: {
                cover: true,
                image: props.image
              },
              VIcon: {
                icon: props.icon
              }
            }
          }, {
            default: () => [slots.default()]
          }), genOverlays(false, "v-avatar")]
        }));
        return {};
      }
    });
    const makeCardItemProps = propsFactory({
      appendAvatar: String,
      appendIcon: IconValue,
      prependAvatar: String,
      prependIcon: IconValue,
      subtitle: [String, Number],
      title: [String, Number],
      ...makeComponentProps(),
      ...makeDensityProps()
    }, "VCardItem");
    const VCardItem = genericComponent()({
      name: "VCardItem",
      props: makeCardItemProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        useRender(() => {
          var _a2;
          const hasPrependMedia = !!(props.prependAvatar || props.prependIcon);
          const hasPrepend = !!(hasPrependMedia || slots.prepend);
          const hasAppendMedia = !!(props.appendAvatar || props.appendIcon);
          const hasAppend = !!(hasAppendMedia || slots.append);
          const hasTitle = !!(props.title != null || slots.title);
          const hasSubtitle = !!(props.subtitle != null || slots.subtitle);
          return createVNode("div", {
            "class": ["v-card-item", props.class],
            "style": props.style
          }, [hasPrepend && createVNode("div", {
            "key": "prepend",
            "class": "v-card-item__prepend"
          }, [!slots.prepend ? createVNode(Fragment, null, [props.prependAvatar && createVNode(VAvatar, {
            "key": "prepend-avatar",
            "density": props.density,
            "image": props.prependAvatar
          }, null), props.prependIcon && createVNode(VIcon, {
            "key": "prepend-icon",
            "density": props.density,
            "icon": props.prependIcon
          }, null)]) : createVNode(VDefaultsProvider, {
            "key": "prepend-defaults",
            "disabled": !hasPrependMedia,
            "defaults": {
              VAvatar: {
                density: props.density,
                image: props.prependAvatar
              },
              VIcon: {
                density: props.density,
                icon: props.prependIcon
              }
            }
          }, slots.prepend)]), createVNode("div", {
            "class": "v-card-item__content"
          }, [hasTitle && createVNode(VCardTitle, {
            "key": "title"
          }, {
            default: () => {
              var _a3;
              return [((_a3 = slots.title) == null ? void 0 : _a3.call(slots)) ?? props.title];
            }
          }), hasSubtitle && createVNode(VCardSubtitle, {
            "key": "subtitle"
          }, {
            default: () => {
              var _a3;
              return [((_a3 = slots.subtitle) == null ? void 0 : _a3.call(slots)) ?? props.subtitle];
            }
          }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), hasAppend && createVNode("div", {
            "key": "append",
            "class": "v-card-item__append"
          }, [!slots.append ? createVNode(Fragment, null, [props.appendIcon && createVNode(VIcon, {
            "key": "append-icon",
            "density": props.density,
            "icon": props.appendIcon
          }, null), props.appendAvatar && createVNode(VAvatar, {
            "key": "append-avatar",
            "density": props.density,
            "image": props.appendAvatar
          }, null)]) : createVNode(VDefaultsProvider, {
            "key": "append-defaults",
            "disabled": !hasAppendMedia,
            "defaults": {
              VAvatar: {
                density: props.density,
                image: props.appendAvatar
              },
              VIcon: {
                density: props.density,
                icon: props.appendIcon
              }
            }
          }, slots.append)])]);
        });
        return {};
      }
    });
    const VCardText = createSimpleFunctional("v-card-text");
    const makeVCardProps = propsFactory({
      appendAvatar: String,
      appendIcon: IconValue,
      disabled: Boolean,
      flat: Boolean,
      hover: Boolean,
      image: String,
      link: {
        type: Boolean,
        default: void 0
      },
      prependAvatar: String,
      prependIcon: IconValue,
      ripple: {
        type: [Boolean, Object],
        default: true
      },
      subtitle: [String, Number],
      text: [String, Number],
      title: [String, Number],
      ...makeBorderProps(),
      ...makeComponentProps(),
      ...makeDensityProps(),
      ...makeDimensionProps(),
      ...makeElevationProps(),
      ...makeLoaderProps(),
      ...makeLocationProps(),
      ...makePositionProps(),
      ...makeRoundedProps(),
      ...makeRouterProps(),
      ...makeTagProps(),
      ...makeThemeProps(),
      ...makeVariantProps({
        variant: "elevated"
      })
    }, "VCard");
    const VCard = genericComponent()({
      name: "VCard",
      directives: {
        Ripple
      },
      props: makeVCardProps(),
      setup(props, _ref) {
        let {
          attrs,
          slots
        } = _ref;
        const {
          themeClasses
        } = provideTheme(props);
        const {
          borderClasses
        } = useBorder(props);
        const {
          colorClasses,
          colorStyles,
          variantClasses
        } = useVariant(props);
        const {
          densityClasses
        } = useDensity(props);
        const {
          dimensionStyles
        } = useDimension(props);
        const {
          elevationClasses
        } = useElevation(props);
        const {
          loaderClasses
        } = useLoader(props);
        const {
          locationStyles
        } = useLocation(props);
        const {
          positionClasses
        } = usePosition(props);
        const {
          roundedClasses
        } = useRounded(props);
        const link2 = useLink(props, attrs);
        const isLink = computed(() => props.link !== false && link2.isLink.value);
        const isClickable = computed(() => !props.disabled && props.link !== false && (props.link || link2.isClickable.value));
        useRender(() => {
          const Tag2 = isLink.value ? "a" : props.tag;
          const hasTitle = !!(slots.title || props.title != null);
          const hasSubtitle = !!(slots.subtitle || props.subtitle != null);
          const hasHeader = hasTitle || hasSubtitle;
          const hasAppend = !!(slots.append || props.appendAvatar || props.appendIcon);
          const hasPrepend = !!(slots.prepend || props.prependAvatar || props.prependIcon);
          const hasImage = !!(slots.image || props.image);
          const hasCardItem = hasHeader || hasPrepend || hasAppend;
          const hasText = !!(slots.text || props.text != null);
          return withDirectives(createVNode(Tag2, {
            "class": ["v-card", {
              "v-card--disabled": props.disabled,
              "v-card--flat": props.flat,
              "v-card--hover": props.hover && !(props.disabled || props.flat),
              "v-card--link": isClickable.value
            }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, loaderClasses.value, positionClasses.value, roundedClasses.value, variantClasses.value, props.class],
            "style": [colorStyles.value, dimensionStyles.value, locationStyles.value, props.style],
            "href": link2.href.value,
            "onClick": isClickable.value && link2.navigate,
            "tabindex": props.disabled ? -1 : void 0
          }, {
            default: () => {
              var _a2;
              return [hasImage && createVNode("div", {
                "key": "image",
                "class": "v-card__image"
              }, [!slots.image ? createVNode(VImg, {
                "key": "image-img",
                "cover": true,
                "src": props.image
              }, null) : createVNode(VDefaultsProvider, {
                "key": "image-defaults",
                "disabled": !props.image,
                "defaults": {
                  VImg: {
                    cover: true,
                    src: props.image
                  }
                }
              }, slots.image)]), createVNode(LoaderSlot, {
                "name": "v-card",
                "active": !!props.loading,
                "color": typeof props.loading === "boolean" ? void 0 : props.loading
              }, {
                default: slots.loader
              }), hasCardItem && createVNode(VCardItem, {
                "key": "item",
                "prependAvatar": props.prependAvatar,
                "prependIcon": props.prependIcon,
                "title": props.title,
                "subtitle": props.subtitle,
                "appendAvatar": props.appendAvatar,
                "appendIcon": props.appendIcon
              }, {
                default: slots.item,
                prepend: slots.prepend,
                title: slots.title,
                subtitle: slots.subtitle,
                append: slots.append
              }), hasText && createVNode(VCardText, {
                "key": "text"
              }, {
                default: () => {
                  var _a3;
                  return [((_a3 = slots.text) == null ? void 0 : _a3.call(slots)) ?? props.text];
                }
              }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots), slots.actions && createVNode(VCardActions, null, {
                default: slots.actions
              }), genOverlays(isClickable.value, "v-card")];
            }
          }), [[resolveDirective("ripple"), isClickable.value && props.ripple]]);
        });
        return {};
      }
    });
    const makeVContainerProps = propsFactory({
      fluid: {
        type: Boolean,
        default: false
      },
      ...makeComponentProps(),
      ...makeTagProps()
    }, "VContainer");
    const VContainer = genericComponent()({
      name: "VContainer",
      props: makeVContainerProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          rtlClasses
        } = useRtl();
        useRender(() => createVNode(props.tag, {
          "class": ["v-container", {
            "v-container--fluid": props.fluid
          }, rtlClasses.value, props.class],
          "style": props.style
        }, slots));
        return {};
      }
    });
    const breakpoints = ["sm", "md", "lg", "xl", "xxl"];
    const DisplaySymbol = Symbol.for("vuetify:display");
    const defaultDisplayOptions = {
      mobileBreakpoint: "lg",
      thresholds: {
        xs: 0,
        sm: 600,
        md: 960,
        lg: 1280,
        xl: 1920,
        xxl: 2560
      }
    };
    const parseDisplayOptions = function() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultDisplayOptions;
      return mergeDeep(defaultDisplayOptions, options);
    };
    function getClientWidth(ssr) {
      return IN_BROWSER && !ssr ? window.innerWidth : typeof ssr === "object" && ssr.clientWidth || 0;
    }
    function getClientHeight(ssr) {
      return IN_BROWSER && !ssr ? window.innerHeight : typeof ssr === "object" && ssr.clientHeight || 0;
    }
    function getPlatform(ssr) {
      const userAgent = IN_BROWSER && !ssr ? window.navigator.userAgent : "ssr";
      function match(regexp) {
        return Boolean(userAgent.match(regexp));
      }
      const android = match(/android/i);
      const ios = match(/iphone|ipad|ipod/i);
      const cordova = match(/cordova/i);
      const electron = match(/electron/i);
      const chrome = match(/chrome/i);
      const edge = match(/edge/i);
      const firefox = match(/firefox/i);
      const opera = match(/opera/i);
      const win = match(/win/i);
      const mac = match(/mac/i);
      const linux = match(/linux/i);
      return {
        android,
        ios,
        cordova,
        electron,
        chrome,
        edge,
        firefox,
        opera,
        win,
        mac,
        linux,
        touch: SUPPORTS_TOUCH,
        ssr: userAgent === "ssr"
      };
    }
    function createDisplay(options, ssr) {
      const {
        thresholds: thresholds2,
        mobileBreakpoint
      } = parseDisplayOptions(options);
      const height = shallowRef(getClientHeight(ssr));
      const platform = shallowRef(getPlatform(ssr));
      const state = reactive({});
      const width = shallowRef(getClientWidth(ssr));
      function updateSize() {
        height.value = getClientHeight();
        width.value = getClientWidth();
      }
      function update() {
        updateSize();
        platform.value = getPlatform();
      }
      watchEffect(() => {
        const xs = width.value < thresholds2.sm;
        const sm = width.value < thresholds2.md && !xs;
        const md = width.value < thresholds2.lg && !(sm || xs);
        const lg2 = width.value < thresholds2.xl && !(md || sm || xs);
        const xl = width.value < thresholds2.xxl && !(lg2 || md || sm || xs);
        const xxl = width.value >= thresholds2.xxl;
        const name = xs ? "xs" : sm ? "sm" : md ? "md" : lg2 ? "lg" : xl ? "xl" : "xxl";
        const breakpointValue = typeof mobileBreakpoint === "number" ? mobileBreakpoint : thresholds2[mobileBreakpoint];
        const mobile = width.value < breakpointValue;
        state.xs = xs;
        state.sm = sm;
        state.md = md;
        state.lg = lg2;
        state.xl = xl;
        state.xxl = xxl;
        state.smAndUp = !xs;
        state.mdAndUp = !(xs || sm);
        state.lgAndUp = !(xs || sm || md);
        state.xlAndUp = !(xs || sm || md || lg2);
        state.smAndDown = !(md || lg2 || xl || xxl);
        state.mdAndDown = !(lg2 || xl || xxl);
        state.lgAndDown = !(xl || xxl);
        state.xlAndDown = !xxl;
        state.name = name;
        state.height = height.value;
        state.width = width.value;
        state.mobile = mobile;
        state.mobileBreakpoint = mobileBreakpoint;
        state.platform = platform.value;
        state.thresholds = thresholds2;
      });
      if (IN_BROWSER) {
        window.addEventListener("resize", updateSize, {
          passive: true
        });
      }
      return {
        ...toRefs(state),
        update,
        ssr: !!ssr
      };
    }
    const makeDisplayProps = propsFactory({
      mobileBreakpoint: [Number, String]
    }, "display");
    function useDisplay() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
      const display = inject$1(DisplaySymbol);
      if (!display)
        throw new Error("Could not find Vuetify display injection");
      const mobile = computed(() => {
        if (!props.mobileBreakpoint)
          return display.mobile.value;
        const breakpointValue = typeof props.mobileBreakpoint === "number" ? props.mobileBreakpoint : display.thresholds.value[props.mobileBreakpoint];
        return display.width.value < breakpointValue;
      });
      const displayClasses = computed(() => {
        if (!name)
          return {};
        return {
          [`${name}--mobile`]: mobile.value
        };
      });
      return {
        ...display,
        displayClasses,
        mobile
      };
    }
    const breakpointProps = (() => {
      return breakpoints.reduce((props, val) => {
        props[val] = {
          type: [Boolean, String, Number],
          default: false
        };
        return props;
      }, {});
    })();
    const offsetProps = (() => {
      return breakpoints.reduce((props, val) => {
        const offsetKey = "offset" + capitalize(val);
        props[offsetKey] = {
          type: [String, Number],
          default: null
        };
        return props;
      }, {});
    })();
    const orderProps = (() => {
      return breakpoints.reduce((props, val) => {
        const orderKey = "order" + capitalize(val);
        props[orderKey] = {
          type: [String, Number],
          default: null
        };
        return props;
      }, {});
    })();
    const propMap$1 = {
      col: Object.keys(breakpointProps),
      offset: Object.keys(offsetProps),
      order: Object.keys(orderProps)
    };
    function breakpointClass$1(type2, prop2, val) {
      let className = type2;
      if (val == null || val === false) {
        return void 0;
      }
      if (prop2) {
        const breakpoint = prop2.replace(type2, "");
        className += `-${breakpoint}`;
      }
      if (type2 === "col") {
        className = "v-" + className;
      }
      if (type2 === "col" && (val === "" || val === true)) {
        return className.toLowerCase();
      }
      className += `-${val}`;
      return className.toLowerCase();
    }
    const ALIGN_SELF_VALUES = ["auto", "start", "end", "center", "baseline", "stretch"];
    const makeVColProps = propsFactory({
      cols: {
        type: [Boolean, String, Number],
        default: false
      },
      ...breakpointProps,
      offset: {
        type: [String, Number],
        default: null
      },
      ...offsetProps,
      order: {
        type: [String, Number],
        default: null
      },
      ...orderProps,
      alignSelf: {
        type: String,
        default: null,
        validator: (str) => ALIGN_SELF_VALUES.includes(str)
      },
      ...makeComponentProps(),
      ...makeTagProps()
    }, "VCol");
    const VCol = genericComponent()({
      name: "VCol",
      props: makeVColProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const classes = computed(() => {
          const classList = [];
          let type2;
          for (type2 in propMap$1) {
            propMap$1[type2].forEach((prop2) => {
              const value = props[prop2];
              const className = breakpointClass$1(type2, prop2, value);
              if (className)
                classList.push(className);
            });
          }
          const hasColClasses = classList.some((className) => className.startsWith("v-col-"));
          classList.push({
            // Default to .v-col if no other col-{bp}-* classes generated nor `cols` specified.
            "v-col": !hasColClasses || !props.cols,
            [`v-col-${props.cols}`]: props.cols,
            [`offset-${props.offset}`]: props.offset,
            [`order-${props.order}`]: props.order,
            [`align-self-${props.alignSelf}`]: props.alignSelf
          });
          return classList;
        });
        return () => {
          var _a2;
          return h(props.tag, {
            class: [classes.value, props.class],
            style: props.style
          }, (_a2 = slots.default) == null ? void 0 : _a2.call(slots));
        };
      }
    });
    const ALIGNMENT = ["start", "end", "center"];
    const SPACE$2 = ["space-between", "space-around", "space-evenly"];
    function makeRowProps(prefix, def2) {
      return breakpoints.reduce((props, val) => {
        const prefixKey = prefix + capitalize(val);
        props[prefixKey] = def2();
        return props;
      }, {});
    }
    const ALIGN_VALUES = [...ALIGNMENT, "baseline", "stretch"];
    const alignValidator = (str) => ALIGN_VALUES.includes(str);
    const alignProps = makeRowProps("align", () => ({
      type: String,
      default: null,
      validator: alignValidator
    }));
    const JUSTIFY_VALUES = [...ALIGNMENT, ...SPACE$2];
    const justifyValidator = (str) => JUSTIFY_VALUES.includes(str);
    const justifyProps = makeRowProps("justify", () => ({
      type: String,
      default: null,
      validator: justifyValidator
    }));
    const ALIGN_CONTENT_VALUES = [...ALIGNMENT, ...SPACE$2, "stretch"];
    const alignContentValidator = (str) => ALIGN_CONTENT_VALUES.includes(str);
    const alignContentProps = makeRowProps("alignContent", () => ({
      type: String,
      default: null,
      validator: alignContentValidator
    }));
    const propMap = {
      align: Object.keys(alignProps),
      justify: Object.keys(justifyProps),
      alignContent: Object.keys(alignContentProps)
    };
    const classMap = {
      align: "align",
      justify: "justify",
      alignContent: "align-content"
    };
    function breakpointClass(type2, prop2, val) {
      let className = classMap[type2];
      if (val == null) {
        return void 0;
      }
      if (prop2) {
        const breakpoint = prop2.replace(type2, "");
        className += `-${breakpoint}`;
      }
      className += `-${val}`;
      return className.toLowerCase();
    }
    const makeVRowProps = propsFactory({
      dense: Boolean,
      noGutters: Boolean,
      align: {
        type: String,
        default: null,
        validator: alignValidator
      },
      ...alignProps,
      justify: {
        type: String,
        default: null,
        validator: justifyValidator
      },
      ...justifyProps,
      alignContent: {
        type: String,
        default: null,
        validator: alignContentValidator
      },
      ...alignContentProps,
      ...makeComponentProps(),
      ...makeTagProps()
    }, "VRow");
    const VRow = genericComponent()({
      name: "VRow",
      props: makeVRowProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const classes = computed(() => {
          const classList = [];
          let type2;
          for (type2 in propMap) {
            propMap[type2].forEach((prop2) => {
              const value = props[prop2];
              const className = breakpointClass(type2, prop2, value);
              if (className)
                classList.push(className);
            });
          }
          classList.push({
            "v-row--no-gutters": props.noGutters,
            "v-row--dense": props.dense,
            [`align-${props.align}`]: props.align,
            [`justify-${props.justify}`]: props.justify,
            [`align-content-${props.alignContent}`]: props.alignContent
          });
          return classList;
        });
        return () => {
          var _a2;
          return h(props.tag, {
            class: ["v-row", classes.value, props.class],
            style: props.style
          }, (_a2 = slots.default) == null ? void 0 : _a2.call(slots));
        };
      }
    });
    const VSpacer = createSimpleFunctional("v-spacer", "div", "VSpacer");
    const ListKey = Symbol.for("vuetify:list");
    function createList() {
      const parent = inject$1(ListKey, {
        hasPrepend: shallowRef(false),
        updateHasPrepend: () => null
      });
      const data = {
        hasPrepend: shallowRef(false),
        updateHasPrepend: (value) => {
          if (value)
            data.hasPrepend.value = value;
        }
      };
      provide(ListKey, data);
      return parent;
    }
    function useList() {
      return inject$1(ListKey, null);
    }
    const singleOpenStrategy = {
      open: (_ref) => {
        let {
          id: id2,
          value,
          opened,
          parents
        } = _ref;
        if (value) {
          const newOpened = /* @__PURE__ */ new Set();
          newOpened.add(id2);
          let parent = parents.get(id2);
          while (parent != null) {
            newOpened.add(parent);
            parent = parents.get(parent);
          }
          return newOpened;
        } else {
          opened.delete(id2);
          return opened;
        }
      },
      select: () => null
    };
    const multipleOpenStrategy = {
      open: (_ref2) => {
        let {
          id: id2,
          value,
          opened,
          parents
        } = _ref2;
        if (value) {
          let parent = parents.get(id2);
          opened.add(id2);
          while (parent != null && parent !== id2) {
            opened.add(parent);
            parent = parents.get(parent);
          }
          return opened;
        } else {
          opened.delete(id2);
        }
        return opened;
      },
      select: () => null
    };
    const listOpenStrategy = {
      open: multipleOpenStrategy.open,
      select: (_ref3) => {
        let {
          id: id2,
          value,
          opened,
          parents
        } = _ref3;
        if (!value)
          return opened;
        const path = [];
        let parent = parents.get(id2);
        while (parent != null) {
          path.push(parent);
          parent = parents.get(parent);
        }
        return new Set(path);
      }
    };
    const independentSelectStrategy = (mandatory) => {
      const strategy = {
        select: (_ref) => {
          let {
            id: id2,
            value,
            selected
          } = _ref;
          id2 = toRaw(id2);
          if (mandatory && !value) {
            const on = Array.from(selected.entries()).reduce((arr, _ref2) => {
              let [key, value2] = _ref2;
              return value2 === "on" ? [...arr, key] : arr;
            }, []);
            if (on.length === 1 && on[0] === id2)
              return selected;
          }
          selected.set(id2, value ? "on" : "off");
          return selected;
        },
        in: (v, children, parents) => {
          let map2 = /* @__PURE__ */ new Map();
          for (const id2 of v || []) {
            map2 = strategy.select({
              id: id2,
              value: true,
              selected: new Map(map2),
              children,
              parents
            });
          }
          return map2;
        },
        out: (v) => {
          const arr = [];
          for (const [key, value] of v.entries()) {
            if (value === "on")
              arr.push(key);
          }
          return arr;
        }
      };
      return strategy;
    };
    const independentSingleSelectStrategy = (mandatory) => {
      const parentStrategy = independentSelectStrategy(mandatory);
      const strategy = {
        select: (_ref3) => {
          let {
            selected,
            id: id2,
            ...rest
          } = _ref3;
          id2 = toRaw(id2);
          const singleSelected = selected.has(id2) ? /* @__PURE__ */ new Map([[id2, selected.get(id2)]]) : /* @__PURE__ */ new Map();
          return parentStrategy.select({
            ...rest,
            id: id2,
            selected: singleSelected
          });
        },
        in: (v, children, parents) => {
          let map2 = /* @__PURE__ */ new Map();
          if (v == null ? void 0 : v.length) {
            map2 = parentStrategy.in(v.slice(0, 1), children, parents);
          }
          return map2;
        },
        out: (v, children, parents) => {
          return parentStrategy.out(v, children, parents);
        }
      };
      return strategy;
    };
    const leafSelectStrategy = (mandatory) => {
      const parentStrategy = independentSelectStrategy(mandatory);
      const strategy = {
        select: (_ref4) => {
          let {
            id: id2,
            selected,
            children,
            ...rest
          } = _ref4;
          id2 = toRaw(id2);
          if (children.has(id2))
            return selected;
          return parentStrategy.select({
            id: id2,
            selected,
            children,
            ...rest
          });
        },
        in: parentStrategy.in,
        out: parentStrategy.out
      };
      return strategy;
    };
    const leafSingleSelectStrategy = (mandatory) => {
      const parentStrategy = independentSingleSelectStrategy(mandatory);
      const strategy = {
        select: (_ref5) => {
          let {
            id: id2,
            selected,
            children,
            ...rest
          } = _ref5;
          id2 = toRaw(id2);
          if (children.has(id2))
            return selected;
          return parentStrategy.select({
            id: id2,
            selected,
            children,
            ...rest
          });
        },
        in: parentStrategy.in,
        out: parentStrategy.out
      };
      return strategy;
    };
    const classicSelectStrategy = (mandatory) => {
      const strategy = {
        select: (_ref6) => {
          let {
            id: id2,
            value,
            selected,
            children,
            parents
          } = _ref6;
          id2 = toRaw(id2);
          const original = new Map(selected);
          const items2 = [id2];
          while (items2.length) {
            const item = items2.shift();
            selected.set(item, value ? "on" : "off");
            if (children.has(item)) {
              items2.push(...children.get(item));
            }
          }
          let parent = parents.get(id2);
          while (parent) {
            const childrenIds = children.get(parent);
            const everySelected = childrenIds.every((cid) => selected.get(cid) === "on");
            const noneSelected = childrenIds.every((cid) => !selected.has(cid) || selected.get(cid) === "off");
            selected.set(parent, everySelected ? "on" : noneSelected ? "off" : "indeterminate");
            parent = parents.get(parent);
          }
          if (mandatory && !value) {
            const on = Array.from(selected.entries()).reduce((arr, _ref7) => {
              let [key, value2] = _ref7;
              return value2 === "on" ? [...arr, key] : arr;
            }, []);
            if (on.length === 0)
              return original;
          }
          return selected;
        },
        in: (v, children, parents) => {
          let map2 = /* @__PURE__ */ new Map();
          for (const id2 of v || []) {
            map2 = strategy.select({
              id: id2,
              value: true,
              selected: new Map(map2),
              children,
              parents
            });
          }
          return map2;
        },
        out: (v, children) => {
          const arr = [];
          for (const [key, value] of v.entries()) {
            if (value === "on" && !children.has(key))
              arr.push(key);
          }
          return arr;
        }
      };
      return strategy;
    };
    const VNestedSymbol = Symbol.for("vuetify:nested");
    const emptyNested = {
      id: shallowRef(),
      root: {
        register: () => null,
        unregister: () => null,
        parents: ref$1(/* @__PURE__ */ new Map()),
        children: ref$1(/* @__PURE__ */ new Map()),
        open: () => null,
        openOnSelect: () => null,
        select: () => null,
        opened: ref$1(/* @__PURE__ */ new Set()),
        selected: ref$1(/* @__PURE__ */ new Map()),
        selectedValues: ref$1([])
      }
    };
    const makeNestedProps = propsFactory({
      selectStrategy: [String, Function],
      openStrategy: [String, Object],
      opened: Array,
      selected: Array,
      mandatory: Boolean
    }, "nested");
    const useNested = (props) => {
      let isUnmounted = false;
      const children = ref$1(/* @__PURE__ */ new Map());
      const parents = ref$1(/* @__PURE__ */ new Map());
      const opened = useProxiedModel(props, "opened", props.opened, (v) => new Set(v), (v) => [...v.values()]);
      const selectStrategy = computed(() => {
        if (typeof props.selectStrategy === "object")
          return props.selectStrategy;
        switch (props.selectStrategy) {
          case "single-leaf":
            return leafSingleSelectStrategy(props.mandatory);
          case "leaf":
            return leafSelectStrategy(props.mandatory);
          case "independent":
            return independentSelectStrategy(props.mandatory);
          case "single-independent":
            return independentSingleSelectStrategy(props.mandatory);
          case "classic":
          default:
            return classicSelectStrategy(props.mandatory);
        }
      });
      const openStrategy = computed(() => {
        if (typeof props.openStrategy === "object")
          return props.openStrategy;
        switch (props.openStrategy) {
          case "list":
            return listOpenStrategy;
          case "single":
            return singleOpenStrategy;
          case "multiple":
          default:
            return multipleOpenStrategy;
        }
      });
      const selected = useProxiedModel(props, "selected", props.selected, (v) => selectStrategy.value.in(v, children.value, parents.value), (v) => selectStrategy.value.out(v, children.value, parents.value));
      onBeforeUnmount(() => {
        isUnmounted = true;
      });
      function getPath(id2) {
        const path = [];
        let parent = id2;
        while (parent != null) {
          path.unshift(parent);
          parent = parents.value.get(parent);
        }
        return path;
      }
      const vm = getCurrentInstance("nested");
      const nested = {
        id: shallowRef(),
        root: {
          opened,
          selected,
          selectedValues: computed(() => {
            const arr = [];
            for (const [key, value] of selected.value.entries()) {
              if (value === "on")
                arr.push(key);
            }
            return arr;
          }),
          register: (id2, parentId, isGroup) => {
            parentId && id2 !== parentId && parents.value.set(id2, parentId);
            isGroup && children.value.set(id2, []);
            if (parentId != null) {
              children.value.set(parentId, [...children.value.get(parentId) || [], id2]);
            }
          },
          unregister: (id2) => {
            if (isUnmounted)
              return;
            children.value.delete(id2);
            const parent = parents.value.get(id2);
            if (parent) {
              const list2 = children.value.get(parent) ?? [];
              children.value.set(parent, list2.filter((child) => child !== id2));
            }
            parents.value.delete(id2);
            opened.value.delete(id2);
          },
          open: (id2, value, event) => {
            vm.emit("click:open", {
              id: id2,
              value,
              path: getPath(id2),
              event
            });
            const newOpened = openStrategy.value.open({
              id: id2,
              value,
              opened: new Set(opened.value),
              children: children.value,
              parents: parents.value,
              event
            });
            newOpened && (opened.value = newOpened);
          },
          openOnSelect: (id2, value, event) => {
            const newOpened = openStrategy.value.select({
              id: id2,
              value,
              selected: new Map(selected.value),
              opened: new Set(opened.value),
              children: children.value,
              parents: parents.value,
              event
            });
            newOpened && (opened.value = newOpened);
          },
          select: (id2, value, event) => {
            vm.emit("click:select", {
              id: id2,
              value,
              path: getPath(id2),
              event
            });
            const newSelected = selectStrategy.value.select({
              id: id2,
              value,
              selected: new Map(selected.value),
              children: children.value,
              parents: parents.value,
              event
            });
            newSelected && (selected.value = newSelected);
            nested.root.openOnSelect(id2, value, event);
          },
          children,
          parents
        }
      };
      provide(VNestedSymbol, nested);
      return nested.root;
    };
    const useNestedItem = (id2, isGroup) => {
      const parent = inject$1(VNestedSymbol, emptyNested);
      const uidSymbol = Symbol(getUid());
      const computedId = computed(() => id2.value !== void 0 ? id2.value : uidSymbol);
      const item = {
        ...parent,
        id: computedId,
        open: (open, e) => parent.root.open(computedId.value, open, e),
        openOnSelect: (open, e) => parent.root.openOnSelect(computedId.value, open, e),
        isOpen: computed(() => parent.root.opened.value.has(computedId.value)),
        parent: computed(() => parent.root.parents.value.get(computedId.value)),
        select: (selected, e) => parent.root.select(computedId.value, selected, e),
        isSelected: computed(() => parent.root.selected.value.get(toRaw(computedId.value)) === "on"),
        isIndeterminate: computed(() => parent.root.selected.value.get(computedId.value) === "indeterminate"),
        isLeaf: computed(() => !parent.root.children.value.get(computedId.value)),
        isGroupActivator: parent.isGroupActivator
      };
      !parent.isGroupActivator && parent.root.register(computedId.value, parent.id.value, isGroup);
      onBeforeUnmount(() => {
        !parent.isGroupActivator && parent.root.unregister(computedId.value);
      });
      isGroup && provide(VNestedSymbol, item);
      return item;
    };
    const useNestedGroupActivator = () => {
      const parent = inject$1(VNestedSymbol, emptyNested);
      provide(VNestedSymbol, {
        ...parent,
        isGroupActivator: true
      });
    };
    const VListGroupActivator = defineComponent({
      name: "VListGroupActivator",
      setup(_, _ref) {
        let {
          slots
        } = _ref;
        useNestedGroupActivator();
        return () => {
          var _a2;
          return (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
        };
      }
    });
    const makeVListGroupProps = propsFactory({
      /* @deprecated */
      activeColor: String,
      baseColor: String,
      color: String,
      collapseIcon: {
        type: IconValue,
        default: "$collapse"
      },
      expandIcon: {
        type: IconValue,
        default: "$expand"
      },
      prependIcon: IconValue,
      appendIcon: IconValue,
      fluid: Boolean,
      subgroup: Boolean,
      title: String,
      value: null,
      ...makeComponentProps(),
      ...makeTagProps()
    }, "VListGroup");
    const VListGroup = genericComponent()({
      name: "VListGroup",
      props: makeVListGroupProps(),
      setup(props, _ref2) {
        let {
          slots
        } = _ref2;
        const {
          isOpen,
          open,
          id: _id
        } = useNestedItem(toRef(props, "value"), true);
        const id2 = computed(() => `v-list-group--id-${String(_id.value)}`);
        const list2 = useList();
        const {
          isBooted
        } = useSsrBoot();
        function onClick(e) {
          open(!isOpen.value, e);
        }
        const activatorProps = computed(() => ({
          onClick,
          class: "v-list-group__header",
          id: id2.value
        }));
        const toggleIcon = computed(() => isOpen.value ? props.collapseIcon : props.expandIcon);
        const activatorDefaults = computed(() => ({
          VListItem: {
            active: isOpen.value,
            activeColor: props.activeColor,
            baseColor: props.baseColor,
            color: props.color,
            prependIcon: props.prependIcon || props.subgroup && toggleIcon.value,
            appendIcon: props.appendIcon || !props.subgroup && toggleIcon.value,
            title: props.title,
            value: props.value
          }
        }));
        useRender(() => createVNode(props.tag, {
          "class": ["v-list-group", {
            "v-list-group--prepend": list2 == null ? void 0 : list2.hasPrepend.value,
            "v-list-group--fluid": props.fluid,
            "v-list-group--subgroup": props.subgroup,
            "v-list-group--open": isOpen.value
          }, props.class],
          "style": props.style
        }, {
          default: () => [slots.activator && createVNode(VDefaultsProvider, {
            "defaults": activatorDefaults.value
          }, {
            default: () => [createVNode(VListGroupActivator, null, {
              default: () => [slots.activator({
                props: activatorProps.value,
                isOpen: isOpen.value
              })]
            })]
          }), createVNode(MaybeTransition, {
            "transition": {
              component: VExpandTransition
            },
            "disabled": !isBooted.value
          }, {
            default: () => {
              var _a2;
              return [withDirectives(createVNode("div", {
                "class": "v-list-group__items",
                "role": "group",
                "aria-labelledby": id2.value
              }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), [[vShow, isOpen.value]])];
            }
          })]
        }));
        return {};
      }
    });
    const VListItemSubtitle = createSimpleFunctional("v-list-item-subtitle");
    const VListItemTitle = createSimpleFunctional("v-list-item-title");
    const makeVListItemProps = propsFactory({
      active: {
        type: Boolean,
        default: void 0
      },
      activeClass: String,
      /* @deprecated */
      activeColor: String,
      appendAvatar: String,
      appendIcon: IconValue,
      baseColor: String,
      disabled: Boolean,
      lines: String,
      link: {
        type: Boolean,
        default: void 0
      },
      nav: Boolean,
      prependAvatar: String,
      prependIcon: IconValue,
      ripple: {
        type: [Boolean, Object],
        default: true
      },
      slim: Boolean,
      subtitle: [String, Number],
      title: [String, Number],
      value: null,
      onClick: EventProp(),
      onClickOnce: EventProp(),
      ...makeBorderProps(),
      ...makeComponentProps(),
      ...makeDensityProps(),
      ...makeDimensionProps(),
      ...makeElevationProps(),
      ...makeRoundedProps(),
      ...makeRouterProps(),
      ...makeTagProps(),
      ...makeThemeProps(),
      ...makeVariantProps({
        variant: "text"
      })
    }, "VListItem");
    const VListItem = genericComponent()({
      name: "VListItem",
      directives: {
        Ripple
      },
      props: makeVListItemProps(),
      emits: {
        click: (e) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          slots,
          emit: emit2
        } = _ref;
        const link2 = useLink(props, attrs);
        const id2 = computed(() => props.value === void 0 ? link2.href.value : props.value);
        const {
          select,
          isSelected,
          isIndeterminate,
          isGroupActivator,
          root,
          parent,
          openOnSelect
        } = useNestedItem(id2, false);
        const list2 = useList();
        const isActive = computed(() => {
          var _a2;
          return props.active !== false && (props.active || ((_a2 = link2.isActive) == null ? void 0 : _a2.value) || isSelected.value);
        });
        const isLink = computed(() => props.link !== false && link2.isLink.value);
        const isClickable = computed(() => !props.disabled && props.link !== false && (props.link || link2.isClickable.value || props.value != null && !!list2));
        const roundedProps = computed(() => props.rounded || props.nav);
        const color = computed(() => props.color ?? props.activeColor);
        const variantProps = computed(() => ({
          color: isActive.value ? color.value ?? props.baseColor : props.baseColor,
          variant: props.variant
        }));
        watch(() => {
          var _a2;
          return (_a2 = link2.isActive) == null ? void 0 : _a2.value;
        }, (val) => {
          if (val && parent.value != null) {
            root.open(parent.value, true);
          }
          if (val) {
            openOnSelect(val);
          }
        }, {
          immediate: true
        });
        const {
          themeClasses
        } = provideTheme(props);
        const {
          borderClasses
        } = useBorder(props);
        const {
          colorClasses,
          colorStyles,
          variantClasses
        } = useVariant(variantProps);
        const {
          densityClasses
        } = useDensity(props);
        const {
          dimensionStyles
        } = useDimension(props);
        const {
          elevationClasses
        } = useElevation(props);
        const {
          roundedClasses
        } = useRounded(roundedProps);
        const lineClasses = computed(() => props.lines ? `v-list-item--${props.lines}-line` : void 0);
        const slotProps = computed(() => ({
          isActive: isActive.value,
          select,
          isSelected: isSelected.value,
          isIndeterminate: isIndeterminate.value
        }));
        function onClick(e) {
          var _a2;
          emit2("click", e);
          if (isGroupActivator || !isClickable.value)
            return;
          (_a2 = link2.navigate) == null ? void 0 : _a2.call(link2, e);
          props.value != null && select(!isSelected.value, e);
        }
        function onKeyDown(e) {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            onClick(e);
          }
        }
        useRender(() => {
          const Tag2 = isLink.value ? "a" : props.tag;
          const hasTitle = slots.title || props.title != null;
          const hasSubtitle = slots.subtitle || props.subtitle != null;
          const hasAppendMedia = !!(props.appendAvatar || props.appendIcon);
          const hasAppend = !!(hasAppendMedia || slots.append);
          const hasPrependMedia = !!(props.prependAvatar || props.prependIcon);
          const hasPrepend = !!(hasPrependMedia || slots.prepend);
          list2 == null ? void 0 : list2.updateHasPrepend(hasPrepend);
          if (props.activeColor) {
            deprecate("active-color", ["color", "base-color"]);
          }
          return withDirectives(createVNode(Tag2, {
            "class": ["v-list-item", {
              "v-list-item--active": isActive.value,
              "v-list-item--disabled": props.disabled,
              "v-list-item--link": isClickable.value,
              "v-list-item--nav": props.nav,
              "v-list-item--prepend": !hasPrepend && (list2 == null ? void 0 : list2.hasPrepend.value),
              "v-list-item--slim": props.slim,
              [`${props.activeClass}`]: props.activeClass && isActive.value
            }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, lineClasses.value, roundedClasses.value, variantClasses.value, props.class],
            "style": [colorStyles.value, dimensionStyles.value, props.style],
            "href": link2.href.value,
            "tabindex": isClickable.value ? list2 ? -2 : 0 : void 0,
            "onClick": onClick,
            "onKeydown": isClickable.value && !isLink.value && onKeyDown
          }, {
            default: () => {
              var _a2;
              return [genOverlays(isClickable.value || isActive.value, "v-list-item"), hasPrepend && createVNode("div", {
                "key": "prepend",
                "class": "v-list-item__prepend"
              }, [!slots.prepend ? createVNode(Fragment, null, [props.prependAvatar && createVNode(VAvatar, {
                "key": "prepend-avatar",
                "density": props.density,
                "image": props.prependAvatar
              }, null), props.prependIcon && createVNode(VIcon, {
                "key": "prepend-icon",
                "density": props.density,
                "icon": props.prependIcon
              }, null)]) : createVNode(VDefaultsProvider, {
                "key": "prepend-defaults",
                "disabled": !hasPrependMedia,
                "defaults": {
                  VAvatar: {
                    density: props.density,
                    image: props.prependAvatar
                  },
                  VIcon: {
                    density: props.density,
                    icon: props.prependIcon
                  },
                  VListItemAction: {
                    start: true
                  }
                }
              }, {
                default: () => {
                  var _a3;
                  return [(_a3 = slots.prepend) == null ? void 0 : _a3.call(slots, slotProps.value)];
                }
              }), createVNode("div", {
                "class": "v-list-item__spacer"
              }, null)]), createVNode("div", {
                "class": "v-list-item__content",
                "data-no-activator": ""
              }, [hasTitle && createVNode(VListItemTitle, {
                "key": "title"
              }, {
                default: () => {
                  var _a3;
                  return [((_a3 = slots.title) == null ? void 0 : _a3.call(slots, {
                    title: props.title
                  })) ?? props.title];
                }
              }), hasSubtitle && createVNode(VListItemSubtitle, {
                "key": "subtitle"
              }, {
                default: () => {
                  var _a3;
                  return [((_a3 = slots.subtitle) == null ? void 0 : _a3.call(slots, {
                    subtitle: props.subtitle
                  })) ?? props.subtitle];
                }
              }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots, slotProps.value)]), hasAppend && createVNode("div", {
                "key": "append",
                "class": "v-list-item__append"
              }, [!slots.append ? createVNode(Fragment, null, [props.appendIcon && createVNode(VIcon, {
                "key": "append-icon",
                "density": props.density,
                "icon": props.appendIcon
              }, null), props.appendAvatar && createVNode(VAvatar, {
                "key": "append-avatar",
                "density": props.density,
                "image": props.appendAvatar
              }, null)]) : createVNode(VDefaultsProvider, {
                "key": "append-defaults",
                "disabled": !hasAppendMedia,
                "defaults": {
                  VAvatar: {
                    density: props.density,
                    image: props.appendAvatar
                  },
                  VIcon: {
                    density: props.density,
                    icon: props.appendIcon
                  },
                  VListItemAction: {
                    end: true
                  }
                }
              }, {
                default: () => {
                  var _a3;
                  return [(_a3 = slots.append) == null ? void 0 : _a3.call(slots, slotProps.value)];
                }
              }), createVNode("div", {
                "class": "v-list-item__spacer"
              }, null)])];
            }
          }), [[resolveDirective("ripple"), isClickable.value && props.ripple]]);
        });
        return {};
      }
    });
    const makeVListSubheaderProps = propsFactory({
      color: String,
      inset: Boolean,
      sticky: Boolean,
      title: String,
      ...makeComponentProps(),
      ...makeTagProps()
    }, "VListSubheader");
    const VListSubheader = genericComponent()({
      name: "VListSubheader",
      props: makeVListSubheaderProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          textColorClasses,
          textColorStyles
        } = useTextColor(toRef(props, "color"));
        useRender(() => {
          const hasText = !!(slots.default || props.title);
          return createVNode(props.tag, {
            "class": ["v-list-subheader", {
              "v-list-subheader--inset": props.inset,
              "v-list-subheader--sticky": props.sticky
            }, textColorClasses.value, props.class],
            "style": [{
              textColorStyles
            }, props.style]
          }, {
            default: () => {
              var _a2;
              return [hasText && createVNode("div", {
                "class": "v-list-subheader__text"
              }, [((_a2 = slots.default) == null ? void 0 : _a2.call(slots)) ?? props.title])];
            }
          });
        });
        return {};
      }
    });
    const makeVDividerProps = propsFactory({
      color: String,
      inset: Boolean,
      length: [Number, String],
      thickness: [Number, String],
      vertical: Boolean,
      ...makeComponentProps(),
      ...makeThemeProps()
    }, "VDivider");
    const VDivider = genericComponent()({
      name: "VDivider",
      props: makeVDividerProps(),
      setup(props, _ref) {
        let {
          attrs
        } = _ref;
        const {
          themeClasses
        } = provideTheme(props);
        const {
          textColorClasses,
          textColorStyles
        } = useTextColor(toRef(props, "color"));
        const dividerStyles = computed(() => {
          const styles = {};
          if (props.length) {
            styles[props.vertical ? "maxHeight" : "maxWidth"] = convertToUnit(props.length);
          }
          if (props.thickness) {
            styles[props.vertical ? "borderRightWidth" : "borderTopWidth"] = convertToUnit(props.thickness);
          }
          return styles;
        });
        useRender(() => createVNode("hr", {
          "class": [{
            "v-divider": true,
            "v-divider--inset": props.inset,
            "v-divider--vertical": props.vertical
          }, themeClasses.value, textColorClasses.value, props.class],
          "style": [dividerStyles.value, textColorStyles.value, props.style],
          "aria-orientation": !attrs.role || attrs.role === "separator" ? props.vertical ? "vertical" : "horizontal" : void 0,
          "role": `${attrs.role || "separator"}`
        }, null));
        return {};
      }
    });
    const makeVListChildrenProps = propsFactory({
      items: Array,
      returnObject: Boolean
    }, "VListChildren");
    const VListChildren = genericComponent()({
      name: "VListChildren",
      props: makeVListChildrenProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        createList();
        return () => {
          var _a2, _b;
          return ((_a2 = slots.default) == null ? void 0 : _a2.call(slots)) ?? ((_b = props.items) == null ? void 0 : _b.map((_ref2) => {
            var _a3, _b2;
            let {
              children,
              props: itemProps,
              type: type2,
              raw: item
            } = _ref2;
            if (type2 === "divider") {
              return ((_a3 = slots.divider) == null ? void 0 : _a3.call(slots, {
                props: itemProps
              })) ?? createVNode(VDivider, itemProps, null);
            }
            if (type2 === "subheader") {
              return ((_b2 = slots.subheader) == null ? void 0 : _b2.call(slots, {
                props: itemProps
              })) ?? createVNode(VListSubheader, itemProps, null);
            }
            const slotsWithItem = {
              subtitle: slots.subtitle ? (slotProps) => {
                var _a4;
                return (_a4 = slots.subtitle) == null ? void 0 : _a4.call(slots, {
                  ...slotProps,
                  item
                });
              } : void 0,
              prepend: slots.prepend ? (slotProps) => {
                var _a4;
                return (_a4 = slots.prepend) == null ? void 0 : _a4.call(slots, {
                  ...slotProps,
                  item
                });
              } : void 0,
              append: slots.append ? (slotProps) => {
                var _a4;
                return (_a4 = slots.append) == null ? void 0 : _a4.call(slots, {
                  ...slotProps,
                  item
                });
              } : void 0,
              title: slots.title ? (slotProps) => {
                var _a4;
                return (_a4 = slots.title) == null ? void 0 : _a4.call(slots, {
                  ...slotProps,
                  item
                });
              } : void 0
            };
            const listGroupProps = VListGroup.filterProps(itemProps);
            return children ? createVNode(VListGroup, mergeProps({
              "value": itemProps == null ? void 0 : itemProps.value
            }, listGroupProps), {
              activator: (_ref3) => {
                let {
                  props: activatorProps
                } = _ref3;
                const listItemProps = {
                  ...itemProps,
                  ...activatorProps,
                  value: props.returnObject ? item : itemProps.value
                };
                return slots.header ? slots.header({
                  props: listItemProps
                }) : createVNode(VListItem, listItemProps, slotsWithItem);
              },
              default: () => createVNode(VListChildren, {
                "items": children
              }, slots)
            }) : slots.item ? slots.item({
              props: itemProps
            }) : createVNode(VListItem, mergeProps(itemProps, {
              "value": props.returnObject ? item : itemProps.value
            }), slotsWithItem);
          }));
        };
      }
    });
    const makeItemsProps = propsFactory({
      items: {
        type: Array,
        default: () => []
      },
      itemTitle: {
        type: [String, Array, Function],
        default: "title"
      },
      itemValue: {
        type: [String, Array, Function],
        default: "value"
      },
      itemChildren: {
        type: [Boolean, String, Array, Function],
        default: "children"
      },
      itemProps: {
        type: [Boolean, String, Array, Function],
        default: "props"
      },
      returnObject: Boolean,
      valueComparator: {
        type: Function,
        default: deepEqual
      }
    }, "list-items");
    function transformItem$1(props, item) {
      const title2 = getPropertyFromItem(item, props.itemTitle, item);
      const value = getPropertyFromItem(item, props.itemValue, title2);
      const children = getPropertyFromItem(item, props.itemChildren);
      const itemProps = props.itemProps === true ? typeof item === "object" && item != null && !Array.isArray(item) ? "children" in item ? omit$1(item, ["children"]) : item : void 0 : getPropertyFromItem(item, props.itemProps);
      const _props = {
        title: title2,
        value,
        ...itemProps
      };
      return {
        title: String(_props.title ?? ""),
        value: _props.value,
        props: _props,
        children: Array.isArray(children) ? transformItems$1(props, children) : void 0,
        raw: item
      };
    }
    function transformItems$1(props, items2) {
      const array = [];
      for (const item of items2) {
        array.push(transformItem$1(props, item));
      }
      return array;
    }
    function useItems(props) {
      const items2 = computed(() => transformItems$1(props, props.items));
      const hasNullItem = computed(() => items2.value.some((item) => item.value === null));
      function transformIn(value) {
        if (!hasNullItem.value) {
          value = value.filter((v) => v !== null);
        }
        return value.map((v) => {
          if (props.returnObject && typeof v === "string") {
            return transformItem$1(props, v);
          }
          return items2.value.find((item) => props.valueComparator(v, item.value)) || transformItem$1(props, v);
        });
      }
      function transformOut(value) {
        return props.returnObject ? value.map((_ref) => {
          let {
            raw
          } = _ref;
          return raw;
        }) : value.map((_ref2) => {
          let {
            value: value2
          } = _ref2;
          return value2;
        });
      }
      return {
        items: items2,
        transformIn,
        transformOut
      };
    }
    function isPrimitive(value) {
      return typeof value === "string" || typeof value === "number" || typeof value === "boolean";
    }
    function transformItem(props, item) {
      const type2 = getPropertyFromItem(item, props.itemType, "item");
      const title2 = isPrimitive(item) ? item : getPropertyFromItem(item, props.itemTitle);
      const value = getPropertyFromItem(item, props.itemValue, void 0);
      const children = getPropertyFromItem(item, props.itemChildren);
      const itemProps = props.itemProps === true ? omit$1(item, ["children"]) : getPropertyFromItem(item, props.itemProps);
      const _props = {
        title: title2,
        value,
        ...itemProps
      };
      return {
        type: type2,
        title: _props.title,
        value: _props.value,
        props: _props,
        children: type2 === "item" && children ? transformItems(props, children) : void 0,
        raw: item
      };
    }
    function transformItems(props, items2) {
      const array = [];
      for (const item of items2) {
        array.push(transformItem(props, item));
      }
      return array;
    }
    function useListItems(props) {
      const items2 = computed(() => transformItems(props, props.items));
      return {
        items: items2
      };
    }
    const makeVListProps = propsFactory({
      baseColor: String,
      /* @deprecated */
      activeColor: String,
      activeClass: String,
      bgColor: String,
      disabled: Boolean,
      expandIcon: String,
      collapseIcon: String,
      lines: {
        type: [Boolean, String],
        default: "one"
      },
      slim: Boolean,
      nav: Boolean,
      ...makeNestedProps({
        selectStrategy: "single-leaf",
        openStrategy: "list"
      }),
      ...makeBorderProps(),
      ...makeComponentProps(),
      ...makeDensityProps(),
      ...makeDimensionProps(),
      ...makeElevationProps(),
      itemType: {
        type: String,
        default: "type"
      },
      ...makeItemsProps(),
      ...makeRoundedProps(),
      ...makeTagProps(),
      ...makeThemeProps(),
      ...makeVariantProps({
        variant: "text"
      })
    }, "VList");
    const VList = genericComponent()({
      name: "VList",
      props: makeVListProps(),
      emits: {
        "update:selected": (value) => true,
        "update:opened": (value) => true,
        "click:open": (value) => true,
        "click:select": (value) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          items: items2
        } = useListItems(props);
        const {
          themeClasses
        } = provideTheme(props);
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(toRef(props, "bgColor"));
        const {
          borderClasses
        } = useBorder(props);
        const {
          densityClasses
        } = useDensity(props);
        const {
          dimensionStyles
        } = useDimension(props);
        const {
          elevationClasses
        } = useElevation(props);
        const {
          roundedClasses
        } = useRounded(props);
        const {
          open,
          select
        } = useNested(props);
        const lineClasses = computed(() => props.lines ? `v-list--${props.lines}-line` : void 0);
        const activeColor = toRef(props, "activeColor");
        const baseColor = toRef(props, "baseColor");
        const color = toRef(props, "color");
        createList();
        provideDefaults({
          VListGroup: {
            activeColor,
            baseColor,
            color,
            expandIcon: toRef(props, "expandIcon"),
            collapseIcon: toRef(props, "collapseIcon")
          },
          VListItem: {
            activeClass: toRef(props, "activeClass"),
            activeColor,
            baseColor,
            color,
            density: toRef(props, "density"),
            disabled: toRef(props, "disabled"),
            lines: toRef(props, "lines"),
            nav: toRef(props, "nav"),
            slim: toRef(props, "slim"),
            variant: toRef(props, "variant")
          }
        });
        const isFocused = shallowRef(false);
        const contentRef = ref$1();
        function onFocusin(e) {
          isFocused.value = true;
        }
        function onFocusout(e) {
          isFocused.value = false;
        }
        function onFocus(e) {
          var _a2;
          if (!isFocused.value && !(e.relatedTarget && ((_a2 = contentRef.value) == null ? void 0 : _a2.contains(e.relatedTarget))))
            focus();
        }
        function onKeydown(e) {
          if (!contentRef.value)
            return;
          if (e.key === "ArrowDown") {
            focus("next");
          } else if (e.key === "ArrowUp") {
            focus("prev");
          } else if (e.key === "Home") {
            focus("first");
          } else if (e.key === "End") {
            focus("last");
          } else {
            return;
          }
          e.preventDefault();
        }
        function onMousedown(e) {
          isFocused.value = true;
        }
        function focus(location2) {
          if (contentRef.value) {
            return focusChild(contentRef.value, location2);
          }
        }
        useRender(() => {
          return createVNode(props.tag, {
            "ref": contentRef,
            "class": ["v-list", {
              "v-list--disabled": props.disabled,
              "v-list--nav": props.nav,
              "v-list--slim": props.slim
            }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, lineClasses.value, roundedClasses.value, props.class],
            "style": [backgroundColorStyles.value, dimensionStyles.value, props.style],
            "tabindex": props.disabled || isFocused.value ? -1 : 0,
            "role": "listbox",
            "aria-activedescendant": void 0,
            "onFocusin": onFocusin,
            "onFocusout": onFocusout,
            "onFocus": onFocus,
            "onKeydown": onKeydown,
            "onMousedown": onMousedown
          }, {
            default: () => [createVNode(VListChildren, {
              "items": items2.value,
              "returnObject": props.returnObject
            }, slots)]
          });
        });
        return {
          open,
          select,
          focus
        };
      }
    });
    const makeVListItemActionProps = propsFactory({
      start: Boolean,
      end: Boolean,
      ...makeComponentProps(),
      ...makeTagProps()
    }, "VListItemAction");
    const VListItemAction = genericComponent()({
      name: "VListItemAction",
      props: makeVListItemActionProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        useRender(() => createVNode(props.tag, {
          "class": ["v-list-item-action", {
            "v-list-item-action--start": props.start,
            "v-list-item-action--end": props.end
          }, props.class],
          "style": props.style
        }, slots));
        return {};
      }
    });
    const makeVMainProps = propsFactory({
      scrollable: Boolean,
      ...makeComponentProps(),
      ...makeTagProps({
        tag: "main"
      })
    }, "VMain");
    const VMain = genericComponent()({
      name: "VMain",
      props: makeVMainProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          mainStyles
        } = useLayout();
        const {
          ssrBootStyles
        } = useSsrBoot();
        useRender(() => createVNode(props.tag, {
          "class": ["v-main", {
            "v-main--scrollable": props.scrollable
          }, props.class],
          "style": [mainStyles.value, ssrBootStyles.value, props.style]
        }, {
          default: () => {
            var _a2, _b;
            return [props.scrollable ? createVNode("div", {
              "class": "v-main__scroller"
            }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]) : (_b = slots.default) == null ? void 0 : _b.call(slots)];
          }
        }));
        return {};
      }
    });
    function useSticky(_ref) {
      let {
        rootEl,
        isSticky,
        layoutItemStyles
      } = _ref;
      const isStuck = shallowRef(false);
      const stuckPosition = shallowRef(0);
      const stickyStyles = computed(() => {
        const side = typeof isStuck.value === "boolean" ? "top" : isStuck.value;
        return [isSticky.value ? {
          top: "auto",
          bottom: "auto",
          height: void 0
        } : void 0, isStuck.value ? {
          [side]: convertToUnit(stuckPosition.value)
        } : {
          top: layoutItemStyles.value.top
        }];
      });
      onMounted(() => {
        watch(isSticky, (val) => {
          if (val) {
            window.addEventListener("scroll", onScroll, {
              passive: true
            });
          } else {
            window.removeEventListener("scroll", onScroll);
          }
        }, {
          immediate: true
        });
      });
      onBeforeUnmount(() => {
        window.removeEventListener("scroll", onScroll);
      });
      let lastScrollTop = 0;
      function onScroll() {
        const direction = lastScrollTop > window.scrollY ? "up" : "down";
        const rect2 = rootEl.value.getBoundingClientRect();
        const layoutTop = parseFloat(layoutItemStyles.value.top ?? 0);
        const top2 = window.scrollY - Math.max(0, stuckPosition.value - layoutTop);
        const bottom2 = rect2.height + Math.max(stuckPosition.value, layoutTop) - window.scrollY - window.innerHeight;
        const bodyScroll = parseFloat(getComputedStyle(rootEl.value).getPropertyValue("--v-body-scroll-y")) || 0;
        if (rect2.height < window.innerHeight - layoutTop) {
          isStuck.value = "top";
          stuckPosition.value = layoutTop;
        } else if (direction === "up" && isStuck.value === "bottom" || direction === "down" && isStuck.value === "top") {
          stuckPosition.value = window.scrollY + rect2.top - bodyScroll;
          isStuck.value = true;
        } else if (direction === "down" && bottom2 <= 0) {
          stuckPosition.value = 0;
          isStuck.value = "bottom";
        } else if (direction === "up" && top2 <= 0) {
          if (!bodyScroll) {
            stuckPosition.value = rect2.top + top2;
            isStuck.value = "top";
          } else if (isStuck.value !== "top") {
            stuckPosition.value = -top2 + bodyScroll + layoutTop;
            isStuck.value = "top";
          }
        }
        lastScrollTop = window.scrollY;
      }
      return {
        isStuck,
        stickyStyles
      };
    }
    const HORIZON = 100;
    const HISTORY = 20;
    function kineticEnergyToVelocity(work) {
      const sqrt2 = 1.41421356237;
      return (work < 0 ? -1 : 1) * Math.sqrt(Math.abs(work)) * sqrt2;
    }
    function calculateImpulseVelocity(samples) {
      if (samples.length < 2) {
        return 0;
      }
      if (samples.length === 2) {
        if (samples[1].t === samples[0].t) {
          return 0;
        }
        return (samples[1].d - samples[0].d) / (samples[1].t - samples[0].t);
      }
      let work = 0;
      for (let i2 = samples.length - 1; i2 > 0; i2--) {
        if (samples[i2].t === samples[i2 - 1].t) {
          continue;
        }
        const vprev = kineticEnergyToVelocity(work);
        const vcurr = (samples[i2].d - samples[i2 - 1].d) / (samples[i2].t - samples[i2 - 1].t);
        work += (vcurr - vprev) * Math.abs(vcurr);
        if (i2 === samples.length - 1) {
          work *= 0.5;
        }
      }
      return kineticEnergyToVelocity(work) * 1e3;
    }
    function useVelocity() {
      const touches = {};
      function addMovement(e) {
        Array.from(e.changedTouches).forEach((touch) => {
          const samples = touches[touch.identifier] ?? (touches[touch.identifier] = new CircularBuffer(HISTORY));
          samples.push([e.timeStamp, touch]);
        });
      }
      function endTouch(e) {
        Array.from(e.changedTouches).forEach((touch) => {
          delete touches[touch.identifier];
        });
      }
      function getVelocity(id2) {
        var _a2;
        const samples = (_a2 = touches[id2]) == null ? void 0 : _a2.values().reverse();
        if (!samples) {
          throw new Error(`No samples for touch id ${id2}`);
        }
        const newest = samples[0];
        const x = [];
        const y = [];
        for (const val of samples) {
          if (newest[0] - val[0] > HORIZON)
            break;
          x.push({
            t: val[0],
            d: val[1].clientX
          });
          y.push({
            t: val[0],
            d: val[1].clientY
          });
        }
        return {
          x: calculateImpulseVelocity(x),
          y: calculateImpulseVelocity(y),
          get direction() {
            const {
              x: x2,
              y: y2
            } = this;
            const [absX, absY] = [Math.abs(x2), Math.abs(y2)];
            return absX > absY && x2 >= 0 ? "right" : absX > absY && x2 <= 0 ? "left" : absY > absX && y2 >= 0 ? "down" : absY > absX && y2 <= 0 ? "up" : oops$1();
          }
        };
      }
      return {
        addMovement,
        endTouch,
        getVelocity
      };
    }
    function oops$1() {
      throw new Error();
    }
    function useTouch(_ref) {
      let {
        isActive,
        isTemporary,
        width,
        touchless,
        position
      } = _ref;
      onMounted(() => {
        window.addEventListener("touchstart", onTouchstart, {
          passive: true
        });
        window.addEventListener("touchmove", onTouchmove, {
          passive: false
        });
        window.addEventListener("touchend", onTouchend, {
          passive: true
        });
      });
      onBeforeUnmount(() => {
        window.removeEventListener("touchstart", onTouchstart);
        window.removeEventListener("touchmove", onTouchmove);
        window.removeEventListener("touchend", onTouchend);
      });
      const isHorizontal = computed(() => ["left", "right"].includes(position.value));
      const {
        addMovement,
        endTouch,
        getVelocity
      } = useVelocity();
      let maybeDragging = false;
      const isDragging = shallowRef(false);
      const dragProgress = shallowRef(0);
      const offset = shallowRef(0);
      let start;
      function getOffset2(pos, active) {
        return (position.value === "left" ? pos : position.value === "right" ? document.documentElement.clientWidth - pos : position.value === "top" ? pos : position.value === "bottom" ? document.documentElement.clientHeight - pos : oops()) - (active ? width.value : 0);
      }
      function getProgress(pos) {
        let limit2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        const progress = position.value === "left" ? (pos - offset.value) / width.value : position.value === "right" ? (document.documentElement.clientWidth - pos - offset.value) / width.value : position.value === "top" ? (pos - offset.value) / width.value : position.value === "bottom" ? (document.documentElement.clientHeight - pos - offset.value) / width.value : oops();
        return limit2 ? Math.max(0, Math.min(1, progress)) : progress;
      }
      function onTouchstart(e) {
        if (touchless.value)
          return;
        const touchX = e.changedTouches[0].clientX;
        const touchY = e.changedTouches[0].clientY;
        const touchZone = 25;
        const inTouchZone = position.value === "left" ? touchX < touchZone : position.value === "right" ? touchX > document.documentElement.clientWidth - touchZone : position.value === "top" ? touchY < touchZone : position.value === "bottom" ? touchY > document.documentElement.clientHeight - touchZone : oops();
        const inElement = isActive.value && (position.value === "left" ? touchX < width.value : position.value === "right" ? touchX > document.documentElement.clientWidth - width.value : position.value === "top" ? touchY < width.value : position.value === "bottom" ? touchY > document.documentElement.clientHeight - width.value : oops());
        if (inTouchZone || inElement || isActive.value && isTemporary.value) {
          maybeDragging = true;
          start = [touchX, touchY];
          offset.value = getOffset2(isHorizontal.value ? touchX : touchY, isActive.value);
          dragProgress.value = getProgress(isHorizontal.value ? touchX : touchY);
          endTouch(e);
          addMovement(e);
        }
      }
      function onTouchmove(e) {
        const touchX = e.changedTouches[0].clientX;
        const touchY = e.changedTouches[0].clientY;
        if (maybeDragging) {
          if (!e.cancelable) {
            maybeDragging = false;
            return;
          }
          const dx = Math.abs(touchX - start[0]);
          const dy = Math.abs(touchY - start[1]);
          const thresholdMet = isHorizontal.value ? dx > dy && dx > 3 : dy > dx && dy > 3;
          if (thresholdMet) {
            isDragging.value = true;
            maybeDragging = false;
          } else if ((isHorizontal.value ? dy : dx) > 3) {
            maybeDragging = false;
          }
        }
        if (!isDragging.value)
          return;
        e.preventDefault();
        addMovement(e);
        const progress = getProgress(isHorizontal.value ? touchX : touchY, false);
        dragProgress.value = Math.max(0, Math.min(1, progress));
        if (progress > 1) {
          offset.value = getOffset2(isHorizontal.value ? touchX : touchY, true);
        } else if (progress < 0) {
          offset.value = getOffset2(isHorizontal.value ? touchX : touchY, false);
        }
      }
      function onTouchend(e) {
        maybeDragging = false;
        if (!isDragging.value)
          return;
        addMovement(e);
        isDragging.value = false;
        const velocity = getVelocity(e.changedTouches[0].identifier);
        const vx = Math.abs(velocity.x);
        const vy = Math.abs(velocity.y);
        const thresholdMet = isHorizontal.value ? vx > vy && vx > 400 : vy > vx && vy > 3;
        if (thresholdMet) {
          isActive.value = velocity.direction === ({
            left: "right",
            right: "left",
            top: "down",
            bottom: "up"
          }[position.value] || oops());
        } else {
          isActive.value = dragProgress.value > 0.5;
        }
      }
      const dragStyles = computed(() => {
        return isDragging.value ? {
          transform: position.value === "left" ? `translateX(calc(-100% + ${dragProgress.value * width.value}px))` : position.value === "right" ? `translateX(calc(100% - ${dragProgress.value * width.value}px))` : position.value === "top" ? `translateY(calc(-100% + ${dragProgress.value * width.value}px))` : position.value === "bottom" ? `translateY(calc(100% - ${dragProgress.value * width.value}px))` : oops(),
          transition: "none"
        } : void 0;
      });
      return {
        isDragging,
        dragProgress,
        dragStyles
      };
    }
    function oops() {
      throw new Error();
    }
    const firstDay = {
      "001": 1,
      AD: 1,
      AE: 6,
      AF: 6,
      AG: 0,
      AI: 1,
      AL: 1,
      AM: 1,
      AN: 1,
      AR: 1,
      AS: 0,
      AT: 1,
      AU: 1,
      AX: 1,
      AZ: 1,
      BA: 1,
      BD: 0,
      BE: 1,
      BG: 1,
      BH: 6,
      BM: 1,
      BN: 1,
      BR: 0,
      BS: 0,
      BT: 0,
      BW: 0,
      BY: 1,
      BZ: 0,
      CA: 0,
      CH: 1,
      CL: 1,
      CM: 1,
      CN: 1,
      CO: 0,
      CR: 1,
      CY: 1,
      CZ: 1,
      DE: 1,
      DJ: 6,
      DK: 1,
      DM: 0,
      DO: 0,
      DZ: 6,
      EC: 1,
      EE: 1,
      EG: 6,
      ES: 1,
      ET: 0,
      FI: 1,
      FJ: 1,
      FO: 1,
      FR: 1,
      GB: 1,
      "GB-alt-variant": 0,
      GE: 1,
      GF: 1,
      GP: 1,
      GR: 1,
      GT: 0,
      GU: 0,
      HK: 0,
      HN: 0,
      HR: 1,
      HU: 1,
      ID: 0,
      IE: 1,
      IL: 0,
      IN: 0,
      IQ: 6,
      IR: 6,
      IS: 1,
      IT: 1,
      JM: 0,
      JO: 6,
      JP: 0,
      KE: 0,
      KG: 1,
      KH: 0,
      KR: 0,
      KW: 6,
      KZ: 1,
      LA: 0,
      LB: 1,
      LI: 1,
      LK: 1,
      LT: 1,
      LU: 1,
      LV: 1,
      LY: 6,
      MC: 1,
      MD: 1,
      ME: 1,
      MH: 0,
      MK: 1,
      MM: 0,
      MN: 1,
      MO: 0,
      MQ: 1,
      MT: 0,
      MV: 5,
      MX: 0,
      MY: 1,
      MZ: 0,
      NI: 0,
      NL: 1,
      NO: 1,
      NP: 0,
      NZ: 1,
      OM: 6,
      PA: 0,
      PE: 0,
      PH: 0,
      PK: 0,
      PL: 1,
      PR: 0,
      PT: 0,
      PY: 0,
      QA: 6,
      RE: 1,
      RO: 1,
      RS: 1,
      RU: 1,
      SA: 0,
      SD: 6,
      SE: 1,
      SG: 0,
      SI: 1,
      SK: 1,
      SM: 1,
      SV: 0,
      SY: 6,
      TH: 0,
      TJ: 1,
      TM: 1,
      TR: 1,
      TT: 0,
      TW: 0,
      UA: 1,
      UM: 0,
      US: 0,
      UY: 1,
      UZ: 1,
      VA: 1,
      VE: 0,
      VI: 0,
      VN: 1,
      WS: 0,
      XK: 1,
      YE: 0,
      ZA: 0,
      ZW: 0
    };
    function getWeekArray(date2, locale) {
      const weeks = [];
      let currentWeek = [];
      const firstDayOfMonth = startOfMonth(date2);
      const lastDayOfMonth = endOfMonth(date2);
      const firstDayWeekIndex = (firstDayOfMonth.getDay() - firstDay[locale.slice(-2).toUpperCase()] + 7) % 7;
      const lastDayWeekIndex = (lastDayOfMonth.getDay() - firstDay[locale.slice(-2).toUpperCase()] + 7) % 7;
      for (let i2 = 0; i2 < firstDayWeekIndex; i2++) {
        const adjacentDay = new Date(firstDayOfMonth);
        adjacentDay.setDate(adjacentDay.getDate() - (firstDayWeekIndex - i2));
        currentWeek.push(adjacentDay);
      }
      for (let i2 = 1; i2 <= lastDayOfMonth.getDate(); i2++) {
        const day = new Date(date2.getFullYear(), date2.getMonth(), i2);
        currentWeek.push(day);
        if (currentWeek.length === 7) {
          weeks.push(currentWeek);
          currentWeek = [];
        }
      }
      for (let i2 = 1; i2 < 7 - lastDayWeekIndex; i2++) {
        const adjacentDay = new Date(lastDayOfMonth);
        adjacentDay.setDate(adjacentDay.getDate() + i2);
        currentWeek.push(adjacentDay);
      }
      if (currentWeek.length > 0) {
        weeks.push(currentWeek);
      }
      return weeks;
    }
    function startOfWeek(date2) {
      const d = new Date(date2);
      while (d.getDay() !== 0) {
        d.setDate(d.getDate() - 1);
      }
      return d;
    }
    function endOfWeek(date2) {
      const d = new Date(date2);
      while (d.getDay() !== 6) {
        d.setDate(d.getDate() + 1);
      }
      return d;
    }
    function startOfMonth(date2) {
      return new Date(date2.getFullYear(), date2.getMonth(), 1);
    }
    function endOfMonth(date2) {
      return new Date(date2.getFullYear(), date2.getMonth() + 1, 0);
    }
    function parseLocalDate(value) {
      const parts = value.split("-").map(Number);
      return new Date(parts[0], parts[1] - 1, parts[2]);
    }
    const _YYYMMDD = /^([12]\d{3}-([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[12]\d|3[01]))$/;
    function date(value) {
      if (value == null)
        return /* @__PURE__ */ new Date();
      if (value instanceof Date)
        return value;
      if (typeof value === "string") {
        let parsed;
        if (_YYYMMDD.test(value)) {
          return parseLocalDate(value);
        } else {
          parsed = Date.parse(value);
        }
        if (!isNaN(parsed))
          return new Date(parsed);
      }
      return null;
    }
    const sundayJanuarySecond2000 = new Date(2e3, 0, 2);
    function getWeekdays(locale) {
      const daysFromSunday = firstDay[locale.slice(-2).toUpperCase()];
      return createRange(7).map((i2) => {
        const weekday = new Date(sundayJanuarySecond2000);
        weekday.setDate(sundayJanuarySecond2000.getDate() + daysFromSunday + i2);
        return new Intl.DateTimeFormat(locale, {
          weekday: "narrow"
        }).format(weekday);
      });
    }
    function format$5(value, formatString, locale, formats2) {
      const newDate = date(value) ?? /* @__PURE__ */ new Date();
      const customFormat = formats2 == null ? void 0 : formats2[formatString];
      if (typeof customFormat === "function") {
        return customFormat(newDate, formatString, locale);
      }
      let options = {};
      switch (formatString) {
        case "fullDateWithWeekday":
          options = {
            weekday: "long",
            day: "numeric",
            month: "long",
            year: "numeric"
          };
          break;
        case "hours12h":
          options = {
            hour: "numeric",
            hour12: true
          };
          break;
        case "normalDateWithWeekday":
          options = {
            weekday: "short",
            day: "numeric",
            month: "short"
          };
          break;
        case "keyboardDate":
          options = {
            day: "2-digit",
            month: "2-digit",
            year: "numeric"
          };
          break;
        case "monthAndDate":
          options = {
            month: "long",
            day: "numeric"
          };
          break;
        case "monthAndYear":
          options = {
            month: "long",
            year: "numeric"
          };
          break;
        case "month":
          options = {
            month: "long"
          };
          break;
        case "monthShort":
          options = {
            month: "short"
          };
          break;
        case "dayOfMonth":
          return new Intl.NumberFormat(locale).format(newDate.getDate());
        case "shortDate":
          options = {
            year: "2-digit",
            month: "numeric",
            day: "numeric"
          };
          break;
        case "weekdayShort":
          options = {
            weekday: "short"
          };
          break;
        case "year":
          options = {
            year: "numeric"
          };
          break;
        default:
          options = customFormat ?? {
            timeZone: "UTC",
            timeZoneName: "short"
          };
      }
      return new Intl.DateTimeFormat(locale, options).format(newDate);
    }
    function toISO(adapter, value) {
      const date2 = adapter.toJsDate(value);
      const year = date2.getFullYear();
      const month = padStart(String(date2.getMonth() + 1), 2, "0");
      const day = padStart(String(date2.getDate()), 2, "0");
      return `${year}-${month}-${day}`;
    }
    function parseISO(value) {
      const [year, month, day] = value.split("-").map(Number);
      return new Date(year, month - 1, day);
    }
    function addMinutes(date2, amount) {
      const d = new Date(date2);
      d.setMinutes(d.getMinutes() + amount);
      return d;
    }
    function addHours(date2, amount) {
      const d = new Date(date2);
      d.setHours(d.getHours() + amount);
      return d;
    }
    function addDays(date2, amount) {
      const d = new Date(date2);
      d.setDate(d.getDate() + amount);
      return d;
    }
    function addWeeks(date2, amount) {
      const d = new Date(date2);
      d.setDate(d.getDate() + amount * 7);
      return d;
    }
    function addMonths(date2, amount) {
      const d = new Date(date2);
      d.setMonth(d.getMonth() + amount);
      return d;
    }
    function getYear(date2) {
      return date2.getFullYear();
    }
    function getMonth(date2) {
      return date2.getMonth();
    }
    function getNextMonth(date2) {
      return new Date(date2.getFullYear(), date2.getMonth() + 1, 1);
    }
    function getHours(date2) {
      return date2.getHours();
    }
    function getMinutes(date2) {
      return date2.getMinutes();
    }
    function startOfYear(date2) {
      return new Date(date2.getFullYear(), 0, 1);
    }
    function endOfYear(date2) {
      return new Date(date2.getFullYear(), 11, 31);
    }
    function isWithinRange(date2, range2) {
      return isAfter(date2, range2[0]) && isBefore(date2, range2[1]);
    }
    function isValid(date2) {
      const d = new Date(date2);
      return d instanceof Date && !isNaN(d.getTime());
    }
    function isAfter(date2, comparing) {
      return date2.getTime() > comparing.getTime();
    }
    function isBefore(date2, comparing) {
      return date2.getTime() < comparing.getTime();
    }
    function isEqual$1(date2, comparing) {
      return date2.getTime() === comparing.getTime();
    }
    function isSameDay(date2, comparing) {
      return date2.getDate() === comparing.getDate() && date2.getMonth() === comparing.getMonth() && date2.getFullYear() === comparing.getFullYear();
    }
    function isSameMonth(date2, comparing) {
      return date2.getMonth() === comparing.getMonth() && date2.getFullYear() === comparing.getFullYear();
    }
    function getDiff(date2, comparing, unit) {
      const d = new Date(date2);
      const c = new Date(comparing);
      if (unit === "month") {
        return d.getMonth() - c.getMonth() + (d.getFullYear() - c.getFullYear()) * 12;
      }
      return Math.floor((d.getTime() - c.getTime()) / (1e3 * 60 * 60 * 24));
    }
    function setHours(date2, count) {
      const d = new Date(date2);
      d.setHours(count);
      return d;
    }
    function setMinutes(date2, count) {
      const d = new Date(date2);
      d.setMinutes(count);
      return d;
    }
    function setMonth(date2, count) {
      const d = new Date(date2);
      d.setMonth(count);
      return d;
    }
    function setYear(date2, year) {
      const d = new Date(date2);
      d.setFullYear(year);
      return d;
    }
    function startOfDay(date2) {
      return new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
    }
    function endOfDay(date2) {
      return new Date(date2.getFullYear(), date2.getMonth(), date2.getDate(), 23, 59, 59, 999);
    }
    class VuetifyDateAdapter {
      constructor(options) {
        this.locale = options.locale;
        this.formats = options.formats;
      }
      date(value) {
        return date(value);
      }
      toJsDate(date2) {
        return date2;
      }
      toISO(date2) {
        return toISO(this, date2);
      }
      parseISO(date2) {
        return parseISO(date2);
      }
      addMinutes(date2, amount) {
        return addMinutes(date2, amount);
      }
      addHours(date2, amount) {
        return addHours(date2, amount);
      }
      addDays(date2, amount) {
        return addDays(date2, amount);
      }
      addWeeks(date2, amount) {
        return addWeeks(date2, amount);
      }
      addMonths(date2, amount) {
        return addMonths(date2, amount);
      }
      getWeekArray(date2) {
        return getWeekArray(date2, this.locale);
      }
      startOfWeek(date2) {
        return startOfWeek(date2);
      }
      endOfWeek(date2) {
        return endOfWeek(date2);
      }
      startOfMonth(date2) {
        return startOfMonth(date2);
      }
      endOfMonth(date2) {
        return endOfMonth(date2);
      }
      format(date2, formatString) {
        return format$5(date2, formatString, this.locale, this.formats);
      }
      isEqual(date2, comparing) {
        return isEqual$1(date2, comparing);
      }
      isValid(date2) {
        return isValid(date2);
      }
      isWithinRange(date2, range2) {
        return isWithinRange(date2, range2);
      }
      isAfter(date2, comparing) {
        return isAfter(date2, comparing);
      }
      isBefore(date2, comparing) {
        return !isAfter(date2, comparing) && !isEqual$1(date2, comparing);
      }
      isSameDay(date2, comparing) {
        return isSameDay(date2, comparing);
      }
      isSameMonth(date2, comparing) {
        return isSameMonth(date2, comparing);
      }
      setMinutes(date2, count) {
        return setMinutes(date2, count);
      }
      setHours(date2, count) {
        return setHours(date2, count);
      }
      setMonth(date2, count) {
        return setMonth(date2, count);
      }
      setYear(date2, year) {
        return setYear(date2, year);
      }
      getDiff(date2, comparing, unit) {
        return getDiff(date2, comparing, unit);
      }
      getWeekdays() {
        return getWeekdays(this.locale);
      }
      getYear(date2) {
        return getYear(date2);
      }
      getMonth(date2) {
        return getMonth(date2);
      }
      getNextMonth(date2) {
        return getNextMonth(date2);
      }
      getHours(date2) {
        return getHours(date2);
      }
      getMinutes(date2) {
        return getMinutes(date2);
      }
      startOfDay(date2) {
        return startOfDay(date2);
      }
      endOfDay(date2) {
        return endOfDay(date2);
      }
      startOfYear(date2) {
        return startOfYear(date2);
      }
      endOfYear(date2) {
        return endOfYear(date2);
      }
    }
    const DateOptionsSymbol = Symbol.for("vuetify:date-options");
    const DateAdapterSymbol = Symbol.for("vuetify:date-adapter");
    function createDate(options, locale) {
      const _options = mergeDeep({
        adapter: VuetifyDateAdapter,
        locale: {
          af: "af-ZA",
          // ar: '', # not the same value for all variants
          bg: "bg-BG",
          ca: "ca-ES",
          ckb: "",
          cs: "cs-CZ",
          de: "de-DE",
          el: "el-GR",
          en: "en-US",
          // es: '', # not the same value for all variants
          et: "et-EE",
          fa: "fa-IR",
          fi: "fi-FI",
          // fr: '', #not the same value for all variants
          hr: "hr-HR",
          hu: "hu-HU",
          he: "he-IL",
          id: "id-ID",
          it: "it-IT",
          ja: "ja-JP",
          ko: "ko-KR",
          lv: "lv-LV",
          lt: "lt-LT",
          nl: "nl-NL",
          no: "no-NO",
          pl: "pl-PL",
          pt: "pt-PT",
          ro: "ro-RO",
          ru: "ru-RU",
          sk: "sk-SK",
          sl: "sl-SI",
          srCyrl: "sr-SP",
          srLatn: "sr-SP",
          sv: "sv-SE",
          th: "th-TH",
          tr: "tr-TR",
          az: "az-AZ",
          uk: "uk-UA",
          vi: "vi-VN",
          zhHans: "zh-CN",
          zhHant: "zh-TW"
        }
      }, options);
      return {
        options: _options,
        instance: createInstance(_options, locale)
      };
    }
    function createInstance(options, locale) {
      const instance = reactive(typeof options.adapter === "function" ? new options.adapter({
        locale: options.locale[locale.current.value] ?? locale.current.value,
        formats: options.formats
      }) : options.adapter);
      watch(locale.current, (value) => {
        instance.locale = options.locale[value] ?? value ?? instance.locale;
      });
      return instance;
    }
    function useDate() {
      const options = inject$1(DateOptionsSymbol);
      if (!options)
        throw new Error("[Vuetify] Could not find injected date options");
      const locale = useLocale();
      return createInstance(options, locale);
    }
    function getWeek(adapter, value) {
      const date2 = adapter.toJsDate(value);
      let year = date2.getFullYear();
      let d1w1 = new Date(year, 0, 1);
      if (date2 < d1w1) {
        year = year - 1;
        d1w1 = new Date(year, 0, 1);
      } else {
        const tv = new Date(year + 1, 0, 1);
        if (date2 >= tv) {
          year = year + 1;
          d1w1 = tv;
        }
      }
      const diffTime = Math.abs(date2.getTime() - d1w1.getTime());
      const diffDays = Math.ceil(diffTime / (1e3 * 60 * 60 * 24));
      return Math.floor(diffDays / 7) + 1;
    }
    const GoToSymbol = Symbol.for("vuetify:goto");
    function genDefaults() {
      return {
        container: void 0,
        duration: 300,
        layout: false,
        offset: 0,
        easing: "easeInOutCubic",
        patterns: {
          linear: (t) => t,
          easeInQuad: (t) => t ** 2,
          easeOutQuad: (t) => t * (2 - t),
          easeInOutQuad: (t) => t < 0.5 ? 2 * t ** 2 : -1 + (4 - 2 * t) * t,
          easeInCubic: (t) => t ** 3,
          easeOutCubic: (t) => --t ** 3 + 1,
          easeInOutCubic: (t) => t < 0.5 ? 4 * t ** 3 : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
          easeInQuart: (t) => t ** 4,
          easeOutQuart: (t) => 1 - --t ** 4,
          easeInOutQuart: (t) => t < 0.5 ? 8 * t ** 4 : 1 - 8 * --t ** 4,
          easeInQuint: (t) => t ** 5,
          easeOutQuint: (t) => 1 + --t ** 5,
          easeInOutQuint: (t) => t < 0.5 ? 16 * t ** 5 : 1 + 16 * --t ** 5
        }
      };
    }
    function createGoTo(options, locale) {
      return {
        rtl: locale.isRtl,
        options: mergeDeep(genDefaults(), options)
      };
    }
    function useScopeId() {
      const vm = getCurrentInstance("useScopeId");
      const scopeId = vm.vnode.scopeId;
      return {
        scopeId: scopeId ? {
          [scopeId]: ""
        } : void 0
      };
    }
    const locations = ["start", "end", "left", "right", "top", "bottom"];
    const makeVNavigationDrawerProps = propsFactory({
      color: String,
      disableResizeWatcher: Boolean,
      disableRouteWatcher: Boolean,
      expandOnHover: Boolean,
      floating: Boolean,
      modelValue: {
        type: Boolean,
        default: null
      },
      permanent: Boolean,
      rail: {
        type: Boolean,
        default: null
      },
      railWidth: {
        type: [Number, String],
        default: 56
      },
      scrim: {
        type: [Boolean, String],
        default: true
      },
      image: String,
      temporary: Boolean,
      touchless: Boolean,
      width: {
        type: [Number, String],
        default: 256
      },
      location: {
        type: String,
        default: "start",
        validator: (value) => locations.includes(value)
      },
      sticky: Boolean,
      ...makeBorderProps(),
      ...makeComponentProps(),
      ...makeDisplayProps(),
      ...makeElevationProps(),
      ...makeLayoutItemProps(),
      ...makeRoundedProps(),
      ...makeTagProps({
        tag: "nav"
      }),
      ...makeThemeProps()
    }, "VNavigationDrawer");
    const VNavigationDrawer = genericComponent()({
      name: "VNavigationDrawer",
      props: makeVNavigationDrawerProps(),
      emits: {
        "update:modelValue": (val) => true,
        "update:rail": (val) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          emit: emit2,
          slots
        } = _ref;
        const {
          isRtl
        } = useRtl();
        const {
          themeClasses
        } = provideTheme(props);
        const {
          borderClasses
        } = useBorder(props);
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(toRef(props, "color"));
        const {
          elevationClasses
        } = useElevation(props);
        const {
          displayClasses,
          mobile
        } = useDisplay(props);
        const {
          roundedClasses
        } = useRounded(props);
        const router2 = useRouter();
        const isActive = useProxiedModel(props, "modelValue", null, (v) => !!v);
        const {
          ssrBootStyles
        } = useSsrBoot();
        const {
          scopeId
        } = useScopeId();
        const rootEl = ref$1();
        const isHovering = shallowRef(false);
        const width = computed(() => {
          return props.rail && props.expandOnHover && isHovering.value ? Number(props.width) : Number(props.rail ? props.railWidth : props.width);
        });
        const location2 = computed(() => {
          return toPhysical(props.location, isRtl.value);
        });
        const isTemporary = computed(() => !props.permanent && (mobile.value || props.temporary));
        const isSticky = computed(() => props.sticky && !isTemporary.value && location2.value !== "bottom");
        useToggleScope(() => props.expandOnHover && props.rail != null, () => {
          watch(isHovering, (val) => emit2("update:rail", !val));
        });
        useToggleScope(() => !props.disableResizeWatcher, () => {
          watch(isTemporary, (val) => !props.permanent && nextTick(() => isActive.value = !val));
        });
        useToggleScope(() => !props.disableRouteWatcher && !!router2, () => {
          watch(router2.currentRoute, () => isTemporary.value && (isActive.value = false));
        });
        watch(() => props.permanent, (val) => {
          if (val)
            isActive.value = true;
        });
        onBeforeMount(() => {
          if (props.modelValue != null || isTemporary.value)
            return;
          isActive.value = props.permanent || !mobile.value;
        });
        const {
          isDragging,
          dragProgress,
          dragStyles
        } = useTouch({
          isActive,
          isTemporary,
          width,
          touchless: toRef(props, "touchless"),
          position: location2
        });
        const layoutSize = computed(() => {
          const size2 = isTemporary.value ? 0 : props.rail && props.expandOnHover ? Number(props.railWidth) : width.value;
          return isDragging.value ? size2 * dragProgress.value : size2;
        });
        const {
          layoutItemStyles,
          layoutItemScrimStyles
        } = useLayoutItem({
          id: props.name,
          order: computed(() => parseInt(props.order, 10)),
          position: location2,
          layoutSize,
          elementSize: width,
          active: computed(() => isActive.value || isDragging.value),
          disableTransitions: computed(() => isDragging.value),
          absolute: computed(() => (
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            props.absolute || isSticky.value && typeof isStuck.value !== "string"
          ))
        });
        const {
          isStuck,
          stickyStyles
        } = useSticky({
          rootEl,
          isSticky,
          layoutItemStyles
        });
        const scrimColor = useBackgroundColor(computed(() => {
          return typeof props.scrim === "string" ? props.scrim : null;
        }));
        const scrimStyles = computed(() => ({
          ...isDragging.value ? {
            opacity: dragProgress.value * 0.2,
            transition: "none"
          } : void 0,
          ...layoutItemScrimStyles.value
        }));
        provideDefaults({
          VList: {
            bgColor: "transparent"
          }
        });
        function onMouseenter() {
          isHovering.value = true;
        }
        function onMouseleave() {
          isHovering.value = false;
        }
        useRender(() => {
          const hasImage = slots.image || props.image;
          return createVNode(Fragment, null, [createVNode(props.tag, mergeProps({
            "ref": rootEl,
            "onMouseenter": onMouseenter,
            "onMouseleave": onMouseleave,
            "class": ["v-navigation-drawer", `v-navigation-drawer--${location2.value}`, {
              "v-navigation-drawer--expand-on-hover": props.expandOnHover,
              "v-navigation-drawer--floating": props.floating,
              "v-navigation-drawer--is-hovering": isHovering.value,
              "v-navigation-drawer--rail": props.rail,
              "v-navigation-drawer--temporary": isTemporary.value,
              "v-navigation-drawer--active": isActive.value,
              "v-navigation-drawer--sticky": isSticky.value
            }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, displayClasses.value, elevationClasses.value, roundedClasses.value, props.class],
            "style": [backgroundColorStyles.value, layoutItemStyles.value, dragStyles.value, ssrBootStyles.value, stickyStyles.value, props.style]
          }, scopeId, attrs), {
            default: () => {
              var _a2, _b, _c, _d;
              return [hasImage && createVNode("div", {
                "key": "image",
                "class": "v-navigation-drawer__img"
              }, [slots.image ? (_a2 = slots.image) == null ? void 0 : _a2.call(slots, {
                image: props.image
              }) : createVNode("img", {
                "src": props.image,
                "alt": ""
              }, null)]), slots.prepend && createVNode("div", {
                "class": "v-navigation-drawer__prepend"
              }, [(_b = slots.prepend) == null ? void 0 : _b.call(slots)]), createVNode("div", {
                "class": "v-navigation-drawer__content"
              }, [(_c = slots.default) == null ? void 0 : _c.call(slots)]), slots.append && createVNode("div", {
                "class": "v-navigation-drawer__append"
              }, [(_d = slots.append) == null ? void 0 : _d.call(slots)])];
            }
          }), createVNode(Transition, {
            "name": "fade-transition"
          }, {
            default: () => [isTemporary.value && (isDragging.value || isActive.value) && !!props.scrim && createVNode("div", mergeProps({
              "class": ["v-navigation-drawer__scrim", scrimColor.backgroundColorClasses.value],
              "style": [scrimStyles.value, scrimColor.backgroundColorStyles.value],
              "onClick": () => isActive.value = false
            }, scopeId), null)]
          })]);
        });
        return {
          isStuck
        };
      }
    });
    function elementToViewport(point, offset) {
      return {
        x: point.x + offset.x,
        y: point.y + offset.y
      };
    }
    function getOffset$1(a, b) {
      return {
        x: a.x - b.x,
        y: a.y - b.y
      };
    }
    function anchorToPoint(anchor, box) {
      if (anchor.side === "top" || anchor.side === "bottom") {
        const {
          side,
          align
        } = anchor;
        const x = align === "left" ? 0 : align === "center" ? box.width / 2 : align === "right" ? box.width : align;
        const y = side === "top" ? 0 : side === "bottom" ? box.height : side;
        return elementToViewport({
          x,
          y
        }, box);
      } else if (anchor.side === "left" || anchor.side === "right") {
        const {
          side,
          align
        } = anchor;
        const x = side === "left" ? 0 : side === "right" ? box.width : side;
        const y = align === "top" ? 0 : align === "center" ? box.height / 2 : align === "bottom" ? box.height : align;
        return elementToViewport({
          x,
          y
        }, box);
      }
      return elementToViewport({
        x: box.width / 2,
        y: box.height / 2
      }, box);
    }
    const locationStrategies = {
      static: staticLocationStrategy,
      // specific viewport position, usually centered
      connected: connectedLocationStrategy
      // connected to a certain element
    };
    const makeLocationStrategyProps = propsFactory({
      locationStrategy: {
        type: [String, Function],
        default: "static",
        validator: (val) => typeof val === "function" || val in locationStrategies
      },
      location: {
        type: String,
        default: "bottom"
      },
      origin: {
        type: String,
        default: "auto"
      },
      offset: [Number, String, Array]
    }, "VOverlay-location-strategies");
    function useLocationStrategies(props, data) {
      const contentStyles = ref$1({});
      const updateLocation = ref$1();
      if (IN_BROWSER) {
        useToggleScope(() => !!(data.isActive.value && props.locationStrategy), (reset) => {
          var _a2, _b;
          watch(() => props.locationStrategy, reset);
          onScopeDispose(() => {
            window.removeEventListener("resize", onResize);
            updateLocation.value = void 0;
          });
          window.addEventListener("resize", onResize, {
            passive: true
          });
          if (typeof props.locationStrategy === "function") {
            updateLocation.value = (_a2 = props.locationStrategy(data, props, contentStyles)) == null ? void 0 : _a2.updateLocation;
          } else {
            updateLocation.value = (_b = locationStrategies[props.locationStrategy](data, props, contentStyles)) == null ? void 0 : _b.updateLocation;
          }
        });
      }
      function onResize(e) {
        var _a2;
        (_a2 = updateLocation.value) == null ? void 0 : _a2.call(updateLocation, e);
      }
      return {
        contentStyles,
        updateLocation
      };
    }
    function staticLocationStrategy() {
    }
    function getIntrinsicSize(el2, isRtl) {
      if (isRtl) {
        el2.style.removeProperty("left");
      } else {
        el2.style.removeProperty("right");
      }
      const contentBox = nullifyTransforms(el2);
      if (isRtl) {
        contentBox.x += parseFloat(el2.style.right || 0);
      } else {
        contentBox.x -= parseFloat(el2.style.left || 0);
      }
      contentBox.y -= parseFloat(el2.style.top || 0);
      return contentBox;
    }
    function connectedLocationStrategy(data, props, contentStyles) {
      const activatorFixed = Array.isArray(data.target.value) || isFixedPosition(data.target.value);
      if (activatorFixed) {
        Object.assign(contentStyles.value, {
          position: "fixed",
          top: 0,
          [data.isRtl.value ? "right" : "left"]: 0
        });
      }
      const {
        preferredAnchor,
        preferredOrigin
      } = destructComputed(() => {
        const parsedAnchor = parseAnchor(props.location, data.isRtl.value);
        const parsedOrigin = props.origin === "overlap" ? parsedAnchor : props.origin === "auto" ? flipSide(parsedAnchor) : parseAnchor(props.origin, data.isRtl.value);
        if (parsedAnchor.side === parsedOrigin.side && parsedAnchor.align === flipAlign(parsedOrigin).align) {
          return {
            preferredAnchor: flipCorner(parsedAnchor),
            preferredOrigin: flipCorner(parsedOrigin)
          };
        } else {
          return {
            preferredAnchor: parsedAnchor,
            preferredOrigin: parsedOrigin
          };
        }
      });
      const [minWidth, minHeight, maxWidth, maxHeight] = ["minWidth", "minHeight", "maxWidth", "maxHeight"].map((key) => {
        return computed(() => {
          const val = parseFloat(props[key]);
          return isNaN(val) ? Infinity : val;
        });
      });
      const offset = computed(() => {
        if (Array.isArray(props.offset)) {
          return props.offset;
        }
        if (typeof props.offset === "string") {
          const offset2 = props.offset.split(" ").map(parseFloat);
          if (offset2.length < 2)
            offset2.push(0);
          return offset2;
        }
        return typeof props.offset === "number" ? [props.offset, 0] : [0, 0];
      });
      let observe = false;
      const observer = new ResizeObserver(() => {
        if (observe)
          updateLocation();
      });
      watch([data.target, data.contentEl], (_ref, _ref2) => {
        let [newTarget, newContentEl] = _ref;
        let [oldTarget, oldContentEl] = _ref2;
        if (oldTarget && !Array.isArray(oldTarget))
          observer.unobserve(oldTarget);
        if (newTarget && !Array.isArray(newTarget))
          observer.observe(newTarget);
        if (oldContentEl)
          observer.unobserve(oldContentEl);
        if (newContentEl)
          observer.observe(newContentEl);
      }, {
        immediate: true
      });
      onScopeDispose(() => {
        observer.disconnect();
      });
      function updateLocation() {
        observe = false;
        requestAnimationFrame(() => observe = true);
        if (!data.target.value || !data.contentEl.value)
          return;
        const targetBox = getTargetBox(data.target.value);
        const contentBox = getIntrinsicSize(data.contentEl.value, data.isRtl.value);
        const scrollParents = getScrollParents(data.contentEl.value);
        const viewportMargin = 12;
        if (!scrollParents.length) {
          scrollParents.push(document.documentElement);
          if (!(data.contentEl.value.style.top && data.contentEl.value.style.left)) {
            contentBox.x -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x") || 0);
            contentBox.y -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y") || 0);
          }
        }
        const viewport = scrollParents.reduce((box, el2) => {
          const rect2 = el2.getBoundingClientRect();
          const scrollBox = new Box({
            x: el2 === document.documentElement ? 0 : rect2.x,
            y: el2 === document.documentElement ? 0 : rect2.y,
            width: el2.clientWidth,
            height: el2.clientHeight
          });
          if (box) {
            return new Box({
              x: Math.max(box.left, scrollBox.left),
              y: Math.max(box.top, scrollBox.top),
              width: Math.min(box.right, scrollBox.right) - Math.max(box.left, scrollBox.left),
              height: Math.min(box.bottom, scrollBox.bottom) - Math.max(box.top, scrollBox.top)
            });
          }
          return scrollBox;
        }, void 0);
        viewport.x += viewportMargin;
        viewport.y += viewportMargin;
        viewport.width -= viewportMargin * 2;
        viewport.height -= viewportMargin * 2;
        let placement = {
          anchor: preferredAnchor.value,
          origin: preferredOrigin.value
        };
        function checkOverflow(_placement) {
          const box = new Box(contentBox);
          const targetPoint = anchorToPoint(_placement.anchor, targetBox);
          const contentPoint = anchorToPoint(_placement.origin, box);
          let {
            x: x2,
            y: y2
          } = getOffset$1(targetPoint, contentPoint);
          switch (_placement.anchor.side) {
            case "top":
              y2 -= offset.value[0];
              break;
            case "bottom":
              y2 += offset.value[0];
              break;
            case "left":
              x2 -= offset.value[0];
              break;
            case "right":
              x2 += offset.value[0];
              break;
          }
          switch (_placement.anchor.align) {
            case "top":
              y2 -= offset.value[1];
              break;
            case "bottom":
              y2 += offset.value[1];
              break;
            case "left":
              x2 -= offset.value[1];
              break;
            case "right":
              x2 += offset.value[1];
              break;
          }
          box.x += x2;
          box.y += y2;
          box.width = Math.min(box.width, maxWidth.value);
          box.height = Math.min(box.height, maxHeight.value);
          const overflows = getOverflow(box, viewport);
          return {
            overflows,
            x: x2,
            y: y2
          };
        }
        let x = 0;
        let y = 0;
        const available = {
          x: 0,
          y: 0
        };
        const flipped = {
          x: false,
          y: false
        };
        let resets = -1;
        while (true) {
          if (resets++ > 10) {
            break;
          }
          const {
            x: _x,
            y: _y,
            overflows
          } = checkOverflow(placement);
          x += _x;
          y += _y;
          contentBox.x += _x;
          contentBox.y += _y;
          {
            const axis2 = getAxis(placement.anchor);
            const hasOverflowX = overflows.x.before || overflows.x.after;
            const hasOverflowY = overflows.y.before || overflows.y.after;
            let reset = false;
            ["x", "y"].forEach((key) => {
              if (key === "x" && hasOverflowX && !flipped.x || key === "y" && hasOverflowY && !flipped.y) {
                const newPlacement = {
                  anchor: {
                    ...placement.anchor
                  },
                  origin: {
                    ...placement.origin
                  }
                };
                const flip = key === "x" ? axis2 === "y" ? flipAlign : flipSide : axis2 === "y" ? flipSide : flipAlign;
                newPlacement.anchor = flip(newPlacement.anchor);
                newPlacement.origin = flip(newPlacement.origin);
                const {
                  overflows: newOverflows
                } = checkOverflow(newPlacement);
                if (newOverflows[key].before <= overflows[key].before && newOverflows[key].after <= overflows[key].after || newOverflows[key].before + newOverflows[key].after < (overflows[key].before + overflows[key].after) / 2) {
                  placement = newPlacement;
                  reset = flipped[key] = true;
                }
              }
            });
            if (reset)
              continue;
          }
          if (overflows.x.before) {
            x += overflows.x.before;
            contentBox.x += overflows.x.before;
          }
          if (overflows.x.after) {
            x -= overflows.x.after;
            contentBox.x -= overflows.x.after;
          }
          if (overflows.y.before) {
            y += overflows.y.before;
            contentBox.y += overflows.y.before;
          }
          if (overflows.y.after) {
            y -= overflows.y.after;
            contentBox.y -= overflows.y.after;
          }
          {
            const overflows2 = getOverflow(contentBox, viewport);
            available.x = viewport.width - overflows2.x.before - overflows2.x.after;
            available.y = viewport.height - overflows2.y.before - overflows2.y.after;
            x += overflows2.x.before;
            contentBox.x += overflows2.x.before;
            y += overflows2.y.before;
            contentBox.y += overflows2.y.before;
          }
          break;
        }
        const axis = getAxis(placement.anchor);
        Object.assign(contentStyles.value, {
          "--v-overlay-anchor-origin": `${placement.anchor.side} ${placement.anchor.align}`,
          transformOrigin: `${placement.origin.side} ${placement.origin.align}`,
          // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,
          top: convertToUnit(pixelRound(y)),
          left: data.isRtl.value ? void 0 : convertToUnit(pixelRound(x)),
          right: data.isRtl.value ? convertToUnit(pixelRound(-x)) : void 0,
          minWidth: convertToUnit(axis === "y" ? Math.min(minWidth.value, targetBox.width) : minWidth.value),
          maxWidth: convertToUnit(pixelCeil(clamp(available.x, minWidth.value === Infinity ? 0 : minWidth.value, maxWidth.value))),
          maxHeight: convertToUnit(pixelCeil(clamp(available.y, minHeight.value === Infinity ? 0 : minHeight.value, maxHeight.value)))
        });
        return {
          available,
          contentBox
        };
      }
      watch(() => [preferredAnchor.value, preferredOrigin.value, props.offset, props.minWidth, props.minHeight, props.maxWidth, props.maxHeight], () => updateLocation());
      nextTick(() => {
        const result = updateLocation();
        if (!result)
          return;
        const {
          available,
          contentBox
        } = result;
        if (contentBox.height > available.y) {
          requestAnimationFrame(() => {
            updateLocation();
            requestAnimationFrame(() => {
              updateLocation();
            });
          });
        }
      });
      return {
        updateLocation
      };
    }
    function pixelRound(val) {
      return Math.round(val * devicePixelRatio) / devicePixelRatio;
    }
    function pixelCeil(val) {
      return Math.ceil(val * devicePixelRatio) / devicePixelRatio;
    }
    let clean = true;
    const frames = [];
    function requestNewFrame(cb) {
      if (!clean || frames.length) {
        frames.push(cb);
        run();
      } else {
        clean = false;
        cb();
        run();
      }
    }
    let raf = -1;
    function run() {
      cancelAnimationFrame(raf);
      raf = requestAnimationFrame(() => {
        const frame = frames.shift();
        if (frame)
          frame();
        if (frames.length)
          run();
        else
          clean = true;
      });
    }
    const scrollStrategies = {
      none: null,
      close: closeScrollStrategy,
      block: blockScrollStrategy,
      reposition: repositionScrollStrategy
    };
    const makeScrollStrategyProps = propsFactory({
      scrollStrategy: {
        type: [String, Function],
        default: "block",
        validator: (val) => typeof val === "function" || val in scrollStrategies
      }
    }, "VOverlay-scroll-strategies");
    function useScrollStrategies(props, data) {
      if (!IN_BROWSER)
        return;
      let scope2;
      watchEffect(async () => {
        scope2 == null ? void 0 : scope2.stop();
        if (!(data.isActive.value && props.scrollStrategy))
          return;
        scope2 = effectScope();
        await nextTick();
        scope2.active && scope2.run(() => {
          var _a2;
          if (typeof props.scrollStrategy === "function") {
            props.scrollStrategy(data, props, scope2);
          } else {
            (_a2 = scrollStrategies[props.scrollStrategy]) == null ? void 0 : _a2.call(scrollStrategies, data, props, scope2);
          }
        });
      });
      onScopeDispose(() => {
        scope2 == null ? void 0 : scope2.stop();
      });
    }
    function closeScrollStrategy(data) {
      function onScroll(e) {
        data.isActive.value = false;
      }
      bindScroll(data.targetEl.value ?? data.contentEl.value, onScroll);
    }
    function blockScrollStrategy(data, props) {
      var _a2;
      const offsetParent = (_a2 = data.root.value) == null ? void 0 : _a2.offsetParent;
      const scrollElements = [.../* @__PURE__ */ new Set([...getScrollParents(data.targetEl.value, props.contained ? offsetParent : void 0), ...getScrollParents(data.contentEl.value, props.contained ? offsetParent : void 0)])].filter((el2) => !el2.classList.contains("v-overlay-scroll-blocked"));
      const scrollbarWidth = window.innerWidth - document.documentElement.offsetWidth;
      const scrollableParent = ((el2) => hasScrollbar(el2) && el2)(offsetParent || document.documentElement);
      if (scrollableParent) {
        data.root.value.classList.add("v-overlay--scroll-blocked");
      }
      scrollElements.forEach((el2, i2) => {
        el2.style.setProperty("--v-body-scroll-x", convertToUnit(-el2.scrollLeft));
        el2.style.setProperty("--v-body-scroll-y", convertToUnit(-el2.scrollTop));
        if (el2 !== document.documentElement) {
          el2.style.setProperty("--v-scrollbar-offset", convertToUnit(scrollbarWidth));
        }
        el2.classList.add("v-overlay-scroll-blocked");
      });
      onScopeDispose(() => {
        scrollElements.forEach((el2, i2) => {
          const x = parseFloat(el2.style.getPropertyValue("--v-body-scroll-x"));
          const y = parseFloat(el2.style.getPropertyValue("--v-body-scroll-y"));
          const scrollBehavior = el2.style.scrollBehavior;
          el2.style.scrollBehavior = "auto";
          el2.style.removeProperty("--v-body-scroll-x");
          el2.style.removeProperty("--v-body-scroll-y");
          el2.style.removeProperty("--v-scrollbar-offset");
          el2.classList.remove("v-overlay-scroll-blocked");
          el2.scrollLeft = -x;
          el2.scrollTop = -y;
          el2.style.scrollBehavior = scrollBehavior;
        });
        if (scrollableParent) {
          data.root.value.classList.remove("v-overlay--scroll-blocked");
        }
      });
    }
    function repositionScrollStrategy(data, props, scope2) {
      let slow = false;
      let raf2 = -1;
      let ric = -1;
      function update(e) {
        requestNewFrame(() => {
          var _a2, _b;
          const start = performance.now();
          (_b = (_a2 = data.updateLocation).value) == null ? void 0 : _b.call(_a2, e);
          const time = performance.now() - start;
          slow = time / (1e3 / 60) > 2;
        });
      }
      ric = (typeof requestIdleCallback === "undefined" ? (cb) => cb() : requestIdleCallback)(() => {
        scope2.run(() => {
          bindScroll(data.targetEl.value ?? data.contentEl.value, (e) => {
            if (slow) {
              cancelAnimationFrame(raf2);
              raf2 = requestAnimationFrame(() => {
                raf2 = requestAnimationFrame(() => {
                  update(e);
                });
              });
            } else {
              update(e);
            }
          });
        });
      });
      onScopeDispose(() => {
        typeof cancelIdleCallback !== "undefined" && cancelIdleCallback(ric);
        cancelAnimationFrame(raf2);
      });
    }
    function bindScroll(el2, onScroll) {
      const scrollElements = [document, ...getScrollParents(el2)];
      scrollElements.forEach((el3) => {
        el3.addEventListener("scroll", onScroll, {
          passive: true
        });
      });
      onScopeDispose(() => {
        scrollElements.forEach((el3) => {
          el3.removeEventListener("scroll", onScroll);
        });
      });
    }
    const VMenuSymbol = Symbol.for("vuetify:v-menu");
    const makeDelayProps = propsFactory({
      closeDelay: [Number, String],
      openDelay: [Number, String]
    }, "delay");
    function useDelay(props, cb) {
      let clearDelay = () => {
      };
      function runDelay(isOpening) {
        clearDelay == null ? void 0 : clearDelay();
        const delay = Number(isOpening ? props.openDelay : props.closeDelay);
        return new Promise((resolve2) => {
          clearDelay = defer(delay, () => {
            cb == null ? void 0 : cb(isOpening);
            resolve2(isOpening);
          });
        });
      }
      function runOpenDelay() {
        return runDelay(true);
      }
      function runCloseDelay() {
        return runDelay(false);
      }
      return {
        clearDelay,
        runOpenDelay,
        runCloseDelay
      };
    }
    const makeActivatorProps = propsFactory({
      target: [String, Object],
      activator: [String, Object],
      activatorProps: {
        type: Object,
        default: () => ({})
      },
      openOnClick: {
        type: Boolean,
        default: void 0
      },
      openOnHover: Boolean,
      openOnFocus: {
        type: Boolean,
        default: void 0
      },
      closeOnContentClick: Boolean,
      ...makeDelayProps()
    }, "VOverlay-activator");
    function useActivator(props, _ref) {
      let {
        isActive,
        isTop
      } = _ref;
      const vm = getCurrentInstance("useActivator");
      const activatorEl = ref$1();
      let isHovered = false;
      let isFocused = false;
      let firstEnter = true;
      const openOnFocus = computed(() => props.openOnFocus || props.openOnFocus == null && props.openOnHover);
      const openOnClick = computed(() => props.openOnClick || props.openOnClick == null && !props.openOnHover && !openOnFocus.value);
      const {
        runOpenDelay,
        runCloseDelay
      } = useDelay(props, (value) => {
        if (value === (props.openOnHover && isHovered || openOnFocus.value && isFocused) && !(props.openOnHover && isActive.value && !isTop.value)) {
          if (isActive.value !== value) {
            firstEnter = true;
          }
          isActive.value = value;
        }
      });
      const cursorTarget = ref$1();
      const availableEvents = {
        onClick: (e) => {
          e.stopPropagation();
          activatorEl.value = e.currentTarget || e.target;
          if (!isActive.value) {
            cursorTarget.value = [e.clientX, e.clientY];
          }
          isActive.value = !isActive.value;
        },
        onMouseenter: (e) => {
          var _a2;
          if ((_a2 = e.sourceCapabilities) == null ? void 0 : _a2.firesTouchEvents)
            return;
          isHovered = true;
          activatorEl.value = e.currentTarget || e.target;
          runOpenDelay();
        },
        onMouseleave: (e) => {
          isHovered = false;
          runCloseDelay();
        },
        onFocus: (e) => {
          if (matchesSelector(e.target, ":focus-visible") === false)
            return;
          isFocused = true;
          e.stopPropagation();
          activatorEl.value = e.currentTarget || e.target;
          runOpenDelay();
        },
        onBlur: (e) => {
          isFocused = false;
          e.stopPropagation();
          runCloseDelay();
        }
      };
      const activatorEvents = computed(() => {
        const events = {};
        if (openOnClick.value) {
          events.onClick = availableEvents.onClick;
        }
        if (props.openOnHover) {
          events.onMouseenter = availableEvents.onMouseenter;
          events.onMouseleave = availableEvents.onMouseleave;
        }
        if (openOnFocus.value) {
          events.onFocus = availableEvents.onFocus;
          events.onBlur = availableEvents.onBlur;
        }
        return events;
      });
      const contentEvents = computed(() => {
        const events = {};
        if (props.openOnHover) {
          events.onMouseenter = () => {
            isHovered = true;
            runOpenDelay();
          };
          events.onMouseleave = () => {
            isHovered = false;
            runCloseDelay();
          };
        }
        if (openOnFocus.value) {
          events.onFocusin = () => {
            isFocused = true;
            runOpenDelay();
          };
          events.onFocusout = () => {
            isFocused = false;
            runCloseDelay();
          };
        }
        if (props.closeOnContentClick) {
          const menu = inject$1(VMenuSymbol, null);
          events.onClick = () => {
            isActive.value = false;
            menu == null ? void 0 : menu.closeParents();
          };
        }
        return events;
      });
      const scrimEvents = computed(() => {
        const events = {};
        if (props.openOnHover) {
          events.onMouseenter = () => {
            if (firstEnter) {
              isHovered = true;
              firstEnter = false;
              runOpenDelay();
            }
          };
          events.onMouseleave = () => {
            isHovered = false;
            runCloseDelay();
          };
        }
        return events;
      });
      watch(isTop, (val) => {
        if (val && (props.openOnHover && !isHovered && (!openOnFocus.value || !isFocused) || openOnFocus.value && !isFocused && (!props.openOnHover || !isHovered))) {
          isActive.value = false;
        }
      });
      watch(isActive, (val) => {
        if (!val) {
          setTimeout(() => {
            cursorTarget.value = void 0;
          });
        }
      }, {
        flush: "post"
      });
      const activatorRef = ref$1();
      watchEffect(() => {
        if (!activatorRef.value)
          return;
        nextTick(() => {
          activatorEl.value = refElement(activatorRef.value);
        });
      });
      const targetRef = ref$1();
      const target2 = computed(() => {
        if (props.target === "cursor" && cursorTarget.value)
          return cursorTarget.value;
        if (targetRef.value)
          return refElement(targetRef.value);
        return getTarget(props.target, vm) || activatorEl.value;
      });
      const targetEl = computed(() => {
        return Array.isArray(target2.value) ? void 0 : target2.value;
      });
      let scope2;
      watch(() => !!props.activator, (val) => {
        if (val && IN_BROWSER) {
          scope2 = effectScope();
          scope2.run(() => {
            _useActivator(props, vm, {
              activatorEl,
              activatorEvents
            });
          });
        } else if (scope2) {
          scope2.stop();
        }
      }, {
        flush: "post",
        immediate: true
      });
      onScopeDispose(() => {
        scope2 == null ? void 0 : scope2.stop();
      });
      return {
        activatorEl,
        activatorRef,
        target: target2,
        targetEl,
        targetRef,
        activatorEvents,
        contentEvents,
        scrimEvents
      };
    }
    function _useActivator(props, vm, _ref2) {
      let {
        activatorEl,
        activatorEvents
      } = _ref2;
      watch(() => props.activator, (val, oldVal) => {
        if (oldVal && val !== oldVal) {
          const activator = getActivator(oldVal);
          activator && unbindActivatorProps(activator);
        }
        if (val) {
          nextTick(() => bindActivatorProps());
        }
      }, {
        immediate: true
      });
      watch(() => props.activatorProps, () => {
        bindActivatorProps();
      });
      onScopeDispose(() => {
        unbindActivatorProps();
      });
      function bindActivatorProps() {
        let el2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getActivator();
        let _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : props.activatorProps;
        if (!el2)
          return;
        bindProps(el2, mergeProps(activatorEvents.value, _props));
      }
      function unbindActivatorProps() {
        let el2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getActivator();
        let _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : props.activatorProps;
        if (!el2)
          return;
        unbindProps(el2, mergeProps(activatorEvents.value, _props));
      }
      function getActivator() {
        let selector = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : props.activator;
        const activator = getTarget(selector, vm);
        activatorEl.value = (activator == null ? void 0 : activator.nodeType) === Node.ELEMENT_NODE ? activator : void 0;
        return activatorEl.value;
      }
    }
    function getTarget(selector, vm) {
      var _a2, _b;
      if (!selector)
        return;
      let target2;
      if (selector === "parent") {
        let el2 = (_b = (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$el) == null ? void 0 : _b.parentNode;
        while (el2 == null ? void 0 : el2.hasAttribute("data-no-activator")) {
          el2 = el2.parentNode;
        }
        target2 = el2;
      } else if (typeof selector === "string") {
        target2 = document.querySelector(selector);
      } else if ("$el" in selector) {
        target2 = selector.$el;
      } else {
        target2 = selector;
      }
      return target2;
    }
    function useHydration() {
      if (!IN_BROWSER)
        return shallowRef(false);
      const {
        ssr
      } = useDisplay();
      if (ssr) {
        const isMounted = shallowRef(false);
        onMounted(() => {
          isMounted.value = true;
        });
        return isMounted;
      } else {
        return shallowRef(true);
      }
    }
    const makeLazyProps = propsFactory({
      eager: Boolean
    }, "lazy");
    function useLazy(props, active) {
      const isBooted = shallowRef(false);
      const hasContent = computed(() => isBooted.value || props.eager || active.value);
      watch(active, () => isBooted.value = true);
      function onAfterLeave() {
        if (!props.eager)
          isBooted.value = false;
      }
      return {
        isBooted,
        hasContent,
        onAfterLeave
      };
    }
    const StackSymbol = Symbol.for("vuetify:stack");
    const globalStack = reactive([]);
    function useStack(isActive, zIndex, disableGlobalStack) {
      const vm = getCurrentInstance("useStack");
      const createStackEntry = !disableGlobalStack;
      const parent = inject$1(StackSymbol, void 0);
      const stack2 = reactive({
        activeChildren: /* @__PURE__ */ new Set()
      });
      provide(StackSymbol, stack2);
      const _zIndex = shallowRef(+zIndex.value);
      useToggleScope(isActive, () => {
        var _a2;
        const lastZIndex = (_a2 = globalStack.at(-1)) == null ? void 0 : _a2[1];
        _zIndex.value = lastZIndex ? lastZIndex + 10 : +zIndex.value;
        if (createStackEntry) {
          globalStack.push([vm.uid, _zIndex.value]);
        }
        parent == null ? void 0 : parent.activeChildren.add(vm.uid);
        onScopeDispose(() => {
          if (createStackEntry) {
            const idx = toRaw(globalStack).findIndex((v) => v[0] === vm.uid);
            globalStack.splice(idx, 1);
          }
          parent == null ? void 0 : parent.activeChildren.delete(vm.uid);
        });
      });
      const globalTop = shallowRef(true);
      if (createStackEntry) {
        watchEffect(() => {
          var _a2;
          const _isTop = ((_a2 = globalStack.at(-1)) == null ? void 0 : _a2[0]) === vm.uid;
          setTimeout(() => globalTop.value = _isTop);
        });
      }
      const localTop = computed(() => !stack2.activeChildren.size);
      return {
        globalTop: readonly(globalTop),
        localTop,
        stackStyles: computed(() => ({
          zIndex: _zIndex.value
        }))
      };
    }
    function useTeleport(target2) {
      const teleportTarget = computed(() => {
        const _target = target2.value;
        if (_target === true || !IN_BROWSER)
          return void 0;
        const targetElement = _target === false ? document.body : typeof _target === "string" ? document.querySelector(_target) : _target;
        if (targetElement == null) {
          return void 0;
        }
        let container = targetElement.querySelector(":scope > .v-overlay-container");
        if (!container) {
          container = document.createElement("div");
          container.className = "v-overlay-container";
          targetElement.appendChild(container);
        }
        return container;
      });
      return {
        teleportTarget
      };
    }
    function defaultConditional() {
      return true;
    }
    function checkEvent(e, el2, binding) {
      if (!e || checkIsActive(e, binding) === false)
        return false;
      const root = attachedRoot(el2);
      if (typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot && root.host === e.target)
        return false;
      const elements = (typeof binding.value === "object" && binding.value.include || (() => []))();
      elements.push(el2);
      return !elements.some((el3) => el3 == null ? void 0 : el3.contains(e.target));
    }
    function checkIsActive(e, binding) {
      const isActive = typeof binding.value === "object" && binding.value.closeConditional || defaultConditional;
      return isActive(e);
    }
    function directive(e, el2, binding) {
      const handler = typeof binding.value === "function" ? binding.value : binding.value.handler;
      el2._clickOutside.lastMousedownWasOutside && checkEvent(e, el2, binding) && setTimeout(() => {
        checkIsActive(e, binding) && handler && handler(e);
      }, 0);
    }
    function handleShadow(el2, callback) {
      const root = attachedRoot(el2);
      callback(document);
      if (typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot) {
        callback(root);
      }
    }
    const ClickOutside = {
      // [data-app] may not be found
      // if using bind, inserted makes
      // sure that the root element is
      // available, iOS does not support
      // clicks on body
      mounted(el2, binding) {
        const onClick = (e) => directive(e, el2, binding);
        const onMousedown = (e) => {
          el2._clickOutside.lastMousedownWasOutside = checkEvent(e, el2, binding);
        };
        handleShadow(el2, (app2) => {
          app2.addEventListener("click", onClick, true);
          app2.addEventListener("mousedown", onMousedown, true);
        });
        if (!el2._clickOutside) {
          el2._clickOutside = {
            lastMousedownWasOutside: false
          };
        }
        el2._clickOutside[binding.instance.$.uid] = {
          onClick,
          onMousedown
        };
      },
      unmounted(el2, binding) {
        if (!el2._clickOutside)
          return;
        handleShadow(el2, (app2) => {
          var _a2;
          if (!app2 || !((_a2 = el2._clickOutside) == null ? void 0 : _a2[binding.instance.$.uid]))
            return;
          const {
            onClick,
            onMousedown
          } = el2._clickOutside[binding.instance.$.uid];
          app2.removeEventListener("click", onClick, true);
          app2.removeEventListener("mousedown", onMousedown, true);
        });
        delete el2._clickOutside[binding.instance.$.uid];
      }
    };
    function Scrim(props) {
      const {
        modelValue,
        color,
        ...rest
      } = props;
      return createVNode(Transition, {
        "name": "fade-transition",
        "appear": true
      }, {
        default: () => [props.modelValue && createVNode("div", mergeProps({
          "class": ["v-overlay__scrim", props.color.backgroundColorClasses.value],
          "style": props.color.backgroundColorStyles.value
        }, rest), null)]
      });
    }
    const makeVOverlayProps = propsFactory({
      absolute: Boolean,
      attach: [Boolean, String, Object],
      closeOnBack: {
        type: Boolean,
        default: true
      },
      contained: Boolean,
      contentClass: null,
      contentProps: null,
      disabled: Boolean,
      opacity: [Number, String],
      noClickAnimation: Boolean,
      modelValue: Boolean,
      persistent: Boolean,
      scrim: {
        type: [Boolean, String],
        default: true
      },
      zIndex: {
        type: [Number, String],
        default: 2e3
      },
      ...makeActivatorProps(),
      ...makeComponentProps(),
      ...makeDimensionProps(),
      ...makeLazyProps(),
      ...makeLocationStrategyProps(),
      ...makeScrollStrategyProps(),
      ...makeThemeProps(),
      ...makeTransitionProps()
    }, "VOverlay");
    const VOverlay = genericComponent()({
      name: "VOverlay",
      directives: {
        ClickOutside
      },
      inheritAttrs: false,
      props: {
        _disableGlobalStack: Boolean,
        ...makeVOverlayProps()
      },
      emits: {
        "click:outside": (e) => true,
        "update:modelValue": (value) => true,
        afterLeave: () => true
      },
      setup(props, _ref) {
        let {
          slots,
          attrs,
          emit: emit2
        } = _ref;
        const model = useProxiedModel(props, "modelValue");
        const isActive = computed({
          get: () => model.value,
          set: (v) => {
            if (!(v && props.disabled))
              model.value = v;
          }
        });
        const {
          teleportTarget
        } = useTeleport(computed(() => props.attach || props.contained));
        const {
          themeClasses
        } = provideTheme(props);
        const {
          rtlClasses,
          isRtl
        } = useRtl();
        const {
          hasContent,
          onAfterLeave: _onAfterLeave
        } = useLazy(props, isActive);
        const scrimColor = useBackgroundColor(computed(() => {
          return typeof props.scrim === "string" ? props.scrim : null;
        }));
        const {
          globalTop,
          localTop,
          stackStyles
        } = useStack(isActive, toRef(props, "zIndex"), props._disableGlobalStack);
        const {
          activatorEl,
          activatorRef,
          target: target2,
          targetEl,
          targetRef,
          activatorEvents,
          contentEvents,
          scrimEvents
        } = useActivator(props, {
          isActive,
          isTop: localTop
        });
        const {
          dimensionStyles
        } = useDimension(props);
        const isMounted = useHydration();
        const {
          scopeId
        } = useScopeId();
        watch(() => props.disabled, (v) => {
          if (v)
            isActive.value = false;
        });
        const root = ref$1();
        const contentEl = ref$1();
        const {
          contentStyles,
          updateLocation
        } = useLocationStrategies(props, {
          isRtl,
          contentEl,
          target: target2,
          isActive
        });
        useScrollStrategies(props, {
          root,
          contentEl,
          targetEl,
          isActive,
          updateLocation
        });
        function onClickOutside(e) {
          emit2("click:outside", e);
          if (!props.persistent)
            isActive.value = false;
          else
            animateClick();
        }
        function closeConditional() {
          return isActive.value && globalTop.value;
        }
        IN_BROWSER && watch(isActive, (val) => {
          if (val) {
            window.addEventListener("keydown", onKeydown);
          } else {
            window.removeEventListener("keydown", onKeydown);
          }
        }, {
          immediate: true
        });
        onBeforeUnmount(() => {
          if (!IN_BROWSER)
            return;
          window.removeEventListener("keydown", onKeydown);
        });
        function onKeydown(e) {
          var _a2, _b;
          if (e.key === "Escape" && globalTop.value) {
            if (!props.persistent) {
              isActive.value = false;
              if ((_a2 = contentEl.value) == null ? void 0 : _a2.contains(document.activeElement)) {
                (_b = activatorEl.value) == null ? void 0 : _b.focus();
              }
            } else
              animateClick();
          }
        }
        const router2 = useRouter();
        useToggleScope(() => props.closeOnBack, () => {
          useBackButton(router2, (next2) => {
            if (globalTop.value && isActive.value) {
              next2(false);
              if (!props.persistent)
                isActive.value = false;
              else
                animateClick();
            } else {
              next2();
            }
          });
        });
        const top2 = ref$1();
        watch(() => isActive.value && (props.absolute || props.contained) && teleportTarget.value == null, (val) => {
          if (val) {
            const scrollParent = getScrollParent(root.value);
            if (scrollParent && scrollParent !== document.scrollingElement) {
              top2.value = scrollParent.scrollTop;
            }
          }
        });
        function animateClick() {
          if (props.noClickAnimation)
            return;
          contentEl.value && animate(contentEl.value, [{
            transformOrigin: "center"
          }, {
            transform: "scale(1.03)"
          }, {
            transformOrigin: "center"
          }], {
            duration: 150,
            easing: standardEasing
          });
        }
        function onAfterLeave() {
          _onAfterLeave();
          emit2("afterLeave");
        }
        useRender(() => {
          var _a2;
          return createVNode(Fragment, null, [(_a2 = slots.activator) == null ? void 0 : _a2.call(slots, {
            isActive: isActive.value,
            props: mergeProps({
              ref: activatorRef,
              targetRef
            }, activatorEvents.value, props.activatorProps)
          }), isMounted.value && hasContent.value && createVNode(Teleport, {
            "disabled": !teleportTarget.value,
            "to": teleportTarget.value
          }, {
            default: () => [createVNode("div", mergeProps({
              "class": ["v-overlay", {
                "v-overlay--absolute": props.absolute || props.contained,
                "v-overlay--active": isActive.value,
                "v-overlay--contained": props.contained
              }, themeClasses.value, rtlClasses.value, props.class],
              "style": [stackStyles.value, {
                "--v-overlay-opacity": props.opacity,
                top: convertToUnit(top2.value)
              }, props.style],
              "ref": root
            }, scopeId, attrs), [createVNode(Scrim, mergeProps({
              "color": scrimColor,
              "modelValue": isActive.value && !!props.scrim
            }, scrimEvents.value), null), createVNode(MaybeTransition, {
              "appear": true,
              "persisted": true,
              "transition": props.transition,
              "target": target2.value,
              "onAfterLeave": onAfterLeave
            }, {
              default: () => {
                var _a3;
                return [withDirectives(createVNode("div", mergeProps({
                  "ref": contentEl,
                  "class": ["v-overlay__content", props.contentClass],
                  "style": [dimensionStyles.value, contentStyles.value]
                }, contentEvents.value, props.contentProps), [(_a3 = slots.default) == null ? void 0 : _a3.call(slots, {
                  isActive
                })]), [[vShow, isActive.value], [resolveDirective("click-outside"), {
                  handler: onClickOutside,
                  closeConditional,
                  include: () => [activatorEl.value]
                }]])];
              }
            })])]
          })]);
        });
        return {
          activatorEl,
          target: target2,
          animateClick,
          contentEl,
          globalTop,
          localTop,
          updateLocation
        };
      }
    });
    const Refs = Symbol("Forwarded refs");
    function getDescriptor(obj, key) {
      let currentObj = obj;
      while (currentObj) {
        const descriptor = Reflect.getOwnPropertyDescriptor(currentObj, key);
        if (descriptor)
          return descriptor;
        currentObj = Object.getPrototypeOf(currentObj);
      }
      return void 0;
    }
    function forwardRefs(target2) {
      for (var _len = arguments.length, refs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        refs[_key - 1] = arguments[_key];
      }
      target2[Refs] = refs;
      return new Proxy(target2, {
        get(target3, key) {
          if (Reflect.has(target3, key)) {
            return Reflect.get(target3, key);
          }
          if (typeof key === "symbol" || key.startsWith("$") || key.startsWith("__"))
            return;
          for (const ref2 of refs) {
            if (ref2.value && Reflect.has(ref2.value, key)) {
              const val = Reflect.get(ref2.value, key);
              return typeof val === "function" ? val.bind(ref2.value) : val;
            }
          }
        },
        has(target3, key) {
          if (Reflect.has(target3, key)) {
            return true;
          }
          if (typeof key === "symbol" || key.startsWith("$") || key.startsWith("__"))
            return false;
          for (const ref2 of refs) {
            if (ref2.value && Reflect.has(ref2.value, key)) {
              return true;
            }
          }
          return false;
        },
        set(target3, key, value) {
          if (Reflect.has(target3, key)) {
            return Reflect.set(target3, key, value);
          }
          if (typeof key === "symbol" || key.startsWith("$") || key.startsWith("__"))
            return false;
          for (const ref2 of refs) {
            if (ref2.value && Reflect.has(ref2.value, key)) {
              return Reflect.set(ref2.value, key, value);
            }
          }
          return false;
        },
        getOwnPropertyDescriptor(target3, key) {
          var _a2;
          const descriptor = Reflect.getOwnPropertyDescriptor(target3, key);
          if (descriptor)
            return descriptor;
          if (typeof key === "symbol" || key.startsWith("$") || key.startsWith("__"))
            return;
          for (const ref2 of refs) {
            if (!ref2.value)
              continue;
            const descriptor2 = getDescriptor(ref2.value, key) ?? ("_" in ref2.value ? getDescriptor((_a2 = ref2.value._) == null ? void 0 : _a2.setupState, key) : void 0);
            if (descriptor2)
              return descriptor2;
          }
          for (const ref2 of refs) {
            const childRefs = ref2.value && ref2.value[Refs];
            if (!childRefs)
              continue;
            const queue2 = childRefs.slice();
            while (queue2.length) {
              const ref3 = queue2.shift();
              const descriptor2 = getDescriptor(ref3.value, key);
              if (descriptor2)
                return descriptor2;
              const childRefs2 = ref3.value && ref3.value[Refs];
              if (childRefs2)
                queue2.push(...childRefs2);
            }
          }
          return void 0;
        }
      });
    }
    const makeVTooltipProps = propsFactory({
      id: String,
      text: String,
      ...omit$1(makeVOverlayProps({
        closeOnBack: false,
        location: "end",
        locationStrategy: "connected",
        eager: true,
        minWidth: 0,
        offset: 10,
        openOnClick: false,
        openOnHover: true,
        origin: "auto",
        scrim: false,
        scrollStrategy: "reposition",
        transition: false
      }), ["absolute", "persistent"])
    }, "VTooltip");
    const VTooltip = genericComponent()({
      name: "VTooltip",
      props: makeVTooltipProps(),
      emits: {
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const isActive = useProxiedModel(props, "modelValue");
        const {
          scopeId
        } = useScopeId();
        const uid2 = getUid();
        const id2 = computed(() => props.id || `v-tooltip-${uid2}`);
        const overlay = ref$1();
        const location2 = computed(() => {
          return props.location.split(" ").length > 1 ? props.location : props.location + " center";
        });
        const origin = computed(() => {
          return props.origin === "auto" || props.origin === "overlap" || props.origin.split(" ").length > 1 || props.location.split(" ").length > 1 ? props.origin : props.origin + " center";
        });
        const transition = computed(() => {
          if (props.transition)
            return props.transition;
          return isActive.value ? "scale-transition" : "fade-transition";
        });
        const activatorProps = computed(() => mergeProps({
          "aria-describedby": id2.value
        }, props.activatorProps));
        useRender(() => {
          const overlayProps = VOverlay.filterProps(props);
          return createVNode(VOverlay, mergeProps({
            "ref": overlay,
            "class": ["v-tooltip", props.class],
            "style": props.style,
            "id": id2.value
          }, overlayProps, {
            "modelValue": isActive.value,
            "onUpdate:modelValue": ($event) => isActive.value = $event,
            "transition": transition.value,
            "absolute": true,
            "location": location2.value,
            "origin": origin.value,
            "persistent": true,
            "role": "tooltip",
            "activatorProps": activatorProps.value,
            "_disableGlobalStack": true
          }, scopeId), {
            activator: slots.activator,
            default: function() {
              var _a2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return ((_a2 = slots.default) == null ? void 0 : _a2.call(slots, ...args)) ?? props.text;
            }
          });
        });
        return forwardRefs({}, overlay);
      }
    });
    function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_router_view = resolveComponent("router-view");
      return openBlock(), createBlock(VApp, null, {
        default: withCtx(() => [
          createVNode(VAppBar, { color: "primary" }, {
            default: withCtx(() => [
              createVNode(VAppBarNavIcon, {
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.drawer = !_ctx.drawer)
              }),
              createVNode(VSpacer),
              createVNode(VImg, {
                class: "mx-4 rotateable",
                "max-height": "40",
                "max-width": "40",
                src: _imports_0
              }),
              createVNode(VToolbarTitle, { class: "app-bar-title" }, {
                default: withCtx(() => [
                  createTextVNode("EVerest Admin Panel")
                ]),
                _: 1
              }),
              createVNode(VSpacer)
            ]),
            _: 1
          }),
          createVNode(VNavigationDrawer, {
            modelValue: _ctx.drawer,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.drawer = $event),
            position: "fixed",
            temporary: ""
          }, {
            default: withCtx(() => [
              createVNode(VList, {
                nav: "",
                density: "compact"
              }, {
                default: withCtx(() => [
                  createVNode(VListItem, {
                    to: "config",
                    "append-icon": "mdi-cog",
                    link: ""
                  }, {
                    default: withCtx(() => [
                      createVNode(VListItemTitle, null, {
                        default: withCtx(() => [
                          createTextVNode("Config")
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }),
                  createVNode(VTooltip, { location: "end" }, {
                    activator: withCtx(({ props }) => [
                      createVNode(VListItem, mergeProps({
                        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.changeInstance()),
                        "append-icon": "mdi-image-filter-hdr",
                        link: ""
                      }, props), {
                        default: withCtx(() => [
                          createVNode(VListItemTitle, null, {
                            default: withCtx(() => [
                              createTextVNode("Change EVerest instance")
                            ]),
                            _: 1
                          })
                        ]),
                        _: 2
                      }, 1040)
                    ]),
                    default: withCtx(() => [
                      createBaseVNode("span", null, "Connected to " + toDisplayString(_ctx.connectionUrl), 1)
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              createVNode(VListItem, { class: "bottom-list d-flex flex-column" }, {
                default: withCtx(() => [
                  createBaseVNode("span", null, "Version " + toDisplayString(_ctx.version), 1)
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["modelValue"]),
          createVNode(VMain, null, {
            default: withCtx(() => [
              !_ctx.evbc_disconnected ? (openBlock(), createBlock(_component_router_view, { key: 0 })) : (openBlock(), createBlock(VOverlay, {
                key: 1,
                dark: false
              }, {
                default: withCtx(() => [
                  createVNode(VCard, {
                    elevation: "10",
                    loading: "true",
                    width: "400",
                    height: "150"
                  }, {
                    actions: withCtx(() => [
                      createVNode(VProgressLinear, {
                        height: "10",
                        indeterminate: ""
                      })
                    ]),
                    default: withCtx(() => [
                      createVNode(VCardTitle, null, {
                        default: withCtx(() => [
                          createTextVNode("Lost connection to EVerest backend")
                        ]),
                        _: 1
                      }),
                      createVNode(VCardText, null, {
                        default: withCtx(() => [
                          createTextVNode("Trying to reconnect ...")
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }))
            ]),
            _: 1
          })
        ]),
        _: 1
      });
    }
    const MainPanel = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$6], ["__scopeId", "data-v-cadf9cf6"]]);
    /**
      * vee-validate v4.12.6
      * (c) 2024 Abdelrahman Awad
      * @license MIT
      */
    function isCallable(fn) {
      return typeof fn === "function";
    }
    function isNullOrUndefined(value) {
      return value === null || value === void 0;
    }
    const isObject$1 = (obj) => obj !== null && !!obj && typeof obj === "object" && !Array.isArray(obj);
    function isIndex(value) {
      return Number(value) >= 0;
    }
    function toNumber(value) {
      const n = parseFloat(value);
      return isNaN(n) ? value : n;
    }
    function isObjectLike(value) {
      return typeof value === "object" && value !== null;
    }
    function getTag(value) {
      if (value == null) {
        return value === void 0 ? "[object Undefined]" : "[object Null]";
      }
      return Object.prototype.toString.call(value);
    }
    function isPlainObject$2(value) {
      if (!isObjectLike(value) || getTag(value) !== "[object Object]") {
        return false;
      }
      if (Object.getPrototypeOf(value) === null) {
        return true;
      }
      let proto = value;
      while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
      }
      return Object.getPrototypeOf(value) === proto;
    }
    function merge(target2, source) {
      Object.keys(source).forEach((key) => {
        if (isPlainObject$2(source[key]) && isPlainObject$2(target2[key])) {
          if (!target2[key]) {
            target2[key] = {};
          }
          merge(target2[key], source[key]);
          return;
        }
        target2[key] = source[key];
      });
      return target2;
    }
    function normalizeFormPath(path) {
      const pathArr = path.split(".");
      if (!pathArr.length) {
        return "";
      }
      let fullPath = String(pathArr[0]);
      for (let i2 = 1; i2 < pathArr.length; i2++) {
        if (isIndex(pathArr[i2])) {
          fullPath += `[${pathArr[i2]}]`;
          continue;
        }
        fullPath += `.${pathArr[i2]}`;
      }
      return fullPath;
    }
    const RULES = {};
    function resolveRule(id2) {
      return RULES[id2];
    }
    function set$1(obj, key, val) {
      if (typeof val.value === "object")
        val.value = klona(val.value);
      if (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === "__proto__") {
        Object.defineProperty(obj, key, val);
      } else
        obj[key] = val.value;
    }
    function klona(x) {
      if (typeof x !== "object")
        return x;
      var i2 = 0, k, list2, tmp, str = Object.prototype.toString.call(x);
      if (str === "[object Object]") {
        tmp = Object.create(x.__proto__ || null);
      } else if (str === "[object Array]") {
        tmp = Array(x.length);
      } else if (str === "[object Set]") {
        tmp = /* @__PURE__ */ new Set();
        x.forEach(function(val) {
          tmp.add(klona(val));
        });
      } else if (str === "[object Map]") {
        tmp = /* @__PURE__ */ new Map();
        x.forEach(function(val, key) {
          tmp.set(klona(key), klona(val));
        });
      } else if (str === "[object Date]") {
        tmp = /* @__PURE__ */ new Date(+x);
      } else if (str === "[object RegExp]") {
        tmp = new RegExp(x.source, x.flags);
      } else if (str === "[object DataView]") {
        tmp = new x.constructor(klona(x.buffer));
      } else if (str === "[object ArrayBuffer]") {
        tmp = x.slice(0);
      } else if (str.slice(-6) === "Array]") {
        tmp = new x.constructor(x);
      }
      if (tmp) {
        for (list2 = Object.getOwnPropertySymbols(x); i2 < list2.length; i2++) {
          set$1(tmp, list2[i2], Object.getOwnPropertyDescriptor(x, list2[i2]));
        }
        for (i2 = 0, list2 = Object.getOwnPropertyNames(x); i2 < list2.length; i2++) {
          if (Object.hasOwnProperty.call(tmp, k = list2[i2]) && tmp[k] === x[k])
            continue;
          set$1(tmp, k, Object.getOwnPropertyDescriptor(x, k));
        }
      }
      return tmp || x;
    }
    const FormContextKey = Symbol("vee-validate-form");
    const FieldContextKey = Symbol("vee-validate-field-instance");
    const IS_ABSENT = Symbol("Default empty value");
    const isClient$1 = typeof window !== "undefined";
    function isLocator(value) {
      return isCallable(value) && !!value.__locatorRef;
    }
    function isTypedSchema(value) {
      return !!value && isCallable(value.parse) && value.__type === "VVTypedSchema";
    }
    function isYupValidator(value) {
      return !!value && isCallable(value.validate);
    }
    function hasCheckedAttr(type2) {
      return type2 === "checkbox" || type2 === "radio";
    }
    function isContainerValue(value) {
      return isObject$1(value) || Array.isArray(value);
    }
    function isEmptyContainer(value) {
      if (Array.isArray(value)) {
        return value.length === 0;
      }
      return isObject$1(value) && Object.keys(value).length === 0;
    }
    function isNotNestedPath(path) {
      return /^\[.+\]$/i.test(path);
    }
    function isNativeMultiSelect(el2) {
      return isNativeSelect(el2) && el2.multiple;
    }
    function isNativeSelect(el2) {
      return el2.tagName === "SELECT";
    }
    function isFormSubmitEvent(evt) {
      return isEvent(evt) && evt.target && "submit" in evt.target;
    }
    function isEvent(evt) {
      if (!evt) {
        return false;
      }
      if (typeof Event !== "undefined" && isCallable(Event) && evt instanceof Event) {
        return true;
      }
      if (evt && evt.srcElement) {
        return true;
      }
      return false;
    }
    function isEqual(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a === "object" && typeof b === "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i2, keys2;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i2 = length; i2-- !== 0; )
            if (!isEqual(a[i2], b[i2]))
              return false;
          return true;
        }
        if (a instanceof Map && b instanceof Map) {
          if (a.size !== b.size)
            return false;
          for (i2 of a.entries())
            if (!b.has(i2[0]))
              return false;
          for (i2 of a.entries())
            if (!isEqual(i2[1], b.get(i2[0])))
              return false;
          return true;
        }
        if (isFile(a) && isFile(b)) {
          if (a.size !== b.size)
            return false;
          if (a.name !== b.name)
            return false;
          if (a.lastModified !== b.lastModified)
            return false;
          if (a.type !== b.type)
            return false;
          return true;
        }
        if (a instanceof Set && b instanceof Set) {
          if (a.size !== b.size)
            return false;
          for (i2 of a.entries())
            if (!b.has(i2[0]))
              return false;
          return true;
        }
        if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i2 = length; i2-- !== 0; )
            if (a[i2] !== b[i2])
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys2 = Object.keys(a);
        length = keys2.length;
        for (i2 = length; i2-- !== 0; ) {
          var key = keys2[i2];
          if (!isEqual(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    }
    function isFile(a) {
      if (!isClient$1) {
        return false;
      }
      return a instanceof File;
    }
    function cleanupNonNestedPath(path) {
      if (isNotNestedPath(path)) {
        return path.replace(/\[|\]/gi, "");
      }
      return path;
    }
    function getFromPath(object, path, fallback) {
      if (!object) {
        return fallback;
      }
      if (isNotNestedPath(path)) {
        return object[cleanupNonNestedPath(path)];
      }
      const resolvedValue = (path || "").split(/\.|\[(\d+)\]/).filter(Boolean).reduce((acc, propKey) => {
        if (isContainerValue(acc) && propKey in acc) {
          return acc[propKey];
        }
        return fallback;
      }, object);
      return resolvedValue;
    }
    function setInPath(object, path, value) {
      if (isNotNestedPath(path)) {
        object[cleanupNonNestedPath(path)] = value;
        return;
      }
      const keys2 = path.split(/\.|\[(\d+)\]/).filter(Boolean);
      let acc = object;
      for (let i2 = 0; i2 < keys2.length; i2++) {
        if (i2 === keys2.length - 1) {
          acc[keys2[i2]] = value;
          return;
        }
        if (!(keys2[i2] in acc) || isNullOrUndefined(acc[keys2[i2]])) {
          acc[keys2[i2]] = isIndex(keys2[i2 + 1]) ? [] : {};
        }
        acc = acc[keys2[i2]];
      }
    }
    function unset(object, key) {
      if (Array.isArray(object) && isIndex(key)) {
        object.splice(Number(key), 1);
        return;
      }
      if (isObject$1(object)) {
        delete object[key];
      }
    }
    function unsetPath(object, path) {
      if (isNotNestedPath(path)) {
        delete object[cleanupNonNestedPath(path)];
        return;
      }
      const keys2 = path.split(/\.|\[(\d+)\]/).filter(Boolean);
      let acc = object;
      for (let i2 = 0; i2 < keys2.length; i2++) {
        if (i2 === keys2.length - 1) {
          unset(acc, keys2[i2]);
          break;
        }
        if (!(keys2[i2] in acc) || isNullOrUndefined(acc[keys2[i2]])) {
          break;
        }
        acc = acc[keys2[i2]];
      }
      const pathValues = keys2.map((_, idx) => {
        return getFromPath(object, keys2.slice(0, idx).join("."));
      });
      for (let i2 = pathValues.length - 1; i2 >= 0; i2--) {
        if (!isEmptyContainer(pathValues[i2])) {
          continue;
        }
        if (i2 === 0) {
          unset(object, keys2[0]);
          continue;
        }
        unset(pathValues[i2 - 1], keys2[i2 - 1]);
      }
    }
    function keysOf(record) {
      return Object.keys(record);
    }
    function injectWithSelf(symbol, def2 = void 0) {
      const vm = getCurrentInstance$1();
      return (vm === null || vm === void 0 ? void 0 : vm.provides[symbol]) || inject$1(symbol, def2);
    }
    function resolveNextCheckboxValue(currentValue, checkedValue, uncheckedValue) {
      if (Array.isArray(currentValue)) {
        const newVal = [...currentValue];
        const idx = newVal.findIndex((v) => isEqual(v, checkedValue));
        idx >= 0 ? newVal.splice(idx, 1) : newVal.push(checkedValue);
        return newVal;
      }
      return isEqual(currentValue, checkedValue) ? uncheckedValue : checkedValue;
    }
    function debounceAsync(inner, ms2 = 0) {
      let timer = null;
      let resolves = [];
      return function(...args) {
        if (timer) {
          clearTimeout(timer);
        }
        timer = setTimeout(() => {
          const result = inner(...args);
          resolves.forEach((r) => r(result));
          resolves = [];
        }, ms2);
        return new Promise((resolve2) => resolves.push(resolve2));
      };
    }
    function applyModelModifiers(value, modifiers) {
      if (!isObject$1(modifiers)) {
        return value;
      }
      if (modifiers.number) {
        return toNumber(value);
      }
      return value;
    }
    function withLatest(fn, onDone) {
      let latestRun;
      return async function runLatest(...args) {
        const pending = fn(...args);
        latestRun = pending;
        const result = await pending;
        if (pending !== latestRun) {
          return result;
        }
        latestRun = void 0;
        return onDone(result, args);
      };
    }
    function normalizeErrorItem(message) {
      return Array.isArray(message) ? message : message ? [message] : [];
    }
    function omit(obj, keys2) {
      const target2 = {};
      for (const key in obj) {
        if (!keys2.includes(key)) {
          target2[key] = obj[key];
        }
      }
      return target2;
    }
    function debounceNextTick(inner) {
      let lastTick = null;
      let resolves = [];
      return function(...args) {
        const thisTick = nextTick(() => {
          if (lastTick !== thisTick) {
            return;
          }
          const result = inner(...args);
          resolves.forEach((r) => r(result));
          resolves = [];
          lastTick = null;
        });
        lastTick = thisTick;
        return new Promise((resolve2) => resolves.push(resolve2));
      };
    }
    function getBoundValue(el2) {
      if (hasValueBinding(el2)) {
        return el2._value;
      }
      return void 0;
    }
    function hasValueBinding(el2) {
      return "_value" in el2;
    }
    function parseInputValue(el2) {
      if (el2.type === "number") {
        return Number.isNaN(el2.valueAsNumber) ? el2.value : el2.valueAsNumber;
      }
      if (el2.type === "range") {
        return Number.isNaN(el2.valueAsNumber) ? el2.value : el2.valueAsNumber;
      }
      return el2.value;
    }
    function normalizeEventValue(value) {
      if (!isEvent(value)) {
        return value;
      }
      const input = value.target;
      if (hasCheckedAttr(input.type) && hasValueBinding(input)) {
        return getBoundValue(input);
      }
      if (input.type === "file" && input.files) {
        const files = Array.from(input.files);
        return input.multiple ? files : files[0];
      }
      if (isNativeMultiSelect(input)) {
        return Array.from(input.options).filter((opt) => opt.selected && !opt.disabled).map(getBoundValue);
      }
      if (isNativeSelect(input)) {
        const selectedOption = Array.from(input.options).find((opt) => opt.selected);
        return selectedOption ? getBoundValue(selectedOption) : input.value;
      }
      return parseInputValue(input);
    }
    function normalizeRules(rules2) {
      const acc = {};
      Object.defineProperty(acc, "_$$isNormalized", {
        value: true,
        writable: false,
        enumerable: false,
        configurable: false
      });
      if (!rules2) {
        return acc;
      }
      if (isObject$1(rules2) && rules2._$$isNormalized) {
        return rules2;
      }
      if (isObject$1(rules2)) {
        return Object.keys(rules2).reduce((prev, curr) => {
          const params = normalizeParams(rules2[curr]);
          if (rules2[curr] !== false) {
            prev[curr] = buildParams(params);
          }
          return prev;
        }, acc);
      }
      if (typeof rules2 !== "string") {
        return acc;
      }
      return rules2.split("|").reduce((prev, rule) => {
        const parsedRule = parseRule(rule);
        if (!parsedRule.name) {
          return prev;
        }
        prev[parsedRule.name] = buildParams(parsedRule.params);
        return prev;
      }, acc);
    }
    function normalizeParams(params) {
      if (params === true) {
        return [];
      }
      if (Array.isArray(params)) {
        return params;
      }
      if (isObject$1(params)) {
        return params;
      }
      return [params];
    }
    function buildParams(provided) {
      const mapValueToLocator = (value) => {
        if (typeof value === "string" && value[0] === "@") {
          return createLocator(value.slice(1));
        }
        return value;
      };
      if (Array.isArray(provided)) {
        return provided.map(mapValueToLocator);
      }
      if (provided instanceof RegExp) {
        return [provided];
      }
      return Object.keys(provided).reduce((prev, key) => {
        prev[key] = mapValueToLocator(provided[key]);
        return prev;
      }, {});
    }
    const parseRule = (rule) => {
      let params = [];
      const name = rule.split(":")[0];
      if (rule.includes(":")) {
        params = rule.split(":").slice(1).join(":").split(",");
      }
      return { name, params };
    };
    function createLocator(value) {
      const locator = (crossTable) => {
        const val = getFromPath(crossTable, value) || crossTable[value];
        return val;
      };
      locator.__locatorRef = value;
      return locator;
    }
    function extractLocators(params) {
      if (Array.isArray(params)) {
        return params.filter(isLocator);
      }
      return keysOf(params).filter((key) => isLocator(params[key])).map((key) => params[key]);
    }
    const DEFAULT_CONFIG = {
      generateMessage: ({ field }) => `${field} is not valid.`,
      bails: true,
      validateOnBlur: true,
      validateOnChange: true,
      validateOnInput: false,
      validateOnModelUpdate: true
    };
    let currentConfig = Object.assign({}, DEFAULT_CONFIG);
    const getConfig = () => currentConfig;
    async function validate$1(value, rules2, options = {}) {
      const shouldBail = options === null || options === void 0 ? void 0 : options.bails;
      const field = {
        name: (options === null || options === void 0 ? void 0 : options.name) || "{field}",
        rules: rules2,
        label: options === null || options === void 0 ? void 0 : options.label,
        bails: shouldBail !== null && shouldBail !== void 0 ? shouldBail : true,
        formData: (options === null || options === void 0 ? void 0 : options.values) || {}
      };
      const result = await _validate(field, value);
      const errors2 = result.errors;
      return {
        errors: errors2,
        valid: !errors2.length
      };
    }
    async function _validate(field, value) {
      if (isTypedSchema(field.rules) || isYupValidator(field.rules)) {
        return validateFieldWithTypedSchema(value, field.rules);
      }
      if (isCallable(field.rules) || Array.isArray(field.rules)) {
        const ctx = {
          field: field.label || field.name,
          name: field.name,
          label: field.label,
          form: field.formData,
          value
        };
        const pipeline = Array.isArray(field.rules) ? field.rules : [field.rules];
        const length2 = pipeline.length;
        const errors22 = [];
        for (let i2 = 0; i2 < length2; i2++) {
          const rule = pipeline[i2];
          const result = await rule(value, ctx);
          const isValid2 = typeof result !== "string" && !Array.isArray(result) && result;
          if (isValid2) {
            continue;
          }
          if (Array.isArray(result)) {
            errors22.push(...result);
          } else {
            const message = typeof result === "string" ? result : _generateFieldError(ctx);
            errors22.push(message);
          }
          if (field.bails) {
            return {
              errors: errors22
            };
          }
        }
        return {
          errors: errors22
        };
      }
      const normalizedContext = Object.assign(Object.assign({}, field), { rules: normalizeRules(field.rules) });
      const errors2 = [];
      const rulesKeys = Object.keys(normalizedContext.rules);
      const length = rulesKeys.length;
      for (let i2 = 0; i2 < length; i2++) {
        const rule = rulesKeys[i2];
        const result = await _test(normalizedContext, value, {
          name: rule,
          params: normalizedContext.rules[rule]
        });
        if (result.error) {
          errors2.push(result.error);
          if (field.bails) {
            return {
              errors: errors2
            };
          }
        }
      }
      return {
        errors: errors2
      };
    }
    function isYupError(err) {
      return !!err && err.name === "ValidationError";
    }
    function yupToTypedSchema(yupSchema) {
      const schema = {
        __type: "VVTypedSchema",
        async parse(values) {
          var _a2;
          try {
            const output = await yupSchema.validate(values, { abortEarly: false });
            return {
              output,
              errors: []
            };
          } catch (err) {
            if (!isYupError(err)) {
              throw err;
            }
            if (!((_a2 = err.inner) === null || _a2 === void 0 ? void 0 : _a2.length) && err.errors.length) {
              return { errors: [{ path: err.path, errors: err.errors }] };
            }
            const errors2 = err.inner.reduce((acc, curr) => {
              const path = curr.path || "";
              if (!acc[path]) {
                acc[path] = { errors: [], path };
              }
              acc[path].errors.push(...curr.errors);
              return acc;
            }, {});
            return { errors: Object.values(errors2) };
          }
        }
      };
      return schema;
    }
    async function validateFieldWithTypedSchema(value, schema) {
      const typedSchema = isTypedSchema(schema) ? schema : yupToTypedSchema(schema);
      const result = await typedSchema.parse(value);
      const messages = [];
      for (const error2 of result.errors) {
        if (error2.errors.length) {
          messages.push(...error2.errors);
        }
      }
      return {
        errors: messages
      };
    }
    async function _test(field, value, rule) {
      const validator = resolveRule(rule.name);
      if (!validator) {
        throw new Error(`No such validator '${rule.name}' exists.`);
      }
      const params = fillTargetValues(rule.params, field.formData);
      const ctx = {
        field: field.label || field.name,
        name: field.name,
        label: field.label,
        value,
        form: field.formData,
        rule: Object.assign(Object.assign({}, rule), { params })
      };
      const result = await validator(value, params, ctx);
      if (typeof result === "string") {
        return {
          error: result
        };
      }
      return {
        error: result ? void 0 : _generateFieldError(ctx)
      };
    }
    function _generateFieldError(fieldCtx) {
      const message = getConfig().generateMessage;
      if (!message) {
        return "Field is invalid";
      }
      return message(fieldCtx);
    }
    function fillTargetValues(params, crossTable) {
      const normalize2 = (value) => {
        if (isLocator(value)) {
          return value(crossTable);
        }
        return value;
      };
      if (Array.isArray(params)) {
        return params.map(normalize2);
      }
      return Object.keys(params).reduce((acc, param) => {
        acc[param] = normalize2(params[param]);
        return acc;
      }, {});
    }
    async function validateTypedSchema(schema, values) {
      const typedSchema = isTypedSchema(schema) ? schema : yupToTypedSchema(schema);
      const validationResult = await typedSchema.parse(klona(values));
      const results = {};
      const errors2 = {};
      for (const error2 of validationResult.errors) {
        const messages = error2.errors;
        const path = (error2.path || "").replace(/\["(\d+)"\]/g, (_, m) => {
          return `[${m}]`;
        });
        results[path] = { valid: !messages.length, errors: messages };
        if (messages.length) {
          errors2[path] = messages[0];
        }
      }
      return {
        valid: !validationResult.errors.length,
        results,
        errors: errors2,
        values: validationResult.value
      };
    }
    async function validateObjectSchema(schema, values, opts) {
      const paths = keysOf(schema);
      const validations = paths.map(async (path) => {
        var _a2, _b, _c;
        const strings = (_a2 = opts === null || opts === void 0 ? void 0 : opts.names) === null || _a2 === void 0 ? void 0 : _a2[path];
        const fieldResult = await validate$1(getFromPath(values, path), schema[path], {
          name: (strings === null || strings === void 0 ? void 0 : strings.name) || path,
          label: strings === null || strings === void 0 ? void 0 : strings.label,
          values,
          bails: (_c = (_b = opts === null || opts === void 0 ? void 0 : opts.bailsMap) === null || _b === void 0 ? void 0 : _b[path]) !== null && _c !== void 0 ? _c : true
        });
        return Object.assign(Object.assign({}, fieldResult), { path });
      });
      let isAllValid = true;
      const validationResults = await Promise.all(validations);
      const results = {};
      const errors2 = {};
      for (const result of validationResults) {
        results[result.path] = {
          valid: result.valid,
          errors: result.errors
        };
        if (!result.valid) {
          isAllValid = false;
          errors2[result.path] = result.errors[0];
        }
      }
      return {
        valid: isAllValid,
        results,
        errors: errors2
      };
    }
    let ID_COUNTER = 0;
    function useFieldState(path, init) {
      const { value, initialValue, setInitialValue } = _useFieldValue(path, init.modelValue, init.form);
      if (!init.form) {
        let setState2 = function(state2) {
          var _a2;
          if ("value" in state2) {
            value.value = state2.value;
          }
          if ("errors" in state2) {
            setErrors(state2.errors);
          }
          if ("touched" in state2) {
            meta.touched = (_a2 = state2.touched) !== null && _a2 !== void 0 ? _a2 : meta.touched;
          }
          if ("initialValue" in state2) {
            setInitialValue(state2.initialValue);
          }
        };
        const { errors: errors22, setErrors } = createFieldErrors();
        const id2 = ID_COUNTER >= Number.MAX_SAFE_INTEGER ? 0 : ++ID_COUNTER;
        const meta = createFieldMeta(value, initialValue, errors22, init.schema);
        return {
          id: id2,
          path,
          value,
          initialValue,
          meta,
          flags: { pendingUnmount: { [id2]: false }, pendingReset: false },
          errors: errors22,
          setState: setState2
        };
      }
      const state = init.form.createPathState(path, {
        bails: init.bails,
        label: init.label,
        type: init.type,
        validate: init.validate,
        schema: init.schema
      });
      const errors2 = computed(() => state.errors);
      function setState(state2) {
        var _a2, _b, _c;
        if ("value" in state2) {
          value.value = state2.value;
        }
        if ("errors" in state2) {
          (_a2 = init.form) === null || _a2 === void 0 ? void 0 : _a2.setFieldError(unref(path), state2.errors);
        }
        if ("touched" in state2) {
          (_b = init.form) === null || _b === void 0 ? void 0 : _b.setFieldTouched(unref(path), (_c = state2.touched) !== null && _c !== void 0 ? _c : false);
        }
        if ("initialValue" in state2) {
          setInitialValue(state2.initialValue);
        }
      }
      return {
        id: Array.isArray(state.id) ? state.id[state.id.length - 1] : state.id,
        path,
        value,
        errors: errors2,
        meta: state,
        initialValue,
        flags: state.__flags,
        setState
      };
    }
    function _useFieldValue(path, modelValue, form) {
      const modelRef = ref$1(unref(modelValue));
      function resolveInitialValue2() {
        if (!form) {
          return unref(modelRef);
        }
        return getFromPath(form.initialValues.value, unref(path), unref(modelRef));
      }
      function setInitialValue(value2) {
        if (!form) {
          modelRef.value = value2;
          return;
        }
        form.setFieldInitialValue(unref(path), value2, true);
      }
      const initialValue = computed(resolveInitialValue2);
      if (!form) {
        const value2 = ref$1(resolveInitialValue2());
        return {
          value: value2,
          initialValue,
          setInitialValue
        };
      }
      const currentValue = resolveModelValue(modelValue, form, initialValue, path);
      form.stageInitialValue(unref(path), currentValue, true);
      const value = computed({
        get() {
          return getFromPath(form.values, unref(path));
        },
        set(newVal) {
          form.setFieldValue(unref(path), newVal, false);
        }
      });
      return {
        value,
        initialValue,
        setInitialValue
      };
    }
    function resolveModelValue(modelValue, form, initialValue, path) {
      if (isRef(modelValue)) {
        return unref(modelValue);
      }
      if (modelValue !== void 0) {
        return modelValue;
      }
      return getFromPath(form.values, unref(path), unref(initialValue));
    }
    function createFieldMeta(currentValue, initialValue, errors2, schema) {
      var _a2, _b;
      const isRequired = (_b = (_a2 = schema === null || schema === void 0 ? void 0 : schema.describe) === null || _a2 === void 0 ? void 0 : _a2.call(schema).required) !== null && _b !== void 0 ? _b : false;
      const meta = reactive({
        touched: false,
        pending: false,
        valid: true,
        required: isRequired,
        validated: !!unref(errors2).length,
        initialValue: computed(() => unref(initialValue)),
        dirty: computed(() => {
          return !isEqual(unref(currentValue), unref(initialValue));
        })
      });
      watch(errors2, (value) => {
        meta.valid = !value.length;
      }, {
        immediate: true,
        flush: "sync"
      });
      return meta;
    }
    function createFieldErrors() {
      const errors2 = ref$1([]);
      return {
        errors: errors2,
        setErrors: (messages) => {
          errors2.value = normalizeErrorItem(messages);
        }
      };
    }
    function useField(path, rules2, opts) {
      if (hasCheckedAttr(opts === null || opts === void 0 ? void 0 : opts.type)) {
        return useFieldWithChecked(path, rules2, opts);
      }
      return _useField(path, rules2, opts);
    }
    function _useField(path, rules2, opts) {
      const { initialValue: modelValue, validateOnMount, bails, type: type2, checkedValue, label, validateOnValueUpdate, uncheckedValue, controlled, keepValueOnUnmount, syncVModel, form: controlForm } = normalizeOptions(opts);
      const injectedForm = controlled ? injectWithSelf(FormContextKey) : void 0;
      const form = controlForm || injectedForm;
      const name = computed(() => normalizeFormPath(toValue$1(path)));
      const validator = computed(() => {
        const schema = toValue$1(form === null || form === void 0 ? void 0 : form.schema);
        if (schema) {
          return void 0;
        }
        const rulesValue = unref(rules2);
        if (isYupValidator(rulesValue) || isTypedSchema(rulesValue) || isCallable(rulesValue) || Array.isArray(rulesValue)) {
          return rulesValue;
        }
        return normalizeRules(rulesValue);
      });
      const { id: id2, value, initialValue, meta, setState, errors: errors2, flags } = useFieldState(name, {
        modelValue,
        form,
        bails,
        label,
        type: type2,
        validate: validator.value ? validate$1$1 : void 0,
        schema: isTypedSchema(rules2) ? rules2 : void 0
      });
      const errorMessage = computed(() => errors2.value[0]);
      if (syncVModel) {
        useVModel({
          value,
          prop: syncVModel,
          handleChange,
          shouldValidate: () => validateOnValueUpdate && !flags.pendingReset
        });
      }
      const handleBlur = (evt, shouldValidate = false) => {
        meta.touched = true;
        if (shouldValidate) {
          validateWithStateMutation();
        }
      };
      async function validateCurrentValue(mode) {
        var _a2, _b;
        if (form === null || form === void 0 ? void 0 : form.validateSchema) {
          const { results } = await form.validateSchema(mode);
          return (_a2 = results[toValue$1(name)]) !== null && _a2 !== void 0 ? _a2 : { valid: true, errors: [] };
        }
        if (validator.value) {
          return validate$1(value.value, validator.value, {
            name: toValue$1(name),
            label: toValue$1(label),
            values: (_b = form === null || form === void 0 ? void 0 : form.values) !== null && _b !== void 0 ? _b : {},
            bails
          });
        }
        return { valid: true, errors: [] };
      }
      const validateWithStateMutation = withLatest(async () => {
        meta.pending = true;
        meta.validated = true;
        return validateCurrentValue("validated-only");
      }, (result) => {
        if (flags.pendingUnmount[field.id]) {
          return result;
        }
        setState({ errors: result.errors });
        meta.pending = false;
        meta.valid = result.valid;
        return result;
      });
      const validateValidStateOnly = withLatest(async () => {
        return validateCurrentValue("silent");
      }, (result) => {
        meta.valid = result.valid;
        return result;
      });
      function validate$1$1(opts2) {
        if ((opts2 === null || opts2 === void 0 ? void 0 : opts2.mode) === "silent") {
          return validateValidStateOnly();
        }
        return validateWithStateMutation();
      }
      function handleChange(e, shouldValidate = true) {
        const newValue = normalizeEventValue(e);
        setValue(newValue, shouldValidate);
      }
      onMounted(() => {
        if (validateOnMount) {
          return validateWithStateMutation();
        }
        if (!form || !form.validateSchema) {
          validateValidStateOnly();
        }
      });
      function setTouched(isTouched) {
        meta.touched = isTouched;
      }
      function resetField(state) {
        var _a2;
        const newValue = state && "value" in state ? state.value : initialValue.value;
        setState({
          value: klona(newValue),
          initialValue: klona(newValue),
          touched: (_a2 = state === null || state === void 0 ? void 0 : state.touched) !== null && _a2 !== void 0 ? _a2 : false,
          errors: (state === null || state === void 0 ? void 0 : state.errors) || []
        });
        meta.pending = false;
        meta.validated = false;
        validateValidStateOnly();
      }
      const vm = getCurrentInstance$1();
      function setValue(newValue, shouldValidate = true) {
        value.value = vm && syncVModel ? applyModelModifiers(newValue, vm.props.modelModifiers) : newValue;
        const validateFn = shouldValidate ? validateWithStateMutation : validateValidStateOnly;
        validateFn();
      }
      function setErrors(errors22) {
        setState({ errors: Array.isArray(errors22) ? errors22 : [errors22] });
      }
      const valueProxy = computed({
        get() {
          return value.value;
        },
        set(newValue) {
          setValue(newValue, validateOnValueUpdate);
        }
      });
      const field = {
        id: id2,
        name,
        label,
        value: valueProxy,
        meta,
        errors: errors2,
        errorMessage,
        type: type2,
        checkedValue,
        uncheckedValue,
        bails,
        keepValueOnUnmount,
        resetField,
        handleReset: () => resetField(),
        validate: validate$1$1,
        handleChange,
        handleBlur,
        setState,
        setTouched,
        setErrors,
        setValue
      };
      provide(FieldContextKey, field);
      if (isRef(rules2) && typeof unref(rules2) !== "function") {
        watch(rules2, (value2, oldValue) => {
          if (isEqual(value2, oldValue)) {
            return;
          }
          meta.validated ? validateWithStateMutation() : validateValidStateOnly();
        }, {
          deep: true
        });
      }
      if (!form) {
        return field;
      }
      const dependencies2 = computed(() => {
        const rulesVal = validator.value;
        if (!rulesVal || isCallable(rulesVal) || isYupValidator(rulesVal) || isTypedSchema(rulesVal) || Array.isArray(rulesVal)) {
          return {};
        }
        return Object.keys(rulesVal).reduce((acc, rule) => {
          const deps = extractLocators(rulesVal[rule]).map((dep) => dep.__locatorRef).reduce((depAcc, depName) => {
            const depValue = getFromPath(form.values, depName) || form.values[depName];
            if (depValue !== void 0) {
              depAcc[depName] = depValue;
            }
            return depAcc;
          }, {});
          Object.assign(acc, deps);
          return acc;
        }, {});
      });
      watch(dependencies2, (deps, oldDeps) => {
        if (!Object.keys(deps).length) {
          return;
        }
        const shouldValidate = !isEqual(deps, oldDeps);
        if (shouldValidate) {
          meta.validated ? validateWithStateMutation() : validateValidStateOnly();
        }
      });
      onBeforeUnmount(() => {
        var _a2;
        const shouldKeepValue = (_a2 = toValue$1(field.keepValueOnUnmount)) !== null && _a2 !== void 0 ? _a2 : toValue$1(form.keepValuesOnUnmount);
        const path2 = toValue$1(name);
        if (shouldKeepValue || !form || flags.pendingUnmount[field.id]) {
          form === null || form === void 0 ? void 0 : form.removePathState(path2, id2);
          return;
        }
        flags.pendingUnmount[field.id] = true;
        const pathState = form.getPathState(path2);
        const matchesId = Array.isArray(pathState === null || pathState === void 0 ? void 0 : pathState.id) && (pathState === null || pathState === void 0 ? void 0 : pathState.multiple) ? pathState === null || pathState === void 0 ? void 0 : pathState.id.includes(field.id) : (pathState === null || pathState === void 0 ? void 0 : pathState.id) === field.id;
        if (!matchesId) {
          return;
        }
        if ((pathState === null || pathState === void 0 ? void 0 : pathState.multiple) && Array.isArray(pathState.value)) {
          const valueIdx = pathState.value.findIndex((i2) => isEqual(i2, toValue$1(field.checkedValue)));
          if (valueIdx > -1) {
            const newVal = [...pathState.value];
            newVal.splice(valueIdx, 1);
            form.setFieldValue(path2, newVal);
          }
          if (Array.isArray(pathState.id)) {
            pathState.id.splice(pathState.id.indexOf(field.id), 1);
          }
        } else {
          form.unsetPathValue(toValue$1(name));
        }
        form.removePathState(path2, id2);
      });
      return field;
    }
    function normalizeOptions(opts) {
      const defaults2 = () => ({
        initialValue: void 0,
        validateOnMount: false,
        bails: true,
        label: void 0,
        validateOnValueUpdate: true,
        keepValueOnUnmount: void 0,
        syncVModel: false,
        controlled: true
      });
      const isVModelSynced = !!(opts === null || opts === void 0 ? void 0 : opts.syncVModel);
      const modelPropName = typeof (opts === null || opts === void 0 ? void 0 : opts.syncVModel) === "string" ? opts.syncVModel : (opts === null || opts === void 0 ? void 0 : opts.modelPropName) || "modelValue";
      const initialValue = isVModelSynced && !("initialValue" in (opts || {})) ? getCurrentModelValue(getCurrentInstance$1(), modelPropName) : opts === null || opts === void 0 ? void 0 : opts.initialValue;
      if (!opts) {
        return Object.assign(Object.assign({}, defaults2()), { initialValue });
      }
      const checkedValue = "valueProp" in opts ? opts.valueProp : opts.checkedValue;
      const controlled = "standalone" in opts ? !opts.standalone : opts.controlled;
      const syncVModel = (opts === null || opts === void 0 ? void 0 : opts.modelPropName) || (opts === null || opts === void 0 ? void 0 : opts.syncVModel) || false;
      return Object.assign(Object.assign(Object.assign({}, defaults2()), opts || {}), {
        initialValue,
        controlled: controlled !== null && controlled !== void 0 ? controlled : true,
        checkedValue,
        syncVModel
      });
    }
    function useFieldWithChecked(name, rules2, opts) {
      const form = !(opts === null || opts === void 0 ? void 0 : opts.standalone) ? injectWithSelf(FormContextKey) : void 0;
      const checkedValue = opts === null || opts === void 0 ? void 0 : opts.checkedValue;
      const uncheckedValue = opts === null || opts === void 0 ? void 0 : opts.uncheckedValue;
      function patchCheckedApi(field) {
        const handleChange = field.handleChange;
        const checked = computed(() => {
          const currentValue = toValue$1(field.value);
          const checkedVal = toValue$1(checkedValue);
          return Array.isArray(currentValue) ? currentValue.findIndex((v) => isEqual(v, checkedVal)) >= 0 : isEqual(checkedVal, currentValue);
        });
        function handleCheckboxChange(e, shouldValidate = true) {
          var _a2, _b;
          if (checked.value === ((_a2 = e === null || e === void 0 ? void 0 : e.target) === null || _a2 === void 0 ? void 0 : _a2.checked)) {
            if (shouldValidate) {
              field.validate();
            }
            return;
          }
          const path = toValue$1(name);
          const pathState = form === null || form === void 0 ? void 0 : form.getPathState(path);
          const value = normalizeEventValue(e);
          let newValue = (_b = toValue$1(checkedValue)) !== null && _b !== void 0 ? _b : value;
          if (form && (pathState === null || pathState === void 0 ? void 0 : pathState.multiple) && pathState.type === "checkbox") {
            newValue = resolveNextCheckboxValue(getFromPath(form.values, path) || [], newValue, void 0);
          } else if ((opts === null || opts === void 0 ? void 0 : opts.type) === "checkbox") {
            newValue = resolveNextCheckboxValue(toValue$1(field.value), newValue, toValue$1(uncheckedValue));
          }
          handleChange(newValue, shouldValidate);
        }
        return Object.assign(Object.assign({}, field), {
          checked,
          checkedValue,
          uncheckedValue,
          handleChange: handleCheckboxChange
        });
      }
      return patchCheckedApi(_useField(name, rules2, opts));
    }
    function useVModel({ prop: prop2, value, handleChange, shouldValidate }) {
      const vm = getCurrentInstance$1();
      if (!vm || !prop2) {
        return;
      }
      const propName = typeof prop2 === "string" ? prop2 : "modelValue";
      const emitName = `update:${propName}`;
      if (!(propName in vm.props)) {
        return;
      }
      watch(value, (newValue) => {
        if (isEqual(newValue, getCurrentModelValue(vm, propName))) {
          return;
        }
        vm.emit(emitName, newValue);
      });
      watch(() => getCurrentModelValue(vm, propName), (propValue) => {
        if (propValue === IS_ABSENT && value.value === void 0) {
          return;
        }
        const newValue = propValue === IS_ABSENT ? void 0 : propValue;
        if (isEqual(newValue, value.value)) {
          return;
        }
        handleChange(newValue, shouldValidate());
      });
    }
    function getCurrentModelValue(vm, propName) {
      if (!vm) {
        return void 0;
      }
      return vm.props[propName];
    }
    let FORM_COUNTER = 0;
    const PRIVATE_PATH_STATE_KEYS = ["bails", "fieldsCount", "id", "multiple", "type", "validate"];
    function resolveInitialValues(opts) {
      const providedValues = Object.assign({}, toValue$1((opts === null || opts === void 0 ? void 0 : opts.initialValues) || {}));
      const schema = unref(opts === null || opts === void 0 ? void 0 : opts.validationSchema);
      if (schema && isTypedSchema(schema) && isCallable(schema.cast)) {
        return klona(schema.cast(providedValues) || {});
      }
      return klona(providedValues);
    }
    function useForm$1(opts) {
      var _a2;
      const formId = FORM_COUNTER++;
      let FIELD_ID_COUNTER = 0;
      const isSubmitting = ref$1(false);
      const isValidating = ref$1(false);
      const submitCount = ref$1(0);
      const fieldArrays = [];
      const formValues = reactive(resolveInitialValues(opts));
      const pathStates = ref$1([]);
      const extraErrorsBag = ref$1({});
      const pathStateLookup = ref$1({});
      const rebuildPathLookup = debounceNextTick(() => {
        pathStateLookup.value = pathStates.value.reduce((names2, state) => {
          names2[normalizeFormPath(toValue$1(state.path))] = state;
          return names2;
        }, {});
      });
      function setFieldError(field, message) {
        const state = findPathState(field);
        if (!state) {
          if (typeof field === "string") {
            extraErrorsBag.value[normalizeFormPath(field)] = normalizeErrorItem(message);
          }
          return;
        }
        if (typeof field === "string") {
          const normalizedPath = normalizeFormPath(field);
          if (extraErrorsBag.value[normalizedPath]) {
            delete extraErrorsBag.value[normalizedPath];
          }
        }
        state.errors = normalizeErrorItem(message);
        state.valid = !state.errors.length;
      }
      function setErrors(paths) {
        keysOf(paths).forEach((path) => {
          setFieldError(path, paths[path]);
        });
      }
      if (opts === null || opts === void 0 ? void 0 : opts.initialErrors) {
        setErrors(opts.initialErrors);
      }
      const errorBag = computed(() => {
        const pathErrors = pathStates.value.reduce((acc, state) => {
          if (state.errors.length) {
            acc[state.path] = state.errors;
          }
          return acc;
        }, {});
        return Object.assign(Object.assign({}, extraErrorsBag.value), pathErrors);
      });
      const errors2 = computed(() => {
        return keysOf(errorBag.value).reduce((acc, key) => {
          const errors22 = errorBag.value[key];
          if (errors22 === null || errors22 === void 0 ? void 0 : errors22.length) {
            acc[key] = errors22[0];
          }
          return acc;
        }, {});
      });
      const fieldNames = computed(() => {
        return pathStates.value.reduce((names2, state) => {
          names2[state.path] = { name: state.path || "", label: state.label || "" };
          return names2;
        }, {});
      });
      const fieldBailsMap = computed(() => {
        return pathStates.value.reduce((map2, state) => {
          var _a22;
          map2[state.path] = (_a22 = state.bails) !== null && _a22 !== void 0 ? _a22 : true;
          return map2;
        }, {});
      });
      const initialErrors = Object.assign({}, (opts === null || opts === void 0 ? void 0 : opts.initialErrors) || {});
      const keepValuesOnUnmount = (_a2 = opts === null || opts === void 0 ? void 0 : opts.keepValuesOnUnmount) !== null && _a2 !== void 0 ? _a2 : false;
      const { initialValues, originalInitialValues, setInitialValues } = useFormInitialValues(pathStates, formValues, opts);
      const meta = useFormMeta(pathStates, formValues, originalInitialValues, errors2);
      const controlledValues = computed(() => {
        return pathStates.value.reduce((acc, state) => {
          const value = getFromPath(formValues, state.path);
          setInPath(acc, state.path, value);
          return acc;
        }, {});
      });
      const schema = opts === null || opts === void 0 ? void 0 : opts.validationSchema;
      function createPathState(path, config2) {
        var _a22, _b;
        const initialValue = computed(() => getFromPath(initialValues.value, toValue$1(path)));
        const pathStateExists = pathStateLookup.value[toValue$1(path)];
        const isCheckboxOrRadio = (config2 === null || config2 === void 0 ? void 0 : config2.type) === "checkbox" || (config2 === null || config2 === void 0 ? void 0 : config2.type) === "radio";
        if (pathStateExists && isCheckboxOrRadio) {
          pathStateExists.multiple = true;
          const id22 = FIELD_ID_COUNTER++;
          if (Array.isArray(pathStateExists.id)) {
            pathStateExists.id.push(id22);
          } else {
            pathStateExists.id = [pathStateExists.id, id22];
          }
          pathStateExists.fieldsCount++;
          pathStateExists.__flags.pendingUnmount[id22] = false;
          return pathStateExists;
        }
        const currentValue = computed(() => getFromPath(formValues, toValue$1(path)));
        const pathValue = toValue$1(path);
        const unsetBatchIndex = UNSET_BATCH.findIndex((_path) => _path === pathValue);
        if (unsetBatchIndex !== -1) {
          UNSET_BATCH.splice(unsetBatchIndex, 1);
        }
        const isRequired = computed(() => {
          var _a3, _b2, _c, _d, _e, _f;
          if (isTypedSchema(schema)) {
            return (_c = (_b2 = (_a3 = schema).describe) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, toValue$1(path)).required) !== null && _c !== void 0 ? _c : false;
          }
          if (isTypedSchema(config2 === null || config2 === void 0 ? void 0 : config2.schema)) {
            return (_f = (_e = (_d = config2 === null || config2 === void 0 ? void 0 : config2.schema).describe) === null || _e === void 0 ? void 0 : _e.call(_d).required) !== null && _f !== void 0 ? _f : false;
          }
          return false;
        });
        const id2 = FIELD_ID_COUNTER++;
        const state = reactive({
          id: id2,
          path,
          touched: false,
          pending: false,
          valid: true,
          validated: !!((_a22 = initialErrors[pathValue]) === null || _a22 === void 0 ? void 0 : _a22.length),
          required: isRequired,
          initialValue,
          errors: shallowRef([]),
          bails: (_b = config2 === null || config2 === void 0 ? void 0 : config2.bails) !== null && _b !== void 0 ? _b : false,
          label: config2 === null || config2 === void 0 ? void 0 : config2.label,
          type: (config2 === null || config2 === void 0 ? void 0 : config2.type) || "default",
          value: currentValue,
          multiple: false,
          __flags: {
            pendingUnmount: { [id2]: false },
            pendingReset: false
          },
          fieldsCount: 1,
          validate: config2 === null || config2 === void 0 ? void 0 : config2.validate,
          dirty: computed(() => {
            return !isEqual(unref(currentValue), unref(initialValue));
          })
        });
        pathStates.value.push(state);
        pathStateLookup.value[pathValue] = state;
        rebuildPathLookup();
        if (errors2.value[pathValue] && !initialErrors[pathValue]) {
          nextTick(() => {
            validateField(pathValue, { mode: "silent" });
          });
        }
        if (isRef(path)) {
          watch(path, (newPath) => {
            rebuildPathLookup();
            const nextValue = klona(currentValue.value);
            pathStateLookup.value[newPath] = state;
            nextTick(() => {
              setInPath(formValues, newPath, nextValue);
            });
          });
        }
        return state;
      }
      const debouncedSilentValidation = debounceAsync(_validateSchema, 5);
      const debouncedValidation = debounceAsync(_validateSchema, 5);
      const validateSchema = withLatest(async (mode) => {
        return await (mode === "silent" ? debouncedSilentValidation() : debouncedValidation());
      }, (formResult, [mode]) => {
        const currentErrorsPaths = keysOf(formCtx.errorBag.value);
        const paths = [
          .../* @__PURE__ */ new Set([...keysOf(formResult.results), ...pathStates.value.map((p2) => p2.path), ...currentErrorsPaths])
        ].sort();
        const results = paths.reduce((validation2, _path) => {
          var _a22;
          const expectedPath = _path;
          const pathState = findPathState(expectedPath) || findHoistedPath(expectedPath);
          const messages = ((_a22 = formResult.results[expectedPath]) === null || _a22 === void 0 ? void 0 : _a22.errors) || [];
          const path = toValue$1(pathState === null || pathState === void 0 ? void 0 : pathState.path) || expectedPath;
          const fieldResult = mergeValidationResults({ errors: messages, valid: !messages.length }, validation2.results[path]);
          validation2.results[path] = fieldResult;
          if (!fieldResult.valid) {
            validation2.errors[path] = fieldResult.errors[0];
          }
          if (pathState && extraErrorsBag.value[path]) {
            delete extraErrorsBag.value[path];
          }
          if (!pathState) {
            setFieldError(path, messages);
            return validation2;
          }
          pathState.valid = fieldResult.valid;
          if (mode === "silent") {
            return validation2;
          }
          if (mode === "validated-only" && !pathState.validated) {
            return validation2;
          }
          setFieldError(pathState, fieldResult.errors);
          return validation2;
        }, { valid: formResult.valid, results: {}, errors: {} });
        if (formResult.values) {
          results.values = formResult.values;
        }
        keysOf(results.results).forEach((path) => {
          var _a22;
          const pathState = findPathState(path);
          if (!pathState) {
            return;
          }
          if (mode === "silent") {
            return;
          }
          if (mode === "validated-only" && !pathState.validated) {
            return;
          }
          setFieldError(pathState, (_a22 = results.results[path]) === null || _a22 === void 0 ? void 0 : _a22.errors);
        });
        return results;
      });
      function mutateAllPathState(mutation) {
        pathStates.value.forEach(mutation);
      }
      function findPathState(path) {
        const normalizedPath = typeof path === "string" ? normalizeFormPath(path) : path;
        const pathState = typeof normalizedPath === "string" ? pathStateLookup.value[normalizedPath] : normalizedPath;
        return pathState;
      }
      function findHoistedPath(path) {
        const candidates = pathStates.value.filter((state) => path.startsWith(state.path));
        return candidates.reduce((bestCandidate, candidate) => {
          if (!bestCandidate) {
            return candidate;
          }
          return candidate.path.length > bestCandidate.path.length ? candidate : bestCandidate;
        }, void 0);
      }
      let UNSET_BATCH = [];
      let PENDING_UNSET;
      function unsetPathValue(path) {
        UNSET_BATCH.push(path);
        if (!PENDING_UNSET) {
          PENDING_UNSET = nextTick(() => {
            const sortedPaths = [...UNSET_BATCH].sort().reverse();
            sortedPaths.forEach((p2) => {
              unsetPath(formValues, p2);
            });
            UNSET_BATCH = [];
            PENDING_UNSET = null;
          });
        }
        return PENDING_UNSET;
      }
      function makeSubmissionFactory(onlyControlled) {
        return function submitHandlerFactory(fn, onValidationError) {
          return function submissionHandler(e) {
            if (e instanceof Event) {
              e.preventDefault();
              e.stopPropagation();
            }
            mutateAllPathState((s) => s.touched = true);
            isSubmitting.value = true;
            submitCount.value++;
            return validate2().then((result) => {
              const values = klona(formValues);
              if (result.valid && typeof fn === "function") {
                const controlled = klona(controlledValues.value);
                let submittedValues = onlyControlled ? controlled : values;
                if (result.values) {
                  submittedValues = result.values;
                }
                return fn(submittedValues, {
                  evt: e,
                  controlledValues: controlled,
                  setErrors,
                  setFieldError,
                  setTouched,
                  setFieldTouched,
                  setValues,
                  setFieldValue,
                  resetForm,
                  resetField
                });
              }
              if (!result.valid && typeof onValidationError === "function") {
                onValidationError({
                  values,
                  evt: e,
                  errors: result.errors,
                  results: result.results
                });
              }
            }).then((returnVal) => {
              isSubmitting.value = false;
              return returnVal;
            }, (err) => {
              isSubmitting.value = false;
              throw err;
            });
          };
        };
      }
      const handleSubmitImpl = makeSubmissionFactory(false);
      const handleSubmit = handleSubmitImpl;
      handleSubmit.withControlled = makeSubmissionFactory(true);
      function removePathState(path, id2) {
        const idx = pathStates.value.findIndex((s) => {
          return s.path === path && (Array.isArray(s.id) ? s.id.includes(id2) : s.id === id2);
        });
        const pathState = pathStates.value[idx];
        if (idx === -1 || !pathState) {
          return;
        }
        nextTick(() => {
          validateField(path, { mode: "silent", warn: false });
        });
        if (pathState.multiple && pathState.fieldsCount) {
          pathState.fieldsCount--;
        }
        if (Array.isArray(pathState.id)) {
          const idIndex = pathState.id.indexOf(id2);
          if (idIndex >= 0) {
            pathState.id.splice(idIndex, 1);
          }
          delete pathState.__flags.pendingUnmount[id2];
        }
        if (!pathState.multiple || pathState.fieldsCount <= 0) {
          pathStates.value.splice(idx, 1);
          unsetInitialValue(path);
          rebuildPathLookup();
          delete pathStateLookup.value[path];
        }
      }
      function destroyPath(path) {
        keysOf(pathStateLookup.value).forEach((key) => {
          if (key.startsWith(path)) {
            delete pathStateLookup.value[key];
          }
        });
        pathStates.value = pathStates.value.filter((s) => !s.path.startsWith(path));
        nextTick(() => {
          rebuildPathLookup();
        });
      }
      const formCtx = {
        formId,
        values: formValues,
        controlledValues,
        errorBag,
        errors: errors2,
        schema,
        submitCount,
        meta,
        isSubmitting,
        isValidating,
        fieldArrays,
        keepValuesOnUnmount,
        validateSchema: unref(schema) ? validateSchema : void 0,
        validate: validate2,
        setFieldError,
        validateField,
        setFieldValue,
        setValues,
        setErrors,
        setFieldTouched,
        setTouched,
        resetForm,
        resetField,
        handleSubmit,
        useFieldModel,
        defineInputBinds,
        defineComponentBinds,
        defineField,
        stageInitialValue,
        unsetInitialValue,
        setFieldInitialValue,
        createPathState,
        getPathState: findPathState,
        unsetPathValue,
        removePathState,
        initialValues,
        getAllPathStates: () => pathStates.value,
        destroyPath,
        isFieldTouched,
        isFieldDirty,
        isFieldValid
      };
      function setFieldValue(field, value, shouldValidate = true) {
        const clonedValue = klona(value);
        const path = typeof field === "string" ? field : field.path;
        const pathState = findPathState(path);
        if (!pathState) {
          createPathState(path);
        }
        setInPath(formValues, path, clonedValue);
        if (shouldValidate) {
          validateField(path);
        }
      }
      function forceSetValues(fields, shouldValidate = true) {
        keysOf(formValues).forEach((key) => {
          delete formValues[key];
        });
        keysOf(fields).forEach((path) => {
          setFieldValue(path, fields[path], false);
        });
        if (shouldValidate) {
          validate2();
        }
      }
      function setValues(fields, shouldValidate = true) {
        merge(formValues, fields);
        fieldArrays.forEach((f) => f && f.reset());
        if (shouldValidate) {
          validate2();
        }
      }
      function createModel(path, shouldValidate) {
        const pathState = findPathState(toValue$1(path)) || createPathState(path);
        return computed({
          get() {
            return pathState.value;
          },
          set(value) {
            var _a22;
            const pathValue = toValue$1(path);
            setFieldValue(pathValue, value, (_a22 = toValue$1(shouldValidate)) !== null && _a22 !== void 0 ? _a22 : false);
          }
        });
      }
      function setFieldTouched(field, isTouched) {
        const pathState = findPathState(field);
        if (pathState) {
          pathState.touched = isTouched;
        }
      }
      function isFieldTouched(field) {
        const pathState = findPathState(field);
        if (pathState) {
          return pathState.touched;
        }
        return pathStates.value.filter((s) => s.path.startsWith(field)).some((s) => s.touched);
      }
      function isFieldDirty(field) {
        const pathState = findPathState(field);
        if (pathState) {
          return pathState.dirty;
        }
        return pathStates.value.filter((s) => s.path.startsWith(field)).some((s) => s.dirty);
      }
      function isFieldValid(field) {
        const pathState = findPathState(field);
        if (pathState) {
          return pathState.valid;
        }
        return pathStates.value.filter((s) => s.path.startsWith(field)).every((s) => s.valid);
      }
      function setTouched(fields) {
        if (typeof fields === "boolean") {
          mutateAllPathState((state) => {
            state.touched = fields;
          });
          return;
        }
        keysOf(fields).forEach((field) => {
          setFieldTouched(field, !!fields[field]);
        });
      }
      function resetField(field, state) {
        var _a22;
        const newValue = state && "value" in state ? state.value : getFromPath(initialValues.value, field);
        const pathState = findPathState(field);
        if (pathState) {
          pathState.__flags.pendingReset = true;
        }
        setFieldInitialValue(field, klona(newValue), true);
        setFieldValue(field, newValue, false);
        setFieldTouched(field, (_a22 = state === null || state === void 0 ? void 0 : state.touched) !== null && _a22 !== void 0 ? _a22 : false);
        setFieldError(field, (state === null || state === void 0 ? void 0 : state.errors) || []);
        nextTick(() => {
          if (pathState) {
            pathState.__flags.pendingReset = false;
          }
        });
      }
      function resetForm(resetState, opts2) {
        let newValues = klona((resetState === null || resetState === void 0 ? void 0 : resetState.values) ? resetState.values : originalInitialValues.value);
        newValues = (opts2 === null || opts2 === void 0 ? void 0 : opts2.force) ? newValues : merge(originalInitialValues.value, newValues);
        newValues = isTypedSchema(schema) && isCallable(schema.cast) ? schema.cast(newValues) : newValues;
        setInitialValues(newValues);
        mutateAllPathState((state) => {
          var _a22;
          state.__flags.pendingReset = true;
          state.validated = false;
          state.touched = ((_a22 = resetState === null || resetState === void 0 ? void 0 : resetState.touched) === null || _a22 === void 0 ? void 0 : _a22[state.path]) || false;
          setFieldValue(state.path, getFromPath(newValues, state.path), false);
          setFieldError(state.path, void 0);
        });
        (opts2 === null || opts2 === void 0 ? void 0 : opts2.force) ? forceSetValues(newValues, false) : setValues(newValues, false);
        setErrors((resetState === null || resetState === void 0 ? void 0 : resetState.errors) || {});
        submitCount.value = (resetState === null || resetState === void 0 ? void 0 : resetState.submitCount) || 0;
        nextTick(() => {
          validate2({ mode: "silent" });
          mutateAllPathState((state) => {
            state.__flags.pendingReset = false;
          });
        });
      }
      async function validate2(opts2) {
        const mode = (opts2 === null || opts2 === void 0 ? void 0 : opts2.mode) || "force";
        if (mode === "force") {
          mutateAllPathState((f) => f.validated = true);
        }
        if (formCtx.validateSchema) {
          return formCtx.validateSchema(mode);
        }
        isValidating.value = true;
        const validations = await Promise.all(pathStates.value.map((state) => {
          if (!state.validate) {
            return Promise.resolve({
              key: state.path,
              valid: true,
              errors: []
            });
          }
          return state.validate(opts2).then((result) => {
            return {
              key: state.path,
              valid: result.valid,
              errors: result.errors
            };
          });
        }));
        isValidating.value = false;
        const results = {};
        const errors22 = {};
        for (const validation2 of validations) {
          results[validation2.key] = {
            valid: validation2.valid,
            errors: validation2.errors
          };
          if (validation2.errors.length) {
            errors22[validation2.key] = validation2.errors[0];
          }
        }
        return {
          valid: validations.every((r) => r.valid),
          results,
          errors: errors22
        };
      }
      async function validateField(path, opts2) {
        var _a22;
        const state = findPathState(path);
        if (state && (opts2 === null || opts2 === void 0 ? void 0 : opts2.mode) !== "silent") {
          state.validated = true;
        }
        if (schema) {
          const { results } = await validateSchema((opts2 === null || opts2 === void 0 ? void 0 : opts2.mode) || "validated-only");
          return results[path] || { errors: [], valid: true };
        }
        if (state === null || state === void 0 ? void 0 : state.validate) {
          return state.validate(opts2);
        }
        !state && ((_a22 = opts2 === null || opts2 === void 0 ? void 0 : opts2.warn) !== null && _a22 !== void 0 ? _a22 : true);
        return Promise.resolve({ errors: [], valid: true });
      }
      function unsetInitialValue(path) {
        unsetPath(initialValues.value, path);
      }
      function stageInitialValue(path, value, updateOriginal = false) {
        setFieldInitialValue(path, value);
        setInPath(formValues, path, value);
        if (updateOriginal && !(opts === null || opts === void 0 ? void 0 : opts.initialValues)) {
          setInPath(originalInitialValues.value, path, klona(value));
        }
      }
      function setFieldInitialValue(path, value, updateOriginal = false) {
        setInPath(initialValues.value, path, klona(value));
        if (updateOriginal) {
          setInPath(originalInitialValues.value, path, klona(value));
        }
      }
      async function _validateSchema() {
        const schemaValue = unref(schema);
        if (!schemaValue) {
          return { valid: true, results: {}, errors: {} };
        }
        isValidating.value = true;
        const formResult = isYupValidator(schemaValue) || isTypedSchema(schemaValue) ? await validateTypedSchema(schemaValue, formValues) : await validateObjectSchema(schemaValue, formValues, {
          names: fieldNames.value,
          bailsMap: fieldBailsMap.value
        });
        isValidating.value = false;
        return formResult;
      }
      const submitForm = handleSubmit((_, { evt }) => {
        if (isFormSubmitEvent(evt)) {
          evt.target.submit();
        }
      });
      onMounted(() => {
        if (opts === null || opts === void 0 ? void 0 : opts.initialErrors) {
          setErrors(opts.initialErrors);
        }
        if (opts === null || opts === void 0 ? void 0 : opts.initialTouched) {
          setTouched(opts.initialTouched);
        }
        if (opts === null || opts === void 0 ? void 0 : opts.validateOnMount) {
          validate2();
          return;
        }
        if (formCtx.validateSchema) {
          formCtx.validateSchema("silent");
        }
      });
      if (isRef(schema)) {
        watch(schema, () => {
          var _a22;
          (_a22 = formCtx.validateSchema) === null || _a22 === void 0 ? void 0 : _a22.call(formCtx, "validated-only");
        });
      }
      provide(FormContextKey, formCtx);
      function defineField(path, config2) {
        const label = isCallable(config2) ? void 0 : config2 === null || config2 === void 0 ? void 0 : config2.label;
        const pathState = findPathState(toValue$1(path)) || createPathState(path, { label });
        const evalConfig = () => isCallable(config2) ? config2(omit(pathState, PRIVATE_PATH_STATE_KEYS)) : config2 || {};
        function onBlur() {
          var _a22;
          pathState.touched = true;
          const validateOnBlur = (_a22 = evalConfig().validateOnBlur) !== null && _a22 !== void 0 ? _a22 : getConfig().validateOnBlur;
          if (validateOnBlur) {
            validateField(pathState.path);
          }
        }
        function onInput() {
          var _a22;
          const validateOnInput = (_a22 = evalConfig().validateOnInput) !== null && _a22 !== void 0 ? _a22 : getConfig().validateOnInput;
          if (validateOnInput) {
            nextTick(() => {
              validateField(pathState.path);
            });
          }
        }
        function onChange() {
          var _a22;
          const validateOnChange = (_a22 = evalConfig().validateOnChange) !== null && _a22 !== void 0 ? _a22 : getConfig().validateOnChange;
          if (validateOnChange) {
            nextTick(() => {
              validateField(pathState.path);
            });
          }
        }
        const props = computed(() => {
          const base2 = {
            onChange,
            onInput,
            onBlur
          };
          if (isCallable(config2)) {
            return Object.assign(Object.assign({}, base2), config2(omit(pathState, PRIVATE_PATH_STATE_KEYS)).props || {});
          }
          if (config2 === null || config2 === void 0 ? void 0 : config2.props) {
            return Object.assign(Object.assign({}, base2), config2.props(omit(pathState, PRIVATE_PATH_STATE_KEYS)));
          }
          return base2;
        });
        const model = createModel(path, () => {
          var _a22, _b, _c;
          return (_c = (_a22 = evalConfig().validateOnModelUpdate) !== null && _a22 !== void 0 ? _a22 : (_b = getConfig()) === null || _b === void 0 ? void 0 : _b.validateOnModelUpdate) !== null && _c !== void 0 ? _c : true;
        });
        return [model, props];
      }
      function useFieldModel(pathOrPaths) {
        if (!Array.isArray(pathOrPaths)) {
          return createModel(pathOrPaths);
        }
        return pathOrPaths.map((p2) => createModel(p2, true));
      }
      function defineInputBinds(path, config2) {
        const [model, props] = defineField(path, config2);
        function onBlur() {
          props.value.onBlur();
        }
        function onInput(e) {
          const value = normalizeEventValue(e);
          setFieldValue(toValue$1(path), value, false);
          props.value.onInput();
        }
        function onChange(e) {
          const value = normalizeEventValue(e);
          setFieldValue(toValue$1(path), value, false);
          props.value.onChange();
        }
        return computed(() => {
          return Object.assign(Object.assign({}, props.value), {
            onBlur,
            onInput,
            onChange,
            value: model.value
          });
        });
      }
      function defineComponentBinds(path, config2) {
        const [model, props] = defineField(path, config2);
        const pathState = findPathState(toValue$1(path));
        function onUpdateModelValue(value) {
          model.value = value;
        }
        return computed(() => {
          const conf = isCallable(config2) ? config2(omit(pathState, PRIVATE_PATH_STATE_KEYS)) : config2 || {};
          return Object.assign({ [conf.model || "modelValue"]: model.value, [`onUpdate:${conf.model || "modelValue"}`]: onUpdateModelValue }, props.value);
        });
      }
      return Object.assign(Object.assign({}, formCtx), { values: readonly(formValues), handleReset: () => resetForm(), submitForm });
    }
    function useFormMeta(pathsState, currentValues, initialValues, errors2) {
      const MERGE_STRATEGIES = {
        touched: "some",
        pending: "some",
        valid: "every"
      };
      const isDirty = computed(() => {
        return !isEqual(currentValues, unref(initialValues));
      });
      function calculateFlags() {
        const states = pathsState.value;
        return keysOf(MERGE_STRATEGIES).reduce((acc, flag) => {
          const mergeMethod = MERGE_STRATEGIES[flag];
          acc[flag] = states[mergeMethod]((s) => s[flag]);
          return acc;
        }, {});
      }
      const flags = reactive(calculateFlags());
      watchEffect(() => {
        const value = calculateFlags();
        flags.touched = value.touched;
        flags.valid = value.valid;
        flags.pending = value.pending;
      });
      return computed(() => {
        return Object.assign(Object.assign({ initialValues: unref(initialValues) }, flags), { valid: flags.valid && !keysOf(errors2.value).length, dirty: isDirty.value });
      });
    }
    function useFormInitialValues(pathsState, formValues, opts) {
      const values = resolveInitialValues(opts);
      const initialValues = ref$1(values);
      const originalInitialValues = ref$1(klona(values));
      function setInitialValues(values2, updateFields = false) {
        initialValues.value = merge(klona(initialValues.value) || {}, klona(values2));
        originalInitialValues.value = merge(klona(originalInitialValues.value) || {}, klona(values2));
        if (!updateFields) {
          return;
        }
        pathsState.value.forEach((state) => {
          const wasTouched = state.touched;
          if (wasTouched) {
            return;
          }
          const newValue = getFromPath(initialValues.value, state.path);
          setInPath(formValues, state.path, klona(newValue));
        });
      }
      return {
        initialValues,
        originalInitialValues,
        setInitialValues
      };
    }
    function mergeValidationResults(a, b) {
      if (!b) {
        return a;
      }
      return {
        valid: a.valid && b.valid,
        errors: [...a.errors, ...b.errors]
      };
    }
    var ComponentViews = /* @__PURE__ */ ((ComponentViews2) => {
      ComponentViews2[ComponentViews2["LIST"] = 0] = "LIST";
      ComponentViews2[ComponentViews2["EDIT"] = 1] = "EDIT";
      ComponentViews2[ComponentViews2["ADD"] = 2] = "ADD";
      return ComponentViews2;
    })(ComponentViews || {});
    const _sfc_main$B = /* @__PURE__ */ defineComponent$1({
      setup() {
        const evbc2 = inject$1("evbc");
        const servers = reactive([
          {
            id: "Loopback",
            host: "loopback",
            editable: false,
            protocol: "ws",
            port: 8849
          },
          {
            id: "tzi",
            host: "oetzi.pionix.net",
            editable: true,
            protocol: "wss",
            port: 8849
          }
        ]);
        const currentView = ref$1(
          0
          /* LIST */
        );
        const connectAutomatically = ref$1(false);
        watch(connectAutomatically, () => {
          submitLocalStorageSettings();
        });
        const currentlyEditing = ref$1(null);
        const connecting = ref$1(false);
        const connectionStatus = ref$1(null);
        const error2 = reactive({ active: false, status: "" });
        const { meta, handleSubmit } = useForm$1({
          validationSchema: {
            instanceId: (value) => {
              if (value === void 0 || value.trim().length < 1) {
                return "Please enter a name with at least one character.";
              } else {
                return true;
              }
            },
            host: (value) => {
              if (value === void 0 || value.trim().length < 1) {
                return "Please enter a host.";
              }
              if (value.includes("://")) {
                return 'Please enter a domain without any protocol (e.g., "test.pionix.de").';
              }
              const domainPattern = /.*:\d+$/;
              if (domainPattern.test(value)) {
                return "Please don't enter a port here.";
              } else {
                return true;
              }
            },
            port: (value) => {
              if (value === void 0 || value < 1 || value > 65535) {
                return "Please enter a valid port number.";
              } else {
                return true;
              }
            }
          }
        });
        const instanceId = useField("instanceId");
        const host = useField("host");
        const port = useField("port");
        const protocol = useField("protocol");
        const openAddServerView = () => {
          resetFields();
          currentView.value = 2;
        };
        const resetFields = () => {
          instanceId.value.value = "";
          host.value.value = "";
          port.value.value = 8849;
          protocol.value.value = "ws";
          currentlyEditing.value = null;
        };
        const openEditServerView = (index) => {
          currentlyEditing.value = servers[index];
          protocol.value.value = servers[index].protocol;
          host.value.value = servers[index].host;
          port.value.value = servers[index].port;
          instanceId.value.value = servers[index].id;
          currentView.value = 1;
        };
        const submitEdit = handleSubmit(async () => {
          if (currentlyEditing.value !== null) {
            currentlyEditing.value.id = instanceId.value.value;
            currentlyEditing.value.host = host.value.value;
            currentlyEditing.value.protocol = protocol.value.value;
            currentlyEditing.value.port = port.value.value;
          } else {
            servers.push({
              id: instanceId.value.value,
              host: host.value.value,
              editable: true,
              protocol: protocol.value.value,
              port: port.value.value
            });
          }
          closeEdit();
          submitLocalStorageSettings();
        });
        const closeEdit = () => {
          currentView.value = 0;
          resetFields();
        };
        const deleteItem = () => {
          servers.splice(servers.indexOf(currentlyEditing.value), 1);
          closeEdit();
          submitLocalStorageSettings();
        };
        const submitLocalStorageSettings = () => {
          window.localStorage.setItem(
            "evbcSettings",
            JSON.stringify({
              servers,
              connectAutomatically: connectAutomatically.value
            })
          );
        };
        const connect = (server) => {
          window.localStorage.setItem("lastConnectedServer", JSON.stringify(server));
          connecting.value = true;
          if (evbc2) {
            evbc2.connect(server.protocol + "://" + server.host + ":" + server.port);
          }
        };
        onMounted(() => {
          var _a2;
          const router2 = useRouter$1();
          const storage = window.localStorage;
          const evbcLsString = storage.getItem("evbcSettings");
          if (evbcLsString) {
            const evbcLocalStorage = JSON.parse(evbcLsString);
            if ("servers" in evbcLocalStorage) {
              servers.splice(0, servers.length);
              servers.push(...evbcLocalStorage.servers);
            }
            if ("connectAutomatically" in evbcLocalStorage) {
              connectAutomatically.value = evbcLocalStorage.connectAutomatically;
              if (router2.currentRoute.value.query.auto_connect !== "false" && connectAutomatically.value && ((_a2 = window.localStorage) == null ? void 0 : _a2.getItem("lastConnectedServer")) !== null) {
                const lastServer = JSON.parse(window.localStorage.getItem("lastConnectedServer"));
                connect(lastServer);
              }
            }
          }
          if (evbc2) {
            const unsubscribe = evbc2.on("connection_state", (ev) => {
              if (ev.type === "INFO") {
                connectionStatus.value = ev.text;
              } else if (ev.type === "INITIALIZED") {
                unsubscribe();
                router2.push({ name: "main" });
              } else if (ev.type === "FAILED") {
                connecting.value = false;
                error2.active = true;
                error2.status = ev.text;
              } else if (ev.type === "IDLE") {
                connecting.value = false;
                connectionStatus.value = "";
              }
            });
          }
        });
        return {
          servers,
          connectAutomatically,
          connecting,
          connectionStatus,
          error: error2,
          openAddServerView,
          openEditServerView,
          submitEdit,
          closeEdit,
          deleteItem,
          submitLocalStorageSettings,
          connect,
          meta,
          host,
          instanceId,
          protocol,
          port,
          currentView,
          currentlyEditing,
          ComponentViews
        };
      }
    });
    const VAlertTitle = createSimpleFunctional("v-alert-title");
    const allowedTypes = ["success", "info", "warning", "error"];
    const makeVAlertProps = propsFactory({
      border: {
        type: [Boolean, String],
        validator: (val) => {
          return typeof val === "boolean" || ["top", "end", "bottom", "start"].includes(val);
        }
      },
      borderColor: String,
      closable: Boolean,
      closeIcon: {
        type: IconValue,
        default: "$close"
      },
      closeLabel: {
        type: String,
        default: "$vuetify.close"
      },
      icon: {
        type: [Boolean, String, Function, Object],
        default: null
      },
      modelValue: {
        type: Boolean,
        default: true
      },
      prominent: Boolean,
      title: String,
      text: String,
      type: {
        type: String,
        validator: (val) => allowedTypes.includes(val)
      },
      ...makeComponentProps(),
      ...makeDensityProps(),
      ...makeDimensionProps(),
      ...makeElevationProps(),
      ...makeLocationProps(),
      ...makePositionProps(),
      ...makeRoundedProps(),
      ...makeTagProps(),
      ...makeThemeProps(),
      ...makeVariantProps({
        variant: "flat"
      })
    }, "VAlert");
    const VAlert = genericComponent()({
      name: "VAlert",
      props: makeVAlertProps(),
      emits: {
        "click:close": (e) => true,
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          emit: emit2,
          slots
        } = _ref;
        const isActive = useProxiedModel(props, "modelValue");
        const icon = computed(() => {
          if (props.icon === false)
            return void 0;
          if (!props.type)
            return props.icon;
          return props.icon ?? `$${props.type}`;
        });
        const variantProps = computed(() => ({
          color: props.color ?? props.type,
          variant: props.variant
        }));
        const {
          themeClasses
        } = provideTheme(props);
        const {
          colorClasses,
          colorStyles,
          variantClasses
        } = useVariant(variantProps);
        const {
          densityClasses
        } = useDensity(props);
        const {
          dimensionStyles
        } = useDimension(props);
        const {
          elevationClasses
        } = useElevation(props);
        const {
          locationStyles
        } = useLocation(props);
        const {
          positionClasses
        } = usePosition(props);
        const {
          roundedClasses
        } = useRounded(props);
        const {
          textColorClasses,
          textColorStyles
        } = useTextColor(toRef(props, "borderColor"));
        const {
          t
        } = useLocale();
        const closeProps = computed(() => ({
          "aria-label": t(props.closeLabel),
          onClick(e) {
            isActive.value = false;
            emit2("click:close", e);
          }
        }));
        return () => {
          const hasPrepend = !!(slots.prepend || icon.value);
          const hasTitle = !!(slots.title || props.title);
          const hasClose = !!(slots.close || props.closable);
          return isActive.value && createVNode(props.tag, {
            "class": ["v-alert", props.border && {
              "v-alert--border": !!props.border,
              [`v-alert--border-${props.border === true ? "start" : props.border}`]: true
            }, {
              "v-alert--prominent": props.prominent
            }, themeClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, variantClasses.value, props.class],
            "style": [colorStyles.value, dimensionStyles.value, locationStyles.value, props.style],
            "role": "alert"
          }, {
            default: () => {
              var _a2, _b;
              return [genOverlays(false, "v-alert"), props.border && createVNode("div", {
                "key": "border",
                "class": ["v-alert__border", textColorClasses.value],
                "style": textColorStyles.value
              }, null), hasPrepend && createVNode("div", {
                "key": "prepend",
                "class": "v-alert__prepend"
              }, [!slots.prepend ? createVNode(VIcon, {
                "key": "prepend-icon",
                "density": props.density,
                "icon": icon.value,
                "size": props.prominent ? 44 : 28
              }, null) : createVNode(VDefaultsProvider, {
                "key": "prepend-defaults",
                "disabled": !icon.value,
                "defaults": {
                  VIcon: {
                    density: props.density,
                    icon: icon.value,
                    size: props.prominent ? 44 : 28
                  }
                }
              }, slots.prepend)]), createVNode("div", {
                "class": "v-alert__content"
              }, [hasTitle && createVNode(VAlertTitle, {
                "key": "title"
              }, {
                default: () => {
                  var _a3;
                  return [((_a3 = slots.title) == null ? void 0 : _a3.call(slots)) ?? props.title];
                }
              }), ((_a2 = slots.text) == null ? void 0 : _a2.call(slots)) ?? props.text, (_b = slots.default) == null ? void 0 : _b.call(slots)]), slots.append && createVNode("div", {
                "key": "append",
                "class": "v-alert__append"
              }, [slots.append()]), hasClose && createVNode("div", {
                "key": "close",
                "class": "v-alert__close"
              }, [!slots.close ? createVNode(VBtn, mergeProps({
                "key": "close-btn",
                "icon": props.closeIcon,
                "size": "x-small",
                "variant": "text"
              }, closeProps.value), null) : createVNode(VDefaultsProvider, {
                "key": "close-defaults",
                "defaults": {
                  VBtn: {
                    icon: props.closeIcon,
                    size: "x-small",
                    variant: "text"
                  }
                }
              }, {
                default: () => {
                  var _a3;
                  return [(_a3 = slots.close) == null ? void 0 : _a3.call(slots, {
                    props: closeProps.value
                  })];
                }
              })])];
            }
          });
        };
      }
    });
    const makeVLabelProps = propsFactory({
      text: String,
      onClick: EventProp(),
      ...makeComponentProps(),
      ...makeThemeProps()
    }, "VLabel");
    const VLabel = genericComponent()({
      name: "VLabel",
      props: makeVLabelProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        useRender(() => {
          var _a2;
          return createVNode("label", {
            "class": ["v-label", {
              "v-label--clickable": !!props.onClick
            }, props.class],
            "style": props.style,
            "onClick": props.onClick
          }, [props.text, (_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
        });
        return {};
      }
    });
    const VSelectionControlGroupSymbol = Symbol.for("vuetify:selection-control-group");
    const makeSelectionControlGroupProps = propsFactory({
      color: String,
      disabled: {
        type: Boolean,
        default: null
      },
      defaultsTarget: String,
      error: Boolean,
      id: String,
      inline: Boolean,
      falseIcon: IconValue,
      trueIcon: IconValue,
      ripple: {
        type: Boolean,
        default: true
      },
      multiple: {
        type: Boolean,
        default: null
      },
      name: String,
      readonly: {
        type: Boolean,
        default: null
      },
      modelValue: null,
      type: String,
      valueComparator: {
        type: Function,
        default: deepEqual
      },
      ...makeComponentProps(),
      ...makeDensityProps(),
      ...makeThemeProps()
    }, "SelectionControlGroup");
    const makeVSelectionControlGroupProps = propsFactory({
      ...makeSelectionControlGroupProps({
        defaultsTarget: "VSelectionControl"
      })
    }, "VSelectionControlGroup");
    genericComponent()({
      name: "VSelectionControlGroup",
      props: makeVSelectionControlGroupProps(),
      emits: {
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const modelValue = useProxiedModel(props, "modelValue");
        const uid2 = getUid();
        const id2 = computed(() => props.id || `v-selection-control-group-${uid2}`);
        const name = computed(() => props.name || id2.value);
        const updateHandlers = /* @__PURE__ */ new Set();
        provide(VSelectionControlGroupSymbol, {
          modelValue,
          forceUpdate: () => {
            updateHandlers.forEach((fn) => fn());
          },
          onForceUpdate: (cb) => {
            updateHandlers.add(cb);
            onScopeDispose(() => {
              updateHandlers.delete(cb);
            });
          }
        });
        provideDefaults({
          [props.defaultsTarget]: {
            color: toRef(props, "color"),
            disabled: toRef(props, "disabled"),
            density: toRef(props, "density"),
            error: toRef(props, "error"),
            inline: toRef(props, "inline"),
            modelValue,
            multiple: computed(() => !!props.multiple || props.multiple == null && Array.isArray(modelValue.value)),
            name,
            falseIcon: toRef(props, "falseIcon"),
            trueIcon: toRef(props, "trueIcon"),
            readonly: toRef(props, "readonly"),
            ripple: toRef(props, "ripple"),
            type: toRef(props, "type"),
            valueComparator: toRef(props, "valueComparator")
          }
        });
        useRender(() => {
          var _a2;
          return createVNode("div", {
            "class": ["v-selection-control-group", {
              "v-selection-control-group--inline": props.inline
            }, props.class],
            "style": props.style,
            "role": props.type === "radio" ? "radiogroup" : void 0
          }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
        });
        return {};
      }
    });
    const makeVSelectionControlProps = propsFactory({
      label: String,
      baseColor: String,
      trueValue: null,
      falseValue: null,
      value: null,
      ...makeComponentProps(),
      ...makeSelectionControlGroupProps()
    }, "VSelectionControl");
    function useSelectionControl(props) {
      const group = inject$1(VSelectionControlGroupSymbol, void 0);
      const {
        densityClasses
      } = useDensity(props);
      const modelValue = useProxiedModel(props, "modelValue");
      const trueValue = computed(() => props.trueValue !== void 0 ? props.trueValue : props.value !== void 0 ? props.value : true);
      const falseValue = computed(() => props.falseValue !== void 0 ? props.falseValue : false);
      const isMultiple = computed(() => !!props.multiple || props.multiple == null && Array.isArray(modelValue.value));
      const model = computed({
        get() {
          const val = group ? group.modelValue.value : modelValue.value;
          return isMultiple.value ? wrapInArray(val).some((v) => props.valueComparator(v, trueValue.value)) : props.valueComparator(val, trueValue.value);
        },
        set(val) {
          if (props.readonly)
            return;
          const currentValue = val ? trueValue.value : falseValue.value;
          let newVal = currentValue;
          if (isMultiple.value) {
            newVal = val ? [...wrapInArray(modelValue.value), currentValue] : wrapInArray(modelValue.value).filter((item) => !props.valueComparator(item, trueValue.value));
          }
          if (group) {
            group.modelValue.value = newVal;
          } else {
            modelValue.value = newVal;
          }
        }
      });
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(computed(() => {
        if (props.error || props.disabled)
          return void 0;
        return model.value ? props.color : props.baseColor;
      }));
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(computed(() => {
        return model.value && !props.error && !props.disabled ? props.color : void 0;
      }));
      const icon = computed(() => model.value ? props.trueIcon : props.falseIcon);
      return {
        group,
        densityClasses,
        trueValue,
        falseValue,
        model,
        textColorClasses,
        textColorStyles,
        backgroundColorClasses,
        backgroundColorStyles,
        icon
      };
    }
    const VSelectionControl = genericComponent()({
      name: "VSelectionControl",
      directives: {
        Ripple
      },
      inheritAttrs: false,
      props: makeVSelectionControlProps(),
      emits: {
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          slots
        } = _ref;
        const {
          group,
          densityClasses,
          icon,
          model,
          textColorClasses,
          textColorStyles,
          backgroundColorClasses,
          backgroundColorStyles,
          trueValue
        } = useSelectionControl(props);
        const uid2 = getUid();
        const isFocused = shallowRef(false);
        const isFocusVisible = shallowRef(false);
        const input = ref$1();
        const id2 = computed(() => props.id || `input-${uid2}`);
        const isInteractive = computed(() => !props.disabled && !props.readonly);
        group == null ? void 0 : group.onForceUpdate(() => {
          if (input.value) {
            input.value.checked = model.value;
          }
        });
        function onFocus(e) {
          if (!isInteractive.value)
            return;
          isFocused.value = true;
          if (matchesSelector(e.target, ":focus-visible") !== false) {
            isFocusVisible.value = true;
          }
        }
        function onBlur() {
          isFocused.value = false;
          isFocusVisible.value = false;
        }
        function onClickLabel(e) {
          e.stopPropagation();
        }
        function onInput(e) {
          if (!isInteractive.value)
            return;
          if (props.readonly && group) {
            nextTick(() => group.forceUpdate());
          }
          model.value = e.target.checked;
        }
        useRender(() => {
          var _a2, _b;
          const label = slots.label ? slots.label({
            label: props.label,
            props: {
              for: id2.value
            }
          }) : props.label;
          const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
          const inputNode = createVNode("input", mergeProps({
            "ref": input,
            "checked": model.value,
            "disabled": !!props.disabled,
            "id": id2.value,
            "onBlur": onBlur,
            "onFocus": onFocus,
            "onInput": onInput,
            "aria-disabled": !!props.disabled,
            "type": props.type,
            "value": trueValue.value,
            "name": props.name,
            "aria-checked": props.type === "checkbox" ? model.value : void 0
          }, inputAttrs), null);
          return createVNode("div", mergeProps({
            "class": ["v-selection-control", {
              "v-selection-control--dirty": model.value,
              "v-selection-control--disabled": props.disabled,
              "v-selection-control--error": props.error,
              "v-selection-control--focused": isFocused.value,
              "v-selection-control--focus-visible": isFocusVisible.value,
              "v-selection-control--inline": props.inline
            }, densityClasses.value, props.class]
          }, rootAttrs, {
            "style": props.style
          }), [createVNode("div", {
            "class": ["v-selection-control__wrapper", textColorClasses.value],
            "style": textColorStyles.value
          }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
            backgroundColorClasses,
            backgroundColorStyles
          }), withDirectives(createVNode("div", {
            "class": ["v-selection-control__input"]
          }, [((_b = slots.input) == null ? void 0 : _b.call(slots, {
            model,
            textColorClasses,
            textColorStyles,
            backgroundColorClasses,
            backgroundColorStyles,
            inputNode,
            icon: icon.value,
            props: {
              onFocus,
              onBlur,
              id: id2.value
            }
          })) ?? createVNode(Fragment, null, [icon.value && createVNode(VIcon, {
            "key": "icon",
            "icon": icon.value
          }, null), inputNode])]), [[resolveDirective("ripple"), props.ripple && [!props.disabled && !props.readonly, null, ["center", "circle"]]]])]), label && createVNode(VLabel, {
            "for": id2.value,
            "onClick": onClickLabel
          }, {
            default: () => [label]
          })]);
        });
        return {
          isFocused,
          input
        };
      }
    });
    const makeVCheckboxBtnProps = propsFactory({
      indeterminate: Boolean,
      indeterminateIcon: {
        type: IconValue,
        default: "$checkboxIndeterminate"
      },
      ...makeVSelectionControlProps({
        falseIcon: "$checkboxOff",
        trueIcon: "$checkboxOn"
      })
    }, "VCheckboxBtn");
    const VCheckboxBtn = genericComponent()({
      name: "VCheckboxBtn",
      props: makeVCheckboxBtnProps(),
      emits: {
        "update:modelValue": (value) => true,
        "update:indeterminate": (value) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const indeterminate = useProxiedModel(props, "indeterminate");
        const model = useProxiedModel(props, "modelValue");
        function onChange(v) {
          if (indeterminate.value) {
            indeterminate.value = false;
          }
        }
        const falseIcon = computed(() => {
          return indeterminate.value ? props.indeterminateIcon : props.falseIcon;
        });
        const trueIcon = computed(() => {
          return indeterminate.value ? props.indeterminateIcon : props.trueIcon;
        });
        useRender(() => {
          const controlProps = omit$1(VSelectionControl.filterProps(props), ["modelValue"]);
          return createVNode(VSelectionControl, mergeProps(controlProps, {
            "modelValue": model.value,
            "onUpdate:modelValue": [($event) => model.value = $event, onChange],
            "class": ["v-checkbox-btn", props.class],
            "style": props.style,
            "type": "checkbox",
            "falseIcon": falseIcon.value,
            "trueIcon": trueIcon.value,
            "aria-checked": indeterminate.value ? "mixed" : void 0
          }), slots);
        });
        return {};
      }
    });
    function useInputIcon(props) {
      const {
        t
      } = useLocale();
      function InputIcon(_ref) {
        let {
          name
        } = _ref;
        const localeKey = {
          prepend: "prependAction",
          prependInner: "prependAction",
          append: "appendAction",
          appendInner: "appendAction",
          clear: "clear"
        }[name];
        const listener = props[`onClick:${name}`];
        const label = listener && localeKey ? t(`$vuetify.input.${localeKey}`, props.label ?? "") : void 0;
        return createVNode(VIcon, {
          "icon": props[`${name}Icon`],
          "aria-label": label,
          "onClick": listener
        }, null);
      }
      return {
        InputIcon
      };
    }
    const makeVMessagesProps = propsFactory({
      active: Boolean,
      color: String,
      messages: {
        type: [Array, String],
        default: () => []
      },
      ...makeComponentProps(),
      ...makeTransitionProps({
        transition: {
          component: VSlideYTransition,
          leaveAbsolute: true,
          group: true
        }
      })
    }, "VMessages");
    const VMessages = genericComponent()({
      name: "VMessages",
      props: makeVMessagesProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const messages = computed(() => wrapInArray(props.messages));
        const {
          textColorClasses,
          textColorStyles
        } = useTextColor(computed(() => props.color));
        useRender(() => createVNode(MaybeTransition, {
          "transition": props.transition,
          "tag": "div",
          "class": ["v-messages", textColorClasses.value, props.class],
          "style": [textColorStyles.value, props.style],
          "role": "alert",
          "aria-live": "polite"
        }, {
          default: () => [props.active && messages.value.map((message, i2) => createVNode("div", {
            "class": "v-messages__message",
            "key": `${i2}-${messages.value}`
          }, [slots.message ? slots.message({
            message
          }) : message]))]
        }));
        return {};
      }
    });
    const makeFocusProps = propsFactory({
      focused: Boolean,
      "onUpdate:focused": EventProp()
    }, "focus");
    function useFocus(props) {
      let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
      const isFocused = useProxiedModel(props, "focused");
      const focusClasses = computed(() => {
        return {
          [`${name}--focused`]: isFocused.value
        };
      });
      function focus() {
        isFocused.value = true;
      }
      function blur() {
        isFocused.value = false;
      }
      return {
        focusClasses,
        isFocused,
        focus,
        blur
      };
    }
    const FormKey = Symbol.for("vuetify:form");
    const makeFormProps = propsFactory({
      disabled: Boolean,
      fastFail: Boolean,
      readonly: Boolean,
      modelValue: {
        type: Boolean,
        default: null
      },
      validateOn: {
        type: String,
        default: "input"
      }
    }, "form");
    function createForm(props) {
      const model = useProxiedModel(props, "modelValue");
      const isDisabled = computed(() => props.disabled);
      const isReadonly2 = computed(() => props.readonly);
      const isValidating = shallowRef(false);
      const items2 = ref$1([]);
      const errors2 = ref$1([]);
      async function validate2() {
        const results = [];
        let valid = true;
        errors2.value = [];
        isValidating.value = true;
        for (const item of items2.value) {
          const itemErrorMessages = await item.validate();
          if (itemErrorMessages.length > 0) {
            valid = false;
            results.push({
              id: item.id,
              errorMessages: itemErrorMessages
            });
          }
          if (!valid && props.fastFail)
            break;
        }
        errors2.value = results;
        isValidating.value = false;
        return {
          valid,
          errors: errors2.value
        };
      }
      function reset() {
        items2.value.forEach((item) => item.reset());
      }
      function resetValidation() {
        items2.value.forEach((item) => item.resetValidation());
      }
      watch(items2, () => {
        let valid = 0;
        let invalid = 0;
        const results = [];
        for (const item of items2.value) {
          if (item.isValid === false) {
            invalid++;
            results.push({
              id: item.id,
              errorMessages: item.errorMessages
            });
          } else if (item.isValid === true)
            valid++;
        }
        errors2.value = results;
        model.value = invalid > 0 ? false : valid === items2.value.length ? true : null;
      }, {
        deep: true,
        flush: "post"
      });
      provide(FormKey, {
        register: (_ref) => {
          let {
            id: id2,
            validate: validate3,
            reset: reset2,
            resetValidation: resetValidation2
          } = _ref;
          if (items2.value.some((item) => item.id === id2))
            ;
          items2.value.push({
            id: id2,
            validate: validate3,
            reset: reset2,
            resetValidation: resetValidation2,
            isValid: null,
            errorMessages: []
          });
        },
        unregister: (id2) => {
          items2.value = items2.value.filter((item) => {
            return item.id !== id2;
          });
        },
        update: (id2, isValid2, errorMessages) => {
          const found = items2.value.find((item) => item.id === id2);
          if (!found)
            return;
          found.isValid = isValid2;
          found.errorMessages = errorMessages;
        },
        isDisabled,
        isReadonly: isReadonly2,
        isValidating,
        isValid: model,
        items: items2,
        validateOn: toRef(props, "validateOn")
      });
      return {
        errors: errors2,
        isDisabled,
        isReadonly: isReadonly2,
        isValidating,
        isValid: model,
        items: items2,
        validate: validate2,
        reset,
        resetValidation
      };
    }
    function useForm() {
      return inject$1(FormKey, null);
    }
    const makeValidationProps = propsFactory({
      disabled: {
        type: Boolean,
        default: null
      },
      error: Boolean,
      errorMessages: {
        type: [Array, String],
        default: () => []
      },
      maxErrors: {
        type: [Number, String],
        default: 1
      },
      name: String,
      label: String,
      readonly: {
        type: Boolean,
        default: null
      },
      rules: {
        type: Array,
        default: () => []
      },
      modelValue: null,
      validateOn: String,
      validationValue: null,
      ...makeFocusProps()
    }, "validation");
    function useValidation(props) {
      let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
      let id2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : getUid();
      const model = useProxiedModel(props, "modelValue");
      const validationModel = computed(() => props.validationValue === void 0 ? model.value : props.validationValue);
      const form = useForm();
      const internalErrorMessages = ref$1([]);
      const isPristine = shallowRef(true);
      const isDirty = computed(() => !!(wrapInArray(model.value === "" ? null : model.value).length || wrapInArray(validationModel.value === "" ? null : validationModel.value).length));
      const isDisabled = computed(() => !!(props.disabled ?? (form == null ? void 0 : form.isDisabled.value)));
      const isReadonly2 = computed(() => !!(props.readonly ?? (form == null ? void 0 : form.isReadonly.value)));
      const errorMessages = computed(() => {
        var _a2;
        return ((_a2 = props.errorMessages) == null ? void 0 : _a2.length) ? wrapInArray(props.errorMessages).concat(internalErrorMessages.value).slice(0, Math.max(0, +props.maxErrors)) : internalErrorMessages.value;
      });
      const validateOn = computed(() => {
        let value = (props.validateOn ?? (form == null ? void 0 : form.validateOn.value)) || "input";
        if (value === "lazy")
          value = "input lazy";
        const set2 = new Set((value == null ? void 0 : value.split(" ")) ?? []);
        return {
          blur: set2.has("blur") || set2.has("input"),
          input: set2.has("input"),
          submit: set2.has("submit"),
          lazy: set2.has("lazy")
        };
      });
      const isValid2 = computed(() => {
        var _a2;
        if (props.error || ((_a2 = props.errorMessages) == null ? void 0 : _a2.length))
          return false;
        if (!props.rules.length)
          return true;
        if (isPristine.value) {
          return internalErrorMessages.value.length || validateOn.value.lazy ? null : true;
        } else {
          return !internalErrorMessages.value.length;
        }
      });
      const isValidating = shallowRef(false);
      const validationClasses = computed(() => {
        return {
          [`${name}--error`]: isValid2.value === false,
          [`${name}--dirty`]: isDirty.value,
          [`${name}--disabled`]: isDisabled.value,
          [`${name}--readonly`]: isReadonly2.value
        };
      });
      const uid2 = computed(() => props.name ?? unref(id2));
      onBeforeMount(() => {
        form == null ? void 0 : form.register({
          id: uid2.value,
          validate: validate2,
          reset,
          resetValidation
        });
      });
      onBeforeUnmount(() => {
        form == null ? void 0 : form.unregister(uid2.value);
      });
      onMounted(async () => {
        if (!validateOn.value.lazy) {
          await validate2(true);
        }
        form == null ? void 0 : form.update(uid2.value, isValid2.value, errorMessages.value);
      });
      useToggleScope(() => validateOn.value.input, () => {
        watch(validationModel, () => {
          if (validationModel.value != null) {
            validate2();
          } else if (props.focused) {
            const unwatch = watch(() => props.focused, (val) => {
              if (!val)
                validate2();
              unwatch();
            });
          }
        });
      });
      useToggleScope(() => validateOn.value.blur, () => {
        watch(() => props.focused, (val) => {
          if (!val)
            validate2();
        });
      });
      watch([isValid2, errorMessages], () => {
        form == null ? void 0 : form.update(uid2.value, isValid2.value, errorMessages.value);
      });
      function reset() {
        model.value = null;
        nextTick(resetValidation);
      }
      function resetValidation() {
        isPristine.value = true;
        if (!validateOn.value.lazy) {
          validate2(true);
        } else {
          internalErrorMessages.value = [];
        }
      }
      async function validate2() {
        let silent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        const results = [];
        isValidating.value = true;
        for (const rule of props.rules) {
          if (results.length >= +(props.maxErrors ?? 1)) {
            break;
          }
          const handler = typeof rule === "function" ? rule : () => rule;
          const result = await handler(validationModel.value);
          if (result === true)
            continue;
          if (result !== false && typeof result !== "string") {
            console.warn(`${result} is not a valid value. Rule functions must return boolean true or a string.`);
            continue;
          }
          results.push(result || "");
        }
        internalErrorMessages.value = results;
        isValidating.value = false;
        isPristine.value = silent;
        return internalErrorMessages.value;
      }
      return {
        errorMessages,
        isDirty,
        isDisabled,
        isReadonly: isReadonly2,
        isPristine,
        isValid: isValid2,
        isValidating,
        reset,
        resetValidation,
        validate: validate2,
        validationClasses
      };
    }
    const makeVInputProps = propsFactory({
      id: String,
      appendIcon: IconValue,
      centerAffix: {
        type: Boolean,
        default: true
      },
      prependIcon: IconValue,
      hideDetails: [Boolean, String],
      hideSpinButtons: Boolean,
      hint: String,
      persistentHint: Boolean,
      messages: {
        type: [Array, String],
        default: () => []
      },
      direction: {
        type: String,
        default: "horizontal",
        validator: (v) => ["horizontal", "vertical"].includes(v)
      },
      "onClick:prepend": EventProp(),
      "onClick:append": EventProp(),
      ...makeComponentProps(),
      ...makeDensityProps(),
      ...makeValidationProps()
    }, "VInput");
    const VInput = genericComponent()({
      name: "VInput",
      props: {
        ...makeVInputProps()
      },
      emits: {
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          slots,
          emit: emit2
        } = _ref;
        const {
          densityClasses
        } = useDensity(props);
        const {
          rtlClasses
        } = useRtl();
        const {
          InputIcon
        } = useInputIcon(props);
        const uid2 = getUid();
        const id2 = computed(() => props.id || `input-${uid2}`);
        const messagesId = computed(() => `${id2.value}-messages`);
        const {
          errorMessages,
          isDirty,
          isDisabled,
          isReadonly: isReadonly2,
          isPristine,
          isValid: isValid2,
          isValidating,
          reset,
          resetValidation,
          validate: validate2,
          validationClasses
        } = useValidation(props, "v-input", id2);
        const slotProps = computed(() => ({
          id: id2,
          messagesId,
          isDirty,
          isDisabled,
          isReadonly: isReadonly2,
          isPristine,
          isValid: isValid2,
          isValidating,
          reset,
          resetValidation,
          validate: validate2
        }));
        const messages = computed(() => {
          var _a2;
          if (((_a2 = props.errorMessages) == null ? void 0 : _a2.length) || !isPristine.value && errorMessages.value.length) {
            return errorMessages.value;
          } else if (props.hint && (props.persistentHint || props.focused)) {
            return props.hint;
          } else {
            return props.messages;
          }
        });
        useRender(() => {
          var _a2, _b, _c, _d;
          const hasPrepend = !!(slots.prepend || props.prependIcon);
          const hasAppend = !!(slots.append || props.appendIcon);
          const hasMessages = messages.value.length > 0;
          const hasDetails = !props.hideDetails || props.hideDetails === "auto" && (hasMessages || !!slots.details);
          return createVNode("div", {
            "class": ["v-input", `v-input--${props.direction}`, {
              "v-input--center-affix": props.centerAffix,
              "v-input--hide-spin-buttons": props.hideSpinButtons
            }, densityClasses.value, rtlClasses.value, validationClasses.value, props.class],
            "style": props.style
          }, [hasPrepend && createVNode("div", {
            "key": "prepend",
            "class": "v-input__prepend"
          }, [(_a2 = slots.prepend) == null ? void 0 : _a2.call(slots, slotProps.value), props.prependIcon && createVNode(InputIcon, {
            "key": "prepend-icon",
            "name": "prepend"
          }, null)]), slots.default && createVNode("div", {
            "class": "v-input__control"
          }, [(_b = slots.default) == null ? void 0 : _b.call(slots, slotProps.value)]), hasAppend && createVNode("div", {
            "key": "append",
            "class": "v-input__append"
          }, [props.appendIcon && createVNode(InputIcon, {
            "key": "append-icon",
            "name": "append"
          }, null), (_c = slots.append) == null ? void 0 : _c.call(slots, slotProps.value)]), hasDetails && createVNode("div", {
            "class": "v-input__details"
          }, [createVNode(VMessages, {
            "id": messagesId.value,
            "active": hasMessages,
            "messages": messages.value
          }, {
            message: slots.message
          }), (_d = slots.details) == null ? void 0 : _d.call(slots, slotProps.value)])]);
        });
        return {
          reset,
          resetValidation,
          validate: validate2,
          isValid: isValid2,
          errorMessages
        };
      }
    });
    const makeVCheckboxProps = propsFactory({
      ...makeVInputProps(),
      ...omit$1(makeVCheckboxBtnProps(), ["inline"])
    }, "VCheckbox");
    const VCheckbox = genericComponent()({
      name: "VCheckbox",
      inheritAttrs: false,
      props: makeVCheckboxProps(),
      emits: {
        "update:modelValue": (value) => true,
        "update:focused": (focused) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          slots
        } = _ref;
        const model = useProxiedModel(props, "modelValue");
        const {
          isFocused,
          focus,
          blur
        } = useFocus(props);
        const uid2 = getUid();
        const id2 = computed(() => props.id || `checkbox-${uid2}`);
        useRender(() => {
          const [rootAttrs, controlAttrs] = filterInputAttrs(attrs);
          const inputProps = VInput.filterProps(props);
          const checkboxProps = VCheckboxBtn.filterProps(props);
          return createVNode(VInput, mergeProps({
            "class": ["v-checkbox", props.class]
          }, rootAttrs, inputProps, {
            "modelValue": model.value,
            "onUpdate:modelValue": ($event) => model.value = $event,
            "id": id2.value,
            "focused": isFocused.value,
            "style": props.style
          }), {
            ...slots,
            default: (_ref2) => {
              let {
                id: id3,
                messagesId,
                isDisabled,
                isReadonly: isReadonly2
              } = _ref2;
              return createVNode(VCheckboxBtn, mergeProps(checkboxProps, {
                "id": id3.value,
                "aria-describedby": messagesId.value,
                "disabled": isDisabled.value,
                "readonly": isReadonly2.value
              }, controlAttrs, {
                "modelValue": model.value,
                "onUpdate:modelValue": ($event) => model.value = $event,
                "onFocus": focus,
                "onBlur": blur
              }), slots);
            }
          });
        });
        return {};
      }
    });
    function bias(val) {
      const c = 0.501;
      const x = Math.abs(val);
      return Math.sign(val) * (x / ((1 / c - 2) * (1 - x) + 1));
    }
    function calculateUpdatedOffset(_ref) {
      let {
        selectedElement,
        containerSize,
        contentSize,
        isRtl,
        currentScrollOffset,
        isHorizontal
      } = _ref;
      const clientSize = isHorizontal ? selectedElement.clientWidth : selectedElement.clientHeight;
      const offsetStart = isHorizontal ? selectedElement.offsetLeft : selectedElement.offsetTop;
      const adjustedOffsetStart = isRtl && isHorizontal ? contentSize - offsetStart - clientSize : offsetStart;
      const totalSize = containerSize + currentScrollOffset;
      const itemOffset = clientSize + adjustedOffsetStart;
      const additionalOffset = clientSize * 0.4;
      if (adjustedOffsetStart <= currentScrollOffset) {
        currentScrollOffset = Math.max(adjustedOffsetStart - additionalOffset, 0);
      } else if (totalSize <= itemOffset) {
        currentScrollOffset = Math.min(currentScrollOffset - (totalSize - itemOffset - additionalOffset), contentSize - containerSize);
      }
      return currentScrollOffset;
    }
    function calculateCenteredOffset(_ref2) {
      let {
        selectedElement,
        containerSize,
        contentSize,
        isRtl,
        isHorizontal
      } = _ref2;
      const clientSize = isHorizontal ? selectedElement.clientWidth : selectedElement.clientHeight;
      const offsetStart = isHorizontal ? selectedElement.offsetLeft : selectedElement.offsetTop;
      const offsetCentered = isRtl && isHorizontal ? contentSize - offsetStart - clientSize / 2 - containerSize / 2 : offsetStart + clientSize / 2 - containerSize / 2;
      return Math.min(contentSize - containerSize, Math.max(0, offsetCentered));
    }
    const VSlideGroupSymbol = Symbol.for("vuetify:v-slide-group");
    const makeVSlideGroupProps = propsFactory({
      centerActive: Boolean,
      direction: {
        type: String,
        default: "horizontal"
      },
      symbol: {
        type: null,
        default: VSlideGroupSymbol
      },
      nextIcon: {
        type: IconValue,
        default: "$next"
      },
      prevIcon: {
        type: IconValue,
        default: "$prev"
      },
      showArrows: {
        type: [Boolean, String],
        validator: (v) => typeof v === "boolean" || ["always", "desktop", "mobile"].includes(v)
      },
      ...makeComponentProps(),
      ...makeDisplayProps(),
      ...makeTagProps(),
      ...makeGroupProps({
        selectedClass: "v-slide-group-item--active"
      })
    }, "VSlideGroup");
    const VSlideGroup = genericComponent()({
      name: "VSlideGroup",
      props: makeVSlideGroupProps(),
      emits: {
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          isRtl
        } = useRtl();
        const {
          displayClasses,
          mobile
        } = useDisplay(props);
        const group = useGroup(props, props.symbol);
        const isOverflowing = shallowRef(false);
        const scrollOffset = shallowRef(0);
        const containerSize = shallowRef(0);
        const contentSize = shallowRef(0);
        const isHorizontal = computed(() => props.direction === "horizontal");
        const {
          resizeRef: containerRef,
          contentRect: containerRect
        } = useResizeObserver$1();
        const {
          resizeRef: contentRef,
          contentRect
        } = useResizeObserver$1();
        const firstSelectedIndex = computed(() => {
          if (!group.selected.value.length)
            return -1;
          return group.items.value.findIndex((item) => item.id === group.selected.value[0]);
        });
        const lastSelectedIndex = computed(() => {
          if (!group.selected.value.length)
            return -1;
          return group.items.value.findIndex((item) => item.id === group.selected.value[group.selected.value.length - 1]);
        });
        if (IN_BROWSER) {
          let frame = -1;
          watch(() => [group.selected.value, containerRect.value, contentRect.value, isHorizontal.value], () => {
            cancelAnimationFrame(frame);
            frame = requestAnimationFrame(() => {
              if (containerRect.value && contentRect.value) {
                const sizeProperty = isHorizontal.value ? "width" : "height";
                containerSize.value = containerRect.value[sizeProperty];
                contentSize.value = contentRect.value[sizeProperty];
                isOverflowing.value = containerSize.value + 1 < contentSize.value;
              }
              if (firstSelectedIndex.value >= 0 && contentRef.value) {
                const selectedElement = contentRef.value.children[lastSelectedIndex.value];
                if (firstSelectedIndex.value === 0 || !isOverflowing.value) {
                  scrollOffset.value = 0;
                } else if (props.centerActive) {
                  scrollOffset.value = calculateCenteredOffset({
                    selectedElement,
                    containerSize: containerSize.value,
                    contentSize: contentSize.value,
                    isRtl: isRtl.value,
                    isHorizontal: isHorizontal.value
                  });
                } else if (isOverflowing.value) {
                  scrollOffset.value = calculateUpdatedOffset({
                    selectedElement,
                    containerSize: containerSize.value,
                    contentSize: contentSize.value,
                    isRtl: isRtl.value,
                    currentScrollOffset: scrollOffset.value,
                    isHorizontal: isHorizontal.value
                  });
                }
              }
            });
          });
        }
        const disableTransition = shallowRef(false);
        let startTouch = 0;
        let startOffset = 0;
        function onTouchstart(e) {
          const sizeProperty = isHorizontal.value ? "clientX" : "clientY";
          const sign = isRtl.value && isHorizontal.value ? -1 : 1;
          startOffset = sign * scrollOffset.value;
          startTouch = e.touches[0][sizeProperty];
          disableTransition.value = true;
        }
        function onTouchmove(e) {
          if (!isOverflowing.value)
            return;
          const sizeProperty = isHorizontal.value ? "clientX" : "clientY";
          const sign = isRtl.value && isHorizontal.value ? -1 : 1;
          scrollOffset.value = sign * (startOffset + startTouch - e.touches[0][sizeProperty]);
        }
        function onTouchend(e) {
          const maxScrollOffset = contentSize.value - containerSize.value;
          if (scrollOffset.value < 0 || !isOverflowing.value) {
            scrollOffset.value = 0;
          } else if (scrollOffset.value >= maxScrollOffset) {
            scrollOffset.value = maxScrollOffset;
          }
          disableTransition.value = false;
        }
        function onScroll() {
          if (!containerRef.value)
            return;
          containerRef.value[isHorizontal.value ? "scrollLeft" : "scrollTop"] = 0;
        }
        const isFocused = shallowRef(false);
        function onFocusin(e) {
          isFocused.value = true;
          if (!isOverflowing.value || !contentRef.value)
            return;
          for (const el2 of e.composedPath()) {
            for (const item of contentRef.value.children) {
              if (item === el2) {
                scrollOffset.value = calculateUpdatedOffset({
                  selectedElement: item,
                  containerSize: containerSize.value,
                  contentSize: contentSize.value,
                  isRtl: isRtl.value,
                  currentScrollOffset: scrollOffset.value,
                  isHorizontal: isHorizontal.value
                });
                return;
              }
            }
          }
        }
        function onFocusout(e) {
          isFocused.value = false;
        }
        function onFocus(e) {
          var _a2;
          if (!isFocused.value && !(e.relatedTarget && ((_a2 = contentRef.value) == null ? void 0 : _a2.contains(e.relatedTarget))))
            focus();
        }
        function onKeydown(e) {
          if (!contentRef.value)
            return;
          if (isHorizontal.value) {
            if (e.key === "ArrowRight") {
              focus(isRtl.value ? "prev" : "next");
            } else if (e.key === "ArrowLeft") {
              focus(isRtl.value ? "next" : "prev");
            }
          } else {
            if (e.key === "ArrowDown") {
              focus("next");
            } else if (e.key === "ArrowUp") {
              focus("prev");
            }
          }
          if (e.key === "Home") {
            focus("first");
          } else if (e.key === "End") {
            focus("last");
          }
        }
        function focus(location2) {
          var _a2, _b, _c, _d, _e;
          if (!contentRef.value)
            return;
          if (!location2) {
            const focusable = focusableChildren(contentRef.value);
            (_a2 = focusable[0]) == null ? void 0 : _a2.focus();
          } else if (location2 === "next") {
            const el2 = (_b = contentRef.value.querySelector(":focus")) == null ? void 0 : _b.nextElementSibling;
            if (el2)
              el2.focus();
            else
              focus("first");
          } else if (location2 === "prev") {
            const el2 = (_c = contentRef.value.querySelector(":focus")) == null ? void 0 : _c.previousElementSibling;
            if (el2)
              el2.focus();
            else
              focus("last");
          } else if (location2 === "first") {
            (_d = contentRef.value.firstElementChild) == null ? void 0 : _d.focus();
          } else if (location2 === "last") {
            (_e = contentRef.value.lastElementChild) == null ? void 0 : _e.focus();
          }
        }
        function scrollTo(location2) {
          const newAbsoluteOffset = scrollOffset.value + (location2 === "prev" ? -1 : 1) * containerSize.value;
          scrollOffset.value = clamp(newAbsoluteOffset, 0, contentSize.value - containerSize.value);
        }
        const contentStyles = computed(() => {
          let scrollAmount = scrollOffset.value > contentSize.value - containerSize.value ? -(contentSize.value - containerSize.value) + bias(contentSize.value - containerSize.value - scrollOffset.value) : -scrollOffset.value;
          if (scrollOffset.value <= 0) {
            scrollAmount = bias(-scrollOffset.value);
          }
          const sign = isRtl.value && isHorizontal.value ? -1 : 1;
          return {
            transform: `translate${isHorizontal.value ? "X" : "Y"}(${sign * scrollAmount}px)`,
            transition: disableTransition.value ? "none" : "",
            willChange: disableTransition.value ? "transform" : ""
          };
        });
        const slotProps = computed(() => ({
          next: group.next,
          prev: group.prev,
          select: group.select,
          isSelected: group.isSelected
        }));
        const hasAffixes = computed(() => {
          switch (props.showArrows) {
            case "always":
              return true;
            case "desktop":
              return !mobile.value;
            case true:
              return isOverflowing.value || Math.abs(scrollOffset.value) > 0;
            case "mobile":
              return mobile.value || isOverflowing.value || Math.abs(scrollOffset.value) > 0;
            default:
              return !mobile.value && (isOverflowing.value || Math.abs(scrollOffset.value) > 0);
          }
        });
        const hasPrev = computed(() => {
          return Math.abs(scrollOffset.value) > 0;
        });
        const hasNext = computed(() => {
          return contentSize.value > Math.abs(scrollOffset.value) + containerSize.value;
        });
        useRender(() => createVNode(props.tag, {
          "class": ["v-slide-group", {
            "v-slide-group--vertical": !isHorizontal.value,
            "v-slide-group--has-affixes": hasAffixes.value,
            "v-slide-group--is-overflowing": isOverflowing.value
          }, displayClasses.value, props.class],
          "style": props.style,
          "tabindex": isFocused.value || group.selected.value.length ? -1 : 0,
          "onFocus": onFocus
        }, {
          default: () => {
            var _a2, _b, _c;
            return [hasAffixes.value && createVNode("div", {
              "key": "prev",
              "class": ["v-slide-group__prev", {
                "v-slide-group__prev--disabled": !hasPrev.value
              }],
              "onClick": () => hasPrev.value && scrollTo("prev")
            }, [((_a2 = slots.prev) == null ? void 0 : _a2.call(slots, slotProps.value)) ?? createVNode(VFadeTransition, null, {
              default: () => [createVNode(VIcon, {
                "icon": isRtl.value ? props.nextIcon : props.prevIcon
              }, null)]
            })]), createVNode("div", {
              "key": "container",
              "ref": containerRef,
              "class": "v-slide-group__container",
              "onScroll": onScroll
            }, [createVNode("div", {
              "ref": contentRef,
              "class": "v-slide-group__content",
              "style": contentStyles.value,
              "onTouchstartPassive": onTouchstart,
              "onTouchmovePassive": onTouchmove,
              "onTouchendPassive": onTouchend,
              "onFocusin": onFocusin,
              "onFocusout": onFocusout,
              "onKeydown": onKeydown
            }, [(_b = slots.default) == null ? void 0 : _b.call(slots, slotProps.value)])]), hasAffixes.value && createVNode("div", {
              "key": "next",
              "class": ["v-slide-group__next", {
                "v-slide-group__next--disabled": !hasNext.value
              }],
              "onClick": () => hasNext.value && scrollTo("next")
            }, [((_c = slots.next) == null ? void 0 : _c.call(slots, slotProps.value)) ?? createVNode(VFadeTransition, null, {
              default: () => [createVNode(VIcon, {
                "icon": isRtl.value ? props.prevIcon : props.nextIcon
              }, null)]
            })])];
          }
        }));
        return {
          selected: group.selected,
          scrollTo,
          scrollOffset,
          focus
        };
      }
    });
    const VChipGroupSymbol = Symbol.for("vuetify:v-chip-group");
    const makeVChipGroupProps = propsFactory({
      column: Boolean,
      filter: Boolean,
      valueComparator: {
        type: Function,
        default: deepEqual
      },
      ...makeVSlideGroupProps(),
      ...makeComponentProps(),
      ...makeGroupProps({
        selectedClass: "v-chip--selected"
      }),
      ...makeTagProps(),
      ...makeThemeProps(),
      ...makeVariantProps({
        variant: "tonal"
      })
    }, "VChipGroup");
    genericComponent()({
      name: "VChipGroup",
      props: makeVChipGroupProps(),
      emits: {
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          themeClasses
        } = provideTheme(props);
        const {
          isSelected,
          select,
          next: next2,
          prev,
          selected
        } = useGroup(props, VChipGroupSymbol);
        provideDefaults({
          VChip: {
            color: toRef(props, "color"),
            disabled: toRef(props, "disabled"),
            filter: toRef(props, "filter"),
            variant: toRef(props, "variant")
          }
        });
        useRender(() => {
          const slideGroupProps = VSlideGroup.filterProps(props);
          return createVNode(VSlideGroup, mergeProps(slideGroupProps, {
            "class": ["v-chip-group", {
              "v-chip-group--column": props.column
            }, themeClasses.value, props.class],
            "style": props.style
          }), {
            default: () => {
              var _a2;
              return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
                isSelected,
                select,
                next: next2,
                prev,
                selected: selected.value
              })];
            }
          });
        });
        return {};
      }
    });
    const makeVChipProps = propsFactory({
      activeClass: String,
      appendAvatar: String,
      appendIcon: IconValue,
      closable: Boolean,
      closeIcon: {
        type: IconValue,
        default: "$delete"
      },
      closeLabel: {
        type: String,
        default: "$vuetify.close"
      },
      draggable: Boolean,
      filter: Boolean,
      filterIcon: {
        type: String,
        default: "$complete"
      },
      label: Boolean,
      link: {
        type: Boolean,
        default: void 0
      },
      pill: Boolean,
      prependAvatar: String,
      prependIcon: IconValue,
      ripple: {
        type: [Boolean, Object],
        default: true
      },
      text: String,
      modelValue: {
        type: Boolean,
        default: true
      },
      onClick: EventProp(),
      onClickOnce: EventProp(),
      ...makeBorderProps(),
      ...makeComponentProps(),
      ...makeDensityProps(),
      ...makeElevationProps(),
      ...makeGroupItemProps(),
      ...makeRoundedProps(),
      ...makeRouterProps(),
      ...makeSizeProps(),
      ...makeTagProps({
        tag: "span"
      }),
      ...makeThemeProps(),
      ...makeVariantProps({
        variant: "tonal"
      })
    }, "VChip");
    const VChip = genericComponent()({
      name: "VChip",
      directives: {
        Ripple
      },
      props: makeVChipProps(),
      emits: {
        "click:close": (e) => true,
        "update:modelValue": (value) => true,
        "group:selected": (val) => true,
        click: (e) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          emit: emit2,
          slots
        } = _ref;
        const {
          t
        } = useLocale();
        const {
          borderClasses
        } = useBorder(props);
        const {
          colorClasses,
          colorStyles,
          variantClasses
        } = useVariant(props);
        const {
          densityClasses
        } = useDensity(props);
        const {
          elevationClasses
        } = useElevation(props);
        const {
          roundedClasses
        } = useRounded(props);
        const {
          sizeClasses
        } = useSize(props);
        const {
          themeClasses
        } = provideTheme(props);
        const isActive = useProxiedModel(props, "modelValue");
        const group = useGroupItem(props, VChipGroupSymbol, false);
        const link2 = useLink(props, attrs);
        const isLink = computed(() => props.link !== false && link2.isLink.value);
        const isClickable = computed(() => !props.disabled && props.link !== false && (!!group || props.link || link2.isClickable.value));
        const closeProps = computed(() => ({
          "aria-label": t(props.closeLabel),
          onClick(e) {
            e.stopPropagation();
            isActive.value = false;
            emit2("click:close", e);
          }
        }));
        function onClick(e) {
          var _a2;
          emit2("click", e);
          if (!isClickable.value)
            return;
          (_a2 = link2.navigate) == null ? void 0 : _a2.call(link2, e);
          group == null ? void 0 : group.toggle();
        }
        function onKeyDown(e) {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            onClick(e);
          }
        }
        return () => {
          const Tag2 = link2.isLink.value ? "a" : props.tag;
          const hasAppendMedia = !!(props.appendIcon || props.appendAvatar);
          const hasAppend = !!(hasAppendMedia || slots.append);
          const hasClose = !!(slots.close || props.closable);
          const hasFilter = !!(slots.filter || props.filter) && group;
          const hasPrependMedia = !!(props.prependIcon || props.prependAvatar);
          const hasPrepend = !!(hasPrependMedia || slots.prepend);
          const hasColor = !group || group.isSelected.value;
          return isActive.value && withDirectives(createVNode(Tag2, {
            "class": ["v-chip", {
              "v-chip--disabled": props.disabled,
              "v-chip--label": props.label,
              "v-chip--link": isClickable.value,
              "v-chip--filter": hasFilter,
              "v-chip--pill": props.pill
            }, themeClasses.value, borderClasses.value, hasColor ? colorClasses.value : void 0, densityClasses.value, elevationClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, group == null ? void 0 : group.selectedClass.value, props.class],
            "style": [hasColor ? colorStyles.value : void 0, props.style],
            "disabled": props.disabled || void 0,
            "draggable": props.draggable,
            "href": link2.href.value,
            "tabindex": isClickable.value ? 0 : void 0,
            "onClick": onClick,
            "onKeydown": isClickable.value && !isLink.value && onKeyDown
          }, {
            default: () => {
              var _a2;
              return [genOverlays(isClickable.value, "v-chip"), hasFilter && createVNode(VExpandXTransition, {
                "key": "filter"
              }, {
                default: () => [withDirectives(createVNode("div", {
                  "class": "v-chip__filter"
                }, [!slots.filter ? createVNode(VIcon, {
                  "key": "filter-icon",
                  "icon": props.filterIcon
                }, null) : createVNode(VDefaultsProvider, {
                  "key": "filter-defaults",
                  "disabled": !props.filterIcon,
                  "defaults": {
                    VIcon: {
                      icon: props.filterIcon
                    }
                  }
                }, slots.filter)]), [[vShow, group.isSelected.value]])]
              }), hasPrepend && createVNode("div", {
                "key": "prepend",
                "class": "v-chip__prepend"
              }, [!slots.prepend ? createVNode(Fragment, null, [props.prependIcon && createVNode(VIcon, {
                "key": "prepend-icon",
                "icon": props.prependIcon,
                "start": true
              }, null), props.prependAvatar && createVNode(VAvatar, {
                "key": "prepend-avatar",
                "image": props.prependAvatar,
                "start": true
              }, null)]) : createVNode(VDefaultsProvider, {
                "key": "prepend-defaults",
                "disabled": !hasPrependMedia,
                "defaults": {
                  VAvatar: {
                    image: props.prependAvatar,
                    start: true
                  },
                  VIcon: {
                    icon: props.prependIcon,
                    start: true
                  }
                }
              }, slots.prepend)]), createVNode("div", {
                "class": "v-chip__content",
                "data-no-activator": ""
              }, [((_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
                isSelected: group == null ? void 0 : group.isSelected.value,
                selectedClass: group == null ? void 0 : group.selectedClass.value,
                select: group == null ? void 0 : group.select,
                toggle: group == null ? void 0 : group.toggle,
                value: group == null ? void 0 : group.value.value,
                disabled: props.disabled
              })) ?? props.text]), hasAppend && createVNode("div", {
                "key": "append",
                "class": "v-chip__append"
              }, [!slots.append ? createVNode(Fragment, null, [props.appendIcon && createVNode(VIcon, {
                "key": "append-icon",
                "end": true,
                "icon": props.appendIcon
              }, null), props.appendAvatar && createVNode(VAvatar, {
                "key": "append-avatar",
                "end": true,
                "image": props.appendAvatar
              }, null)]) : createVNode(VDefaultsProvider, {
                "key": "append-defaults",
                "disabled": !hasAppendMedia,
                "defaults": {
                  VAvatar: {
                    end: true,
                    image: props.appendAvatar
                  },
                  VIcon: {
                    end: true,
                    icon: props.appendIcon
                  }
                }
              }, slots.append)]), hasClose && createVNode("button", mergeProps({
                "key": "close",
                "class": "v-chip__close",
                "type": "button"
              }, closeProps.value), [!slots.close ? createVNode(VIcon, {
                "key": "close-icon",
                "icon": props.closeIcon,
                "size": "x-small"
              }, null) : createVNode(VDefaultsProvider, {
                "key": "close-defaults",
                "defaults": {
                  VIcon: {
                    icon: props.closeIcon,
                    size: "x-small"
                  }
                }
              }, slots.close)])];
            }
          }), [[resolveDirective("ripple"), isClickable.value && props.ripple, null]]);
        };
      }
    });
    const makeVMenuProps = propsFactory({
      // TODO
      // disableKeys: Boolean,
      id: String,
      ...omit$1(makeVOverlayProps({
        closeDelay: 250,
        closeOnContentClick: true,
        locationStrategy: "connected",
        openDelay: 300,
        scrim: false,
        scrollStrategy: "reposition",
        transition: {
          component: VDialogTransition
        }
      }), ["absolute"])
    }, "VMenu");
    const VMenu = genericComponent()({
      name: "VMenu",
      props: makeVMenuProps(),
      emits: {
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const isActive = useProxiedModel(props, "modelValue");
        const {
          scopeId
        } = useScopeId();
        const uid2 = getUid();
        const id2 = computed(() => props.id || `v-menu-${uid2}`);
        const overlay = ref$1();
        const parent = inject$1(VMenuSymbol, null);
        const openChildren = shallowRef(0);
        provide(VMenuSymbol, {
          register() {
            ++openChildren.value;
          },
          unregister() {
            --openChildren.value;
          },
          closeParents(e) {
            setTimeout(() => {
              if (!openChildren.value && (e == null || e && !isClickInsideElement(e, overlay.value.contentEl))) {
                isActive.value = false;
                parent == null ? void 0 : parent.closeParents();
              }
            }, 40);
          }
        });
        async function onFocusIn(e) {
          var _a2, _b, _c;
          const before = e.relatedTarget;
          const after = e.target;
          await nextTick();
          if (isActive.value && before !== after && ((_a2 = overlay.value) == null ? void 0 : _a2.contentEl) && // We're the topmost menu
          ((_b = overlay.value) == null ? void 0 : _b.globalTop) && // It isn't the document or the menu body
          ![document, overlay.value.contentEl].includes(after) && // It isn't inside the menu body
          !overlay.value.contentEl.contains(after)) {
            const focusable = focusableChildren(overlay.value.contentEl);
            (_c = focusable[0]) == null ? void 0 : _c.focus();
          }
        }
        watch(isActive, (val) => {
          if (val) {
            parent == null ? void 0 : parent.register();
            document.addEventListener("focusin", onFocusIn, {
              once: true
            });
          } else {
            parent == null ? void 0 : parent.unregister();
            document.removeEventListener("focusin", onFocusIn);
          }
        });
        function onClickOutside(e) {
          parent == null ? void 0 : parent.closeParents(e);
        }
        function onKeydown(e) {
          var _a2, _b, _c;
          if (props.disabled)
            return;
          if (e.key === "Tab") {
            const nextElement = getNextElement(focusableChildren((_a2 = overlay.value) == null ? void 0 : _a2.contentEl, false), e.shiftKey ? "prev" : "next", (el2) => el2.tabIndex >= 0);
            if (!nextElement) {
              isActive.value = false;
              (_c = (_b = overlay.value) == null ? void 0 : _b.activatorEl) == null ? void 0 : _c.focus();
            }
          }
        }
        function onActivatorKeydown(e) {
          var _a2;
          if (props.disabled)
            return;
          const el2 = (_a2 = overlay.value) == null ? void 0 : _a2.contentEl;
          if (el2 && isActive.value) {
            if (e.key === "ArrowDown") {
              e.preventDefault();
              focusChild(el2, "next");
            } else if (e.key === "ArrowUp") {
              e.preventDefault();
              focusChild(el2, "prev");
            }
          } else if (["ArrowDown", "ArrowUp"].includes(e.key)) {
            isActive.value = true;
            e.preventDefault();
            setTimeout(() => setTimeout(() => onActivatorKeydown(e)));
          }
        }
        const activatorProps = computed(() => mergeProps({
          "aria-haspopup": "menu",
          "aria-expanded": String(isActive.value),
          "aria-owns": id2.value,
          onKeydown: onActivatorKeydown
        }, props.activatorProps));
        useRender(() => {
          const overlayProps = VOverlay.filterProps(props);
          return createVNode(VOverlay, mergeProps({
            "ref": overlay,
            "id": id2.value,
            "class": ["v-menu", props.class],
            "style": props.style
          }, overlayProps, {
            "modelValue": isActive.value,
            "onUpdate:modelValue": ($event) => isActive.value = $event,
            "absolute": true,
            "activatorProps": activatorProps.value,
            "onClick:outside": onClickOutside,
            "onKeydown": onKeydown
          }, scopeId), {
            activator: slots.activator,
            default: function() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return createVNode(VDefaultsProvider, {
                "root": "VMenu"
              }, {
                default: () => {
                  var _a2;
                  return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, ...args)];
                }
              });
            }
          });
        });
        return forwardRefs({
          id: id2,
          openChildren: openChildren
        }, overlay);
      }
    });
    const makeVCounterProps = propsFactory({
      active: Boolean,
      max: [Number, String],
      value: {
        type: [Number, String],
        default: 0
      },
      ...makeComponentProps(),
      ...makeTransitionProps({
        transition: {
          component: VSlideYTransition
        }
      })
    }, "VCounter");
    const VCounter = genericComponent()({
      name: "VCounter",
      functional: true,
      props: makeVCounterProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const counter = computed(() => {
          return props.max ? `${props.value} / ${props.max}` : String(props.value);
        });
        useRender(() => createVNode(MaybeTransition, {
          "transition": props.transition
        }, {
          default: () => [withDirectives(createVNode("div", {
            "class": ["v-counter", props.class],
            "style": props.style
          }, [slots.default ? slots.default({
            counter: counter.value,
            max: props.max,
            value: props.value
          }) : counter.value]), [[vShow, props.active]])]
        }));
        return {};
      }
    });
    const makeVFieldLabelProps = propsFactory({
      floating: Boolean,
      ...makeComponentProps()
    }, "VFieldLabel");
    const VFieldLabel = genericComponent()({
      name: "VFieldLabel",
      props: makeVFieldLabelProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        useRender(() => createVNode(VLabel, {
          "class": ["v-field-label", {
            "v-field-label--floating": props.floating
          }, props.class],
          "style": props.style,
          "aria-hidden": props.floating || void 0
        }, slots));
        return {};
      }
    });
    const allowedVariants$1 = ["underlined", "outlined", "filled", "solo", "solo-inverted", "solo-filled", "plain"];
    const makeVFieldProps = propsFactory({
      appendInnerIcon: IconValue,
      bgColor: String,
      clearable: Boolean,
      clearIcon: {
        type: IconValue,
        default: "$clear"
      },
      active: Boolean,
      centerAffix: {
        type: Boolean,
        default: void 0
      },
      color: String,
      baseColor: String,
      dirty: Boolean,
      disabled: {
        type: Boolean,
        default: null
      },
      error: Boolean,
      flat: Boolean,
      label: String,
      persistentClear: Boolean,
      prependInnerIcon: IconValue,
      reverse: Boolean,
      singleLine: Boolean,
      variant: {
        type: String,
        default: "filled",
        validator: (v) => allowedVariants$1.includes(v)
      },
      "onClick:clear": EventProp(),
      "onClick:appendInner": EventProp(),
      "onClick:prependInner": EventProp(),
      ...makeComponentProps(),
      ...makeLoaderProps(),
      ...makeRoundedProps(),
      ...makeThemeProps()
    }, "VField");
    const VField = genericComponent()({
      name: "VField",
      inheritAttrs: false,
      props: {
        id: String,
        ...makeFocusProps(),
        ...makeVFieldProps()
      },
      emits: {
        "update:focused": (focused) => true,
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          emit: emit2,
          slots
        } = _ref;
        const {
          themeClasses
        } = provideTheme(props);
        const {
          loaderClasses
        } = useLoader(props);
        const {
          focusClasses,
          isFocused,
          focus,
          blur
        } = useFocus(props);
        const {
          InputIcon
        } = useInputIcon(props);
        const {
          roundedClasses
        } = useRounded(props);
        const {
          rtlClasses
        } = useRtl();
        const isActive = computed(() => props.dirty || props.active);
        const hasLabel = computed(() => !props.singleLine && !!(props.label || slots.label));
        const uid2 = getUid();
        const id2 = computed(() => props.id || `input-${uid2}`);
        const messagesId = computed(() => `${id2.value}-messages`);
        const labelRef = ref$1();
        const floatingLabelRef = ref$1();
        const controlRef = ref$1();
        const isPlainOrUnderlined = computed(() => ["plain", "underlined"].includes(props.variant));
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(toRef(props, "bgColor"));
        const {
          textColorClasses,
          textColorStyles
        } = useTextColor(computed(() => {
          return props.error || props.disabled ? void 0 : isActive.value && isFocused.value ? props.color : props.baseColor;
        }));
        watch(isActive, (val) => {
          if (hasLabel.value) {
            const el2 = labelRef.value.$el;
            const targetEl = floatingLabelRef.value.$el;
            requestAnimationFrame(() => {
              const rect2 = nullifyTransforms(el2);
              const targetRect = targetEl.getBoundingClientRect();
              const x = targetRect.x - rect2.x;
              const y = targetRect.y - rect2.y - (rect2.height / 2 - targetRect.height / 2);
              const targetWidth = targetRect.width / 0.75;
              const width = Math.abs(targetWidth - rect2.width) > 1 ? {
                maxWidth: convertToUnit(targetWidth)
              } : void 0;
              const style = getComputedStyle(el2);
              const targetStyle = getComputedStyle(targetEl);
              const duration = parseFloat(style.transitionDuration) * 1e3 || 150;
              const scale = parseFloat(targetStyle.getPropertyValue("--v-field-label-scale"));
              const color = targetStyle.getPropertyValue("color");
              el2.style.visibility = "visible";
              targetEl.style.visibility = "hidden";
              animate(el2, {
                transform: `translate(${x}px, ${y}px) scale(${scale})`,
                color,
                ...width
              }, {
                duration,
                easing: standardEasing,
                direction: val ? "normal" : "reverse"
              }).finished.then(() => {
                el2.style.removeProperty("visibility");
                targetEl.style.removeProperty("visibility");
              });
            });
          }
        }, {
          flush: "post"
        });
        const slotProps = computed(() => ({
          isActive,
          isFocused,
          controlRef,
          blur,
          focus
        }));
        function onClick(e) {
          if (e.target !== document.activeElement) {
            e.preventDefault();
          }
        }
        useRender(() => {
          var _a2, _b, _c;
          const isOutlined = props.variant === "outlined";
          const hasPrepend = slots["prepend-inner"] || props.prependInnerIcon;
          const hasClear = !!(props.clearable || slots.clear);
          const hasAppend = !!(slots["append-inner"] || props.appendInnerIcon || hasClear);
          const label = () => slots.label ? slots.label({
            ...slotProps.value,
            label: props.label,
            props: {
              for: id2.value
            }
          }) : props.label;
          return createVNode("div", mergeProps({
            "class": ["v-field", {
              "v-field--active": isActive.value,
              "v-field--appended": hasAppend,
              "v-field--center-affix": props.centerAffix ?? !isPlainOrUnderlined.value,
              "v-field--disabled": props.disabled,
              "v-field--dirty": props.dirty,
              "v-field--error": props.error,
              "v-field--flat": props.flat,
              "v-field--has-background": !!props.bgColor,
              "v-field--persistent-clear": props.persistentClear,
              "v-field--prepended": hasPrepend,
              "v-field--reverse": props.reverse,
              "v-field--single-line": props.singleLine,
              "v-field--no-label": !label(),
              [`v-field--variant-${props.variant}`]: true
            }, themeClasses.value, backgroundColorClasses.value, focusClasses.value, loaderClasses.value, roundedClasses.value, rtlClasses.value, props.class],
            "style": [backgroundColorStyles.value, props.style],
            "onClick": onClick
          }, attrs), [createVNode("div", {
            "class": "v-field__overlay"
          }, null), createVNode(LoaderSlot, {
            "name": "v-field",
            "active": !!props.loading,
            "color": props.error ? "error" : typeof props.loading === "string" ? props.loading : props.color
          }, {
            default: slots.loader
          }), hasPrepend && createVNode("div", {
            "key": "prepend",
            "class": "v-field__prepend-inner"
          }, [props.prependInnerIcon && createVNode(InputIcon, {
            "key": "prepend-icon",
            "name": "prependInner"
          }, null), (_a2 = slots["prepend-inner"]) == null ? void 0 : _a2.call(slots, slotProps.value)]), createVNode("div", {
            "class": "v-field__field",
            "data-no-activator": ""
          }, [["filled", "solo", "solo-inverted", "solo-filled"].includes(props.variant) && hasLabel.value && createVNode(VFieldLabel, {
            "key": "floating-label",
            "ref": floatingLabelRef,
            "class": [textColorClasses.value],
            "floating": true,
            "for": id2.value,
            "style": textColorStyles.value
          }, {
            default: () => [label()]
          }), createVNode(VFieldLabel, {
            "ref": labelRef,
            "for": id2.value
          }, {
            default: () => [label()]
          }), (_b = slots.default) == null ? void 0 : _b.call(slots, {
            ...slotProps.value,
            props: {
              id: id2.value,
              class: "v-field__input",
              "aria-describedby": messagesId.value
            },
            focus,
            blur
          })]), hasClear && createVNode(VExpandXTransition, {
            "key": "clear"
          }, {
            default: () => [withDirectives(createVNode("div", {
              "class": "v-field__clearable",
              "onMousedown": (e) => {
                e.preventDefault();
                e.stopPropagation();
              }
            }, [slots.clear ? slots.clear() : createVNode(InputIcon, {
              "name": "clear"
            }, null)]), [[vShow, props.dirty]])]
          }), hasAppend && createVNode("div", {
            "key": "append",
            "class": "v-field__append-inner"
          }, [(_c = slots["append-inner"]) == null ? void 0 : _c.call(slots, slotProps.value), props.appendInnerIcon && createVNode(InputIcon, {
            "key": "append-icon",
            "name": "appendInner"
          }, null)]), createVNode("div", {
            "class": ["v-field__outline", textColorClasses.value],
            "style": textColorStyles.value
          }, [isOutlined && createVNode(Fragment, null, [createVNode("div", {
            "class": "v-field__outline__start"
          }, null), hasLabel.value && createVNode("div", {
            "class": "v-field__outline__notch"
          }, [createVNode(VFieldLabel, {
            "ref": floatingLabelRef,
            "floating": true,
            "for": id2.value
          }, {
            default: () => [label()]
          })]), createVNode("div", {
            "class": "v-field__outline__end"
          }, null)]), isPlainOrUnderlined.value && hasLabel.value && createVNode(VFieldLabel, {
            "ref": floatingLabelRef,
            "floating": true,
            "for": id2.value
          }, {
            default: () => [label()]
          })])]);
        });
        return {
          controlRef
        };
      }
    });
    function filterFieldProps(attrs) {
      const keys2 = Object.keys(VField.props).filter((k) => !isOn(k) && k !== "class" && k !== "style");
      return pick(attrs, keys2);
    }
    const activeTypes = ["color", "file", "time", "date", "datetime-local", "week", "month"];
    const makeVTextFieldProps = propsFactory({
      autofocus: Boolean,
      counter: [Boolean, Number, String],
      counterValue: [Number, Function],
      prefix: String,
      placeholder: String,
      persistentPlaceholder: Boolean,
      persistentCounter: Boolean,
      suffix: String,
      role: String,
      type: {
        type: String,
        default: "text"
      },
      modelModifiers: Object,
      ...makeVInputProps(),
      ...makeVFieldProps()
    }, "VTextField");
    const VTextField = genericComponent()({
      name: "VTextField",
      directives: {
        Intersect: Intersect$1
      },
      inheritAttrs: false,
      props: makeVTextFieldProps(),
      emits: {
        "click:control": (e) => true,
        "mousedown:control": (e) => true,
        "update:focused": (focused) => true,
        "update:modelValue": (val) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          emit: emit2,
          slots
        } = _ref;
        const model = useProxiedModel(props, "modelValue");
        const {
          isFocused,
          focus,
          blur
        } = useFocus(props);
        const counterValue = computed(() => {
          return typeof props.counterValue === "function" ? props.counterValue(model.value) : typeof props.counterValue === "number" ? props.counterValue : (model.value ?? "").toString().length;
        });
        const max = computed(() => {
          if (attrs.maxlength)
            return attrs.maxlength;
          if (!props.counter || typeof props.counter !== "number" && typeof props.counter !== "string")
            return void 0;
          return props.counter;
        });
        const isPlainOrUnderlined = computed(() => ["plain", "underlined"].includes(props.variant));
        function onIntersect(isIntersecting, entries) {
          var _a2, _b;
          if (!props.autofocus || !isIntersecting)
            return;
          (_b = (_a2 = entries[0].target) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
        }
        const vInputRef = ref$1();
        const vFieldRef = ref$1();
        const inputRef = ref$1();
        const isActive = computed(() => activeTypes.includes(props.type) || props.persistentPlaceholder || isFocused.value || props.active);
        function onFocus() {
          var _a2;
          if (inputRef.value !== document.activeElement) {
            (_a2 = inputRef.value) == null ? void 0 : _a2.focus();
          }
          if (!isFocused.value)
            focus();
        }
        function onControlMousedown(e) {
          emit2("mousedown:control", e);
          if (e.target === inputRef.value)
            return;
          onFocus();
          e.preventDefault();
        }
        function onControlClick(e) {
          onFocus();
          emit2("click:control", e);
        }
        function onClear(e) {
          e.stopPropagation();
          onFocus();
          nextTick(() => {
            model.value = null;
            callEvent(props["onClick:clear"], e);
          });
        }
        function onInput(e) {
          var _a2;
          const el2 = e.target;
          model.value = el2.value;
          if (((_a2 = props.modelModifiers) == null ? void 0 : _a2.trim) && ["text", "search", "password", "tel", "url"].includes(props.type)) {
            const caretPosition = [el2.selectionStart, el2.selectionEnd];
            nextTick(() => {
              el2.selectionStart = caretPosition[0];
              el2.selectionEnd = caretPosition[1];
            });
          }
        }
        useRender(() => {
          const hasCounter = !!(slots.counter || props.counter !== false && props.counter != null);
          const hasDetails = !!(hasCounter || slots.details);
          const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
          const {
            modelValue: _,
            ...inputProps
          } = VInput.filterProps(props);
          const fieldProps = filterFieldProps(props);
          return createVNode(VInput, mergeProps({
            "ref": vInputRef,
            "modelValue": model.value,
            "onUpdate:modelValue": ($event) => model.value = $event,
            "class": ["v-text-field", {
              "v-text-field--prefixed": props.prefix,
              "v-text-field--suffixed": props.suffix,
              "v-input--plain-underlined": isPlainOrUnderlined.value
            }, props.class],
            "style": props.style
          }, rootAttrs, inputProps, {
            "centerAffix": !isPlainOrUnderlined.value,
            "focused": isFocused.value
          }), {
            ...slots,
            default: (_ref2) => {
              let {
                id: id2,
                isDisabled,
                isDirty,
                isReadonly: isReadonly2,
                isValid: isValid2
              } = _ref2;
              return createVNode(VField, mergeProps({
                "ref": vFieldRef,
                "onMousedown": onControlMousedown,
                "onClick": onControlClick,
                "onClick:clear": onClear,
                "onClick:prependInner": props["onClick:prependInner"],
                "onClick:appendInner": props["onClick:appendInner"],
                "role": props.role
              }, fieldProps, {
                "id": id2.value,
                "active": isActive.value || isDirty.value,
                "dirty": isDirty.value || props.dirty,
                "disabled": isDisabled.value,
                "focused": isFocused.value,
                "error": isValid2.value === false
              }), {
                ...slots,
                default: (_ref3) => {
                  let {
                    props: {
                      class: fieldClass,
                      ...slotProps
                    }
                  } = _ref3;
                  const inputNode = withDirectives(createVNode("input", mergeProps({
                    "ref": inputRef,
                    "value": model.value,
                    "onInput": onInput,
                    "autofocus": props.autofocus,
                    "readonly": isReadonly2.value,
                    "disabled": isDisabled.value,
                    "name": props.name,
                    "placeholder": props.placeholder,
                    "size": 1,
                    "type": props.type,
                    "onFocus": onFocus,
                    "onBlur": blur
                  }, slotProps, inputAttrs), null), [[resolveDirective("intersect"), {
                    handler: onIntersect
                  }, null, {
                    once: true
                  }]]);
                  return createVNode(Fragment, null, [props.prefix && createVNode("span", {
                    "class": "v-text-field__prefix"
                  }, [createVNode("span", {
                    "class": "v-text-field__prefix__text"
                  }, [props.prefix])]), slots.default ? createVNode("div", {
                    "class": fieldClass,
                    "data-no-activator": ""
                  }, [slots.default(), inputNode]) : cloneVNode(inputNode, {
                    class: fieldClass
                  }), props.suffix && createVNode("span", {
                    "class": "v-text-field__suffix"
                  }, [createVNode("span", {
                    "class": "v-text-field__suffix__text"
                  }, [props.suffix])])]);
                }
              });
            },
            details: hasDetails ? (slotProps) => {
              var _a2;
              return createVNode(Fragment, null, [(_a2 = slots.details) == null ? void 0 : _a2.call(slots, slotProps), hasCounter && createVNode(Fragment, null, [createVNode("span", null, null), createVNode(VCounter, {
                "active": props.persistentCounter || isFocused.value,
                "value": counterValue.value,
                "max": max.value
              }, slots.counter)])]);
            } : void 0
          });
        });
        return forwardRefs({}, vInputRef, vFieldRef, inputRef);
      }
    });
    const makeVVirtualScrollItemProps = propsFactory({
      renderless: Boolean,
      ...makeComponentProps()
    }, "VVirtualScrollItem");
    const VVirtualScrollItem = genericComponent()({
      name: "VVirtualScrollItem",
      inheritAttrs: false,
      props: makeVVirtualScrollItemProps(),
      emits: {
        "update:height": (height) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          emit: emit2,
          slots
        } = _ref;
        const {
          resizeRef,
          contentRect
        } = useResizeObserver$1(void 0, "border");
        watch(() => {
          var _a2;
          return (_a2 = contentRect.value) == null ? void 0 : _a2.height;
        }, (height) => {
          if (height != null)
            emit2("update:height", height);
        });
        useRender(() => {
          var _a2, _b;
          return props.renderless ? createVNode(Fragment, null, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
            itemRef: resizeRef
          })]) : createVNode("div", mergeProps({
            "ref": resizeRef,
            "class": ["v-virtual-scroll__item", props.class],
            "style": props.style
          }, attrs), [(_b = slots.default) == null ? void 0 : _b.call(slots)]);
        });
      }
    });
    const UP$1 = -1;
    const DOWN$1 = 1;
    const BUFFER_PX = 100;
    const makeVirtualProps = propsFactory({
      itemHeight: {
        type: [Number, String],
        default: null
      },
      height: [Number, String]
    }, "virtual");
    function useVirtual(props, items2) {
      const display = useDisplay();
      const itemHeight = shallowRef(0);
      watchEffect(() => {
        itemHeight.value = parseFloat(props.itemHeight || 0);
      });
      const first = shallowRef(0);
      const last = shallowRef(Math.ceil(
        // Assume 16px items filling the entire screen height if
        // not provided. This is probably incorrect but it minimises
        // the chance of ending up with empty space at the bottom.
        // The default value is set here to avoid poisoning getSize()
        (parseInt(props.height) || display.height.value) / (itemHeight.value || 16)
      ) || 1);
      const paddingTop = shallowRef(0);
      const paddingBottom = shallowRef(0);
      const containerRef = ref$1();
      const markerRef = ref$1();
      let markerOffset = 0;
      const {
        resizeRef,
        contentRect
      } = useResizeObserver$1();
      watchEffect(() => {
        resizeRef.value = containerRef.value;
      });
      const viewportHeight = computed(() => {
        var _a2;
        return containerRef.value === document.documentElement ? display.height.value : ((_a2 = contentRect.value) == null ? void 0 : _a2.height) || parseInt(props.height) || 0;
      });
      const hasInitialRender = computed(() => {
        return !!(containerRef.value && markerRef.value && viewportHeight.value && itemHeight.value);
      });
      let sizes = Array.from({
        length: items2.value.length
      });
      let offsets = Array.from({
        length: items2.value.length
      });
      const updateTime = shallowRef(0);
      let targetScrollIndex = -1;
      function getSize(index) {
        return sizes[index] || itemHeight.value;
      }
      const updateOffsets = debounce(() => {
        const start = performance.now();
        offsets[0] = 0;
        const length = items2.value.length;
        for (let i2 = 1; i2 <= length - 1; i2++) {
          offsets[i2] = (offsets[i2 - 1] || 0) + getSize(i2 - 1);
        }
        updateTime.value = Math.max(updateTime.value, performance.now() - start);
      }, updateTime);
      const unwatch = watch(hasInitialRender, (v) => {
        if (!v)
          return;
        unwatch();
        markerOffset = markerRef.value.offsetTop;
        updateOffsets.immediate();
        calculateVisibleItems();
        if (!~targetScrollIndex)
          return;
        nextTick(() => {
          IN_BROWSER && window.requestAnimationFrame(() => {
            scrollToIndex(targetScrollIndex);
            targetScrollIndex = -1;
          });
        });
      });
      onScopeDispose(() => {
        updateOffsets.clear();
      });
      function handleItemResize(index, height) {
        const prevHeight = sizes[index];
        const prevMinHeight = itemHeight.value;
        itemHeight.value = prevMinHeight ? Math.min(itemHeight.value, height) : height;
        if (prevHeight !== height || prevMinHeight !== itemHeight.value) {
          sizes[index] = height;
          updateOffsets();
        }
      }
      function calculateOffset(index) {
        index = clamp(index, 0, items2.value.length - 1);
        return offsets[index] || 0;
      }
      function calculateIndex(scrollTop) {
        return binaryClosest(offsets, scrollTop);
      }
      let lastScrollTop = 0;
      let scrollVelocity = 0;
      let lastScrollTime = 0;
      watch(viewportHeight, (val, oldVal) => {
        if (oldVal) {
          calculateVisibleItems();
          if (val < oldVal) {
            requestAnimationFrame(() => {
              scrollVelocity = 0;
              calculateVisibleItems();
            });
          }
        }
      });
      function handleScroll() {
        if (!containerRef.value || !markerRef.value)
          return;
        const scrollTop = containerRef.value.scrollTop;
        const scrollTime = performance.now();
        const scrollDeltaT = scrollTime - lastScrollTime;
        if (scrollDeltaT > 500) {
          scrollVelocity = Math.sign(scrollTop - lastScrollTop);
          markerOffset = markerRef.value.offsetTop;
        } else {
          scrollVelocity = scrollTop - lastScrollTop;
        }
        lastScrollTop = scrollTop;
        lastScrollTime = scrollTime;
        calculateVisibleItems();
      }
      function handleScrollend() {
        if (!containerRef.value || !markerRef.value)
          return;
        scrollVelocity = 0;
        lastScrollTime = 0;
        calculateVisibleItems();
      }
      let raf2 = -1;
      function calculateVisibleItems() {
        cancelAnimationFrame(raf2);
        raf2 = requestAnimationFrame(_calculateVisibleItems);
      }
      function _calculateVisibleItems() {
        if (!containerRef.value || !viewportHeight.value)
          return;
        const scrollTop = lastScrollTop - markerOffset;
        const direction = Math.sign(scrollVelocity);
        const startPx = Math.max(0, scrollTop - BUFFER_PX);
        const start = clamp(calculateIndex(startPx), 0, items2.value.length);
        const endPx = scrollTop + viewportHeight.value + BUFFER_PX;
        const end = clamp(calculateIndex(endPx) + 1, start + 1, items2.value.length);
        if (
          // Only update the side we're scrolling towards,
          // the other side will be updated incidentally
          (direction !== UP$1 || start < first.value) && (direction !== DOWN$1 || end > last.value)
        ) {
          const topOverflow = calculateOffset(first.value) - calculateOffset(start);
          const bottomOverflow = calculateOffset(end) - calculateOffset(last.value);
          const bufferOverflow = Math.max(topOverflow, bottomOverflow);
          if (bufferOverflow > BUFFER_PX) {
            first.value = start;
            last.value = end;
          } else {
            if (start <= 0)
              first.value = start;
            if (end >= items2.value.length)
              last.value = end;
          }
        }
        paddingTop.value = calculateOffset(first.value);
        paddingBottom.value = calculateOffset(items2.value.length) - calculateOffset(last.value);
      }
      function scrollToIndex(index) {
        const offset = calculateOffset(index);
        if (!containerRef.value || index && !offset) {
          targetScrollIndex = index;
        } else {
          containerRef.value.scrollTop = offset;
        }
      }
      const computedItems = computed(() => {
        return items2.value.slice(first.value, last.value).map((item, index) => ({
          raw: item,
          index: index + first.value
        }));
      });
      watch(items2, () => {
        sizes = Array.from({
          length: items2.value.length
        });
        offsets = Array.from({
          length: items2.value.length
        });
        updateOffsets.immediate();
        calculateVisibleItems();
      }, {
        deep: true
      });
      return {
        containerRef,
        markerRef,
        computedItems,
        paddingTop,
        paddingBottom,
        scrollToIndex,
        handleScroll,
        handleScrollend,
        handleItemResize
      };
    }
    function binaryClosest(arr, val) {
      let high = arr.length - 1;
      let low = 0;
      let mid2 = 0;
      let item = null;
      let target2 = -1;
      if (arr[high] < val) {
        return high;
      }
      while (low <= high) {
        mid2 = low + high >> 1;
        item = arr[mid2];
        if (item > val) {
          high = mid2 - 1;
        } else if (item < val) {
          target2 = mid2;
          low = mid2 + 1;
        } else if (item === val) {
          return mid2;
        } else {
          return low;
        }
      }
      return target2;
    }
    const makeVVirtualScrollProps = propsFactory({
      items: {
        type: Array,
        default: () => []
      },
      renderless: Boolean,
      ...makeVirtualProps(),
      ...makeComponentProps(),
      ...makeDimensionProps()
    }, "VVirtualScroll");
    const VVirtualScroll = genericComponent()({
      name: "VVirtualScroll",
      props: makeVVirtualScrollProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const vm = getCurrentInstance("VVirtualScroll");
        const {
          dimensionStyles
        } = useDimension(props);
        const {
          containerRef,
          markerRef,
          handleScroll,
          handleScrollend,
          handleItemResize,
          scrollToIndex,
          paddingTop,
          paddingBottom,
          computedItems
        } = useVirtual(props, toRef(props, "items"));
        useToggleScope(() => props.renderless, () => {
          function handleListeners() {
            var _a2, _b;
            let add2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
            const method = add2 ? "addEventListener" : "removeEventListener";
            if (containerRef.value === document.documentElement) {
              document[method]("scroll", handleScroll, {
                passive: true
              });
              document[method]("scrollend", handleScrollend);
            } else {
              (_a2 = containerRef.value) == null ? void 0 : _a2[method]("scroll", handleScroll, {
                passive: true
              });
              (_b = containerRef.value) == null ? void 0 : _b[method]("scrollend", handleScrollend);
            }
          }
          onMounted(() => {
            containerRef.value = getScrollParent(vm.vnode.el, true);
            handleListeners(true);
          });
          onScopeDispose(handleListeners);
        });
        useRender(() => {
          const children = computedItems.value.map((item) => createVNode(VVirtualScrollItem, {
            "key": item.index,
            "renderless": props.renderless,
            "onUpdate:height": (height) => handleItemResize(item.index, height)
          }, {
            default: (slotProps) => {
              var _a2;
              return (_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
                item: item.raw,
                index: item.index,
                ...slotProps
              });
            }
          }));
          return props.renderless ? createVNode(Fragment, null, [createVNode("div", {
            "ref": markerRef,
            "class": "v-virtual-scroll__spacer",
            "style": {
              paddingTop: convertToUnit(paddingTop.value)
            }
          }, null), children, createVNode("div", {
            "class": "v-virtual-scroll__spacer",
            "style": {
              paddingBottom: convertToUnit(paddingBottom.value)
            }
          }, null)]) : createVNode("div", {
            "ref": containerRef,
            "class": ["v-virtual-scroll", props.class],
            "onScrollPassive": handleScroll,
            "onScrollend": handleScrollend,
            "style": [dimensionStyles.value, props.style]
          }, [createVNode("div", {
            "ref": markerRef,
            "class": "v-virtual-scroll__container",
            "style": {
              paddingTop: convertToUnit(paddingTop.value),
              paddingBottom: convertToUnit(paddingBottom.value)
            }
          }, [children])]);
        });
        return {
          scrollToIndex
        };
      }
    });
    function useScrolling(listRef, textFieldRef) {
      const isScrolling = shallowRef(false);
      let scrollTimeout;
      function onListScroll(e) {
        cancelAnimationFrame(scrollTimeout);
        isScrolling.value = true;
        scrollTimeout = requestAnimationFrame(() => {
          scrollTimeout = requestAnimationFrame(() => {
            isScrolling.value = false;
          });
        });
      }
      async function finishScrolling() {
        await new Promise((resolve2) => requestAnimationFrame(resolve2));
        await new Promise((resolve2) => requestAnimationFrame(resolve2));
        await new Promise((resolve2) => requestAnimationFrame(resolve2));
        await new Promise((resolve2) => {
          if (isScrolling.value) {
            const stop = watch(isScrolling, () => {
              stop();
              resolve2();
            });
          } else
            resolve2();
        });
      }
      async function onListKeydown(e) {
        var _a2, _b;
        if (e.key === "Tab") {
          (_a2 = textFieldRef.value) == null ? void 0 : _a2.focus();
        }
        if (!["PageDown", "PageUp", "Home", "End"].includes(e.key))
          return;
        const el2 = (_b = listRef.value) == null ? void 0 : _b.$el;
        if (!el2)
          return;
        if (e.key === "Home" || e.key === "End") {
          el2.scrollTo({
            top: e.key === "Home" ? 0 : el2.scrollHeight,
            behavior: "smooth"
          });
        }
        await finishScrolling();
        const children = el2.querySelectorAll(":scope > :not(.v-virtual-scroll__spacer)");
        if (e.key === "PageDown" || e.key === "Home") {
          const top2 = el2.getBoundingClientRect().top;
          for (const child of children) {
            if (child.getBoundingClientRect().top >= top2) {
              child.focus();
              break;
            }
          }
        } else {
          const bottom2 = el2.getBoundingClientRect().bottom;
          for (const child of [...children].reverse()) {
            if (child.getBoundingClientRect().bottom <= bottom2) {
              child.focus();
              break;
            }
          }
        }
      }
      return {
        onListScroll,
        onListKeydown
      };
    }
    const makeSelectProps = propsFactory({
      chips: Boolean,
      closableChips: Boolean,
      closeText: {
        type: String,
        default: "$vuetify.close"
      },
      openText: {
        type: String,
        default: "$vuetify.open"
      },
      eager: Boolean,
      hideNoData: Boolean,
      hideSelected: Boolean,
      listProps: {
        type: Object
      },
      menu: Boolean,
      menuIcon: {
        type: IconValue,
        default: "$dropdown"
      },
      menuProps: {
        type: Object
      },
      multiple: Boolean,
      noDataText: {
        type: String,
        default: "$vuetify.noDataText"
      },
      openOnClear: Boolean,
      itemColor: String,
      ...makeItemsProps({
        itemChildren: false
      })
    }, "Select");
    const makeVSelectProps = propsFactory({
      ...makeSelectProps(),
      ...omit$1(makeVTextFieldProps({
        modelValue: null,
        role: "combobox"
      }), ["validationValue", "dirty", "appendInnerIcon"]),
      ...makeTransitionProps({
        transition: {
          component: VDialogTransition
        }
      })
    }, "VSelect");
    const VSelect = genericComponent()({
      name: "VSelect",
      props: makeVSelectProps(),
      emits: {
        "update:focused": (focused) => true,
        "update:modelValue": (value) => true,
        "update:menu": (ue) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          t
        } = useLocale();
        const vTextFieldRef = ref$1();
        const vMenuRef = ref$1();
        const vVirtualScrollRef = ref$1();
        const _menu = useProxiedModel(props, "menu");
        const menu = computed({
          get: () => _menu.value,
          set: (v) => {
            var _a2;
            if (_menu.value && !v && ((_a2 = vMenuRef.value) == null ? void 0 : _a2.openChildren))
              return;
            _menu.value = v;
          }
        });
        const {
          items: items2,
          transformIn,
          transformOut
        } = useItems(props);
        const model = useProxiedModel(props, "modelValue", [], (v) => transformIn(v === null ? [null] : wrapInArray(v)), (v) => {
          const transformed = transformOut(v);
          return props.multiple ? transformed : transformed[0] ?? null;
        });
        const counterValue = computed(() => {
          return typeof props.counterValue === "function" ? props.counterValue(model.value) : typeof props.counterValue === "number" ? props.counterValue : model.value.length;
        });
        const form = useForm();
        const selectedValues = computed(() => model.value.map((selection) => selection.value));
        const isFocused = shallowRef(false);
        const label = computed(() => menu.value ? props.closeText : props.openText);
        let keyboardLookupPrefix = "";
        let keyboardLookupLastTime;
        const displayItems = computed(() => {
          if (props.hideSelected) {
            return items2.value.filter((item) => !model.value.some((s) => s === item));
          }
          return items2.value;
        });
        const menuDisabled = computed(() => props.hideNoData && !displayItems.value.length || props.readonly || (form == null ? void 0 : form.isReadonly.value));
        const computedMenuProps = computed(() => {
          var _a2;
          return {
            ...props.menuProps,
            activatorProps: {
              ...((_a2 = props.menuProps) == null ? void 0 : _a2.activatorProps) || {},
              "aria-haspopup": "listbox"
              // Set aria-haspopup to 'listbox'
            }
          };
        });
        const listRef = ref$1();
        const {
          onListScroll,
          onListKeydown
        } = useScrolling(listRef, vTextFieldRef);
        function onClear(e) {
          if (props.openOnClear) {
            menu.value = true;
          }
        }
        function onMousedownControl() {
          if (menuDisabled.value)
            return;
          menu.value = !menu.value;
        }
        function onKeydown(e) {
          var _a2, _b;
          if (!e.key || props.readonly || (form == null ? void 0 : form.isReadonly.value))
            return;
          if (["Enter", " ", "ArrowDown", "ArrowUp", "Home", "End"].includes(e.key)) {
            e.preventDefault();
          }
          if (["Enter", "ArrowDown", " "].includes(e.key)) {
            menu.value = true;
          }
          if (["Escape", "Tab"].includes(e.key)) {
            menu.value = false;
          }
          if (e.key === "Home") {
            (_a2 = listRef.value) == null ? void 0 : _a2.focus("first");
          } else if (e.key === "End") {
            (_b = listRef.value) == null ? void 0 : _b.focus("last");
          }
          const KEYBOARD_LOOKUP_THRESHOLD = 1e3;
          function checkPrintable(e2) {
            const isPrintableChar = e2.key.length === 1;
            const noModifier = !e2.ctrlKey && !e2.metaKey && !e2.altKey;
            return isPrintableChar && noModifier;
          }
          if (props.multiple || !checkPrintable(e))
            return;
          const now2 = performance.now();
          if (now2 - keyboardLookupLastTime > KEYBOARD_LOOKUP_THRESHOLD) {
            keyboardLookupPrefix = "";
          }
          keyboardLookupPrefix += e.key.toLowerCase();
          keyboardLookupLastTime = now2;
          const item = items2.value.find((item2) => item2.title.toLowerCase().startsWith(keyboardLookupPrefix));
          if (item !== void 0) {
            model.value = [item];
          }
        }
        function select(item) {
          const index = model.value.findIndex((selection) => props.valueComparator(selection.value, item.value));
          const add2 = index === -1;
          if (props.multiple) {
            if (add2) {
              model.value = [...model.value, item];
            } else {
              const value = [...model.value];
              value.splice(index, 1);
              model.value = value;
            }
          } else {
            model.value = add2 ? [item] : [];
            menu.value = false;
          }
        }
        function onBlur(e) {
          var _a2;
          if (!((_a2 = listRef.value) == null ? void 0 : _a2.$el.contains(e.relatedTarget))) {
            menu.value = false;
          }
        }
        function onAfterLeave() {
          var _a2;
          if (isFocused.value) {
            (_a2 = vTextFieldRef.value) == null ? void 0 : _a2.focus();
          }
        }
        function onFocusin(e) {
          isFocused.value = true;
        }
        function onModelUpdate(v) {
          if (v == null)
            model.value = [];
          else if (matchesSelector(vTextFieldRef.value, ":autofill") || matchesSelector(vTextFieldRef.value, ":-webkit-autofill")) {
            const item = items2.value.find((item2) => item2.title === v);
            if (item) {
              select(item);
            }
          } else if (vTextFieldRef.value) {
            vTextFieldRef.value.value = "";
          }
        }
        watch(menu, () => {
          if (!props.hideSelected && menu.value && model.value.length) {
            const index = displayItems.value.findIndex((item) => model.value.some((s) => props.valueComparator(s.value, item.value)));
            IN_BROWSER && window.requestAnimationFrame(() => {
              var _a2;
              index >= 0 && ((_a2 = vVirtualScrollRef.value) == null ? void 0 : _a2.scrollToIndex(index));
            });
          }
        });
        watch(displayItems, (val, oldVal) => {
          if (!isFocused.value)
            return;
          if (!val.length && props.hideNoData) {
            menu.value = false;
          }
          if (!oldVal.length && val.length) {
            menu.value = true;
          }
        });
        useRender(() => {
          const hasChips = !!(props.chips || slots.chip);
          const hasList = !!(!props.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
          const isDirty = model.value.length > 0;
          const textFieldProps = VTextField.filterProps(props);
          const placeholder = isDirty || !isFocused.value && props.label && !props.persistentPlaceholder ? void 0 : props.placeholder;
          return createVNode(VTextField, mergeProps({
            "ref": vTextFieldRef
          }, textFieldProps, {
            "modelValue": model.value.map((v) => v.props.value).join(", "),
            "onUpdate:modelValue": onModelUpdate,
            "focused": isFocused.value,
            "onUpdate:focused": ($event) => isFocused.value = $event,
            "validationValue": model.externalValue,
            "counterValue": counterValue.value,
            "dirty": isDirty,
            "class": ["v-select", {
              "v-select--active-menu": menu.value,
              "v-select--chips": !!props.chips,
              [`v-select--${props.multiple ? "multiple" : "single"}`]: true,
              "v-select--selected": model.value.length,
              "v-select--selection-slot": !!slots.selection
            }, props.class],
            "style": props.style,
            "inputmode": "none",
            "placeholder": placeholder,
            "onClick:clear": onClear,
            "onMousedown:control": onMousedownControl,
            "onBlur": onBlur,
            "onKeydown": onKeydown,
            "aria-label": t(label.value),
            "title": t(label.value)
          }), {
            ...slots,
            default: () => createVNode(Fragment, null, [createVNode(VMenu, mergeProps({
              "ref": vMenuRef,
              "modelValue": menu.value,
              "onUpdate:modelValue": ($event) => menu.value = $event,
              "activator": "parent",
              "contentClass": "v-select__content",
              "disabled": menuDisabled.value,
              "eager": props.eager,
              "maxHeight": 310,
              "openOnClick": false,
              "closeOnContentClick": false,
              "transition": props.transition,
              "onAfterLeave": onAfterLeave
            }, computedMenuProps.value), {
              default: () => [hasList && createVNode(VList, mergeProps({
                "ref": listRef,
                "selected": selectedValues.value,
                "selectStrategy": props.multiple ? "independent" : "single-independent",
                "onMousedown": (e) => e.preventDefault(),
                "onKeydown": onListKeydown,
                "onFocusin": onFocusin,
                "onScrollPassive": onListScroll,
                "tabindex": "-1",
                "aria-live": "polite",
                "color": props.itemColor ?? props.color
              }, props.listProps), {
                default: () => {
                  var _a2, _b, _c;
                  return [(_a2 = slots["prepend-item"]) == null ? void 0 : _a2.call(slots), !displayItems.value.length && !props.hideNoData && (((_b = slots["no-data"]) == null ? void 0 : _b.call(slots)) ?? createVNode(VListItem, {
                    "title": t(props.noDataText)
                  }, null)), createVNode(VVirtualScroll, {
                    "ref": vVirtualScrollRef,
                    "renderless": true,
                    "items": displayItems.value
                  }, {
                    default: (_ref2) => {
                      var _a3;
                      let {
                        item,
                        index,
                        itemRef
                      } = _ref2;
                      const itemProps = mergeProps(item.props, {
                        ref: itemRef,
                        key: index,
                        onClick: () => select(item)
                      });
                      return ((_a3 = slots.item) == null ? void 0 : _a3.call(slots, {
                        item,
                        index,
                        props: itemProps
                      })) ?? createVNode(VListItem, mergeProps(itemProps, {
                        "role": "option"
                      }), {
                        prepend: (_ref3) => {
                          let {
                            isSelected
                          } = _ref3;
                          return createVNode(Fragment, null, [props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                            "key": item.value,
                            "modelValue": isSelected,
                            "ripple": false,
                            "tabindex": "-1"
                          }, null) : void 0, item.props.prependAvatar && createVNode(VAvatar, {
                            "image": item.props.prependAvatar
                          }, null), item.props.prependIcon && createVNode(VIcon, {
                            "icon": item.props.prependIcon
                          }, null)]);
                        }
                      });
                    }
                  }), (_c = slots["append-item"]) == null ? void 0 : _c.call(slots)];
                }
              })]
            }), model.value.map((item, index) => {
              function onChipClose(e) {
                e.stopPropagation();
                e.preventDefault();
                select(item);
              }
              const slotProps = {
                "onClick:close": onChipClose,
                onMousedown(e) {
                  e.preventDefault();
                  e.stopPropagation();
                },
                modelValue: true,
                "onUpdate:modelValue": void 0
              };
              const hasSlot = hasChips ? !!slots.chip : !!slots.selection;
              const slotContent = hasSlot ? ensureValidVNode(hasChips ? slots.chip({
                item,
                index,
                props: slotProps
              }) : slots.selection({
                item,
                index
              })) : void 0;
              if (hasSlot && !slotContent)
                return void 0;
              return createVNode("div", {
                "key": item.value,
                "class": "v-select__selection"
              }, [hasChips ? !slots.chip ? createVNode(VChip, mergeProps({
                "key": "chip",
                "closable": props.closableChips,
                "size": "small",
                "text": item.title,
                "disabled": item.props.disabled
              }, slotProps), null) : createVNode(VDefaultsProvider, {
                "key": "chip-defaults",
                "defaults": {
                  VChip: {
                    closable: props.closableChips,
                    size: "small",
                    text: item.title
                  }
                }
              }, {
                default: () => [slotContent]
              }) : slotContent ?? createVNode("span", {
                "class": "v-select__selection-text"
              }, [item.title, props.multiple && index < model.value.length - 1 && createVNode("span", {
                "class": "v-select__selection-comma"
              }, [createTextVNode(",")])])]);
            })]),
            "append-inner": function() {
              var _a2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return createVNode(Fragment, null, [(_a2 = slots["append-inner"]) == null ? void 0 : _a2.call(slots, ...args), props.menuIcon ? createVNode(VIcon, {
                "class": "v-select__menu-icon",
                "icon": props.menuIcon
              }, null) : void 0]);
            }
          });
        });
        return forwardRefs({
          isFocused,
          menu,
          select
        }, vTextFieldRef);
      }
    });
    const _hoisted_1$5 = {
      key: 0,
      class: "pt-10 text-center font-weight-medium text-h6"
    };
    function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Form = resolveComponent("Form");
      return openBlock(), createBlock(VApp, null, {
        default: withCtx(() => [
          createVNode(VMain, null, {
            default: withCtx(() => [
              createVNode(VContainer, {
                fluid: "",
                "fill-height": ""
              }, {
                default: withCtx(() => [
                  createVNode(VRow, {
                    align: "center",
                    justify: "center"
                  }, {
                    default: withCtx(() => [
                      createVNode(VCol, {
                        xs: "12",
                        sm: "10",
                        md: "8"
                      }, {
                        default: withCtx(() => [
                          createVNode(VCard, { elevation: "10" }, {
                            default: withCtx(() => [
                              createVNode(VToolbar, {
                                dark: "",
                                color: "primary"
                              }, {
                                default: withCtx(() => [
                                  _ctx.currentView === _ctx.ComponentViews.LIST ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                                    createVNode(VToolbarTitle, null, {
                                      default: withCtx(() => [
                                        createTextVNode("Choose EVerest instance")
                                      ]),
                                      _: 1
                                    }),
                                    createVNode(VSpacer),
                                    createVNode(VBtn, {
                                      icon: "mdi-plus",
                                      disabled: _ctx.connecting,
                                      onClick: _ctx.openAddServerView
                                    }, null, 8, ["disabled", "onClick"])
                                  ], 64)) : (openBlock(), createBlock(VToolbarTitle, { key: 1 }, {
                                    default: withCtx(() => [
                                      createTextVNode(toDisplayString(_ctx.currentView === _ctx.ComponentViews.ADD ? "Add" : "Edit") + " server instance", 1)
                                    ]),
                                    _: 1
                                  }))
                                ]),
                                _: 1
                              }),
                              createVNode(VCardText, null, {
                                default: withCtx(() => [
                                  [_ctx.ComponentViews.ADD, _ctx.ComponentViews.EDIT].includes(_ctx.currentView) ? (openBlock(), createBlock(_component_Form, {
                                    key: 0,
                                    onSubmit: _ctx.submitEdit
                                  }, {
                                    default: withCtx(() => [
                                      createVNode(VContainer, null, {
                                        default: withCtx(() => [
                                          createVNode(VRow, null, {
                                            default: withCtx(() => [
                                              createVNode(VCol, {
                                                cols: "12",
                                                sm: "12"
                                              }, {
                                                default: withCtx(() => [
                                                  createVNode(VTextField, {
                                                    label: "Name of EVerest instance",
                                                    modelValue: _ctx.instanceId.value.value,
                                                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.instanceId.value.value = $event),
                                                    "error-messages": _ctx.instanceId.errorMessage.value,
                                                    hint: "For example 'Local', 'Development'..."
                                                  }, null, 8, ["modelValue", "error-messages"])
                                                ]),
                                                _: 1
                                              })
                                            ]),
                                            _: 1
                                          }),
                                          createVNode(VRow, null, {
                                            default: withCtx(() => [
                                              createVNode(VCol, {
                                                cols: "3",
                                                sm: "3"
                                              }, {
                                                default: withCtx(() => [
                                                  createVNode(VSelect, {
                                                    modelValue: _ctx.protocol.value.value,
                                                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.protocol.value.value = $event),
                                                    "error-messages": _ctx.protocol.errorMessage.value,
                                                    label: "Protocol",
                                                    items: [{ value: "ws", title: "ws://" }, { value: "wss", title: "wss://" }]
                                                  }, null, 8, ["modelValue", "error-messages"])
                                                ]),
                                                _: 1
                                              }),
                                              createVNode(VCol, {
                                                cols: "6",
                                                sm: "6"
                                              }, {
                                                default: withCtx(() => [
                                                  createVNode(VTextField, {
                                                    label: "EVerest instance host address",
                                                    modelValue: _ctx.host.value.value,
                                                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.host.value.value = $event),
                                                    "error-messages": _ctx.host.errorMessage.value,
                                                    hint: "For example, oetzi.pionix.net"
                                                  }, null, 8, ["modelValue", "error-messages"])
                                                ]),
                                                _: 1
                                              }),
                                              createVNode(VCol, {
                                                cols: "3",
                                                sm: "3"
                                              }, {
                                                default: withCtx(() => [
                                                  createVNode(VTextField, {
                                                    type: "number",
                                                    label: "Port",
                                                    modelValue: _ctx.port.value.value,
                                                    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.port.value.value = $event),
                                                    "error-messages": _ctx.port.errorMessage.value,
                                                    hint: "For example, 8849"
                                                  }, null, 8, ["modelValue", "error-messages"])
                                                ]),
                                                _: 1
                                              })
                                            ]),
                                            _: 1
                                          }),
                                          createVNode(VRow, null, {
                                            default: withCtx(() => [
                                              createVNode(VCol, null, {
                                                default: withCtx(() => [
                                                  createVNode(VBtn, {
                                                    icon: "mdi-delete",
                                                    elevation: "2",
                                                    onClick: _cache[4] || (_cache[4] = ($event) => _ctx.deleteItem())
                                                  })
                                                ]),
                                                _: 1
                                              }),
                                              createVNode(VSpacer),
                                              createVNode(VCol, { class: "text-right" }, {
                                                default: withCtx(() => [
                                                  createVNode(VBtn, {
                                                    class: "mx-4",
                                                    icon: "mdi-close",
                                                    elevation: "2",
                                                    onClick: _cache[5] || (_cache[5] = ($event) => _ctx.closeEdit())
                                                  }),
                                                  createVNode(VBtn, {
                                                    icon: "mdi-check",
                                                    elevation: "2",
                                                    type: "submit",
                                                    disabled: !_ctx.meta.valid
                                                  }, null, 8, ["disabled"])
                                                ]),
                                                _: 1
                                              })
                                            ]),
                                            _: 1
                                          })
                                        ]),
                                        _: 1
                                      })
                                    ]),
                                    _: 1
                                  }, 8, ["onSubmit"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                                    createVNode(VListSubheader, {
                                      lines: "two",
                                      disabled: _ctx.connecting,
                                      class: "mb-3"
                                    }, {
                                      default: withCtx(() => [
                                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.servers, (server, index) => {
                                          return openBlock(), createBlock(VListItem, {
                                            "prepend-icon": "mdi-server",
                                            key: server.id,
                                            onClick: ($event) => _ctx.connect(server)
                                          }, createSlots({
                                            default: withCtx(() => [
                                              createVNode(VListItemTitle, null, {
                                                default: withCtx(() => [
                                                  createTextVNode(toDisplayString(server.id), 1)
                                                ]),
                                                _: 2
                                              }, 1024),
                                              createVNode(VListItemSubtitle, null, {
                                                default: withCtx(() => [
                                                  createTextVNode(toDisplayString(server.host), 1)
                                                ]),
                                                _: 2
                                              }, 1024)
                                            ]),
                                            _: 2
                                          }, [
                                            server.editable ? {
                                              name: "append",
                                              fn: withCtx(() => [
                                                createVNode(VListItemAction, null, {
                                                  default: withCtx(() => [
                                                    createVNode(VBtn, {
                                                      variant: "text",
                                                      icon: "mdi-pencil",
                                                      onClick: withModifiers(($event) => _ctx.openEditServerView(index), ["prevent", "stop"])
                                                    }, null, 8, ["onClick"])
                                                  ]),
                                                  _: 2
                                                }, 1024)
                                              ]),
                                              key: "0"
                                            } : void 0
                                          ]), 1032, ["onClick"]);
                                        }), 128))
                                      ]),
                                      _: 1
                                    }, 8, ["disabled"]),
                                    createVNode(VCheckbox, {
                                      modelValue: _ctx.connectAutomatically,
                                      "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => _ctx.connectAutomatically = $event),
                                      label: "Automatically connect to this instance"
                                    }, null, 8, ["modelValue"]),
                                    createVNode(VAlert, {
                                      text: _ctx.error.status,
                                      prominent: "",
                                      type: "error",
                                      icon: "mdi-cloud-alert",
                                      modelValue: _ctx.error.active,
                                      "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => _ctx.error.active = $event),
                                      closable: ""
                                    }, null, 8, ["text", "modelValue"]),
                                    createVNode(Transition, null, {
                                      default: withCtx(() => [
                                        _ctx.connecting ? (openBlock(), createElementBlock("p", _hoisted_1$5, toDisplayString(_ctx.connectionStatus), 1)) : createCommentVNode("", true)
                                      ]),
                                      _: 1
                                    }),
                                    createVNode(VProgressLinear, {
                                      active: _ctx.connecting,
                                      height: "10",
                                      absolute: "",
                                      location: "bottom",
                                      indeterminate: ""
                                    }, null, 8, ["active"])
                                  ], 64))
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      });
    }
    const LoginPage = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", _sfc_render$5]]);
    var isVue2 = false;
    /*!
     * pinia v2.1.7
     * (c) 2023 Eduardo San Martin Morote
     * @license MIT
     */
    let activePinia;
    const setActivePinia = (pinia2) => activePinia = pinia2;
    const piniaSymbol = (
      /* istanbul ignore next */
      Symbol()
    );
    function isPlainObject$1(o) {
      return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
    }
    var MutationType;
    (function(MutationType2) {
      MutationType2["direct"] = "direct";
      MutationType2["patchObject"] = "patch object";
      MutationType2["patchFunction"] = "patch function";
    })(MutationType || (MutationType = {}));
    function createPinia() {
      const scope2 = effectScope(true);
      const state = scope2.run(() => ref$1({}));
      let _p = [];
      let toBeInstalled = [];
      const pinia2 = markRaw({
        install(app2) {
          setActivePinia(pinia2);
          {
            pinia2._a = app2;
            app2.provide(piniaSymbol, pinia2);
            app2.config.globalProperties.$pinia = pinia2;
            toBeInstalled.forEach((plugin) => _p.push(plugin));
            toBeInstalled = [];
          }
        },
        use(plugin) {
          if (!this._a && !isVue2) {
            toBeInstalled.push(plugin);
          } else {
            _p.push(plugin);
          }
          return this;
        },
        _p,
        // it's actually undefined here
        // @ts-expect-error
        _a: null,
        _e: scope2,
        _s: /* @__PURE__ */ new Map(),
        state
      });
      return pinia2;
    }
    const noop = () => {
    };
    function addSubscription(subscriptions, callback, detached, onCleanup = noop) {
      subscriptions.push(callback);
      const removeSubscription = () => {
        const idx = subscriptions.indexOf(callback);
        if (idx > -1) {
          subscriptions.splice(idx, 1);
          onCleanup();
        }
      };
      if (!detached && getCurrentScope$1()) {
        onScopeDispose(removeSubscription);
      }
      return removeSubscription;
    }
    function triggerSubscriptions(subscriptions, ...args) {
      subscriptions.slice().forEach((callback) => {
        callback(...args);
      });
    }
    const fallbackRunWithContext = (fn) => fn();
    function mergeReactiveObjects(target2, patchToApply) {
      if (target2 instanceof Map && patchToApply instanceof Map) {
        patchToApply.forEach((value, key) => target2.set(key, value));
      }
      if (target2 instanceof Set && patchToApply instanceof Set) {
        patchToApply.forEach(target2.add, target2);
      }
      for (const key in patchToApply) {
        if (!patchToApply.hasOwnProperty(key))
          continue;
        const subPatch = patchToApply[key];
        const targetValue = target2[key];
        if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && target2.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
          target2[key] = mergeReactiveObjects(targetValue, subPatch);
        } else {
          target2[key] = subPatch;
        }
      }
      return target2;
    }
    const skipHydrateSymbol = (
      /* istanbul ignore next */
      Symbol()
    );
    function shouldHydrate(obj) {
      return !isPlainObject$1(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
    }
    const { assign: assign$2 } = Object;
    function isComputed(o) {
      return !!(isRef(o) && o.effect);
    }
    function createOptionsStore(id2, options, pinia2, hot) {
      const { state, actions, getters } = options;
      const initialState = pinia2.state.value[id2];
      let store;
      function setup2() {
        if (!initialState && true) {
          {
            pinia2.state.value[id2] = state ? state() : {};
          }
        }
        const localState = toRefs(pinia2.state.value[id2]);
        return assign$2(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
          computedGetters[name] = markRaw(computed(() => {
            setActivePinia(pinia2);
            const store2 = pinia2._s.get(id2);
            return getters[name].call(store2, store2);
          }));
          return computedGetters;
        }, {}));
      }
      store = createSetupStore(id2, setup2, options, pinia2, hot, true);
      return store;
    }
    function createSetupStore($id2, setup2, options = {}, pinia2, hot, isOptionsStore) {
      let scope2;
      const optionsForPlugin = assign$2({ actions: {} }, options);
      const $subscribeOptions = {
        deep: true
        // flush: 'post',
      };
      let isListening;
      let isSyncListening;
      let subscriptions = [];
      let actionSubscriptions = [];
      let debuggerEvents;
      const initialState = pinia2.state.value[$id2];
      if (!isOptionsStore && !initialState && true) {
        {
          pinia2.state.value[$id2] = {};
        }
      }
      ref$1({});
      let activeListener;
      function $patch(partialStateOrMutator) {
        let subscriptionMutation;
        isListening = isSyncListening = false;
        if (typeof partialStateOrMutator === "function") {
          partialStateOrMutator(pinia2.state.value[$id2]);
          subscriptionMutation = {
            type: MutationType.patchFunction,
            storeId: $id2,
            events: debuggerEvents
          };
        } else {
          mergeReactiveObjects(pinia2.state.value[$id2], partialStateOrMutator);
          subscriptionMutation = {
            type: MutationType.patchObject,
            payload: partialStateOrMutator,
            storeId: $id2,
            events: debuggerEvents
          };
        }
        const myListenerId = activeListener = Symbol();
        nextTick().then(() => {
          if (activeListener === myListenerId) {
            isListening = true;
          }
        });
        isSyncListening = true;
        triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id2]);
      }
      const $reset = isOptionsStore ? function $reset2() {
        const { state } = options;
        const newState = state ? state() : {};
        this.$patch(($state) => {
          assign$2($state, newState);
        });
      } : (
        /* istanbul ignore next */
        noop
      );
      function $dispose() {
        scope2.stop();
        subscriptions = [];
        actionSubscriptions = [];
        pinia2._s.delete($id2);
      }
      function wrapAction(name, action) {
        return function() {
          setActivePinia(pinia2);
          const args = Array.from(arguments);
          const afterCallbackList = [];
          const onErrorCallbackList = [];
          function after(callback) {
            afterCallbackList.push(callback);
          }
          function onError(callback) {
            onErrorCallbackList.push(callback);
          }
          triggerSubscriptions(actionSubscriptions, {
            args,
            name,
            store,
            after,
            onError
          });
          let ret;
          try {
            ret = action.apply(this && this.$id === $id2 ? this : store, args);
          } catch (error2) {
            triggerSubscriptions(onErrorCallbackList, error2);
            throw error2;
          }
          if (ret instanceof Promise) {
            return ret.then((value) => {
              triggerSubscriptions(afterCallbackList, value);
              return value;
            }).catch((error2) => {
              triggerSubscriptions(onErrorCallbackList, error2);
              return Promise.reject(error2);
            });
          }
          triggerSubscriptions(afterCallbackList, ret);
          return ret;
        };
      }
      const partialStore = {
        _p: pinia2,
        // _s: scope,
        $id: $id2,
        $onAction: addSubscription.bind(null, actionSubscriptions),
        $patch,
        $reset,
        $subscribe(callback, options2 = {}) {
          const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
          const stopWatcher = scope2.run(() => watch(() => pinia2.state.value[$id2], (state) => {
            if (options2.flush === "sync" ? isSyncListening : isListening) {
              callback({
                storeId: $id2,
                type: MutationType.direct,
                events: debuggerEvents
              }, state);
            }
          }, assign$2({}, $subscribeOptions, options2)));
          return removeSubscription;
        },
        $dispose
      };
      const store = reactive(partialStore);
      pinia2._s.set($id2, store);
      const runWithContext = pinia2._a && pinia2._a.runWithContext || fallbackRunWithContext;
      const setupStore = runWithContext(() => pinia2._e.run(() => (scope2 = effectScope()).run(setup2)));
      for (const key in setupStore) {
        const prop2 = setupStore[key];
        if (isRef(prop2) && !isComputed(prop2) || isReactive(prop2)) {
          if (!isOptionsStore) {
            if (initialState && shouldHydrate(prop2)) {
              if (isRef(prop2)) {
                prop2.value = initialState[key];
              } else {
                mergeReactiveObjects(prop2, initialState[key]);
              }
            }
            {
              pinia2.state.value[$id2][key] = prop2;
            }
          }
        } else if (typeof prop2 === "function") {
          const actionValue = wrapAction(key, prop2);
          {
            setupStore[key] = actionValue;
          }
          optionsForPlugin.actions[key] = prop2;
        } else
          ;
      }
      {
        assign$2(store, setupStore);
        assign$2(toRaw(store), setupStore);
      }
      Object.defineProperty(store, "$state", {
        get: () => pinia2.state.value[$id2],
        set: (state) => {
          $patch(($state) => {
            assign$2($state, state);
          });
        }
      });
      pinia2._p.forEach((extender) => {
        {
          assign$2(store, scope2.run(() => extender({
            store,
            app: pinia2._a,
            pinia: pinia2,
            options: optionsForPlugin
          })));
        }
      });
      if (initialState && isOptionsStore && options.hydrate) {
        options.hydrate(store.$state, initialState);
      }
      isListening = true;
      isSyncListening = true;
      return store;
    }
    function defineStore(idOrOptions, setup2, setupOptions) {
      let id2;
      let options;
      const isSetupStore = typeof setup2 === "function";
      if (typeof idOrOptions === "string") {
        id2 = idOrOptions;
        options = isSetupStore ? setupOptions : setup2;
      } else {
        options = idOrOptions;
        id2 = idOrOptions.id;
      }
      function useStore(pinia2, hot) {
        const hasContext = hasInjectionContext();
        pinia2 = // in test mode, ignore the argument provided as we can always retrieve a
        // pinia instance with getActivePinia()
        pinia2 || (hasContext ? inject$1(piniaSymbol, null) : null);
        if (pinia2)
          setActivePinia(pinia2);
        pinia2 = activePinia;
        if (!pinia2._s.has(id2)) {
          if (isSetupStore) {
            createSetupStore(id2, setup2, options, pinia2);
          } else {
            createOptionsStore(id2, options, pinia2);
          }
        }
        const store = pinia2._s.get(id2);
        return store;
      }
      useStore.$id = id2;
      return useStore;
    }
    class ConfigStageContext {
      constructor() {
        __publicField(this, "_event_handlers", []);
        __publicField(this, "container");
        __publicField(this, "_current_selected_terminal", null);
      }
      // constructor() {}
      add_observer(handler) {
        this._event_handlers.push(handler);
      }
      remove_observer(handler) {
        this._event_handlers.splice(this._event_handlers.indexOf(handler), 1);
      }
      set_container(container) {
        this.container = container;
      }
      _clear_terminal_selection() {
        this._current_selected_terminal = null;
      }
      clicked_instance(id2) {
        this._clear_terminal_selection();
        this._publish({ type: "SELECT", selection: { type: "MODULE_INSTANCE", id: id2 } });
      }
      clicked_terminal(terminal, module_instance_id) {
        if (!this._current_selected_terminal) {
          this._publish({ type: "SELECT", selection: { type: "TERMINAL", terminal } });
          this._current_selected_terminal = {
            ...terminal,
            module_instance_id
          };
          return;
        }
        this._publish({
          type: "ADD_CONNECTION",
          // FIXME (aw): is there a way making this more beautiful?
          connection: {
            providing_impl_name: terminal.type === "provide" ? terminal.id : this._current_selected_terminal.id,
            providing_instance_id: terminal.type === "provide" ? module_instance_id : this._current_selected_terminal.module_instance_id,
            requirement_name: terminal.type === "requirement" ? terminal.id : this._current_selected_terminal.id,
            requiring_instance_id: terminal.type === "requirement" ? module_instance_id : this._current_selected_terminal.module_instance_id
          }
        });
        this.unselect();
      }
      unselect() {
        this._clear_terminal_selection();
        this._publish({
          type: "SELECT",
          selection: { type: "NONE" }
        });
      }
      clicked_connection(id2) {
        this._clear_terminal_selection();
        this._publish({
          type: "SELECT",
          selection: { type: "CONNECTION", id: id2 }
        });
      }
      _publish(event) {
        this._event_handlers.forEach((handler) => {
          handler(event);
        });
      }
    }
    const useEvbcStore = defineStore("evbc", () => {
      const config_opened = ref$1(false);
      const selection = ref$1({ type: "NONE" });
      const config_model = ref$1(null);
      const config_context = reactive(new ConfigStageContext());
      config_context.add_observer((ev) => {
        if (ev.type === "SELECT") {
          selection.value = ev.selection;
        }
      });
      function setOpenedConfig(model) {
        if (config_opened.value) {
          config_opened.value = false;
        }
        config_model.value = model;
        config_opened.value = true;
      }
      function resetOpenedConfig() {
        config_model.value = null;
        config_opened.value = false;
      }
      function setCurrentSelection(sel) {
        selection.value = sel;
      }
      const get_config_context = () => config_context;
      const get_current_config = () => config_opened.value ? config_model.value : null;
      const get_selected_module_instance = () => config_opened.value && selection.value.type === "MODULE_INSTANCE" ? selection.value.id : null;
      const get_selected_terminal = () => config_opened.value && selection.value.type === "TERMINAL" ? selection.value.terminal : null;
      const get_selected_connection = () => config_opened.value && selection.value.type === "CONNECTION" ? selection.value.id : null;
      return {
        config_opened,
        selection,
        config_model,
        config_context,
        setOpenedConfig,
        resetOpenedConfig,
        setCurrentSelection,
        get_config_context,
        get_current_config,
        get_selected_module_instance,
        get_selected_terminal,
        get_selected_connection
      };
    });
    var PI_OVER_180 = Math.PI / 180;
    function detectBrowser() {
      return typeof window !== "undefined" && ({}.toString.call(window) === "[object Window]" || {}.toString.call(window) === "[object global]");
    }
    const glob = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" ? self : {};
    const Konva$2 = {
      _global: glob,
      version: "8.4.3",
      isBrowser: detectBrowser(),
      isUnminified: /param/.test((function(param) {
      }).toString()),
      dblClickWindow: 400,
      getAngle(angle2) {
        return Konva$2.angleDeg ? angle2 * PI_OVER_180 : angle2;
      },
      enableTrace: false,
      pointerEventsEnabled: true,
      autoDrawEnabled: true,
      hitOnDragEnabled: false,
      capturePointerEventsEnabled: false,
      _mouseListenClick: false,
      _touchListenClick: false,
      _pointerListenClick: false,
      _mouseInDblClickWindow: false,
      _touchInDblClickWindow: false,
      _pointerInDblClickWindow: false,
      _mouseDblClickPointerId: null,
      _touchDblClickPointerId: null,
      _pointerDblClickPointerId: null,
      pixelRatio: typeof window !== "undefined" && window.devicePixelRatio || 1,
      dragDistance: 3,
      angleDeg: true,
      showWarnings: true,
      dragButtons: [0, 1],
      isDragging() {
        return Konva$2["DD"].isDragging;
      },
      isDragReady() {
        return !!Konva$2["DD"].node;
      },
      releaseCanvasOnDestroy: true,
      document: glob.document,
      _injectGlobal(Konva2) {
        glob.Konva = Konva2;
      }
    };
    const _registerNode = (NodeClass) => {
      Konva$2[NodeClass.prototype.getClassName()] = NodeClass;
    };
    Konva$2._injectGlobal(Konva$2);
    class Transform {
      constructor(m = [1, 0, 0, 1, 0, 0]) {
        this.dirty = false;
        this.m = m && m.slice() || [1, 0, 0, 1, 0, 0];
      }
      reset() {
        this.m[0] = 1;
        this.m[1] = 0;
        this.m[2] = 0;
        this.m[3] = 1;
        this.m[4] = 0;
        this.m[5] = 0;
      }
      copy() {
        return new Transform(this.m);
      }
      copyInto(tr) {
        tr.m[0] = this.m[0];
        tr.m[1] = this.m[1];
        tr.m[2] = this.m[2];
        tr.m[3] = this.m[3];
        tr.m[4] = this.m[4];
        tr.m[5] = this.m[5];
      }
      point(point) {
        var m = this.m;
        return {
          x: m[0] * point.x + m[2] * point.y + m[4],
          y: m[1] * point.x + m[3] * point.y + m[5]
        };
      }
      translate(x, y) {
        this.m[4] += this.m[0] * x + this.m[2] * y;
        this.m[5] += this.m[1] * x + this.m[3] * y;
        return this;
      }
      scale(sx, sy) {
        this.m[0] *= sx;
        this.m[1] *= sx;
        this.m[2] *= sy;
        this.m[3] *= sy;
        return this;
      }
      rotate(rad) {
        var c = Math.cos(rad);
        var s = Math.sin(rad);
        var m11 = this.m[0] * c + this.m[2] * s;
        var m12 = this.m[1] * c + this.m[3] * s;
        var m21 = this.m[0] * -s + this.m[2] * c;
        var m22 = this.m[1] * -s + this.m[3] * c;
        this.m[0] = m11;
        this.m[1] = m12;
        this.m[2] = m21;
        this.m[3] = m22;
        return this;
      }
      getTranslation() {
        return {
          x: this.m[4],
          y: this.m[5]
        };
      }
      skew(sx, sy) {
        var m11 = this.m[0] + this.m[2] * sy;
        var m12 = this.m[1] + this.m[3] * sy;
        var m21 = this.m[2] + this.m[0] * sx;
        var m22 = this.m[3] + this.m[1] * sx;
        this.m[0] = m11;
        this.m[1] = m12;
        this.m[2] = m21;
        this.m[3] = m22;
        return this;
      }
      multiply(matrix) {
        var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
        var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];
        var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
        var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];
        var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
        var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];
        this.m[0] = m11;
        this.m[1] = m12;
        this.m[2] = m21;
        this.m[3] = m22;
        this.m[4] = dx;
        this.m[5] = dy;
        return this;
      }
      invert() {
        var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
        var m0 = this.m[3] * d;
        var m1 = -this.m[1] * d;
        var m2 = -this.m[2] * d;
        var m3 = this.m[0] * d;
        var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
        var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
        this.m[0] = m0;
        this.m[1] = m1;
        this.m[2] = m2;
        this.m[3] = m3;
        this.m[4] = m4;
        this.m[5] = m5;
        return this;
      }
      getMatrix() {
        return this.m;
      }
      decompose() {
        var a = this.m[0];
        var b = this.m[1];
        var c = this.m[2];
        var d = this.m[3];
        var e = this.m[4];
        var f = this.m[5];
        var delta2 = a * d - b * c;
        let result = {
          x: e,
          y: f,
          rotation: 0,
          scaleX: 0,
          scaleY: 0,
          skewX: 0,
          skewY: 0
        };
        if (a != 0 || b != 0) {
          var r = Math.sqrt(a * a + b * b);
          result.rotation = b > 0 ? Math.acos(a / r) : -Math.acos(a / r);
          result.scaleX = r;
          result.scaleY = delta2 / r;
          result.skewX = (a * c + b * d) / delta2;
          result.skewY = 0;
        } else if (c != 0 || d != 0) {
          var s = Math.sqrt(c * c + d * d);
          result.rotation = Math.PI / 2 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s));
          result.scaleX = delta2 / s;
          result.scaleY = s;
          result.skewX = 0;
          result.skewY = (a * c + b * d) / delta2;
        } else
          ;
        result.rotation = Util._getRotation(result.rotation);
        return result;
      }
    }
    var OBJECT_ARRAY = "[object Array]", OBJECT_NUMBER = "[object Number]", OBJECT_STRING = "[object String]", OBJECT_BOOLEAN = "[object Boolean]", PI_OVER_DEG180 = Math.PI / 180, DEG180_OVER_PI = 180 / Math.PI, HASH$1 = "#", EMPTY_STRING$1 = "", ZERO = "0", KONVA_WARNING = "Konva warning: ", KONVA_ERROR = "Konva error: ", RGB_PAREN = "rgb(", COLORS = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 132, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 255, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 203],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [119, 128, 144],
      slategrey: [119, 128, 144],
      snow: [255, 255, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      transparent: [255, 255, 255, 0],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 5]
    }, RGB_REGEX = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/, animQueue = [];
    const req = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame || function(f) {
      setTimeout(f, 60);
    };
    const Util = {
      _isElement(obj) {
        return !!(obj && obj.nodeType == 1);
      },
      _isFunction(obj) {
        return !!(obj && obj.constructor && obj.call && obj.apply);
      },
      _isPlainObject(obj) {
        return !!obj && obj.constructor === Object;
      },
      _isArray(obj) {
        return Object.prototype.toString.call(obj) === OBJECT_ARRAY;
      },
      _isNumber(obj) {
        return Object.prototype.toString.call(obj) === OBJECT_NUMBER && !isNaN(obj) && isFinite(obj);
      },
      _isString(obj) {
        return Object.prototype.toString.call(obj) === OBJECT_STRING;
      },
      _isBoolean(obj) {
        return Object.prototype.toString.call(obj) === OBJECT_BOOLEAN;
      },
      isObject(val) {
        return val instanceof Object;
      },
      isValidSelector(selector) {
        if (typeof selector !== "string") {
          return false;
        }
        var firstChar = selector[0];
        return firstChar === "#" || firstChar === "." || firstChar === firstChar.toUpperCase();
      },
      _sign(number) {
        if (number === 0) {
          return 1;
        }
        if (number > 0) {
          return 1;
        } else {
          return -1;
        }
      },
      requestAnimFrame(callback) {
        animQueue.push(callback);
        if (animQueue.length === 1) {
          req(function() {
            const queue2 = animQueue;
            animQueue = [];
            queue2.forEach(function(cb) {
              cb();
            });
          });
        }
      },
      createCanvasElement() {
        var canvas = document.createElement("canvas");
        try {
          canvas.style = canvas.style || {};
        } catch (e) {
        }
        return canvas;
      },
      createImageElement() {
        return document.createElement("img");
      },
      _isInDocument(el2) {
        while (el2 = el2.parentNode) {
          if (el2 == document) {
            return true;
          }
        }
        return false;
      },
      _urlToImage(url, callback) {
        var imageObj = Util.createImageElement();
        imageObj.onload = function() {
          callback(imageObj);
        };
        imageObj.src = url;
      },
      _rgbToHex(r, g, b) {
        return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
      },
      _hexToRgb(hex2) {
        hex2 = hex2.replace(HASH$1, EMPTY_STRING$1);
        var bigint = parseInt(hex2, 16);
        return {
          r: bigint >> 16 & 255,
          g: bigint >> 8 & 255,
          b: bigint & 255
        };
      },
      getRandomColor() {
        var randColor = (Math.random() * 16777215 << 0).toString(16);
        while (randColor.length < 6) {
          randColor = ZERO + randColor;
        }
        return HASH$1 + randColor;
      },
      getRGB(color) {
        var rgb2;
        if (color in COLORS) {
          rgb2 = COLORS[color];
          return {
            r: rgb2[0],
            g: rgb2[1],
            b: rgb2[2]
          };
        } else if (color[0] === HASH$1) {
          return this._hexToRgb(color.substring(1));
        } else if (color.substr(0, 4) === RGB_PAREN) {
          rgb2 = RGB_REGEX.exec(color.replace(/ /g, ""));
          return {
            r: parseInt(rgb2[1], 10),
            g: parseInt(rgb2[2], 10),
            b: parseInt(rgb2[3], 10)
          };
        } else {
          return {
            r: 0,
            g: 0,
            b: 0
          };
        }
      },
      colorToRGBA(str) {
        str = str || "black";
        return Util._namedColorToRBA(str) || Util._hex3ColorToRGBA(str) || Util._hex4ColorToRGBA(str) || Util._hex6ColorToRGBA(str) || Util._hex8ColorToRGBA(str) || Util._rgbColorToRGBA(str) || Util._rgbaColorToRGBA(str) || Util._hslColorToRGBA(str);
      },
      _namedColorToRBA(str) {
        var c = COLORS[str.toLowerCase()];
        if (!c) {
          return null;
        }
        return {
          r: c[0],
          g: c[1],
          b: c[2],
          a: 1
        };
      },
      _rgbColorToRGBA(str) {
        if (str.indexOf("rgb(") === 0) {
          str = str.match(/rgb\(([^)]+)\)/)[1];
          var parts = str.split(/ *, */).map(Number);
          return {
            r: parts[0],
            g: parts[1],
            b: parts[2],
            a: 1
          };
        }
      },
      _rgbaColorToRGBA(str) {
        if (str.indexOf("rgba(") === 0) {
          str = str.match(/rgba\(([^)]+)\)/)[1];
          var parts = str.split(/ *, */).map((n, index) => {
            if (n.slice(-1) === "%") {
              return index === 3 ? parseInt(n) / 100 : parseInt(n) / 100 * 255;
            }
            return Number(n);
          });
          return {
            r: parts[0],
            g: parts[1],
            b: parts[2],
            a: parts[3]
          };
        }
      },
      _hex8ColorToRGBA(str) {
        if (str[0] === "#" && str.length === 9) {
          return {
            r: parseInt(str.slice(1, 3), 16),
            g: parseInt(str.slice(3, 5), 16),
            b: parseInt(str.slice(5, 7), 16),
            a: parseInt(str.slice(7, 9), 16) / 255
          };
        }
      },
      _hex6ColorToRGBA(str) {
        if (str[0] === "#" && str.length === 7) {
          return {
            r: parseInt(str.slice(1, 3), 16),
            g: parseInt(str.slice(3, 5), 16),
            b: parseInt(str.slice(5, 7), 16),
            a: 1
          };
        }
      },
      _hex4ColorToRGBA(str) {
        if (str[0] === "#" && str.length === 5) {
          return {
            r: parseInt(str[1] + str[1], 16),
            g: parseInt(str[2] + str[2], 16),
            b: parseInt(str[3] + str[3], 16),
            a: parseInt(str[4] + str[4], 16) / 255
          };
        }
      },
      _hex3ColorToRGBA(str) {
        if (str[0] === "#" && str.length === 4) {
          return {
            r: parseInt(str[1] + str[1], 16),
            g: parseInt(str[2] + str[2], 16),
            b: parseInt(str[3] + str[3], 16),
            a: 1
          };
        }
      },
      _hslColorToRGBA(str) {
        if (/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.test(str)) {
          const [_, ...hsl2] = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(str);
          const h2 = Number(hsl2[0]) / 360;
          const s = Number(hsl2[1]) / 100;
          const l = Number(hsl2[2]) / 100;
          let t2;
          let t3;
          let val;
          if (s === 0) {
            val = l * 255;
            return {
              r: Math.round(val),
              g: Math.round(val),
              b: Math.round(val),
              a: 1
            };
          }
          if (l < 0.5) {
            t2 = l * (1 + s);
          } else {
            t2 = l + s - l * s;
          }
          const t1 = 2 * l - t2;
          const rgb2 = [0, 0, 0];
          for (let i2 = 0; i2 < 3; i2++) {
            t3 = h2 + 1 / 3 * -(i2 - 1);
            if (t3 < 0) {
              t3++;
            }
            if (t3 > 1) {
              t3--;
            }
            if (6 * t3 < 1) {
              val = t1 + (t2 - t1) * 6 * t3;
            } else if (2 * t3 < 1) {
              val = t2;
            } else if (3 * t3 < 2) {
              val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
            } else {
              val = t1;
            }
            rgb2[i2] = val * 255;
          }
          return {
            r: Math.round(rgb2[0]),
            g: Math.round(rgb2[1]),
            b: Math.round(rgb2[2]),
            a: 1
          };
        }
      },
      haveIntersection(r1, r2) {
        return !(r2.x > r1.x + r1.width || r2.x + r2.width < r1.x || r2.y > r1.y + r1.height || r2.y + r2.height < r1.y);
      },
      cloneObject(obj) {
        var retObj = {};
        for (var key in obj) {
          if (this._isPlainObject(obj[key])) {
            retObj[key] = this.cloneObject(obj[key]);
          } else if (this._isArray(obj[key])) {
            retObj[key] = this.cloneArray(obj[key]);
          } else {
            retObj[key] = obj[key];
          }
        }
        return retObj;
      },
      cloneArray(arr) {
        return arr.slice(0);
      },
      degToRad(deg2) {
        return deg2 * PI_OVER_DEG180;
      },
      radToDeg(rad) {
        return rad * DEG180_OVER_PI;
      },
      _degToRad(deg2) {
        Util.warn("Util._degToRad is removed. Please use public Util.degToRad instead.");
        return Util.degToRad(deg2);
      },
      _radToDeg(rad) {
        Util.warn("Util._radToDeg is removed. Please use public Util.radToDeg instead.");
        return Util.radToDeg(rad);
      },
      _getRotation(radians) {
        return Konva$2.angleDeg ? Util.radToDeg(radians) : radians;
      },
      _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      },
      throw(str) {
        throw new Error(KONVA_ERROR + str);
      },
      error(str) {
        console.error(KONVA_ERROR + str);
      },
      warn(str) {
        if (!Konva$2.showWarnings) {
          return;
        }
        console.warn(KONVA_WARNING + str);
      },
      each(obj, func) {
        for (var key in obj) {
          func(key, obj[key]);
        }
      },
      _inRange(val, left, right) {
        return left <= val && val < right;
      },
      _getProjectionToSegment(x1, y1, x2, y2, x3, y3) {
        var x, y, dist2;
        var pd2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
        if (pd2 == 0) {
          x = x1;
          y = y1;
          dist2 = (x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2);
        } else {
          var u = ((x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1)) / pd2;
          if (u < 0) {
            x = x1;
            y = y1;
            dist2 = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3);
          } else if (u > 1) {
            x = x2;
            y = y2;
            dist2 = (x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3);
          } else {
            x = x1 + u * (x2 - x1);
            y = y1 + u * (y2 - y1);
            dist2 = (x - x3) * (x - x3) + (y - y3) * (y - y3);
          }
        }
        return [x, y, dist2];
      },
      _getProjectionToLine(pt, line, isClosed) {
        var pc = Util.cloneObject(pt);
        var dist2 = Number.MAX_VALUE;
        line.forEach(function(p1, i2) {
          if (!isClosed && i2 === line.length - 1) {
            return;
          }
          var p2 = line[(i2 + 1) % line.length];
          var proj = Util._getProjectionToSegment(p1.x, p1.y, p2.x, p2.y, pt.x, pt.y);
          var px = proj[0], py = proj[1], pdist = proj[2];
          if (pdist < dist2) {
            pc.x = px;
            pc.y = py;
            dist2 = pdist;
          }
        });
        return pc;
      },
      _prepareArrayForTween(startArray, endArray, isClosed) {
        var n, start = [], end = [];
        if (startArray.length > endArray.length) {
          var temp = endArray;
          endArray = startArray;
          startArray = temp;
        }
        for (n = 0; n < startArray.length; n += 2) {
          start.push({
            x: startArray[n],
            y: startArray[n + 1]
          });
        }
        for (n = 0; n < endArray.length; n += 2) {
          end.push({
            x: endArray[n],
            y: endArray[n + 1]
          });
        }
        var newStart = [];
        end.forEach(function(point) {
          var pr2 = Util._getProjectionToLine(point, start, isClosed);
          newStart.push(pr2.x);
          newStart.push(pr2.y);
        });
        return newStart;
      },
      _prepareToStringify(obj) {
        var desc;
        obj.visitedByCircularReferenceRemoval = true;
        for (var key in obj) {
          if (!(obj.hasOwnProperty(key) && obj[key] && typeof obj[key] == "object")) {
            continue;
          }
          desc = Object.getOwnPropertyDescriptor(obj, key);
          if (obj[key].visitedByCircularReferenceRemoval || Util._isElement(obj[key])) {
            if (desc.configurable) {
              delete obj[key];
            } else {
              return null;
            }
          } else if (Util._prepareToStringify(obj[key]) === null) {
            if (desc.configurable) {
              delete obj[key];
            } else {
              return null;
            }
          }
        }
        delete obj.visitedByCircularReferenceRemoval;
        return obj;
      },
      _assign(target2, source) {
        for (var key in source) {
          target2[key] = source[key];
        }
        return target2;
      },
      _getFirstPointerId(evt) {
        if (!evt.touches) {
          return evt.pointerId || 999;
        } else {
          return evt.changedTouches[0].identifier;
        }
      },
      releaseCanvas(...canvases) {
        if (!Konva$2.releaseCanvasOnDestroy)
          return;
        canvases.forEach((c) => {
          c.width = 0;
          c.height = 0;
        });
      },
      drawRoundedRectPath(context, width, height, cornerRadius) {
        let topLeft = 0;
        let topRight = 0;
        let bottomLeft = 0;
        let bottomRight = 0;
        if (typeof cornerRadius === "number") {
          topLeft = topRight = bottomLeft = bottomRight = Math.min(cornerRadius, width / 2, height / 2);
        } else {
          topLeft = Math.min(cornerRadius[0] || 0, width / 2, height / 2);
          topRight = Math.min(cornerRadius[1] || 0, width / 2, height / 2);
          bottomRight = Math.min(cornerRadius[2] || 0, width / 2, height / 2);
          bottomLeft = Math.min(cornerRadius[3] || 0, width / 2, height / 2);
        }
        context.moveTo(topLeft, 0);
        context.lineTo(width - topRight, 0);
        context.arc(width - topRight, topRight, topRight, Math.PI * 3 / 2, 0, false);
        context.lineTo(width, height - bottomRight);
        context.arc(width - bottomRight, height - bottomRight, bottomRight, 0, Math.PI / 2, false);
        context.lineTo(bottomLeft, height);
        context.arc(bottomLeft, height - bottomLeft, bottomLeft, Math.PI / 2, Math.PI, false);
        context.lineTo(0, topLeft);
        context.arc(topLeft, topLeft, topLeft, Math.PI, Math.PI * 3 / 2, false);
      }
    };
    function _formatValue(val) {
      if (Util._isString(val)) {
        return '"' + val + '"';
      }
      if (Object.prototype.toString.call(val) === "[object Number]") {
        return val;
      }
      if (Util._isBoolean(val)) {
        return val;
      }
      return Object.prototype.toString.call(val);
    }
    function RGBComponent(val) {
      if (val > 255) {
        return 255;
      } else if (val < 0) {
        return 0;
      }
      return Math.round(val);
    }
    function getNumberValidator() {
      if (Konva$2.isUnminified) {
        return function(val, attr) {
          if (!Util._isNumber(val)) {
            Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a number.');
          }
          return val;
        };
      }
    }
    function getNumberOrArrayOfNumbersValidator(noOfElements) {
      if (Konva$2.isUnminified) {
        return function(val, attr) {
          let isNumber = Util._isNumber(val);
          let isValidArray = Util._isArray(val) && val.length == noOfElements;
          if (!isNumber && !isValidArray) {
            Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a number or Array<number>(' + noOfElements + ")");
          }
          return val;
        };
      }
    }
    function getNumberOrAutoValidator() {
      if (Konva$2.isUnminified) {
        return function(val, attr) {
          var isNumber = Util._isNumber(val);
          var isAuto = val === "auto";
          if (!(isNumber || isAuto)) {
            Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a number or "auto".');
          }
          return val;
        };
      }
    }
    function getStringValidator() {
      if (Konva$2.isUnminified) {
        return function(val, attr) {
          if (!Util._isString(val)) {
            Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a string.');
          }
          return val;
        };
      }
    }
    function getStringOrGradientValidator() {
      if (Konva$2.isUnminified) {
        return function(val, attr) {
          const isString2 = Util._isString(val);
          const isGradient = Object.prototype.toString.call(val) === "[object CanvasGradient]" || val && val.addColorStop;
          if (!(isString2 || isGradient)) {
            Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a string or a native gradient.');
          }
          return val;
        };
      }
    }
    function getNumberArrayValidator() {
      if (Konva$2.isUnminified) {
        return function(val, attr) {
          const TypedArray = Int8Array ? Object.getPrototypeOf(Int8Array) : null;
          if (TypedArray && val instanceof TypedArray) {
            return val;
          }
          if (!Util._isArray(val)) {
            Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a array of numbers.');
          } else {
            val.forEach(function(item) {
              if (!Util._isNumber(item)) {
                Util.warn('"' + attr + '" attribute has non numeric element ' + item + ". Make sure that all elements are numbers.");
              }
            });
          }
          return val;
        };
      }
    }
    function getBooleanValidator() {
      if (Konva$2.isUnminified) {
        return function(val, attr) {
          var isBool = val === true || val === false;
          if (!isBool) {
            Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a boolean.');
          }
          return val;
        };
      }
    }
    function getComponentValidator(components) {
      if (Konva$2.isUnminified) {
        return function(val, attr) {
          if (val === void 0 || val === null) {
            return val;
          }
          if (!Util.isObject(val)) {
            Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be an object with properties ' + components);
          }
          return val;
        };
      }
    }
    var GET = "get", SET$1 = "set";
    const Factory = {
      addGetterSetter(constructor, attr, def2, validator, after) {
        Factory.addGetter(constructor, attr, def2);
        Factory.addSetter(constructor, attr, validator, after);
        Factory.addOverloadedGetterSetter(constructor, attr);
      },
      addGetter(constructor, attr, def2) {
        var method = GET + Util._capitalize(attr);
        constructor.prototype[method] = constructor.prototype[method] || function() {
          var val = this.attrs[attr];
          return val === void 0 ? def2 : val;
        };
      },
      addSetter(constructor, attr, validator, after) {
        var method = SET$1 + Util._capitalize(attr);
        if (!constructor.prototype[method]) {
          Factory.overWriteSetter(constructor, attr, validator, after);
        }
      },
      overWriteSetter(constructor, attr, validator, after) {
        var method = SET$1 + Util._capitalize(attr);
        constructor.prototype[method] = function(val) {
          if (validator && val !== void 0 && val !== null) {
            val = validator.call(this, val, attr);
          }
          this._setAttr(attr, val);
          if (after) {
            after.call(this);
          }
          return this;
        };
      },
      addComponentsGetterSetter(constructor, attr, components, validator, after) {
        var len = components.length, capitalize2 = Util._capitalize, getter = GET + capitalize2(attr), setter = SET$1 + capitalize2(attr), n, component;
        constructor.prototype[getter] = function() {
          var ret = {};
          for (n = 0; n < len; n++) {
            component = components[n];
            ret[component] = this.getAttr(attr + capitalize2(component));
          }
          return ret;
        };
        var basicValidator = getComponentValidator(components);
        constructor.prototype[setter] = function(val) {
          var oldVal = this.attrs[attr], key;
          if (validator) {
            val = validator.call(this, val);
          }
          if (basicValidator) {
            basicValidator.call(this, val, attr);
          }
          for (key in val) {
            if (!val.hasOwnProperty(key)) {
              continue;
            }
            this._setAttr(attr + capitalize2(key), val[key]);
          }
          if (!val) {
            components.forEach((component2) => {
              this._setAttr(attr + capitalize2(component2), void 0);
            });
          }
          this._fireChangeEvent(attr, oldVal, val);
          if (after) {
            after.call(this);
          }
          return this;
        };
        Factory.addOverloadedGetterSetter(constructor, attr);
      },
      addOverloadedGetterSetter(constructor, attr) {
        var capitalizedAttr = Util._capitalize(attr), setter = SET$1 + capitalizedAttr, getter = GET + capitalizedAttr;
        constructor.prototype[attr] = function() {
          if (arguments.length) {
            this[setter](arguments[0]);
            return this;
          }
          return this[getter]();
        };
      },
      addDeprecatedGetterSetter(constructor, attr, def2, validator) {
        Util.error("Adding deprecated " + attr);
        var method = GET + Util._capitalize(attr);
        var message = attr + " property is deprecated and will be removed soon. Look at Konva change log for more information.";
        constructor.prototype[method] = function() {
          Util.error(message);
          var val = this.attrs[attr];
          return val === void 0 ? def2 : val;
        };
        Factory.addSetter(constructor, attr, validator, function() {
          Util.error(message);
        });
        Factory.addOverloadedGetterSetter(constructor, attr);
      },
      backCompat(constructor, methods) {
        Util.each(methods, function(oldMethodName, newMethodName) {
          var method = constructor.prototype[newMethodName];
          var oldGetter = GET + Util._capitalize(oldMethodName);
          var oldSetter = SET$1 + Util._capitalize(oldMethodName);
          function deprecated() {
            method.apply(this, arguments);
            Util.error('"' + oldMethodName + '" method is deprecated and will be removed soon. Use ""' + newMethodName + '" instead.');
          }
          constructor.prototype[oldMethodName] = deprecated;
          constructor.prototype[oldGetter] = deprecated;
          constructor.prototype[oldSetter] = deprecated;
        });
      },
      afterSetFilter() {
        this._filterUpToDate = false;
      }
    };
    function simplifyArray(arr) {
      var retArr = [], len = arr.length, util2 = Util, n, val;
      for (n = 0; n < len; n++) {
        val = arr[n];
        if (util2._isNumber(val)) {
          val = Math.round(val * 1e3) / 1e3;
        } else if (!util2._isString(val)) {
          val = val + "";
        }
        retArr.push(val);
      }
      return retArr;
    }
    var COMMA = ",", OPEN_PAREN = "(", CLOSE_PAREN = ")", OPEN_PAREN_BRACKET = "([", CLOSE_BRACKET_PAREN = "])", SEMICOLON = ";", DOUBLE_PAREN = "()", EQUALS = "=", CONTEXT_METHODS = [
      "arc",
      "arcTo",
      "beginPath",
      "bezierCurveTo",
      "clearRect",
      "clip",
      "closePath",
      "createLinearGradient",
      "createPattern",
      "createRadialGradient",
      "drawImage",
      "ellipse",
      "fill",
      "fillText",
      "getImageData",
      "createImageData",
      "lineTo",
      "moveTo",
      "putImageData",
      "quadraticCurveTo",
      "rect",
      "restore",
      "rotate",
      "save",
      "scale",
      "setLineDash",
      "setTransform",
      "stroke",
      "strokeText",
      "transform",
      "translate"
    ];
    var CONTEXT_PROPERTIES = [
      "fillStyle",
      "strokeStyle",
      "shadowColor",
      "shadowBlur",
      "shadowOffsetX",
      "shadowOffsetY",
      "lineCap",
      "lineDashOffset",
      "lineJoin",
      "lineWidth",
      "miterLimit",
      "font",
      "textAlign",
      "textBaseline",
      "globalAlpha",
      "globalCompositeOperation",
      "imageSmoothingEnabled"
    ];
    const traceArrMax = 100;
    class Context {
      constructor(canvas) {
        this.canvas = canvas;
        if (Konva$2.enableTrace) {
          this.traceArr = [];
          this._enableTrace();
        }
      }
      fillShape(shape) {
        if (shape.fillEnabled()) {
          this._fill(shape);
        }
      }
      _fill(shape) {
      }
      strokeShape(shape) {
        if (shape.hasStroke()) {
          this._stroke(shape);
        }
      }
      _stroke(shape) {
      }
      fillStrokeShape(shape) {
        if (shape.attrs.fillAfterStrokeEnabled) {
          this.strokeShape(shape);
          this.fillShape(shape);
        } else {
          this.fillShape(shape);
          this.strokeShape(shape);
        }
      }
      getTrace(relaxed, rounded) {
        var traceArr = this.traceArr, len = traceArr.length, str = "", n, trace, method, args;
        for (n = 0; n < len; n++) {
          trace = traceArr[n];
          method = trace.method;
          if (method) {
            args = trace.args;
            str += method;
            if (relaxed) {
              str += DOUBLE_PAREN;
            } else {
              if (Util._isArray(args[0])) {
                str += OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;
              } else {
                if (rounded) {
                  args = args.map((a) => typeof a === "number" ? Math.floor(a) : a);
                }
                str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;
              }
            }
          } else {
            str += trace.property;
            if (!relaxed) {
              str += EQUALS + trace.val;
            }
          }
          str += SEMICOLON;
        }
        return str;
      }
      clearTrace() {
        this.traceArr = [];
      }
      _trace(str) {
        var traceArr = this.traceArr, len;
        traceArr.push(str);
        len = traceArr.length;
        if (len >= traceArrMax) {
          traceArr.shift();
        }
      }
      reset() {
        var pixelRatio = this.getCanvas().getPixelRatio();
        this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);
      }
      getCanvas() {
        return this.canvas;
      }
      clear(bounds) {
        var canvas = this.getCanvas();
        if (bounds) {
          this.clearRect(bounds.x || 0, bounds.y || 0, bounds.width || 0, bounds.height || 0);
        } else {
          this.clearRect(0, 0, canvas.getWidth() / canvas.pixelRatio, canvas.getHeight() / canvas.pixelRatio);
        }
      }
      _applyLineCap(shape) {
        const lineCap = shape.attrs.lineCap;
        if (lineCap) {
          this.setAttr("lineCap", lineCap);
        }
      }
      _applyOpacity(shape) {
        var absOpacity = shape.getAbsoluteOpacity();
        if (absOpacity !== 1) {
          this.setAttr("globalAlpha", absOpacity);
        }
      }
      _applyLineJoin(shape) {
        const lineJoin = shape.attrs.lineJoin;
        if (lineJoin) {
          this.setAttr("lineJoin", lineJoin);
        }
      }
      setAttr(attr, val) {
        this._context[attr] = val;
      }
      arc(a0, a1, a2, a3, a4, a5) {
        this._context.arc(a0, a1, a2, a3, a4, a5);
      }
      arcTo(a0, a1, a2, a3, a4) {
        this._context.arcTo(a0, a1, a2, a3, a4);
      }
      beginPath() {
        this._context.beginPath();
      }
      bezierCurveTo(a0, a1, a2, a3, a4, a5) {
        this._context.bezierCurveTo(a0, a1, a2, a3, a4, a5);
      }
      clearRect(a0, a1, a2, a3) {
        this._context.clearRect(a0, a1, a2, a3);
      }
      clip() {
        this._context.clip();
      }
      closePath() {
        this._context.closePath();
      }
      createImageData(a0, a1) {
        var a = arguments;
        if (a.length === 2) {
          return this._context.createImageData(a0, a1);
        } else if (a.length === 1) {
          return this._context.createImageData(a0);
        }
      }
      createLinearGradient(a0, a1, a2, a3) {
        return this._context.createLinearGradient(a0, a1, a2, a3);
      }
      createPattern(a0, a1) {
        return this._context.createPattern(a0, a1);
      }
      createRadialGradient(a0, a1, a2, a3, a4, a5) {
        return this._context.createRadialGradient(a0, a1, a2, a3, a4, a5);
      }
      drawImage(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        var a = arguments, _context = this._context;
        if (a.length === 3) {
          _context.drawImage(a0, a1, a2);
        } else if (a.length === 5) {
          _context.drawImage(a0, a1, a2, a3, a4);
        } else if (a.length === 9) {
          _context.drawImage(a0, a1, a2, a3, a4, a5, a6, a7, a8);
        }
      }
      ellipse(a0, a1, a2, a3, a4, a5, a6, a7) {
        this._context.ellipse(a0, a1, a2, a3, a4, a5, a6, a7);
      }
      isPointInPath(x, y, path, fillRule) {
        if (path) {
          return this._context.isPointInPath(path, x, y, fillRule);
        }
        return this._context.isPointInPath(x, y, fillRule);
      }
      fill(path2d) {
        if (path2d) {
          this._context.fill(path2d);
        } else {
          this._context.fill();
        }
      }
      fillRect(x, y, width, height) {
        this._context.fillRect(x, y, width, height);
      }
      strokeRect(x, y, width, height) {
        this._context.strokeRect(x, y, width, height);
      }
      fillText(text2, x, y, maxWidth) {
        if (maxWidth) {
          this._context.fillText(text2, x, y, maxWidth);
        } else {
          this._context.fillText(text2, x, y);
        }
      }
      measureText(text2) {
        return this._context.measureText(text2);
      }
      getImageData(a0, a1, a2, a3) {
        return this._context.getImageData(a0, a1, a2, a3);
      }
      lineTo(a0, a1) {
        this._context.lineTo(a0, a1);
      }
      moveTo(a0, a1) {
        this._context.moveTo(a0, a1);
      }
      rect(a0, a1, a2, a3) {
        this._context.rect(a0, a1, a2, a3);
      }
      putImageData(a0, a1, a2) {
        this._context.putImageData(a0, a1, a2);
      }
      quadraticCurveTo(a0, a1, a2, a3) {
        this._context.quadraticCurveTo(a0, a1, a2, a3);
      }
      restore() {
        this._context.restore();
      }
      rotate(a0) {
        this._context.rotate(a0);
      }
      save() {
        this._context.save();
      }
      scale(a0, a1) {
        this._context.scale(a0, a1);
      }
      setLineDash(a0) {
        if (this._context.setLineDash) {
          this._context.setLineDash(a0);
        } else if ("mozDash" in this._context) {
          this._context["mozDash"] = a0;
        } else if ("webkitLineDash" in this._context) {
          this._context["webkitLineDash"] = a0;
        }
      }
      getLineDash() {
        return this._context.getLineDash();
      }
      setTransform(a0, a1, a2, a3, a4, a5) {
        this._context.setTransform(a0, a1, a2, a3, a4, a5);
      }
      stroke(path2d) {
        if (path2d) {
          this._context.stroke(path2d);
        } else {
          this._context.stroke();
        }
      }
      strokeText(a0, a1, a2, a3) {
        this._context.strokeText(a0, a1, a2, a3);
      }
      transform(a0, a1, a2, a3, a4, a5) {
        this._context.transform(a0, a1, a2, a3, a4, a5);
      }
      translate(a0, a1) {
        this._context.translate(a0, a1);
      }
      _enableTrace() {
        var that = this, len = CONTEXT_METHODS.length, origSetter = this.setAttr, n, args;
        var func = function(methodName) {
          var origMethod = that[methodName], ret;
          that[methodName] = function() {
            args = simplifyArray(Array.prototype.slice.call(arguments, 0));
            ret = origMethod.apply(that, arguments);
            that._trace({
              method: methodName,
              args
            });
            return ret;
          };
        };
        for (n = 0; n < len; n++) {
          func(CONTEXT_METHODS[n]);
        }
        that.setAttr = function() {
          origSetter.apply(that, arguments);
          var prop2 = arguments[0];
          var val = arguments[1];
          if (prop2 === "shadowOffsetX" || prop2 === "shadowOffsetY" || prop2 === "shadowBlur") {
            val = val / this.canvas.getPixelRatio();
          }
          that._trace({
            property: prop2,
            val
          });
        };
      }
      _applyGlobalCompositeOperation(node) {
        const op = node.attrs.globalCompositeOperation;
        var def2 = !op || op === "source-over";
        if (!def2) {
          this.setAttr("globalCompositeOperation", op);
        }
      }
    }
    CONTEXT_PROPERTIES.forEach(function(prop2) {
      Object.defineProperty(Context.prototype, prop2, {
        get() {
          return this._context[prop2];
        },
        set(val) {
          this._context[prop2] = val;
        }
      });
    });
    class SceneContext extends Context {
      constructor(canvas) {
        super(canvas);
        this._context = canvas._canvas.getContext("2d");
      }
      _fillColor(shape) {
        var fill = shape.fill();
        this.setAttr("fillStyle", fill);
        shape._fillFunc(this);
      }
      _fillPattern(shape) {
        this.setAttr("fillStyle", shape._getFillPattern());
        shape._fillFunc(this);
      }
      _fillLinearGradient(shape) {
        var grd = shape._getLinearGradient();
        if (grd) {
          this.setAttr("fillStyle", grd);
          shape._fillFunc(this);
        }
      }
      _fillRadialGradient(shape) {
        const grd = shape._getRadialGradient();
        if (grd) {
          this.setAttr("fillStyle", grd);
          shape._fillFunc(this);
        }
      }
      _fill(shape) {
        const hasColor = shape.fill(), fillPriority = shape.getFillPriority();
        if (hasColor && fillPriority === "color") {
          this._fillColor(shape);
          return;
        }
        const hasPattern = shape.getFillPatternImage();
        if (hasPattern && fillPriority === "pattern") {
          this._fillPattern(shape);
          return;
        }
        const hasLinearGradient = shape.getFillLinearGradientColorStops();
        if (hasLinearGradient && fillPriority === "linear-gradient") {
          this._fillLinearGradient(shape);
          return;
        }
        const hasRadialGradient = shape.getFillRadialGradientColorStops();
        if (hasRadialGradient && fillPriority === "radial-gradient") {
          this._fillRadialGradient(shape);
          return;
        }
        if (hasColor) {
          this._fillColor(shape);
        } else if (hasPattern) {
          this._fillPattern(shape);
        } else if (hasLinearGradient) {
          this._fillLinearGradient(shape);
        } else if (hasRadialGradient) {
          this._fillRadialGradient(shape);
        }
      }
      _strokeLinearGradient(shape) {
        const start = shape.getStrokeLinearGradientStartPoint(), end = shape.getStrokeLinearGradientEndPoint(), colorStops = shape.getStrokeLinearGradientColorStops(), grd = this.createLinearGradient(start.x, start.y, end.x, end.y);
        if (colorStops) {
          for (var n = 0; n < colorStops.length; n += 2) {
            grd.addColorStop(colorStops[n], colorStops[n + 1]);
          }
          this.setAttr("strokeStyle", grd);
        }
      }
      _stroke(shape) {
        var dash2 = shape.dash(), strokeScaleEnabled = shape.getStrokeScaleEnabled();
        if (shape.hasStroke()) {
          if (!strokeScaleEnabled) {
            this.save();
            var pixelRatio = this.getCanvas().getPixelRatio();
            this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
          }
          this._applyLineCap(shape);
          if (dash2 && shape.dashEnabled()) {
            this.setLineDash(dash2);
            this.setAttr("lineDashOffset", shape.dashOffset());
          }
          this.setAttr("lineWidth", shape.strokeWidth());
          if (!shape.getShadowForStrokeEnabled()) {
            this.setAttr("shadowColor", "rgba(0,0,0,0)");
          }
          var hasLinearGradient = shape.getStrokeLinearGradientColorStops();
          if (hasLinearGradient) {
            this._strokeLinearGradient(shape);
          } else {
            this.setAttr("strokeStyle", shape.stroke());
          }
          shape._strokeFunc(this);
          if (!strokeScaleEnabled) {
            this.restore();
          }
        }
      }
      _applyShadow(shape) {
        var _a2, _b, _c;
        var color = (_a2 = shape.getShadowRGBA()) !== null && _a2 !== void 0 ? _a2 : "black", blur = (_b = shape.getShadowBlur()) !== null && _b !== void 0 ? _b : 5, offset = (_c = shape.getShadowOffset()) !== null && _c !== void 0 ? _c : {
          x: 0,
          y: 0
        }, scale = shape.getAbsoluteScale(), ratio2 = this.canvas.getPixelRatio(), scaleX = scale.x * ratio2, scaleY = scale.y * ratio2;
        this.setAttr("shadowColor", color);
        this.setAttr("shadowBlur", blur * Math.min(Math.abs(scaleX), Math.abs(scaleY)));
        this.setAttr("shadowOffsetX", offset.x * scaleX);
        this.setAttr("shadowOffsetY", offset.y * scaleY);
      }
    }
    class HitContext extends Context {
      constructor(canvas) {
        super(canvas);
        this._context = canvas._canvas.getContext("2d", {
          willReadFrequently: true
        });
      }
      _fill(shape) {
        this.save();
        this.setAttr("fillStyle", shape.colorKey);
        shape._fillFuncHit(this);
        this.restore();
      }
      strokeShape(shape) {
        if (shape.hasHitStroke()) {
          this._stroke(shape);
        }
      }
      _stroke(shape) {
        if (shape.hasHitStroke()) {
          const strokeScaleEnabled = shape.getStrokeScaleEnabled();
          if (!strokeScaleEnabled) {
            this.save();
            var pixelRatio = this.getCanvas().getPixelRatio();
            this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
          }
          this._applyLineCap(shape);
          var hitStrokeWidth = shape.hitStrokeWidth();
          var strokeWidth = hitStrokeWidth === "auto" ? shape.strokeWidth() : hitStrokeWidth;
          this.setAttr("lineWidth", strokeWidth);
          this.setAttr("strokeStyle", shape.colorKey);
          shape._strokeFuncHit(this);
          if (!strokeScaleEnabled) {
            this.restore();
          }
        }
      }
    }
    var _pixelRatio;
    function getDevicePixelRatio() {
      if (_pixelRatio) {
        return _pixelRatio;
      }
      var canvas = Util.createCanvasElement();
      var context = canvas.getContext("2d");
      _pixelRatio = function() {
        var devicePixelRatio2 = Konva$2._global.devicePixelRatio || 1, backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
        return devicePixelRatio2 / backingStoreRatio;
      }();
      Util.releaseCanvas(canvas);
      return _pixelRatio;
    }
    class Canvas {
      constructor(config2) {
        this.pixelRatio = 1;
        this.width = 0;
        this.height = 0;
        this.isCache = false;
        var conf = config2 || {};
        var pixelRatio = conf.pixelRatio || Konva$2.pixelRatio || getDevicePixelRatio();
        this.pixelRatio = pixelRatio;
        this._canvas = Util.createCanvasElement();
        this._canvas.style.padding = "0";
        this._canvas.style.margin = "0";
        this._canvas.style.border = "0";
        this._canvas.style.background = "transparent";
        this._canvas.style.position = "absolute";
        this._canvas.style.top = "0";
        this._canvas.style.left = "0";
      }
      getContext() {
        return this.context;
      }
      getPixelRatio() {
        return this.pixelRatio;
      }
      setPixelRatio(pixelRatio) {
        var previousRatio = this.pixelRatio;
        this.pixelRatio = pixelRatio;
        this.setSize(this.getWidth() / previousRatio, this.getHeight() / previousRatio);
      }
      setWidth(width) {
        this.width = this._canvas.width = width * this.pixelRatio;
        this._canvas.style.width = width + "px";
        var pixelRatio = this.pixelRatio, _context = this.getContext()._context;
        _context.scale(pixelRatio, pixelRatio);
      }
      setHeight(height) {
        this.height = this._canvas.height = height * this.pixelRatio;
        this._canvas.style.height = height + "px";
        var pixelRatio = this.pixelRatio, _context = this.getContext()._context;
        _context.scale(pixelRatio, pixelRatio);
      }
      getWidth() {
        return this.width;
      }
      getHeight() {
        return this.height;
      }
      setSize(width, height) {
        this.setWidth(width || 0);
        this.setHeight(height || 0);
      }
      toDataURL(mimeType, quality) {
        try {
          return this._canvas.toDataURL(mimeType, quality);
        } catch (e) {
          try {
            return this._canvas.toDataURL();
          } catch (err) {
            Util.error("Unable to get data URL. " + err.message + " For more info read https://konvajs.org/docs/posts/Tainted_Canvas.html.");
            return "";
          }
        }
      }
    }
    Factory.addGetterSetter(Canvas, "pixelRatio", void 0, getNumberValidator());
    class SceneCanvas extends Canvas {
      constructor(config2 = { width: 0, height: 0 }) {
        super(config2);
        this.context = new SceneContext(this);
        this.setSize(config2.width, config2.height);
      }
    }
    class HitCanvas extends Canvas {
      constructor(config2 = { width: 0, height: 0 }) {
        super(config2);
        this.hitCanvas = true;
        this.context = new HitContext(this);
        this.setSize(config2.width, config2.height);
      }
    }
    const DD$1 = {
      get isDragging() {
        var flag = false;
        DD$1._dragElements.forEach((elem) => {
          if (elem.dragStatus === "dragging") {
            flag = true;
          }
        });
        return flag;
      },
      justDragged: false,
      get node() {
        var node;
        DD$1._dragElements.forEach((elem) => {
          node = elem.node;
        });
        return node;
      },
      _dragElements: /* @__PURE__ */ new Map(),
      _drag(evt) {
        const nodesToFireEvents = [];
        DD$1._dragElements.forEach((elem, key) => {
          const { node } = elem;
          const stage = node.getStage();
          stage.setPointersPositions(evt);
          if (elem.pointerId === void 0) {
            elem.pointerId = Util._getFirstPointerId(evt);
          }
          const pos = stage._changedPointerPositions.find((pos2) => pos2.id === elem.pointerId);
          if (!pos) {
            return;
          }
          if (elem.dragStatus !== "dragging") {
            var dragDistance = node.dragDistance();
            var distance = Math.max(Math.abs(pos.x - elem.startPointerPos.x), Math.abs(pos.y - elem.startPointerPos.y));
            if (distance < dragDistance) {
              return;
            }
            node.startDrag({ evt });
            if (!node.isDragging()) {
              return;
            }
          }
          node._setDragPosition(evt, elem);
          nodesToFireEvents.push(node);
        });
        nodesToFireEvents.forEach((node) => {
          node.fire("dragmove", {
            type: "dragmove",
            target: node,
            evt
          }, true);
        });
      },
      _endDragBefore(evt) {
        const drawNodes = [];
        DD$1._dragElements.forEach((elem) => {
          const { node } = elem;
          const stage = node.getStage();
          if (evt) {
            stage.setPointersPositions(evt);
          }
          const pos = stage._changedPointerPositions.find((pos2) => pos2.id === elem.pointerId);
          if (!pos) {
            return;
          }
          if (elem.dragStatus === "dragging" || elem.dragStatus === "stopped") {
            DD$1.justDragged = true;
            Konva$2._mouseListenClick = false;
            Konva$2._touchListenClick = false;
            Konva$2._pointerListenClick = false;
            elem.dragStatus = "stopped";
          }
          const drawNode = elem.node.getLayer() || elem.node instanceof Konva$2["Stage"] && elem.node;
          if (drawNode && drawNodes.indexOf(drawNode) === -1) {
            drawNodes.push(drawNode);
          }
        });
        drawNodes.forEach((drawNode) => {
          drawNode.draw();
        });
      },
      _endDragAfter(evt) {
        DD$1._dragElements.forEach((elem, key) => {
          if (elem.dragStatus === "stopped") {
            elem.node.fire("dragend", {
              type: "dragend",
              target: elem.node,
              evt
            }, true);
          }
          if (elem.dragStatus !== "dragging") {
            DD$1._dragElements.delete(key);
          }
        });
      }
    };
    if (Konva$2.isBrowser) {
      window.addEventListener("mouseup", DD$1._endDragBefore, true);
      window.addEventListener("touchend", DD$1._endDragBefore, true);
      window.addEventListener("mousemove", DD$1._drag);
      window.addEventListener("touchmove", DD$1._drag);
      window.addEventListener("mouseup", DD$1._endDragAfter, false);
      window.addEventListener("touchend", DD$1._endDragAfter, false);
    }
    var ABSOLUTE_OPACITY = "absoluteOpacity", ALL_LISTENERS = "allEventListeners", ABSOLUTE_TRANSFORM = "absoluteTransform", ABSOLUTE_SCALE = "absoluteScale", CANVAS = "canvas", CHANGE = "Change", CHILDREN = "children", KONVA = "konva", LISTENING = "listening", MOUSEENTER$1 = "mouseenter", MOUSELEAVE$1 = "mouseleave", SET = "set", SHAPE = "Shape", SPACE$1 = " ", STAGE$1 = "stage", TRANSFORM = "transform", UPPER_STAGE = "Stage", VISIBLE = "visible", TRANSFORM_CHANGE_STR$1 = [
      "xChange.konva",
      "yChange.konva",
      "scaleXChange.konva",
      "scaleYChange.konva",
      "skewXChange.konva",
      "skewYChange.konva",
      "rotationChange.konva",
      "offsetXChange.konva",
      "offsetYChange.konva",
      "transformsEnabledChange.konva"
    ].join(SPACE$1);
    let idCounter$1 = 1;
    let Node$1 = class Node2 {
      constructor(config2) {
        this._id = idCounter$1++;
        this.eventListeners = {};
        this.attrs = {};
        this.index = 0;
        this._allEventListeners = null;
        this.parent = null;
        this._cache = /* @__PURE__ */ new Map();
        this._attachedDepsListeners = /* @__PURE__ */ new Map();
        this._lastPos = null;
        this._batchingTransformChange = false;
        this._needClearTransformCache = false;
        this._filterUpToDate = false;
        this._isUnderCache = false;
        this._dragEventId = null;
        this._shouldFireChangeEvents = false;
        this.setAttrs(config2);
        this._shouldFireChangeEvents = true;
      }
      hasChildren() {
        return false;
      }
      _clearCache(attr) {
        if ((attr === TRANSFORM || attr === ABSOLUTE_TRANSFORM) && this._cache.get(attr)) {
          this._cache.get(attr).dirty = true;
        } else if (attr) {
          this._cache.delete(attr);
        } else {
          this._cache.clear();
        }
      }
      _getCache(attr, privateGetter) {
        var cache = this._cache.get(attr);
        var isTransform = attr === TRANSFORM || attr === ABSOLUTE_TRANSFORM;
        var invalid = cache === void 0 || isTransform && cache.dirty === true;
        if (invalid) {
          cache = privateGetter.call(this);
          this._cache.set(attr, cache);
        }
        return cache;
      }
      _calculate(name, deps, getter) {
        if (!this._attachedDepsListeners.get(name)) {
          const depsString = deps.map((dep) => dep + "Change.konva").join(SPACE$1);
          this.on(depsString, () => {
            this._clearCache(name);
          });
          this._attachedDepsListeners.set(name, true);
        }
        return this._getCache(name, getter);
      }
      _getCanvasCache() {
        return this._cache.get(CANVAS);
      }
      _clearSelfAndDescendantCache(attr) {
        this._clearCache(attr);
        if (attr === ABSOLUTE_TRANSFORM) {
          this.fire("absoluteTransformChange");
        }
      }
      clearCache() {
        if (this._cache.has(CANVAS)) {
          const { scene, filter, hit } = this._cache.get(CANVAS);
          Util.releaseCanvas(scene, filter, hit);
          this._cache.delete(CANVAS);
        }
        this._clearSelfAndDescendantCache();
        this._requestDraw();
        return this;
      }
      cache(config2) {
        var conf = config2 || {};
        var rect2 = {};
        if (conf.x === void 0 || conf.y === void 0 || conf.width === void 0 || conf.height === void 0) {
          rect2 = this.getClientRect({
            skipTransform: true,
            relativeTo: this.getParent()
          });
        }
        var width = Math.ceil(conf.width || rect2.width), height = Math.ceil(conf.height || rect2.height), pixelRatio = conf.pixelRatio, x = conf.x === void 0 ? Math.floor(rect2.x) : conf.x, y = conf.y === void 0 ? Math.floor(rect2.y) : conf.y, offset = conf.offset || 0, drawBorder = conf.drawBorder || false, hitCanvasPixelRatio = conf.hitCanvasPixelRatio || 1;
        if (!width || !height) {
          Util.error("Can not cache the node. Width or height of the node equals 0. Caching is skipped.");
          return;
        }
        width += offset * 2 + 1;
        height += offset * 2 + 1;
        x -= offset;
        y -= offset;
        var cachedSceneCanvas = new SceneCanvas({
          pixelRatio,
          width,
          height
        }), cachedFilterCanvas = new SceneCanvas({
          pixelRatio,
          width: 0,
          height: 0
        }), cachedHitCanvas = new HitCanvas({
          pixelRatio: hitCanvasPixelRatio,
          width,
          height
        }), sceneContext = cachedSceneCanvas.getContext(), hitContext = cachedHitCanvas.getContext();
        cachedHitCanvas.isCache = true;
        cachedSceneCanvas.isCache = true;
        this._cache.delete(CANVAS);
        this._filterUpToDate = false;
        if (conf.imageSmoothingEnabled === false) {
          cachedSceneCanvas.getContext()._context.imageSmoothingEnabled = false;
          cachedFilterCanvas.getContext()._context.imageSmoothingEnabled = false;
        }
        sceneContext.save();
        hitContext.save();
        sceneContext.translate(-x, -y);
        hitContext.translate(-x, -y);
        this._isUnderCache = true;
        this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
        this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);
        this.drawScene(cachedSceneCanvas, this);
        this.drawHit(cachedHitCanvas, this);
        this._isUnderCache = false;
        sceneContext.restore();
        hitContext.restore();
        if (drawBorder) {
          sceneContext.save();
          sceneContext.beginPath();
          sceneContext.rect(0, 0, width, height);
          sceneContext.closePath();
          sceneContext.setAttr("strokeStyle", "red");
          sceneContext.setAttr("lineWidth", 5);
          sceneContext.stroke();
          sceneContext.restore();
        }
        this._cache.set(CANVAS, {
          scene: cachedSceneCanvas,
          filter: cachedFilterCanvas,
          hit: cachedHitCanvas,
          x,
          y
        });
        this._requestDraw();
        return this;
      }
      isCached() {
        return this._cache.has(CANVAS);
      }
      getClientRect(config2) {
        throw new Error('abstract "getClientRect" method call');
      }
      _transformedRect(rect2, top2) {
        var points = [
          { x: rect2.x, y: rect2.y },
          { x: rect2.x + rect2.width, y: rect2.y },
          { x: rect2.x + rect2.width, y: rect2.y + rect2.height },
          { x: rect2.x, y: rect2.y + rect2.height }
        ];
        var minX, minY, maxX, maxY;
        var trans = this.getAbsoluteTransform(top2);
        points.forEach(function(point) {
          var transformed = trans.point(point);
          if (minX === void 0) {
            minX = maxX = transformed.x;
            minY = maxY = transformed.y;
          }
          minX = Math.min(minX, transformed.x);
          minY = Math.min(minY, transformed.y);
          maxX = Math.max(maxX, transformed.x);
          maxY = Math.max(maxY, transformed.y);
        });
        return {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        };
      }
      _drawCachedSceneCanvas(context) {
        context.save();
        context._applyOpacity(this);
        context._applyGlobalCompositeOperation(this);
        const canvasCache = this._getCanvasCache();
        context.translate(canvasCache.x, canvasCache.y);
        var cacheCanvas = this._getCachedSceneCanvas();
        var ratio2 = cacheCanvas.pixelRatio;
        context.drawImage(cacheCanvas._canvas, 0, 0, cacheCanvas.width / ratio2, cacheCanvas.height / ratio2);
        context.restore();
      }
      _drawCachedHitCanvas(context) {
        var canvasCache = this._getCanvasCache(), hitCanvas = canvasCache.hit;
        context.save();
        context.translate(canvasCache.x, canvasCache.y);
        context.drawImage(hitCanvas._canvas, 0, 0, hitCanvas.width / hitCanvas.pixelRatio, hitCanvas.height / hitCanvas.pixelRatio);
        context.restore();
      }
      _getCachedSceneCanvas() {
        var filters = this.filters(), cachedCanvas = this._getCanvasCache(), sceneCanvas = cachedCanvas.scene, filterCanvas = cachedCanvas.filter, filterContext = filterCanvas.getContext(), len, imageData, n, filter;
        if (filters) {
          if (!this._filterUpToDate) {
            var ratio2 = sceneCanvas.pixelRatio;
            filterCanvas.setSize(sceneCanvas.width / sceneCanvas.pixelRatio, sceneCanvas.height / sceneCanvas.pixelRatio);
            try {
              len = filters.length;
              filterContext.clear();
              filterContext.drawImage(sceneCanvas._canvas, 0, 0, sceneCanvas.getWidth() / ratio2, sceneCanvas.getHeight() / ratio2);
              imageData = filterContext.getImageData(0, 0, filterCanvas.getWidth(), filterCanvas.getHeight());
              for (n = 0; n < len; n++) {
                filter = filters[n];
                if (typeof filter !== "function") {
                  Util.error("Filter should be type of function, but got " + typeof filter + " instead. Please check correct filters");
                  continue;
                }
                filter.call(this, imageData);
                filterContext.putImageData(imageData, 0, 0);
              }
            } catch (e) {
              Util.error("Unable to apply filter. " + e.message + " This post my help you https://konvajs.org/docs/posts/Tainted_Canvas.html.");
            }
            this._filterUpToDate = true;
          }
          return filterCanvas;
        }
        return sceneCanvas;
      }
      on(evtStr, handler) {
        this._cache && this._cache.delete(ALL_LISTENERS);
        if (arguments.length === 3) {
          return this._delegate.apply(this, arguments);
        }
        var events = evtStr.split(SPACE$1), len = events.length, n, event, parts, baseEvent, name;
        for (n = 0; n < len; n++) {
          event = events[n];
          parts = event.split(".");
          baseEvent = parts[0];
          name = parts[1] || "";
          if (!this.eventListeners[baseEvent]) {
            this.eventListeners[baseEvent] = [];
          }
          this.eventListeners[baseEvent].push({
            name,
            handler
          });
        }
        return this;
      }
      off(evtStr, callback) {
        var events = (evtStr || "").split(SPACE$1), len = events.length, n, t, event, parts, baseEvent, name;
        this._cache && this._cache.delete(ALL_LISTENERS);
        if (!evtStr) {
          for (t in this.eventListeners) {
            this._off(t);
          }
        }
        for (n = 0; n < len; n++) {
          event = events[n];
          parts = event.split(".");
          baseEvent = parts[0];
          name = parts[1];
          if (baseEvent) {
            if (this.eventListeners[baseEvent]) {
              this._off(baseEvent, name, callback);
            }
          } else {
            for (t in this.eventListeners) {
              this._off(t, name, callback);
            }
          }
        }
        return this;
      }
      dispatchEvent(evt) {
        var e = {
          target: this,
          type: evt.type,
          evt
        };
        this.fire(evt.type, e);
        return this;
      }
      addEventListener(type2, handler) {
        this.on(type2, function(evt) {
          handler.call(this, evt.evt);
        });
        return this;
      }
      removeEventListener(type2) {
        this.off(type2);
        return this;
      }
      _delegate(event, selector, handler) {
        var stopNode = this;
        this.on(event, function(evt) {
          var targets = evt.target.findAncestors(selector, true, stopNode);
          for (var i2 = 0; i2 < targets.length; i2++) {
            evt = Util.cloneObject(evt);
            evt.currentTarget = targets[i2];
            handler.call(targets[i2], evt);
          }
        });
      }
      remove() {
        if (this.isDragging()) {
          this.stopDrag();
        }
        DD$1._dragElements.delete(this._id);
        this._remove();
        return this;
      }
      _clearCaches() {
        this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
        this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
        this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);
        this._clearSelfAndDescendantCache(STAGE$1);
        this._clearSelfAndDescendantCache(VISIBLE);
        this._clearSelfAndDescendantCache(LISTENING);
      }
      _remove() {
        this._clearCaches();
        var parent = this.getParent();
        if (parent && parent.children) {
          parent.children.splice(this.index, 1);
          parent._setChildrenIndices();
          this.parent = null;
        }
      }
      destroy() {
        this.remove();
        this.clearCache();
        return this;
      }
      getAttr(attr) {
        var method = "get" + Util._capitalize(attr);
        if (Util._isFunction(this[method])) {
          return this[method]();
        }
        return this.attrs[attr];
      }
      getAncestors() {
        var parent = this.getParent(), ancestors = [];
        while (parent) {
          ancestors.push(parent);
          parent = parent.getParent();
        }
        return ancestors;
      }
      getAttrs() {
        return this.attrs || {};
      }
      setAttrs(config2) {
        this._batchTransformChanges(() => {
          var key, method;
          if (!config2) {
            return this;
          }
          for (key in config2) {
            if (key === CHILDREN) {
              continue;
            }
            method = SET + Util._capitalize(key);
            if (Util._isFunction(this[method])) {
              this[method](config2[key]);
            } else {
              this._setAttr(key, config2[key]);
            }
          }
        });
        return this;
      }
      isListening() {
        return this._getCache(LISTENING, this._isListening);
      }
      _isListening(relativeTo) {
        const listening = this.listening();
        if (!listening) {
          return false;
        }
        const parent = this.getParent();
        if (parent && parent !== relativeTo && this !== relativeTo) {
          return parent._isListening(relativeTo);
        } else {
          return true;
        }
      }
      isVisible() {
        return this._getCache(VISIBLE, this._isVisible);
      }
      _isVisible(relativeTo) {
        const visible = this.visible();
        if (!visible) {
          return false;
        }
        const parent = this.getParent();
        if (parent && parent !== relativeTo && this !== relativeTo) {
          return parent._isVisible(relativeTo);
        } else {
          return true;
        }
      }
      shouldDrawHit(top2, skipDragCheck = false) {
        if (top2) {
          return this._isVisible(top2) && this._isListening(top2);
        }
        var layer = this.getLayer();
        var layerUnderDrag = false;
        DD$1._dragElements.forEach((elem) => {
          if (elem.dragStatus !== "dragging") {
            return;
          } else if (elem.node.nodeType === "Stage") {
            layerUnderDrag = true;
          } else if (elem.node.getLayer() === layer) {
            layerUnderDrag = true;
          }
        });
        var dragSkip = !skipDragCheck && !Konva$2.hitOnDragEnabled && layerUnderDrag;
        return this.isListening() && this.isVisible() && !dragSkip;
      }
      show() {
        this.visible(true);
        return this;
      }
      hide() {
        this.visible(false);
        return this;
      }
      getZIndex() {
        return this.index || 0;
      }
      getAbsoluteZIndex() {
        var depth = this.getDepth(), that = this, index = 0, nodes, len, n, child;
        function addChildren(children) {
          nodes = [];
          len = children.length;
          for (n = 0; n < len; n++) {
            child = children[n];
            index++;
            if (child.nodeType !== SHAPE) {
              nodes = nodes.concat(child.getChildren().slice());
            }
            if (child._id === that._id) {
              n = len;
            }
          }
          if (nodes.length > 0 && nodes[0].getDepth() <= depth) {
            addChildren(nodes);
          }
        }
        if (that.nodeType !== UPPER_STAGE) {
          addChildren(that.getStage().getChildren());
        }
        return index;
      }
      getDepth() {
        var depth = 0, parent = this.parent;
        while (parent) {
          depth++;
          parent = parent.parent;
        }
        return depth;
      }
      _batchTransformChanges(func) {
        this._batchingTransformChange = true;
        func();
        this._batchingTransformChange = false;
        if (this._needClearTransformCache) {
          this._clearCache(TRANSFORM);
          this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
        }
        this._needClearTransformCache = false;
      }
      setPosition(pos) {
        this._batchTransformChanges(() => {
          this.x(pos.x);
          this.y(pos.y);
        });
        return this;
      }
      getPosition() {
        return {
          x: this.x(),
          y: this.y()
        };
      }
      getRelativePointerPosition() {
        if (!this.getStage()) {
          return null;
        }
        var pos = this.getStage().getPointerPosition();
        if (!pos) {
          return null;
        }
        var transform2 = this.getAbsoluteTransform().copy();
        transform2.invert();
        return transform2.point(pos);
      }
      getAbsolutePosition(top2) {
        let haveCachedParent = false;
        let parent = this.parent;
        while (parent) {
          if (parent.isCached()) {
            haveCachedParent = true;
            break;
          }
          parent = parent.parent;
        }
        if (haveCachedParent && !top2) {
          top2 = true;
        }
        var absoluteMatrix = this.getAbsoluteTransform(top2).getMatrix(), absoluteTransform = new Transform(), offset = this.offset();
        absoluteTransform.m = absoluteMatrix.slice();
        absoluteTransform.translate(offset.x, offset.y);
        return absoluteTransform.getTranslation();
      }
      setAbsolutePosition(pos) {
        var origTrans = this._clearTransform();
        this.attrs.x = origTrans.x;
        this.attrs.y = origTrans.y;
        delete origTrans.x;
        delete origTrans.y;
        this._clearCache(TRANSFORM);
        var it2 = this._getAbsoluteTransform().copy();
        it2.invert();
        it2.translate(pos.x, pos.y);
        pos = {
          x: this.attrs.x + it2.getTranslation().x,
          y: this.attrs.y + it2.getTranslation().y
        };
        this._setTransform(origTrans);
        this.setPosition({ x: pos.x, y: pos.y });
        this._clearCache(TRANSFORM);
        this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
        return this;
      }
      _setTransform(trans) {
        var key;
        for (key in trans) {
          this.attrs[key] = trans[key];
        }
      }
      _clearTransform() {
        var trans = {
          x: this.x(),
          y: this.y(),
          rotation: this.rotation(),
          scaleX: this.scaleX(),
          scaleY: this.scaleY(),
          offsetX: this.offsetX(),
          offsetY: this.offsetY(),
          skewX: this.skewX(),
          skewY: this.skewY()
        };
        this.attrs.x = 0;
        this.attrs.y = 0;
        this.attrs.rotation = 0;
        this.attrs.scaleX = 1;
        this.attrs.scaleY = 1;
        this.attrs.offsetX = 0;
        this.attrs.offsetY = 0;
        this.attrs.skewX = 0;
        this.attrs.skewY = 0;
        return trans;
      }
      move(change) {
        var changeX = change.x, changeY = change.y, x = this.x(), y = this.y();
        if (changeX !== void 0) {
          x += changeX;
        }
        if (changeY !== void 0) {
          y += changeY;
        }
        this.setPosition({ x, y });
        return this;
      }
      _eachAncestorReverse(func, top2) {
        var family = [], parent = this.getParent(), len, n;
        if (top2 && top2._id === this._id) {
          return;
        }
        family.unshift(this);
        while (parent && (!top2 || parent._id !== top2._id)) {
          family.unshift(parent);
          parent = parent.parent;
        }
        len = family.length;
        for (n = 0; n < len; n++) {
          func(family[n]);
        }
      }
      rotate(theta2) {
        this.rotation(this.rotation() + theta2);
        return this;
      }
      moveToTop() {
        if (!this.parent) {
          Util.warn("Node has no parent. moveToTop function is ignored.");
          return false;
        }
        var index = this.index, len = this.parent.getChildren().length;
        if (index < len - 1) {
          this.parent.children.splice(index, 1);
          this.parent.children.push(this);
          this.parent._setChildrenIndices();
          return true;
        }
        return false;
      }
      moveUp() {
        if (!this.parent) {
          Util.warn("Node has no parent. moveUp function is ignored.");
          return false;
        }
        var index = this.index, len = this.parent.getChildren().length;
        if (index < len - 1) {
          this.parent.children.splice(index, 1);
          this.parent.children.splice(index + 1, 0, this);
          this.parent._setChildrenIndices();
          return true;
        }
        return false;
      }
      moveDown() {
        if (!this.parent) {
          Util.warn("Node has no parent. moveDown function is ignored.");
          return false;
        }
        var index = this.index;
        if (index > 0) {
          this.parent.children.splice(index, 1);
          this.parent.children.splice(index - 1, 0, this);
          this.parent._setChildrenIndices();
          return true;
        }
        return false;
      }
      moveToBottom() {
        if (!this.parent) {
          Util.warn("Node has no parent. moveToBottom function is ignored.");
          return false;
        }
        var index = this.index;
        if (index > 0) {
          this.parent.children.splice(index, 1);
          this.parent.children.unshift(this);
          this.parent._setChildrenIndices();
          return true;
        }
        return false;
      }
      setZIndex(zIndex) {
        if (!this.parent) {
          Util.warn("Node has no parent. zIndex parameter is ignored.");
          return this;
        }
        if (zIndex < 0 || zIndex >= this.parent.children.length) {
          Util.warn("Unexpected value " + zIndex + " for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to " + (this.parent.children.length - 1) + ".");
        }
        var index = this.index;
        this.parent.children.splice(index, 1);
        this.parent.children.splice(zIndex, 0, this);
        this.parent._setChildrenIndices();
        return this;
      }
      getAbsoluteOpacity() {
        return this._getCache(ABSOLUTE_OPACITY, this._getAbsoluteOpacity);
      }
      _getAbsoluteOpacity() {
        var absOpacity = this.opacity();
        var parent = this.getParent();
        if (parent && !parent._isUnderCache) {
          absOpacity *= parent.getAbsoluteOpacity();
        }
        return absOpacity;
      }
      moveTo(newContainer) {
        if (this.getParent() !== newContainer) {
          this._remove();
          newContainer.add(this);
        }
        return this;
      }
      toObject() {
        var obj = {}, attrs = this.getAttrs(), key, val, getter, defaultValue, nonPlainObject;
        obj.attrs = {};
        for (key in attrs) {
          val = attrs[key];
          nonPlainObject = Util.isObject(val) && !Util._isPlainObject(val) && !Util._isArray(val);
          if (nonPlainObject) {
            continue;
          }
          getter = typeof this[key] === "function" && this[key];
          delete attrs[key];
          defaultValue = getter ? getter.call(this) : null;
          attrs[key] = val;
          if (defaultValue !== val) {
            obj.attrs[key] = val;
          }
        }
        obj.className = this.getClassName();
        return Util._prepareToStringify(obj);
      }
      toJSON() {
        return JSON.stringify(this.toObject());
      }
      getParent() {
        return this.parent;
      }
      findAncestors(selector, includeSelf, stopNode) {
        var res = [];
        if (includeSelf && this._isMatch(selector)) {
          res.push(this);
        }
        var ancestor = this.parent;
        while (ancestor) {
          if (ancestor === stopNode) {
            return res;
          }
          if (ancestor._isMatch(selector)) {
            res.push(ancestor);
          }
          ancestor = ancestor.parent;
        }
        return res;
      }
      isAncestorOf(node) {
        return false;
      }
      findAncestor(selector, includeSelf, stopNode) {
        return this.findAncestors(selector, includeSelf, stopNode)[0];
      }
      _isMatch(selector) {
        if (!selector) {
          return false;
        }
        if (typeof selector === "function") {
          return selector(this);
        }
        var selectorArr = selector.replace(/ /g, "").split(","), len = selectorArr.length, n, sel;
        for (n = 0; n < len; n++) {
          sel = selectorArr[n];
          if (!Util.isValidSelector(sel)) {
            Util.warn('Selector "' + sel + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".');
            Util.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".');
            Util.warn("Konva is awesome, right?");
          }
          if (sel.charAt(0) === "#") {
            if (this.id() === sel.slice(1)) {
              return true;
            }
          } else if (sel.charAt(0) === ".") {
            if (this.hasName(sel.slice(1))) {
              return true;
            }
          } else if (this.className === sel || this.nodeType === sel) {
            return true;
          }
        }
        return false;
      }
      getLayer() {
        var parent = this.getParent();
        return parent ? parent.getLayer() : null;
      }
      getStage() {
        return this._getCache(STAGE$1, this._getStage);
      }
      _getStage() {
        var parent = this.getParent();
        if (parent) {
          return parent.getStage();
        } else {
          return void 0;
        }
      }
      fire(eventType, evt = {}, bubble) {
        evt.target = evt.target || this;
        if (bubble) {
          this._fireAndBubble(eventType, evt);
        } else {
          this._fire(eventType, evt);
        }
        return this;
      }
      getAbsoluteTransform(top2) {
        if (top2) {
          return this._getAbsoluteTransform(top2);
        } else {
          return this._getCache(ABSOLUTE_TRANSFORM, this._getAbsoluteTransform);
        }
      }
      _getAbsoluteTransform(top2) {
        var at;
        if (top2) {
          at = new Transform();
          this._eachAncestorReverse(function(node) {
            var transformsEnabled2 = node.transformsEnabled();
            if (transformsEnabled2 === "all") {
              at.multiply(node.getTransform());
            } else if (transformsEnabled2 === "position") {
              at.translate(node.x() - node.offsetX(), node.y() - node.offsetY());
            }
          }, top2);
          return at;
        } else {
          at = this._cache.get(ABSOLUTE_TRANSFORM) || new Transform();
          if (this.parent) {
            this.parent.getAbsoluteTransform().copyInto(at);
          } else {
            at.reset();
          }
          var transformsEnabled = this.transformsEnabled();
          if (transformsEnabled === "all") {
            at.multiply(this.getTransform());
          } else if (transformsEnabled === "position") {
            const x = this.attrs.x || 0;
            const y = this.attrs.y || 0;
            const offsetX = this.attrs.offsetX || 0;
            const offsetY = this.attrs.offsetY || 0;
            at.translate(x - offsetX, y - offsetY);
          }
          at.dirty = false;
          return at;
        }
      }
      getAbsoluteScale(top2) {
        var parent = this;
        while (parent) {
          if (parent._isUnderCache) {
            top2 = parent;
          }
          parent = parent.getParent();
        }
        const transform2 = this.getAbsoluteTransform(top2);
        const attrs = transform2.decompose();
        return {
          x: attrs.scaleX,
          y: attrs.scaleY
        };
      }
      getAbsoluteRotation() {
        return this.getAbsoluteTransform().decompose().rotation;
      }
      getTransform() {
        return this._getCache(TRANSFORM, this._getTransform);
      }
      _getTransform() {
        var _a2, _b;
        var m = this._cache.get(TRANSFORM) || new Transform();
        m.reset();
        var x = this.x(), y = this.y(), rotation = Konva$2.getAngle(this.rotation()), scaleX = (_a2 = this.attrs.scaleX) !== null && _a2 !== void 0 ? _a2 : 1, scaleY = (_b = this.attrs.scaleY) !== null && _b !== void 0 ? _b : 1, skewX = this.attrs.skewX || 0, skewY = this.attrs.skewY || 0, offsetX = this.attrs.offsetX || 0, offsetY = this.attrs.offsetY || 0;
        if (x !== 0 || y !== 0) {
          m.translate(x, y);
        }
        if (rotation !== 0) {
          m.rotate(rotation);
        }
        if (skewX !== 0 || skewY !== 0) {
          m.skew(skewX, skewY);
        }
        if (scaleX !== 1 || scaleY !== 1) {
          m.scale(scaleX, scaleY);
        }
        if (offsetX !== 0 || offsetY !== 0) {
          m.translate(-1 * offsetX, -1 * offsetY);
        }
        m.dirty = false;
        return m;
      }
      clone(obj) {
        var attrs = Util.cloneObject(this.attrs), key, allListeners, len, n, listener;
        for (key in obj) {
          attrs[key] = obj[key];
        }
        var node = new this.constructor(attrs);
        for (key in this.eventListeners) {
          allListeners = this.eventListeners[key];
          len = allListeners.length;
          for (n = 0; n < len; n++) {
            listener = allListeners[n];
            if (listener.name.indexOf(KONVA) < 0) {
              if (!node.eventListeners[key]) {
                node.eventListeners[key] = [];
              }
              node.eventListeners[key].push(listener);
            }
          }
        }
        return node;
      }
      _toKonvaCanvas(config2) {
        config2 = config2 || {};
        var box = this.getClientRect();
        var stage = this.getStage(), x = config2.x !== void 0 ? config2.x : Math.floor(box.x), y = config2.y !== void 0 ? config2.y : Math.floor(box.y), pixelRatio = config2.pixelRatio || 1, canvas = new SceneCanvas({
          width: config2.width || Math.ceil(box.width) || (stage ? stage.width() : 0),
          height: config2.height || Math.ceil(box.height) || (stage ? stage.height() : 0),
          pixelRatio
        }), context = canvas.getContext();
        if (config2.imageSmoothingEnabled === false) {
          context._context.imageSmoothingEnabled = false;
        }
        context.save();
        if (x || y) {
          context.translate(-1 * x, -1 * y);
        }
        this.drawScene(canvas);
        context.restore();
        return canvas;
      }
      toCanvas(config2) {
        return this._toKonvaCanvas(config2)._canvas;
      }
      toDataURL(config2) {
        config2 = config2 || {};
        var mimeType = config2.mimeType || null, quality = config2.quality || null;
        var url = this._toKonvaCanvas(config2).toDataURL(mimeType, quality);
        if (config2.callback) {
          config2.callback(url);
        }
        return url;
      }
      toImage(config2) {
        return new Promise((resolve2, reject) => {
          try {
            const callback = config2 === null || config2 === void 0 ? void 0 : config2.callback;
            if (callback)
              delete config2.callback;
            Util._urlToImage(this.toDataURL(config2), function(img) {
              resolve2(img);
              callback === null || callback === void 0 ? void 0 : callback(img);
            });
          } catch (err) {
            reject(err);
          }
        });
      }
      toBlob(config2) {
        return new Promise((resolve2, reject) => {
          try {
            const callback = config2 === null || config2 === void 0 ? void 0 : config2.callback;
            if (callback)
              delete config2.callback;
            this.toCanvas(config2).toBlob((blob) => {
              resolve2(blob);
              callback === null || callback === void 0 ? void 0 : callback(blob);
            });
          } catch (err) {
            reject(err);
          }
        });
      }
      setSize(size2) {
        this.width(size2.width);
        this.height(size2.height);
        return this;
      }
      getSize() {
        return {
          width: this.width(),
          height: this.height()
        };
      }
      getClassName() {
        return this.className || this.nodeType;
      }
      getType() {
        return this.nodeType;
      }
      getDragDistance() {
        if (this.attrs.dragDistance !== void 0) {
          return this.attrs.dragDistance;
        } else if (this.parent) {
          return this.parent.getDragDistance();
        } else {
          return Konva$2.dragDistance;
        }
      }
      _off(type2, name, callback) {
        var evtListeners = this.eventListeners[type2], i2, evtName, handler;
        for (i2 = 0; i2 < evtListeners.length; i2++) {
          evtName = evtListeners[i2].name;
          handler = evtListeners[i2].handler;
          if ((evtName !== "konva" || name === "konva") && (!name || evtName === name) && (!callback || callback === handler)) {
            evtListeners.splice(i2, 1);
            if (evtListeners.length === 0) {
              delete this.eventListeners[type2];
              break;
            }
            i2--;
          }
        }
      }
      _fireChangeEvent(attr, oldVal, newVal) {
        this._fire(attr + CHANGE, {
          oldVal,
          newVal
        });
      }
      addName(name) {
        if (!this.hasName(name)) {
          var oldName = this.name();
          var newName = oldName ? oldName + " " + name : name;
          this.name(newName);
        }
        return this;
      }
      hasName(name) {
        if (!name) {
          return false;
        }
        const fullName = this.name();
        if (!fullName) {
          return false;
        }
        var names2 = (fullName || "").split(/\s/g);
        return names2.indexOf(name) !== -1;
      }
      removeName(name) {
        var names2 = (this.name() || "").split(/\s/g);
        var index = names2.indexOf(name);
        if (index !== -1) {
          names2.splice(index, 1);
          this.name(names2.join(" "));
        }
        return this;
      }
      setAttr(attr, val) {
        var func = this[SET + Util._capitalize(attr)];
        if (Util._isFunction(func)) {
          func.call(this, val);
        } else {
          this._setAttr(attr, val);
        }
        return this;
      }
      _requestDraw() {
        if (Konva$2.autoDrawEnabled) {
          const drawNode = this.getLayer() || this.getStage();
          drawNode === null || drawNode === void 0 ? void 0 : drawNode.batchDraw();
        }
      }
      _setAttr(key, val) {
        var oldVal = this.attrs[key];
        if (oldVal === val && !Util.isObject(val)) {
          return;
        }
        if (val === void 0 || val === null) {
          delete this.attrs[key];
        } else {
          this.attrs[key] = val;
        }
        if (this._shouldFireChangeEvents) {
          this._fireChangeEvent(key, oldVal, val);
        }
        this._requestDraw();
      }
      _setComponentAttr(key, component, val) {
        var oldVal;
        if (val !== void 0) {
          oldVal = this.attrs[key];
          if (!oldVal) {
            this.attrs[key] = this.getAttr(key);
          }
          this.attrs[key][component] = val;
          this._fireChangeEvent(key, oldVal, val);
        }
      }
      _fireAndBubble(eventType, evt, compareShape) {
        if (evt && this.nodeType === SHAPE) {
          evt.target = this;
        }
        var shouldStop = (eventType === MOUSEENTER$1 || eventType === MOUSELEAVE$1) && (compareShape && (this === compareShape || this.isAncestorOf && this.isAncestorOf(compareShape)) || this.nodeType === "Stage" && !compareShape);
        if (!shouldStop) {
          this._fire(eventType, evt);
          var stopBubble = (eventType === MOUSEENTER$1 || eventType === MOUSELEAVE$1) && compareShape && compareShape.isAncestorOf && compareShape.isAncestorOf(this) && !compareShape.isAncestorOf(this.parent);
          if ((evt && !evt.cancelBubble || !evt) && this.parent && this.parent.isListening() && !stopBubble) {
            if (compareShape && compareShape.parent) {
              this._fireAndBubble.call(this.parent, eventType, evt, compareShape);
            } else {
              this._fireAndBubble.call(this.parent, eventType, evt);
            }
          }
        }
      }
      _getProtoListeners(eventType) {
        let listeners = this._cache.get(ALL_LISTENERS);
        if (!listeners) {
          listeners = {};
          let obj = Object.getPrototypeOf(this);
          while (obj) {
            if (!obj.eventListeners) {
              obj = Object.getPrototypeOf(obj);
              continue;
            }
            for (var event in obj.eventListeners) {
              const newEvents = obj.eventListeners[event];
              const oldEvents = listeners[event] || [];
              listeners[event] = newEvents.concat(oldEvents);
            }
            obj = Object.getPrototypeOf(obj);
          }
          this._cache.set(ALL_LISTENERS, listeners);
        }
        return listeners[eventType];
      }
      _fire(eventType, evt) {
        evt = evt || {};
        evt.currentTarget = this;
        evt.type = eventType;
        const topListeners = this._getProtoListeners(eventType);
        if (topListeners) {
          for (var i2 = 0; i2 < topListeners.length; i2++) {
            topListeners[i2].handler.call(this, evt);
          }
        }
        const selfListeners = this.eventListeners[eventType];
        if (selfListeners) {
          for (var i2 = 0; i2 < selfListeners.length; i2++) {
            selfListeners[i2].handler.call(this, evt);
          }
        }
      }
      draw() {
        this.drawScene();
        this.drawHit();
        return this;
      }
      _createDragElement(evt) {
        var pointerId = evt ? evt.pointerId : void 0;
        var stage = this.getStage();
        var ap2 = this.getAbsolutePosition();
        var pos = stage._getPointerById(pointerId) || stage._changedPointerPositions[0] || ap2;
        DD$1._dragElements.set(this._id, {
          node: this,
          startPointerPos: pos,
          offset: {
            x: pos.x - ap2.x,
            y: pos.y - ap2.y
          },
          dragStatus: "ready",
          pointerId
        });
      }
      startDrag(evt, bubbleEvent = true) {
        if (!DD$1._dragElements.has(this._id)) {
          this._createDragElement(evt);
        }
        const elem = DD$1._dragElements.get(this._id);
        elem.dragStatus = "dragging";
        this.fire("dragstart", {
          type: "dragstart",
          target: this,
          evt: evt && evt.evt
        }, bubbleEvent);
      }
      _setDragPosition(evt, elem) {
        const pos = this.getStage()._getPointerById(elem.pointerId);
        if (!pos) {
          return;
        }
        var newNodePos = {
          x: pos.x - elem.offset.x,
          y: pos.y - elem.offset.y
        };
        var dbf = this.dragBoundFunc();
        if (dbf !== void 0) {
          const bounded = dbf.call(this, newNodePos, evt);
          if (!bounded) {
            Util.warn("dragBoundFunc did not return any value. That is unexpected behavior. You must return new absolute position from dragBoundFunc.");
          } else {
            newNodePos = bounded;
          }
        }
        if (!this._lastPos || this._lastPos.x !== newNodePos.x || this._lastPos.y !== newNodePos.y) {
          this.setAbsolutePosition(newNodePos);
          this._requestDraw();
        }
        this._lastPos = newNodePos;
      }
      stopDrag(evt) {
        const elem = DD$1._dragElements.get(this._id);
        if (elem) {
          elem.dragStatus = "stopped";
        }
        DD$1._endDragBefore(evt);
        DD$1._endDragAfter(evt);
      }
      setDraggable(draggable) {
        this._setAttr("draggable", draggable);
        this._dragChange();
      }
      isDragging() {
        const elem = DD$1._dragElements.get(this._id);
        return elem ? elem.dragStatus === "dragging" : false;
      }
      _listenDrag() {
        this._dragCleanup();
        this.on("mousedown.konva touchstart.konva", function(evt) {
          var shouldCheckButton = evt.evt["button"] !== void 0;
          var canDrag = !shouldCheckButton || Konva$2.dragButtons.indexOf(evt.evt["button"]) >= 0;
          if (!canDrag) {
            return;
          }
          if (this.isDragging()) {
            return;
          }
          var hasDraggingChild = false;
          DD$1._dragElements.forEach((elem) => {
            if (this.isAncestorOf(elem.node)) {
              hasDraggingChild = true;
            }
          });
          if (!hasDraggingChild) {
            this._createDragElement(evt);
          }
        });
      }
      _dragChange() {
        if (this.attrs.draggable) {
          this._listenDrag();
        } else {
          this._dragCleanup();
          var stage = this.getStage();
          if (!stage) {
            return;
          }
          const dragElement = DD$1._dragElements.get(this._id);
          const isDragging = dragElement && dragElement.dragStatus === "dragging";
          const isReady = dragElement && dragElement.dragStatus === "ready";
          if (isDragging) {
            this.stopDrag();
          } else if (isReady) {
            DD$1._dragElements.delete(this._id);
          }
        }
      }
      _dragCleanup() {
        this.off("mousedown.konva");
        this.off("touchstart.konva");
      }
      isClientRectOnScreen(margin = { x: 0, y: 0 }) {
        const stage = this.getStage();
        if (!stage) {
          return false;
        }
        const screenRect = {
          x: -margin.x,
          y: -margin.y,
          width: stage.width() + 2 * margin.x,
          height: stage.height() + 2 * margin.y
        };
        return Util.haveIntersection(screenRect, this.getClientRect());
      }
      static create(data, container) {
        if (Util._isString(data)) {
          data = JSON.parse(data);
        }
        return this._createNode(data, container);
      }
      static _createNode(obj, container) {
        var className = Node2.prototype.getClassName.call(obj), children = obj.children, no, len, n;
        if (container) {
          obj.attrs.container = container;
        }
        if (!Konva$2[className]) {
          Util.warn('Can not find a node with class name "' + className + '". Fallback to "Shape".');
          className = "Shape";
        }
        const Class = Konva$2[className];
        no = new Class(obj.attrs);
        if (children) {
          len = children.length;
          for (n = 0; n < len; n++) {
            no.add(Node2._createNode(children[n]));
          }
        }
        return no;
      }
    };
    Node$1.prototype.nodeType = "Node";
    Node$1.prototype._attrsAffectingSize = [];
    Node$1.prototype.eventListeners = {};
    Node$1.prototype.on.call(Node$1.prototype, TRANSFORM_CHANGE_STR$1, function() {
      if (this._batchingTransformChange) {
        this._needClearTransformCache = true;
        return;
      }
      this._clearCache(TRANSFORM);
      this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
    });
    Node$1.prototype.on.call(Node$1.prototype, "visibleChange.konva", function() {
      this._clearSelfAndDescendantCache(VISIBLE);
    });
    Node$1.prototype.on.call(Node$1.prototype, "listeningChange.konva", function() {
      this._clearSelfAndDescendantCache(LISTENING);
    });
    Node$1.prototype.on.call(Node$1.prototype, "opacityChange.konva", function() {
      this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
    });
    const addGetterSetter = Factory.addGetterSetter;
    addGetterSetter(Node$1, "zIndex");
    addGetterSetter(Node$1, "absolutePosition");
    addGetterSetter(Node$1, "position");
    addGetterSetter(Node$1, "x", 0, getNumberValidator());
    addGetterSetter(Node$1, "y", 0, getNumberValidator());
    addGetterSetter(Node$1, "globalCompositeOperation", "source-over", getStringValidator());
    addGetterSetter(Node$1, "opacity", 1, getNumberValidator());
    addGetterSetter(Node$1, "name", "", getStringValidator());
    addGetterSetter(Node$1, "id", "", getStringValidator());
    addGetterSetter(Node$1, "rotation", 0, getNumberValidator());
    Factory.addComponentsGetterSetter(Node$1, "scale", ["x", "y"]);
    addGetterSetter(Node$1, "scaleX", 1, getNumberValidator());
    addGetterSetter(Node$1, "scaleY", 1, getNumberValidator());
    Factory.addComponentsGetterSetter(Node$1, "skew", ["x", "y"]);
    addGetterSetter(Node$1, "skewX", 0, getNumberValidator());
    addGetterSetter(Node$1, "skewY", 0, getNumberValidator());
    Factory.addComponentsGetterSetter(Node$1, "offset", ["x", "y"]);
    addGetterSetter(Node$1, "offsetX", 0, getNumberValidator());
    addGetterSetter(Node$1, "offsetY", 0, getNumberValidator());
    addGetterSetter(Node$1, "dragDistance", null, getNumberValidator());
    addGetterSetter(Node$1, "width", 0, getNumberValidator());
    addGetterSetter(Node$1, "height", 0, getNumberValidator());
    addGetterSetter(Node$1, "listening", true, getBooleanValidator());
    addGetterSetter(Node$1, "preventDefault", true, getBooleanValidator());
    addGetterSetter(Node$1, "filters", null, function(val) {
      this._filterUpToDate = false;
      return val;
    });
    addGetterSetter(Node$1, "visible", true, getBooleanValidator());
    addGetterSetter(Node$1, "transformsEnabled", "all", getStringValidator());
    addGetterSetter(Node$1, "size");
    addGetterSetter(Node$1, "dragBoundFunc");
    addGetterSetter(Node$1, "draggable", false, getBooleanValidator());
    Factory.backCompat(Node$1, {
      rotateDeg: "rotate",
      setRotationDeg: "setRotation",
      getRotationDeg: "getRotation"
    });
    class Container extends Node$1 {
      constructor() {
        super(...arguments);
        this.children = [];
      }
      getChildren(filterFunc) {
        if (!filterFunc) {
          return this.children || [];
        }
        const children = this.children || [];
        var results = [];
        children.forEach(function(child) {
          if (filterFunc(child)) {
            results.push(child);
          }
        });
        return results;
      }
      hasChildren() {
        return this.getChildren().length > 0;
      }
      removeChildren() {
        this.getChildren().forEach((child) => {
          child.parent = null;
          child.index = 0;
          child.remove();
        });
        this.children = [];
        this._requestDraw();
        return this;
      }
      destroyChildren() {
        this.getChildren().forEach((child) => {
          child.parent = null;
          child.index = 0;
          child.destroy();
        });
        this.children = [];
        this._requestDraw();
        return this;
      }
      add(...children) {
        if (children.length === 0) {
          return this;
        }
        if (children.length > 1) {
          for (var i2 = 0; i2 < children.length; i2++) {
            this.add(children[i2]);
          }
          return this;
        }
        const child = children[0];
        if (child.getParent()) {
          child.moveTo(this);
          return this;
        }
        this._validateAdd(child);
        child.index = this.getChildren().length;
        child.parent = this;
        child._clearCaches();
        this.getChildren().push(child);
        this._fire("add", {
          child
        });
        this._requestDraw();
        return this;
      }
      destroy() {
        if (this.hasChildren()) {
          this.destroyChildren();
        }
        super.destroy();
        return this;
      }
      find(selector) {
        return this._generalFind(selector, false);
      }
      findOne(selector) {
        var result = this._generalFind(selector, true);
        return result.length > 0 ? result[0] : void 0;
      }
      _generalFind(selector, findOne) {
        var retArr = [];
        this._descendants((node) => {
          const valid = node._isMatch(selector);
          if (valid) {
            retArr.push(node);
          }
          if (valid && findOne) {
            return true;
          }
          return false;
        });
        return retArr;
      }
      _descendants(fn) {
        let shouldStop = false;
        const children = this.getChildren();
        for (const child of children) {
          shouldStop = fn(child);
          if (shouldStop) {
            return true;
          }
          if (!child.hasChildren()) {
            continue;
          }
          shouldStop = child._descendants(fn);
          if (shouldStop) {
            return true;
          }
        }
        return false;
      }
      toObject() {
        var obj = Node$1.prototype.toObject.call(this);
        obj.children = [];
        this.getChildren().forEach((child) => {
          obj.children.push(child.toObject());
        });
        return obj;
      }
      isAncestorOf(node) {
        var parent = node.getParent();
        while (parent) {
          if (parent._id === this._id) {
            return true;
          }
          parent = parent.getParent();
        }
        return false;
      }
      clone(obj) {
        var node = Node$1.prototype.clone.call(this, obj);
        this.getChildren().forEach(function(no) {
          node.add(no.clone());
        });
        return node;
      }
      getAllIntersections(pos) {
        var arr = [];
        this.find("Shape").forEach(function(shape) {
          if (shape.isVisible() && shape.intersects(pos)) {
            arr.push(shape);
          }
        });
        return arr;
      }
      _clearSelfAndDescendantCache(attr) {
        var _a2;
        super._clearSelfAndDescendantCache(attr);
        if (this.isCached()) {
          return;
        }
        (_a2 = this.children) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(node) {
          node._clearSelfAndDescendantCache(attr);
        });
      }
      _setChildrenIndices() {
        var _a2;
        (_a2 = this.children) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(child, n) {
          child.index = n;
        });
        this._requestDraw();
      }
      drawScene(can, top2) {
        var layer = this.getLayer(), canvas = can || layer && layer.getCanvas(), context = canvas && canvas.getContext(), cachedCanvas = this._getCanvasCache(), cachedSceneCanvas = cachedCanvas && cachedCanvas.scene;
        var caching = canvas && canvas.isCache;
        if (!this.isVisible() && !caching) {
          return this;
        }
        if (cachedSceneCanvas) {
          context.save();
          var m = this.getAbsoluteTransform(top2).getMatrix();
          context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
          this._drawCachedSceneCanvas(context);
          context.restore();
        } else {
          this._drawChildren("drawScene", canvas, top2);
        }
        return this;
      }
      drawHit(can, top2) {
        if (!this.shouldDrawHit(top2)) {
          return this;
        }
        var layer = this.getLayer(), canvas = can || layer && layer.hitCanvas, context = canvas && canvas.getContext(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;
        if (cachedHitCanvas) {
          context.save();
          var m = this.getAbsoluteTransform(top2).getMatrix();
          context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
          this._drawCachedHitCanvas(context);
          context.restore();
        } else {
          this._drawChildren("drawHit", canvas, top2);
        }
        return this;
      }
      _drawChildren(drawMethod, canvas, top2) {
        var _a2;
        var context = canvas && canvas.getContext(), clipWidth = this.clipWidth(), clipHeight = this.clipHeight(), clipFunc = this.clipFunc(), hasClip = clipWidth && clipHeight || clipFunc;
        const selfCache = top2 === this;
        if (hasClip) {
          context.save();
          var transform2 = this.getAbsoluteTransform(top2);
          var m = transform2.getMatrix();
          context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
          context.beginPath();
          if (clipFunc) {
            clipFunc.call(this, context, this);
          } else {
            var clipX = this.clipX();
            var clipY = this.clipY();
            context.rect(clipX, clipY, clipWidth, clipHeight);
          }
          context.clip();
          m = transform2.copy().invert().getMatrix();
          context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
        }
        var hasComposition = !selfCache && this.globalCompositeOperation() !== "source-over" && drawMethod === "drawScene";
        if (hasComposition) {
          context.save();
          context._applyGlobalCompositeOperation(this);
        }
        (_a2 = this.children) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(child) {
          child[drawMethod](canvas, top2);
        });
        if (hasComposition) {
          context.restore();
        }
        if (hasClip) {
          context.restore();
        }
      }
      getClientRect(config2) {
        var _a2;
        config2 = config2 || {};
        var skipTransform = config2.skipTransform;
        var relativeTo = config2.relativeTo;
        var minX, minY, maxX, maxY;
        var selfRect = {
          x: Infinity,
          y: Infinity,
          width: 0,
          height: 0
        };
        var that = this;
        (_a2 = this.children) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(child) {
          if (!child.visible()) {
            return;
          }
          var rect2 = child.getClientRect({
            relativeTo: that,
            skipShadow: config2.skipShadow,
            skipStroke: config2.skipStroke
          });
          if (rect2.width === 0 && rect2.height === 0) {
            return;
          }
          if (minX === void 0) {
            minX = rect2.x;
            minY = rect2.y;
            maxX = rect2.x + rect2.width;
            maxY = rect2.y + rect2.height;
          } else {
            minX = Math.min(minX, rect2.x);
            minY = Math.min(minY, rect2.y);
            maxX = Math.max(maxX, rect2.x + rect2.width);
            maxY = Math.max(maxY, rect2.y + rect2.height);
          }
        });
        var shapes2 = this.find("Shape");
        var hasVisible = false;
        for (var i2 = 0; i2 < shapes2.length; i2++) {
          var shape = shapes2[i2];
          if (shape._isVisible(this)) {
            hasVisible = true;
            break;
          }
        }
        if (hasVisible && minX !== void 0) {
          selfRect = {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
          };
        } else {
          selfRect = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
        if (!skipTransform) {
          return this._transformedRect(selfRect, relativeTo);
        }
        return selfRect;
      }
    }
    Factory.addComponentsGetterSetter(Container, "clip", [
      "x",
      "y",
      "width",
      "height"
    ]);
    Factory.addGetterSetter(Container, "clipX", void 0, getNumberValidator());
    Factory.addGetterSetter(Container, "clipY", void 0, getNumberValidator());
    Factory.addGetterSetter(Container, "clipWidth", void 0, getNumberValidator());
    Factory.addGetterSetter(Container, "clipHeight", void 0, getNumberValidator());
    Factory.addGetterSetter(Container, "clipFunc");
    const Captures = /* @__PURE__ */ new Map();
    const SUPPORT_POINTER_EVENTS = Konva$2._global["PointerEvent"] !== void 0;
    function getCapturedShape(pointerId) {
      return Captures.get(pointerId);
    }
    function createEvent(evt) {
      return {
        evt,
        pointerId: evt.pointerId
      };
    }
    function hasPointerCapture(pointerId, shape) {
      return Captures.get(pointerId) === shape;
    }
    function setPointerCapture(pointerId, shape) {
      releaseCapture(pointerId);
      const stage = shape.getStage();
      if (!stage)
        return;
      Captures.set(pointerId, shape);
      if (SUPPORT_POINTER_EVENTS) {
        shape._fire("gotpointercapture", createEvent(new PointerEvent("gotpointercapture")));
      }
    }
    function releaseCapture(pointerId, target2) {
      const shape = Captures.get(pointerId);
      if (!shape)
        return;
      const stage = shape.getStage();
      if (stage && stage.content)
        ;
      Captures.delete(pointerId);
      if (SUPPORT_POINTER_EVENTS) {
        shape._fire("lostpointercapture", createEvent(new PointerEvent("lostpointercapture")));
      }
    }
    var STAGE = "Stage", STRING = "string", PX = "px", MOUSEOUT = "mouseout", MOUSELEAVE = "mouseleave", MOUSEOVER = "mouseover", MOUSEENTER = "mouseenter", MOUSEMOVE = "mousemove", MOUSEDOWN = "mousedown", MOUSEUP = "mouseup", POINTERMOVE = "pointermove", POINTERDOWN = "pointerdown", POINTERUP = "pointerup", POINTERCANCEL = "pointercancel", LOSTPOINTERCAPTURE = "lostpointercapture", POINTEROUT = "pointerout", POINTERLEAVE = "pointerleave", POINTEROVER = "pointerover", POINTERENTER = "pointerenter", CONTEXTMENU = "contextmenu", TOUCHSTART = "touchstart", TOUCHEND = "touchend", TOUCHMOVE = "touchmove", TOUCHCANCEL = "touchcancel", WHEEL = "wheel", MAX_LAYERS_NUMBER = 5, EVENTS = [
      [MOUSEENTER, "_pointerenter"],
      [MOUSEDOWN, "_pointerdown"],
      [MOUSEMOVE, "_pointermove"],
      [MOUSEUP, "_pointerup"],
      [MOUSELEAVE, "_pointerleave"],
      [TOUCHSTART, "_pointerdown"],
      [TOUCHMOVE, "_pointermove"],
      [TOUCHEND, "_pointerup"],
      [TOUCHCANCEL, "_pointercancel"],
      [MOUSEOVER, "_pointerover"],
      [WHEEL, "_wheel"],
      [CONTEXTMENU, "_contextmenu"],
      [POINTERDOWN, "_pointerdown"],
      [POINTERMOVE, "_pointermove"],
      [POINTERUP, "_pointerup"],
      [POINTERCANCEL, "_pointercancel"],
      [LOSTPOINTERCAPTURE, "_lostpointercapture"]
    ];
    const EVENTS_MAP = {
      mouse: {
        [POINTEROUT]: MOUSEOUT,
        [POINTERLEAVE]: MOUSELEAVE,
        [POINTEROVER]: MOUSEOVER,
        [POINTERENTER]: MOUSEENTER,
        [POINTERMOVE]: MOUSEMOVE,
        [POINTERDOWN]: MOUSEDOWN,
        [POINTERUP]: MOUSEUP,
        [POINTERCANCEL]: "mousecancel",
        pointerclick: "click",
        pointerdblclick: "dblclick"
      },
      touch: {
        [POINTEROUT]: "touchout",
        [POINTERLEAVE]: "touchleave",
        [POINTEROVER]: "touchover",
        [POINTERENTER]: "touchenter",
        [POINTERMOVE]: TOUCHMOVE,
        [POINTERDOWN]: TOUCHSTART,
        [POINTERUP]: TOUCHEND,
        [POINTERCANCEL]: TOUCHCANCEL,
        pointerclick: "tap",
        pointerdblclick: "dbltap"
      },
      pointer: {
        [POINTEROUT]: POINTEROUT,
        [POINTERLEAVE]: POINTERLEAVE,
        [POINTEROVER]: POINTEROVER,
        [POINTERENTER]: POINTERENTER,
        [POINTERMOVE]: POINTERMOVE,
        [POINTERDOWN]: POINTERDOWN,
        [POINTERUP]: POINTERUP,
        [POINTERCANCEL]: POINTERCANCEL,
        pointerclick: "pointerclick",
        pointerdblclick: "pointerdblclick"
      }
    };
    const getEventType = (type2) => {
      if (type2.indexOf("pointer") >= 0) {
        return "pointer";
      }
      if (type2.indexOf("touch") >= 0) {
        return "touch";
      }
      return "mouse";
    };
    const getEventsMap = (eventType) => {
      const type2 = getEventType(eventType);
      if (type2 === "pointer") {
        return Konva$2.pointerEventsEnabled && EVENTS_MAP.pointer;
      }
      if (type2 === "touch") {
        return EVENTS_MAP.touch;
      }
      if (type2 === "mouse") {
        return EVENTS_MAP.mouse;
      }
    };
    function checkNoClip(attrs = {}) {
      if (attrs.clipFunc || attrs.clipWidth || attrs.clipHeight) {
        Util.warn("Stage does not support clipping. Please use clip for Layers or Groups.");
      }
      return attrs;
    }
    const NO_POINTERS_MESSAGE = `Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);`;
    const stages = [];
    class Stage extends Container {
      constructor(config2) {
        super(checkNoClip(config2));
        this._pointerPositions = [];
        this._changedPointerPositions = [];
        this._buildDOM();
        this._bindContentEvents();
        stages.push(this);
        this.on("widthChange.konva heightChange.konva", this._resizeDOM);
        this.on("visibleChange.konva", this._checkVisibility);
        this.on("clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva", () => {
          checkNoClip(this.attrs);
        });
        this._checkVisibility();
      }
      _validateAdd(child) {
        const isLayer = child.getType() === "Layer";
        const isFastLayer = child.getType() === "FastLayer";
        const valid = isLayer || isFastLayer;
        if (!valid) {
          Util.throw("You may only add layers to the stage.");
        }
      }
      _checkVisibility() {
        if (!this.content) {
          return;
        }
        const style = this.visible() ? "" : "none";
        this.content.style.display = style;
      }
      setContainer(container) {
        if (typeof container === STRING) {
          if (container.charAt(0) === ".") {
            var className = container.slice(1);
            container = document.getElementsByClassName(className)[0];
          } else {
            var id2;
            if (container.charAt(0) !== "#") {
              id2 = container;
            } else {
              id2 = container.slice(1);
            }
            container = document.getElementById(id2);
          }
          if (!container) {
            throw "Can not find container in document with id " + id2;
          }
        }
        this._setAttr("container", container);
        if (this.content) {
          if (this.content.parentElement) {
            this.content.parentElement.removeChild(this.content);
          }
          container.appendChild(this.content);
        }
        return this;
      }
      shouldDrawHit() {
        return true;
      }
      clear() {
        var layers = this.children, len = layers.length, n;
        for (n = 0; n < len; n++) {
          layers[n].clear();
        }
        return this;
      }
      clone(obj) {
        if (!obj) {
          obj = {};
        }
        obj.container = typeof document !== "undefined" && document.createElement("div");
        return Container.prototype.clone.call(this, obj);
      }
      destroy() {
        super.destroy();
        var content2 = this.content;
        if (content2 && Util._isInDocument(content2)) {
          this.container().removeChild(content2);
        }
        var index = stages.indexOf(this);
        if (index > -1) {
          stages.splice(index, 1);
        }
        Util.releaseCanvas(this.bufferCanvas._canvas, this.bufferHitCanvas._canvas);
        return this;
      }
      getPointerPosition() {
        const pos = this._pointerPositions[0] || this._changedPointerPositions[0];
        if (!pos) {
          Util.warn(NO_POINTERS_MESSAGE);
          return null;
        }
        return {
          x: pos.x,
          y: pos.y
        };
      }
      _getPointerById(id2) {
        return this._pointerPositions.find((p2) => p2.id === id2);
      }
      getPointersPositions() {
        return this._pointerPositions;
      }
      getStage() {
        return this;
      }
      getContent() {
        return this.content;
      }
      _toKonvaCanvas(config2) {
        config2 = config2 || {};
        config2.x = config2.x || 0;
        config2.y = config2.y || 0;
        config2.width = config2.width || this.width();
        config2.height = config2.height || this.height();
        var canvas = new SceneCanvas({
          width: config2.width,
          height: config2.height,
          pixelRatio: config2.pixelRatio || 1
        });
        var _context = canvas.getContext()._context;
        var layers = this.children;
        if (config2.x || config2.y) {
          _context.translate(-1 * config2.x, -1 * config2.y);
        }
        layers.forEach(function(layer) {
          if (!layer.isVisible()) {
            return;
          }
          var layerCanvas = layer._toKonvaCanvas(config2);
          _context.drawImage(layerCanvas._canvas, config2.x, config2.y, layerCanvas.getWidth() / layerCanvas.getPixelRatio(), layerCanvas.getHeight() / layerCanvas.getPixelRatio());
        });
        return canvas;
      }
      getIntersection(pos) {
        if (!pos) {
          return null;
        }
        var layers = this.children, len = layers.length, end = len - 1, n;
        for (n = end; n >= 0; n--) {
          const shape = layers[n].getIntersection(pos);
          if (shape) {
            return shape;
          }
        }
        return null;
      }
      _resizeDOM() {
        var width = this.width();
        var height = this.height();
        if (this.content) {
          this.content.style.width = width + PX;
          this.content.style.height = height + PX;
        }
        this.bufferCanvas.setSize(width, height);
        this.bufferHitCanvas.setSize(width, height);
        this.children.forEach((layer) => {
          layer.setSize({ width, height });
          layer.draw();
        });
      }
      add(layer, ...rest) {
        if (arguments.length > 1) {
          for (var i2 = 0; i2 < arguments.length; i2++) {
            this.add(arguments[i2]);
          }
          return this;
        }
        super.add(layer);
        var length = this.children.length;
        if (length > MAX_LAYERS_NUMBER) {
          Util.warn("The stage has " + length + " layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group.");
        }
        layer.setSize({ width: this.width(), height: this.height() });
        layer.draw();
        if (Konva$2.isBrowser) {
          this.content.appendChild(layer.canvas._canvas);
        }
        return this;
      }
      getParent() {
        return null;
      }
      getLayer() {
        return null;
      }
      hasPointerCapture(pointerId) {
        return hasPointerCapture(pointerId, this);
      }
      setPointerCapture(pointerId) {
        setPointerCapture(pointerId, this);
      }
      releaseCapture(pointerId) {
        releaseCapture(pointerId);
      }
      getLayers() {
        return this.children;
      }
      _bindContentEvents() {
        if (!Konva$2.isBrowser) {
          return;
        }
        EVENTS.forEach(([event, methodName]) => {
          this.content.addEventListener(event, (evt) => {
            this[methodName](evt);
          }, { passive: false });
        });
      }
      _pointerenter(evt) {
        this.setPointersPositions(evt);
        const events = getEventsMap(evt.type);
        this._fire(events.pointerenter, {
          evt,
          target: this,
          currentTarget: this
        });
      }
      _pointerover(evt) {
        this.setPointersPositions(evt);
        const events = getEventsMap(evt.type);
        this._fire(events.pointerover, {
          evt,
          target: this,
          currentTarget: this
        });
      }
      _getTargetShape(evenType) {
        let shape = this[evenType + "targetShape"];
        if (shape && !shape.getStage()) {
          shape = null;
        }
        return shape;
      }
      _pointerleave(evt) {
        const events = getEventsMap(evt.type);
        const eventType = getEventType(evt.type);
        if (!events) {
          return;
        }
        this.setPointersPositions(evt);
        var targetShape = this._getTargetShape(eventType);
        var eventsEnabled = !DD$1.isDragging || Konva$2.hitOnDragEnabled;
        if (targetShape && eventsEnabled) {
          targetShape._fireAndBubble(events.pointerout, { evt });
          targetShape._fireAndBubble(events.pointerleave, { evt });
          this._fire(events.pointerleave, {
            evt,
            target: this,
            currentTarget: this
          });
          this[eventType + "targetShape"] = null;
        } else if (eventsEnabled) {
          this._fire(events.pointerleave, {
            evt,
            target: this,
            currentTarget: this
          });
          this._fire(events.pointerout, {
            evt,
            target: this,
            currentTarget: this
          });
        }
        this.pointerPos = void 0;
        this._pointerPositions = [];
      }
      _pointerdown(evt) {
        const events = getEventsMap(evt.type);
        const eventType = getEventType(evt.type);
        if (!events) {
          return;
        }
        this.setPointersPositions(evt);
        var triggeredOnShape = false;
        this._changedPointerPositions.forEach((pos) => {
          var shape = this.getIntersection(pos);
          DD$1.justDragged = false;
          Konva$2["_" + eventType + "ListenClick"] = true;
          const hasShape = shape && shape.isListening();
          if (!hasShape) {
            return;
          }
          if (Konva$2.capturePointerEventsEnabled) {
            shape.setPointerCapture(pos.id);
          }
          this[eventType + "ClickStartShape"] = shape;
          shape._fireAndBubble(events.pointerdown, {
            evt,
            pointerId: pos.id
          });
          triggeredOnShape = true;
          const isTouch = evt.type.indexOf("touch") >= 0;
          if (shape.preventDefault() && evt.cancelable && isTouch) {
            evt.preventDefault();
          }
        });
        if (!triggeredOnShape) {
          this._fire(events.pointerdown, {
            evt,
            target: this,
            currentTarget: this,
            pointerId: this._pointerPositions[0].id
          });
        }
      }
      _pointermove(evt) {
        const events = getEventsMap(evt.type);
        const eventType = getEventType(evt.type);
        if (!events) {
          return;
        }
        if (DD$1.isDragging && DD$1.node.preventDefault() && evt.cancelable) {
          evt.preventDefault();
        }
        this.setPointersPositions(evt);
        var eventsEnabled = !DD$1.isDragging || Konva$2.hitOnDragEnabled;
        if (!eventsEnabled) {
          return;
        }
        var processedShapesIds = {};
        let triggeredOnShape = false;
        var targetShape = this._getTargetShape(eventType);
        this._changedPointerPositions.forEach((pos) => {
          const shape = getCapturedShape(pos.id) || this.getIntersection(pos);
          const pointerId = pos.id;
          const event = { evt, pointerId };
          var differentTarget = targetShape !== shape;
          if (differentTarget && targetShape) {
            targetShape._fireAndBubble(events.pointerout, Object.assign({}, event), shape);
            targetShape._fireAndBubble(events.pointerleave, Object.assign({}, event), shape);
          }
          if (shape) {
            if (processedShapesIds[shape._id]) {
              return;
            }
            processedShapesIds[shape._id] = true;
          }
          if (shape && shape.isListening()) {
            triggeredOnShape = true;
            if (differentTarget) {
              shape._fireAndBubble(events.pointerover, Object.assign({}, event), targetShape);
              shape._fireAndBubble(events.pointerenter, Object.assign({}, event), targetShape);
              this[eventType + "targetShape"] = shape;
            }
            shape._fireAndBubble(events.pointermove, Object.assign({}, event));
          } else {
            if (targetShape) {
              this._fire(events.pointerover, {
                evt,
                target: this,
                currentTarget: this,
                pointerId
              });
              this[eventType + "targetShape"] = null;
            }
          }
        });
        if (!triggeredOnShape) {
          this._fire(events.pointermove, {
            evt,
            target: this,
            currentTarget: this,
            pointerId: this._changedPointerPositions[0].id
          });
        }
      }
      _pointerup(evt) {
        const events = getEventsMap(evt.type);
        const eventType = getEventType(evt.type);
        if (!events) {
          return;
        }
        this.setPointersPositions(evt);
        const clickStartShape = this[eventType + "ClickStartShape"];
        const clickEndShape = this[eventType + "ClickEndShape"];
        var processedShapesIds = {};
        let triggeredOnShape = false;
        this._changedPointerPositions.forEach((pos) => {
          const shape = getCapturedShape(pos.id) || this.getIntersection(pos);
          if (shape) {
            shape.releaseCapture(pos.id);
            if (processedShapesIds[shape._id]) {
              return;
            }
            processedShapesIds[shape._id] = true;
          }
          const pointerId = pos.id;
          const event = { evt, pointerId };
          let fireDblClick = false;
          if (Konva$2["_" + eventType + "InDblClickWindow"]) {
            fireDblClick = true;
            clearTimeout(this[eventType + "DblTimeout"]);
          } else if (!DD$1.justDragged) {
            Konva$2["_" + eventType + "InDblClickWindow"] = true;
            clearTimeout(this[eventType + "DblTimeout"]);
          }
          this[eventType + "DblTimeout"] = setTimeout(function() {
            Konva$2["_" + eventType + "InDblClickWindow"] = false;
          }, Konva$2.dblClickWindow);
          if (shape && shape.isListening()) {
            triggeredOnShape = true;
            this[eventType + "ClickEndShape"] = shape;
            shape._fireAndBubble(events.pointerup, Object.assign({}, event));
            if (Konva$2["_" + eventType + "ListenClick"] && clickStartShape && clickStartShape === shape) {
              shape._fireAndBubble(events.pointerclick, Object.assign({}, event));
              if (fireDblClick && clickEndShape && clickEndShape === shape) {
                shape._fireAndBubble(events.pointerdblclick, Object.assign({}, event));
              }
            }
          } else {
            this[eventType + "ClickEndShape"] = null;
            if (Konva$2["_" + eventType + "ListenClick"]) {
              this._fire(events.pointerclick, {
                evt,
                target: this,
                currentTarget: this,
                pointerId
              });
            }
            if (fireDblClick) {
              this._fire(events.pointerdblclick, {
                evt,
                target: this,
                currentTarget: this,
                pointerId
              });
            }
          }
        });
        if (!triggeredOnShape) {
          this._fire(events.pointerup, {
            evt,
            target: this,
            currentTarget: this,
            pointerId: this._changedPointerPositions[0].id
          });
        }
        Konva$2["_" + eventType + "ListenClick"] = false;
        if (evt.cancelable && eventType !== "touch") {
          evt.preventDefault();
        }
      }
      _contextmenu(evt) {
        this.setPointersPositions(evt);
        var shape = this.getIntersection(this.getPointerPosition());
        if (shape && shape.isListening()) {
          shape._fireAndBubble(CONTEXTMENU, { evt });
        } else {
          this._fire(CONTEXTMENU, {
            evt,
            target: this,
            currentTarget: this
          });
        }
      }
      _wheel(evt) {
        this.setPointersPositions(evt);
        var shape = this.getIntersection(this.getPointerPosition());
        if (shape && shape.isListening()) {
          shape._fireAndBubble(WHEEL, { evt });
        } else {
          this._fire(WHEEL, {
            evt,
            target: this,
            currentTarget: this
          });
        }
      }
      _pointercancel(evt) {
        this.setPointersPositions(evt);
        const shape = getCapturedShape(evt.pointerId) || this.getIntersection(this.getPointerPosition());
        if (shape) {
          shape._fireAndBubble(POINTERUP, createEvent(evt));
        }
        releaseCapture(evt.pointerId);
      }
      _lostpointercapture(evt) {
        releaseCapture(evt.pointerId);
      }
      setPointersPositions(evt) {
        var contentPosition = this._getContentPosition(), x = null, y = null;
        evt = evt ? evt : window.event;
        if (evt.touches !== void 0) {
          this._pointerPositions = [];
          this._changedPointerPositions = [];
          Array.prototype.forEach.call(evt.touches, (touch) => {
            this._pointerPositions.push({
              id: touch.identifier,
              x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,
              y: (touch.clientY - contentPosition.top) / contentPosition.scaleY
            });
          });
          Array.prototype.forEach.call(evt.changedTouches || evt.touches, (touch) => {
            this._changedPointerPositions.push({
              id: touch.identifier,
              x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,
              y: (touch.clientY - contentPosition.top) / contentPosition.scaleY
            });
          });
        } else {
          x = (evt.clientX - contentPosition.left) / contentPosition.scaleX;
          y = (evt.clientY - contentPosition.top) / contentPosition.scaleY;
          this.pointerPos = {
            x,
            y
          };
          this._pointerPositions = [{ x, y, id: Util._getFirstPointerId(evt) }];
          this._changedPointerPositions = [
            { x, y, id: Util._getFirstPointerId(evt) }
          ];
        }
      }
      _setPointerPosition(evt) {
        Util.warn('Method _setPointerPosition is deprecated. Use "stage.setPointersPositions(event)" instead.');
        this.setPointersPositions(evt);
      }
      _getContentPosition() {
        if (!this.content || !this.content.getBoundingClientRect) {
          return {
            top: 0,
            left: 0,
            scaleX: 1,
            scaleY: 1
          };
        }
        var rect2 = this.content.getBoundingClientRect();
        return {
          top: rect2.top,
          left: rect2.left,
          scaleX: rect2.width / this.content.clientWidth || 1,
          scaleY: rect2.height / this.content.clientHeight || 1
        };
      }
      _buildDOM() {
        this.bufferCanvas = new SceneCanvas({
          width: this.width(),
          height: this.height()
        });
        this.bufferHitCanvas = new HitCanvas({
          pixelRatio: 1,
          width: this.width(),
          height: this.height()
        });
        if (!Konva$2.isBrowser) {
          return;
        }
        var container = this.container();
        if (!container) {
          throw "Stage has no container. A container is required.";
        }
        container.innerHTML = "";
        this.content = document.createElement("div");
        this.content.style.position = "relative";
        this.content.style.userSelect = "none";
        this.content.className = "konvajs-content";
        this.content.setAttribute("role", "presentation");
        container.appendChild(this.content);
        this._resizeDOM();
      }
      cache() {
        Util.warn("Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.");
        return this;
      }
      clearCache() {
        return this;
      }
      batchDraw() {
        this.getChildren().forEach(function(layer) {
          layer.batchDraw();
        });
        return this;
      }
    }
    Stage.prototype.nodeType = STAGE;
    _registerNode(Stage);
    Factory.addGetterSetter(Stage, "container");
    var HAS_SHADOW = "hasShadow";
    var SHADOW_RGBA = "shadowRGBA";
    var patternImage = "patternImage";
    var linearGradient = "linearGradient";
    var radialGradient = "radialGradient";
    let dummyContext$1;
    function getDummyContext$1() {
      if (dummyContext$1) {
        return dummyContext$1;
      }
      dummyContext$1 = Util.createCanvasElement().getContext("2d");
      return dummyContext$1;
    }
    const shapes = {};
    function _fillFunc$2(context) {
      context.fill();
    }
    function _strokeFunc$2(context) {
      context.stroke();
    }
    function _fillFuncHit(context) {
      context.fill();
    }
    function _strokeFuncHit(context) {
      context.stroke();
    }
    function _clearHasShadowCache() {
      this._clearCache(HAS_SHADOW);
    }
    function _clearGetShadowRGBACache() {
      this._clearCache(SHADOW_RGBA);
    }
    function _clearFillPatternCache() {
      this._clearCache(patternImage);
    }
    function _clearLinearGradientCache() {
      this._clearCache(linearGradient);
    }
    function _clearRadialGradientCache() {
      this._clearCache(radialGradient);
    }
    class Shape extends Node$1 {
      constructor(config2) {
        super(config2);
        let key;
        while (true) {
          key = Util.getRandomColor();
          if (key && !(key in shapes)) {
            break;
          }
        }
        this.colorKey = key;
        shapes[key] = this;
      }
      getContext() {
        Util.warn("shape.getContext() method is deprecated. Please do not use it.");
        return this.getLayer().getContext();
      }
      getCanvas() {
        Util.warn("shape.getCanvas() method is deprecated. Please do not use it.");
        return this.getLayer().getCanvas();
      }
      getSceneFunc() {
        return this.attrs.sceneFunc || this["_sceneFunc"];
      }
      getHitFunc() {
        return this.attrs.hitFunc || this["_hitFunc"];
      }
      hasShadow() {
        return this._getCache(HAS_SHADOW, this._hasShadow);
      }
      _hasShadow() {
        return this.shadowEnabled() && this.shadowOpacity() !== 0 && !!(this.shadowColor() || this.shadowBlur() || this.shadowOffsetX() || this.shadowOffsetY());
      }
      _getFillPattern() {
        return this._getCache(patternImage, this.__getFillPattern);
      }
      __getFillPattern() {
        if (this.fillPatternImage()) {
          var ctx = getDummyContext$1();
          const pattern3 = ctx.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || "repeat");
          if (pattern3 && pattern3.setTransform) {
            const tr = new Transform();
            tr.translate(this.fillPatternX(), this.fillPatternY());
            tr.rotate(Konva$2.getAngle(this.fillPatternRotation()));
            tr.scale(this.fillPatternScaleX(), this.fillPatternScaleY());
            tr.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());
            const m = tr.getMatrix();
            const matrix = typeof DOMMatrix === "undefined" ? {
              a: m[0],
              b: m[1],
              c: m[2],
              d: m[3],
              e: m[4],
              f: m[5]
            } : new DOMMatrix(m);
            pattern3.setTransform(matrix);
          }
          return pattern3;
        }
      }
      _getLinearGradient() {
        return this._getCache(linearGradient, this.__getLinearGradient);
      }
      __getLinearGradient() {
        var colorStops = this.fillLinearGradientColorStops();
        if (colorStops) {
          var ctx = getDummyContext$1();
          var start = this.fillLinearGradientStartPoint();
          var end = this.fillLinearGradientEndPoint();
          var grd = ctx.createLinearGradient(start.x, start.y, end.x, end.y);
          for (var n = 0; n < colorStops.length; n += 2) {
            grd.addColorStop(colorStops[n], colorStops[n + 1]);
          }
          return grd;
        }
      }
      _getRadialGradient() {
        return this._getCache(radialGradient, this.__getRadialGradient);
      }
      __getRadialGradient() {
        var colorStops = this.fillRadialGradientColorStops();
        if (colorStops) {
          var ctx = getDummyContext$1();
          var start = this.fillRadialGradientStartPoint();
          var end = this.fillRadialGradientEndPoint();
          var grd = ctx.createRadialGradient(start.x, start.y, this.fillRadialGradientStartRadius(), end.x, end.y, this.fillRadialGradientEndRadius());
          for (var n = 0; n < colorStops.length; n += 2) {
            grd.addColorStop(colorStops[n], colorStops[n + 1]);
          }
          return grd;
        }
      }
      getShadowRGBA() {
        return this._getCache(SHADOW_RGBA, this._getShadowRGBA);
      }
      _getShadowRGBA() {
        if (!this.hasShadow()) {
          return;
        }
        var rgba2 = Util.colorToRGBA(this.shadowColor());
        if (rgba2) {
          return "rgba(" + rgba2.r + "," + rgba2.g + "," + rgba2.b + "," + rgba2.a * (this.shadowOpacity() || 1) + ")";
        }
      }
      hasFill() {
        return this._calculate("hasFill", [
          "fillEnabled",
          "fill",
          "fillPatternImage",
          "fillLinearGradientColorStops",
          "fillRadialGradientColorStops"
        ], () => {
          return this.fillEnabled() && !!(this.fill() || this.fillPatternImage() || this.fillLinearGradientColorStops() || this.fillRadialGradientColorStops());
        });
      }
      hasStroke() {
        return this._calculate("hasStroke", [
          "strokeEnabled",
          "strokeWidth",
          "stroke",
          "strokeLinearGradientColorStops"
        ], () => {
          return this.strokeEnabled() && this.strokeWidth() && !!(this.stroke() || this.strokeLinearGradientColorStops());
        });
      }
      hasHitStroke() {
        const width = this.hitStrokeWidth();
        if (width === "auto") {
          return this.hasStroke();
        }
        return this.strokeEnabled() && !!width;
      }
      intersects(point) {
        var stage = this.getStage(), bufferHitCanvas = stage.bufferHitCanvas, p2;
        bufferHitCanvas.getContext().clear();
        this.drawHit(bufferHitCanvas, null, true);
        p2 = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data;
        return p2[3] > 0;
      }
      destroy() {
        Node$1.prototype.destroy.call(this);
        delete shapes[this.colorKey];
        delete this.colorKey;
        return this;
      }
      _useBufferCanvas(forceFill) {
        var _a2;
        if (!this.getStage()) {
          return false;
        }
        const perfectDrawEnabled = (_a2 = this.attrs.perfectDrawEnabled) !== null && _a2 !== void 0 ? _a2 : true;
        if (!perfectDrawEnabled) {
          return false;
        }
        const hasFill = forceFill || this.hasFill();
        const hasStroke = this.hasStroke();
        const isTransparent = this.getAbsoluteOpacity() !== 1;
        if (hasFill && hasStroke && isTransparent) {
          return true;
        }
        const hasShadow = this.hasShadow();
        const strokeForShadow = this.shadowForStrokeEnabled();
        if (hasFill && hasStroke && hasShadow && strokeForShadow) {
          return true;
        }
        return false;
      }
      setStrokeHitEnabled(val) {
        Util.warn("strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead.");
        if (val) {
          this.hitStrokeWidth("auto");
        } else {
          this.hitStrokeWidth(0);
        }
      }
      getStrokeHitEnabled() {
        if (this.hitStrokeWidth() === 0) {
          return false;
        } else {
          return true;
        }
      }
      getSelfRect() {
        var size2 = this.size();
        return {
          x: this._centroid ? -size2.width / 2 : 0,
          y: this._centroid ? -size2.height / 2 : 0,
          width: size2.width,
          height: size2.height
        };
      }
      getClientRect(config2 = {}) {
        const skipTransform = config2.skipTransform;
        const relativeTo = config2.relativeTo;
        const fillRect = this.getSelfRect();
        const applyStroke = !config2.skipStroke && this.hasStroke();
        const strokeWidth = applyStroke && this.strokeWidth() || 0;
        const fillAndStrokeWidth = fillRect.width + strokeWidth;
        const fillAndStrokeHeight = fillRect.height + strokeWidth;
        const applyShadow = !config2.skipShadow && this.hasShadow();
        const shadowOffsetX = applyShadow ? this.shadowOffsetX() : 0;
        const shadowOffsetY = applyShadow ? this.shadowOffsetY() : 0;
        const preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);
        const preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);
        const blurRadius = applyShadow && this.shadowBlur() || 0;
        const width = preWidth + blurRadius * 2;
        const height = preHeight + blurRadius * 2;
        const rect2 = {
          width,
          height,
          x: -(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetX, 0) + fillRect.x,
          y: -(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetY, 0) + fillRect.y
        };
        if (!skipTransform) {
          return this._transformedRect(rect2, relativeTo);
        }
        return rect2;
      }
      drawScene(can, top2) {
        var layer = this.getLayer(), canvas = can || layer.getCanvas(), context = canvas.getContext(), cachedCanvas = this._getCanvasCache(), drawFunc = this.getSceneFunc(), hasShadow = this.hasShadow(), stage, bufferCanvas, bufferContext;
        var skipBuffer = canvas.isCache;
        var cachingSelf = top2 === this;
        if (!this.isVisible() && !cachingSelf) {
          return this;
        }
        if (cachedCanvas) {
          context.save();
          var m = this.getAbsoluteTransform(top2).getMatrix();
          context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
          this._drawCachedSceneCanvas(context);
          context.restore();
          return this;
        }
        if (!drawFunc) {
          return this;
        }
        context.save();
        if (this._useBufferCanvas() && !skipBuffer) {
          stage = this.getStage();
          bufferCanvas = stage.bufferCanvas;
          bufferContext = bufferCanvas.getContext();
          bufferContext.clear();
          bufferContext.save();
          bufferContext._applyLineJoin(this);
          var o = this.getAbsoluteTransform(top2).getMatrix();
          bufferContext.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
          drawFunc.call(this, bufferContext, this);
          bufferContext.restore();
          var ratio2 = bufferCanvas.pixelRatio;
          if (hasShadow) {
            context._applyShadow(this);
          }
          context._applyOpacity(this);
          context._applyGlobalCompositeOperation(this);
          context.drawImage(bufferCanvas._canvas, 0, 0, bufferCanvas.width / ratio2, bufferCanvas.height / ratio2);
        } else {
          context._applyLineJoin(this);
          if (!cachingSelf) {
            var o = this.getAbsoluteTransform(top2).getMatrix();
            context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
            context._applyOpacity(this);
            context._applyGlobalCompositeOperation(this);
          }
          if (hasShadow) {
            context._applyShadow(this);
          }
          drawFunc.call(this, context, this);
        }
        context.restore();
        return this;
      }
      drawHit(can, top2, skipDragCheck = false) {
        if (!this.shouldDrawHit(top2, skipDragCheck)) {
          return this;
        }
        var layer = this.getLayer(), canvas = can || layer.hitCanvas, context = canvas && canvas.getContext(), drawFunc = this.hitFunc() || this.sceneFunc(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;
        if (!this.colorKey) {
          Util.warn("Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()");
        }
        if (cachedHitCanvas) {
          context.save();
          var m = this.getAbsoluteTransform(top2).getMatrix();
          context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
          this._drawCachedHitCanvas(context);
          context.restore();
          return this;
        }
        if (!drawFunc) {
          return this;
        }
        context.save();
        context._applyLineJoin(this);
        const selfCache = this === top2;
        if (!selfCache) {
          var o = this.getAbsoluteTransform(top2).getMatrix();
          context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
        }
        drawFunc.call(this, context, this);
        context.restore();
        return this;
      }
      drawHitFromCache(alphaThreshold = 0) {
        var cachedCanvas = this._getCanvasCache(), sceneCanvas = this._getCachedSceneCanvas(), hitCanvas = cachedCanvas.hit, hitContext = hitCanvas.getContext(), hitWidth = hitCanvas.getWidth(), hitHeight = hitCanvas.getHeight(), hitImageData, hitData, len, rgbColorKey, i2, alpha2;
        hitContext.clear();
        hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);
        try {
          hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);
          hitData = hitImageData.data;
          len = hitData.length;
          rgbColorKey = Util._hexToRgb(this.colorKey);
          for (i2 = 0; i2 < len; i2 += 4) {
            alpha2 = hitData[i2 + 3];
            if (alpha2 > alphaThreshold) {
              hitData[i2] = rgbColorKey.r;
              hitData[i2 + 1] = rgbColorKey.g;
              hitData[i2 + 2] = rgbColorKey.b;
              hitData[i2 + 3] = 255;
            } else {
              hitData[i2 + 3] = 0;
            }
          }
          hitContext.putImageData(hitImageData, 0, 0);
        } catch (e) {
          Util.error("Unable to draw hit graph from cached scene canvas. " + e.message);
        }
        return this;
      }
      hasPointerCapture(pointerId) {
        return hasPointerCapture(pointerId, this);
      }
      setPointerCapture(pointerId) {
        setPointerCapture(pointerId, this);
      }
      releaseCapture(pointerId) {
        releaseCapture(pointerId);
      }
    }
    Shape.prototype._fillFunc = _fillFunc$2;
    Shape.prototype._strokeFunc = _strokeFunc$2;
    Shape.prototype._fillFuncHit = _fillFuncHit;
    Shape.prototype._strokeFuncHit = _strokeFuncHit;
    Shape.prototype._centroid = false;
    Shape.prototype.nodeType = "Shape";
    _registerNode(Shape);
    Shape.prototype.eventListeners = {};
    Shape.prototype.on.call(Shape.prototype, "shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", _clearHasShadowCache);
    Shape.prototype.on.call(Shape.prototype, "shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", _clearGetShadowRGBACache);
    Shape.prototype.on.call(Shape.prototype, "fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva", _clearFillPatternCache);
    Shape.prototype.on.call(Shape.prototype, "fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva", _clearLinearGradientCache);
    Shape.prototype.on.call(Shape.prototype, "fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva", _clearRadialGradientCache);
    Factory.addGetterSetter(Shape, "stroke", void 0, getStringOrGradientValidator());
    Factory.addGetterSetter(Shape, "strokeWidth", 2, getNumberValidator());
    Factory.addGetterSetter(Shape, "fillAfterStrokeEnabled", false);
    Factory.addGetterSetter(Shape, "hitStrokeWidth", "auto", getNumberOrAutoValidator());
    Factory.addGetterSetter(Shape, "strokeHitEnabled", true, getBooleanValidator());
    Factory.addGetterSetter(Shape, "perfectDrawEnabled", true, getBooleanValidator());
    Factory.addGetterSetter(Shape, "shadowForStrokeEnabled", true, getBooleanValidator());
    Factory.addGetterSetter(Shape, "lineJoin");
    Factory.addGetterSetter(Shape, "lineCap");
    Factory.addGetterSetter(Shape, "sceneFunc");
    Factory.addGetterSetter(Shape, "hitFunc");
    Factory.addGetterSetter(Shape, "dash");
    Factory.addGetterSetter(Shape, "dashOffset", 0, getNumberValidator());
    Factory.addGetterSetter(Shape, "shadowColor", void 0, getStringValidator());
    Factory.addGetterSetter(Shape, "shadowBlur", 0, getNumberValidator());
    Factory.addGetterSetter(Shape, "shadowOpacity", 1, getNumberValidator());
    Factory.addComponentsGetterSetter(Shape, "shadowOffset", ["x", "y"]);
    Factory.addGetterSetter(Shape, "shadowOffsetX", 0, getNumberValidator());
    Factory.addGetterSetter(Shape, "shadowOffsetY", 0, getNumberValidator());
    Factory.addGetterSetter(Shape, "fillPatternImage");
    Factory.addGetterSetter(Shape, "fill", void 0, getStringOrGradientValidator());
    Factory.addGetterSetter(Shape, "fillPatternX", 0, getNumberValidator());
    Factory.addGetterSetter(Shape, "fillPatternY", 0, getNumberValidator());
    Factory.addGetterSetter(Shape, "fillLinearGradientColorStops");
    Factory.addGetterSetter(Shape, "strokeLinearGradientColorStops");
    Factory.addGetterSetter(Shape, "fillRadialGradientStartRadius", 0);
    Factory.addGetterSetter(Shape, "fillRadialGradientEndRadius", 0);
    Factory.addGetterSetter(Shape, "fillRadialGradientColorStops");
    Factory.addGetterSetter(Shape, "fillPatternRepeat", "repeat");
    Factory.addGetterSetter(Shape, "fillEnabled", true);
    Factory.addGetterSetter(Shape, "strokeEnabled", true);
    Factory.addGetterSetter(Shape, "shadowEnabled", true);
    Factory.addGetterSetter(Shape, "dashEnabled", true);
    Factory.addGetterSetter(Shape, "strokeScaleEnabled", true);
    Factory.addGetterSetter(Shape, "fillPriority", "color");
    Factory.addComponentsGetterSetter(Shape, "fillPatternOffset", ["x", "y"]);
    Factory.addGetterSetter(Shape, "fillPatternOffsetX", 0, getNumberValidator());
    Factory.addGetterSetter(Shape, "fillPatternOffsetY", 0, getNumberValidator());
    Factory.addComponentsGetterSetter(Shape, "fillPatternScale", ["x", "y"]);
    Factory.addGetterSetter(Shape, "fillPatternScaleX", 1, getNumberValidator());
    Factory.addGetterSetter(Shape, "fillPatternScaleY", 1, getNumberValidator());
    Factory.addComponentsGetterSetter(Shape, "fillLinearGradientStartPoint", [
      "x",
      "y"
    ]);
    Factory.addComponentsGetterSetter(Shape, "strokeLinearGradientStartPoint", [
      "x",
      "y"
    ]);
    Factory.addGetterSetter(Shape, "fillLinearGradientStartPointX", 0);
    Factory.addGetterSetter(Shape, "strokeLinearGradientStartPointX", 0);
    Factory.addGetterSetter(Shape, "fillLinearGradientStartPointY", 0);
    Factory.addGetterSetter(Shape, "strokeLinearGradientStartPointY", 0);
    Factory.addComponentsGetterSetter(Shape, "fillLinearGradientEndPoint", [
      "x",
      "y"
    ]);
    Factory.addComponentsGetterSetter(Shape, "strokeLinearGradientEndPoint", [
      "x",
      "y"
    ]);
    Factory.addGetterSetter(Shape, "fillLinearGradientEndPointX", 0);
    Factory.addGetterSetter(Shape, "strokeLinearGradientEndPointX", 0);
    Factory.addGetterSetter(Shape, "fillLinearGradientEndPointY", 0);
    Factory.addGetterSetter(Shape, "strokeLinearGradientEndPointY", 0);
    Factory.addComponentsGetterSetter(Shape, "fillRadialGradientStartPoint", [
      "x",
      "y"
    ]);
    Factory.addGetterSetter(Shape, "fillRadialGradientStartPointX", 0);
    Factory.addGetterSetter(Shape, "fillRadialGradientStartPointY", 0);
    Factory.addComponentsGetterSetter(Shape, "fillRadialGradientEndPoint", [
      "x",
      "y"
    ]);
    Factory.addGetterSetter(Shape, "fillRadialGradientEndPointX", 0);
    Factory.addGetterSetter(Shape, "fillRadialGradientEndPointY", 0);
    Factory.addGetterSetter(Shape, "fillPatternRotation", 0);
    Factory.backCompat(Shape, {
      dashArray: "dash",
      getDashArray: "getDash",
      setDashArray: "getDash",
      drawFunc: "sceneFunc",
      getDrawFunc: "getSceneFunc",
      setDrawFunc: "setSceneFunc",
      drawHitFunc: "hitFunc",
      getDrawHitFunc: "getHitFunc",
      setDrawHitFunc: "setHitFunc"
    });
    var HASH = "#", BEFORE_DRAW = "beforeDraw", DRAW = "draw", INTERSECTION_OFFSETS = [
      { x: 0, y: 0 },
      { x: -1, y: -1 },
      { x: 1, y: -1 },
      { x: 1, y: 1 },
      { x: -1, y: 1 }
    ], INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;
    class Layer extends Container {
      constructor(config2) {
        super(config2);
        this.canvas = new SceneCanvas();
        this.hitCanvas = new HitCanvas({
          pixelRatio: 1
        });
        this._waitingForDraw = false;
        this.on("visibleChange.konva", this._checkVisibility);
        this._checkVisibility();
        this.on("imageSmoothingEnabledChange.konva", this._setSmoothEnabled);
        this._setSmoothEnabled();
      }
      createPNGStream() {
        const c = this.canvas._canvas;
        return c.createPNGStream();
      }
      getCanvas() {
        return this.canvas;
      }
      getNativeCanvasElement() {
        return this.canvas._canvas;
      }
      getHitCanvas() {
        return this.hitCanvas;
      }
      getContext() {
        return this.getCanvas().getContext();
      }
      clear(bounds) {
        this.getContext().clear(bounds);
        this.getHitCanvas().getContext().clear(bounds);
        return this;
      }
      setZIndex(index) {
        super.setZIndex(index);
        var stage = this.getStage();
        if (stage && stage.content) {
          stage.content.removeChild(this.getNativeCanvasElement());
          if (index < stage.children.length - 1) {
            stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[index + 1].getCanvas()._canvas);
          } else {
            stage.content.appendChild(this.getNativeCanvasElement());
          }
        }
        return this;
      }
      moveToTop() {
        Node$1.prototype.moveToTop.call(this);
        var stage = this.getStage();
        if (stage && stage.content) {
          stage.content.removeChild(this.getNativeCanvasElement());
          stage.content.appendChild(this.getNativeCanvasElement());
        }
        return true;
      }
      moveUp() {
        var moved = Node$1.prototype.moveUp.call(this);
        if (!moved) {
          return false;
        }
        var stage = this.getStage();
        if (!stage || !stage.content) {
          return false;
        }
        stage.content.removeChild(this.getNativeCanvasElement());
        if (this.index < stage.children.length - 1) {
          stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[this.index + 1].getCanvas()._canvas);
        } else {
          stage.content.appendChild(this.getNativeCanvasElement());
        }
        return true;
      }
      moveDown() {
        if (Node$1.prototype.moveDown.call(this)) {
          var stage = this.getStage();
          if (stage) {
            var children = stage.children;
            if (stage.content) {
              stage.content.removeChild(this.getNativeCanvasElement());
              stage.content.insertBefore(this.getNativeCanvasElement(), children[this.index + 1].getCanvas()._canvas);
            }
          }
          return true;
        }
        return false;
      }
      moveToBottom() {
        if (Node$1.prototype.moveToBottom.call(this)) {
          var stage = this.getStage();
          if (stage) {
            var children = stage.children;
            if (stage.content) {
              stage.content.removeChild(this.getNativeCanvasElement());
              stage.content.insertBefore(this.getNativeCanvasElement(), children[1].getCanvas()._canvas);
            }
          }
          return true;
        }
        return false;
      }
      getLayer() {
        return this;
      }
      remove() {
        var _canvas = this.getNativeCanvasElement();
        Node$1.prototype.remove.call(this);
        if (_canvas && _canvas.parentNode && Util._isInDocument(_canvas)) {
          _canvas.parentNode.removeChild(_canvas);
        }
        return this;
      }
      getStage() {
        return this.parent;
      }
      setSize({ width, height }) {
        this.canvas.setSize(width, height);
        this.hitCanvas.setSize(width, height);
        this._setSmoothEnabled();
        return this;
      }
      _validateAdd(child) {
        var type2 = child.getType();
        if (type2 !== "Group" && type2 !== "Shape") {
          Util.throw("You may only add groups and shapes to a layer.");
        }
      }
      _toKonvaCanvas(config2) {
        config2 = config2 || {};
        config2.width = config2.width || this.getWidth();
        config2.height = config2.height || this.getHeight();
        config2.x = config2.x !== void 0 ? config2.x : this.x();
        config2.y = config2.y !== void 0 ? config2.y : this.y();
        return Node$1.prototype._toKonvaCanvas.call(this, config2);
      }
      _checkVisibility() {
        const visible = this.visible();
        if (visible) {
          this.canvas._canvas.style.display = "block";
        } else {
          this.canvas._canvas.style.display = "none";
        }
      }
      _setSmoothEnabled() {
        this.getContext()._context.imageSmoothingEnabled = this.imageSmoothingEnabled();
      }
      getWidth() {
        if (this.parent) {
          return this.parent.width();
        }
      }
      setWidth() {
        Util.warn('Can not change width of layer. Use "stage.width(value)" function instead.');
      }
      getHeight() {
        if (this.parent) {
          return this.parent.height();
        }
      }
      setHeight() {
        Util.warn('Can not change height of layer. Use "stage.height(value)" function instead.');
      }
      batchDraw() {
        if (!this._waitingForDraw) {
          this._waitingForDraw = true;
          Util.requestAnimFrame(() => {
            this.draw();
            this._waitingForDraw = false;
          });
        }
        return this;
      }
      getIntersection(pos) {
        if (!this.isListening() || !this.isVisible()) {
          return null;
        }
        var spiralSearchDistance = 1;
        var continueSearch = false;
        while (true) {
          for (let i2 = 0; i2 < INTERSECTION_OFFSETS_LEN; i2++) {
            const intersectionOffset = INTERSECTION_OFFSETS[i2];
            const obj = this._getIntersection({
              x: pos.x + intersectionOffset.x * spiralSearchDistance,
              y: pos.y + intersectionOffset.y * spiralSearchDistance
            });
            const shape = obj.shape;
            if (shape) {
              return shape;
            }
            continueSearch = !!obj.antialiased;
            if (!obj.antialiased) {
              break;
            }
          }
          if (continueSearch) {
            spiralSearchDistance += 1;
          } else {
            return null;
          }
        }
      }
      _getIntersection(pos) {
        const ratio2 = this.hitCanvas.pixelRatio;
        const p2 = this.hitCanvas.context.getImageData(Math.round(pos.x * ratio2), Math.round(pos.y * ratio2), 1, 1).data;
        const p3 = p2[3];
        if (p3 === 255) {
          const colorKey = Util._rgbToHex(p2[0], p2[1], p2[2]);
          const shape = shapes[HASH + colorKey];
          if (shape) {
            return {
              shape
            };
          }
          return {
            antialiased: true
          };
        } else if (p3 > 0) {
          return {
            antialiased: true
          };
        }
        return {};
      }
      drawScene(can, top2) {
        var layer = this.getLayer(), canvas = can || layer && layer.getCanvas();
        this._fire(BEFORE_DRAW, {
          node: this
        });
        if (this.clearBeforeDraw()) {
          canvas.getContext().clear();
        }
        Container.prototype.drawScene.call(this, canvas, top2);
        this._fire(DRAW, {
          node: this
        });
        return this;
      }
      drawHit(can, top2) {
        var layer = this.getLayer(), canvas = can || layer && layer.hitCanvas;
        if (layer && layer.clearBeforeDraw()) {
          layer.getHitCanvas().getContext().clear();
        }
        Container.prototype.drawHit.call(this, canvas, top2);
        return this;
      }
      enableHitGraph() {
        this.hitGraphEnabled(true);
        return this;
      }
      disableHitGraph() {
        this.hitGraphEnabled(false);
        return this;
      }
      setHitGraphEnabled(val) {
        Util.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead.");
        this.listening(val);
      }
      getHitGraphEnabled(val) {
        Util.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead.");
        return this.listening();
      }
      toggleHitCanvas() {
        if (!this.parent || !this.parent["content"]) {
          return;
        }
        var parent = this.parent;
        var added = !!this.hitCanvas._canvas.parentNode;
        if (added) {
          parent.content.removeChild(this.hitCanvas._canvas);
        } else {
          parent.content.appendChild(this.hitCanvas._canvas);
        }
      }
      destroy() {
        Util.releaseCanvas(this.getNativeCanvasElement(), this.getHitCanvas()._canvas);
        return super.destroy();
      }
    }
    Layer.prototype.nodeType = "Layer";
    _registerNode(Layer);
    Factory.addGetterSetter(Layer, "imageSmoothingEnabled", true);
    Factory.addGetterSetter(Layer, "clearBeforeDraw", true);
    Factory.addGetterSetter(Layer, "hitGraphEnabled", true, getBooleanValidator());
    class FastLayer extends Layer {
      constructor(attrs) {
        super(attrs);
        this.listening(false);
        Util.warn('Konva.Fast layer is deprecated. Please use "new Konva.Layer({ listening: false })" instead.');
      }
    }
    FastLayer.prototype.nodeType = "FastLayer";
    _registerNode(FastLayer);
    class Group extends Container {
      _validateAdd(child) {
        var type2 = child.getType();
        if (type2 !== "Group" && type2 !== "Shape") {
          Util.throw("You may only add groups and shapes to groups.");
        }
      }
    }
    Group.prototype.nodeType = "Group";
    _registerNode(Group);
    var now = function() {
      if (glob.performance && glob.performance.now) {
        return function() {
          return glob.performance.now();
        };
      }
      return function() {
        return (/* @__PURE__ */ new Date()).getTime();
      };
    }();
    class Animation {
      constructor(func, layers) {
        this.id = Animation.animIdCounter++;
        this.frame = {
          time: 0,
          timeDiff: 0,
          lastTime: now(),
          frameRate: 0
        };
        this.func = func;
        this.setLayers(layers);
      }
      setLayers(layers) {
        var lays = [];
        if (!layers) {
          lays = [];
        } else if (layers.length > 0) {
          lays = layers;
        } else {
          lays = [layers];
        }
        this.layers = lays;
        return this;
      }
      getLayers() {
        return this.layers;
      }
      addLayer(layer) {
        var layers = this.layers, len = layers.length, n;
        for (n = 0; n < len; n++) {
          if (layers[n]._id === layer._id) {
            return false;
          }
        }
        this.layers.push(layer);
        return true;
      }
      isRunning() {
        var a = Animation, animations = a.animations, len = animations.length, n;
        for (n = 0; n < len; n++) {
          if (animations[n].id === this.id) {
            return true;
          }
        }
        return false;
      }
      start() {
        this.stop();
        this.frame.timeDiff = 0;
        this.frame.lastTime = now();
        Animation._addAnimation(this);
        return this;
      }
      stop() {
        Animation._removeAnimation(this);
        return this;
      }
      _updateFrameObject(time) {
        this.frame.timeDiff = time - this.frame.lastTime;
        this.frame.lastTime = time;
        this.frame.time += this.frame.timeDiff;
        this.frame.frameRate = 1e3 / this.frame.timeDiff;
      }
      static _addAnimation(anim) {
        this.animations.push(anim);
        this._handleAnimation();
      }
      static _removeAnimation(anim) {
        var id2 = anim.id, animations = this.animations, len = animations.length, n;
        for (n = 0; n < len; n++) {
          if (animations[n].id === id2) {
            this.animations.splice(n, 1);
            break;
          }
        }
      }
      static _runFrames() {
        var layerHash = {}, animations = this.animations, anim, layers, func, n, i2, layersLen, layer, key, needRedraw;
        for (n = 0; n < animations.length; n++) {
          anim = animations[n];
          layers = anim.layers;
          func = anim.func;
          anim._updateFrameObject(now());
          layersLen = layers.length;
          if (func) {
            needRedraw = func.call(anim, anim.frame) !== false;
          } else {
            needRedraw = true;
          }
          if (!needRedraw) {
            continue;
          }
          for (i2 = 0; i2 < layersLen; i2++) {
            layer = layers[i2];
            if (layer._id !== void 0) {
              layerHash[layer._id] = layer;
            }
          }
        }
        for (key in layerHash) {
          if (!layerHash.hasOwnProperty(key)) {
            continue;
          }
          layerHash[key].batchDraw();
        }
      }
      static _animationLoop() {
        var Anim = Animation;
        if (Anim.animations.length) {
          Anim._runFrames();
          Util.requestAnimFrame(Anim._animationLoop);
        } else {
          Anim.animRunning = false;
        }
      }
      static _handleAnimation() {
        if (!this.animRunning) {
          this.animRunning = true;
          Util.requestAnimFrame(this._animationLoop);
        }
      }
    }
    Animation.animations = [];
    Animation.animIdCounter = 0;
    Animation.animRunning = false;
    var blacklist = {
      node: 1,
      duration: 1,
      easing: 1,
      onFinish: 1,
      yoyo: 1
    }, PAUSED = 1, PLAYING = 2, REVERSING = 3, idCounter = 0, colorAttrs = ["fill", "stroke", "shadowColor"];
    class TweenEngine {
      constructor(prop2, propFunc, func, begin, finish, duration, yoyo) {
        this.prop = prop2;
        this.propFunc = propFunc;
        this.begin = begin;
        this._pos = begin;
        this.duration = duration;
        this._change = 0;
        this.prevPos = 0;
        this.yoyo = yoyo;
        this._time = 0;
        this._position = 0;
        this._startTime = 0;
        this._finish = 0;
        this.func = func;
        this._change = finish - this.begin;
        this.pause();
      }
      fire(str) {
        var handler = this[str];
        if (handler) {
          handler();
        }
      }
      setTime(t) {
        if (t > this.duration) {
          if (this.yoyo) {
            this._time = this.duration;
            this.reverse();
          } else {
            this.finish();
          }
        } else if (t < 0) {
          if (this.yoyo) {
            this._time = 0;
            this.play();
          } else {
            this.reset();
          }
        } else {
          this._time = t;
          this.update();
        }
      }
      getTime() {
        return this._time;
      }
      setPosition(p2) {
        this.prevPos = this._pos;
        this.propFunc(p2);
        this._pos = p2;
      }
      getPosition(t) {
        if (t === void 0) {
          t = this._time;
        }
        return this.func(t, this.begin, this._change, this.duration);
      }
      play() {
        this.state = PLAYING;
        this._startTime = this.getTimer() - this._time;
        this.onEnterFrame();
        this.fire("onPlay");
      }
      reverse() {
        this.state = REVERSING;
        this._time = this.duration - this._time;
        this._startTime = this.getTimer() - this._time;
        this.onEnterFrame();
        this.fire("onReverse");
      }
      seek(t) {
        this.pause();
        this._time = t;
        this.update();
        this.fire("onSeek");
      }
      reset() {
        this.pause();
        this._time = 0;
        this.update();
        this.fire("onReset");
      }
      finish() {
        this.pause();
        this._time = this.duration;
        this.update();
        this.fire("onFinish");
      }
      update() {
        this.setPosition(this.getPosition(this._time));
        this.fire("onUpdate");
      }
      onEnterFrame() {
        var t = this.getTimer() - this._startTime;
        if (this.state === PLAYING) {
          this.setTime(t);
        } else if (this.state === REVERSING) {
          this.setTime(this.duration - t);
        }
      }
      pause() {
        this.state = PAUSED;
        this.fire("onPause");
      }
      getTimer() {
        return (/* @__PURE__ */ new Date()).getTime();
      }
    }
    class Tween {
      constructor(config2) {
        var that = this, node = config2.node, nodeId = node._id, duration, easing = config2.easing || Easings.Linear, yoyo = !!config2.yoyo, key;
        if (typeof config2.duration === "undefined") {
          duration = 0.3;
        } else if (config2.duration === 0) {
          duration = 1e-3;
        } else {
          duration = config2.duration;
        }
        this.node = node;
        this._id = idCounter++;
        var layers = node.getLayer() || (node instanceof Konva$2["Stage"] ? node.getLayers() : null);
        if (!layers) {
          Util.error("Tween constructor have `node` that is not in a layer. Please add node into layer first.");
        }
        this.anim = new Animation(function() {
          that.tween.onEnterFrame();
        }, layers);
        this.tween = new TweenEngine(key, function(i2) {
          that._tweenFunc(i2);
        }, easing, 0, 1, duration * 1e3, yoyo);
        this._addListeners();
        if (!Tween.attrs[nodeId]) {
          Tween.attrs[nodeId] = {};
        }
        if (!Tween.attrs[nodeId][this._id]) {
          Tween.attrs[nodeId][this._id] = {};
        }
        if (!Tween.tweens[nodeId]) {
          Tween.tweens[nodeId] = {};
        }
        for (key in config2) {
          if (blacklist[key] === void 0) {
            this._addAttr(key, config2[key]);
          }
        }
        this.reset();
        this.onFinish = config2.onFinish;
        this.onReset = config2.onReset;
        this.onUpdate = config2.onUpdate;
      }
      _addAttr(key, end) {
        var node = this.node, nodeId = node._id, start, diff, tweenId, n, len, trueEnd, trueStart, endRGBA;
        tweenId = Tween.tweens[nodeId][key];
        if (tweenId) {
          delete Tween.attrs[nodeId][tweenId][key];
        }
        start = node.getAttr(key);
        if (Util._isArray(end)) {
          diff = [];
          len = Math.max(end.length, start.length);
          if (key === "points" && end.length !== start.length) {
            if (end.length > start.length) {
              trueStart = start;
              start = Util._prepareArrayForTween(start, end, node.closed());
            } else {
              trueEnd = end;
              end = Util._prepareArrayForTween(end, start, node.closed());
            }
          }
          if (key.indexOf("fill") === 0) {
            for (n = 0; n < len; n++) {
              if (n % 2 === 0) {
                diff.push(end[n] - start[n]);
              } else {
                var startRGBA = Util.colorToRGBA(start[n]);
                endRGBA = Util.colorToRGBA(end[n]);
                start[n] = startRGBA;
                diff.push({
                  r: endRGBA.r - startRGBA.r,
                  g: endRGBA.g - startRGBA.g,
                  b: endRGBA.b - startRGBA.b,
                  a: endRGBA.a - startRGBA.a
                });
              }
            }
          } else {
            for (n = 0; n < len; n++) {
              diff.push(end[n] - start[n]);
            }
          }
        } else if (colorAttrs.indexOf(key) !== -1) {
          start = Util.colorToRGBA(start);
          endRGBA = Util.colorToRGBA(end);
          diff = {
            r: endRGBA.r - start.r,
            g: endRGBA.g - start.g,
            b: endRGBA.b - start.b,
            a: endRGBA.a - start.a
          };
        } else {
          diff = end - start;
        }
        Tween.attrs[nodeId][this._id][key] = {
          start,
          diff,
          end,
          trueEnd,
          trueStart
        };
        Tween.tweens[nodeId][key] = this._id;
      }
      _tweenFunc(i2) {
        var node = this.node, attrs = Tween.attrs[node._id][this._id], key, attr, start, diff, newVal, n, len, end;
        for (key in attrs) {
          attr = attrs[key];
          start = attr.start;
          diff = attr.diff;
          end = attr.end;
          if (Util._isArray(start)) {
            newVal = [];
            len = Math.max(start.length, end.length);
            if (key.indexOf("fill") === 0) {
              for (n = 0; n < len; n++) {
                if (n % 2 === 0) {
                  newVal.push((start[n] || 0) + diff[n] * i2);
                } else {
                  newVal.push("rgba(" + Math.round(start[n].r + diff[n].r * i2) + "," + Math.round(start[n].g + diff[n].g * i2) + "," + Math.round(start[n].b + diff[n].b * i2) + "," + (start[n].a + diff[n].a * i2) + ")");
                }
              }
            } else {
              for (n = 0; n < len; n++) {
                newVal.push((start[n] || 0) + diff[n] * i2);
              }
            }
          } else if (colorAttrs.indexOf(key) !== -1) {
            newVal = "rgba(" + Math.round(start.r + diff.r * i2) + "," + Math.round(start.g + diff.g * i2) + "," + Math.round(start.b + diff.b * i2) + "," + (start.a + diff.a * i2) + ")";
          } else {
            newVal = start + diff * i2;
          }
          node.setAttr(key, newVal);
        }
      }
      _addListeners() {
        this.tween.onPlay = () => {
          this.anim.start();
        };
        this.tween.onReverse = () => {
          this.anim.start();
        };
        this.tween.onPause = () => {
          this.anim.stop();
        };
        this.tween.onFinish = () => {
          var node = this.node;
          var attrs = Tween.attrs[node._id][this._id];
          if (attrs.points && attrs.points.trueEnd) {
            node.setAttr("points", attrs.points.trueEnd);
          }
          if (this.onFinish) {
            this.onFinish.call(this);
          }
        };
        this.tween.onReset = () => {
          var node = this.node;
          var attrs = Tween.attrs[node._id][this._id];
          if (attrs.points && attrs.points.trueStart) {
            node.points(attrs.points.trueStart);
          }
          if (this.onReset) {
            this.onReset();
          }
        };
        this.tween.onUpdate = () => {
          if (this.onUpdate) {
            this.onUpdate.call(this);
          }
        };
      }
      play() {
        this.tween.play();
        return this;
      }
      reverse() {
        this.tween.reverse();
        return this;
      }
      reset() {
        this.tween.reset();
        return this;
      }
      seek(t) {
        this.tween.seek(t * 1e3);
        return this;
      }
      pause() {
        this.tween.pause();
        return this;
      }
      finish() {
        this.tween.finish();
        return this;
      }
      destroy() {
        var nodeId = this.node._id, thisId = this._id, attrs = Tween.tweens[nodeId], key;
        this.pause();
        for (key in attrs) {
          delete Tween.tweens[nodeId][key];
        }
        delete Tween.attrs[nodeId][thisId];
      }
    }
    Tween.attrs = {};
    Tween.tweens = {};
    Node$1.prototype.to = function(params) {
      var onFinish = params.onFinish;
      params.node = this;
      params.onFinish = function() {
        this.destroy();
        if (onFinish) {
          onFinish();
        }
      };
      var tween = new Tween(params);
      tween.play();
    };
    const Easings = {
      BackEaseIn(t, b, c, d) {
        var s = 1.70158;
        return c * (t /= d) * t * ((s + 1) * t - s) + b;
      },
      BackEaseOut(t, b, c, d) {
        var s = 1.70158;
        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
      },
      BackEaseInOut(t, b, c, d) {
        var s = 1.70158;
        if ((t /= d / 2) < 1) {
          return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
        }
        return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
      },
      ElasticEaseIn(t, b, c, d, a, p2) {
        var s = 0;
        if (t === 0) {
          return b;
        }
        if ((t /= d) === 1) {
          return b + c;
        }
        if (!p2) {
          p2 = d * 0.3;
        }
        if (!a || a < Math.abs(c)) {
          a = c;
          s = p2 / 4;
        } else {
          s = p2 / (2 * Math.PI) * Math.asin(c / a);
        }
        return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p2)) + b;
      },
      ElasticEaseOut(t, b, c, d, a, p2) {
        var s = 0;
        if (t === 0) {
          return b;
        }
        if ((t /= d) === 1) {
          return b + c;
        }
        if (!p2) {
          p2 = d * 0.3;
        }
        if (!a || a < Math.abs(c)) {
          a = c;
          s = p2 / 4;
        } else {
          s = p2 / (2 * Math.PI) * Math.asin(c / a);
        }
        return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p2) + c + b;
      },
      ElasticEaseInOut(t, b, c, d, a, p2) {
        var s = 0;
        if (t === 0) {
          return b;
        }
        if ((t /= d / 2) === 2) {
          return b + c;
        }
        if (!p2) {
          p2 = d * (0.3 * 1.5);
        }
        if (!a || a < Math.abs(c)) {
          a = c;
          s = p2 / 4;
        } else {
          s = p2 / (2 * Math.PI) * Math.asin(c / a);
        }
        if (t < 1) {
          return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p2)) + b;
        }
        return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p2) * 0.5 + c + b;
      },
      BounceEaseOut(t, b, c, d) {
        if ((t /= d) < 1 / 2.75) {
          return c * (7.5625 * t * t) + b;
        } else if (t < 2 / 2.75) {
          return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
        } else if (t < 2.5 / 2.75) {
          return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
        } else {
          return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
        }
      },
      BounceEaseIn(t, b, c, d) {
        return c - Easings.BounceEaseOut(d - t, 0, c, d) + b;
      },
      BounceEaseInOut(t, b, c, d) {
        if (t < d / 2) {
          return Easings.BounceEaseIn(t * 2, 0, c, d) * 0.5 + b;
        } else {
          return Easings.BounceEaseOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
        }
      },
      EaseIn(t, b, c, d) {
        return c * (t /= d) * t + b;
      },
      EaseOut(t, b, c, d) {
        return -c * (t /= d) * (t - 2) + b;
      },
      EaseInOut(t, b, c, d) {
        if ((t /= d / 2) < 1) {
          return c / 2 * t * t + b;
        }
        return -c / 2 * (--t * (t - 2) - 1) + b;
      },
      StrongEaseIn(t, b, c, d) {
        return c * (t /= d) * t * t * t * t + b;
      },
      StrongEaseOut(t, b, c, d) {
        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
      },
      StrongEaseInOut(t, b, c, d) {
        if ((t /= d / 2) < 1) {
          return c / 2 * t * t * t * t * t + b;
        }
        return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
      },
      Linear(t, b, c, d) {
        return c * t / d + b;
      }
    };
    const Konva$1 = Util._assign(Konva$2, {
      Util,
      Transform,
      Node: Node$1,
      Container,
      Stage,
      stages,
      Layer,
      FastLayer,
      Group,
      DD: DD$1,
      Shape,
      shapes,
      Animation,
      Tween,
      Easings,
      Context,
      Canvas
    });
    class Arc extends Shape {
      _sceneFunc(context) {
        var angle2 = Konva$2.getAngle(this.angle()), clockwise = this.clockwise();
        context.beginPath();
        context.arc(0, 0, this.outerRadius(), 0, angle2, clockwise);
        context.arc(0, 0, this.innerRadius(), angle2, 0, !clockwise);
        context.closePath();
        context.fillStrokeShape(this);
      }
      getWidth() {
        return this.outerRadius() * 2;
      }
      getHeight() {
        return this.outerRadius() * 2;
      }
      setWidth(width) {
        this.outerRadius(width / 2);
      }
      setHeight(height) {
        this.outerRadius(height / 2);
      }
      getSelfRect() {
        const innerRadius = this.innerRadius();
        const outerRadius = this.outerRadius();
        const clockwise = this.clockwise();
        const angle2 = Konva$2.getAngle(clockwise ? 360 - this.angle() : this.angle());
        const boundLeftRatio = Math.cos(Math.min(angle2, Math.PI));
        const boundRightRatio = 1;
        const boundTopRatio = Math.sin(Math.min(Math.max(Math.PI, angle2), 3 * Math.PI / 2));
        const boundBottomRatio = Math.sin(Math.min(angle2, Math.PI / 2));
        const boundLeft = boundLeftRatio * (boundLeftRatio > 0 ? innerRadius : outerRadius);
        const boundRight = boundRightRatio * outerRadius;
        const boundTop = boundTopRatio * (boundTopRatio > 0 ? innerRadius : outerRadius);
        const boundBottom = boundBottomRatio * (boundBottomRatio > 0 ? outerRadius : innerRadius);
        return {
          x: boundLeft,
          y: clockwise ? -1 * boundBottom : boundTop,
          width: boundRight - boundLeft,
          height: boundBottom - boundTop
        };
      }
    }
    Arc.prototype._centroid = true;
    Arc.prototype.className = "Arc";
    Arc.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
    _registerNode(Arc);
    Factory.addGetterSetter(Arc, "innerRadius", 0, getNumberValidator());
    Factory.addGetterSetter(Arc, "outerRadius", 0, getNumberValidator());
    Factory.addGetterSetter(Arc, "angle", 0, getNumberValidator());
    Factory.addGetterSetter(Arc, "clockwise", false, getBooleanValidator());
    function getControlPoints(x0, y0, x1, y1, x2, y2, t) {
      var d01 = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2)), d12 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)), fa = t * d01 / (d01 + d12), fb = t * d12 / (d01 + d12), p1x = x1 - fa * (x2 - x0), p1y = y1 - fa * (y2 - y0), p2x = x1 + fb * (x2 - x0), p2y = y1 + fb * (y2 - y0);
      return [p1x, p1y, p2x, p2y];
    }
    function expandPoints(p2, tension) {
      var len = p2.length, allPoints = [], n, cp;
      for (n = 2; n < len - 2; n += 2) {
        cp = getControlPoints(p2[n - 2], p2[n - 1], p2[n], p2[n + 1], p2[n + 2], p2[n + 3], tension);
        if (isNaN(cp[0])) {
          continue;
        }
        allPoints.push(cp[0]);
        allPoints.push(cp[1]);
        allPoints.push(p2[n]);
        allPoints.push(p2[n + 1]);
        allPoints.push(cp[2]);
        allPoints.push(cp[3]);
      }
      return allPoints;
    }
    class Line extends Shape {
      constructor(config2) {
        super(config2);
        this.on("pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva", function() {
          this._clearCache("tensionPoints");
        });
      }
      _sceneFunc(context) {
        var points = this.points(), length = points.length, tension = this.tension(), closed = this.closed(), bezier = this.bezier(), tp, len, n;
        if (!length) {
          return;
        }
        context.beginPath();
        context.moveTo(points[0], points[1]);
        if (tension !== 0 && length > 4) {
          tp = this.getTensionPoints();
          len = tp.length;
          n = closed ? 0 : 4;
          if (!closed) {
            context.quadraticCurveTo(tp[0], tp[1], tp[2], tp[3]);
          }
          while (n < len - 2) {
            context.bezierCurveTo(tp[n++], tp[n++], tp[n++], tp[n++], tp[n++], tp[n++]);
          }
          if (!closed) {
            context.quadraticCurveTo(tp[len - 2], tp[len - 1], points[length - 2], points[length - 1]);
          }
        } else if (bezier) {
          n = 2;
          while (n < length) {
            context.bezierCurveTo(points[n++], points[n++], points[n++], points[n++], points[n++], points[n++]);
          }
        } else {
          for (n = 2; n < length; n += 2) {
            context.lineTo(points[n], points[n + 1]);
          }
        }
        if (closed) {
          context.closePath();
          context.fillStrokeShape(this);
        } else {
          context.strokeShape(this);
        }
      }
      getTensionPoints() {
        return this._getCache("tensionPoints", this._getTensionPoints);
      }
      _getTensionPoints() {
        if (this.closed()) {
          return this._getTensionPointsClosed();
        } else {
          return expandPoints(this.points(), this.tension());
        }
      }
      _getTensionPointsClosed() {
        var p2 = this.points(), len = p2.length, tension = this.tension(), firstControlPoints = getControlPoints(p2[len - 2], p2[len - 1], p2[0], p2[1], p2[2], p2[3], tension), lastControlPoints = getControlPoints(p2[len - 4], p2[len - 3], p2[len - 2], p2[len - 1], p2[0], p2[1], tension), middle = expandPoints(p2, tension), tp = [firstControlPoints[2], firstControlPoints[3]].concat(middle).concat([
          lastControlPoints[0],
          lastControlPoints[1],
          p2[len - 2],
          p2[len - 1],
          lastControlPoints[2],
          lastControlPoints[3],
          firstControlPoints[0],
          firstControlPoints[1],
          p2[0],
          p2[1]
        ]);
        return tp;
      }
      getWidth() {
        return this.getSelfRect().width;
      }
      getHeight() {
        return this.getSelfRect().height;
      }
      getSelfRect() {
        var points = this.points();
        if (points.length < 4) {
          return {
            x: points[0] || 0,
            y: points[1] || 0,
            width: 0,
            height: 0
          };
        }
        if (this.tension() !== 0) {
          points = [
            points[0],
            points[1],
            ...this._getTensionPoints(),
            points[points.length - 2],
            points[points.length - 1]
          ];
        } else {
          points = this.points();
        }
        var minX = points[0];
        var maxX = points[0];
        var minY = points[1];
        var maxY = points[1];
        var x, y;
        for (var i2 = 0; i2 < points.length / 2; i2++) {
          x = points[i2 * 2];
          y = points[i2 * 2 + 1];
          minX = Math.min(minX, x);
          maxX = Math.max(maxX, x);
          minY = Math.min(minY, y);
          maxY = Math.max(maxY, y);
        }
        return {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        };
      }
    }
    Line.prototype.className = "Line";
    Line.prototype._attrsAffectingSize = ["points", "bezier", "tension"];
    _registerNode(Line);
    Factory.addGetterSetter(Line, "closed", false);
    Factory.addGetterSetter(Line, "bezier", false);
    Factory.addGetterSetter(Line, "tension", 0, getNumberValidator());
    Factory.addGetterSetter(Line, "points", [], getNumberArrayValidator());
    class Path extends Shape {
      constructor(config2) {
        super(config2);
        this.dataArray = [];
        this.pathLength = 0;
        this.dataArray = Path.parsePathData(this.data());
        this.pathLength = 0;
        for (var i2 = 0; i2 < this.dataArray.length; ++i2) {
          this.pathLength += this.dataArray[i2].pathLength;
        }
        this.on("dataChange.konva", function() {
          this.dataArray = Path.parsePathData(this.data());
          this.pathLength = 0;
          for (var i3 = 0; i3 < this.dataArray.length; ++i3) {
            this.pathLength += this.dataArray[i3].pathLength;
          }
        });
      }
      _sceneFunc(context) {
        var ca2 = this.dataArray;
        context.beginPath();
        var isClosed = false;
        for (var n = 0; n < ca2.length; n++) {
          var c = ca2[n].command;
          var p2 = ca2[n].points;
          switch (c) {
            case "L":
              context.lineTo(p2[0], p2[1]);
              break;
            case "M":
              context.moveTo(p2[0], p2[1]);
              break;
            case "C":
              context.bezierCurveTo(p2[0], p2[1], p2[2], p2[3], p2[4], p2[5]);
              break;
            case "Q":
              context.quadraticCurveTo(p2[0], p2[1], p2[2], p2[3]);
              break;
            case "A":
              var cx = p2[0], cy = p2[1], rx2 = p2[2], ry = p2[3], theta2 = p2[4], dTheta = p2[5], psi2 = p2[6], fs = p2[7];
              var r = rx2 > ry ? rx2 : ry;
              var scaleX = rx2 > ry ? 1 : rx2 / ry;
              var scaleY = rx2 > ry ? ry / rx2 : 1;
              context.translate(cx, cy);
              context.rotate(psi2);
              context.scale(scaleX, scaleY);
              context.arc(0, 0, r, theta2, theta2 + dTheta, 1 - fs);
              context.scale(1 / scaleX, 1 / scaleY);
              context.rotate(-psi2);
              context.translate(-cx, -cy);
              break;
            case "z":
              isClosed = true;
              context.closePath();
              break;
          }
        }
        if (!isClosed && !this.hasFill()) {
          context.strokeShape(this);
        } else {
          context.fillStrokeShape(this);
        }
      }
      getSelfRect() {
        var points = [];
        this.dataArray.forEach(function(data) {
          if (data.command === "A") {
            var start = data.points[4];
            var dTheta = data.points[5];
            var end = data.points[4] + dTheta;
            var inc = Math.PI / 180;
            if (Math.abs(start - end) < inc) {
              inc = Math.abs(start - end);
            }
            if (dTheta < 0) {
              for (let t = start - inc; t > end; t -= inc) {
                const point = Path.getPointOnEllipticalArc(data.points[0], data.points[1], data.points[2], data.points[3], t, 0);
                points.push(point.x, point.y);
              }
            } else {
              for (let t = start + inc; t < end; t += inc) {
                const point = Path.getPointOnEllipticalArc(data.points[0], data.points[1], data.points[2], data.points[3], t, 0);
                points.push(point.x, point.y);
              }
            }
          } else if (data.command === "C") {
            for (let t = 0; t <= 1; t += 0.01) {
              const point = Path.getPointOnCubicBezier(t, data.start.x, data.start.y, data.points[0], data.points[1], data.points[2], data.points[3], data.points[4], data.points[5]);
              points.push(point.x, point.y);
            }
          } else {
            points = points.concat(data.points);
          }
        });
        var minX = points[0];
        var maxX = points[0];
        var minY = points[1];
        var maxY = points[1];
        var x, y;
        for (var i2 = 0; i2 < points.length / 2; i2++) {
          x = points[i2 * 2];
          y = points[i2 * 2 + 1];
          if (!isNaN(x)) {
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
          }
          if (!isNaN(y)) {
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
          }
        }
        return {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        };
      }
      getLength() {
        return this.pathLength;
      }
      getPointAtLength(length) {
        var point, i2 = 0, ii2 = this.dataArray.length;
        if (!ii2) {
          return null;
        }
        while (i2 < ii2 && length > this.dataArray[i2].pathLength) {
          length -= this.dataArray[i2].pathLength;
          ++i2;
        }
        if (i2 === ii2) {
          point = this.dataArray[i2 - 1].points.slice(-2);
          return {
            x: point[0],
            y: point[1]
          };
        }
        if (length < 0.01) {
          point = this.dataArray[i2].points.slice(0, 2);
          return {
            x: point[0],
            y: point[1]
          };
        }
        var cp = this.dataArray[i2];
        var p2 = cp.points;
        switch (cp.command) {
          case "L":
            return Path.getPointOnLine(length, cp.start.x, cp.start.y, p2[0], p2[1]);
          case "C":
            return Path.getPointOnCubicBezier(length / cp.pathLength, cp.start.x, cp.start.y, p2[0], p2[1], p2[2], p2[3], p2[4], p2[5]);
          case "Q":
            return Path.getPointOnQuadraticBezier(length / cp.pathLength, cp.start.x, cp.start.y, p2[0], p2[1], p2[2], p2[3]);
          case "A":
            var cx = p2[0], cy = p2[1], rx2 = p2[2], ry = p2[3], theta2 = p2[4], dTheta = p2[5], psi2 = p2[6];
            theta2 += dTheta * length / cp.pathLength;
            return Path.getPointOnEllipticalArc(cx, cy, rx2, ry, theta2, psi2);
        }
        return null;
      }
      static getLineLength(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      }
      static getPointOnLine(dist2, P1x, P1y, P2x, P2y, fromX, fromY) {
        if (fromX === void 0) {
          fromX = P1x;
        }
        if (fromY === void 0) {
          fromY = P1y;
        }
        var m = (P2y - P1y) / (P2x - P1x + 1e-8);
        var run2 = Math.sqrt(dist2 * dist2 / (1 + m * m));
        if (P2x < P1x) {
          run2 *= -1;
        }
        var rise = m * run2;
        var pt;
        if (P2x === P1x) {
          pt = {
            x: fromX,
            y: fromY + rise
          };
        } else if ((fromY - P1y) / (fromX - P1x + 1e-8) === m) {
          pt = {
            x: fromX + run2,
            y: fromY + rise
          };
        } else {
          var ix, iy;
          var len = this.getLineLength(P1x, P1y, P2x, P2y);
          var u = (fromX - P1x) * (P2x - P1x) + (fromY - P1y) * (P2y - P1y);
          u = u / (len * len);
          ix = P1x + u * (P2x - P1x);
          iy = P1y + u * (P2y - P1y);
          var pRise = this.getLineLength(fromX, fromY, ix, iy);
          var pRun = Math.sqrt(dist2 * dist2 - pRise * pRise);
          run2 = Math.sqrt(pRun * pRun / (1 + m * m));
          if (P2x < P1x) {
            run2 *= -1;
          }
          rise = m * run2;
          pt = {
            x: ix + run2,
            y: iy + rise
          };
        }
        return pt;
      }
      static getPointOnCubicBezier(pct, P1x, P1y, P2x, P2y, P3x, P3y, P4x, P4y) {
        function CB1(t) {
          return t * t * t;
        }
        function CB2(t) {
          return 3 * t * t * (1 - t);
        }
        function CB3(t) {
          return 3 * t * (1 - t) * (1 - t);
        }
        function CB4(t) {
          return (1 - t) * (1 - t) * (1 - t);
        }
        var x = P4x * CB1(pct) + P3x * CB2(pct) + P2x * CB3(pct) + P1x * CB4(pct);
        var y = P4y * CB1(pct) + P3y * CB2(pct) + P2y * CB3(pct) + P1y * CB4(pct);
        return {
          x,
          y
        };
      }
      static getPointOnQuadraticBezier(pct, P1x, P1y, P2x, P2y, P3x, P3y) {
        function QB1(t) {
          return t * t;
        }
        function QB2(t) {
          return 2 * t * (1 - t);
        }
        function QB3(t) {
          return (1 - t) * (1 - t);
        }
        var x = P3x * QB1(pct) + P2x * QB2(pct) + P1x * QB3(pct);
        var y = P3y * QB1(pct) + P2y * QB2(pct) + P1y * QB3(pct);
        return {
          x,
          y
        };
      }
      static getPointOnEllipticalArc(cx, cy, rx2, ry, theta2, psi2) {
        var cosPsi = Math.cos(psi2), sinPsi = Math.sin(psi2);
        var pt = {
          x: rx2 * Math.cos(theta2),
          y: ry * Math.sin(theta2)
        };
        return {
          x: cx + (pt.x * cosPsi - pt.y * sinPsi),
          y: cy + (pt.x * sinPsi + pt.y * cosPsi)
        };
      }
      static parsePathData(data) {
        if (!data) {
          return [];
        }
        var cs2 = data;
        var cc = [
          "m",
          "M",
          "l",
          "L",
          "v",
          "V",
          "h",
          "H",
          "z",
          "Z",
          "c",
          "C",
          "q",
          "Q",
          "t",
          "T",
          "s",
          "S",
          "a",
          "A"
        ];
        cs2 = cs2.replace(new RegExp(" ", "g"), ",");
        for (var n = 0; n < cc.length; n++) {
          cs2 = cs2.replace(new RegExp(cc[n], "g"), "|" + cc[n]);
        }
        var arr = cs2.split("|");
        var ca2 = [];
        var coords = [];
        var cpx = 0;
        var cpy = 0;
        var re2 = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi;
        var match;
        for (n = 1; n < arr.length; n++) {
          var str = arr[n];
          var c = str.charAt(0);
          str = str.slice(1);
          coords.length = 0;
          while (match = re2.exec(str)) {
            coords.push(match[0]);
          }
          var p2 = [];
          for (var j = 0, jlen = coords.length; j < jlen; j++) {
            if (coords[j] === "00") {
              p2.push(0, 0);
              continue;
            }
            var parsed = parseFloat(coords[j]);
            if (!isNaN(parsed)) {
              p2.push(parsed);
            } else {
              p2.push(0);
            }
          }
          while (p2.length > 0) {
            if (isNaN(p2[0])) {
              break;
            }
            var cmd = null;
            var points = [];
            var startX = cpx, startY = cpy;
            var prevCmd, ctlPtx, ctlPty;
            var rx2, ry, psi2, fa, fs, x1, y1;
            switch (c) {
              case "l":
                cpx += p2.shift();
                cpy += p2.shift();
                cmd = "L";
                points.push(cpx, cpy);
                break;
              case "L":
                cpx = p2.shift();
                cpy = p2.shift();
                points.push(cpx, cpy);
                break;
              case "m":
                var dx = p2.shift();
                var dy = p2.shift();
                cpx += dx;
                cpy += dy;
                cmd = "M";
                if (ca2.length > 2 && ca2[ca2.length - 1].command === "z") {
                  for (var idx = ca2.length - 2; idx >= 0; idx--) {
                    if (ca2[idx].command === "M") {
                      cpx = ca2[idx].points[0] + dx;
                      cpy = ca2[idx].points[1] + dy;
                      break;
                    }
                  }
                }
                points.push(cpx, cpy);
                c = "l";
                break;
              case "M":
                cpx = p2.shift();
                cpy = p2.shift();
                cmd = "M";
                points.push(cpx, cpy);
                c = "L";
                break;
              case "h":
                cpx += p2.shift();
                cmd = "L";
                points.push(cpx, cpy);
                break;
              case "H":
                cpx = p2.shift();
                cmd = "L";
                points.push(cpx, cpy);
                break;
              case "v":
                cpy += p2.shift();
                cmd = "L";
                points.push(cpx, cpy);
                break;
              case "V":
                cpy = p2.shift();
                cmd = "L";
                points.push(cpx, cpy);
                break;
              case "C":
                points.push(p2.shift(), p2.shift(), p2.shift(), p2.shift());
                cpx = p2.shift();
                cpy = p2.shift();
                points.push(cpx, cpy);
                break;
              case "c":
                points.push(cpx + p2.shift(), cpy + p2.shift(), cpx + p2.shift(), cpy + p2.shift());
                cpx += p2.shift();
                cpy += p2.shift();
                cmd = "C";
                points.push(cpx, cpy);
                break;
              case "S":
                ctlPtx = cpx;
                ctlPty = cpy;
                prevCmd = ca2[ca2.length - 1];
                if (prevCmd.command === "C") {
                  ctlPtx = cpx + (cpx - prevCmd.points[2]);
                  ctlPty = cpy + (cpy - prevCmd.points[3]);
                }
                points.push(ctlPtx, ctlPty, p2.shift(), p2.shift());
                cpx = p2.shift();
                cpy = p2.shift();
                cmd = "C";
                points.push(cpx, cpy);
                break;
              case "s":
                ctlPtx = cpx;
                ctlPty = cpy;
                prevCmd = ca2[ca2.length - 1];
                if (prevCmd.command === "C") {
                  ctlPtx = cpx + (cpx - prevCmd.points[2]);
                  ctlPty = cpy + (cpy - prevCmd.points[3]);
                }
                points.push(ctlPtx, ctlPty, cpx + p2.shift(), cpy + p2.shift());
                cpx += p2.shift();
                cpy += p2.shift();
                cmd = "C";
                points.push(cpx, cpy);
                break;
              case "Q":
                points.push(p2.shift(), p2.shift());
                cpx = p2.shift();
                cpy = p2.shift();
                points.push(cpx, cpy);
                break;
              case "q":
                points.push(cpx + p2.shift(), cpy + p2.shift());
                cpx += p2.shift();
                cpy += p2.shift();
                cmd = "Q";
                points.push(cpx, cpy);
                break;
              case "T":
                ctlPtx = cpx;
                ctlPty = cpy;
                prevCmd = ca2[ca2.length - 1];
                if (prevCmd.command === "Q") {
                  ctlPtx = cpx + (cpx - prevCmd.points[0]);
                  ctlPty = cpy + (cpy - prevCmd.points[1]);
                }
                cpx = p2.shift();
                cpy = p2.shift();
                cmd = "Q";
                points.push(ctlPtx, ctlPty, cpx, cpy);
                break;
              case "t":
                ctlPtx = cpx;
                ctlPty = cpy;
                prevCmd = ca2[ca2.length - 1];
                if (prevCmd.command === "Q") {
                  ctlPtx = cpx + (cpx - prevCmd.points[0]);
                  ctlPty = cpy + (cpy - prevCmd.points[1]);
                }
                cpx += p2.shift();
                cpy += p2.shift();
                cmd = "Q";
                points.push(ctlPtx, ctlPty, cpx, cpy);
                break;
              case "A":
                rx2 = p2.shift();
                ry = p2.shift();
                psi2 = p2.shift();
                fa = p2.shift();
                fs = p2.shift();
                x1 = cpx;
                y1 = cpy;
                cpx = p2.shift();
                cpy = p2.shift();
                cmd = "A";
                points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx2, ry, psi2);
                break;
              case "a":
                rx2 = p2.shift();
                ry = p2.shift();
                psi2 = p2.shift();
                fa = p2.shift();
                fs = p2.shift();
                x1 = cpx;
                y1 = cpy;
                cpx += p2.shift();
                cpy += p2.shift();
                cmd = "A";
                points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx2, ry, psi2);
                break;
            }
            ca2.push({
              command: cmd || c,
              points,
              start: {
                x: startX,
                y: startY
              },
              pathLength: this.calcLength(startX, startY, cmd || c, points)
            });
          }
          if (c === "z" || c === "Z") {
            ca2.push({
              command: "z",
              points: [],
              start: void 0,
              pathLength: 0
            });
          }
        }
        return ca2;
      }
      static calcLength(x, y, cmd, points) {
        var len, p1, p2, t;
        var path = Path;
        switch (cmd) {
          case "L":
            return path.getLineLength(x, y, points[0], points[1]);
          case "C":
            len = 0;
            p1 = path.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
            for (t = 0.01; t <= 1; t += 0.01) {
              p2 = path.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
              len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
              p1 = p2;
            }
            return len;
          case "Q":
            len = 0;
            p1 = path.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);
            for (t = 0.01; t <= 1; t += 0.01) {
              p2 = path.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);
              len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
              p1 = p2;
            }
            return len;
          case "A":
            len = 0;
            var start = points[4];
            var dTheta = points[5];
            var end = points[4] + dTheta;
            var inc = Math.PI / 180;
            if (Math.abs(start - end) < inc) {
              inc = Math.abs(start - end);
            }
            p1 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);
            if (dTheta < 0) {
              for (t = start - inc; t > end; t -= inc) {
                p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                p1 = p2;
              }
            } else {
              for (t = start + inc; t < end; t += inc) {
                p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                p1 = p2;
              }
            }
            p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
            len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
            return len;
        }
        return 0;
      }
      static convertEndpointToCenterParameterization(x1, y1, x2, y2, fa, fs, rx2, ry, psiDeg) {
        var psi2 = psiDeg * (Math.PI / 180);
        var xp = Math.cos(psi2) * (x1 - x2) / 2 + Math.sin(psi2) * (y1 - y2) / 2;
        var yp = -1 * Math.sin(psi2) * (x1 - x2) / 2 + Math.cos(psi2) * (y1 - y2) / 2;
        var lambda2 = xp * xp / (rx2 * rx2) + yp * yp / (ry * ry);
        if (lambda2 > 1) {
          rx2 *= Math.sqrt(lambda2);
          ry *= Math.sqrt(lambda2);
        }
        var f = Math.sqrt((rx2 * rx2 * (ry * ry) - rx2 * rx2 * (yp * yp) - ry * ry * (xp * xp)) / (rx2 * rx2 * (yp * yp) + ry * ry * (xp * xp)));
        if (fa === fs) {
          f *= -1;
        }
        if (isNaN(f)) {
          f = 0;
        }
        var cxp = f * rx2 * yp / ry;
        var cyp = f * -ry * xp / rx2;
        var cx = (x1 + x2) / 2 + Math.cos(psi2) * cxp - Math.sin(psi2) * cyp;
        var cy = (y1 + y2) / 2 + Math.sin(psi2) * cxp + Math.cos(psi2) * cyp;
        var vMag = function(v2) {
          return Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
        };
        var vRatio = function(u2, v2) {
          return (u2[0] * v2[0] + u2[1] * v2[1]) / (vMag(u2) * vMag(v2));
        };
        var vAngle = function(u2, v2) {
          return (u2[0] * v2[1] < u2[1] * v2[0] ? -1 : 1) * Math.acos(vRatio(u2, v2));
        };
        var theta2 = vAngle([1, 0], [(xp - cxp) / rx2, (yp - cyp) / ry]);
        var u = [(xp - cxp) / rx2, (yp - cyp) / ry];
        var v = [(-1 * xp - cxp) / rx2, (-1 * yp - cyp) / ry];
        var dTheta = vAngle(u, v);
        if (vRatio(u, v) <= -1) {
          dTheta = Math.PI;
        }
        if (vRatio(u, v) >= 1) {
          dTheta = 0;
        }
        if (fs === 0 && dTheta > 0) {
          dTheta = dTheta - 2 * Math.PI;
        }
        if (fs === 1 && dTheta < 0) {
          dTheta = dTheta + 2 * Math.PI;
        }
        return [cx, cy, rx2, ry, theta2, dTheta, psi2, fs];
      }
    }
    Path.prototype.className = "Path";
    Path.prototype._attrsAffectingSize = ["data"];
    _registerNode(Path);
    Factory.addGetterSetter(Path, "data");
    class Arrow extends Line {
      _sceneFunc(ctx) {
        super._sceneFunc(ctx);
        var PI2 = Math.PI * 2;
        var points = this.points();
        var tp = points;
        var fromTension = this.tension() !== 0 && points.length > 4;
        if (fromTension) {
          tp = this.getTensionPoints();
        }
        var length = this.pointerLength();
        var n = points.length;
        var dx, dy;
        if (fromTension) {
          const lp = [
            tp[tp.length - 4],
            tp[tp.length - 3],
            tp[tp.length - 2],
            tp[tp.length - 1],
            points[n - 2],
            points[n - 1]
          ];
          const lastLength = Path.calcLength(tp[tp.length - 4], tp[tp.length - 3], "C", lp);
          const previous = Path.getPointOnQuadraticBezier(Math.min(1, 1 - length / lastLength), lp[0], lp[1], lp[2], lp[3], lp[4], lp[5]);
          dx = points[n - 2] - previous.x;
          dy = points[n - 1] - previous.y;
        } else {
          dx = points[n - 2] - points[n - 4];
          dy = points[n - 1] - points[n - 3];
        }
        var radians = (Math.atan2(dy, dx) + PI2) % PI2;
        var width = this.pointerWidth();
        if (this.pointerAtEnding()) {
          ctx.save();
          ctx.beginPath();
          ctx.translate(points[n - 2], points[n - 1]);
          ctx.rotate(radians);
          ctx.moveTo(0, 0);
          ctx.lineTo(-length, width / 2);
          ctx.lineTo(-length, -width / 2);
          ctx.closePath();
          ctx.restore();
          this.__fillStroke(ctx);
        }
        if (this.pointerAtBeginning()) {
          ctx.save();
          ctx.beginPath();
          ctx.translate(points[0], points[1]);
          if (fromTension) {
            dx = (tp[0] + tp[2]) / 2 - points[0];
            dy = (tp[1] + tp[3]) / 2 - points[1];
          } else {
            dx = points[2] - points[0];
            dy = points[3] - points[1];
          }
          ctx.rotate((Math.atan2(-dy, -dx) + PI2) % PI2);
          ctx.moveTo(0, 0);
          ctx.lineTo(-length, width / 2);
          ctx.lineTo(-length, -width / 2);
          ctx.closePath();
          ctx.restore();
          this.__fillStroke(ctx);
        }
      }
      __fillStroke(ctx) {
        var isDashEnabled = this.dashEnabled();
        if (isDashEnabled) {
          this.attrs.dashEnabled = false;
          ctx.setLineDash([]);
        }
        ctx.fillStrokeShape(this);
        if (isDashEnabled) {
          this.attrs.dashEnabled = true;
        }
      }
      getSelfRect() {
        const lineRect = super.getSelfRect();
        const offset = this.pointerWidth() / 2;
        return {
          x: lineRect.x - offset,
          y: lineRect.y - offset,
          width: lineRect.width + offset * 2,
          height: lineRect.height + offset * 2
        };
      }
    }
    Arrow.prototype.className = "Arrow";
    _registerNode(Arrow);
    Factory.addGetterSetter(Arrow, "pointerLength", 10, getNumberValidator());
    Factory.addGetterSetter(Arrow, "pointerWidth", 10, getNumberValidator());
    Factory.addGetterSetter(Arrow, "pointerAtBeginning", false);
    Factory.addGetterSetter(Arrow, "pointerAtEnding", true);
    class Circle extends Shape {
      _sceneFunc(context) {
        context.beginPath();
        context.arc(0, 0, this.attrs.radius || 0, 0, Math.PI * 2, false);
        context.closePath();
        context.fillStrokeShape(this);
      }
      getWidth() {
        return this.radius() * 2;
      }
      getHeight() {
        return this.radius() * 2;
      }
      setWidth(width) {
        if (this.radius() !== width / 2) {
          this.radius(width / 2);
        }
      }
      setHeight(height) {
        if (this.radius() !== height / 2) {
          this.radius(height / 2);
        }
      }
    }
    Circle.prototype._centroid = true;
    Circle.prototype.className = "Circle";
    Circle.prototype._attrsAffectingSize = ["radius"];
    _registerNode(Circle);
    Factory.addGetterSetter(Circle, "radius", 0, getNumberValidator());
    class Ellipse extends Shape {
      _sceneFunc(context) {
        var rx2 = this.radiusX(), ry = this.radiusY();
        context.beginPath();
        context.save();
        if (rx2 !== ry) {
          context.scale(1, ry / rx2);
        }
        context.arc(0, 0, rx2, 0, Math.PI * 2, false);
        context.restore();
        context.closePath();
        context.fillStrokeShape(this);
      }
      getWidth() {
        return this.radiusX() * 2;
      }
      getHeight() {
        return this.radiusY() * 2;
      }
      setWidth(width) {
        this.radiusX(width / 2);
      }
      setHeight(height) {
        this.radiusY(height / 2);
      }
    }
    Ellipse.prototype.className = "Ellipse";
    Ellipse.prototype._centroid = true;
    Ellipse.prototype._attrsAffectingSize = ["radiusX", "radiusY"];
    _registerNode(Ellipse);
    Factory.addComponentsGetterSetter(Ellipse, "radius", ["x", "y"]);
    Factory.addGetterSetter(Ellipse, "radiusX", 0, getNumberValidator());
    Factory.addGetterSetter(Ellipse, "radiusY", 0, getNumberValidator());
    let Image$1 = class Image2 extends Shape {
      constructor(attrs) {
        super(attrs);
        this.on("imageChange.konva", () => {
          this._setImageLoad();
        });
        this._setImageLoad();
      }
      _setImageLoad() {
        const image2 = this.image();
        if (image2 && image2.complete) {
          return;
        }
        if (image2 && image2.readyState === 4) {
          return;
        }
        if (image2 && image2["addEventListener"]) {
          image2["addEventListener"]("load", () => {
            this._requestDraw();
          });
        }
      }
      _useBufferCanvas() {
        return super._useBufferCanvas(true);
      }
      _sceneFunc(context) {
        const width = this.getWidth();
        const height = this.getHeight();
        const cornerRadius = this.cornerRadius();
        const image2 = this.attrs.image;
        let params;
        if (image2) {
          const cropWidth = this.attrs.cropWidth;
          const cropHeight = this.attrs.cropHeight;
          if (cropWidth && cropHeight) {
            params = [
              image2,
              this.cropX(),
              this.cropY(),
              cropWidth,
              cropHeight,
              0,
              0,
              width,
              height
            ];
          } else {
            params = [image2, 0, 0, width, height];
          }
        }
        if (this.hasFill() || this.hasStroke() || cornerRadius) {
          context.beginPath();
          cornerRadius ? Util.drawRoundedRectPath(context, width, height, cornerRadius) : context.rect(0, 0, width, height);
          context.closePath();
          context.fillStrokeShape(this);
        }
        if (image2) {
          if (cornerRadius) {
            context.clip();
          }
          context.drawImage.apply(context, params);
        }
      }
      _hitFunc(context) {
        var width = this.width(), height = this.height(), cornerRadius = this.cornerRadius();
        context.beginPath();
        if (!cornerRadius) {
          context.rect(0, 0, width, height);
        } else {
          Util.drawRoundedRectPath(context, width, height, cornerRadius);
        }
        context.closePath();
        context.fillStrokeShape(this);
      }
      getWidth() {
        var _a2, _b;
        return (_a2 = this.attrs.width) !== null && _a2 !== void 0 ? _a2 : (_b = this.image()) === null || _b === void 0 ? void 0 : _b.width;
      }
      getHeight() {
        var _a2, _b;
        return (_a2 = this.attrs.height) !== null && _a2 !== void 0 ? _a2 : (_b = this.image()) === null || _b === void 0 ? void 0 : _b.height;
      }
      static fromURL(url, callback, onError = null) {
        var img = Util.createImageElement();
        img.onload = function() {
          var image2 = new Image2({
            image: img
          });
          callback(image2);
        };
        img.onerror = onError;
        img.crossOrigin = "Anonymous";
        img.src = url;
      }
    };
    Image$1.prototype.className = "Image";
    _registerNode(Image$1);
    Factory.addGetterSetter(Image$1, "cornerRadius", 0, getNumberOrArrayOfNumbersValidator(4));
    Factory.addGetterSetter(Image$1, "image");
    Factory.addComponentsGetterSetter(Image$1, "crop", ["x", "y", "width", "height"]);
    Factory.addGetterSetter(Image$1, "cropX", 0, getNumberValidator());
    Factory.addGetterSetter(Image$1, "cropY", 0, getNumberValidator());
    Factory.addGetterSetter(Image$1, "cropWidth", 0, getNumberValidator());
    Factory.addGetterSetter(Image$1, "cropHeight", 0, getNumberValidator());
    var ATTR_CHANGE_LIST$2 = [
      "fontFamily",
      "fontSize",
      "fontStyle",
      "padding",
      "lineHeight",
      "text",
      "width",
      "height",
      "pointerDirection",
      "pointerWidth",
      "pointerHeight"
    ], CHANGE_KONVA$1 = "Change.konva", NONE$1 = "none", UP = "up", RIGHT$1 = "right", DOWN = "down", LEFT$1 = "left", attrChangeListLen$1 = ATTR_CHANGE_LIST$2.length;
    class Label extends Group {
      constructor(config2) {
        super(config2);
        this.on("add.konva", function(evt) {
          this._addListeners(evt.child);
          this._sync();
        });
      }
      getText() {
        return this.find("Text")[0];
      }
      getTag() {
        return this.find("Tag")[0];
      }
      _addListeners(text2) {
        var that = this, n;
        var func = function() {
          that._sync();
        };
        for (n = 0; n < attrChangeListLen$1; n++) {
          text2.on(ATTR_CHANGE_LIST$2[n] + CHANGE_KONVA$1, func);
        }
      }
      getWidth() {
        return this.getText().width();
      }
      getHeight() {
        return this.getText().height();
      }
      _sync() {
        var text2 = this.getText(), tag = this.getTag(), width, height, pointerDirection, pointerWidth, x, y, pointerHeight;
        if (text2 && tag) {
          width = text2.width();
          height = text2.height();
          pointerDirection = tag.pointerDirection();
          pointerWidth = tag.pointerWidth();
          pointerHeight = tag.pointerHeight();
          x = 0;
          y = 0;
          switch (pointerDirection) {
            case UP:
              x = width / 2;
              y = -1 * pointerHeight;
              break;
            case RIGHT$1:
              x = width + pointerWidth;
              y = height / 2;
              break;
            case DOWN:
              x = width / 2;
              y = height + pointerHeight;
              break;
            case LEFT$1:
              x = -1 * pointerWidth;
              y = height / 2;
              break;
          }
          tag.setAttrs({
            x: -1 * x,
            y: -1 * y,
            width,
            height
          });
          text2.setAttrs({
            x: -1 * x,
            y: -1 * y
          });
        }
      }
    }
    Label.prototype.className = "Label";
    _registerNode(Label);
    class Tag extends Shape {
      _sceneFunc(context) {
        var width = this.width(), height = this.height(), pointerDirection = this.pointerDirection(), pointerWidth = this.pointerWidth(), pointerHeight = this.pointerHeight(), cornerRadius = this.cornerRadius();
        let topLeft = 0;
        let topRight = 0;
        let bottomLeft = 0;
        let bottomRight = 0;
        if (typeof cornerRadius === "number") {
          topLeft = topRight = bottomLeft = bottomRight = Math.min(cornerRadius, width / 2, height / 2);
        } else {
          topLeft = Math.min(cornerRadius[0] || 0, width / 2, height / 2);
          topRight = Math.min(cornerRadius[1] || 0, width / 2, height / 2);
          bottomRight = Math.min(cornerRadius[2] || 0, width / 2, height / 2);
          bottomLeft = Math.min(cornerRadius[3] || 0, width / 2, height / 2);
        }
        context.beginPath();
        context.moveTo(topLeft, 0);
        if (pointerDirection === UP) {
          context.lineTo((width - pointerWidth) / 2, 0);
          context.lineTo(width / 2, -1 * pointerHeight);
          context.lineTo((width + pointerWidth) / 2, 0);
        }
        context.lineTo(width - topRight, 0);
        context.arc(width - topRight, topRight, topRight, Math.PI * 3 / 2, 0, false);
        if (pointerDirection === RIGHT$1) {
          context.lineTo(width, (height - pointerHeight) / 2);
          context.lineTo(width + pointerWidth, height / 2);
          context.lineTo(width, (height + pointerHeight) / 2);
        }
        context.lineTo(width, height - bottomRight);
        context.arc(width - bottomRight, height - bottomRight, bottomRight, 0, Math.PI / 2, false);
        if (pointerDirection === DOWN) {
          context.lineTo((width + pointerWidth) / 2, height);
          context.lineTo(width / 2, height + pointerHeight);
          context.lineTo((width - pointerWidth) / 2, height);
        }
        context.lineTo(bottomLeft, height);
        context.arc(bottomLeft, height - bottomLeft, bottomLeft, Math.PI / 2, Math.PI, false);
        if (pointerDirection === LEFT$1) {
          context.lineTo(0, (height + pointerHeight) / 2);
          context.lineTo(-1 * pointerWidth, height / 2);
          context.lineTo(0, (height - pointerHeight) / 2);
        }
        context.lineTo(0, topLeft);
        context.arc(topLeft, topLeft, topLeft, Math.PI, Math.PI * 3 / 2, false);
        context.closePath();
        context.fillStrokeShape(this);
      }
      getSelfRect() {
        var x = 0, y = 0, pointerWidth = this.pointerWidth(), pointerHeight = this.pointerHeight(), direction = this.pointerDirection(), width = this.width(), height = this.height();
        if (direction === UP) {
          y -= pointerHeight;
          height += pointerHeight;
        } else if (direction === DOWN) {
          height += pointerHeight;
        } else if (direction === LEFT$1) {
          x -= pointerWidth * 1.5;
          width += pointerWidth;
        } else if (direction === RIGHT$1) {
          width += pointerWidth * 1.5;
        }
        return {
          x,
          y,
          width,
          height
        };
      }
    }
    Tag.prototype.className = "Tag";
    _registerNode(Tag);
    Factory.addGetterSetter(Tag, "pointerDirection", NONE$1);
    Factory.addGetterSetter(Tag, "pointerWidth", 0, getNumberValidator());
    Factory.addGetterSetter(Tag, "pointerHeight", 0, getNumberValidator());
    Factory.addGetterSetter(Tag, "cornerRadius", 0, getNumberOrArrayOfNumbersValidator(4));
    class Rect extends Shape {
      _sceneFunc(context) {
        var cornerRadius = this.cornerRadius(), width = this.width(), height = this.height();
        context.beginPath();
        if (!cornerRadius) {
          context.rect(0, 0, width, height);
        } else {
          Util.drawRoundedRectPath(context, width, height, cornerRadius);
        }
        context.closePath();
        context.fillStrokeShape(this);
      }
    }
    Rect.prototype.className = "Rect";
    _registerNode(Rect);
    Factory.addGetterSetter(Rect, "cornerRadius", 0, getNumberOrArrayOfNumbersValidator(4));
    class RegularPolygon extends Shape {
      _sceneFunc(context) {
        const points = this._getPoints();
        context.beginPath();
        context.moveTo(points[0].x, points[0].y);
        for (var n = 1; n < points.length; n++) {
          context.lineTo(points[n].x, points[n].y);
        }
        context.closePath();
        context.fillStrokeShape(this);
      }
      _getPoints() {
        const sides = this.attrs.sides;
        const radius = this.attrs.radius || 0;
        const points = [];
        for (var n = 0; n < sides; n++) {
          points.push({
            x: radius * Math.sin(n * 2 * Math.PI / sides),
            y: -1 * radius * Math.cos(n * 2 * Math.PI / sides)
          });
        }
        return points;
      }
      getSelfRect() {
        const points = this._getPoints();
        var minX = points[0].x;
        var maxX = points[0].y;
        var minY = points[0].x;
        var maxY = points[0].y;
        points.forEach((point) => {
          minX = Math.min(minX, point.x);
          maxX = Math.max(maxX, point.x);
          minY = Math.min(minY, point.y);
          maxY = Math.max(maxY, point.y);
        });
        return {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        };
      }
      getWidth() {
        return this.radius() * 2;
      }
      getHeight() {
        return this.radius() * 2;
      }
      setWidth(width) {
        this.radius(width / 2);
      }
      setHeight(height) {
        this.radius(height / 2);
      }
    }
    RegularPolygon.prototype.className = "RegularPolygon";
    RegularPolygon.prototype._centroid = true;
    RegularPolygon.prototype._attrsAffectingSize = ["radius"];
    _registerNode(RegularPolygon);
    Factory.addGetterSetter(RegularPolygon, "radius", 0, getNumberValidator());
    Factory.addGetterSetter(RegularPolygon, "sides", 0, getNumberValidator());
    var PIx2 = Math.PI * 2;
    class Ring extends Shape {
      _sceneFunc(context) {
        context.beginPath();
        context.arc(0, 0, this.innerRadius(), 0, PIx2, false);
        context.moveTo(this.outerRadius(), 0);
        context.arc(0, 0, this.outerRadius(), PIx2, 0, true);
        context.closePath();
        context.fillStrokeShape(this);
      }
      getWidth() {
        return this.outerRadius() * 2;
      }
      getHeight() {
        return this.outerRadius() * 2;
      }
      setWidth(width) {
        this.outerRadius(width / 2);
      }
      setHeight(height) {
        this.outerRadius(height / 2);
      }
    }
    Ring.prototype.className = "Ring";
    Ring.prototype._centroid = true;
    Ring.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
    _registerNode(Ring);
    Factory.addGetterSetter(Ring, "innerRadius", 0, getNumberValidator());
    Factory.addGetterSetter(Ring, "outerRadius", 0, getNumberValidator());
    class Sprite extends Shape {
      constructor(config2) {
        super(config2);
        this._updated = true;
        this.anim = new Animation(() => {
          var updated2 = this._updated;
          this._updated = false;
          return updated2;
        });
        this.on("animationChange.konva", function() {
          this.frameIndex(0);
        });
        this.on("frameIndexChange.konva", function() {
          this._updated = true;
        });
        this.on("frameRateChange.konva", function() {
          if (!this.anim.isRunning()) {
            return;
          }
          clearInterval(this.interval);
          this._setInterval();
        });
      }
      _sceneFunc(context) {
        var anim = this.animation(), index = this.frameIndex(), ix4 = index * 4, set2 = this.animations()[anim], offsets = this.frameOffsets(), x = set2[ix4 + 0], y = set2[ix4 + 1], width = set2[ix4 + 2], height = set2[ix4 + 3], image2 = this.image();
        if (this.hasFill() || this.hasStroke()) {
          context.beginPath();
          context.rect(0, 0, width, height);
          context.closePath();
          context.fillStrokeShape(this);
        }
        if (image2) {
          if (offsets) {
            var offset = offsets[anim], ix2 = index * 2;
            context.drawImage(image2, x, y, width, height, offset[ix2 + 0], offset[ix2 + 1], width, height);
          } else {
            context.drawImage(image2, x, y, width, height, 0, 0, width, height);
          }
        }
      }
      _hitFunc(context) {
        var anim = this.animation(), index = this.frameIndex(), ix4 = index * 4, set2 = this.animations()[anim], offsets = this.frameOffsets(), width = set2[ix4 + 2], height = set2[ix4 + 3];
        context.beginPath();
        if (offsets) {
          var offset = offsets[anim];
          var ix2 = index * 2;
          context.rect(offset[ix2 + 0], offset[ix2 + 1], width, height);
        } else {
          context.rect(0, 0, width, height);
        }
        context.closePath();
        context.fillShape(this);
      }
      _useBufferCanvas() {
        return super._useBufferCanvas(true);
      }
      _setInterval() {
        var that = this;
        this.interval = setInterval(function() {
          that._updateIndex();
        }, 1e3 / this.frameRate());
      }
      start() {
        if (this.isRunning()) {
          return;
        }
        var layer = this.getLayer();
        this.anim.setLayers(layer);
        this._setInterval();
        this.anim.start();
      }
      stop() {
        this.anim.stop();
        clearInterval(this.interval);
      }
      isRunning() {
        return this.anim.isRunning();
      }
      _updateIndex() {
        var index = this.frameIndex(), animation = this.animation(), animations = this.animations(), anim = animations[animation], len = anim.length / 4;
        if (index < len - 1) {
          this.frameIndex(index + 1);
        } else {
          this.frameIndex(0);
        }
      }
    }
    Sprite.prototype.className = "Sprite";
    _registerNode(Sprite);
    Factory.addGetterSetter(Sprite, "animation");
    Factory.addGetterSetter(Sprite, "animations");
    Factory.addGetterSetter(Sprite, "frameOffsets");
    Factory.addGetterSetter(Sprite, "image");
    Factory.addGetterSetter(Sprite, "frameIndex", 0, getNumberValidator());
    Factory.addGetterSetter(Sprite, "frameRate", 17, getNumberValidator());
    Factory.backCompat(Sprite, {
      index: "frameIndex",
      getIndex: "getFrameIndex",
      setIndex: "setFrameIndex"
    });
    let Star$1 = class Star extends Shape {
      _sceneFunc(context) {
        var innerRadius = this.innerRadius(), outerRadius = this.outerRadius(), numPoints = this.numPoints();
        context.beginPath();
        context.moveTo(0, 0 - outerRadius);
        for (var n = 1; n < numPoints * 2; n++) {
          var radius = n % 2 === 0 ? outerRadius : innerRadius;
          var x = radius * Math.sin(n * Math.PI / numPoints);
          var y = -1 * radius * Math.cos(n * Math.PI / numPoints);
          context.lineTo(x, y);
        }
        context.closePath();
        context.fillStrokeShape(this);
      }
      getWidth() {
        return this.outerRadius() * 2;
      }
      getHeight() {
        return this.outerRadius() * 2;
      }
      setWidth(width) {
        this.outerRadius(width / 2);
      }
      setHeight(height) {
        this.outerRadius(height / 2);
      }
    };
    Star$1.prototype.className = "Star";
    Star$1.prototype._centroid = true;
    Star$1.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
    _registerNode(Star$1);
    Factory.addGetterSetter(Star$1, "numPoints", 5, getNumberValidator());
    Factory.addGetterSetter(Star$1, "innerRadius", 0, getNumberValidator());
    Factory.addGetterSetter(Star$1, "outerRadius", 0, getNumberValidator());
    function stringToArray(string) {
      return Array.from(string);
    }
    var AUTO = "auto", CENTER = "center", JUSTIFY = "justify", CHANGE_KONVA = "Change.konva", CONTEXT_2D = "2d", DASH = "-", LEFT = "left", TEXT = "text", TEXT_UPPER = "Text", TOP = "top", BOTTOM = "bottom", MIDDLE = "middle", NORMAL$1 = "normal", PX_SPACE = "px ", SPACE = " ", RIGHT = "right", WORD = "word", CHAR = "char", NONE = "none", ELLIPSIS = "", ATTR_CHANGE_LIST$1 = [
      "fontFamily",
      "fontSize",
      "fontStyle",
      "fontVariant",
      "padding",
      "align",
      "verticalAlign",
      "lineHeight",
      "text",
      "width",
      "height",
      "wrap",
      "ellipsis",
      "letterSpacing"
    ], attrChangeListLen = ATTR_CHANGE_LIST$1.length;
    function normalizeFontFamily(fontFamily) {
      return fontFamily.split(",").map((family) => {
        family = family.trim();
        const hasSpace = family.indexOf(" ") >= 0;
        const hasQuotes = family.indexOf('"') >= 0 || family.indexOf("'") >= 0;
        if (hasSpace && !hasQuotes) {
          family = `"${family}"`;
        }
        return family;
      }).join(", ");
    }
    var dummyContext;
    function getDummyContext() {
      if (dummyContext) {
        return dummyContext;
      }
      dummyContext = Util.createCanvasElement().getContext(CONTEXT_2D);
      return dummyContext;
    }
    function _fillFunc$1(context) {
      context.fillText(this._partialText, this._partialTextX, this._partialTextY);
    }
    function _strokeFunc$1(context) {
      context.strokeText(this._partialText, this._partialTextX, this._partialTextY);
    }
    function checkDefaultFill(config2) {
      config2 = config2 || {};
      if (!config2.fillLinearGradientColorStops && !config2.fillRadialGradientColorStops && !config2.fillPatternImage) {
        config2.fill = config2.fill || "black";
      }
      return config2;
    }
    class Text extends Shape {
      constructor(config2) {
        super(checkDefaultFill(config2));
        this._partialTextX = 0;
        this._partialTextY = 0;
        for (var n = 0; n < attrChangeListLen; n++) {
          this.on(ATTR_CHANGE_LIST$1[n] + CHANGE_KONVA, this._setTextData);
        }
        this._setTextData();
      }
      _sceneFunc(context) {
        var textArr = this.textArr, textArrLen = textArr.length;
        if (!this.text()) {
          return;
        }
        var padding = this.padding(), fontSize = this.fontSize(), lineHeightPx = this.lineHeight() * fontSize, verticalAlign = this.verticalAlign(), alignY = 0, align = this.align(), totalWidth = this.getWidth(), letterSpacing = this.letterSpacing(), fill = this.fill(), textDecoration = this.textDecoration(), shouldUnderline = textDecoration.indexOf("underline") !== -1, shouldLineThrough = textDecoration.indexOf("line-through") !== -1, n;
        var translateY = 0;
        var translateY = lineHeightPx / 2;
        var lineTranslateX = 0;
        var lineTranslateY = 0;
        context.setAttr("font", this._getContextFont());
        context.setAttr("textBaseline", MIDDLE);
        context.setAttr("textAlign", LEFT);
        if (verticalAlign === MIDDLE) {
          alignY = (this.getHeight() - textArrLen * lineHeightPx - padding * 2) / 2;
        } else if (verticalAlign === BOTTOM) {
          alignY = this.getHeight() - textArrLen * lineHeightPx - padding * 2;
        }
        context.translate(padding, alignY + padding);
        for (n = 0; n < textArrLen; n++) {
          var lineTranslateX = 0;
          var lineTranslateY = 0;
          var obj = textArr[n], text2 = obj.text, width = obj.width, lastLine = obj.lastInParagraph, spacesNumber, oneWord, lineWidth;
          context.save();
          if (align === RIGHT) {
            lineTranslateX += totalWidth - width - padding * 2;
          } else if (align === CENTER) {
            lineTranslateX += (totalWidth - width - padding * 2) / 2;
          }
          if (shouldUnderline) {
            context.save();
            context.beginPath();
            context.moveTo(lineTranslateX, translateY + lineTranslateY + Math.round(fontSize / 2));
            spacesNumber = text2.split(" ").length - 1;
            oneWord = spacesNumber === 0;
            lineWidth = align === JUSTIFY && !lastLine ? totalWidth - padding * 2 : width;
            context.lineTo(lineTranslateX + Math.round(lineWidth), translateY + lineTranslateY + Math.round(fontSize / 2));
            context.lineWidth = fontSize / 15;
            const gradient = this._getLinearGradient();
            context.strokeStyle = gradient || fill;
            context.stroke();
            context.restore();
          }
          if (shouldLineThrough) {
            context.save();
            context.beginPath();
            context.moveTo(lineTranslateX, translateY + lineTranslateY);
            spacesNumber = text2.split(" ").length - 1;
            oneWord = spacesNumber === 0;
            lineWidth = align === JUSTIFY && lastLine && !oneWord ? totalWidth - padding * 2 : width;
            context.lineTo(lineTranslateX + Math.round(lineWidth), translateY + lineTranslateY);
            context.lineWidth = fontSize / 15;
            const gradient = this._getLinearGradient();
            context.strokeStyle = gradient || fill;
            context.stroke();
            context.restore();
          }
          if (letterSpacing !== 0 || align === JUSTIFY) {
            spacesNumber = text2.split(" ").length - 1;
            var array = stringToArray(text2);
            for (var li = 0; li < array.length; li++) {
              var letter = array[li];
              if (letter === " " && !lastLine && align === JUSTIFY) {
                lineTranslateX += (totalWidth - padding * 2 - width) / spacesNumber;
              }
              this._partialTextX = lineTranslateX;
              this._partialTextY = translateY + lineTranslateY;
              this._partialText = letter;
              context.fillStrokeShape(this);
              lineTranslateX += this.measureSize(letter).width + letterSpacing;
            }
          } else {
            this._partialTextX = lineTranslateX;
            this._partialTextY = translateY + lineTranslateY;
            this._partialText = text2;
            context.fillStrokeShape(this);
          }
          context.restore();
          if (textArrLen > 1) {
            translateY += lineHeightPx;
          }
        }
      }
      _hitFunc(context) {
        var width = this.getWidth(), height = this.getHeight();
        context.beginPath();
        context.rect(0, 0, width, height);
        context.closePath();
        context.fillStrokeShape(this);
      }
      setText(text2) {
        var str = Util._isString(text2) ? text2 : text2 === null || text2 === void 0 ? "" : text2 + "";
        this._setAttr(TEXT, str);
        return this;
      }
      getWidth() {
        var isAuto = this.attrs.width === AUTO || this.attrs.width === void 0;
        return isAuto ? this.getTextWidth() + this.padding() * 2 : this.attrs.width;
      }
      getHeight() {
        var isAuto = this.attrs.height === AUTO || this.attrs.height === void 0;
        return isAuto ? this.fontSize() * this.textArr.length * this.lineHeight() + this.padding() * 2 : this.attrs.height;
      }
      getTextWidth() {
        return this.textWidth;
      }
      getTextHeight() {
        Util.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.");
        return this.textHeight;
      }
      measureSize(text2) {
        var _context = getDummyContext(), fontSize = this.fontSize(), metrics;
        _context.save();
        _context.font = this._getContextFont();
        metrics = _context.measureText(text2);
        _context.restore();
        return {
          width: metrics.width,
          height: fontSize
        };
      }
      _getContextFont() {
        return this.fontStyle() + SPACE + this.fontVariant() + SPACE + (this.fontSize() + PX_SPACE) + normalizeFontFamily(this.fontFamily());
      }
      _addTextLine(line) {
        const align = this.align();
        if (align === JUSTIFY) {
          line = line.trim();
        }
        var width = this._getTextWidth(line);
        return this.textArr.push({
          text: line,
          width,
          lastInParagraph: false
        });
      }
      _getTextWidth(text2) {
        var letterSpacing = this.letterSpacing();
        var length = text2.length;
        return getDummyContext().measureText(text2).width + (length ? letterSpacing * (length - 1) : 0);
      }
      _setTextData() {
        var lines = this.text().split("\n"), fontSize = +this.fontSize(), textWidth = 0, lineHeightPx = this.lineHeight() * fontSize, width = this.attrs.width, height = this.attrs.height, fixedWidth = width !== AUTO && width !== void 0, fixedHeight = height !== AUTO && height !== void 0, padding = this.padding(), maxWidth = width - padding * 2, maxHeightPx = height - padding * 2, currentHeightPx = 0, wrap = this.wrap(), shouldWrap = wrap !== NONE, wrapAtWord = wrap !== CHAR && shouldWrap, shouldAddEllipsis = this.ellipsis();
        this.textArr = [];
        getDummyContext().font = this._getContextFont();
        var additionalWidth = shouldAddEllipsis ? this._getTextWidth(ELLIPSIS) : 0;
        for (var i2 = 0, max = lines.length; i2 < max; ++i2) {
          var line = lines[i2];
          var lineWidth = this._getTextWidth(line);
          if (fixedWidth && lineWidth > maxWidth) {
            while (line.length > 0) {
              var low = 0, high = line.length, match = "", matchWidth = 0;
              while (low < high) {
                var mid2 = low + high >>> 1, substr = line.slice(0, mid2 + 1), substrWidth = this._getTextWidth(substr) + additionalWidth;
                if (substrWidth <= maxWidth) {
                  low = mid2 + 1;
                  match = substr;
                  matchWidth = substrWidth;
                } else {
                  high = mid2;
                }
              }
              if (match) {
                if (wrapAtWord) {
                  var wrapIndex;
                  var nextChar = line[match.length];
                  var nextIsSpaceOrDash = nextChar === SPACE || nextChar === DASH;
                  if (nextIsSpaceOrDash && matchWidth <= maxWidth) {
                    wrapIndex = match.length;
                  } else {
                    wrapIndex = Math.max(match.lastIndexOf(SPACE), match.lastIndexOf(DASH)) + 1;
                  }
                  if (wrapIndex > 0) {
                    low = wrapIndex;
                    match = match.slice(0, low);
                    matchWidth = this._getTextWidth(match);
                  }
                }
                match = match.trimRight();
                this._addTextLine(match);
                textWidth = Math.max(textWidth, matchWidth);
                currentHeightPx += lineHeightPx;
                var shouldHandleEllipsis = this._shouldHandleEllipsis(currentHeightPx);
                if (shouldHandleEllipsis) {
                  this._tryToAddEllipsisToLastLine();
                  break;
                }
                line = line.slice(low);
                line = line.trimLeft();
                if (line.length > 0) {
                  lineWidth = this._getTextWidth(line);
                  if (lineWidth <= maxWidth) {
                    this._addTextLine(line);
                    currentHeightPx += lineHeightPx;
                    textWidth = Math.max(textWidth, lineWidth);
                    break;
                  }
                }
              } else {
                break;
              }
            }
          } else {
            this._addTextLine(line);
            currentHeightPx += lineHeightPx;
            textWidth = Math.max(textWidth, lineWidth);
            if (this._shouldHandleEllipsis(currentHeightPx) && i2 < max - 1) {
              this._tryToAddEllipsisToLastLine();
            }
          }
          if (this.textArr[this.textArr.length - 1]) {
            this.textArr[this.textArr.length - 1].lastInParagraph = true;
          }
          if (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx) {
            break;
          }
        }
        this.textHeight = fontSize;
        this.textWidth = textWidth;
      }
      _shouldHandleEllipsis(currentHeightPx) {
        var fontSize = +this.fontSize(), lineHeightPx = this.lineHeight() * fontSize, height = this.attrs.height, fixedHeight = height !== AUTO && height !== void 0, padding = this.padding(), maxHeightPx = height - padding * 2, wrap = this.wrap(), shouldWrap = wrap !== NONE;
        return !shouldWrap || fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx;
      }
      _tryToAddEllipsisToLastLine() {
        var width = this.attrs.width, fixedWidth = width !== AUTO && width !== void 0, padding = this.padding(), maxWidth = width - padding * 2, shouldAddEllipsis = this.ellipsis();
        var lastLine = this.textArr[this.textArr.length - 1];
        if (!lastLine || !shouldAddEllipsis) {
          return;
        }
        if (fixedWidth) {
          var haveSpace = this._getTextWidth(lastLine.text + ELLIPSIS) < maxWidth;
          if (!haveSpace) {
            lastLine.text = lastLine.text.slice(0, lastLine.text.length - 3);
          }
        }
        this.textArr.splice(this.textArr.length - 1, 1);
        this._addTextLine(lastLine.text + ELLIPSIS);
      }
      getStrokeScaleEnabled() {
        return true;
      }
    }
    Text.prototype._fillFunc = _fillFunc$1;
    Text.prototype._strokeFunc = _strokeFunc$1;
    Text.prototype.className = TEXT_UPPER;
    Text.prototype._attrsAffectingSize = [
      "text",
      "fontSize",
      "padding",
      "wrap",
      "lineHeight",
      "letterSpacing"
    ];
    _registerNode(Text);
    Factory.overWriteSetter(Text, "width", getNumberOrAutoValidator());
    Factory.overWriteSetter(Text, "height", getNumberOrAutoValidator());
    Factory.addGetterSetter(Text, "fontFamily", "Arial");
    Factory.addGetterSetter(Text, "fontSize", 12, getNumberValidator());
    Factory.addGetterSetter(Text, "fontStyle", NORMAL$1);
    Factory.addGetterSetter(Text, "fontVariant", NORMAL$1);
    Factory.addGetterSetter(Text, "padding", 0, getNumberValidator());
    Factory.addGetterSetter(Text, "align", LEFT);
    Factory.addGetterSetter(Text, "verticalAlign", TOP);
    Factory.addGetterSetter(Text, "lineHeight", 1, getNumberValidator());
    Factory.addGetterSetter(Text, "wrap", WORD);
    Factory.addGetterSetter(Text, "ellipsis", false, getBooleanValidator());
    Factory.addGetterSetter(Text, "letterSpacing", 0, getNumberValidator());
    Factory.addGetterSetter(Text, "text", "", getStringValidator());
    Factory.addGetterSetter(Text, "textDecoration", "");
    var EMPTY_STRING = "", NORMAL = "normal";
    function _fillFunc(context) {
      context.fillText(this.partialText, 0, 0);
    }
    function _strokeFunc(context) {
      context.strokeText(this.partialText, 0, 0);
    }
    class TextPath extends Shape {
      constructor(config2) {
        super(config2);
        this.dummyCanvas = Util.createCanvasElement();
        this.dataArray = [];
        this.dataArray = Path.parsePathData(this.attrs.data);
        this.on("dataChange.konva", function() {
          this.dataArray = Path.parsePathData(this.attrs.data);
          this._setTextData();
        });
        this.on("textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva", this._setTextData);
        this._setTextData();
      }
      _sceneFunc(context) {
        context.setAttr("font", this._getContextFont());
        context.setAttr("textBaseline", this.textBaseline());
        context.setAttr("textAlign", "left");
        context.save();
        var textDecoration = this.textDecoration();
        var fill = this.fill();
        var fontSize = this.fontSize();
        var glyphInfo = this.glyphInfo;
        if (textDecoration === "underline") {
          context.beginPath();
        }
        for (var i2 = 0; i2 < glyphInfo.length; i2++) {
          context.save();
          var p0 = glyphInfo[i2].p0;
          context.translate(p0.x, p0.y);
          context.rotate(glyphInfo[i2].rotation);
          this.partialText = glyphInfo[i2].text;
          context.fillStrokeShape(this);
          if (textDecoration === "underline") {
            if (i2 === 0) {
              context.moveTo(0, fontSize / 2 + 1);
            }
            context.lineTo(fontSize, fontSize / 2 + 1);
          }
          context.restore();
        }
        if (textDecoration === "underline") {
          context.strokeStyle = fill;
          context.lineWidth = fontSize / 20;
          context.stroke();
        }
        context.restore();
      }
      _hitFunc(context) {
        context.beginPath();
        var glyphInfo = this.glyphInfo;
        if (glyphInfo.length >= 1) {
          var p0 = glyphInfo[0].p0;
          context.moveTo(p0.x, p0.y);
        }
        for (var i2 = 0; i2 < glyphInfo.length; i2++) {
          var p1 = glyphInfo[i2].p1;
          context.lineTo(p1.x, p1.y);
        }
        context.setAttr("lineWidth", this.fontSize());
        context.setAttr("strokeStyle", this.colorKey);
        context.stroke();
      }
      getTextWidth() {
        return this.textWidth;
      }
      getTextHeight() {
        Util.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.");
        return this.textHeight;
      }
      setText(text2) {
        return Text.prototype.setText.call(this, text2);
      }
      _getContextFont() {
        return Text.prototype._getContextFont.call(this);
      }
      _getTextSize(text2) {
        var dummyCanvas = this.dummyCanvas;
        var _context = dummyCanvas.getContext("2d");
        _context.save();
        _context.font = this._getContextFont();
        var metrics = _context.measureText(text2);
        _context.restore();
        return {
          width: metrics.width,
          height: parseInt(this.attrs.fontSize, 10)
        };
      }
      _setTextData() {
        var that = this;
        var size2 = this._getTextSize(this.attrs.text);
        var letterSpacing = this.letterSpacing();
        var align = this.align();
        var kerningFunc = this.kerningFunc();
        this.textWidth = size2.width;
        this.textHeight = size2.height;
        var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || "").length - 1) * letterSpacing, 0);
        this.glyphInfo = [];
        var fullPathWidth = 0;
        for (var l = 0; l < that.dataArray.length; l++) {
          if (that.dataArray[l].pathLength > 0) {
            fullPathWidth += that.dataArray[l].pathLength;
          }
        }
        var offset = 0;
        if (align === "center") {
          offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);
        }
        if (align === "right") {
          offset = Math.max(0, fullPathWidth - textFullWidth);
        }
        var charArr = stringToArray(this.text());
        var spacesNumber = this.text().split(" ").length - 1;
        var p0, p1, pathCmd;
        var pIndex = -1;
        var currentT = 0;
        var getNextPathSegment = function() {
          currentT = 0;
          var pathData = that.dataArray;
          for (var j = pIndex + 1; j < pathData.length; j++) {
            if (pathData[j].pathLength > 0) {
              pIndex = j;
              return pathData[j];
            } else if (pathData[j].command === "M") {
              p0 = {
                x: pathData[j].points[0],
                y: pathData[j].points[1]
              };
            }
          }
          return {};
        };
        var findSegmentToFitCharacter = function(c) {
          var glyphWidth2 = that._getTextSize(c).width + letterSpacing;
          if (c === " " && align === "justify") {
            glyphWidth2 += (fullPathWidth - textFullWidth) / spacesNumber;
          }
          var currLen = 0;
          var attempts = 0;
          p1 = void 0;
          while (Math.abs(glyphWidth2 - currLen) / glyphWidth2 > 0.01 && attempts < 20) {
            attempts++;
            var cumulativePathLength = currLen;
            while (pathCmd === void 0) {
              pathCmd = getNextPathSegment();
              if (pathCmd && cumulativePathLength + pathCmd.pathLength < glyphWidth2) {
                cumulativePathLength += pathCmd.pathLength;
                pathCmd = void 0;
              }
            }
            if (Object.keys(pathCmd).length === 0 || p0 === void 0) {
              return void 0;
            }
            var needNewSegment = false;
            switch (pathCmd.command) {
              case "L":
                if (Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth2) {
                  p1 = Path.getPointOnLine(glyphWidth2, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);
                } else {
                  pathCmd = void 0;
                }
                break;
              case "A":
                var start = pathCmd.points[4];
                var dTheta = pathCmd.points[5];
                var end = pathCmd.points[4] + dTheta;
                if (currentT === 0) {
                  currentT = start + 1e-8;
                } else if (glyphWidth2 > currLen) {
                  currentT += Math.PI / 180 * dTheta / Math.abs(dTheta);
                } else {
                  currentT -= Math.PI / 360 * dTheta / Math.abs(dTheta);
                }
                if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {
                  currentT = end;
                  needNewSegment = true;
                }
                p1 = Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);
                break;
              case "C":
                if (currentT === 0) {
                  if (glyphWidth2 > pathCmd.pathLength) {
                    currentT = 1e-8;
                  } else {
                    currentT = glyphWidth2 / pathCmd.pathLength;
                  }
                } else if (glyphWidth2 > currLen) {
                  currentT += (glyphWidth2 - currLen) / pathCmd.pathLength / 2;
                } else {
                  currentT = Math.max(currentT - (currLen - glyphWidth2) / pathCmd.pathLength / 2, 0);
                }
                if (currentT > 1) {
                  currentT = 1;
                  needNewSegment = true;
                }
                p1 = Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);
                break;
              case "Q":
                if (currentT === 0) {
                  currentT = glyphWidth2 / pathCmd.pathLength;
                } else if (glyphWidth2 > currLen) {
                  currentT += (glyphWidth2 - currLen) / pathCmd.pathLength;
                } else {
                  currentT -= (currLen - glyphWidth2) / pathCmd.pathLength;
                }
                if (currentT > 1) {
                  currentT = 1;
                  needNewSegment = true;
                }
                p1 = Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);
                break;
            }
            if (p1 !== void 0) {
              currLen = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);
            }
            if (needNewSegment) {
              needNewSegment = false;
              pathCmd = void 0;
            }
          }
        };
        var testChar = "C";
        var glyphWidth = that._getTextSize(testChar).width + letterSpacing;
        var lettersInOffset = offset / glyphWidth - 1;
        for (var k = 0; k < lettersInOffset; k++) {
          findSegmentToFitCharacter(testChar);
          if (p0 === void 0 || p1 === void 0) {
            break;
          }
          p0 = p1;
        }
        for (var i2 = 0; i2 < charArr.length; i2++) {
          findSegmentToFitCharacter(charArr[i2]);
          if (p0 === void 0 || p1 === void 0) {
            break;
          }
          var width = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);
          var kern = 0;
          if (kerningFunc) {
            try {
              kern = kerningFunc(charArr[i2 - 1], charArr[i2]) * this.fontSize();
            } catch (e) {
              kern = 0;
            }
          }
          p0.x += kern;
          p1.x += kern;
          this.textWidth += kern;
          var midpoint = Path.getPointOnLine(kern + width / 2, p0.x, p0.y, p1.x, p1.y);
          var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);
          this.glyphInfo.push({
            transposeX: midpoint.x,
            transposeY: midpoint.y,
            text: charArr[i2],
            rotation,
            p0,
            p1
          });
          p0 = p1;
        }
      }
      getSelfRect() {
        if (!this.glyphInfo.length) {
          return {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
        var points = [];
        this.glyphInfo.forEach(function(info) {
          points.push(info.p0.x);
          points.push(info.p0.y);
          points.push(info.p1.x);
          points.push(info.p1.y);
        });
        var minX = points[0] || 0;
        var maxX = points[0] || 0;
        var minY = points[1] || 0;
        var maxY = points[1] || 0;
        var x, y;
        for (var i2 = 0; i2 < points.length / 2; i2++) {
          x = points[i2 * 2];
          y = points[i2 * 2 + 1];
          minX = Math.min(minX, x);
          maxX = Math.max(maxX, x);
          minY = Math.min(minY, y);
          maxY = Math.max(maxY, y);
        }
        var fontSize = this.fontSize();
        return {
          x: minX - fontSize / 2,
          y: minY - fontSize / 2,
          width: maxX - minX + fontSize,
          height: maxY - minY + fontSize
        };
      }
      destroy() {
        Util.releaseCanvas(this.dummyCanvas);
        return super.destroy();
      }
    }
    TextPath.prototype._fillFunc = _fillFunc;
    TextPath.prototype._strokeFunc = _strokeFunc;
    TextPath.prototype._fillFuncHit = _fillFunc;
    TextPath.prototype._strokeFuncHit = _strokeFunc;
    TextPath.prototype.className = "TextPath";
    TextPath.prototype._attrsAffectingSize = ["text", "fontSize", "data"];
    _registerNode(TextPath);
    Factory.addGetterSetter(TextPath, "data");
    Factory.addGetterSetter(TextPath, "fontFamily", "Arial");
    Factory.addGetterSetter(TextPath, "fontSize", 12, getNumberValidator());
    Factory.addGetterSetter(TextPath, "fontStyle", NORMAL);
    Factory.addGetterSetter(TextPath, "align", "left");
    Factory.addGetterSetter(TextPath, "letterSpacing", 0, getNumberValidator());
    Factory.addGetterSetter(TextPath, "textBaseline", "middle");
    Factory.addGetterSetter(TextPath, "fontVariant", NORMAL);
    Factory.addGetterSetter(TextPath, "text", EMPTY_STRING);
    Factory.addGetterSetter(TextPath, "textDecoration", null);
    Factory.addGetterSetter(TextPath, "kerningFunc", null);
    var EVENTS_NAME = "tr-konva";
    var ATTR_CHANGE_LIST = [
      "resizeEnabledChange",
      "rotateAnchorOffsetChange",
      "rotateEnabledChange",
      "enabledAnchorsChange",
      "anchorSizeChange",
      "borderEnabledChange",
      "borderStrokeChange",
      "borderStrokeWidthChange",
      "borderDashChange",
      "anchorStrokeChange",
      "anchorStrokeWidthChange",
      "anchorFillChange",
      "anchorCornerRadiusChange",
      "ignoreStrokeChange"
    ].map((e) => e + `.${EVENTS_NAME}`).join(" ");
    var NODES_RECT = "nodesRect";
    var TRANSFORM_CHANGE_STR = [
      "widthChange",
      "heightChange",
      "scaleXChange",
      "scaleYChange",
      "skewXChange",
      "skewYChange",
      "rotationChange",
      "offsetXChange",
      "offsetYChange",
      "transformsEnabledChange",
      "strokeWidthChange"
    ];
    var ANGLES = {
      "top-left": -45,
      "top-center": 0,
      "top-right": 45,
      "middle-right": -90,
      "middle-left": 90,
      "bottom-left": -135,
      "bottom-center": 180,
      "bottom-right": 135
    };
    const TOUCH_DEVICE = "ontouchstart" in Konva$2._global;
    function getCursor(anchorName, rad) {
      if (anchorName === "rotater") {
        return "crosshair";
      }
      rad += Util.degToRad(ANGLES[anchorName] || 0);
      var angle2 = (Util.radToDeg(rad) % 360 + 360) % 360;
      if (Util._inRange(angle2, 315 + 22.5, 360) || Util._inRange(angle2, 0, 22.5)) {
        return "ns-resize";
      } else if (Util._inRange(angle2, 45 - 22.5, 45 + 22.5)) {
        return "nesw-resize";
      } else if (Util._inRange(angle2, 90 - 22.5, 90 + 22.5)) {
        return "ew-resize";
      } else if (Util._inRange(angle2, 135 - 22.5, 135 + 22.5)) {
        return "nwse-resize";
      } else if (Util._inRange(angle2, 180 - 22.5, 180 + 22.5)) {
        return "ns-resize";
      } else if (Util._inRange(angle2, 225 - 22.5, 225 + 22.5)) {
        return "nesw-resize";
      } else if (Util._inRange(angle2, 270 - 22.5, 270 + 22.5)) {
        return "ew-resize";
      } else if (Util._inRange(angle2, 315 - 22.5, 315 + 22.5)) {
        return "nwse-resize";
      } else {
        Util.error("Transformer has unknown angle for cursor detection: " + angle2);
        return "pointer";
      }
    }
    var ANCHORS_NAMES = [
      "top-left",
      "top-center",
      "top-right",
      "middle-right",
      "middle-left",
      "bottom-left",
      "bottom-center",
      "bottom-right"
    ];
    var MAX_SAFE_INTEGER = 1e8;
    function getCenter(shape) {
      return {
        x: shape.x + shape.width / 2 * Math.cos(shape.rotation) + shape.height / 2 * Math.sin(-shape.rotation),
        y: shape.y + shape.height / 2 * Math.cos(shape.rotation) + shape.width / 2 * Math.sin(shape.rotation)
      };
    }
    function rotateAroundPoint(shape, angleRad, point) {
      const x = point.x + (shape.x - point.x) * Math.cos(angleRad) - (shape.y - point.y) * Math.sin(angleRad);
      const y = point.y + (shape.x - point.x) * Math.sin(angleRad) + (shape.y - point.y) * Math.cos(angleRad);
      return Object.assign(Object.assign({}, shape), {
        rotation: shape.rotation + angleRad,
        x,
        y
      });
    }
    function rotateAroundCenter(shape, deltaRad) {
      const center = getCenter(shape);
      return rotateAroundPoint(shape, deltaRad, center);
    }
    function getSnap(snaps, newRotationRad, tol) {
      let snapped = newRotationRad;
      for (let i2 = 0; i2 < snaps.length; i2++) {
        const angle2 = Konva$2.getAngle(snaps[i2]);
        const absDiff = Math.abs(angle2 - newRotationRad) % (Math.PI * 2);
        const dif = Math.min(absDiff, Math.PI * 2 - absDiff);
        if (dif < tol) {
          snapped = angle2;
        }
      }
      return snapped;
    }
    class Transformer extends Group {
      constructor(config2) {
        super(config2);
        this._transforming = false;
        this._createElements();
        this._handleMouseMove = this._handleMouseMove.bind(this);
        this._handleMouseUp = this._handleMouseUp.bind(this);
        this.update = this.update.bind(this);
        this.on(ATTR_CHANGE_LIST, this.update);
        if (this.getNode()) {
          this.update();
        }
      }
      attachTo(node) {
        this.setNode(node);
        return this;
      }
      setNode(node) {
        Util.warn("tr.setNode(shape), tr.node(shape) and tr.attachTo(shape) methods are deprecated. Please use tr.nodes(nodesArray) instead.");
        return this.setNodes([node]);
      }
      getNode() {
        return this._nodes && this._nodes[0];
      }
      _getEventNamespace() {
        return EVENTS_NAME + this._id;
      }
      setNodes(nodes = []) {
        if (this._nodes && this._nodes.length) {
          this.detach();
        }
        const filteredNodes = nodes.filter((node) => {
          if (node.isAncestorOf(this)) {
            Util.error("Konva.Transformer cannot be an a child of the node you are trying to attach");
            return false;
          }
          return true;
        });
        this._nodes = nodes = filteredNodes;
        if (nodes.length === 1 && this.useSingleNodeRotation()) {
          this.rotation(nodes[0].getAbsoluteRotation());
        } else {
          this.rotation(0);
        }
        this._nodes.forEach((node) => {
          const onChange = () => {
            if (this.nodes().length === 1 && this.useSingleNodeRotation()) {
              this.rotation(this.nodes()[0].getAbsoluteRotation());
            }
            this._resetTransformCache();
            if (!this._transforming && !this.isDragging()) {
              this.update();
            }
          };
          const additionalEvents = node._attrsAffectingSize.map((prop2) => prop2 + "Change." + this._getEventNamespace()).join(" ");
          node.on(additionalEvents, onChange);
          node.on(TRANSFORM_CHANGE_STR.map((e) => e + `.${this._getEventNamespace()}`).join(" "), onChange);
          node.on(`absoluteTransformChange.${this._getEventNamespace()}`, onChange);
          this._proxyDrag(node);
        });
        this._resetTransformCache();
        var elementsCreated = !!this.findOne(".top-left");
        if (elementsCreated) {
          this.update();
        }
        return this;
      }
      _proxyDrag(node) {
        let lastPos;
        node.on(`dragstart.${this._getEventNamespace()}`, (e) => {
          lastPos = node.getAbsolutePosition();
          if (!this.isDragging() && node !== this.findOne(".back")) {
            this.startDrag(e, false);
          }
        });
        node.on(`dragmove.${this._getEventNamespace()}`, (e) => {
          if (!lastPos) {
            return;
          }
          const abs = node.getAbsolutePosition();
          const dx = abs.x - lastPos.x;
          const dy = abs.y - lastPos.y;
          this.nodes().forEach((otherNode) => {
            if (otherNode === node) {
              return;
            }
            if (otherNode.isDragging()) {
              return;
            }
            const otherAbs = otherNode.getAbsolutePosition();
            otherNode.setAbsolutePosition({
              x: otherAbs.x + dx,
              y: otherAbs.y + dy
            });
            otherNode.startDrag(e);
          });
          lastPos = null;
        });
      }
      getNodes() {
        return this._nodes || [];
      }
      getActiveAnchor() {
        return this._movingAnchorName;
      }
      detach() {
        if (this._nodes) {
          this._nodes.forEach((node) => {
            node.off("." + this._getEventNamespace());
          });
        }
        this._nodes = [];
        this._resetTransformCache();
      }
      _resetTransformCache() {
        this._clearCache(NODES_RECT);
        this._clearCache("transform");
        this._clearSelfAndDescendantCache("absoluteTransform");
      }
      _getNodeRect() {
        return this._getCache(NODES_RECT, this.__getNodeRect);
      }
      __getNodeShape(node, rot = this.rotation(), relative) {
        var rect2 = node.getClientRect({
          skipTransform: true,
          skipShadow: true,
          skipStroke: this.ignoreStroke()
        });
        var absScale = node.getAbsoluteScale(relative);
        var absPos = node.getAbsolutePosition(relative);
        var dx = rect2.x * absScale.x - node.offsetX() * absScale.x;
        var dy = rect2.y * absScale.y - node.offsetY() * absScale.y;
        const rotation = (Konva$2.getAngle(node.getAbsoluteRotation()) + Math.PI * 2) % (Math.PI * 2);
        const box = {
          x: absPos.x + dx * Math.cos(rotation) + dy * Math.sin(-rotation),
          y: absPos.y + dy * Math.cos(rotation) + dx * Math.sin(rotation),
          width: rect2.width * absScale.x,
          height: rect2.height * absScale.y,
          rotation
        };
        return rotateAroundPoint(box, -Konva$2.getAngle(rot), {
          x: 0,
          y: 0
        });
      }
      __getNodeRect() {
        var node = this.getNode();
        if (!node) {
          return {
            x: -MAX_SAFE_INTEGER,
            y: -MAX_SAFE_INTEGER,
            width: 0,
            height: 0,
            rotation: 0
          };
        }
        const totalPoints = [];
        this.nodes().map((node2) => {
          const box = node2.getClientRect({
            skipTransform: true,
            skipShadow: true,
            skipStroke: this.ignoreStroke()
          });
          var points = [
            { x: box.x, y: box.y },
            { x: box.x + box.width, y: box.y },
            { x: box.x + box.width, y: box.y + box.height },
            { x: box.x, y: box.y + box.height }
          ];
          var trans = node2.getAbsoluteTransform();
          points.forEach(function(point) {
            var transformed = trans.point(point);
            totalPoints.push(transformed);
          });
        });
        const tr = new Transform();
        tr.rotate(-Konva$2.getAngle(this.rotation()));
        var minX, minY, maxX, maxY;
        totalPoints.forEach(function(point) {
          var transformed = tr.point(point);
          if (minX === void 0) {
            minX = maxX = transformed.x;
            minY = maxY = transformed.y;
          }
          minX = Math.min(minX, transformed.x);
          minY = Math.min(minY, transformed.y);
          maxX = Math.max(maxX, transformed.x);
          maxY = Math.max(maxY, transformed.y);
        });
        tr.invert();
        const p2 = tr.point({ x: minX, y: minY });
        return {
          x: p2.x,
          y: p2.y,
          width: maxX - minX,
          height: maxY - minY,
          rotation: Konva$2.getAngle(this.rotation())
        };
      }
      getX() {
        return this._getNodeRect().x;
      }
      getY() {
        return this._getNodeRect().y;
      }
      getWidth() {
        return this._getNodeRect().width;
      }
      getHeight() {
        return this._getNodeRect().height;
      }
      _createElements() {
        this._createBack();
        ANCHORS_NAMES.forEach((function(name) {
          this._createAnchor(name);
        }).bind(this));
        this._createAnchor("rotater");
      }
      _createAnchor(name) {
        var anchor = new Rect({
          stroke: "rgb(0, 161, 255)",
          fill: "white",
          strokeWidth: 1,
          name: name + " _anchor",
          dragDistance: 0,
          draggable: true,
          hitStrokeWidth: TOUCH_DEVICE ? 10 : "auto"
        });
        var self2 = this;
        anchor.on("mousedown touchstart", function(e) {
          self2._handleMouseDown(e);
        });
        anchor.on("dragstart", (e) => {
          anchor.stopDrag();
          e.cancelBubble = true;
        });
        anchor.on("dragend", (e) => {
          e.cancelBubble = true;
        });
        anchor.on("mouseenter", () => {
          var rad = Konva$2.getAngle(this.rotation());
          var cursor = getCursor(name, rad);
          anchor.getStage().content && (anchor.getStage().content.style.cursor = cursor);
          this._cursorChange = true;
        });
        anchor.on("mouseout", () => {
          anchor.getStage().content && (anchor.getStage().content.style.cursor = "");
          this._cursorChange = false;
        });
        this.add(anchor);
      }
      _createBack() {
        var back = new Shape({
          name: "back",
          width: 0,
          height: 0,
          draggable: true,
          sceneFunc(ctx) {
            var tr = this.getParent();
            var padding = tr.padding();
            ctx.beginPath();
            ctx.rect(-padding, -padding, this.width() + padding * 2, this.height() + padding * 2);
            ctx.moveTo(this.width() / 2, -padding);
            if (tr.rotateEnabled()) {
              ctx.lineTo(this.width() / 2, -tr.rotateAnchorOffset() * Util._sign(this.height()) - padding);
            }
            ctx.fillStrokeShape(this);
          },
          hitFunc: (ctx, shape) => {
            if (!this.shouldOverdrawWholeArea()) {
              return;
            }
            var padding = this.padding();
            ctx.beginPath();
            ctx.rect(-padding, -padding, shape.width() + padding * 2, shape.height() + padding * 2);
            ctx.fillStrokeShape(shape);
          }
        });
        this.add(back);
        this._proxyDrag(back);
        back.on("dragstart", (e) => {
          e.cancelBubble = true;
        });
        back.on("dragmove", (e) => {
          e.cancelBubble = true;
        });
        back.on("dragend", (e) => {
          e.cancelBubble = true;
        });
        this.on("dragmove", (e) => {
          this.update();
        });
      }
      _handleMouseDown(e) {
        this._movingAnchorName = e.target.name().split(" ")[0];
        var attrs = this._getNodeRect();
        var width = attrs.width;
        var height = attrs.height;
        var hypotenuse = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));
        this.sin = Math.abs(height / hypotenuse);
        this.cos = Math.abs(width / hypotenuse);
        if (typeof window !== "undefined") {
          window.addEventListener("mousemove", this._handleMouseMove);
          window.addEventListener("touchmove", this._handleMouseMove);
          window.addEventListener("mouseup", this._handleMouseUp, true);
          window.addEventListener("touchend", this._handleMouseUp, true);
        }
        this._transforming = true;
        var ap2 = e.target.getAbsolutePosition();
        var pos = e.target.getStage().getPointerPosition();
        this._anchorDragOffset = {
          x: pos.x - ap2.x,
          y: pos.y - ap2.y
        };
        this._fire("transformstart", { evt: e.evt, target: this.getNode() });
        this._nodes.forEach((target2) => {
          target2._fire("transformstart", { evt: e.evt, target: target2 });
        });
      }
      _handleMouseMove(e) {
        var x, y, newHypotenuse;
        var anchorNode = this.findOne("." + this._movingAnchorName);
        var stage = anchorNode.getStage();
        stage.setPointersPositions(e);
        const pp = stage.getPointerPosition();
        let newNodePos = {
          x: pp.x - this._anchorDragOffset.x,
          y: pp.y - this._anchorDragOffset.y
        };
        const oldAbs = anchorNode.getAbsolutePosition();
        if (this.anchorDragBoundFunc()) {
          newNodePos = this.anchorDragBoundFunc()(oldAbs, newNodePos, e);
        }
        anchorNode.setAbsolutePosition(newNodePos);
        const newAbs = anchorNode.getAbsolutePosition();
        if (oldAbs.x === newAbs.x && oldAbs.y === newAbs.y) {
          return;
        }
        if (this._movingAnchorName === "rotater") {
          var attrs = this._getNodeRect();
          x = anchorNode.x() - attrs.width / 2;
          y = -anchorNode.y() + attrs.height / 2;
          let delta2 = Math.atan2(-y, x) + Math.PI / 2;
          if (attrs.height < 0) {
            delta2 -= Math.PI;
          }
          var oldRotation = Konva$2.getAngle(this.rotation());
          const newRotation = oldRotation + delta2;
          const tol = Konva$2.getAngle(this.rotationSnapTolerance());
          const snappedRot = getSnap(this.rotationSnaps(), newRotation, tol);
          const diff = snappedRot - attrs.rotation;
          const shape = rotateAroundCenter(attrs, diff);
          this._fitNodesInto(shape, e);
          return;
        }
        var keepProportion = this.keepRatio() || e.shiftKey;
        var centeredScaling = this.centeredScaling() || e.altKey;
        if (this._movingAnchorName === "top-left") {
          if (keepProportion) {
            var comparePoint = centeredScaling ? {
              x: this.width() / 2,
              y: this.height() / 2
            } : {
              x: this.findOne(".bottom-right").x(),
              y: this.findOne(".bottom-right").y()
            };
            newHypotenuse = Math.sqrt(Math.pow(comparePoint.x - anchorNode.x(), 2) + Math.pow(comparePoint.y - anchorNode.y(), 2));
            var reverseX = this.findOne(".top-left").x() > comparePoint.x ? -1 : 1;
            var reverseY = this.findOne(".top-left").y() > comparePoint.y ? -1 : 1;
            x = newHypotenuse * this.cos * reverseX;
            y = newHypotenuse * this.sin * reverseY;
            this.findOne(".top-left").x(comparePoint.x - x);
            this.findOne(".top-left").y(comparePoint.y - y);
          }
        } else if (this._movingAnchorName === "top-center") {
          this.findOne(".top-left").y(anchorNode.y());
        } else if (this._movingAnchorName === "top-right") {
          if (keepProportion) {
            var comparePoint = centeredScaling ? {
              x: this.width() / 2,
              y: this.height() / 2
            } : {
              x: this.findOne(".bottom-left").x(),
              y: this.findOne(".bottom-left").y()
            };
            newHypotenuse = Math.sqrt(Math.pow(anchorNode.x() - comparePoint.x, 2) + Math.pow(comparePoint.y - anchorNode.y(), 2));
            var reverseX = this.findOne(".top-right").x() < comparePoint.x ? -1 : 1;
            var reverseY = this.findOne(".top-right").y() > comparePoint.y ? -1 : 1;
            x = newHypotenuse * this.cos * reverseX;
            y = newHypotenuse * this.sin * reverseY;
            this.findOne(".top-right").x(comparePoint.x + x);
            this.findOne(".top-right").y(comparePoint.y - y);
          }
          var pos = anchorNode.position();
          this.findOne(".top-left").y(pos.y);
          this.findOne(".bottom-right").x(pos.x);
        } else if (this._movingAnchorName === "middle-left") {
          this.findOne(".top-left").x(anchorNode.x());
        } else if (this._movingAnchorName === "middle-right") {
          this.findOne(".bottom-right").x(anchorNode.x());
        } else if (this._movingAnchorName === "bottom-left") {
          if (keepProportion) {
            var comparePoint = centeredScaling ? {
              x: this.width() / 2,
              y: this.height() / 2
            } : {
              x: this.findOne(".top-right").x(),
              y: this.findOne(".top-right").y()
            };
            newHypotenuse = Math.sqrt(Math.pow(comparePoint.x - anchorNode.x(), 2) + Math.pow(anchorNode.y() - comparePoint.y, 2));
            var reverseX = comparePoint.x < anchorNode.x() ? -1 : 1;
            var reverseY = anchorNode.y() < comparePoint.y ? -1 : 1;
            x = newHypotenuse * this.cos * reverseX;
            y = newHypotenuse * this.sin * reverseY;
            anchorNode.x(comparePoint.x - x);
            anchorNode.y(comparePoint.y + y);
          }
          pos = anchorNode.position();
          this.findOne(".top-left").x(pos.x);
          this.findOne(".bottom-right").y(pos.y);
        } else if (this._movingAnchorName === "bottom-center") {
          this.findOne(".bottom-right").y(anchorNode.y());
        } else if (this._movingAnchorName === "bottom-right") {
          if (keepProportion) {
            var comparePoint = centeredScaling ? {
              x: this.width() / 2,
              y: this.height() / 2
            } : {
              x: this.findOne(".top-left").x(),
              y: this.findOne(".top-left").y()
            };
            newHypotenuse = Math.sqrt(Math.pow(anchorNode.x() - comparePoint.x, 2) + Math.pow(anchorNode.y() - comparePoint.y, 2));
            var reverseX = this.findOne(".bottom-right").x() < comparePoint.x ? -1 : 1;
            var reverseY = this.findOne(".bottom-right").y() < comparePoint.y ? -1 : 1;
            x = newHypotenuse * this.cos * reverseX;
            y = newHypotenuse * this.sin * reverseY;
            this.findOne(".bottom-right").x(comparePoint.x + x);
            this.findOne(".bottom-right").y(comparePoint.y + y);
          }
        } else {
          console.error(new Error("Wrong position argument of selection resizer: " + this._movingAnchorName));
        }
        var centeredScaling = this.centeredScaling() || e.altKey;
        if (centeredScaling) {
          var topLeft = this.findOne(".top-left");
          var bottomRight = this.findOne(".bottom-right");
          var topOffsetX = topLeft.x();
          var topOffsetY = topLeft.y();
          var bottomOffsetX = this.getWidth() - bottomRight.x();
          var bottomOffsetY = this.getHeight() - bottomRight.y();
          bottomRight.move({
            x: -topOffsetX,
            y: -topOffsetY
          });
          topLeft.move({
            x: bottomOffsetX,
            y: bottomOffsetY
          });
        }
        var absPos = this.findOne(".top-left").getAbsolutePosition();
        x = absPos.x;
        y = absPos.y;
        var width = this.findOne(".bottom-right").x() - this.findOne(".top-left").x();
        var height = this.findOne(".bottom-right").y() - this.findOne(".top-left").y();
        this._fitNodesInto({
          x,
          y,
          width,
          height,
          rotation: Konva$2.getAngle(this.rotation())
        }, e);
      }
      _handleMouseUp(e) {
        this._removeEvents(e);
      }
      getAbsoluteTransform() {
        return this.getTransform();
      }
      _removeEvents(e) {
        if (this._transforming) {
          this._transforming = false;
          if (typeof window !== "undefined") {
            window.removeEventListener("mousemove", this._handleMouseMove);
            window.removeEventListener("touchmove", this._handleMouseMove);
            window.removeEventListener("mouseup", this._handleMouseUp, true);
            window.removeEventListener("touchend", this._handleMouseUp, true);
          }
          var node = this.getNode();
          this._fire("transformend", { evt: e, target: node });
          if (node) {
            this._nodes.forEach((target2) => {
              target2._fire("transformend", { evt: e, target: target2 });
            });
          }
          this._movingAnchorName = null;
        }
      }
      _fitNodesInto(newAttrs, evt) {
        var oldAttrs = this._getNodeRect();
        const minSize = 1;
        if (Util._inRange(newAttrs.width, -this.padding() * 2 - minSize, minSize)) {
          this.update();
          return;
        }
        if (Util._inRange(newAttrs.height, -this.padding() * 2 - minSize, minSize)) {
          this.update();
          return;
        }
        const allowNegativeScale = this.flipEnabled();
        var t = new Transform();
        t.rotate(Konva$2.getAngle(this.rotation()));
        if (this._movingAnchorName && newAttrs.width < 0 && this._movingAnchorName.indexOf("left") >= 0) {
          const offset = t.point({
            x: -this.padding() * 2,
            y: 0
          });
          newAttrs.x += offset.x;
          newAttrs.y += offset.y;
          newAttrs.width += this.padding() * 2;
          this._movingAnchorName = this._movingAnchorName.replace("left", "right");
          this._anchorDragOffset.x -= offset.x;
          this._anchorDragOffset.y -= offset.y;
          if (!allowNegativeScale) {
            this.update();
            return;
          }
        } else if (this._movingAnchorName && newAttrs.width < 0 && this._movingAnchorName.indexOf("right") >= 0) {
          const offset = t.point({
            x: this.padding() * 2,
            y: 0
          });
          this._movingAnchorName = this._movingAnchorName.replace("right", "left");
          this._anchorDragOffset.x -= offset.x;
          this._anchorDragOffset.y -= offset.y;
          newAttrs.width += this.padding() * 2;
          if (!allowNegativeScale) {
            this.update();
            return;
          }
        }
        if (this._movingAnchorName && newAttrs.height < 0 && this._movingAnchorName.indexOf("top") >= 0) {
          const offset = t.point({
            x: 0,
            y: -this.padding() * 2
          });
          newAttrs.x += offset.x;
          newAttrs.y += offset.y;
          this._movingAnchorName = this._movingAnchorName.replace("top", "bottom");
          this._anchorDragOffset.x -= offset.x;
          this._anchorDragOffset.y -= offset.y;
          newAttrs.height += this.padding() * 2;
          if (!allowNegativeScale) {
            this.update();
            return;
          }
        } else if (this._movingAnchorName && newAttrs.height < 0 && this._movingAnchorName.indexOf("bottom") >= 0) {
          const offset = t.point({
            x: 0,
            y: this.padding() * 2
          });
          this._movingAnchorName = this._movingAnchorName.replace("bottom", "top");
          this._anchorDragOffset.x -= offset.x;
          this._anchorDragOffset.y -= offset.y;
          newAttrs.height += this.padding() * 2;
          if (!allowNegativeScale) {
            this.update();
            return;
          }
        }
        if (this.boundBoxFunc()) {
          const bounded = this.boundBoxFunc()(oldAttrs, newAttrs);
          if (bounded) {
            newAttrs = bounded;
          } else {
            Util.warn("boundBoxFunc returned falsy. You should return new bound rect from it!");
          }
        }
        const baseSize = 1e7;
        const oldTr = new Transform();
        oldTr.translate(oldAttrs.x, oldAttrs.y);
        oldTr.rotate(oldAttrs.rotation);
        oldTr.scale(oldAttrs.width / baseSize, oldAttrs.height / baseSize);
        const newTr = new Transform();
        newTr.translate(newAttrs.x, newAttrs.y);
        newTr.rotate(newAttrs.rotation);
        newTr.scale(newAttrs.width / baseSize, newAttrs.height / baseSize);
        const delta2 = newTr.multiply(oldTr.invert());
        this._nodes.forEach((node) => {
          var _a2;
          const parentTransform = node.getParent().getAbsoluteTransform();
          const localTransform = node.getTransform().copy();
          localTransform.translate(node.offsetX(), node.offsetY());
          const newLocalTransform = new Transform();
          newLocalTransform.multiply(parentTransform.copy().invert()).multiply(delta2).multiply(parentTransform).multiply(localTransform);
          const attrs = newLocalTransform.decompose();
          node.setAttrs(attrs);
          this._fire("transform", { evt, target: node });
          node._fire("transform", { evt, target: node });
          (_a2 = node.getLayer()) === null || _a2 === void 0 ? void 0 : _a2.batchDraw();
        });
        this.rotation(Util._getRotation(newAttrs.rotation));
        this._resetTransformCache();
        this.update();
        this.getLayer().batchDraw();
      }
      forceUpdate() {
        this._resetTransformCache();
        this.update();
      }
      _batchChangeChild(selector, attrs) {
        const anchor = this.findOne(selector);
        anchor.setAttrs(attrs);
      }
      update() {
        var _a2;
        var attrs = this._getNodeRect();
        this.rotation(Util._getRotation(attrs.rotation));
        var width = attrs.width;
        var height = attrs.height;
        var enabledAnchors = this.enabledAnchors();
        var resizeEnabled = this.resizeEnabled();
        var padding = this.padding();
        var anchorSize = this.anchorSize();
        this.find("._anchor").forEach((node) => {
          node.setAttrs({
            width: anchorSize,
            height: anchorSize,
            offsetX: anchorSize / 2,
            offsetY: anchorSize / 2,
            stroke: this.anchorStroke(),
            strokeWidth: this.anchorStrokeWidth(),
            fill: this.anchorFill(),
            cornerRadius: this.anchorCornerRadius()
          });
        });
        this._batchChangeChild(".top-left", {
          x: 0,
          y: 0,
          offsetX: anchorSize / 2 + padding,
          offsetY: anchorSize / 2 + padding,
          visible: resizeEnabled && enabledAnchors.indexOf("top-left") >= 0
        });
        this._batchChangeChild(".top-center", {
          x: width / 2,
          y: 0,
          offsetY: anchorSize / 2 + padding,
          visible: resizeEnabled && enabledAnchors.indexOf("top-center") >= 0
        });
        this._batchChangeChild(".top-right", {
          x: width,
          y: 0,
          offsetX: anchorSize / 2 - padding,
          offsetY: anchorSize / 2 + padding,
          visible: resizeEnabled && enabledAnchors.indexOf("top-right") >= 0
        });
        this._batchChangeChild(".middle-left", {
          x: 0,
          y: height / 2,
          offsetX: anchorSize / 2 + padding,
          visible: resizeEnabled && enabledAnchors.indexOf("middle-left") >= 0
        });
        this._batchChangeChild(".middle-right", {
          x: width,
          y: height / 2,
          offsetX: anchorSize / 2 - padding,
          visible: resizeEnabled && enabledAnchors.indexOf("middle-right") >= 0
        });
        this._batchChangeChild(".bottom-left", {
          x: 0,
          y: height,
          offsetX: anchorSize / 2 + padding,
          offsetY: anchorSize / 2 - padding,
          visible: resizeEnabled && enabledAnchors.indexOf("bottom-left") >= 0
        });
        this._batchChangeChild(".bottom-center", {
          x: width / 2,
          y: height,
          offsetY: anchorSize / 2 - padding,
          visible: resizeEnabled && enabledAnchors.indexOf("bottom-center") >= 0
        });
        this._batchChangeChild(".bottom-right", {
          x: width,
          y: height,
          offsetX: anchorSize / 2 - padding,
          offsetY: anchorSize / 2 - padding,
          visible: resizeEnabled && enabledAnchors.indexOf("bottom-right") >= 0
        });
        this._batchChangeChild(".rotater", {
          x: width / 2,
          y: -this.rotateAnchorOffset() * Util._sign(height) - padding,
          visible: this.rotateEnabled()
        });
        this._batchChangeChild(".back", {
          width,
          height,
          visible: this.borderEnabled(),
          stroke: this.borderStroke(),
          strokeWidth: this.borderStrokeWidth(),
          dash: this.borderDash(),
          x: 0,
          y: 0
        });
        (_a2 = this.getLayer()) === null || _a2 === void 0 ? void 0 : _a2.batchDraw();
      }
      isTransforming() {
        return this._transforming;
      }
      stopTransform() {
        if (this._transforming) {
          this._removeEvents();
          var anchorNode = this.findOne("." + this._movingAnchorName);
          if (anchorNode) {
            anchorNode.stopDrag();
          }
        }
      }
      destroy() {
        if (this.getStage() && this._cursorChange) {
          this.getStage().content && (this.getStage().content.style.cursor = "");
        }
        Group.prototype.destroy.call(this);
        this.detach();
        this._removeEvents();
        return this;
      }
      toObject() {
        return Node$1.prototype.toObject.call(this);
      }
      clone(obj) {
        var node = Node$1.prototype.clone.call(this, obj);
        return node;
      }
      getClientRect() {
        if (this.nodes().length > 0) {
          return super.getClientRect();
        } else {
          return { x: 0, y: 0, width: 0, height: 0 };
        }
      }
    }
    function validateAnchors(val) {
      if (!(val instanceof Array)) {
        Util.warn("enabledAnchors value should be an array");
      }
      if (val instanceof Array) {
        val.forEach(function(name) {
          if (ANCHORS_NAMES.indexOf(name) === -1) {
            Util.warn("Unknown anchor name: " + name + ". Available names are: " + ANCHORS_NAMES.join(", "));
          }
        });
      }
      return val || [];
    }
    Transformer.prototype.className = "Transformer";
    _registerNode(Transformer);
    Factory.addGetterSetter(Transformer, "enabledAnchors", ANCHORS_NAMES, validateAnchors);
    Factory.addGetterSetter(Transformer, "flipEnabled", true, getBooleanValidator());
    Factory.addGetterSetter(Transformer, "resizeEnabled", true);
    Factory.addGetterSetter(Transformer, "anchorSize", 10, getNumberValidator());
    Factory.addGetterSetter(Transformer, "rotateEnabled", true);
    Factory.addGetterSetter(Transformer, "rotationSnaps", []);
    Factory.addGetterSetter(Transformer, "rotateAnchorOffset", 50, getNumberValidator());
    Factory.addGetterSetter(Transformer, "rotationSnapTolerance", 5, getNumberValidator());
    Factory.addGetterSetter(Transformer, "borderEnabled", true);
    Factory.addGetterSetter(Transformer, "anchorStroke", "rgb(0, 161, 255)");
    Factory.addGetterSetter(Transformer, "anchorStrokeWidth", 1, getNumberValidator());
    Factory.addGetterSetter(Transformer, "anchorFill", "white");
    Factory.addGetterSetter(Transformer, "anchorCornerRadius", 0, getNumberValidator());
    Factory.addGetterSetter(Transformer, "borderStroke", "rgb(0, 161, 255)");
    Factory.addGetterSetter(Transformer, "borderStrokeWidth", 1, getNumberValidator());
    Factory.addGetterSetter(Transformer, "borderDash");
    Factory.addGetterSetter(Transformer, "keepRatio", true);
    Factory.addGetterSetter(Transformer, "centeredScaling", false);
    Factory.addGetterSetter(Transformer, "ignoreStroke", false);
    Factory.addGetterSetter(Transformer, "padding", 0, getNumberValidator());
    Factory.addGetterSetter(Transformer, "node");
    Factory.addGetterSetter(Transformer, "nodes");
    Factory.addGetterSetter(Transformer, "boundBoxFunc");
    Factory.addGetterSetter(Transformer, "anchorDragBoundFunc");
    Factory.addGetterSetter(Transformer, "shouldOverdrawWholeArea", false);
    Factory.addGetterSetter(Transformer, "useSingleNodeRotation", true);
    Factory.backCompat(Transformer, {
      lineEnabled: "borderEnabled",
      rotateHandlerOffset: "rotateAnchorOffset",
      enabledHandlers: "enabledAnchors"
    });
    let Wedge$1 = class Wedge extends Shape {
      _sceneFunc(context) {
        context.beginPath();
        context.arc(0, 0, this.radius(), 0, Konva$2.getAngle(this.angle()), this.clockwise());
        context.lineTo(0, 0);
        context.closePath();
        context.fillStrokeShape(this);
      }
      getWidth() {
        return this.radius() * 2;
      }
      getHeight() {
        return this.radius() * 2;
      }
      setWidth(width) {
        this.radius(width / 2);
      }
      setHeight(height) {
        this.radius(height / 2);
      }
    };
    Wedge$1.prototype.className = "Wedge";
    Wedge$1.prototype._centroid = true;
    Wedge$1.prototype._attrsAffectingSize = ["radius"];
    _registerNode(Wedge$1);
    Factory.addGetterSetter(Wedge$1, "radius", 0, getNumberValidator());
    Factory.addGetterSetter(Wedge$1, "angle", 0, getNumberValidator());
    Factory.addGetterSetter(Wedge$1, "clockwise", false);
    Factory.backCompat(Wedge$1, {
      angleDeg: "angle",
      getAngleDeg: "getAngle",
      setAngleDeg: "setAngle"
    });
    function BlurStack() {
      this.r = 0;
      this.g = 0;
      this.b = 0;
      this.a = 0;
      this.next = null;
    }
    var mul_table = [
      512,
      512,
      456,
      512,
      328,
      456,
      335,
      512,
      405,
      328,
      271,
      456,
      388,
      335,
      292,
      512,
      454,
      405,
      364,
      328,
      298,
      271,
      496,
      456,
      420,
      388,
      360,
      335,
      312,
      292,
      273,
      512,
      482,
      454,
      428,
      405,
      383,
      364,
      345,
      328,
      312,
      298,
      284,
      271,
      259,
      496,
      475,
      456,
      437,
      420,
      404,
      388,
      374,
      360,
      347,
      335,
      323,
      312,
      302,
      292,
      282,
      273,
      265,
      512,
      497,
      482,
      468,
      454,
      441,
      428,
      417,
      405,
      394,
      383,
      373,
      364,
      354,
      345,
      337,
      328,
      320,
      312,
      305,
      298,
      291,
      284,
      278,
      271,
      265,
      259,
      507,
      496,
      485,
      475,
      465,
      456,
      446,
      437,
      428,
      420,
      412,
      404,
      396,
      388,
      381,
      374,
      367,
      360,
      354,
      347,
      341,
      335,
      329,
      323,
      318,
      312,
      307,
      302,
      297,
      292,
      287,
      282,
      278,
      273,
      269,
      265,
      261,
      512,
      505,
      497,
      489,
      482,
      475,
      468,
      461,
      454,
      447,
      441,
      435,
      428,
      422,
      417,
      411,
      405,
      399,
      394,
      389,
      383,
      378,
      373,
      368,
      364,
      359,
      354,
      350,
      345,
      341,
      337,
      332,
      328,
      324,
      320,
      316,
      312,
      309,
      305,
      301,
      298,
      294,
      291,
      287,
      284,
      281,
      278,
      274,
      271,
      268,
      265,
      262,
      259,
      257,
      507,
      501,
      496,
      491,
      485,
      480,
      475,
      470,
      465,
      460,
      456,
      451,
      446,
      442,
      437,
      433,
      428,
      424,
      420,
      416,
      412,
      408,
      404,
      400,
      396,
      392,
      388,
      385,
      381,
      377,
      374,
      370,
      367,
      363,
      360,
      357,
      354,
      350,
      347,
      344,
      341,
      338,
      335,
      332,
      329,
      326,
      323,
      320,
      318,
      315,
      312,
      310,
      307,
      304,
      302,
      299,
      297,
      294,
      292,
      289,
      287,
      285,
      282,
      280,
      278,
      275,
      273,
      271,
      269,
      267,
      265,
      263,
      261,
      259
    ];
    var shg_table = [
      9,
      11,
      12,
      13,
      13,
      14,
      14,
      15,
      15,
      15,
      15,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24
    ];
    function filterGaussBlurRGBA(imageData, radius) {
      var pixels = imageData.data, width = imageData.width, height = imageData.height;
      var x, y, i2, p2, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, r_out_sum, g_out_sum, b_out_sum, a_out_sum, r_in_sum, g_in_sum, b_in_sum, a_in_sum, pr2, pg, pb, pa, rbs;
      var div2 = radius + radius + 1, widthMinus1 = width - 1, heightMinus1 = height - 1, radiusPlus1 = radius + 1, sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2, stackStart = new BlurStack(), stackEnd = null, stack2 = stackStart, stackIn = null, stackOut = null, mul_sum = mul_table[radius], shg_sum = shg_table[radius];
      for (i2 = 1; i2 < div2; i2++) {
        stack2 = stack2.next = new BlurStack();
        if (i2 === radiusPlus1) {
          stackEnd = stack2;
        }
      }
      stack2.next = stackStart;
      yw = yi = 0;
      for (y = 0; y < height; y++) {
        r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
        r_out_sum = radiusPlus1 * (pr2 = pixels[yi]);
        g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
        b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
        a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
        r_sum += sumFactor * pr2;
        g_sum += sumFactor * pg;
        b_sum += sumFactor * pb;
        a_sum += sumFactor * pa;
        stack2 = stackStart;
        for (i2 = 0; i2 < radiusPlus1; i2++) {
          stack2.r = pr2;
          stack2.g = pg;
          stack2.b = pb;
          stack2.a = pa;
          stack2 = stack2.next;
        }
        for (i2 = 1; i2 < radiusPlus1; i2++) {
          p2 = yi + ((widthMinus1 < i2 ? widthMinus1 : i2) << 2);
          r_sum += (stack2.r = pr2 = pixels[p2]) * (rbs = radiusPlus1 - i2);
          g_sum += (stack2.g = pg = pixels[p2 + 1]) * rbs;
          b_sum += (stack2.b = pb = pixels[p2 + 2]) * rbs;
          a_sum += (stack2.a = pa = pixels[p2 + 3]) * rbs;
          r_in_sum += pr2;
          g_in_sum += pg;
          b_in_sum += pb;
          a_in_sum += pa;
          stack2 = stack2.next;
        }
        stackIn = stackStart;
        stackOut = stackEnd;
        for (x = 0; x < width; x++) {
          pixels[yi + 3] = pa = a_sum * mul_sum >> shg_sum;
          if (pa !== 0) {
            pa = 255 / pa;
            pixels[yi] = (r_sum * mul_sum >> shg_sum) * pa;
            pixels[yi + 1] = (g_sum * mul_sum >> shg_sum) * pa;
            pixels[yi + 2] = (b_sum * mul_sum >> shg_sum) * pa;
          } else {
            pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
          }
          r_sum -= r_out_sum;
          g_sum -= g_out_sum;
          b_sum -= b_out_sum;
          a_sum -= a_out_sum;
          r_out_sum -= stackIn.r;
          g_out_sum -= stackIn.g;
          b_out_sum -= stackIn.b;
          a_out_sum -= stackIn.a;
          p2 = yw + ((p2 = x + radius + 1) < widthMinus1 ? p2 : widthMinus1) << 2;
          r_in_sum += stackIn.r = pixels[p2];
          g_in_sum += stackIn.g = pixels[p2 + 1];
          b_in_sum += stackIn.b = pixels[p2 + 2];
          a_in_sum += stackIn.a = pixels[p2 + 3];
          r_sum += r_in_sum;
          g_sum += g_in_sum;
          b_sum += b_in_sum;
          a_sum += a_in_sum;
          stackIn = stackIn.next;
          r_out_sum += pr2 = stackOut.r;
          g_out_sum += pg = stackOut.g;
          b_out_sum += pb = stackOut.b;
          a_out_sum += pa = stackOut.a;
          r_in_sum -= pr2;
          g_in_sum -= pg;
          b_in_sum -= pb;
          a_in_sum -= pa;
          stackOut = stackOut.next;
          yi += 4;
        }
        yw += width;
      }
      for (x = 0; x < width; x++) {
        g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
        yi = x << 2;
        r_out_sum = radiusPlus1 * (pr2 = pixels[yi]);
        g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
        b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
        a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
        r_sum += sumFactor * pr2;
        g_sum += sumFactor * pg;
        b_sum += sumFactor * pb;
        a_sum += sumFactor * pa;
        stack2 = stackStart;
        for (i2 = 0; i2 < radiusPlus1; i2++) {
          stack2.r = pr2;
          stack2.g = pg;
          stack2.b = pb;
          stack2.a = pa;
          stack2 = stack2.next;
        }
        yp = width;
        for (i2 = 1; i2 <= radius; i2++) {
          yi = yp + x << 2;
          r_sum += (stack2.r = pr2 = pixels[yi]) * (rbs = radiusPlus1 - i2);
          g_sum += (stack2.g = pg = pixels[yi + 1]) * rbs;
          b_sum += (stack2.b = pb = pixels[yi + 2]) * rbs;
          a_sum += (stack2.a = pa = pixels[yi + 3]) * rbs;
          r_in_sum += pr2;
          g_in_sum += pg;
          b_in_sum += pb;
          a_in_sum += pa;
          stack2 = stack2.next;
          if (i2 < heightMinus1) {
            yp += width;
          }
        }
        yi = x;
        stackIn = stackStart;
        stackOut = stackEnd;
        for (y = 0; y < height; y++) {
          p2 = yi << 2;
          pixels[p2 + 3] = pa = a_sum * mul_sum >> shg_sum;
          if (pa > 0) {
            pa = 255 / pa;
            pixels[p2] = (r_sum * mul_sum >> shg_sum) * pa;
            pixels[p2 + 1] = (g_sum * mul_sum >> shg_sum) * pa;
            pixels[p2 + 2] = (b_sum * mul_sum >> shg_sum) * pa;
          } else {
            pixels[p2] = pixels[p2 + 1] = pixels[p2 + 2] = 0;
          }
          r_sum -= r_out_sum;
          g_sum -= g_out_sum;
          b_sum -= b_out_sum;
          a_sum -= a_out_sum;
          r_out_sum -= stackIn.r;
          g_out_sum -= stackIn.g;
          b_out_sum -= stackIn.b;
          a_out_sum -= stackIn.a;
          p2 = x + ((p2 = y + radiusPlus1) < heightMinus1 ? p2 : heightMinus1) * width << 2;
          r_sum += r_in_sum += stackIn.r = pixels[p2];
          g_sum += g_in_sum += stackIn.g = pixels[p2 + 1];
          b_sum += b_in_sum += stackIn.b = pixels[p2 + 2];
          a_sum += a_in_sum += stackIn.a = pixels[p2 + 3];
          stackIn = stackIn.next;
          r_out_sum += pr2 = stackOut.r;
          g_out_sum += pg = stackOut.g;
          b_out_sum += pb = stackOut.b;
          a_out_sum += pa = stackOut.a;
          r_in_sum -= pr2;
          g_in_sum -= pg;
          b_in_sum -= pb;
          a_in_sum -= pa;
          stackOut = stackOut.next;
          yi += width;
        }
      }
    }
    const Blur = function Blur2(imageData) {
      var radius = Math.round(this.blurRadius());
      if (radius > 0) {
        filterGaussBlurRGBA(imageData, radius);
      }
    };
    Factory.addGetterSetter(Node$1, "blurRadius", 0, getNumberValidator(), Factory.afterSetFilter);
    const Brighten = function(imageData) {
      var brightness = this.brightness() * 255, data = imageData.data, len = data.length, i2;
      for (i2 = 0; i2 < len; i2 += 4) {
        data[i2] += brightness;
        data[i2 + 1] += brightness;
        data[i2 + 2] += brightness;
      }
    };
    Factory.addGetterSetter(Node$1, "brightness", 0, getNumberValidator(), Factory.afterSetFilter);
    const Contrast = function(imageData) {
      var adjust = Math.pow((this.contrast() + 100) / 100, 2);
      var data = imageData.data, nPixels = data.length, red2 = 150, green2 = 150, blue2 = 150, i2;
      for (i2 = 0; i2 < nPixels; i2 += 4) {
        red2 = data[i2];
        green2 = data[i2 + 1];
        blue2 = data[i2 + 2];
        red2 /= 255;
        red2 -= 0.5;
        red2 *= adjust;
        red2 += 0.5;
        red2 *= 255;
        green2 /= 255;
        green2 -= 0.5;
        green2 *= adjust;
        green2 += 0.5;
        green2 *= 255;
        blue2 /= 255;
        blue2 -= 0.5;
        blue2 *= adjust;
        blue2 += 0.5;
        blue2 *= 255;
        red2 = red2 < 0 ? 0 : red2 > 255 ? 255 : red2;
        green2 = green2 < 0 ? 0 : green2 > 255 ? 255 : green2;
        blue2 = blue2 < 0 ? 0 : blue2 > 255 ? 255 : blue2;
        data[i2] = red2;
        data[i2 + 1] = green2;
        data[i2 + 2] = blue2;
      }
    };
    Factory.addGetterSetter(Node$1, "contrast", 0, getNumberValidator(), Factory.afterSetFilter);
    const Emboss = function(imageData) {
      var strength = this.embossStrength() * 10, greyLevel = this.embossWhiteLevel() * 255, direction = this.embossDirection(), blend = this.embossBlend(), dirY = 0, dirX = 0, data = imageData.data, w = imageData.width, h2 = imageData.height, w4 = w * 4, y = h2;
      switch (direction) {
        case "top-left":
          dirY = -1;
          dirX = -1;
          break;
        case "top":
          dirY = -1;
          dirX = 0;
          break;
        case "top-right":
          dirY = -1;
          dirX = 1;
          break;
        case "right":
          dirY = 0;
          dirX = 1;
          break;
        case "bottom-right":
          dirY = 1;
          dirX = 1;
          break;
        case "bottom":
          dirY = 1;
          dirX = 0;
          break;
        case "bottom-left":
          dirY = 1;
          dirX = -1;
          break;
        case "left":
          dirY = 0;
          dirX = -1;
          break;
        default:
          Util.error("Unknown emboss direction: " + direction);
      }
      do {
        var offsetY = (y - 1) * w4;
        var otherY = dirY;
        if (y + otherY < 1) {
          otherY = 0;
        }
        if (y + otherY > h2) {
          otherY = 0;
        }
        var offsetYOther = (y - 1 + otherY) * w * 4;
        var x = w;
        do {
          var offset = offsetY + (x - 1) * 4;
          var otherX = dirX;
          if (x + otherX < 1) {
            otherX = 0;
          }
          if (x + otherX > w) {
            otherX = 0;
          }
          var offsetOther = offsetYOther + (x - 1 + otherX) * 4;
          var dR = data[offset] - data[offsetOther];
          var dG = data[offset + 1] - data[offsetOther + 1];
          var dB = data[offset + 2] - data[offsetOther + 2];
          var dif = dR;
          var absDif = dif > 0 ? dif : -dif;
          var absG = dG > 0 ? dG : -dG;
          var absB = dB > 0 ? dB : -dB;
          if (absG > absDif) {
            dif = dG;
          }
          if (absB > absDif) {
            dif = dB;
          }
          dif *= strength;
          if (blend) {
            var r = data[offset] + dif;
            var g = data[offset + 1] + dif;
            var b = data[offset + 2] + dif;
            data[offset] = r > 255 ? 255 : r < 0 ? 0 : r;
            data[offset + 1] = g > 255 ? 255 : g < 0 ? 0 : g;
            data[offset + 2] = b > 255 ? 255 : b < 0 ? 0 : b;
          } else {
            var grey2 = greyLevel - dif;
            if (grey2 < 0) {
              grey2 = 0;
            } else if (grey2 > 255) {
              grey2 = 255;
            }
            data[offset] = data[offset + 1] = data[offset + 2] = grey2;
          }
        } while (--x);
      } while (--y);
    };
    Factory.addGetterSetter(Node$1, "embossStrength", 0.5, getNumberValidator(), Factory.afterSetFilter);
    Factory.addGetterSetter(Node$1, "embossWhiteLevel", 0.5, getNumberValidator(), Factory.afterSetFilter);
    Factory.addGetterSetter(Node$1, "embossDirection", "top-left", null, Factory.afterSetFilter);
    Factory.addGetterSetter(Node$1, "embossBlend", false, null, Factory.afterSetFilter);
    function remap(fromValue, fromMin, fromMax, toMin, toMax) {
      var fromRange = fromMax - fromMin, toRange = toMax - toMin, toValue2;
      if (fromRange === 0) {
        return toMin + toRange / 2;
      }
      if (toRange === 0) {
        return toMin;
      }
      toValue2 = (fromValue - fromMin) / fromRange;
      toValue2 = toRange * toValue2 + toMin;
      return toValue2;
    }
    const Enhance = function(imageData) {
      var data = imageData.data, nSubPixels = data.length, rMin = data[0], rMax = rMin, r, gMin = data[1], gMax = gMin, g, bMin = data[2], bMax = bMin, b, i2;
      var enhanceAmount = this.enhance();
      if (enhanceAmount === 0) {
        return;
      }
      for (i2 = 0; i2 < nSubPixels; i2 += 4) {
        r = data[i2 + 0];
        if (r < rMin) {
          rMin = r;
        } else if (r > rMax) {
          rMax = r;
        }
        g = data[i2 + 1];
        if (g < gMin) {
          gMin = g;
        } else if (g > gMax) {
          gMax = g;
        }
        b = data[i2 + 2];
        if (b < bMin) {
          bMin = b;
        } else if (b > bMax) {
          bMax = b;
        }
      }
      if (rMax === rMin) {
        rMax = 255;
        rMin = 0;
      }
      if (gMax === gMin) {
        gMax = 255;
        gMin = 0;
      }
      if (bMax === bMin) {
        bMax = 255;
        bMin = 0;
      }
      var rMid, rGoalMax, rGoalMin, gMid, gGoalMax, gGoalMin, bMid, bGoalMax, bGoalMin;
      if (enhanceAmount > 0) {
        rGoalMax = rMax + enhanceAmount * (255 - rMax);
        rGoalMin = rMin - enhanceAmount * (rMin - 0);
        gGoalMax = gMax + enhanceAmount * (255 - gMax);
        gGoalMin = gMin - enhanceAmount * (gMin - 0);
        bGoalMax = bMax + enhanceAmount * (255 - bMax);
        bGoalMin = bMin - enhanceAmount * (bMin - 0);
      } else {
        rMid = (rMax + rMin) * 0.5;
        rGoalMax = rMax + enhanceAmount * (rMax - rMid);
        rGoalMin = rMin + enhanceAmount * (rMin - rMid);
        gMid = (gMax + gMin) * 0.5;
        gGoalMax = gMax + enhanceAmount * (gMax - gMid);
        gGoalMin = gMin + enhanceAmount * (gMin - gMid);
        bMid = (bMax + bMin) * 0.5;
        bGoalMax = bMax + enhanceAmount * (bMax - bMid);
        bGoalMin = bMin + enhanceAmount * (bMin - bMid);
      }
      for (i2 = 0; i2 < nSubPixels; i2 += 4) {
        data[i2 + 0] = remap(data[i2 + 0], rMin, rMax, rGoalMin, rGoalMax);
        data[i2 + 1] = remap(data[i2 + 1], gMin, gMax, gGoalMin, gGoalMax);
        data[i2 + 2] = remap(data[i2 + 2], bMin, bMax, bGoalMin, bGoalMax);
      }
    };
    Factory.addGetterSetter(Node$1, "enhance", 0, getNumberValidator(), Factory.afterSetFilter);
    const Grayscale = function(imageData) {
      var data = imageData.data, len = data.length, i2, brightness;
      for (i2 = 0; i2 < len; i2 += 4) {
        brightness = 0.34 * data[i2] + 0.5 * data[i2 + 1] + 0.16 * data[i2 + 2];
        data[i2] = brightness;
        data[i2 + 1] = brightness;
        data[i2 + 2] = brightness;
      }
    };
    Factory.addGetterSetter(Node$1, "hue", 0, getNumberValidator(), Factory.afterSetFilter);
    Factory.addGetterSetter(Node$1, "saturation", 0, getNumberValidator(), Factory.afterSetFilter);
    Factory.addGetterSetter(Node$1, "luminance", 0, getNumberValidator(), Factory.afterSetFilter);
    const HSL = function(imageData) {
      var data = imageData.data, nPixels = data.length, v = 1, s = Math.pow(2, this.saturation()), h2 = Math.abs(this.hue() + 360) % 360, l = this.luminance() * 127, i2;
      var vsu = v * s * Math.cos(h2 * Math.PI / 180), vsw = v * s * Math.sin(h2 * Math.PI / 180);
      var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw, rg = 0.587 * v - 0.587 * vsu + 0.33 * vsw, rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
      var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw, gg2 = 0.587 * v + 0.413 * vsu + 0.035 * vsw, gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
      var br = 0.299 * v - 0.3 * vsu + 1.25 * vsw, bg = 0.587 * v - 0.586 * vsu - 1.05 * vsw, bb = 0.114 * v + 0.886 * vsu - 0.2 * vsw;
      var r, g, b, a;
      for (i2 = 0; i2 < nPixels; i2 += 4) {
        r = data[i2 + 0];
        g = data[i2 + 1];
        b = data[i2 + 2];
        a = data[i2 + 3];
        data[i2 + 0] = rr * r + rg * g + rb * b + l;
        data[i2 + 1] = gr * r + gg2 * g + gb * b + l;
        data[i2 + 2] = br * r + bg * g + bb * b + l;
        data[i2 + 3] = a;
      }
    };
    const HSV = function(imageData) {
      var data = imageData.data, nPixels = data.length, v = Math.pow(2, this.value()), s = Math.pow(2, this.saturation()), h2 = Math.abs(this.hue() + 360) % 360, i2;
      var vsu = v * s * Math.cos(h2 * Math.PI / 180), vsw = v * s * Math.sin(h2 * Math.PI / 180);
      var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw, rg = 0.587 * v - 0.587 * vsu + 0.33 * vsw, rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
      var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw, gg2 = 0.587 * v + 0.413 * vsu + 0.035 * vsw, gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
      var br = 0.299 * v - 0.3 * vsu + 1.25 * vsw, bg = 0.587 * v - 0.586 * vsu - 1.05 * vsw, bb = 0.114 * v + 0.886 * vsu - 0.2 * vsw;
      var r, g, b, a;
      for (i2 = 0; i2 < nPixels; i2 += 4) {
        r = data[i2 + 0];
        g = data[i2 + 1];
        b = data[i2 + 2];
        a = data[i2 + 3];
        data[i2 + 0] = rr * r + rg * g + rb * b;
        data[i2 + 1] = gr * r + gg2 * g + gb * b;
        data[i2 + 2] = br * r + bg * g + bb * b;
        data[i2 + 3] = a;
      }
    };
    Factory.addGetterSetter(Node$1, "hue", 0, getNumberValidator(), Factory.afterSetFilter);
    Factory.addGetterSetter(Node$1, "saturation", 0, getNumberValidator(), Factory.afterSetFilter);
    Factory.addGetterSetter(Node$1, "value", 0, getNumberValidator(), Factory.afterSetFilter);
    const Invert = function(imageData) {
      var data = imageData.data, len = data.length, i2;
      for (i2 = 0; i2 < len; i2 += 4) {
        data[i2] = 255 - data[i2];
        data[i2 + 1] = 255 - data[i2 + 1];
        data[i2 + 2] = 255 - data[i2 + 2];
      }
    };
    var ToPolar = function(src, dst, opt) {
      var srcPixels = src.data, dstPixels = dst.data, xSize = src.width, ySize = src.height, xMid = opt.polarCenterX || xSize / 2, yMid = opt.polarCenterY || ySize / 2, i2, x, y, r = 0, g = 0, b = 0, a = 0;
      var rad, rMax = Math.sqrt(xMid * xMid + yMid * yMid);
      x = xSize - xMid;
      y = ySize - yMid;
      rad = Math.sqrt(x * x + y * y);
      rMax = rad > rMax ? rad : rMax;
      var rSize = ySize, tSize = xSize, radius, theta2;
      var conversion = 360 / tSize * Math.PI / 180, sin, cos;
      for (theta2 = 0; theta2 < tSize; theta2 += 1) {
        sin = Math.sin(theta2 * conversion);
        cos = Math.cos(theta2 * conversion);
        for (radius = 0; radius < rSize; radius += 1) {
          x = Math.floor(xMid + rMax * radius / rSize * cos);
          y = Math.floor(yMid + rMax * radius / rSize * sin);
          i2 = (y * xSize + x) * 4;
          r = srcPixels[i2 + 0];
          g = srcPixels[i2 + 1];
          b = srcPixels[i2 + 2];
          a = srcPixels[i2 + 3];
          i2 = (theta2 + radius * xSize) * 4;
          dstPixels[i2 + 0] = r;
          dstPixels[i2 + 1] = g;
          dstPixels[i2 + 2] = b;
          dstPixels[i2 + 3] = a;
        }
      }
    };
    var FromPolar = function(src, dst, opt) {
      var srcPixels = src.data, dstPixels = dst.data, xSize = src.width, ySize = src.height, xMid = opt.polarCenterX || xSize / 2, yMid = opt.polarCenterY || ySize / 2, i2, x, y, dx, dy, r = 0, g = 0, b = 0, a = 0;
      var rad, rMax = Math.sqrt(xMid * xMid + yMid * yMid);
      x = xSize - xMid;
      y = ySize - yMid;
      rad = Math.sqrt(x * x + y * y);
      rMax = rad > rMax ? rad : rMax;
      var rSize = ySize, tSize = xSize, radius, theta2, phaseShift = opt.polarRotation || 0;
      var x1, y1;
      for (x = 0; x < xSize; x += 1) {
        for (y = 0; y < ySize; y += 1) {
          dx = x - xMid;
          dy = y - yMid;
          radius = Math.sqrt(dx * dx + dy * dy) * rSize / rMax;
          theta2 = (Math.atan2(dy, dx) * 180 / Math.PI + 360 + phaseShift) % 360;
          theta2 = theta2 * tSize / 360;
          x1 = Math.floor(theta2);
          y1 = Math.floor(radius);
          i2 = (y1 * xSize + x1) * 4;
          r = srcPixels[i2 + 0];
          g = srcPixels[i2 + 1];
          b = srcPixels[i2 + 2];
          a = srcPixels[i2 + 3];
          i2 = (y * xSize + x) * 4;
          dstPixels[i2 + 0] = r;
          dstPixels[i2 + 1] = g;
          dstPixels[i2 + 2] = b;
          dstPixels[i2 + 3] = a;
        }
      }
    };
    const Kaleidoscope = function(imageData) {
      var xSize = imageData.width, ySize = imageData.height;
      var x, y, xoff, i2, r, g, b, a, srcPos, dstPos;
      var power = Math.round(this.kaleidoscopePower());
      var angle2 = Math.round(this.kaleidoscopeAngle());
      var offset = Math.floor(xSize * (angle2 % 360) / 360);
      if (power < 1) {
        return;
      }
      var tempCanvas = Util.createCanvasElement();
      tempCanvas.width = xSize;
      tempCanvas.height = ySize;
      var scratchData = tempCanvas.getContext("2d").getImageData(0, 0, xSize, ySize);
      Util.releaseCanvas(tempCanvas);
      ToPolar(imageData, scratchData, {
        polarCenterX: xSize / 2,
        polarCenterY: ySize / 2
      });
      var minSectionSize = xSize / Math.pow(2, power);
      while (minSectionSize <= 8) {
        minSectionSize = minSectionSize * 2;
        power -= 1;
      }
      minSectionSize = Math.ceil(minSectionSize);
      var sectionSize = minSectionSize;
      var xStart = 0, xEnd = sectionSize, xDelta = 1;
      if (offset + minSectionSize > xSize) {
        xStart = sectionSize;
        xEnd = 0;
        xDelta = -1;
      }
      for (y = 0; y < ySize; y += 1) {
        for (x = xStart; x !== xEnd; x += xDelta) {
          xoff = Math.round(x + offset) % xSize;
          srcPos = (xSize * y + xoff) * 4;
          r = scratchData.data[srcPos + 0];
          g = scratchData.data[srcPos + 1];
          b = scratchData.data[srcPos + 2];
          a = scratchData.data[srcPos + 3];
          dstPos = (xSize * y + x) * 4;
          scratchData.data[dstPos + 0] = r;
          scratchData.data[dstPos + 1] = g;
          scratchData.data[dstPos + 2] = b;
          scratchData.data[dstPos + 3] = a;
        }
      }
      for (y = 0; y < ySize; y += 1) {
        sectionSize = Math.floor(minSectionSize);
        for (i2 = 0; i2 < power; i2 += 1) {
          for (x = 0; x < sectionSize + 1; x += 1) {
            srcPos = (xSize * y + x) * 4;
            r = scratchData.data[srcPos + 0];
            g = scratchData.data[srcPos + 1];
            b = scratchData.data[srcPos + 2];
            a = scratchData.data[srcPos + 3];
            dstPos = (xSize * y + sectionSize * 2 - x - 1) * 4;
            scratchData.data[dstPos + 0] = r;
            scratchData.data[dstPos + 1] = g;
            scratchData.data[dstPos + 2] = b;
            scratchData.data[dstPos + 3] = a;
          }
          sectionSize *= 2;
        }
      }
      FromPolar(scratchData, imageData, { polarRotation: 0 });
    };
    Factory.addGetterSetter(Node$1, "kaleidoscopePower", 2, getNumberValidator(), Factory.afterSetFilter);
    Factory.addGetterSetter(Node$1, "kaleidoscopeAngle", 0, getNumberValidator(), Factory.afterSetFilter);
    function pixelAt(idata, x, y) {
      var idx = (y * idata.width + x) * 4;
      var d = [];
      d.push(idata.data[idx++], idata.data[idx++], idata.data[idx++], idata.data[idx++]);
      return d;
    }
    function rgbDistance(p1, p2) {
      return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2) + Math.pow(p1[2] - p2[2], 2));
    }
    function rgbMean(pTab) {
      var m = [0, 0, 0];
      for (var i2 = 0; i2 < pTab.length; i2++) {
        m[0] += pTab[i2][0];
        m[1] += pTab[i2][1];
        m[2] += pTab[i2][2];
      }
      m[0] /= pTab.length;
      m[1] /= pTab.length;
      m[2] /= pTab.length;
      return m;
    }
    function backgroundMask(idata, threshold) {
      var rgbv_no = pixelAt(idata, 0, 0);
      var rgbv_ne = pixelAt(idata, idata.width - 1, 0);
      var rgbv_so = pixelAt(idata, 0, idata.height - 1);
      var rgbv_se = pixelAt(idata, idata.width - 1, idata.height - 1);
      var thres = threshold || 10;
      if (rgbDistance(rgbv_no, rgbv_ne) < thres && rgbDistance(rgbv_ne, rgbv_se) < thres && rgbDistance(rgbv_se, rgbv_so) < thres && rgbDistance(rgbv_so, rgbv_no) < thres) {
        var mean = rgbMean([rgbv_ne, rgbv_no, rgbv_se, rgbv_so]);
        var mask = [];
        for (var i2 = 0; i2 < idata.width * idata.height; i2++) {
          var d = rgbDistance(mean, [
            idata.data[i2 * 4],
            idata.data[i2 * 4 + 1],
            idata.data[i2 * 4 + 2]
          ]);
          mask[i2] = d < thres ? 0 : 255;
        }
        return mask;
      }
    }
    function applyMask(idata, mask) {
      for (var i2 = 0; i2 < idata.width * idata.height; i2++) {
        idata.data[4 * i2 + 3] = mask[i2];
      }
    }
    function erodeMask(mask, sw, sh) {
      var weights = [1, 1, 1, 1, 0, 1, 1, 1, 1];
      var side = Math.round(Math.sqrt(weights.length));
      var halfSide = Math.floor(side / 2);
      var maskResult = [];
      for (var y = 0; y < sh; y++) {
        for (var x = 0; x < sw; x++) {
          var so = y * sw + x;
          var a = 0;
          for (var cy = 0; cy < side; cy++) {
            for (var cx = 0; cx < side; cx++) {
              var scy2 = y + cy - halfSide;
              var scx = x + cx - halfSide;
              if (scy2 >= 0 && scy2 < sh && scx >= 0 && scx < sw) {
                var srcOff = scy2 * sw + scx;
                var wt = weights[cy * side + cx];
                a += mask[srcOff] * wt;
              }
            }
          }
          maskResult[so] = a === 255 * 8 ? 255 : 0;
        }
      }
      return maskResult;
    }
    function dilateMask(mask, sw, sh) {
      var weights = [1, 1, 1, 1, 1, 1, 1, 1, 1];
      var side = Math.round(Math.sqrt(weights.length));
      var halfSide = Math.floor(side / 2);
      var maskResult = [];
      for (var y = 0; y < sh; y++) {
        for (var x = 0; x < sw; x++) {
          var so = y * sw + x;
          var a = 0;
          for (var cy = 0; cy < side; cy++) {
            for (var cx = 0; cx < side; cx++) {
              var scy2 = y + cy - halfSide;
              var scx = x + cx - halfSide;
              if (scy2 >= 0 && scy2 < sh && scx >= 0 && scx < sw) {
                var srcOff = scy2 * sw + scx;
                var wt = weights[cy * side + cx];
                a += mask[srcOff] * wt;
              }
            }
          }
          maskResult[so] = a >= 255 * 4 ? 255 : 0;
        }
      }
      return maskResult;
    }
    function smoothEdgeMask(mask, sw, sh) {
      var weights = [1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9];
      var side = Math.round(Math.sqrt(weights.length));
      var halfSide = Math.floor(side / 2);
      var maskResult = [];
      for (var y = 0; y < sh; y++) {
        for (var x = 0; x < sw; x++) {
          var so = y * sw + x;
          var a = 0;
          for (var cy = 0; cy < side; cy++) {
            for (var cx = 0; cx < side; cx++) {
              var scy2 = y + cy - halfSide;
              var scx = x + cx - halfSide;
              if (scy2 >= 0 && scy2 < sh && scx >= 0 && scx < sw) {
                var srcOff = scy2 * sw + scx;
                var wt = weights[cy * side + cx];
                a += mask[srcOff] * wt;
              }
            }
          }
          maskResult[so] = a;
        }
      }
      return maskResult;
    }
    const Mask = function(imageData) {
      var threshold = this.threshold(), mask = backgroundMask(imageData, threshold);
      if (mask) {
        mask = erodeMask(mask, imageData.width, imageData.height);
        mask = dilateMask(mask, imageData.width, imageData.height);
        mask = smoothEdgeMask(mask, imageData.width, imageData.height);
        applyMask(imageData, mask);
      }
      return imageData;
    };
    Factory.addGetterSetter(Node$1, "threshold", 0, getNumberValidator(), Factory.afterSetFilter);
    const Noise = function(imageData) {
      var amount = this.noise() * 255, data = imageData.data, nPixels = data.length, half2 = amount / 2, i2;
      for (i2 = 0; i2 < nPixels; i2 += 4) {
        data[i2 + 0] += half2 - 2 * half2 * Math.random();
        data[i2 + 1] += half2 - 2 * half2 * Math.random();
        data[i2 + 2] += half2 - 2 * half2 * Math.random();
      }
    };
    Factory.addGetterSetter(Node$1, "noise", 0.2, getNumberValidator(), Factory.afterSetFilter);
    const Pixelate = function(imageData) {
      var pixelSize = Math.ceil(this.pixelSize()), width = imageData.width, height = imageData.height, x, y, i2, red2, green2, blue2, alpha2, nBinsX = Math.ceil(width / pixelSize), nBinsY = Math.ceil(height / pixelSize), xBinStart, xBinEnd, yBinStart, yBinEnd, xBin, yBin, pixelsInBin, data = imageData.data;
      if (pixelSize <= 0) {
        Util.error("pixelSize value can not be <= 0");
        return;
      }
      for (xBin = 0; xBin < nBinsX; xBin += 1) {
        for (yBin = 0; yBin < nBinsY; yBin += 1) {
          red2 = 0;
          green2 = 0;
          blue2 = 0;
          alpha2 = 0;
          xBinStart = xBin * pixelSize;
          xBinEnd = xBinStart + pixelSize;
          yBinStart = yBin * pixelSize;
          yBinEnd = yBinStart + pixelSize;
          pixelsInBin = 0;
          for (x = xBinStart; x < xBinEnd; x += 1) {
            if (x >= width) {
              continue;
            }
            for (y = yBinStart; y < yBinEnd; y += 1) {
              if (y >= height) {
                continue;
              }
              i2 = (width * y + x) * 4;
              red2 += data[i2 + 0];
              green2 += data[i2 + 1];
              blue2 += data[i2 + 2];
              alpha2 += data[i2 + 3];
              pixelsInBin += 1;
            }
          }
          red2 = red2 / pixelsInBin;
          green2 = green2 / pixelsInBin;
          blue2 = blue2 / pixelsInBin;
          alpha2 = alpha2 / pixelsInBin;
          for (x = xBinStart; x < xBinEnd; x += 1) {
            if (x >= width) {
              continue;
            }
            for (y = yBinStart; y < yBinEnd; y += 1) {
              if (y >= height) {
                continue;
              }
              i2 = (width * y + x) * 4;
              data[i2 + 0] = red2;
              data[i2 + 1] = green2;
              data[i2 + 2] = blue2;
              data[i2 + 3] = alpha2;
            }
          }
        }
      }
    };
    Factory.addGetterSetter(Node$1, "pixelSize", 8, getNumberValidator(), Factory.afterSetFilter);
    const Posterize = function(imageData) {
      var levels = Math.round(this.levels() * 254) + 1, data = imageData.data, len = data.length, scale = 255 / levels, i2;
      for (i2 = 0; i2 < len; i2 += 1) {
        data[i2] = Math.floor(data[i2] / scale) * scale;
      }
    };
    Factory.addGetterSetter(Node$1, "levels", 0.5, getNumberValidator(), Factory.afterSetFilter);
    const RGB = function(imageData) {
      var data = imageData.data, nPixels = data.length, red2 = this.red(), green2 = this.green(), blue2 = this.blue(), i2, brightness;
      for (i2 = 0; i2 < nPixels; i2 += 4) {
        brightness = (0.34 * data[i2] + 0.5 * data[i2 + 1] + 0.16 * data[i2 + 2]) / 255;
        data[i2] = brightness * red2;
        data[i2 + 1] = brightness * green2;
        data[i2 + 2] = brightness * blue2;
        data[i2 + 3] = data[i2 + 3];
      }
    };
    Factory.addGetterSetter(Node$1, "red", 0, function(val) {
      this._filterUpToDate = false;
      if (val > 255) {
        return 255;
      } else if (val < 0) {
        return 0;
      } else {
        return Math.round(val);
      }
    });
    Factory.addGetterSetter(Node$1, "green", 0, function(val) {
      this._filterUpToDate = false;
      if (val > 255) {
        return 255;
      } else if (val < 0) {
        return 0;
      } else {
        return Math.round(val);
      }
    });
    Factory.addGetterSetter(Node$1, "blue", 0, RGBComponent, Factory.afterSetFilter);
    const RGBA = function(imageData) {
      var data = imageData.data, nPixels = data.length, red2 = this.red(), green2 = this.green(), blue2 = this.blue(), alpha2 = this.alpha(), i2, ia;
      for (i2 = 0; i2 < nPixels; i2 += 4) {
        ia = 1 - alpha2;
        data[i2] = red2 * alpha2 + data[i2] * ia;
        data[i2 + 1] = green2 * alpha2 + data[i2 + 1] * ia;
        data[i2 + 2] = blue2 * alpha2 + data[i2 + 2] * ia;
      }
    };
    Factory.addGetterSetter(Node$1, "red", 0, function(val) {
      this._filterUpToDate = false;
      if (val > 255) {
        return 255;
      } else if (val < 0) {
        return 0;
      } else {
        return Math.round(val);
      }
    });
    Factory.addGetterSetter(Node$1, "green", 0, function(val) {
      this._filterUpToDate = false;
      if (val > 255) {
        return 255;
      } else if (val < 0) {
        return 0;
      } else {
        return Math.round(val);
      }
    });
    Factory.addGetterSetter(Node$1, "blue", 0, RGBComponent, Factory.afterSetFilter);
    Factory.addGetterSetter(Node$1, "alpha", 1, function(val) {
      this._filterUpToDate = false;
      if (val > 1) {
        return 1;
      } else if (val < 0) {
        return 0;
      } else {
        return val;
      }
    });
    const Sepia = function(imageData) {
      var data = imageData.data, nPixels = data.length, i2, r, g, b;
      for (i2 = 0; i2 < nPixels; i2 += 4) {
        r = data[i2 + 0];
        g = data[i2 + 1];
        b = data[i2 + 2];
        data[i2 + 0] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189);
        data[i2 + 1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168);
        data[i2 + 2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);
      }
    };
    const Solarize = function(imageData) {
      var data = imageData.data, w = imageData.width, h2 = imageData.height, w4 = w * 4, y = h2;
      do {
        var offsetY = (y - 1) * w4;
        var x = w;
        do {
          var offset = offsetY + (x - 1) * 4;
          var r = data[offset];
          var g = data[offset + 1];
          var b = data[offset + 2];
          if (r > 127) {
            r = 255 - r;
          }
          if (g > 127) {
            g = 255 - g;
          }
          if (b > 127) {
            b = 255 - b;
          }
          data[offset] = r;
          data[offset + 1] = g;
          data[offset + 2] = b;
        } while (--x);
      } while (--y);
    };
    const Threshold = function(imageData) {
      var level = this.threshold() * 255, data = imageData.data, len = data.length, i2;
      for (i2 = 0; i2 < len; i2 += 1) {
        data[i2] = data[i2] < level ? 0 : 255;
      }
    };
    Factory.addGetterSetter(Node$1, "threshold", 0.5, getNumberValidator(), Factory.afterSetFilter);
    const Konva = Konva$1.Util._assign(Konva$1, {
      Arc,
      Arrow,
      Circle,
      Ellipse,
      Image: Image$1,
      Label,
      Tag,
      Line,
      Path,
      Rect,
      RegularPolygon,
      Ring,
      Sprite,
      Star: Star$1,
      Text,
      TextPath,
      Transformer,
      Wedge: Wedge$1,
      Filters: {
        Blur,
        Brighten,
        Contrast,
        Emboss,
        Enhance,
        Grayscale,
        HSL,
        HSV,
        Invert,
        Kaleidoscope,
        Mask,
        Noise,
        Pixelate,
        Posterize,
        RGB,
        RGBA,
        Sepia,
        Solarize,
        Threshold
      }
    });
    const md3 = {
      defaults: {
        VAppBar: {
          flat: true
        },
        VAutocomplete: {
          variant: "filled"
        },
        VBanner: {
          color: "primary"
        },
        VBottomSheet: {
          contentClass: "rounded-t-xl overflow-hidden"
        },
        VBtn: {
          color: "primary",
          rounded: "xl"
        },
        VBtnGroup: {
          rounded: "xl",
          VBtn: {
            rounded: null
          }
        },
        VCard: {
          rounded: "lg"
        },
        VCheckbox: {
          color: "secondary",
          inset: true
        },
        VChip: {
          rounded: "sm"
        },
        VCombobox: {
          variant: "filled"
        },
        VNavigationDrawer: {
          // VList: {
          //   nav: true,
          //   VListItem: {
          //     rounded: 'xl',
          //   },
          // },
        },
        VSelect: {
          variant: "filled"
        },
        VSlider: {
          color: "primary"
        },
        VTabs: {
          color: "primary"
        },
        VTextarea: {
          variant: "filled"
        },
        VTextField: {
          variant: "filled"
        },
        VToolbar: {
          VBtn: {
            color: null
          }
        }
      },
      icons: {
        defaultSet: "mdi",
        sets: {
          mdi
        }
      },
      theme: {
        themes: {
          light: {
            colors: {
              primary: "#6750a4",
              secondary: "#b4b0bb",
              tertiary: "#7d5260",
              error: "#b3261e",
              surface: "#fffbfe"
            }
          }
        }
      }
    };
    function createVuetify() {
      let vuetify2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        blueprint,
        ...rest
      } = vuetify2;
      const options = mergeDeep(blueprint, rest);
      const {
        aliases: aliases2 = {},
        components = {},
        directives = {}
      } = options;
      const defaults2 = createDefaults(options.defaults);
      const display = createDisplay(options.display, options.ssr);
      const theme = createTheme(options.theme);
      const icons = createIcons(options.icons);
      const locale = createLocale(options.locale);
      const date2 = createDate(options.date, locale);
      const goTo = createGoTo(options.goTo, locale);
      const install = (app2) => {
        for (const key in directives) {
          app2.directive(key, directives[key]);
        }
        for (const key in components) {
          app2.component(key, components[key]);
        }
        for (const key in aliases2) {
          app2.component(key, defineComponent({
            ...aliases2[key],
            name: key,
            aliasName: aliases2[key].name
          }));
        }
        theme.install(app2);
        app2.provide(DefaultsSymbol, defaults2);
        app2.provide(DisplaySymbol, display);
        app2.provide(ThemeSymbol, theme);
        app2.provide(IconSymbol, icons);
        app2.provide(LocaleSymbol, locale);
        app2.provide(DateOptionsSymbol, date2.options);
        app2.provide(DateAdapterSymbol, date2.instance);
        app2.provide(GoToSymbol, goTo);
        if (IN_BROWSER && options.ssr) {
          if (app2.$nuxt) {
            app2.$nuxt.hook("app:suspense:resolve", () => {
              display.update();
            });
          } else {
            const {
              mount
            } = app2;
            app2.mount = function() {
              const vm = mount(...arguments);
              nextTick(() => display.update());
              app2.mount = mount;
              return vm;
            };
          }
        }
        getUid.reset();
        {
          app2.mixin({
            computed: {
              $vuetify() {
                return reactive({
                  defaults: inject.call(this, DefaultsSymbol),
                  display: inject.call(this, DisplaySymbol),
                  theme: inject.call(this, ThemeSymbol),
                  icons: inject.call(this, IconSymbol),
                  locale: inject.call(this, LocaleSymbol),
                  date: inject.call(this, DateAdapterSymbol)
                });
              }
            }
          });
        }
      };
      return {
        install,
        defaults: defaults2,
        display,
        theme,
        icons,
        locale,
        date: date2,
        goTo
      };
    }
    const version = "3.5.5";
    createVuetify.version = version;
    function inject(key) {
      var _a2, _b;
      const vm = this.$;
      const provides = ((_a2 = vm.parent) == null ? void 0 : _a2.provides) ?? ((_b = vm.vnode.appContext) == null ? void 0 : _b.provides);
      if (provides && key in provides) {
        return provides[key];
      }
    }
    const everestTheme = {
      dark: false,
      colors: {
        background: "#EFEDE8",
        surface: "#EFEDE8",
        primary: "#254C84",
        secondary: "#35CE7C",
        error: "#b9352b",
        info: "#254C84",
        success: "#35CE7C",
        warning: "#c09112",
        "on-background": "#212121",
        "on-surface": "#212121"
      }
    };
    const currentTheme = everestTheme;
    const vuetify = createVuetify({
      blueprint: md3,
      theme: {
        defaultTheme: "everestTheme",
        themes: {
          everestTheme
        }
      }
    });
    const COLOR = {
      TERMINAL_REQUIREMENT: currentTheme.colors.secondary,
      TERMINAL_REQUIREMENT_DISABLED: "#d5d4cc",
      TERMINAL_PROVIDE: currentTheme.colors.warning,
      TERMINAL_PROVIDE_DISABLED: "#d5d4cc",
      CONNECTION: currentTheme.colors.secondary
    };
    const ICON_DATA = {
      EDIT: "M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z",
      GRAB: "M13,6V11H18V7.75L22.25,12L18,16.25V13H13V18H16.25L12,22.25L7.75,18H11V13H6V16.25L1.75,12L6,7.75V11H11V6H7.75L12,1.75L16.25,6H13Z",
      TERMINAL: "M12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20M17,14L12,9L7,14H17Z",
      DISABLED: "M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2C6.47,2 2,6.47 2,12C2,17.53 6.47,22 12,22C17.53,22 22,17.53 22,12C22,6.47 17.53,2 12,2M14.59,8L12,10.59L9.41,8L8,9.41L10.59,12L8,14.59L9.41,16L12,13.41L14.59,16L16,14.59L13.41,12L16,9.41L14.59,8Z"
    };
    const SIZE = {
      GRID: 24,
      FRAME_WIDTH: 288,
      FRAME_HEIGHT: 144,
      TERMINAL: 24,
      CONNECTION_WIDTH: 4,
      CONNECTION_CTRL: 100
    };
    const NORMAL_TEXT = {
      fontFamily: "Roboto, sans-serif"
    };
    const MONO_TEXT = {
      fontFamily: "Roboto Mono, monospace"
    };
    const TOOLTIP = {
      position: {
        x: 10,
        y: 10
      }
    };
    const INITIAL_RPC_TIMEOUT_VALUE = 1e4;
    class TerminalShape extends Konva.Path {
      constructor(config2) {
        config2.data = config2.data || ICON_DATA.TERMINAL;
        config2.fill = config2.fill || config2.terminal_type === "requirement" ? COLOR.TERMINAL_REQUIREMENT : COLOR.TERMINAL_PROVIDE;
        config2.x = config2.x || 0;
        config2.y = config2.y || 0;
        config2.offset = config2.offset || { x: SIZE.TERMINAL / 2, y: SIZE.TERMINAL / 2 };
        config2.hitFunc = config2.hitFunc || function(context, shape) {
          context.beginPath();
          context.rect(0, 0, SIZE.TERMINAL, SIZE.TERMINAL);
          context.closePath();
          context.fillShape(shape);
        };
        super(config2);
        if (config2.terminal_alignment) {
          this.set_alignment(config2.terminal_alignment);
        }
      }
      get terminal_type() {
        return this.getAttr("terminal_type");
      }
      get terminal_id() {
        return this.getAttr("terminal_id");
      }
      get terminal_alignment() {
        return this.getAttr("terminal_alignment");
      }
      set_alignment(alignment) {
        this.setAttr("terminal_alignment", alignment);
        const is_provide = this.terminal_type === "provide";
        if (alignment === "top") {
          this.rotation(is_provide ? 0 : 180);
        } else if (alignment === "right") {
          this.rotation(is_provide ? 90 : 270);
        } else if (alignment === "bottom") {
          this.rotation(is_provide ? 180 : 0);
        } else if (alignment === "left") {
          this.rotation(is_provide ? 270 : 90);
        }
      }
      // get_rotation(alignment: TerminalAlignment): number {
      //   const provide = this.terminal_type === "provide";
      //   if (alignment === "top") {
      //     return provide ? 0 : 180;
      //   } else if (alignment === "right") {
      //     return provide ? 90 : 270;
      //   } else if (alignment === "bottom") {
      //     return provide ? 180 : 0;
      //   } else {
      //     return provide ? 270 : 90;
      //   }
      // }
      set_appearence(look) {
        if (look !== "DISABLED") {
          this.data(ICON_DATA.TERMINAL);
        }
        if (look === "DISABLED") {
          this.data(ICON_DATA.DISABLED);
          this.fill(this.terminal_type === "requirement" ? COLOR.TERMINAL_REQUIREMENT_DISABLED : COLOR.TERMINAL_PROVIDE_DISABLED);
          this.listening(false);
        } else if (look === "PLACEHOLDER") {
          this.fill(this.terminal_type === "requirement" ? COLOR.TERMINAL_REQUIREMENT_DISABLED : COLOR.TERMINAL_PROVIDE_DISABLED);
          this.listening(false);
        } else if (look === "NORMAL") {
          this.fill(this.terminal_type === "requirement" ? COLOR.TERMINAL_REQUIREMENT : COLOR.TERMINAL_PROVIDE);
          this.listening(true);
        }
      }
    }
    function check_hit(x, y, terminal_distribution) {
      let align = null;
      let index = null;
      if (0 < x && x < SIZE.FRAME_WIDTH) {
        if (-SIZE.TERMINAL < y && y < 0) {
          align = "top";
          index = Math.floor(terminal_distribution.top.length * x / SIZE.FRAME_WIDTH + 0.5);
        } else if (y > SIZE.FRAME_HEIGHT && y < SIZE.FRAME_HEIGHT + SIZE.TERMINAL) {
          align = "bottom";
          index = Math.floor(terminal_distribution.bottom.length * x / SIZE.FRAME_WIDTH + 0.5);
        }
      }
      if (0 < y && y < SIZE.FRAME_HEIGHT) {
        if (-SIZE.TERMINAL < x && x < 0) {
          align = "left";
          index = Math.floor(terminal_distribution.left.length * y / SIZE.FRAME_HEIGHT + 0.5);
        } else if (x > SIZE.FRAME_WIDTH && x < SIZE.FRAME_WIDTH + SIZE.TERMINAL) {
          align = "right";
          index = Math.floor(terminal_distribution.right.length * y / SIZE.FRAME_HEIGHT + 0.5);
        }
      }
      return {
        align,
        index
      };
    }
    class ModuleView {
      constructor(view_model) {
        __publicField(this, "group");
        __publicField(this, "_vm");
        __publicField(this, "_terminal_views");
        __publicField(this, "_title");
        __publicField(this, "_observers", []);
        this.group = new Konva.Group({
          draggable: true
        });
        this._vm = view_model;
        this._terminal_views = view_model.terminal_lookup.map((item, terminal_id) => {
          const view = new TerminalShape({
            terminal_type: item.terminal.type,
            terminal_id,
            terminal_alignment: item.alignment
          });
          view.setDraggable(true);
          view.on("dragstart", () => this._terminal_dragstart_handler(view));
          view.on("dragmove", () => this._terminal_dragmove_handler(view));
          view.on("dragend", () => this._terminal_dragend_handler(view));
          view.on("mouseenter", () => {
            this._vm.set_cursor("pointer");
            const showTooltip = {
              type: "SHOW_TOOLTIP",
              text: `Interface type: ${item.terminal.interface}`
            };
            this._vm.notify_stage_context(showTooltip);
          });
          view.on("mouseleave", () => {
            this._vm.set_cursor("default");
            const hideTooltip = {
              type: "HIDE_TOOLTIP"
            };
            this._vm.notify_stage_context(hideTooltip);
          });
          view.on("pointerclick", (ev) => {
            view_model.clicked_terminal(terminal_id);
            ev.cancelBubble = true;
          });
          return view;
        });
        Object.entries(view_model.terminal_dist).forEach(([_alignment, terminal_ids]) => {
          this._recalculate_terminal_position(_alignment, terminal_ids, false);
        });
        view_model.add_observer((ev) => this._vm_event_handler(ev));
        this.group.on("dragmove", () => this._module_dragmove_handler());
        this.group.position({
          x: view_model.grid_position.x * SIZE.GRID,
          y: view_model.grid_position.y * SIZE.GRID
        });
        const frame = new Konva.Rect({
          cornerRadius: 4,
          width: SIZE.FRAME_WIDTH,
          height: SIZE.FRAME_HEIGHT,
          fill: currentTheme.colors.primary,
          shadowBlur: 4,
          shadowOpacity: 0.4,
          shadowOffset: {
            x: 2,
            y: 2
          },
          fillAfterStrokeEnabled: true,
          listening: true
        });
        const strokeWidth = 8;
        const topStroke = new Konva.Line({
          cornerRadius: 4,
          points: [
            0,
            strokeWidth / 2,
            // Start at the top-left corner of where the rectangle is positioned
            SIZE.FRAME_WIDTH,
            strokeWidth / 2
            // End at the top-right corner of where the rectangle is positioned
          ],
          stroke: currentTheme.colors.secondary,
          strokeWidth,
          x: frame.x(),
          y: frame.y(),
          listening: true
        });
        const title2 = new Konva.Text({
          wrap: "none",
          text: view_model.id,
          fontFamily: NORMAL_TEXT.fontFamily,
          ellipsis: true,
          fill: "white",
          fontSize: 16 * 2,
          padding: 16,
          y: strokeWidth,
          width: SIZE.FRAME_WIDTH,
          listening: true
        });
        const typeInfo = new Konva.Text({
          wrap: "none",
          text: `${view_model.type}`,
          fontFamily: MONO_TEXT.fontFamily,
          ellipsis: true,
          fill: "white",
          opacity: 0.5,
          fontSize: 16,
          padding: 8,
          width: SIZE.FRAME_WIDTH,
          y: frame.height() - 16 * 2,
          align: "right",
          listening: true
        });
        [frame, title2, topStroke, typeInfo].forEach((e) => {
          e.on("mouseenter", () => {
            this._vm.set_cursor("pointer");
          });
          e.on("mouseleave", () => {
            this._vm.set_cursor("default");
          });
          e.on("pointerclick", (ev) => {
            this._vm.clicked_title();
            ev.cancelBubble = true;
          });
        });
        this._title = title2;
        this.group.add(frame, topStroke, typeInfo, title2, ...this._terminal_views);
        this.group.cache();
      }
      get_terminal_placement(id2) {
        const terminal_view = this._terminal_views[id2];
        const relative_position = terminal_view.position();
        const module_position = this.group.position();
        return {
          x: relative_position.x + module_position.x,
          y: relative_position.y + module_position.y,
          alignment: terminal_view.terminal_alignment
        };
      }
      add_observer(handler) {
        this._observers.push(handler);
        return () => {
          this._observers = this._observers.filter((other) => other !== handler);
        };
      }
      _notify(ev) {
        this._observers.forEach((handler) => handler(ev));
      }
      _vm_event_handler(ev) {
        if (ev.type === "TERMINAL_MODIFY_APPEARENCE") {
          ev.disable.forEach((id2) => {
            this._terminal_views[id2].set_appearence("DISABLED");
          });
          ev.normal.forEach((id2) => {
            this._terminal_views[id2].set_appearence("NORMAL");
          });
          this.group.cache();
        } else if (ev.type === "MODULE_MODEL_UPDATE") {
          this._title.setText(this._vm.id);
          this.group.cache();
        }
      }
      _module_dragmove_handler() {
        const pos = this.group.position();
        const new_grid_pos = {
          x: Math.round(pos.x / SIZE.GRID),
          y: Math.round(pos.y / SIZE.GRID)
        };
        const cur_grid_pos = this._vm.grid_position;
        const new_group_pos = {
          x: new_grid_pos.x * SIZE.GRID,
          y: new_grid_pos.y * SIZE.GRID
        };
        this.group.position(new_group_pos);
        if (cur_grid_pos.x != new_grid_pos.x || cur_grid_pos.y != new_grid_pos.y) {
          this._vm.grid_position = new_grid_pos;
          const update_terminals = this._terminal_views.map((item, id2) => {
            return {
              alignment: item.terminal_alignment,
              id: id2,
              x: item.x() + new_group_pos.x,
              y: item.y() + new_group_pos.y
            };
          });
          this._notify({
            type: "TERMINALS_UPDATED",
            terminals: update_terminals,
            module_moved: true
          });
        }
      }
      _terminal_dragstart_handler(view) {
        const replace_terminal = view.clone();
        replace_terminal.set_appearence("PLACEHOLDER");
        this._terminal_views[view.terminal_id] = replace_terminal;
        this.group.add(replace_terminal);
        view.moveToTop();
        this.group.clearCache();
      }
      _terminal_dragmove_handler(view) {
        const hit = check_hit(view.x(), view.y(), this._vm.terminal_dist);
        if (!hit.align) {
          return;
        }
        if (hit.align != this._vm.terminal_lookup[view.terminal_id].alignment) {
          view.set_alignment(hit.align);
        }
        const changed_areas = this._vm.move_terminal(view.terminal_id, hit.align, hit.index);
        changed_areas.forEach((alignment) => {
          this._recalculate_terminal_position(alignment, this._vm.terminal_dist[alignment], true);
        });
      }
      _terminal_dragend_handler(view) {
        this._terminal_views[view.terminal_id].destroy();
        this._terminal_views[view.terminal_id] = view;
        const end_align = this._vm.terminal_lookup[view.terminal_id].alignment;
        this._recalculate_terminal_position(end_align, this._vm.terminal_dist[end_align]);
        this.group.cache();
      }
      _recalculate_terminal_position(alignment, terminal_ids, animate2 = false) {
        const horizontal_align = alignment === "top" || alignment === "bottom";
        const x_offset = alignment === "right" ? SIZE.FRAME_WIDTH + SIZE.TERMINAL : 0;
        const y_offset = alignment === "bottom" ? SIZE.FRAME_HEIGHT + SIZE.TERMINAL : 0;
        const size2 = horizontal_align ? SIZE.FRAME_WIDTH : SIZE.FRAME_HEIGHT;
        const terminal_count = terminal_ids.length;
        const terminal_update_event = {
          type: "TERMINALS_UPDATED",
          terminals: [],
          module_moved: false
        };
        terminal_ids.forEach((terminal_id, index) => {
          const terminal_view = this._terminal_views[terminal_id];
          const list_offset = (index + 0.5) * size2 / terminal_count;
          const x = x_offset + (horizontal_align ? list_offset : -SIZE.TERMINAL / 2);
          const y = y_offset + (horizontal_align ? -SIZE.TERMINAL / 2 : list_offset);
          terminal_view.set_alignment(alignment);
          if (animate2) {
            terminal_view.to({
              duration: 0.2,
              ease: "EaseIn",
              x,
              y
            });
          } else {
            terminal_view.x(x);
            terminal_view.y(y);
          }
          terminal_update_event.terminals.push({
            alignment,
            id: terminal_id,
            x: x + this.group.x(),
            y: y + this.group.y()
          });
        });
        this._notify(terminal_update_event);
      }
    }
    class ModuleViewModel {
      constructor(model, id2, stage_context) {
        __publicField(this, "_grid_position");
        __publicField(this, "terminal_dist", {
          top: [],
          right: [],
          bottom: [],
          left: []
        });
        __publicField(this, "terminal_lookup", []);
        __publicField(this, "type");
        __publicField(this, "_instance_id");
        __publicField(this, "_config_model");
        __publicField(this, "_module_instance");
        __publicField(this, "_observers", []);
        __publicField(this, "_stage_context");
        this._instance_id = id2;
        this._config_model = model;
        this._stage_context = stage_context;
        this._module_instance = model.get_module_instance(id2);
        this._initialize_terminals(this._module_instance.view_config.terminals);
        this._grid_position = this._module_instance.view_config.position;
        this.type = this._module_instance.type;
        stage_context.add_observer((ev) => this._handle_stage_context_event(ev));
        model.add_observer((ev) => {
          if (ev.type == "MODULE_INSTANCE_UPDATED" && ev.id == id2) {
            this._notify({ type: "MODULE_MODEL_UPDATE" });
          }
        });
      }
      _initialize_terminals(terminal_arrangement) {
        Object.entries(terminal_arrangement).forEach(([_alignment, terminals]) => {
          const alignment = _alignment;
          terminals.forEach((terminal) => {
            const index = this.terminal_dist[alignment].length;
            const terminal_id = this.terminal_lookup.length;
            this.terminal_lookup.push({
              terminal,
              alignment,
              index
            });
            this.terminal_dist[alignment].push(terminal_id);
          });
        });
      }
      add_observer(handler) {
        this._observers.push(handler);
        return () => {
          this._observers = this._observers.filter((other) => other !== handler);
        };
      }
      notify_stage_context(event) {
        this._stage_context._publish(event);
      }
      _notify(ev) {
        this._observers.forEach((handler) => handler(ev));
      }
      clicked_terminal(terminal_id) {
        const terminal = this.terminal_lookup[terminal_id].terminal;
        this._stage_context.clicked_terminal(terminal, this._instance_id);
      }
      clicked_title() {
        this._stage_context.clicked_instance(this._instance_id);
      }
      set_cursor(type2) {
        this._stage_context.container.style.cursor = type2;
      }
      _handle_stage_context_event(event) {
        if (event.type !== "SELECT") {
          return;
        }
        const selection_event = event.selection;
        if (selection_event.type === "TERMINAL") {
          const modify_event = {
            type: "TERMINAL_MODIFY_APPEARENCE",
            disable: [],
            highlight: [],
            normal: []
          };
          const terminal = selection_event.terminal;
          this.terminal_lookup.forEach((item, id2) => {
            if (item.terminal.type !== terminal.type && (terminal.type === "provide" ? this._config_model.interfaces_match(terminal.interface, item.terminal.interface) : this._config_model.interfaces_match(item.terminal.interface, terminal.interface))) {
              return;
            }
            modify_event.disable.push(id2);
          });
          this._notify(modify_event);
        } else {
          this._notify({
            type: "TERMINAL_MODIFY_APPEARENCE",
            normal: Array.from(this.terminal_lookup.keys()),
            disable: [],
            highlight: []
          });
        }
      }
      get id() {
        return this._module_instance.id;
      }
      get grid_position() {
        return this._grid_position;
      }
      // returns diff or null
      set grid_position(pos) {
        this._grid_position = pos;
        this._config_model.update_module_view_position(this._instance_id, pos);
      }
      move_terminal(terminal_id, new_align, new_index) {
        const cur_align = this.terminal_lookup[terminal_id].alignment;
        const cur_index = this.terminal_lookup[terminal_id].index;
        if (new_align != cur_align) {
          this.terminal_dist[cur_align].splice(cur_index, 1);
          this.terminal_dist[new_align].splice(new_index, 0, terminal_id);
          this.terminal_lookup[terminal_id].alignment = new_align;
          this._recalculate_terminal_index([cur_align, new_align]);
          return [cur_align, new_align];
        } else {
          if (new_index > cur_index + 1 || new_index < cur_index) {
            this.terminal_dist[cur_align].splice(cur_index, 1);
            const corrected_new_index = new_index < cur_index ? new_index : new_index - 1;
            this.terminal_dist[cur_align].splice(corrected_new_index, 0, terminal_id);
            this._recalculate_terminal_index([cur_align]);
            return [cur_align];
          } else {
            return [];
          }
        }
      }
      get_terminal_lookup_id(name, type2) {
        return this.terminal_lookup.findIndex((item) => item.terminal.id === name && item.terminal.type === type2);
      }
      _recalculate_terminal_index(alignments) {
        const new_arrangement = {};
        alignments.forEach((alignment) => {
          this.terminal_dist[alignment].forEach((terminal_id, index) => {
            this.terminal_lookup[terminal_id].index = index;
          });
          new_arrangement[alignment] = this.terminal_dist[alignment].map((id2) => this.terminal_lookup[id2].terminal);
        });
        this._config_model.update_module_view_terminals(this._instance_id, new_arrangement);
      }
    }
    const correction = {
      top: {
        x: 0,
        y: -SIZE.GRID / 2
      },
      right: {
        x: SIZE.GRID / 2,
        y: 0
      },
      bottom: {
        x: 0,
        y: SIZE.GRID / 2
      },
      left: {
        x: -SIZE.GRID / 2,
        y: 0
      }
    };
    class ConnectionShape extends Konva.Line {
      constructor(config2) {
        config2.bezier = config2.bezier || true;
        config2.strokeWidth = config2.strokeWidth || SIZE.CONNECTION_WIDTH;
        config2.stroke = config2.stroke || COLOR.CONNECTION;
        super(config2);
        this.update_terminals(config2.requirement, config2.provide);
      }
      update_terminals(requirement, provide2, animate2 = false) {
        requirement = requirement || this.getAttr("requirement");
        provide2 = provide2 || this.getAttr("provide");
        const req_x = requirement.x + correction[requirement.alignment].x;
        const req_y = requirement.y + correction[requirement.alignment].y;
        const prov_x = provide2.x + correction[provide2.alignment].x;
        const prov_y = provide2.y + correction[provide2.alignment].y;
        const x_dist = prov_x - req_x;
        const y_dist = prov_y - req_y;
        const cps = [
          [requirement.alignment, req_x, req_y, x_dist, y_dist],
          [provide2.alignment, prov_x, prov_y, -x_dist, -y_dist]
        ].map((item) => {
          const [alignment, pos_x, pos_y, dist_x, dist_y] = item;
          if (alignment === "top") {
            return [pos_x, pos_y - Math.max(SIZE.CONNECTION_CTRL, -dist_y)];
          } else if (alignment === "right") {
            return [pos_x + Math.max(SIZE.CONNECTION_CTRL, dist_x), pos_y];
          } else if (alignment === "bottom") {
            return [pos_x, pos_y + Math.max(SIZE.CONNECTION_CTRL, dist_y)];
          } else {
            return [pos_x - Math.max(SIZE.CONNECTION_CTRL, -dist_x), pos_y];
          }
        });
        const points = [req_x, req_y, cps[0][0], cps[0][1], cps[1][0], cps[1][1], prov_x, prov_y];
        if (animate2) {
          this.to({
            points,
            duration: 0.2,
            ease: "EaseIn"
          });
        } else {
          this.points(points);
        }
        this.setAttrs({
          requirement,
          provide: provide2
        });
      }
    }
    class ConnectionManager {
      constructor(stage_context) {
        __publicField(this, "group");
        __publicField(this, "connections", []);
        __publicField(this, "_registered_modules", []);
        __publicField(this, "_stage_context");
        this.group = new Konva.Group();
        this._stage_context = stage_context;
      }
      add_connection(id2, provide2, requirement) {
        const providing_placement = provide2.module_view.get_terminal_placement(provide2.terminal_lookup_id);
        const requiring_placement = requirement.module_view.get_terminal_placement(requirement.terminal_lookup_id);
        const connection_view = new ConnectionShape({
          provide: providing_placement,
          requirement: requiring_placement,
          hitStrokeWidth: 12
          // FIXME (aw): constant
        });
        const connection_item = {
          id: id2,
          view: connection_view
        };
        connection_view.on("pointerclick", () => this._stage_context.clicked_connection(id2));
        connection_view.on("mouseenter", () => {
          this._stage_context.container.style.cursor = "pointer";
        });
        connection_view.on("mouseleave", () => {
          this._stage_context.container.style.cursor = "default";
        });
        this.connections.push(connection_item);
        this._insert_terminal_for_module_view(provide2, connection_item, "provide");
        this._insert_terminal_for_module_view(requirement, connection_item, "requirement");
        this.group.add(connection_view);
      }
      delete_connection(id2) {
        const cxn_index = this.connections.findIndex((cxn) => cxn.id === id2);
        const cxn_item = this.connections[cxn_index];
        cxn_item.view.destroy();
        this.connections.slice(cxn_index, 1);
      }
      // FIXME (aw): naming on half etc
      _insert_terminal_for_module_view(half2, connection_item, type2) {
        const module2 = this._registered_modules.find((item) => item.view === half2.module_view);
        if (module2) {
          const terminal = module2.terminal_lookup[half2.terminal_lookup_id];
          if (terminal) {
            terminal.connections.push(connection_item);
          } else {
            module2.terminal_lookup[half2.terminal_lookup_id] = {
              type: type2,
              connections: [connection_item]
            };
          }
          return;
        }
        const new_module = {
          view: half2.module_view,
          terminal_lookup: Array(half2.module_view._terminal_views.length)
        };
        new_module.terminal_lookup[half2.terminal_lookup_id] = {
          type: type2,
          connections: [connection_item]
        };
        this._registered_modules.push(new_module);
        new_module.view.add_observer((ev) => {
          if (ev.type === "TERMINALS_UPDATED") {
            const is_animated = ev.module_moved === false;
            ev.terminals.forEach((terminal) => {
              if (!new_module.terminal_lookup[terminal.id])
                return;
              const { connections, type: type22 } = new_module.terminal_lookup[terminal.id];
              connections.forEach((cxn) => {
                if (type22 === "provide") {
                  cxn.view.update_terminals(null, terminal, is_animated);
                } else {
                  cxn.view.update_terminals(terminal, null, is_animated);
                }
              });
            });
          }
        });
      }
    }
    class ConfigStage {
      constructor(config2, context) {
        // view part
        __publicField(this, "_konva");
        __publicField(this, "_module_views", {});
        // view model part
        __publicField(this, "_model", null);
        __publicField(this, "_module_vms", {});
        __publicField(this, "_conn_man");
        __publicField(this, "context");
        __publicField(this, "_stage");
        __publicField(this, "_bg");
        this.config = config2;
        this._stage = new Konva.Stage(config2);
        Konva.dragButtons = [0, 2];
        this._stage.on("contextmenu", (e) => e.evt.preventDefault());
        const tooltipLayer = new Konva.Layer({});
        const tooltip = new Konva.Text({
          text: "",
          fontFamily: NORMAL_TEXT.fontFamily,
          fontSize: 16,
          padding: 5,
          fill: "white",
          alpha: 0.75,
          visible: false,
          sceneFunc: function(context2, shape) {
            const { width, height } = shape.size();
            const borderRadius = 3;
            context2.beginPath();
            context2.moveTo(borderRadius, 0);
            context2.lineTo(width - borderRadius, 0);
            context2.arcTo(width, 0, width, borderRadius, borderRadius);
            context2.lineTo(width, height - borderRadius);
            context2.arcTo(width, height, width - borderRadius, height, borderRadius);
            context2.lineTo(borderRadius, height);
            context2.arcTo(0, height, 0, height - borderRadius, borderRadius);
            context2.lineTo(0, borderRadius);
            context2.arcTo(0, 0, borderRadius, 0, borderRadius);
            context2.closePath();
            context2.fillStyle = currentTheme.colors.secondary;
            context2.fill();
            shape._sceneFunc(context2);
          },
          ...TOOLTIP.position
        });
        tooltipLayer.add(tooltip);
        const static_layer = new Konva.Layer({
          draggable: true
        });
        this._reset_static_layer(static_layer);
        this._stage.on("wheel", (event) => {
          event.evt.preventDefault();
          const oldScale = static_layer.scaleX();
          const pointer = this._stage.getPointerPosition();
          if (!pointer) {
            return;
          }
          const mousePointTo = {
            x: (pointer.x - static_layer.x()) / oldScale,
            y: (pointer.y - static_layer.y()) / oldScale
          };
          const delta2 = event.evt.deltaY === 1 || event.evt.deltaY === -1 ? event.evt.deltaY * 0.2 : event.evt.deltaY;
          const zoomIntensity = 5e-3;
          const scaleBy = Math.exp(delta2 * zoomIntensity);
          const newScale = oldScale * scaleBy;
          static_layer.scale({ x: newScale, y: newScale });
          const newPos = {
            x: pointer.x - mousePointTo.x * newScale,
            y: pointer.y - mousePointTo.y * newScale
          };
          static_layer.position(newPos);
          this._bg.width(this._stage.width() / newScale);
          this._bg.height(this._stage.height() / newScale);
          this._bg.setAbsolutePosition({ x: 0, y: 0 });
          static_layer.batchDraw();
        });
        this._stage.add(static_layer);
        this._stage.add(tooltipLayer);
        this._konva = {
          stage: this._stage,
          tooltip,
          static_layer,
          anim_layer: null
        };
        this.context = context;
        context.set_container(this._stage.container());
        this.context.add_observer((ev) => this._handle_stage_context_event(ev));
        this.registerListeners();
        this.resizeStage();
      }
      registerListeners() {
        window.addEventListener("resize", () => this.resizeStage());
      }
      // TODO : Call this method when the stage is destroyed
      unregisterListeners() {
        window.removeEventListener("resize", this.resizeStage);
      }
      resizeStage() {
        const container = document.getElementById(this.config.container);
        const containerWidth = container.offsetWidth;
        const containerHeight = container.offsetHeight;
        this._stage.width(containerWidth);
        this._stage.height(containerHeight);
      }
      set_model(model) {
        if (this._model)
          ;
        this._conn_man = new ConnectionManager(this.context);
        this._reset_static_layer(this._konva.static_layer);
        this._konva.static_layer.add(this._conn_man.group);
        this._model = model;
        Object.keys(model._instances).forEach((id2) => this._add_module_instance_to_stage(Number(id2)));
        Object.keys(model._connections).forEach((id2) => {
          try {
            this._add_connection_to_stage(Number(id2));
          } catch (e) {
            console.warn(e);
          }
        });
        model.add_observer((ev) => this._handle_config_event(ev));
      }
      _handle_config_event(ev) {
        if (ev.type === "MODULE_INSTANCE_ADDED") {
          this._add_module_instance_to_stage(ev.id);
        } else if (ev.type === "CONNECTION_ADDED") {
          this._add_connection_to_stage(ev.id);
        } else if (ev.type === "CONNECTION_DELETED") {
          this._conn_man.delete_connection(ev.id);
          this.context.unselect();
        } else if (ev.type === "MODULE_INSTANCE_DELETED") {
          const id2 = ev.id;
          this._module_views[id2].group.destroy();
          delete this._module_views[id2];
          delete this._module_vms[id2];
          this.context.unselect();
        }
      }
      _handle_stage_context_event(ev) {
        if (ev.type === "ADD_CONNECTION") {
          this._model.add_connection(ev.connection);
        } else if (ev.type === "SHOW_TOOLTIP") {
          this._konva.tooltip.text(ev.text);
          this._konva.tooltip.show();
        } else if (ev.type === "HIDE_TOOLTIP") {
          this._konva.tooltip.hide();
        }
      }
      _add_module_instance_to_stage(id2) {
        const module_view_model = new ModuleViewModel(this._model, id2, this.context);
        this._module_vms[id2] = module_view_model;
        if (!module_view_model.grid_position) {
          module_view_model.grid_position = {
            x: id2,
            y: id2
          };
        }
        const module_view = new ModuleView(module_view_model);
        this._module_views[id2] = module_view;
        this._konva.static_layer.add(module_view.group);
      }
      _add_connection_to_stage(id2) {
        const cxn = this._model._connections[id2];
        const requiring_view_model = this._module_vms[cxn.requiring_instance_id];
        const requiring_view = this._module_views[cxn.requiring_instance_id];
        const providing_view_model = this._module_vms[cxn.providing_instance_id];
        const providing_view = this._module_views[cxn.providing_instance_id];
        const providing_terminal_lookup_id = providing_view_model.get_terminal_lookup_id(
          cxn.providing_impl_name,
          "provide"
        );
        if (providing_terminal_lookup_id === -1) {
          throw Error(`Couldn't add connection to stage, terminal ${cxn.providing_impl_name} not found on ${providing_view_model.type}.`);
        }
        const requiring_terminal_lookup_id = requiring_view_model.get_terminal_lookup_id(
          cxn.requirement_name,
          "requirement"
        );
        if (requiring_terminal_lookup_id === -1) {
          throw Error(`Couldn't add connection to stage, terminal ${cxn.requirement_name} not found on ${requiring_view_model.type}.`);
        }
        this._conn_man.add_connection(
          id2,
          { module_view: providing_view, terminal_lookup_id: providing_terminal_lookup_id },
          { module_view: requiring_view, terminal_lookup_id: requiring_terminal_lookup_id }
        );
      }
      _reset_static_layer(static_layer) {
        static_layer.destroyChildren();
        this._bg = new Konva.Rect({
          width: this._stage.width(),
          height: this._stage.height(),
          fill: "rgba(255, 0, 0, 0)"
        });
        this._bg.on("pointerclick", () => this.context.unselect());
        static_layer.add(this._bg);
        static_layer.on("dragstart", () => {
          this._stage.container().style.cursor = "grab";
        });
        static_layer.on("dragend", () => {
          this._stage.container().style.cursor = "default";
          this._bg.setAbsolutePosition({ x: 0, y: 0 });
        });
      }
    }
    const _sfc_main$A = /* @__PURE__ */ defineComponent$1({
      setup() {
        const evbcStore2 = useEvbcStore();
        const evbc2 = inject$1("evbc");
        const selected_interface = null;
        const notyf2 = inject$1("notyf");
        let stage;
        onMounted(() => {
          stage = new ConfigStage(
            {
              container: "konva-stage",
              width: 1024,
              // will automatically be resized responsively
              height: 800,
              draggable: false
              // we only want to have the static layer draggable
            },
            evbcStore2.config_context
          );
          if (current_config.value) {
            stage.set_model(current_config.value);
          }
        });
        const current_config = computed(evbcStore2.get_current_config);
        const save_config = () => {
          if (!current_config.value)
            return;
          evbc2.save_config(current_config.value).then(() => {
            notyf2.success(`Successfully saved ${current_config.value._name}`);
          }).catch((error2) => {
            notyf2.error(`Failed to save ${current_config.value._name}
Reason: ${error2}`);
          });
        };
        watch(current_config, (new_config, old_config) => {
          stage.set_model(new_config);
        });
        return {
          selected_interface,
          stage,
          current_config,
          save_config
        };
      }
    });
    const makeVSheetProps = propsFactory({
      color: String,
      ...makeBorderProps(),
      ...makeComponentProps(),
      ...makeDimensionProps(),
      ...makeElevationProps(),
      ...makeLocationProps(),
      ...makePositionProps(),
      ...makeRoundedProps(),
      ...makeTagProps(),
      ...makeThemeProps()
    }, "VSheet");
    const VSheet = genericComponent()({
      name: "VSheet",
      props: makeVSheetProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          themeClasses
        } = provideTheme(props);
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(toRef(props, "color"));
        const {
          borderClasses
        } = useBorder(props);
        const {
          dimensionStyles
        } = useDimension(props);
        const {
          elevationClasses
        } = useElevation(props);
        const {
          locationStyles
        } = useLocation(props);
        const {
          positionClasses
        } = usePosition(props);
        const {
          roundedClasses
        } = useRounded(props);
        useRender(() => createVNode(props.tag, {
          "class": ["v-sheet", themeClasses.value, backgroundColorClasses.value, borderClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, props.class],
          "style": [backgroundColorStyles.value, dimensionStyles.value, locationStyles.value, props.style]
        }, slots));
        return {};
      }
    });
    const _hoisted_1$4 = /* @__PURE__ */ createBaseVNode("div", { id: "konva-stage" }, null, -1);
    function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createBlock(VSheet, {
        id: "konva-stage-container",
        width: "100%",
        height: "100vh",
        elevation: "4"
      }, {
        default: withCtx(() => [
          _hoisted_1$4,
          _ctx.current_config ? (openBlock(), createBlock(VBtn, {
            key: 0,
            id: "config-save-button",
            icon: "mdi-content-save",
            color: "primary",
            onClick: _ctx.save_config
          }, null, 8, ["onClick"])) : createCommentVNode("", true)
        ]),
        _: 1
      });
    }
    const EvConfigCanvas = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", _sfc_render$4]]);
    const _sfc_main$z = /* @__PURE__ */ defineComponent$1({
      props: {
        show_dialog: {
          type: Boolean,
          required: true
        },
        title: {
          type: String,
          required: true
        },
        text: {
          type: String,
          required: true
        },
        accept_text: {
          type: String,
          required: true
        },
        deny_text: {
          type: String,
          required: true
        }
      },
      methods: {
        accept() {
          this.$emit("accept");
        },
        deny() {
          this.$emit("deny");
        }
      }
    });
    const makeVDialogProps = propsFactory({
      fullscreen: Boolean,
      retainFocus: {
        type: Boolean,
        default: true
      },
      scrollable: Boolean,
      ...makeVOverlayProps({
        origin: "center center",
        scrollStrategy: "block",
        transition: {
          component: VDialogTransition
        },
        zIndex: 2400
      })
    }, "VDialog");
    const VDialog = genericComponent()({
      name: "VDialog",
      props: makeVDialogProps(),
      emits: {
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const isActive = useProxiedModel(props, "modelValue");
        const {
          scopeId
        } = useScopeId();
        const overlay = ref$1();
        function onFocusin(e) {
          var _a2, _b;
          const before = e.relatedTarget;
          const after = e.target;
          if (before !== after && ((_a2 = overlay.value) == null ? void 0 : _a2.contentEl) && // We're the topmost dialog
          ((_b = overlay.value) == null ? void 0 : _b.globalTop) && // It isn't the document or the dialog body
          ![document, overlay.value.contentEl].includes(after) && // It isn't inside the dialog body
          !overlay.value.contentEl.contains(after)) {
            const focusable = focusableChildren(overlay.value.contentEl);
            if (!focusable.length)
              return;
            const firstElement = focusable[0];
            const lastElement = focusable[focusable.length - 1];
            if (before === firstElement) {
              lastElement.focus();
            } else {
              firstElement.focus();
            }
          }
        }
        if (IN_BROWSER) {
          watch(() => isActive.value && props.retainFocus, (val) => {
            val ? document.addEventListener("focusin", onFocusin) : document.removeEventListener("focusin", onFocusin);
          }, {
            immediate: true
          });
        }
        watch(isActive, async (val) => {
          var _a2, _b;
          await nextTick();
          if (val) {
            (_a2 = overlay.value.contentEl) == null ? void 0 : _a2.focus({
              preventScroll: true
            });
          } else {
            (_b = overlay.value.activatorEl) == null ? void 0 : _b.focus({
              preventScroll: true
            });
          }
        });
        const activatorProps = computed(() => mergeProps({
          "aria-haspopup": "dialog",
          "aria-expanded": String(isActive.value)
        }, props.activatorProps));
        useRender(() => {
          const overlayProps = VOverlay.filterProps(props);
          return createVNode(VOverlay, mergeProps({
            "ref": overlay,
            "class": ["v-dialog", {
              "v-dialog--fullscreen": props.fullscreen,
              "v-dialog--scrollable": props.scrollable
            }, props.class],
            "style": props.style
          }, overlayProps, {
            "modelValue": isActive.value,
            "onUpdate:modelValue": ($event) => isActive.value = $event,
            "aria-modal": "true",
            "activatorProps": activatorProps.value,
            "role": "dialog"
          }, scopeId), {
            activator: slots.activator,
            default: function() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return createVNode(VDefaultsProvider, {
                "root": "VDialog"
              }, {
                default: () => {
                  var _a2;
                  return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, ...args)];
                }
              });
            }
          });
        });
        return forwardRefs({}, overlay);
      }
    });
    function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createBlock(VDialog, {
        "model-value": _ctx.show_dialog,
        "onClick:outside": _ctx.deny,
        width: "auto"
      }, {
        default: withCtx(() => [
          createVNode(VCard, null, {
            default: withCtx(() => [
              createVNode(VCardTitle, { class: "d-flex flex-row align-baseline" }, {
                default: withCtx(() => [
                  createVNode(VIcon, {
                    size: "large",
                    color: "error"
                  }, {
                    default: withCtx(() => [
                      createTextVNode(" mdi-alert-circle ")
                    ]),
                    _: 1
                  }),
                  createTextVNode("  " + toDisplayString(_ctx.$props.title), 1)
                ]),
                _: 1
              }),
              createVNode(VCardText, null, {
                default: withCtx(() => [
                  createBaseVNode("p", null, toDisplayString(_ctx.$props.text), 1)
                ]),
                _: 1
              }),
              createVNode(VCardActions, null, {
                default: withCtx(() => [
                  createVNode(VBtn, {
                    color: "error",
                    onClick: _ctx.accept
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.$props.accept_text), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick"]),
                  createVNode(VBtn, { onClick: _ctx.deny }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.$props.deny_text), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick"])
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["model-value", "onClick:outside"]);
    }
    const EvDialog = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["render", _sfc_render$3]]);
    let evbcStore$1;
    let evbc$1;
    const _sfc_main$y = /* @__PURE__ */ defineComponent$1({
      data: () => {
        return {
          show_dialog: false,
          config_to_load: null
        };
      },
      created() {
        evbcStore$1 = useEvbcStore();
        evbc$1 = inject$1("evbc");
      },
      components: { EvDialog },
      computed: {
        current_config() {
          return evbcStore$1.get_current_config();
        },
        module_list() {
          return Object.entries(evbc$1.everest_definitions.modules).map(([key, value]) => ({
            type: key,
            description: value.description
          }));
        },
        config_list() {
          const configs = evbc$1._configs;
          return Object.entries(configs).map(([key]) => key);
        }
      },
      methods: {
        add_module_to_config(type2) {
          if (evbcStore$1.get_current_config()) {
            evbcStore$1.get_current_config().add_new_module_instance(type2);
          } else {
            const new_config = evbc$1.create_empty_config("test_config");
            new_config.add_new_module_instance(type2);
            evbcStore$1.setOpenedConfig(new_config);
          }
        },
        load_config_if_empty(name) {
          if (!this.current_config) {
            this.load_config(name);
            return;
          }
          this.config_to_load = name;
          this.show_dialog = true;
        },
        load_config(name) {
          if (!name)
            return;
          this.show_dialog = false;
          const new_config = evbc$1.load_config(name);
          evbcStore$1.setOpenedConfig(new_config);
        },
        restart_modules() {
          evbc$1._cxn.rpc_issuer.restart_modules();
        },
        close_dialog() {
          this.show_dialog = false;
        }
      }
    });
    const VExpansionPanelSymbol = Symbol.for("vuetify:v-expansion-panel");
    const allowedVariants = ["default", "accordion", "inset", "popout"];
    const makeVExpansionPanelsProps = propsFactory({
      color: String,
      flat: Boolean,
      static: Boolean,
      tile: Boolean,
      variant: {
        type: String,
        default: "default",
        validator: (v) => allowedVariants.includes(v)
      },
      readonly: Boolean,
      ...makeComponentProps(),
      ...makeGroupProps(),
      ...makeTagProps(),
      ...makeThemeProps()
    }, "VExpansionPanels");
    const VExpansionPanels = genericComponent()({
      name: "VExpansionPanels",
      props: makeVExpansionPanelsProps(),
      emits: {
        "update:modelValue": (val) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        useGroup(props, VExpansionPanelSymbol);
        const {
          themeClasses
        } = provideTheme(props);
        const variantClass = computed(() => props.variant && `v-expansion-panels--variant-${props.variant}`);
        provideDefaults({
          VExpansionPanel: {
            color: toRef(props, "color"),
            readonly: toRef(props, "readonly")
          },
          VExpansionPanelTitle: {
            static: toRef(props, "static")
          }
        });
        useRender(() => createVNode(props.tag, {
          "class": ["v-expansion-panels", {
            "v-expansion-panels--flat": props.flat,
            "v-expansion-panels--tile": props.tile
          }, themeClasses.value, variantClass.value, props.class],
          "style": props.style
        }, slots));
        return {};
      }
    });
    const makeVExpansionPanelTextProps = propsFactory({
      ...makeComponentProps(),
      ...makeLazyProps()
    }, "VExpansionPanelText");
    const VExpansionPanelText = genericComponent()({
      name: "VExpansionPanelText",
      props: makeVExpansionPanelTextProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const expansionPanel = inject$1(VExpansionPanelSymbol);
        if (!expansionPanel)
          throw new Error("[Vuetify] v-expansion-panel-text needs to be placed inside v-expansion-panel");
        const {
          hasContent,
          onAfterLeave
        } = useLazy(props, expansionPanel.isSelected);
        useRender(() => createVNode(VExpandTransition, {
          "onAfterLeave": onAfterLeave
        }, {
          default: () => {
            var _a2;
            return [withDirectives(createVNode("div", {
              "class": ["v-expansion-panel-text", props.class],
              "style": props.style
            }, [slots.default && hasContent.value && createVNode("div", {
              "class": "v-expansion-panel-text__wrapper"
            }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)])]), [[vShow, expansionPanel.isSelected.value]])];
          }
        }));
        return {};
      }
    });
    const makeVExpansionPanelTitleProps = propsFactory({
      color: String,
      expandIcon: {
        type: IconValue,
        default: "$expand"
      },
      collapseIcon: {
        type: IconValue,
        default: "$collapse"
      },
      hideActions: Boolean,
      static: Boolean,
      ripple: {
        type: [Boolean, Object],
        default: false
      },
      readonly: Boolean,
      ...makeComponentProps()
    }, "VExpansionPanelTitle");
    const VExpansionPanelTitle = genericComponent()({
      name: "VExpansionPanelTitle",
      directives: {
        Ripple
      },
      props: makeVExpansionPanelTitleProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const expansionPanel = inject$1(VExpansionPanelSymbol);
        if (!expansionPanel)
          throw new Error("[Vuetify] v-expansion-panel-title needs to be placed inside v-expansion-panel");
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(props, "color");
        const slotProps = computed(() => ({
          collapseIcon: props.collapseIcon,
          disabled: expansionPanel.disabled.value,
          expanded: expansionPanel.isSelected.value,
          expandIcon: props.expandIcon,
          readonly: props.readonly
        }));
        useRender(() => {
          var _a2;
          return withDirectives(createVNode("button", {
            "class": ["v-expansion-panel-title", {
              "v-expansion-panel-title--active": expansionPanel.isSelected.value,
              "v-expansion-panel-title--static": props.static
            }, backgroundColorClasses.value, props.class],
            "style": [backgroundColorStyles.value, props.style],
            "type": "button",
            "tabindex": expansionPanel.disabled.value ? -1 : void 0,
            "disabled": expansionPanel.disabled.value,
            "aria-expanded": expansionPanel.isSelected.value,
            "onClick": !props.readonly ? expansionPanel.toggle : void 0
          }, [createVNode("span", {
            "class": "v-expansion-panel-title__overlay"
          }, null), (_a2 = slots.default) == null ? void 0 : _a2.call(slots, slotProps.value), !props.hideActions && createVNode("span", {
            "class": "v-expansion-panel-title__icon"
          }, [slots.actions ? slots.actions(slotProps.value) : createVNode(VIcon, {
            "icon": expansionPanel.isSelected.value ? props.collapseIcon : props.expandIcon
          }, null)])]), [[resolveDirective("ripple"), props.ripple]]);
        });
        return {};
      }
    });
    const makeVExpansionPanelProps = propsFactory({
      title: String,
      text: String,
      bgColor: String,
      ...makeComponentProps(),
      ...makeElevationProps(),
      ...makeGroupItemProps(),
      ...makeLazyProps(),
      ...makeRoundedProps(),
      ...makeTagProps(),
      ...makeVExpansionPanelTitleProps()
    }, "VExpansionPanel");
    const VExpansionPanel = genericComponent()({
      name: "VExpansionPanel",
      props: makeVExpansionPanelProps(),
      emits: {
        "group:selected": (val) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const groupItem = useGroupItem(props, VExpansionPanelSymbol);
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(props, "bgColor");
        const {
          elevationClasses
        } = useElevation(props);
        const {
          roundedClasses
        } = useRounded(props);
        const isDisabled = computed(() => (groupItem == null ? void 0 : groupItem.disabled.value) || props.disabled);
        const selectedIndices = computed(() => groupItem.group.items.value.reduce((arr, item, index) => {
          if (groupItem.group.selected.value.includes(item.id))
            arr.push(index);
          return arr;
        }, []));
        const isBeforeSelected = computed(() => {
          const index = groupItem.group.items.value.findIndex((item) => item.id === groupItem.id);
          return !groupItem.isSelected.value && selectedIndices.value.some((selectedIndex) => selectedIndex - index === 1);
        });
        const isAfterSelected = computed(() => {
          const index = groupItem.group.items.value.findIndex((item) => item.id === groupItem.id);
          return !groupItem.isSelected.value && selectedIndices.value.some((selectedIndex) => selectedIndex - index === -1);
        });
        provide(VExpansionPanelSymbol, groupItem);
        provideDefaults({
          VExpansionPanelText: {
            eager: toRef(props, "eager")
          },
          VExpansionPanelTitle: {
            readonly: toRef(props, "readonly")
          }
        });
        useRender(() => {
          const hasText = !!(slots.text || props.text);
          const hasTitle = !!(slots.title || props.title);
          return createVNode(props.tag, {
            "class": ["v-expansion-panel", {
              "v-expansion-panel--active": groupItem.isSelected.value,
              "v-expansion-panel--before-active": isBeforeSelected.value,
              "v-expansion-panel--after-active": isAfterSelected.value,
              "v-expansion-panel--disabled": isDisabled.value
            }, roundedClasses.value, backgroundColorClasses.value, props.class],
            "style": [backgroundColorStyles.value, props.style]
          }, {
            default: () => {
              var _a2;
              return [createVNode("div", {
                "class": ["v-expansion-panel__shadow", ...elevationClasses.value]
              }, null), hasTitle && createVNode(VExpansionPanelTitle, {
                "key": "title",
                "collapseIcon": props.collapseIcon,
                "color": props.color,
                "expandIcon": props.expandIcon,
                "hideActions": props.hideActions,
                "ripple": props.ripple
              }, {
                default: () => [slots.title ? slots.title() : props.title]
              }), hasText && createVNode(VExpansionPanelText, {
                "key": "text"
              }, {
                default: () => [slots.text ? slots.text() : props.text]
              }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots)];
            }
          });
        });
        return {};
      }
    });
    function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ev_dialog = resolveComponent("ev-dialog");
      return openBlock(), createBlock(VExpansionPanels, { class: "ma-0" }, {
        default: withCtx(() => [
          createVNode(VExpansionPanel, null, {
            default: withCtx(() => [
              createVNode(VExpansionPanelTitle, null, {
                default: withCtx(() => [
                  createTextVNode(" Available modules")
                ]),
                _: 1
              }),
              createVNode(VExpansionPanelText, null, {
                default: withCtx(() => [
                  createVNode(VList, { class: "ma-0" }, {
                    default: withCtx(() => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.module_list, (module2) => {
                        return openBlock(), createBlock(VTooltip, {
                          location: "right",
                          key: module2.type,
                          "open-delay": "500"
                        }, {
                          activator: withCtx(({ props }) => [
                            createVNode(VListItem, mergeProps(props, {
                              title: module2.type,
                              onClick: withModifiers(($event) => _ctx.add_module_to_config(module2.type), ["stop"])
                            }), {
                              append: withCtx(() => [
                                createVNode(VIcon, null, {
                                  default: withCtx(() => [
                                    createTextVNode("mdi-plus")
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 2
                            }, 1040, ["title", "onClick"])
                          ]),
                          default: withCtx(() => [
                            createBaseVNode("span", null, toDisplayString(`${module2.type}: ${module2.description}`), 1)
                          ]),
                          _: 2
                        }, 1024);
                      }), 128))
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          createVNode(VExpansionPanel, {
            disabled: _ctx.config_list.length == 0
          }, {
            default: withCtx(() => [
              createVNode(VExpansionPanelTitle, null, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(_ctx.config_list.length == 0 ? "No configs available" : "Available configs"), 1)
                ]),
                _: 1
              }),
              createVNode(VExpansionPanelText, null, {
                default: withCtx(() => [
                  createVNode(VList, { class: "ma-0" }, {
                    default: withCtx(() => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.config_list, (config2) => {
                        return openBlock(), createBlock(VTooltip, {
                          location: "right",
                          key: config2,
                          "open-delay": "500"
                        }, {
                          activator: withCtx(({ props }) => [
                            createVNode(VListItem, mergeProps({ title: config2 }, props, {
                              onClick: ($event) => _ctx.load_config_if_empty(config2)
                            }), {
                              append: withCtx(() => [
                                createVNode(VIcon, null, {
                                  default: withCtx(() => [
                                    createTextVNode("mdi-upload")
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 2
                            }, 1040, ["title", "onClick"])
                          ]),
                          default: withCtx(() => [
                            createBaseVNode("span", null, toDisplayString(config2), 1)
                          ]),
                          _: 2
                        }, 1024);
                      }), 128))
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              createVNode(_component_ev_dialog, {
                show_dialog: _ctx.show_dialog,
                title: "Warning",
                text: "Do you want to discard the current config and load the new one?",
                accept_text: "Load config",
                deny_text: "Don't load config",
                onAccept: _cache[0] || (_cache[0] = ($event) => _ctx.load_config(_ctx.config_to_load)),
                onDeny: _cache[1] || (_cache[1] = ($event) => _ctx.close_dialog())
              }, null, 8, ["show_dialog"])
            ]),
            _: 1
          }, 8, ["disabled"]),
          createVNode(VExpansionPanel, null, {
            default: withCtx(() => [
              createVNode(VExpansionPanelTitle, null, {
                default: withCtx(() => [
                  createTextVNode(" Issue commands")
                ]),
                _: 1
              }),
              createVNode(VExpansionPanelText, null, {
                default: withCtx(() => [
                  createVNode(VList, null, {
                    default: withCtx(() => [
                      createVNode(VListItem, {
                        onClick: _cache[2] || (_cache[2] = ($event) => _ctx.restart_modules()),
                        title: "Restart modules"
                      }, {
                        append: withCtx(() => [
                          createVNode(VIcon, null, {
                            default: withCtx(() => [
                              createTextVNode("mdi-run")
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      });
    }
    const EvModuleList = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["render", _sfc_render$2]]);
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    function getAugmentedNamespace(n) {
      if (n.__esModule)
        return n;
      var f = n.default;
      if (typeof f == "function") {
        var a = function a2() {
          if (this instanceof a2) {
            return Reflect.construct(f, arguments, this.constructor);
          }
          return f.apply(this, arguments);
        };
        a.prototype = f.prototype;
      } else
        a = {};
      Object.defineProperty(a, "__esModule", { value: true });
      Object.keys(n).forEach(function(k) {
        var d = Object.getOwnPropertyDescriptor(n, k);
        Object.defineProperty(a, k, d.get ? d : {
          enumerable: true,
          get: function() {
            return n[k];
          }
        });
      });
      return a;
    }
    var _2019 = { exports: {} };
    var core$3 = {};
    var validate = {};
    var boolSchema = {};
    var errors$1 = {};
    var codegen = {};
    var code$2 = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.regexpCode = exports2.getEsmExportName = exports2.getProperty = exports2.safeStringify = exports2.stringify = exports2.strConcat = exports2.addCodeArg = exports2.str = exports2._ = exports2.nil = exports2._Code = exports2.Name = exports2.IDENTIFIER = exports2._CodeOrName = void 0;
      class _CodeOrName {
      }
      exports2._CodeOrName = _CodeOrName;
      exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
      class Name extends _CodeOrName {
        constructor(s) {
          super();
          if (!exports2.IDENTIFIER.test(s))
            throw new Error("CodeGen: name must be a valid identifier");
          this.str = s;
        }
        toString() {
          return this.str;
        }
        emptyStr() {
          return false;
        }
        get names() {
          return { [this.str]: 1 };
        }
      }
      exports2.Name = Name;
      class _Code extends _CodeOrName {
        constructor(code2) {
          super();
          this._items = typeof code2 === "string" ? [code2] : code2;
        }
        toString() {
          return this.str;
        }
        emptyStr() {
          if (this._items.length > 1)
            return false;
          const item = this._items[0];
          return item === "" || item === '""';
        }
        get str() {
          var _a2;
          return (_a2 = this._str) !== null && _a2 !== void 0 ? _a2 : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
        }
        get names() {
          var _a2;
          return (_a2 = this._names) !== null && _a2 !== void 0 ? _a2 : this._names = this._items.reduce((names2, c) => {
            if (c instanceof Name)
              names2[c.str] = (names2[c.str] || 0) + 1;
            return names2;
          }, {});
        }
      }
      exports2._Code = _Code;
      exports2.nil = new _Code("");
      function _(strs, ...args) {
        const code2 = [strs[0]];
        let i2 = 0;
        while (i2 < args.length) {
          addCodeArg(code2, args[i2]);
          code2.push(strs[++i2]);
        }
        return new _Code(code2);
      }
      exports2._ = _;
      const plus2 = new _Code("+");
      function str(strs, ...args) {
        const expr = [safeStringify(strs[0])];
        let i2 = 0;
        while (i2 < args.length) {
          expr.push(plus2);
          addCodeArg(expr, args[i2]);
          expr.push(plus2, safeStringify(strs[++i2]));
        }
        optimize(expr);
        return new _Code(expr);
      }
      exports2.str = str;
      function addCodeArg(code2, arg) {
        if (arg instanceof _Code)
          code2.push(...arg._items);
        else if (arg instanceof Name)
          code2.push(arg);
        else
          code2.push(interpolate(arg));
      }
      exports2.addCodeArg = addCodeArg;
      function optimize(expr) {
        let i2 = 1;
        while (i2 < expr.length - 1) {
          if (expr[i2] === plus2) {
            const res = mergeExprItems(expr[i2 - 1], expr[i2 + 1]);
            if (res !== void 0) {
              expr.splice(i2 - 1, 3, res);
              continue;
            }
            expr[i2++] = "+";
          }
          i2++;
        }
      }
      function mergeExprItems(a, b) {
        if (b === '""')
          return a;
        if (a === '""')
          return b;
        if (typeof a == "string") {
          if (b instanceof Name || a[a.length - 1] !== '"')
            return;
          if (typeof b != "string")
            return `${a.slice(0, -1)}${b}"`;
          if (b[0] === '"')
            return a.slice(0, -1) + b.slice(1);
          return;
        }
        if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
          return `"${a}${b.slice(1)}`;
        return;
      }
      function strConcat(c1, c2) {
        return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
      }
      exports2.strConcat = strConcat;
      function interpolate(x) {
        return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
      }
      function stringify(x) {
        return new _Code(safeStringify(x));
      }
      exports2.stringify = stringify;
      function safeStringify(x) {
        return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      }
      exports2.safeStringify = safeStringify;
      function getProperty(key) {
        return typeof key == "string" && exports2.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
      }
      exports2.getProperty = getProperty;
      function getEsmExportName(key) {
        if (typeof key == "string" && exports2.IDENTIFIER.test(key)) {
          return new _Code(`${key}`);
        }
        throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
      }
      exports2.getEsmExportName = getEsmExportName;
      function regexpCode(rx2) {
        return new _Code(rx2.toString());
      }
      exports2.regexpCode = regexpCode;
    })(code$2);
    var scope = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ValueScope = exports2.ValueScopeName = exports2.Scope = exports2.varKinds = exports2.UsedValueState = void 0;
      const code_12 = code$2;
      class ValueError extends Error {
        constructor(name) {
          super(`CodeGen: "code" for ${name} not defined`);
          this.value = name.value;
        }
      }
      var UsedValueState;
      (function(UsedValueState2) {
        UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
        UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
      })(UsedValueState = exports2.UsedValueState || (exports2.UsedValueState = {}));
      exports2.varKinds = {
        const: new code_12.Name("const"),
        let: new code_12.Name("let"),
        var: new code_12.Name("var")
      };
      class Scope {
        constructor({ prefixes: prefixes2, parent } = {}) {
          this._names = {};
          this._prefixes = prefixes2;
          this._parent = parent;
        }
        toName(nameOrPrefix) {
          return nameOrPrefix instanceof code_12.Name ? nameOrPrefix : this.name(nameOrPrefix);
        }
        name(prefix) {
          return new code_12.Name(this._newName(prefix));
        }
        _newName(prefix) {
          const ng = this._names[prefix] || this._nameGroup(prefix);
          return `${prefix}${ng.index++}`;
        }
        _nameGroup(prefix) {
          var _a2, _b;
          if (((_b = (_a2 = this._parent) === null || _a2 === void 0 ? void 0 : _a2._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
            throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
          }
          return this._names[prefix] = { prefix, index: 0 };
        }
      }
      exports2.Scope = Scope;
      class ValueScopeName extends code_12.Name {
        constructor(prefix, nameStr) {
          super(nameStr);
          this.prefix = prefix;
        }
        setValue(value, { property, itemIndex }) {
          this.value = value;
          this.scopePath = (0, code_12._)`.${new code_12.Name(property)}[${itemIndex}]`;
        }
      }
      exports2.ValueScopeName = ValueScopeName;
      const line = (0, code_12._)`\n`;
      class ValueScope extends Scope {
        constructor(opts) {
          super(opts);
          this._values = {};
          this._scope = opts.scope;
          this.opts = { ...opts, _n: opts.lines ? line : code_12.nil };
        }
        get() {
          return this._scope;
        }
        name(prefix) {
          return new ValueScopeName(prefix, this._newName(prefix));
        }
        value(nameOrPrefix, value) {
          var _a2;
          if (value.ref === void 0)
            throw new Error("CodeGen: ref must be passed in value");
          const name = this.toName(nameOrPrefix);
          const { prefix } = name;
          const valueKey = (_a2 = value.key) !== null && _a2 !== void 0 ? _a2 : value.ref;
          let vs = this._values[prefix];
          if (vs) {
            const _name = vs.get(valueKey);
            if (_name)
              return _name;
          } else {
            vs = this._values[prefix] = /* @__PURE__ */ new Map();
          }
          vs.set(valueKey, name);
          const s = this._scope[prefix] || (this._scope[prefix] = []);
          const itemIndex = s.length;
          s[itemIndex] = value.ref;
          name.setValue(value, { property: prefix, itemIndex });
          return name;
        }
        getValue(prefix, keyOrRef) {
          const vs = this._values[prefix];
          if (!vs)
            return;
          return vs.get(keyOrRef);
        }
        scopeRefs(scopeName, values = this._values) {
          return this._reduceValues(values, (name) => {
            if (name.scopePath === void 0)
              throw new Error(`CodeGen: name "${name}" has no value`);
            return (0, code_12._)`${scopeName}${name.scopePath}`;
          });
        }
        scopeCode(values = this._values, usedValues, getCode) {
          return this._reduceValues(values, (name) => {
            if (name.value === void 0)
              throw new Error(`CodeGen: name "${name}" has no value`);
            return name.value.code;
          }, usedValues, getCode);
        }
        _reduceValues(values, valueCode, usedValues = {}, getCode) {
          let code2 = code_12.nil;
          for (const prefix in values) {
            const vs = values[prefix];
            if (!vs)
              continue;
            const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
            vs.forEach((name) => {
              if (nameSet.has(name))
                return;
              nameSet.set(name, UsedValueState.Started);
              let c = valueCode(name);
              if (c) {
                const def2 = this.opts.es5 ? exports2.varKinds.var : exports2.varKinds.const;
                code2 = (0, code_12._)`${code2}${def2} ${name} = ${c};${this.opts._n}`;
              } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
                code2 = (0, code_12._)`${code2}${c}${this.opts._n}`;
              } else {
                throw new ValueError(name);
              }
              nameSet.set(name, UsedValueState.Completed);
            });
          }
          return code2;
        }
      }
      exports2.ValueScope = ValueScope;
    })(scope);
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.or = exports2.and = exports2.not = exports2.CodeGen = exports2.operators = exports2.varKinds = exports2.ValueScopeName = exports2.ValueScope = exports2.Scope = exports2.Name = exports2.regexpCode = exports2.stringify = exports2.getProperty = exports2.nil = exports2.strConcat = exports2.str = exports2._ = void 0;
      const code_12 = code$2;
      const scope_1 = scope;
      var code_2 = code$2;
      Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
        return code_2._;
      } });
      Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
        return code_2.str;
      } });
      Object.defineProperty(exports2, "strConcat", { enumerable: true, get: function() {
        return code_2.strConcat;
      } });
      Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
        return code_2.nil;
      } });
      Object.defineProperty(exports2, "getProperty", { enumerable: true, get: function() {
        return code_2.getProperty;
      } });
      Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
        return code_2.stringify;
      } });
      Object.defineProperty(exports2, "regexpCode", { enumerable: true, get: function() {
        return code_2.regexpCode;
      } });
      Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
        return code_2.Name;
      } });
      var scope_2 = scope;
      Object.defineProperty(exports2, "Scope", { enumerable: true, get: function() {
        return scope_2.Scope;
      } });
      Object.defineProperty(exports2, "ValueScope", { enumerable: true, get: function() {
        return scope_2.ValueScope;
      } });
      Object.defineProperty(exports2, "ValueScopeName", { enumerable: true, get: function() {
        return scope_2.ValueScopeName;
      } });
      Object.defineProperty(exports2, "varKinds", { enumerable: true, get: function() {
        return scope_2.varKinds;
      } });
      exports2.operators = {
        GT: new code_12._Code(">"),
        GTE: new code_12._Code(">="),
        LT: new code_12._Code("<"),
        LTE: new code_12._Code("<="),
        EQ: new code_12._Code("==="),
        NEQ: new code_12._Code("!=="),
        NOT: new code_12._Code("!"),
        OR: new code_12._Code("||"),
        AND: new code_12._Code("&&"),
        ADD: new code_12._Code("+")
      };
      class Node2 {
        optimizeNodes() {
          return this;
        }
        optimizeNames(_names, _constants) {
          return this;
        }
      }
      class Def extends Node2 {
        constructor(varKind, name, rhs) {
          super();
          this.varKind = varKind;
          this.name = name;
          this.rhs = rhs;
        }
        render({ es5, _n }) {
          const varKind = es5 ? scope_1.varKinds.var : this.varKind;
          const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
          return `${varKind} ${this.name}${rhs};` + _n;
        }
        optimizeNames(names2, constants) {
          if (!names2[this.name.str])
            return;
          if (this.rhs)
            this.rhs = optimizeExpr(this.rhs, names2, constants);
          return this;
        }
        get names() {
          return this.rhs instanceof code_12._CodeOrName ? this.rhs.names : {};
        }
      }
      class Assign2 extends Node2 {
        constructor(lhs, rhs, sideEffects) {
          super();
          this.lhs = lhs;
          this.rhs = rhs;
          this.sideEffects = sideEffects;
        }
        render({ _n }) {
          return `${this.lhs} = ${this.rhs};` + _n;
        }
        optimizeNames(names2, constants) {
          if (this.lhs instanceof code_12.Name && !names2[this.lhs.str] && !this.sideEffects)
            return;
          this.rhs = optimizeExpr(this.rhs, names2, constants);
          return this;
        }
        get names() {
          const names2 = this.lhs instanceof code_12.Name ? {} : { ...this.lhs.names };
          return addExprNames(names2, this.rhs);
        }
      }
      class AssignOp extends Assign2 {
        constructor(lhs, op, rhs, sideEffects) {
          super(lhs, rhs, sideEffects);
          this.op = op;
        }
        render({ _n }) {
          return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
        }
      }
      class Label2 extends Node2 {
        constructor(label) {
          super();
          this.label = label;
          this.names = {};
        }
        render({ _n }) {
          return `${this.label}:` + _n;
        }
      }
      class Break extends Node2 {
        constructor(label) {
          super();
          this.label = label;
          this.names = {};
        }
        render({ _n }) {
          const label = this.label ? ` ${this.label}` : "";
          return `break${label};` + _n;
        }
      }
      class Throw extends Node2 {
        constructor(error2) {
          super();
          this.error = error2;
        }
        render({ _n }) {
          return `throw ${this.error};` + _n;
        }
        get names() {
          return this.error.names;
        }
      }
      class AnyCode extends Node2 {
        constructor(code2) {
          super();
          this.code = code2;
        }
        render({ _n }) {
          return `${this.code};` + _n;
        }
        optimizeNodes() {
          return `${this.code}` ? this : void 0;
        }
        optimizeNames(names2, constants) {
          this.code = optimizeExpr(this.code, names2, constants);
          return this;
        }
        get names() {
          return this.code instanceof code_12._CodeOrName ? this.code.names : {};
        }
      }
      class ParentNode extends Node2 {
        constructor(nodes = []) {
          super();
          this.nodes = nodes;
        }
        render(opts) {
          return this.nodes.reduce((code2, n) => code2 + n.render(opts), "");
        }
        optimizeNodes() {
          const { nodes } = this;
          let i2 = nodes.length;
          while (i2--) {
            const n = nodes[i2].optimizeNodes();
            if (Array.isArray(n))
              nodes.splice(i2, 1, ...n);
            else if (n)
              nodes[i2] = n;
            else
              nodes.splice(i2, 1);
          }
          return nodes.length > 0 ? this : void 0;
        }
        optimizeNames(names2, constants) {
          const { nodes } = this;
          let i2 = nodes.length;
          while (i2--) {
            const n = nodes[i2];
            if (n.optimizeNames(names2, constants))
              continue;
            subtractNames(names2, n.names);
            nodes.splice(i2, 1);
          }
          return nodes.length > 0 ? this : void 0;
        }
        get names() {
          return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
        }
      }
      class BlockNode extends ParentNode {
        render(opts) {
          return "{" + opts._n + super.render(opts) + "}" + opts._n;
        }
      }
      class Root extends ParentNode {
      }
      class Else extends BlockNode {
      }
      Else.kind = "else";
      class If extends BlockNode {
        constructor(condition, nodes) {
          super(nodes);
          this.condition = condition;
        }
        render(opts) {
          let code2 = `if(${this.condition})` + super.render(opts);
          if (this.else)
            code2 += "else " + this.else.render(opts);
          return code2;
        }
        optimizeNodes() {
          super.optimizeNodes();
          const cond = this.condition;
          if (cond === true)
            return this.nodes;
          let e = this.else;
          if (e) {
            const ns = e.optimizeNodes();
            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
          }
          if (e) {
            if (cond === false)
              return e instanceof If ? e : e.nodes;
            if (this.nodes.length)
              return this;
            return new If(not2(cond), e instanceof If ? [e] : e.nodes);
          }
          if (cond === false || !this.nodes.length)
            return void 0;
          return this;
        }
        optimizeNames(names2, constants) {
          var _a2;
          this.else = (_a2 = this.else) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names2, constants);
          if (!(super.optimizeNames(names2, constants) || this.else))
            return;
          this.condition = optimizeExpr(this.condition, names2, constants);
          return this;
        }
        get names() {
          const names2 = super.names;
          addExprNames(names2, this.condition);
          if (this.else)
            addNames(names2, this.else.names);
          return names2;
        }
      }
      If.kind = "if";
      class For extends BlockNode {
      }
      For.kind = "for";
      class ForLoop extends For {
        constructor(iteration) {
          super();
          this.iteration = iteration;
        }
        render(opts) {
          return `for(${this.iteration})` + super.render(opts);
        }
        optimizeNames(names2, constants) {
          if (!super.optimizeNames(names2, constants))
            return;
          this.iteration = optimizeExpr(this.iteration, names2, constants);
          return this;
        }
        get names() {
          return addNames(super.names, this.iteration.names);
        }
      }
      class ForRange extends For {
        constructor(varKind, name, from, to) {
          super();
          this.varKind = varKind;
          this.name = name;
          this.from = from;
          this.to = to;
        }
        render(opts) {
          const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
          const { name, from, to } = this;
          return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
        }
        get names() {
          const names2 = addExprNames(super.names, this.from);
          return addExprNames(names2, this.to);
        }
      }
      class ForIter extends For {
        constructor(loop, varKind, name, iterable) {
          super();
          this.loop = loop;
          this.varKind = varKind;
          this.name = name;
          this.iterable = iterable;
        }
        render(opts) {
          return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
        }
        optimizeNames(names2, constants) {
          if (!super.optimizeNames(names2, constants))
            return;
          this.iterable = optimizeExpr(this.iterable, names2, constants);
          return this;
        }
        get names() {
          return addNames(super.names, this.iterable.names);
        }
      }
      class Func extends BlockNode {
        constructor(name, args, async) {
          super();
          this.name = name;
          this.args = args;
          this.async = async;
        }
        render(opts) {
          const _async = this.async ? "async " : "";
          return `${_async}function ${this.name}(${this.args})` + super.render(opts);
        }
      }
      Func.kind = "func";
      class Return extends ParentNode {
        render(opts) {
          return "return " + super.render(opts);
        }
      }
      Return.kind = "return";
      class Try extends BlockNode {
        render(opts) {
          let code2 = "try" + super.render(opts);
          if (this.catch)
            code2 += this.catch.render(opts);
          if (this.finally)
            code2 += this.finally.render(opts);
          return code2;
        }
        optimizeNodes() {
          var _a2, _b;
          super.optimizeNodes();
          (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNodes();
          (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
          return this;
        }
        optimizeNames(names2, constants) {
          var _a2, _b;
          super.optimizeNames(names2, constants);
          (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names2, constants);
          (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants);
          return this;
        }
        get names() {
          const names2 = super.names;
          if (this.catch)
            addNames(names2, this.catch.names);
          if (this.finally)
            addNames(names2, this.finally.names);
          return names2;
        }
      }
      class Catch extends BlockNode {
        constructor(error2) {
          super();
          this.error = error2;
        }
        render(opts) {
          return `catch(${this.error})` + super.render(opts);
        }
      }
      Catch.kind = "catch";
      class Finally extends BlockNode {
        render(opts) {
          return "finally" + super.render(opts);
        }
      }
      Finally.kind = "finally";
      class CodeGen {
        constructor(extScope, opts = {}) {
          this._values = {};
          this._blockStarts = [];
          this._constants = {};
          this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
          this._extScope = extScope;
          this._scope = new scope_1.Scope({ parent: extScope });
          this._nodes = [new Root()];
        }
        toString() {
          return this._root.render(this.opts);
        }
        // returns unique name in the internal scope
        name(prefix) {
          return this._scope.name(prefix);
        }
        // reserves unique name in the external scope
        scopeName(prefix) {
          return this._extScope.name(prefix);
        }
        // reserves unique name in the external scope and assigns value to it
        scopeValue(prefixOrName, value) {
          const name = this._extScope.value(prefixOrName, value);
          const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
          vs.add(name);
          return name;
        }
        getScopeValue(prefix, keyOrRef) {
          return this._extScope.getValue(prefix, keyOrRef);
        }
        // return code that assigns values in the external scope to the names that are used internally
        // (same names that were returned by gen.scopeName or gen.scopeValue)
        scopeRefs(scopeName) {
          return this._extScope.scopeRefs(scopeName, this._values);
        }
        scopeCode() {
          return this._extScope.scopeCode(this._values);
        }
        _def(varKind, nameOrPrefix, rhs, constant) {
          const name = this._scope.toName(nameOrPrefix);
          if (rhs !== void 0 && constant)
            this._constants[name.str] = rhs;
          this._leafNode(new Def(varKind, name, rhs));
          return name;
        }
        // `const` declaration (`var` in es5 mode)
        const(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
        }
        // `let` declaration with optional assignment (`var` in es5 mode)
        let(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
        }
        // `var` declaration with optional assignment
        var(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
        }
        // assignment code
        assign(lhs, rhs, sideEffects) {
          return this._leafNode(new Assign2(lhs, rhs, sideEffects));
        }
        // `+=` code
        add(lhs, rhs) {
          return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));
        }
        // appends passed SafeExpr to code or executes Block
        code(c) {
          if (typeof c == "function")
            c();
          else if (c !== code_12.nil)
            this._leafNode(new AnyCode(c));
          return this;
        }
        // returns code for object literal for the passed argument list of key-value pairs
        object(...keyValues2) {
          const code2 = ["{"];
          for (const [key, value] of keyValues2) {
            if (code2.length > 1)
              code2.push(",");
            code2.push(key);
            if (key !== value || this.opts.es5) {
              code2.push(":");
              (0, code_12.addCodeArg)(code2, value);
            }
          }
          code2.push("}");
          return new code_12._Code(code2);
        }
        // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
        if(condition, thenBody, elseBody) {
          this._blockNode(new If(condition));
          if (thenBody && elseBody) {
            this.code(thenBody).else().code(elseBody).endIf();
          } else if (thenBody) {
            this.code(thenBody).endIf();
          } else if (elseBody) {
            throw new Error('CodeGen: "else" body without "then" body');
          }
          return this;
        }
        // `else if` clause - invalid without `if` or after `else` clauses
        elseIf(condition) {
          return this._elseNode(new If(condition));
        }
        // `else` clause - only valid after `if` or `else if` clauses
        else() {
          return this._elseNode(new Else());
        }
        // end `if` statement (needed if gen.if was used only with condition)
        endIf() {
          return this._endBlockNode(If, Else);
        }
        _for(node, forBody) {
          this._blockNode(node);
          if (forBody)
            this.code(forBody).endFor();
          return this;
        }
        // a generic `for` clause (or statement if `forBody` is passed)
        for(iteration, forBody) {
          return this._for(new ForLoop(iteration), forBody);
        }
        // `for` statement for a range of values
        forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
          const name = this._scope.toName(nameOrPrefix);
          return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
        }
        // `for-of` statement (in es5 mode replace with a normal for loop)
        forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
          const name = this._scope.toName(nameOrPrefix);
          if (this.opts.es5) {
            const arr = iterable instanceof code_12.Name ? iterable : this.var("_arr", iterable);
            return this.forRange("_i", 0, (0, code_12._)`${arr}.length`, (i2) => {
              this.var(name, (0, code_12._)`${arr}[${i2}]`);
              forBody(name);
            });
          }
          return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
        }
        // `for-in` statement.
        // With option `ownProperties` replaced with a `for-of` loop for object keys
        forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
          if (this.opts.ownProperties) {
            return this.forOf(nameOrPrefix, (0, code_12._)`Object.keys(${obj})`, forBody);
          }
          const name = this._scope.toName(nameOrPrefix);
          return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
        }
        // end `for` loop
        endFor() {
          return this._endBlockNode(For);
        }
        // `label` statement
        label(label) {
          return this._leafNode(new Label2(label));
        }
        // `break` statement
        break(label) {
          return this._leafNode(new Break(label));
        }
        // `return` statement
        return(value) {
          const node = new Return();
          this._blockNode(node);
          this.code(value);
          if (node.nodes.length !== 1)
            throw new Error('CodeGen: "return" should have one node');
          return this._endBlockNode(Return);
        }
        // `try` statement
        try(tryBody, catchCode, finallyCode) {
          if (!catchCode && !finallyCode)
            throw new Error('CodeGen: "try" without "catch" and "finally"');
          const node = new Try();
          this._blockNode(node);
          this.code(tryBody);
          if (catchCode) {
            const error2 = this.name("e");
            this._currNode = node.catch = new Catch(error2);
            catchCode(error2);
          }
          if (finallyCode) {
            this._currNode = node.finally = new Finally();
            this.code(finallyCode);
          }
          return this._endBlockNode(Catch, Finally);
        }
        // `throw` statement
        throw(error2) {
          return this._leafNode(new Throw(error2));
        }
        // start self-balancing block
        block(body, nodeCount) {
          this._blockStarts.push(this._nodes.length);
          if (body)
            this.code(body).endBlock(nodeCount);
          return this;
        }
        // end the current self-balancing block
        endBlock(nodeCount) {
          const len = this._blockStarts.pop();
          if (len === void 0)
            throw new Error("CodeGen: not in self-balancing block");
          const toClose = this._nodes.length - len;
          if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
          }
          this._nodes.length = len;
          return this;
        }
        // `function` heading (or definition if funcBody is passed)
        func(name, args = code_12.nil, async, funcBody) {
          this._blockNode(new Func(name, args, async));
          if (funcBody)
            this.code(funcBody).endFunc();
          return this;
        }
        // end function definition
        endFunc() {
          return this._endBlockNode(Func);
        }
        optimize(n = 1) {
          while (n-- > 0) {
            this._root.optimizeNodes();
            this._root.optimizeNames(this._root.names, this._constants);
          }
        }
        _leafNode(node) {
          this._currNode.nodes.push(node);
          return this;
        }
        _blockNode(node) {
          this._currNode.nodes.push(node);
          this._nodes.push(node);
        }
        _endBlockNode(N1, N2) {
          const n = this._currNode;
          if (n instanceof N1 || N2 && n instanceof N2) {
            this._nodes.pop();
            return this;
          }
          throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
        }
        _elseNode(node) {
          const n = this._currNode;
          if (!(n instanceof If)) {
            throw new Error('CodeGen: "else" without "if"');
          }
          this._currNode = n.else = node;
          return this;
        }
        get _root() {
          return this._nodes[0];
        }
        get _currNode() {
          const ns = this._nodes;
          return ns[ns.length - 1];
        }
        set _currNode(node) {
          const ns = this._nodes;
          ns[ns.length - 1] = node;
        }
      }
      exports2.CodeGen = CodeGen;
      function addNames(names2, from) {
        for (const n in from)
          names2[n] = (names2[n] || 0) + (from[n] || 0);
        return names2;
      }
      function addExprNames(names2, from) {
        return from instanceof code_12._CodeOrName ? addNames(names2, from.names) : names2;
      }
      function optimizeExpr(expr, names2, constants) {
        if (expr instanceof code_12.Name)
          return replaceName(expr);
        if (!canOptimize(expr))
          return expr;
        return new code_12._Code(expr._items.reduce((items2, c) => {
          if (c instanceof code_12.Name)
            c = replaceName(c);
          if (c instanceof code_12._Code)
            items2.push(...c._items);
          else
            items2.push(c);
          return items2;
        }, []));
        function replaceName(n) {
          const c = constants[n.str];
          if (c === void 0 || names2[n.str] !== 1)
            return n;
          delete names2[n.str];
          return c;
        }
        function canOptimize(e) {
          return e instanceof code_12._Code && e._items.some((c) => c instanceof code_12.Name && names2[c.str] === 1 && constants[c.str] !== void 0);
        }
      }
      function subtractNames(names2, from) {
        for (const n in from)
          names2[n] = (names2[n] || 0) - (from[n] || 0);
      }
      function not2(x) {
        return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_12._)`!${par2(x)}`;
      }
      exports2.not = not2;
      const andCode = mappend(exports2.operators.AND);
      function and2(...args) {
        return args.reduce(andCode);
      }
      exports2.and = and2;
      const orCode = mappend(exports2.operators.OR);
      function or2(...args) {
        return args.reduce(orCode);
      }
      exports2.or = or2;
      function mappend(op) {
        return (x, y) => x === code_12.nil ? y : y === code_12.nil ? x : (0, code_12._)`${par2(x)} ${op} ${par2(y)}`;
      }
      function par2(x) {
        return x instanceof code_12.Name ? x : (0, code_12._)`(${x})`;
      }
    })(codegen);
    var util = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.checkStrictMode = exports2.getErrorPath = exports2.Type = exports2.useFunc = exports2.setEvaluated = exports2.evaluatedPropsToName = exports2.mergeEvaluated = exports2.eachItem = exports2.unescapeJsonPointer = exports2.escapeJsonPointer = exports2.escapeFragment = exports2.unescapeFragment = exports2.schemaRefOrVal = exports2.schemaHasRulesButRef = exports2.schemaHasRules = exports2.checkUnknownRules = exports2.alwaysValidSchema = exports2.toHash = void 0;
      const codegen_12 = codegen;
      const code_12 = code$2;
      function toHash(arr) {
        const hash = {};
        for (const item of arr)
          hash[item] = true;
        return hash;
      }
      exports2.toHash = toHash;
      function alwaysValidSchema(it2, schema) {
        if (typeof schema == "boolean")
          return schema;
        if (Object.keys(schema).length === 0)
          return true;
        checkUnknownRules(it2, schema);
        return !schemaHasRules(schema, it2.self.RULES.all);
      }
      exports2.alwaysValidSchema = alwaysValidSchema;
      function checkUnknownRules(it2, schema = it2.schema) {
        const { opts, self: self2 } = it2;
        if (!opts.strictSchema)
          return;
        if (typeof schema === "boolean")
          return;
        const rules2 = self2.RULES.keywords;
        for (const key in schema) {
          if (!rules2[key])
            checkStrictMode(it2, `unknown keyword: "${key}"`);
        }
      }
      exports2.checkUnknownRules = checkUnknownRules;
      function schemaHasRules(schema, rules2) {
        if (typeof schema == "boolean")
          return !schema;
        for (const key in schema)
          if (rules2[key])
            return true;
        return false;
      }
      exports2.schemaHasRules = schemaHasRules;
      function schemaHasRulesButRef(schema, RULES2) {
        if (typeof schema == "boolean")
          return !schema;
        for (const key in schema)
          if (key !== "$ref" && RULES2.all[key])
            return true;
        return false;
      }
      exports2.schemaHasRulesButRef = schemaHasRulesButRef;
      function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword2, $data) {
        if (!$data) {
          if (typeof schema == "number" || typeof schema == "boolean")
            return schema;
          if (typeof schema == "string")
            return (0, codegen_12._)`${schema}`;
        }
        return (0, codegen_12._)`${topSchemaRef}${schemaPath}${(0, codegen_12.getProperty)(keyword2)}`;
      }
      exports2.schemaRefOrVal = schemaRefOrVal;
      function unescapeFragment(str) {
        return unescapeJsonPointer(decodeURIComponent(str));
      }
      exports2.unescapeFragment = unescapeFragment;
      function escapeFragment(str) {
        return encodeURIComponent(escapeJsonPointer(str));
      }
      exports2.escapeFragment = escapeFragment;
      function escapeJsonPointer(str) {
        if (typeof str == "number")
          return `${str}`;
        return str.replace(/~/g, "~0").replace(/\//g, "~1");
      }
      exports2.escapeJsonPointer = escapeJsonPointer;
      function unescapeJsonPointer(str) {
        return str.replace(/~1/g, "/").replace(/~0/g, "~");
      }
      exports2.unescapeJsonPointer = unescapeJsonPointer;
      function eachItem(xs, f) {
        if (Array.isArray(xs)) {
          for (const x of xs)
            f(x);
        } else {
          f(xs);
        }
      }
      exports2.eachItem = eachItem;
      function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
        return (gen, from, to, toName) => {
          const res = to === void 0 ? from : to instanceof codegen_12.Name ? (from instanceof codegen_12.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_12.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
          return toName === codegen_12.Name && !(res instanceof codegen_12.Name) ? resultToName(gen, res) : res;
        };
      }
      exports2.mergeEvaluated = {
        props: makeMergeEvaluated({
          mergeNames: (gen, from, to) => gen.if((0, codegen_12._)`${to} !== true && ${from} !== undefined`, () => {
            gen.if((0, codegen_12._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_12._)`${to} || {}`).code((0, codegen_12._)`Object.assign(${to}, ${from})`));
          }),
          mergeToName: (gen, from, to) => gen.if((0, codegen_12._)`${to} !== true`, () => {
            if (from === true) {
              gen.assign(to, true);
            } else {
              gen.assign(to, (0, codegen_12._)`${to} || {}`);
              setEvaluated(gen, to, from);
            }
          }),
          mergeValues: (from, to) => from === true ? true : { ...from, ...to },
          resultToName: evaluatedPropsToName
        }),
        items: makeMergeEvaluated({
          mergeNames: (gen, from, to) => gen.if((0, codegen_12._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_12._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
          mergeToName: (gen, from, to) => gen.if((0, codegen_12._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_12._)`${to} > ${from} ? ${to} : ${from}`)),
          mergeValues: (from, to) => from === true ? true : Math.max(from, to),
          resultToName: (gen, items2) => gen.var("items", items2)
        })
      };
      function evaluatedPropsToName(gen, ps) {
        if (ps === true)
          return gen.var("props", true);
        const props = gen.var("props", (0, codegen_12._)`{}`);
        if (ps !== void 0)
          setEvaluated(gen, props, ps);
        return props;
      }
      exports2.evaluatedPropsToName = evaluatedPropsToName;
      function setEvaluated(gen, props, ps) {
        Object.keys(ps).forEach((p2) => gen.assign((0, codegen_12._)`${props}${(0, codegen_12.getProperty)(p2)}`, true));
      }
      exports2.setEvaluated = setEvaluated;
      const snippets = {};
      function useFunc(gen, f) {
        return gen.scopeValue("func", {
          ref: f,
          code: snippets[f.code] || (snippets[f.code] = new code_12._Code(f.code))
        });
      }
      exports2.useFunc = useFunc;
      var Type;
      (function(Type2) {
        Type2[Type2["Num"] = 0] = "Num";
        Type2[Type2["Str"] = 1] = "Str";
      })(Type = exports2.Type || (exports2.Type = {}));
      function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
        if (dataProp instanceof codegen_12.Name) {
          const isNumber = dataPropType === Type.Num;
          return jsPropertySyntax ? isNumber ? (0, codegen_12._)`"[" + ${dataProp} + "]"` : (0, codegen_12._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_12._)`"/" + ${dataProp}` : (0, codegen_12._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
        }
        return jsPropertySyntax ? (0, codegen_12.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
      }
      exports2.getErrorPath = getErrorPath;
      function checkStrictMode(it2, msg, mode = it2.opts.strictSchema) {
        if (!mode)
          return;
        msg = `strict mode: ${msg}`;
        if (mode === true)
          throw new Error(msg);
        it2.self.logger.warn(msg);
      }
      exports2.checkStrictMode = checkStrictMode;
    })(util);
    var names$2 = {};
    Object.defineProperty(names$2, "__esModule", { value: true });
    const codegen_1$x = codegen;
    const names$1 = {
      // validation function arguments
      data: new codegen_1$x.Name("data"),
      // args passed from referencing schema
      valCxt: new codegen_1$x.Name("valCxt"),
      instancePath: new codegen_1$x.Name("instancePath"),
      parentData: new codegen_1$x.Name("parentData"),
      parentDataProperty: new codegen_1$x.Name("parentDataProperty"),
      rootData: new codegen_1$x.Name("rootData"),
      dynamicAnchors: new codegen_1$x.Name("dynamicAnchors"),
      // function scoped variables
      vErrors: new codegen_1$x.Name("vErrors"),
      errors: new codegen_1$x.Name("errors"),
      this: new codegen_1$x.Name("this"),
      // "globals"
      self: new codegen_1$x.Name("self"),
      scope: new codegen_1$x.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1$x.Name("json"),
      jsonPos: new codegen_1$x.Name("jsonPos"),
      jsonLen: new codegen_1$x.Name("jsonLen"),
      jsonPart: new codegen_1$x.Name("jsonPart")
    };
    names$2.default = names$1;
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.extendErrors = exports2.resetErrorsCount = exports2.reportExtraError = exports2.reportError = exports2.keyword$DataError = exports2.keywordError = void 0;
      const codegen_12 = codegen;
      const util_12 = util;
      const names_12 = names$2;
      exports2.keywordError = {
        message: ({ keyword: keyword2 }) => (0, codegen_12.str)`must pass "${keyword2}" keyword validation`
      };
      exports2.keyword$DataError = {
        message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_12.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_12.str)`"${keyword2}" keyword is invalid ($data)`
      };
      function reportError(cxt, error2 = exports2.keywordError, errorPaths, overrideAllErrors) {
        const { it: it2 } = cxt;
        const { gen, compositeRule, allErrors } = it2;
        const errObj = errorObjectCode(cxt, error2, errorPaths);
        if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
          addError(gen, errObj);
        } else {
          returnErrors(it2, (0, codegen_12._)`[${errObj}]`);
        }
      }
      exports2.reportError = reportError;
      function reportExtraError(cxt, error2 = exports2.keywordError, errorPaths) {
        const { it: it2 } = cxt;
        const { gen, compositeRule, allErrors } = it2;
        const errObj = errorObjectCode(cxt, error2, errorPaths);
        addError(gen, errObj);
        if (!(compositeRule || allErrors)) {
          returnErrors(it2, names_12.default.vErrors);
        }
      }
      exports2.reportExtraError = reportExtraError;
      function resetErrorsCount(gen, errsCount) {
        gen.assign(names_12.default.errors, errsCount);
        gen.if((0, codegen_12._)`${names_12.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_12._)`${names_12.default.vErrors}.length`, errsCount), () => gen.assign(names_12.default.vErrors, null)));
      }
      exports2.resetErrorsCount = resetErrorsCount;
      function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it: it2 }) {
        if (errsCount === void 0)
          throw new Error("ajv implementation error");
        const err = gen.name("err");
        gen.forRange("i", errsCount, names_12.default.errors, (i2) => {
          gen.const(err, (0, codegen_12._)`${names_12.default.vErrors}[${i2}]`);
          gen.if((0, codegen_12._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_12._)`${err}.instancePath`, (0, codegen_12.strConcat)(names_12.default.instancePath, it2.errorPath)));
          gen.assign((0, codegen_12._)`${err}.schemaPath`, (0, codegen_12.str)`${it2.errSchemaPath}/${keyword2}`);
          if (it2.opts.verbose) {
            gen.assign((0, codegen_12._)`${err}.schema`, schemaValue);
            gen.assign((0, codegen_12._)`${err}.data`, data);
          }
        });
      }
      exports2.extendErrors = extendErrors;
      function addError(gen, errObj) {
        const err = gen.const("err", errObj);
        gen.if((0, codegen_12._)`${names_12.default.vErrors} === null`, () => gen.assign(names_12.default.vErrors, (0, codegen_12._)`[${err}]`), (0, codegen_12._)`${names_12.default.vErrors}.push(${err})`);
        gen.code((0, codegen_12._)`${names_12.default.errors}++`);
      }
      function returnErrors(it2, errs) {
        const { gen, validateName, schemaEnv } = it2;
        if (schemaEnv.$async) {
          gen.throw((0, codegen_12._)`new ${it2.ValidationError}(${errs})`);
        } else {
          gen.assign((0, codegen_12._)`${validateName}.errors`, errs);
          gen.return(false);
        }
      }
      const E = {
        keyword: new codegen_12.Name("keyword"),
        schemaPath: new codegen_12.Name("schemaPath"),
        params: new codegen_12.Name("params"),
        propertyName: new codegen_12.Name("propertyName"),
        message: new codegen_12.Name("message"),
        schema: new codegen_12.Name("schema"),
        parentSchema: new codegen_12.Name("parentSchema")
      };
      function errorObjectCode(cxt, error2, errorPaths) {
        const { createErrors } = cxt.it;
        if (createErrors === false)
          return (0, codegen_12._)`{}`;
        return errorObject(cxt, error2, errorPaths);
      }
      function errorObject(cxt, error2, errorPaths = {}) {
        const { gen, it: it2 } = cxt;
        const keyValues2 = [
          errorInstancePath(it2, errorPaths),
          errorSchemaPath(cxt, errorPaths)
        ];
        extraErrorProps(cxt, error2, keyValues2);
        return gen.object(...keyValues2);
      }
      function errorInstancePath({ errorPath }, { instancePath }) {
        const instPath = instancePath ? (0, codegen_12.str)`${errorPath}${(0, util_12.getErrorPath)(instancePath, util_12.Type.Str)}` : errorPath;
        return [names_12.default.instancePath, (0, codegen_12.strConcat)(names_12.default.instancePath, instPath)];
      }
      function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
        let schPath = parentSchema ? errSchemaPath : (0, codegen_12.str)`${errSchemaPath}/${keyword2}`;
        if (schemaPath) {
          schPath = (0, codegen_12.str)`${schPath}${(0, util_12.getErrorPath)(schemaPath, util_12.Type.Str)}`;
        }
        return [E.schemaPath, schPath];
      }
      function extraErrorProps(cxt, { params, message }, keyValues2) {
        const { keyword: keyword2, data, schemaValue, it: it2 } = cxt;
        const { opts, propertyName, topSchemaRef, schemaPath } = it2;
        keyValues2.push([E.keyword, keyword2], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_12._)`{}`]);
        if (opts.messages) {
          keyValues2.push([E.message, typeof message == "function" ? message(cxt) : message]);
        }
        if (opts.verbose) {
          keyValues2.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_12._)`${topSchemaRef}${schemaPath}`], [names_12.default.data, data]);
        }
        if (propertyName)
          keyValues2.push([E.propertyName, propertyName]);
      }
    })(errors$1);
    Object.defineProperty(boolSchema, "__esModule", { value: true });
    boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
    const errors_1$2 = errors$1;
    const codegen_1$w = codegen;
    const names_1$9 = names$2;
    const boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it2) {
      const { gen, schema, validateName } = it2;
      if (schema === false) {
        falseSchemaError(it2, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1$9.default.data);
      } else {
        gen.assign((0, codegen_1$w._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it2, valid) {
      const { gen, schema } = it2;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it2);
      } else {
        gen.var(valid, true);
      }
    }
    boolSchema.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it2, overrideAllErrors) {
      const { gen, data } = it2;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it: it2
      };
      (0, errors_1$2.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
    var dataType = {};
    var rules = {};
    Object.defineProperty(rules, "__esModule", { value: true });
    rules.getRules = rules.isJSONType = void 0;
    const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    const jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    rules.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    rules.getRules = getRules;
    var applicability = {};
    Object.defineProperty(applicability, "__esModule", { value: true });
    applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self: self2 }, type2) {
      const group = self2.RULES.types[type2];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    applicability.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    applicability.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a2;
      return schema[rule.keyword] !== void 0 || ((_a2 = rule.definition.implements) === null || _a2 === void 0 ? void 0 : _a2.some((kwd) => schema[kwd] !== void 0));
    }
    applicability.shouldUseRule = shouldUseRule;
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.reportTypeError = exports2.checkDataTypes = exports2.checkDataType = exports2.coerceAndCheckDataType = exports2.getJSONTypes = exports2.getSchemaTypes = exports2.DataType = void 0;
      const rules_1 = rules;
      const applicability_12 = applicability;
      const errors_12 = errors$1;
      const codegen_12 = codegen;
      const util_12 = util;
      var DataType;
      (function(DataType2) {
        DataType2[DataType2["Correct"] = 0] = "Correct";
        DataType2[DataType2["Wrong"] = 1] = "Wrong";
      })(DataType = exports2.DataType || (exports2.DataType = {}));
      function getSchemaTypes(schema) {
        const types2 = getJSONTypes(schema.type);
        const hasNull = types2.includes("null");
        if (hasNull) {
          if (schema.nullable === false)
            throw new Error("type: null contradicts nullable: false");
        } else {
          if (!types2.length && schema.nullable !== void 0) {
            throw new Error('"nullable" cannot be used without "type"');
          }
          if (schema.nullable === true)
            types2.push("null");
        }
        return types2;
      }
      exports2.getSchemaTypes = getSchemaTypes;
      function getJSONTypes(ts) {
        const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
        if (types2.every(rules_1.isJSONType))
          return types2;
        throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
      }
      exports2.getJSONTypes = getJSONTypes;
      function coerceAndCheckDataType(it2, types2) {
        const { gen, data, opts } = it2;
        const coerceTo = coerceToTypes(types2, opts.coerceTypes);
        const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_12.schemaHasRulesForType)(it2, types2[0]));
        if (checkTypes) {
          const wrongType = checkDataTypes(types2, data, opts.strictNumbers, DataType.Wrong);
          gen.if(wrongType, () => {
            if (coerceTo.length)
              coerceData(it2, types2, coerceTo);
            else
              reportTypeError(it2);
          });
        }
        return checkTypes;
      }
      exports2.coerceAndCheckDataType = coerceAndCheckDataType;
      const COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
      function coerceToTypes(types2, coerceTypes) {
        return coerceTypes ? types2.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
      }
      function coerceData(it2, types2, coerceTo) {
        const { gen, data, opts } = it2;
        const dataType2 = gen.let("dataType", (0, codegen_12._)`typeof ${data}`);
        const coerced = gen.let("coerced", (0, codegen_12._)`undefined`);
        if (opts.coerceTypes === "array") {
          gen.if((0, codegen_12._)`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_12._)`${data}[0]`).assign(dataType2, (0, codegen_12._)`typeof ${data}`).if(checkDataTypes(types2, data, opts.strictNumbers), () => gen.assign(coerced, data)));
        }
        gen.if((0, codegen_12._)`${coerced} !== undefined`);
        for (const t of coerceTo) {
          if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
            coerceSpecificType(t);
          }
        }
        gen.else();
        reportTypeError(it2);
        gen.endIf();
        gen.if((0, codegen_12._)`${coerced} !== undefined`, () => {
          gen.assign(data, coerced);
          assignParentData(it2, coerced);
        });
        function coerceSpecificType(t) {
          switch (t) {
            case "string":
              gen.elseIf((0, codegen_12._)`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, (0, codegen_12._)`"" + ${data}`).elseIf((0, codegen_12._)`${data} === null`).assign(coerced, (0, codegen_12._)`""`);
              return;
            case "number":
              gen.elseIf((0, codegen_12._)`${dataType2} == "boolean" || ${data} === null
              || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_12._)`+${data}`);
              return;
            case "integer":
              gen.elseIf((0, codegen_12._)`${dataType2} === "boolean" || ${data} === null
              || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_12._)`+${data}`);
              return;
            case "boolean":
              gen.elseIf((0, codegen_12._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_12._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
              return;
            case "null":
              gen.elseIf((0, codegen_12._)`${data} === "" || ${data} === 0 || ${data} === false`);
              gen.assign(coerced, null);
              return;
            case "array":
              gen.elseIf((0, codegen_12._)`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_12._)`[${data}]`);
          }
        }
      }
      function assignParentData({ gen, parentData, parentDataProperty }, expr) {
        gen.if((0, codegen_12._)`${parentData} !== undefined`, () => gen.assign((0, codegen_12._)`${parentData}[${parentDataProperty}]`, expr));
      }
      function checkDataType(dataType2, data, strictNums, correct = DataType.Correct) {
        const EQ = correct === DataType.Correct ? codegen_12.operators.EQ : codegen_12.operators.NEQ;
        let cond;
        switch (dataType2) {
          case "null":
            return (0, codegen_12._)`${data} ${EQ} null`;
          case "array":
            cond = (0, codegen_12._)`Array.isArray(${data})`;
            break;
          case "object":
            cond = (0, codegen_12._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
            break;
          case "integer":
            cond = numCond((0, codegen_12._)`!(${data} % 1) && !isNaN(${data})`);
            break;
          case "number":
            cond = numCond();
            break;
          default:
            return (0, codegen_12._)`typeof ${data} ${EQ} ${dataType2}`;
        }
        return correct === DataType.Correct ? cond : (0, codegen_12.not)(cond);
        function numCond(_cond = codegen_12.nil) {
          return (0, codegen_12.and)((0, codegen_12._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_12._)`isFinite(${data})` : codegen_12.nil);
        }
      }
      exports2.checkDataType = checkDataType;
      function checkDataTypes(dataTypes, data, strictNums, correct) {
        if (dataTypes.length === 1) {
          return checkDataType(dataTypes[0], data, strictNums, correct);
        }
        let cond;
        const types2 = (0, util_12.toHash)(dataTypes);
        if (types2.array && types2.object) {
          const notObj = (0, codegen_12._)`typeof ${data} != "object"`;
          cond = types2.null ? notObj : (0, codegen_12._)`!${data} || ${notObj}`;
          delete types2.null;
          delete types2.array;
          delete types2.object;
        } else {
          cond = codegen_12.nil;
        }
        if (types2.number)
          delete types2.integer;
        for (const t in types2)
          cond = (0, codegen_12.and)(cond, checkDataType(t, data, strictNums, correct));
        return cond;
      }
      exports2.checkDataTypes = checkDataTypes;
      const typeError = {
        message: ({ schema }) => `must be ${schema}`,
        params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_12._)`{type: ${schema}}` : (0, codegen_12._)`{type: ${schemaValue}}`
      };
      function reportTypeError(it2) {
        const cxt = getTypeErrorContext(it2);
        (0, errors_12.reportError)(cxt, typeError);
      }
      exports2.reportTypeError = reportTypeError;
      function getTypeErrorContext(it2) {
        const { gen, data, schema } = it2;
        const schemaCode = (0, util_12.schemaRefOrVal)(it2, schema, "type");
        return {
          gen,
          keyword: "type",
          data,
          schema: schema.type,
          schemaCode,
          schemaValue: schemaCode,
          parentSchema: schema,
          params: {},
          it: it2
        };
      }
    })(dataType);
    var defaults = {};
    Object.defineProperty(defaults, "__esModule", { value: true });
    defaults.assignDefaults = void 0;
    const codegen_1$v = codegen;
    const util_1$t = util;
    function assignDefaults(it2, ty) {
      const { properties: properties2, items: items2 } = it2.schema;
      if (ty === "object" && properties2) {
        for (const key in properties2) {
          assignDefault(it2, key, properties2[key].default);
        }
      } else if (ty === "array" && Array.isArray(items2)) {
        items2.forEach((sch, i2) => assignDefault(it2, i2, sch.default));
      }
    }
    defaults.assignDefaults = assignDefaults;
    function assignDefault(it2, prop2, defaultValue) {
      const { gen, compositeRule, data, opts } = it2;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1$v._)`${data}${(0, codegen_1$v.getProperty)(prop2)}`;
      if (compositeRule) {
        (0, util_1$t.checkStrictMode)(it2, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1$v._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1$v._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1$v._)`${childData} = ${(0, codegen_1$v.stringify)(defaultValue)}`);
    }
    var keyword = {};
    var code$1 = {};
    Object.defineProperty(code$1, "__esModule", { value: true });
    code$1.validateUnion = code$1.validateArray = code$1.usePattern = code$1.callValidateCode = code$1.schemaProperties = code$1.allSchemaProperties = code$1.noPropertyInData = code$1.propertyInData = code$1.isOwnProperty = code$1.hasPropFunc = code$1.reportMissingProp = code$1.checkMissingProp = code$1.checkReportMissingProp = void 0;
    const codegen_1$u = codegen;
    const util_1$s = util;
    const names_1$8 = names$2;
    const util_2$1 = util;
    function checkReportMissingProp(cxt, prop2) {
      const { gen, data, it: it2 } = cxt;
      gen.if(noPropertyInData(gen, data, prop2, it2.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1$u._)`${prop2}` }, true);
        cxt.error();
      });
    }
    code$1.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties2, missing) {
      return (0, codegen_1$u.or)(...properties2.map((prop2) => (0, codegen_1$u.and)(noPropertyInData(gen, data, prop2, opts.ownProperties), (0, codegen_1$u._)`${missing} = ${prop2}`)));
    }
    code$1.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    code$1.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1$u._)`Object.prototype.hasOwnProperty`
      });
    }
    code$1.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1$u._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    code$1.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1$u._)`${data}${(0, codegen_1$u.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1$u._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    code$1.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1$u._)`${data}${(0, codegen_1$u.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1$u.or)(cond, (0, codegen_1$u.not)(isOwnProperty(gen, data, property))) : cond;
    }
    code$1.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p2) => p2 !== "__proto__") : [];
    }
    code$1.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it2, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p2) => !(0, util_1$s.alwaysValidSchema)(it2, schemaMap[p2]));
    }
    code$1.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it: it2 }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1$u._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1$8.default.instancePath, (0, codegen_1$u.strConcat)(names_1$8.default.instancePath, errorPath)],
        [names_1$8.default.parentData, it2.parentData],
        [names_1$8.default.parentDataProperty, it2.parentDataProperty],
        [names_1$8.default.rootData, names_1$8.default.rootData]
      ];
      if (it2.opts.dynamicRef)
        valCxt.push([names_1$8.default.dynamicAnchors, names_1$8.default.dynamicAnchors]);
      const args = (0, codegen_1$u._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1$u.nil ? (0, codegen_1$u._)`${func}.call(${context}, ${args})` : (0, codegen_1$u._)`${func}(${args})`;
    }
    code$1.callValidateCode = callValidateCode;
    const newRegExp = (0, codegen_1$u._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern3) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx2 = regExp(pattern3, u);
      return gen.scopeValue("pattern", {
        key: rx2.toString(),
        ref: rx2,
        code: (0, codegen_1$u._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2$1.useFunc)(gen, regExp)}(${pattern3}, ${u})`
      });
    }
    code$1.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword: keyword2, it: it2 } = cxt;
      const valid = gen.name("valid");
      if (it2.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1$u._)`${data}.length`);
        gen.forRange("i", 0, len, (i2) => {
          cxt.subschema({
            keyword: keyword2,
            dataProp: i2,
            dataPropType: util_1$s.Type.Num
          }, valid);
          gen.if((0, codegen_1$u.not)(valid), notValid);
        });
      }
    }
    code$1.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword: keyword2, it: it2 } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1$s.alwaysValidSchema)(it2, sch));
      if (alwaysValid && !it2.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i2) => {
        const schCxt = cxt.subschema({
          keyword: keyword2,
          schemaProp: i2,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1$u._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1$u.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    code$1.validateUnion = validateUnion;
    Object.defineProperty(keyword, "__esModule", { value: true });
    keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
    const codegen_1$t = codegen;
    const names_1$7 = names$2;
    const code_1$9 = code$1;
    const errors_1$1 = errors$1;
    function macroKeywordCode(cxt, def2) {
      const { gen, keyword: keyword2, schema, parentSchema, it: it2 } = cxt;
      const macroSchema = def2.macro.call(it2.self, schema, parentSchema, it2);
      const schemaRef = useKeyword(gen, keyword2, macroSchema);
      if (it2.opts.validateSchema !== false)
        it2.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1$t.nil,
        errSchemaPath: `${it2.errSchemaPath}/${keyword2}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    keyword.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def2) {
      var _a2;
      const { gen, keyword: keyword2, schema, parentSchema, $data, it: it2 } = cxt;
      checkAsyncKeyword(it2, def2);
      const validate2 = !$data && def2.compile ? def2.compile.call(it2.self, schema, parentSchema, it2) : def2.validate;
      const validateRef = useKeyword(gen, keyword2, validate2);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a2 = def2.valid) !== null && _a2 !== void 0 ? _a2 : valid);
      function validateKeyword() {
        if (def2.errors === false) {
          assignValid();
          if (def2.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def2.async ? validateAsync() : validateSync();
          if (def2.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1$t._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1$t._)`${e} instanceof ${it2.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1$t._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1$t._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1$t.nil);
        return validateErrs;
      }
      function assignValid(_await = def2.async ? (0, codegen_1$t._)`await ` : codegen_1$t.nil) {
        const passCxt = it2.opts.passContext ? names_1$7.default.this : names_1$7.default.self;
        const passSchema = !("compile" in def2 && !$data || def2.schema === false);
        gen.assign(valid, (0, codegen_1$t._)`${_await}${(0, code_1$9.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def2.modifying);
      }
      function reportErrs(errors2) {
        var _a3;
        gen.if((0, codegen_1$t.not)((_a3 = def2.valid) !== null && _a3 !== void 0 ? _a3 : valid), errors2);
      }
    }
    keyword.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it: it2 } = cxt;
      gen.if(it2.parentData, () => gen.assign(data, (0, codegen_1$t._)`${it2.parentData}[${it2.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1$t._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1$7.default.vErrors, (0, codegen_1$t._)`${names_1$7.default.vErrors} === null ? ${errs} : ${names_1$7.default.vErrors}.concat(${errs})`).assign(names_1$7.default.errors, (0, codegen_1$t._)`${names_1$7.default.vErrors}.length`);
        (0, errors_1$1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def2) {
      if (def2.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword2, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword2}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1$t.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    keyword.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def2, keyword2) {
      if (Array.isArray(def2.keyword) ? !def2.keyword.includes(keyword2) : def2.keyword !== keyword2) {
        throw new Error("ajv implementation error");
      }
      const deps = def2.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
      }
      if (def2.validateSchema) {
        const valid = def2.validateSchema(schema[keyword2]);
        if (!valid) {
          const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def2.validateSchema.errors);
          if (opts.validateSchema === "log")
            self2.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    keyword.validateKeywordUsage = validateKeywordUsage;
    var subschema = {};
    Object.defineProperty(subschema, "__esModule", { value: true });
    subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
    const codegen_1$s = codegen;
    const util_1$r = util;
    function getSubschema(it2, { keyword: keyword2, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword2 !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword2 !== void 0) {
        const sch = it2.schema[keyword2];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1$s._)`${it2.schemaPath}${(0, codegen_1$s.getProperty)(keyword2)}`,
          errSchemaPath: `${it2.errSchemaPath}/${keyword2}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1$s._)`${it2.schemaPath}${(0, codegen_1$s.getProperty)(keyword2)}${(0, codegen_1$s.getProperty)(schemaProp)}`,
          errSchemaPath: `${it2.errSchemaPath}/${keyword2}/${(0, util_1$r.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    subschema.getSubschema = getSubschema;
    function extendSubschemaData(subschema2, it2, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it2;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it2;
        const nextData = gen.let("data", (0, codegen_1$s._)`${it2.data}${(0, codegen_1$s.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema2.errorPath = (0, codegen_1$s.str)`${errorPath}${(0, util_1$r.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema2.parentDataProperty = (0, codegen_1$s._)`${dataProp}`;
        subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1$s.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema2.propertyName = propertyName;
      }
      if (dataTypes)
        subschema2.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema2.data = _nextData;
        subschema2.dataLevel = it2.dataLevel + 1;
        subschema2.dataTypes = [];
        it2.definedProperties = /* @__PURE__ */ new Set();
        subschema2.parentData = it2.data;
        subschema2.dataNames = [...it2.dataNames, _nextData];
      }
    }
    subschema.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema2.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema2.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema2.allErrors = allErrors;
      subschema2.jtdDiscriminator = jtdDiscriminator;
      subschema2.jtdMetadata = jtdMetadata;
    }
    subschema.extendSubschemaMode = extendSubschemaMode;
    var resolve$1 = {};
    var fastDeepEqual = function equal2(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i2, keys2;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i2 = length; i2-- !== 0; )
            if (!equal2(a[i2], b[i2]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys2 = Object.keys(a);
        length = keys2.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i2 = length; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys2[i2]))
            return false;
        for (i2 = length; i2-- !== 0; ) {
          var key = keys2[i2];
          if (!equal2(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
    var jsonSchemaTraverse = { exports: {} };
    var traverse$1 = jsonSchemaTraverse.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre2 = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre2, post, schema, "", schema);
    };
    traverse$1.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse$1.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse$1.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse$1.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre2, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre2(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse$1.arrayKeywords) {
              for (var i2 = 0; i2 < sch.length; i2++)
                _traverse(opts, pre2, post, sch[i2], jsonPtr + "/" + key + "/" + i2, rootSchema, jsonPtr, key, schema, i2);
            }
          } else if (key in traverse$1.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop2 in sch)
                _traverse(opts, pre2, post, sch[prop2], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop2), rootSchema, jsonPtr, key, schema, prop2);
            }
          } else if (key in traverse$1.keywords || opts.allKeys && !(key in traverse$1.skipKeywords)) {
            _traverse(opts, pre2, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    var jsonSchemaTraverseExports = jsonSchemaTraverse.exports;
    Object.defineProperty(resolve$1, "__esModule", { value: true });
    resolve$1.getSchemaRefs = resolve$1.resolveUrl = resolve$1.normalizeId = resolve$1._getFullPath = resolve$1.getFullPath = resolve$1.inlineRef = void 0;
    const util_1$q = util;
    const equal$2 = fastDeepEqual;
    const traverse = jsonSchemaTraverseExports;
    const SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit2 = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit2 === true)
        return !hasRef(schema);
      if (!limit2)
        return false;
      return countKeys(schema) <= limit2;
    }
    resolve$1.inlineRef = inlineRef;
    const REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1$q.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id2 = "", normalize2) {
      if (normalize2 !== false)
        id2 = normalizeId(id2);
      const p2 = resolver.parse(id2);
      return _getFullPath(resolver, p2);
    }
    resolve$1.getFullPath = getFullPath;
    function _getFullPath(resolver, p2) {
      const serialized = resolver.serialize(p2);
      return serialized.split("#")[0] + "#";
    }
    resolve$1._getFullPath = _getFullPath;
    const TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id2) {
      return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
    }
    resolve$1.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id2) {
      id2 = normalizeId(id2);
      return resolver.resolve(baseId, id2);
    }
    resolve$1.resolveUrl = resolveUrl;
    const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let baseId2 = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          baseId2 = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = baseId2;
        function addRef(ref2) {
          const _resolve = this.opts.uriResolver.resolve;
          ref2 = normalizeId(baseId2 ? _resolve(baseId2, ref2) : ref2);
          if (schemaRefs.has(ref2))
            throw ambiguos(ref2);
          schemaRefs.add(ref2);
          let schOrRef = this.refs[ref2];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref2);
          } else if (ref2 !== normalizeId(fullPath)) {
            if (ref2[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref2], ref2);
              localRefs[ref2] = sch;
            } else {
              this.refs[ref2] = fullPath;
            }
          }
          return ref2;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref2) {
        if (sch2 !== void 0 && !equal$2(sch1, sch2))
          throw ambiguos(ref2);
      }
      function ambiguos(ref2) {
        return new Error(`reference "${ref2}" resolves to more than one schema`);
      }
    }
    resolve$1.getSchemaRefs = getSchemaRefs;
    Object.defineProperty(validate, "__esModule", { value: true });
    validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
    const boolSchema_1 = boolSchema;
    const dataType_1$1 = dataType;
    const applicability_1 = applicability;
    const dataType_2 = dataType;
    const defaults_1 = defaults;
    const keyword_1 = keyword;
    const subschema_1 = subschema;
    const codegen_1$r = codegen;
    const names_1$6 = names$2;
    const resolve_1$2 = resolve$1;
    const util_1$p = util;
    const errors_1 = errors$1;
    function validateFunctionCode(it2) {
      if (isSchemaObj(it2)) {
        checkKeywords(it2);
        if (schemaCxtHasRules(it2)) {
          topSchemaObjCode(it2);
          return;
        }
      }
      validateFunction(it2, () => (0, boolSchema_1.topBoolOrEmptySchema)(it2));
    }
    validate.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1$r._)`${names_1$6.default.data}, ${names_1$6.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1$r._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1$r._)`${names_1$6.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1$r._)`{${names_1$6.default.instancePath}="", ${names_1$6.default.parentData}, ${names_1$6.default.parentDataProperty}, ${names_1$6.default.rootData}=${names_1$6.default.data}${opts.dynamicRef ? (0, codegen_1$r._)`, ${names_1$6.default.dynamicAnchors}={}` : codegen_1$r.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1$6.default.valCxt, () => {
        gen.var(names_1$6.default.instancePath, (0, codegen_1$r._)`${names_1$6.default.valCxt}.${names_1$6.default.instancePath}`);
        gen.var(names_1$6.default.parentData, (0, codegen_1$r._)`${names_1$6.default.valCxt}.${names_1$6.default.parentData}`);
        gen.var(names_1$6.default.parentDataProperty, (0, codegen_1$r._)`${names_1$6.default.valCxt}.${names_1$6.default.parentDataProperty}`);
        gen.var(names_1$6.default.rootData, (0, codegen_1$r._)`${names_1$6.default.valCxt}.${names_1$6.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1$6.default.dynamicAnchors, (0, codegen_1$r._)`${names_1$6.default.valCxt}.${names_1$6.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1$6.default.instancePath, (0, codegen_1$r._)`""`);
        gen.var(names_1$6.default.parentData, (0, codegen_1$r._)`undefined`);
        gen.var(names_1$6.default.parentDataProperty, (0, codegen_1$r._)`undefined`);
        gen.var(names_1$6.default.rootData, names_1$6.default.data);
        if (opts.dynamicRef)
          gen.var(names_1$6.default.dynamicAnchors, (0, codegen_1$r._)`{}`);
      });
    }
    function topSchemaObjCode(it2) {
      const { schema, opts, gen } = it2;
      validateFunction(it2, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it2);
        checkNoDefault(it2);
        gen.let(names_1$6.default.vErrors, null);
        gen.let(names_1$6.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it2);
        typeAndKeywords(it2);
        returnResults(it2);
      });
      return;
    }
    function resetEvaluated(it2) {
      const { gen, validateName } = it2;
      it2.evaluated = gen.const("evaluated", (0, codegen_1$r._)`${validateName}.evaluated`);
      gen.if((0, codegen_1$r._)`${it2.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1$r._)`${it2.evaluated}.props`, (0, codegen_1$r._)`undefined`));
      gen.if((0, codegen_1$r._)`${it2.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1$r._)`${it2.evaluated}.items`, (0, codegen_1$r._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1$r._)`/*# sourceURL=${schId} */` : codegen_1$r.nil;
    }
    function subschemaCode(it2, valid) {
      if (isSchemaObj(it2)) {
        checkKeywords(it2);
        if (schemaCxtHasRules(it2)) {
          subSchemaObjCode(it2, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it2, valid);
    }
    function schemaCxtHasRules({ schema, self: self2 }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self2.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it2) {
      return typeof it2.schema != "boolean";
    }
    function subSchemaObjCode(it2, valid) {
      const { schema, gen, opts } = it2;
      if (opts.$comment && schema.$comment)
        commentKeyword(it2);
      updateContext(it2);
      checkAsyncSchema(it2);
      const errsCount = gen.const("_errs", names_1$6.default.errors);
      typeAndKeywords(it2, errsCount);
      gen.var(valid, (0, codegen_1$r._)`${errsCount} === ${names_1$6.default.errors}`);
    }
    function checkKeywords(it2) {
      (0, util_1$p.checkUnknownRules)(it2);
      checkRefsAndKeywords(it2);
    }
    function typeAndKeywords(it2, errsCount) {
      if (it2.opts.jtd)
        return schemaKeywords(it2, [], false, errsCount);
      const types2 = (0, dataType_1$1.getSchemaTypes)(it2.schema);
      const checkedTypes = (0, dataType_1$1.coerceAndCheckDataType)(it2, types2);
      schemaKeywords(it2, types2, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it2) {
      const { schema, errSchemaPath, opts, self: self2 } = it2;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1$p.schemaHasRulesButRef)(schema, self2.RULES)) {
        self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it2) {
      const { schema, opts } = it2;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1$p.checkStrictMode)(it2, "default is ignored in the schema root");
      }
    }
    function updateContext(it2) {
      const schId = it2.schema[it2.opts.schemaId];
      if (schId)
        it2.baseId = (0, resolve_1$2.resolveUrl)(it2.opts.uriResolver, it2.baseId, schId);
    }
    function checkAsyncSchema(it2) {
      if (it2.schema.$async && !it2.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1$r._)`${names_1$6.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1$r.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1$r._)`${names_1$6.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it2) {
      const { gen, schemaEnv, validateName, ValidationError: ValidationError2, opts } = it2;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1$r._)`${names_1$6.default.errors} === 0`, () => gen.return(names_1$6.default.data), () => gen.throw((0, codegen_1$r._)`new ${ValidationError2}(${names_1$6.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1$r._)`${validateName}.errors`, names_1$6.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it2);
        gen.return((0, codegen_1$r._)`${names_1$6.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items: items2 }) {
      if (props instanceof codegen_1$r.Name)
        gen.assign((0, codegen_1$r._)`${evaluated}.props`, props);
      if (items2 instanceof codegen_1$r.Name)
        gen.assign((0, codegen_1$r._)`${evaluated}.items`, items2);
    }
    function schemaKeywords(it2, types2, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self: self2 } = it2;
      const { RULES: RULES2 } = self2;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1$p.schemaHasRulesButRef)(schema, RULES2))) {
        gen.block(() => keywordCode(it2, "$ref", RULES2.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it2, types2);
      gen.block(() => {
        for (const group of RULES2.rules)
          groupKeywords(group);
        groupKeywords(RULES2.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it2, group);
          if (types2.length === 1 && types2[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it2);
          }
          gen.endIf();
        } else {
          iterateKeywords(it2, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1$r._)`${names_1$6.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it2, group) {
      const { gen, schema, opts: { useDefaults } } = it2;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it2, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it2, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it2, types2) {
      if (it2.schemaEnv.meta || !it2.opts.strictTypes)
        return;
      checkContextTypes(it2, types2);
      if (!it2.opts.allowUnionTypes)
        checkMultipleTypes(it2, types2);
      checkKeywordTypes(it2, it2.dataTypes);
    }
    function checkContextTypes(it2, types2) {
      if (!types2.length)
        return;
      if (!it2.dataTypes.length) {
        it2.dataTypes = types2;
        return;
      }
      types2.forEach((t) => {
        if (!includesType(it2.dataTypes, t)) {
          strictTypesError(it2, `type "${t}" not allowed by context "${it2.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it2, types2);
    }
    function checkMultipleTypes(it2, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it2, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it2, ts) {
      const rules2 = it2.self.RULES.all;
      for (const keyword2 in rules2) {
        const rule = rules2[keyword2];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it2.schema, rule)) {
          const { type: type2 } = rule.definition;
          if (type2.length && !type2.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it2, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it2, withTypes) {
      const ts = [];
      for (const t of it2.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it2.dataTypes = ts;
    }
    function strictTypesError(it2, msg) {
      const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1$p.checkStrictMode)(it2, msg, it2.opts.strictTypes);
    }
    class KeywordCxt {
      constructor(it2, def2, keyword2) {
        (0, keyword_1.validateKeywordUsage)(it2, def2, keyword2);
        this.gen = it2.gen;
        this.allErrors = it2.allErrors;
        this.keyword = keyword2;
        this.data = it2.data;
        this.schema = it2.schema[keyword2];
        this.$data = def2.$data && it2.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1$p.schemaRefOrVal)(it2, this.schema, keyword2, this.$data);
        this.schemaType = def2.schemaType;
        this.parentSchema = it2.schema;
        this.params = {};
        this.it = it2;
        this.def = def2;
        if (this.$data) {
          this.schemaCode = it2.gen.const("vSchema", getData(this.$data, it2));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def2.schemaType, def2.allowUndefined)) {
            throw new Error(`${keyword2} value must be ${JSON.stringify(def2.schemaType)}`);
          }
        }
        if ("code" in def2 ? def2.trackErrors : def2.errors !== false) {
          this.errsCount = it2.gen.const("_errs", names_1$6.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1$r.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1$r.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1$r._)`${schemaCode} !== undefined && (${(0, codegen_1$r.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign2) {
        if (assign2)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1$r.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1$r.nil, $dataValid = codegen_1$r.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def: def2 } = this;
        gen.if((0, codegen_1$r.or)((0, codegen_1$r._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1$r.nil)
          gen.assign(valid, true);
        if (schemaType.length || def2.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1$r.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def: def2, it: it2 } = this;
        return (0, codegen_1$r.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1$r.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1$r._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it2.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1$r.nil;
        }
        function invalid$DataSchema() {
          if (def2.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def2.validateSchema });
            return (0, codegen_1$r._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1$r.nil;
        }
      }
      subschema(appl, valid) {
        const subschema2 = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema2, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema2, appl);
        const nextContext = { ...this.it, ...subschema2, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it: it2, gen } = this;
        if (!it2.opts.unevaluated)
          return;
        if (it2.props !== true && schemaCxt.props !== void 0) {
          it2.props = util_1$p.mergeEvaluated.props(gen, schemaCxt.props, it2.props, toName);
        }
        if (it2.items !== true && schemaCxt.items !== void 0) {
          it2.items = util_1$p.mergeEvaluated.items(gen, schemaCxt.items, it2.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it: it2, gen } = this;
        if (it2.opts.unevaluated && (it2.props !== true || it2.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1$r.Name));
          return true;
        }
      }
    }
    validate.KeywordCxt = KeywordCxt;
    function keywordCode(it2, keyword2, def2, ruleType) {
      const cxt = new KeywordCxt(it2, def2, keyword2);
      if ("code" in def2) {
        def2.code(cxt, ruleType);
      } else if (cxt.$data && def2.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def2);
      } else if ("macro" in def2) {
        (0, keyword_1.macroKeywordCode)(cxt, def2);
      } else if (def2.compile || def2.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def2);
      }
    }
    const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1$6.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1$6.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1$r._)`${data}${(0, codegen_1$r.getProperty)((0, util_1$p.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1$r._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    validate.getData = getData;
    var validation_error = {};
    Object.defineProperty(validation_error, "__esModule", { value: true });
    class ValidationError extends Error {
      constructor(errors2) {
        super("validation failed");
        this.errors = errors2;
        this.ajv = this.validation = true;
      }
    }
    validation_error.default = ValidationError;
    var ref_error = {};
    Object.defineProperty(ref_error, "__esModule", { value: true });
    const resolve_1$1 = resolve$1;
    class MissingRefError extends Error {
      constructor(resolver, baseId, ref2, msg) {
        super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
        this.missingRef = (0, resolve_1$1.resolveUrl)(resolver, baseId, ref2);
        this.missingSchema = (0, resolve_1$1.normalizeId)((0, resolve_1$1.getFullPath)(resolver, this.missingRef));
      }
    }
    ref_error.default = MissingRefError;
    var compile$2 = {};
    Object.defineProperty(compile$2, "__esModule", { value: true });
    compile$2.resolveSchema = compile$2.getCompilingSchema = compile$2.resolveRef = compile$2.compileSchema = compile$2.SchemaEnv = void 0;
    const codegen_1$q = codegen;
    const validation_error_1 = validation_error;
    const names_1$5 = names$2;
    const resolve_1 = resolve$1;
    const util_1$o = util;
    const validate_1$1 = validate;
    class SchemaEnv {
      constructor(env) {
        var _a2;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a2 = env.baseId) !== null && _a2 !== void 0 ? _a2 : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    }
    compile$2.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1$q.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1$q._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1$5.default.data,
        parentData: names_1$5.default.parentData,
        parentDataProperty: names_1$5.default.parentDataProperty,
        dataNames: [names_1$5.default.data],
        dataPathArr: [codegen_1$q.nil],
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1$q.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1$q.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1$q._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1$1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1$5.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1$5.default.self}`, `${names_1$5.default.scope}`, sourceCode);
        const validate2 = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate2 });
        validate2.errors = null;
        validate2.schema = sch.schema;
        validate2.schemaEnv = sch;
        if (sch.$async)
          validate2.$async = true;
        if (this.opts.code.source === true) {
          validate2.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items: items2 } = schemaCxt;
          validate2.evaluated = {
            props: props instanceof codegen_1$q.Name ? void 0 : props,
            items: items2 instanceof codegen_1$q.Name ? void 0 : items2,
            dynamicProps: props instanceof codegen_1$q.Name,
            dynamicItems: items2 instanceof codegen_1$q.Name
          };
          if (validate2.source)
            validate2.source.evaluated = (0, codegen_1$q.stringify)(validate2.evaluated);
        }
        sch.validate = validate2;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    compile$2.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref2) {
      var _a2;
      ref2 = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref2);
      const schOrFunc = root.refs[ref2];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref2);
      if (_sch === void 0) {
        const schema = (_a2 = root.localRefs) === null || _a2 === void 0 ? void 0 : _a2[ref2];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref2] = inlineOrCompile.call(this, _sch);
    }
    compile$2.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    compile$2.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref2) {
      let sch;
      while (typeof (sch = this.refs[ref2]) == "string")
        ref2 = sch;
      return sch || this.schemas[ref2] || resolveSchema.call(this, root, ref2);
    }
    function resolveSchema(root, ref2) {
      const p2 = this.opts.uriResolver.parse(ref2);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p2);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p2, root);
      }
      const id2 = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id2] || this.schemas[id2];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p2, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id2 === (0, resolve_1.normalizeId)(ref2)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p2, schOrRef);
    }
    compile$2.resolveSchema = resolveSchema;
    const PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a2;
      if (((_a2 = parsedRef.fragment) === null || _a2 === void 0 ? void 0 : _a2[0]) !== "/")
        return;
      for (const part2 of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1$o.unescapeFragment)(part2)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part2) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1$o.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
    const $id$8 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
    const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
    const type$8 = "object";
    const required$1 = [
      "$data"
    ];
    const properties$9 = {
      $data: {
        type: "string",
        anyOf: [
          {
            format: "relative-json-pointer"
          },
          {
            format: "json-pointer"
          }
        ]
      }
    };
    const additionalProperties$1 = false;
    const require$$9 = {
      $id: $id$8,
      description,
      type: type$8,
      required: required$1,
      properties: properties$9,
      additionalProperties: additionalProperties$1
    };
    var uri$1 = {};
    var uri_all = { exports: {} };
    /** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
    (function(module2, exports2) {
      (function(global2, factory) {
        factory(exports2);
      })(commonjsGlobal, function(exports3) {
        function merge2() {
          for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
            sets[_key] = arguments[_key];
          }
          if (sets.length > 1) {
            sets[0] = sets[0].slice(0, -1);
            var xl = sets.length - 1;
            for (var x = 1; x < xl; ++x) {
              sets[x] = sets[x].slice(1, -1);
            }
            sets[xl] = sets[xl].slice(1);
            return sets.join("");
          } else {
            return sets[0];
          }
        }
        function subexp(str) {
          return "(?:" + str + ")";
        }
        function typeOf(o) {
          return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
        }
        function toUpperCase(str) {
          return str.toUpperCase();
        }
        function toArray(obj) {
          return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
        }
        function assign2(target2, source) {
          var obj = target2;
          if (source) {
            for (var key in source) {
              obj[key] = source[key];
            }
          }
          return obj;
        }
        function buildExps(isIRI) {
          var ALPHA$$ = "[A-Za-z]", DIGIT$$ = "[0-9]", HEXDIG$$2 = merge2(DIGIT$$, "[A-Fa-f]"), PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge2(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge2(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
          subexp(ALPHA$$ + merge2(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
          subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*");
          var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+");
          subexp("[vV]" + HEXDIG$$2 + "+\\." + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+");
          subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$)) + "*");
          var PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]"));
          subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+");
          subexp(subexp(PCHAR$ + "|" + merge2("[\\/\\?]", IPRIVATE$$)) + "*");
          return {
            NOT_SCHEME: new RegExp(merge2("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
            NOT_USERINFO: new RegExp(merge2("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            NOT_HOST: new RegExp(merge2("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            NOT_PATH: new RegExp(merge2("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            NOT_PATH_NOSCHEME: new RegExp(merge2("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            NOT_QUERY: new RegExp(merge2("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
            NOT_FRAGMENT: new RegExp(merge2("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
            ESCAPE: new RegExp(merge2("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
            OTHER_CHARS: new RegExp(merge2("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
            PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
            IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
            IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
            //RFC 6874, with relaxed parsing rules
          };
        }
        var URI_PROTOCOL = buildExps(false);
        var IRI_PROTOCOL = buildExps(true);
        var slicedToArray = /* @__PURE__ */ function() {
          function sliceIterator(arr, i2) {
            var _arr2 = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr2.push(_s.value);
                if (i2 && _arr2.length === i2)
                  break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"])
                  _i["return"]();
              } finally {
                if (_d)
                  throw _e;
              }
            }
            return _arr2;
          }
          return function(arr, i2) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i2);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();
        var toConsumableArray = function(arr) {
          if (Array.isArray(arr)) {
            for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++)
              arr2[i2] = arr[i2];
            return arr2;
          } else {
            return Array.from(arr);
          }
        };
        var maxInt2 = 2147483647;
        var base2 = 36;
        var tMin2 = 1;
        var tMax2 = 26;
        var skew2 = 38;
        var damp2 = 700;
        var initialBias2 = 72;
        var initialN2 = 128;
        var delimiter2 = "-";
        var regexPunycode2 = /^xn--/;
        var regexNonASCII2 = /[^\0-\x7E]/;
        var regexSeparators2 = /[\x2E\u3002\uFF0E\uFF61]/g;
        var errors2 = {
          "overflow": "Overflow: input needs wider integers to process",
          "not-basic": "Illegal input >= 0x80 (not a basic code point)",
          "invalid-input": "Invalid input"
        };
        var baseMinusTMin2 = base2 - tMin2;
        var floor2 = Math.floor;
        var stringFromCharCode2 = String.fromCharCode;
        function error$12(type2) {
          throw new RangeError(errors2[type2]);
        }
        function map2(array, fn) {
          var result = [];
          var length = array.length;
          while (length--) {
            result[length] = fn(array[length]);
          }
          return result;
        }
        function mapDomain2(string, fn) {
          var parts = string.split("@");
          var result = "";
          if (parts.length > 1) {
            result = parts[0] + "@";
            string = parts[1];
          }
          string = string.replace(regexSeparators2, ".");
          var labels = string.split(".");
          var encoded = map2(labels, fn).join(".");
          return result + encoded;
        }
        function ucs2decode2(string) {
          var output = [];
          var counter = 0;
          var length = string.length;
          while (counter < length) {
            var value = string.charCodeAt(counter++);
            if (value >= 55296 && value <= 56319 && counter < length) {
              var extra = string.charCodeAt(counter++);
              if ((extra & 64512) == 56320) {
                output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
              } else {
                output.push(value);
                counter--;
              }
            } else {
              output.push(value);
            }
          }
          return output;
        }
        var ucs2encode2 = function ucs2encode3(array) {
          return String.fromCodePoint.apply(String, toConsumableArray(array));
        };
        var basicToDigit2 = function basicToDigit3(codePoint) {
          if (codePoint - 48 < 10) {
            return codePoint - 22;
          }
          if (codePoint - 65 < 26) {
            return codePoint - 65;
          }
          if (codePoint - 97 < 26) {
            return codePoint - 97;
          }
          return base2;
        };
        var digitToBasic2 = function digitToBasic3(digit, flag) {
          return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        };
        var adapt2 = function adapt3(delta2, numPoints, firstTime) {
          var k = 0;
          delta2 = firstTime ? floor2(delta2 / damp2) : delta2 >> 1;
          delta2 += floor2(delta2 / numPoints);
          for (
            ;
            /* no initialization */
            delta2 > baseMinusTMin2 * tMax2 >> 1;
            k += base2
          ) {
            delta2 = floor2(delta2 / baseMinusTMin2);
          }
          return floor2(k + (baseMinusTMin2 + 1) * delta2 / (delta2 + skew2));
        };
        var decode2 = function decode3(input) {
          var output = [];
          var inputLength = input.length;
          var i2 = 0;
          var n = initialN2;
          var bias2 = initialBias2;
          var basic = input.lastIndexOf(delimiter2);
          if (basic < 0) {
            basic = 0;
          }
          for (var j = 0; j < basic; ++j) {
            if (input.charCodeAt(j) >= 128) {
              error$12("not-basic");
            }
            output.push(input.charCodeAt(j));
          }
          for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
            var oldi = i2;
            for (
              var w = 1, k = base2;
              ;
              /* no condition */
              k += base2
            ) {
              if (index >= inputLength) {
                error$12("invalid-input");
              }
              var digit = basicToDigit2(input.charCodeAt(index++));
              if (digit >= base2 || digit > floor2((maxInt2 - i2) / w)) {
                error$12("overflow");
              }
              i2 += digit * w;
              var t = k <= bias2 ? tMin2 : k >= bias2 + tMax2 ? tMax2 : k - bias2;
              if (digit < t) {
                break;
              }
              var baseMinusT = base2 - t;
              if (w > floor2(maxInt2 / baseMinusT)) {
                error$12("overflow");
              }
              w *= baseMinusT;
            }
            var out = output.length + 1;
            bias2 = adapt2(i2 - oldi, out, oldi == 0);
            if (floor2(i2 / out) > maxInt2 - n) {
              error$12("overflow");
            }
            n += floor2(i2 / out);
            i2 %= out;
            output.splice(i2++, 0, n);
          }
          return String.fromCodePoint.apply(String, output);
        };
        var encode2 = function encode3(input) {
          var output = [];
          input = ucs2decode2(input);
          var inputLength = input.length;
          var n = initialN2;
          var delta2 = 0;
          var bias2 = initialBias2;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _currentValue2 = _step.value;
              if (_currentValue2 < 128) {
                output.push(stringFromCharCode2(_currentValue2));
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          var basicLength = output.length;
          var handledCPCount = basicLength;
          if (basicLength) {
            output.push(delimiter2);
          }
          while (handledCPCount < inputLength) {
            var m = maxInt2;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = void 0;
            try {
              for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var currentValue = _step2.value;
                if (currentValue >= n && currentValue < m) {
                  m = currentValue;
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
            var handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > floor2((maxInt2 - delta2) / handledCPCountPlusOne)) {
              error$12("overflow");
            }
            delta2 += (m - n) * handledCPCountPlusOne;
            n = m;
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = void 0;
            try {
              for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var _currentValue = _step3.value;
                if (_currentValue < n && ++delta2 > maxInt2) {
                  error$12("overflow");
                }
                if (_currentValue == n) {
                  var q = delta2;
                  for (
                    var k = base2;
                    ;
                    /* no condition */
                    k += base2
                  ) {
                    var t = k <= bias2 ? tMin2 : k >= bias2 + tMax2 ? tMax2 : k - bias2;
                    if (q < t) {
                      break;
                    }
                    var qMinusT = q - t;
                    var baseMinusT = base2 - t;
                    output.push(stringFromCharCode2(digitToBasic2(t + qMinusT % baseMinusT, 0)));
                    q = floor2(qMinusT / baseMinusT);
                  }
                  output.push(stringFromCharCode2(digitToBasic2(q, 0)));
                  bias2 = adapt2(delta2, handledCPCountPlusOne, handledCPCount == basicLength);
                  delta2 = 0;
                  ++handledCPCount;
                }
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
            ++delta2;
            ++n;
          }
          return output.join("");
        };
        var toUnicode2 = function toUnicode3(input) {
          return mapDomain2(input, function(string) {
            return regexPunycode2.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
          });
        };
        var toASCII2 = function toASCII3(input) {
          return mapDomain2(input, function(string) {
            return regexNonASCII2.test(string) ? "xn--" + encode2(string) : string;
          });
        };
        var punycode2 = {
          /**
           * A string representing the current Punycode.js version number.
           * @memberOf punycode
           * @type String
           */
          "version": "2.1.0",
          /**
           * An object of methods to convert from JavaScript's internal character
           * representation (UCS-2) to Unicode code points, and back.
           * @see <https://mathiasbynens.be/notes/javascript-encoding>
           * @memberOf punycode
           * @type Object
           */
          "ucs2": {
            "decode": ucs2decode2,
            "encode": ucs2encode2
          },
          "decode": decode2,
          "encode": encode2,
          "toASCII": toASCII2,
          "toUnicode": toUnicode2
        };
        var SCHEMES = {};
        function pctEncChar(chr) {
          var c = chr.charCodeAt(0);
          var e = void 0;
          if (c < 16)
            e = "%0" + c.toString(16).toUpperCase();
          else if (c < 128)
            e = "%" + c.toString(16).toUpperCase();
          else if (c < 2048)
            e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
          else
            e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
          return e;
        }
        function pctDecChars(str) {
          var newStr = "";
          var i2 = 0;
          var il = str.length;
          while (i2 < il) {
            var c = parseInt(str.substr(i2 + 1, 2), 16);
            if (c < 128) {
              newStr += String.fromCharCode(c);
              i2 += 3;
            } else if (c >= 194 && c < 224) {
              if (il - i2 >= 6) {
                var c2 = parseInt(str.substr(i2 + 4, 2), 16);
                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
              } else {
                newStr += str.substr(i2, 6);
              }
              i2 += 6;
            } else if (c >= 224) {
              if (il - i2 >= 9) {
                var _c = parseInt(str.substr(i2 + 4, 2), 16);
                var c3 = parseInt(str.substr(i2 + 7, 2), 16);
                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
              } else {
                newStr += str.substr(i2, 9);
              }
              i2 += 9;
            } else {
              newStr += str.substr(i2, 3);
              i2 += 3;
            }
          }
          return newStr;
        }
        function _normalizeComponentEncoding(components, protocol) {
          function decodeUnreserved2(str) {
            var decStr = pctDecChars(str);
            return !decStr.match(protocol.UNRESERVED) ? str : decStr;
          }
          if (components.scheme)
            components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
          if (components.userinfo !== void 0)
            components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          if (components.host !== void 0)
            components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          if (components.path !== void 0)
            components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          if (components.query !== void 0)
            components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          if (components.fragment !== void 0)
            components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          return components;
        }
        function _stripLeadingZeros(str) {
          return str.replace(/^0*(.*)/, "$1") || "0";
        }
        function _normalizeIPv4(host, protocol) {
          var matches = host.match(protocol.IPV4ADDRESS) || [];
          var _matches = slicedToArray(matches, 2), address = _matches[1];
          if (address) {
            return address.split(".").map(_stripLeadingZeros).join(".");
          } else {
            return host;
          }
        }
        function _normalizeIPv6(host, protocol) {
          var matches = host.match(protocol.IPV6ADDRESS) || [];
          var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
          if (address) {
            var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
            var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
            var lastFields = last.split(":").map(_stripLeadingZeros);
            var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
            var fieldCount = isLastFieldIPv4Address ? 7 : 8;
            var lastFieldsStart = lastFields.length - fieldCount;
            var fields = Array(fieldCount);
            for (var x = 0; x < fieldCount; ++x) {
              fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
            }
            if (isLastFieldIPv4Address) {
              fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
            }
            var allZeroFields = fields.reduce(function(acc, field, index) {
              if (!field || field === "0") {
                var lastLongest = acc[acc.length - 1];
                if (lastLongest && lastLongest.index + lastLongest.length === index) {
                  lastLongest.length++;
                } else {
                  acc.push({ index, length: 1 });
                }
              }
              return acc;
            }, []);
            var longestZeroFields = allZeroFields.sort(function(a, b) {
              return b.length - a.length;
            })[0];
            var newHost = void 0;
            if (longestZeroFields && longestZeroFields.length > 1) {
              var newFirst = fields.slice(0, longestZeroFields.index);
              var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
              newHost = newFirst.join(":") + "::" + newLast.join(":");
            } else {
              newHost = fields.join(":");
            }
            if (zone) {
              newHost += "%" + zone;
            }
            return newHost;
          } else {
            return host;
          }
        }
        var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
        var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
        function parse2(uriString) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var components = {};
          var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
          if (options.reference === "suffix")
            uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
          var matches = uriString.match(URI_PARSE);
          if (matches) {
            if (NO_MATCH_IS_UNDEFINED) {
              components.scheme = matches[1];
              components.userinfo = matches[3];
              components.host = matches[4];
              components.port = parseInt(matches[5], 10);
              components.path = matches[6] || "";
              components.query = matches[7];
              components.fragment = matches[8];
              if (isNaN(components.port)) {
                components.port = matches[5];
              }
            } else {
              components.scheme = matches[1] || void 0;
              components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
              components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
              components.port = parseInt(matches[5], 10);
              components.path = matches[6] || "";
              components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
              components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
              if (isNaN(components.port)) {
                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
              }
            }
            if (components.host) {
              components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
            }
            if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
              components.reference = "same-document";
            } else if (components.scheme === void 0) {
              components.reference = "relative";
            } else if (components.fragment === void 0) {
              components.reference = "absolute";
            } else {
              components.reference = "uri";
            }
            if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
              components.error = components.error || "URI is not a " + options.reference + " reference.";
            }
            var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
            if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
              if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                try {
                  components.host = punycode2.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                } catch (e) {
                  components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                }
              }
              _normalizeComponentEncoding(components, URI_PROTOCOL);
            } else {
              _normalizeComponentEncoding(components, protocol);
            }
            if (schemeHandler && schemeHandler.parse) {
              schemeHandler.parse(components, options);
            }
          } else {
            components.error = components.error || "URI can not be parsed.";
          }
          return components;
        }
        function _recomposeAuthority(components, options) {
          var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
          var uriTokens = [];
          if (components.userinfo !== void 0) {
            uriTokens.push(components.userinfo);
            uriTokens.push("@");
          }
          if (components.host !== void 0) {
            uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
              return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
            }));
          }
          if (typeof components.port === "number" || typeof components.port === "string") {
            uriTokens.push(":");
            uriTokens.push(String(components.port));
          }
          return uriTokens.length ? uriTokens.join("") : void 0;
        }
        var RDS1 = /^\.\.?\//;
        var RDS2 = /^\/\.(\/|$)/;
        var RDS3 = /^\/\.\.(\/|$)/;
        var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
        function removeDotSegments(input) {
          var output = [];
          while (input.length) {
            if (input.match(RDS1)) {
              input = input.replace(RDS1, "");
            } else if (input.match(RDS2)) {
              input = input.replace(RDS2, "/");
            } else if (input.match(RDS3)) {
              input = input.replace(RDS3, "/");
              output.pop();
            } else if (input === "." || input === "..") {
              input = "";
            } else {
              var im = input.match(RDS5);
              if (im) {
                var s = im[0];
                input = input.slice(s.length);
                output.push(s);
              } else {
                throw new Error("Unexpected dot segment condition");
              }
            }
          }
          return output.join("");
        }
        function serialize(components) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
          var uriTokens = [];
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (schemeHandler && schemeHandler.serialize)
            schemeHandler.serialize(components, options);
          if (components.host) {
            if (protocol.IPV6ADDRESS.test(components.host))
              ;
            else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
              try {
                components.host = !options.iri ? punycode2.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode2.toUnicode(components.host);
              } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
              }
            }
          }
          _normalizeComponentEncoding(components, protocol);
          if (options.reference !== "suffix" && components.scheme) {
            uriTokens.push(components.scheme);
            uriTokens.push(":");
          }
          var authority = _recomposeAuthority(components, options);
          if (authority !== void 0) {
            if (options.reference !== "suffix") {
              uriTokens.push("//");
            }
            uriTokens.push(authority);
            if (components.path && components.path.charAt(0) !== "/") {
              uriTokens.push("/");
            }
          }
          if (components.path !== void 0) {
            var s = components.path;
            if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
              s = removeDotSegments(s);
            }
            if (authority === void 0) {
              s = s.replace(/^\/\//, "/%2F");
            }
            uriTokens.push(s);
          }
          if (components.query !== void 0) {
            uriTokens.push("?");
            uriTokens.push(components.query);
          }
          if (components.fragment !== void 0) {
            uriTokens.push("#");
            uriTokens.push(components.fragment);
          }
          return uriTokens.join("");
        }
        function resolveComponents(base3, relative) {
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var skipNormalization = arguments[3];
          var target2 = {};
          if (!skipNormalization) {
            base3 = parse2(serialize(base3, options), options);
            relative = parse2(serialize(relative, options), options);
          }
          options = options || {};
          if (!options.tolerant && relative.scheme) {
            target2.scheme = relative.scheme;
            target2.userinfo = relative.userinfo;
            target2.host = relative.host;
            target2.port = relative.port;
            target2.path = removeDotSegments(relative.path || "");
            target2.query = relative.query;
          } else {
            if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
              target2.userinfo = relative.userinfo;
              target2.host = relative.host;
              target2.port = relative.port;
              target2.path = removeDotSegments(relative.path || "");
              target2.query = relative.query;
            } else {
              if (!relative.path) {
                target2.path = base3.path;
                if (relative.query !== void 0) {
                  target2.query = relative.query;
                } else {
                  target2.query = base3.query;
                }
              } else {
                if (relative.path.charAt(0) === "/") {
                  target2.path = removeDotSegments(relative.path);
                } else {
                  if ((base3.userinfo !== void 0 || base3.host !== void 0 || base3.port !== void 0) && !base3.path) {
                    target2.path = "/" + relative.path;
                  } else if (!base3.path) {
                    target2.path = relative.path;
                  } else {
                    target2.path = base3.path.slice(0, base3.path.lastIndexOf("/") + 1) + relative.path;
                  }
                  target2.path = removeDotSegments(target2.path);
                }
                target2.query = relative.query;
              }
              target2.userinfo = base3.userinfo;
              target2.host = base3.host;
              target2.port = base3.port;
            }
            target2.scheme = base3.scheme;
          }
          target2.fragment = relative.fragment;
          return target2;
        }
        function resolve2(baseURI, relativeURI, options) {
          var schemelessOptions = assign2({ scheme: "null" }, options);
          return serialize(resolveComponents(parse2(baseURI, schemelessOptions), parse2(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
        }
        function normalize2(uri2, options) {
          if (typeof uri2 === "string") {
            uri2 = serialize(parse2(uri2, options), options);
          } else if (typeOf(uri2) === "object") {
            uri2 = parse2(serialize(uri2, options), options);
          }
          return uri2;
        }
        function equal2(uriA, uriB, options) {
          if (typeof uriA === "string") {
            uriA = serialize(parse2(uriA, options), options);
          } else if (typeOf(uriA) === "object") {
            uriA = serialize(uriA, options);
          }
          if (typeof uriB === "string") {
            uriB = serialize(parse2(uriB, options), options);
          } else if (typeOf(uriB) === "object") {
            uriB = serialize(uriB, options);
          }
          return uriA === uriB;
        }
        function escapeComponent(str, options) {
          return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
        }
        function unescapeComponent(str, options) {
          return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
        }
        var handler = {
          scheme: "http",
          domainHost: true,
          parse: function parse3(components, options) {
            if (!components.host) {
              components.error = components.error || "HTTP URIs must have a host.";
            }
            return components;
          },
          serialize: function serialize2(components, options) {
            var secure = String(components.scheme).toLowerCase() === "https";
            if (components.port === (secure ? 443 : 80) || components.port === "") {
              components.port = void 0;
            }
            if (!components.path) {
              components.path = "/";
            }
            return components;
          }
        };
        var handler$1 = {
          scheme: "https",
          domainHost: handler.domainHost,
          parse: handler.parse,
          serialize: handler.serialize
        };
        function isSecure(wsComponents) {
          return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
        }
        var handler$2 = {
          scheme: "ws",
          domainHost: true,
          parse: function parse3(components, options) {
            var wsComponents = components;
            wsComponents.secure = isSecure(wsComponents);
            wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
            wsComponents.path = void 0;
            wsComponents.query = void 0;
            return wsComponents;
          },
          serialize: function serialize2(wsComponents, options) {
            if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
              wsComponents.port = void 0;
            }
            if (typeof wsComponents.secure === "boolean") {
              wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
              wsComponents.secure = void 0;
            }
            if (wsComponents.resourceName) {
              var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
              wsComponents.path = path && path !== "/" ? path : void 0;
              wsComponents.query = query;
              wsComponents.resourceName = void 0;
            }
            wsComponents.fragment = void 0;
            return wsComponents;
          }
        };
        var handler$3 = {
          scheme: "wss",
          domainHost: handler$2.domainHost,
          parse: handler$2.parse,
          serialize: handler$2.serialize
        };
        var O = {};
        var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]";
        var HEXDIG$$ = "[0-9A-Fa-f]";
        var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
        var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
        var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
        var VCHAR$$ = merge2(QTEXT$$, '[\\"\\\\]');
        var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
        var UNRESERVED = new RegExp(UNRESERVED$$, "g");
        var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
        var NOT_LOCAL_PART = new RegExp(merge2("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
        var NOT_HFNAME = new RegExp(merge2("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
        var NOT_HFVALUE = NOT_HFNAME;
        function decodeUnreserved(str) {
          var decStr = pctDecChars(str);
          return !decStr.match(UNRESERVED) ? str : decStr;
        }
        var handler$4 = {
          scheme: "mailto",
          parse: function parse$$1(components, options) {
            var mailtoComponents = components;
            var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
            mailtoComponents.path = void 0;
            if (mailtoComponents.query) {
              var unknownHeaders = false;
              var headers = {};
              var hfields = mailtoComponents.query.split("&");
              for (var x = 0, xl = hfields.length; x < xl; ++x) {
                var hfield = hfields[x].split("=");
                switch (hfield[0]) {
                  case "to":
                    var toAddrs = hfield[1].split(",");
                    for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                      to.push(toAddrs[_x]);
                    }
                    break;
                  case "subject":
                    mailtoComponents.subject = unescapeComponent(hfield[1], options);
                    break;
                  case "body":
                    mailtoComponents.body = unescapeComponent(hfield[1], options);
                    break;
                  default:
                    unknownHeaders = true;
                    headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                    break;
                }
              }
              if (unknownHeaders)
                mailtoComponents.headers = headers;
            }
            mailtoComponents.query = void 0;
            for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
              var addr = to[_x2].split("@");
              addr[0] = unescapeComponent(addr[0]);
              if (!options.unicodeSupport) {
                try {
                  addr[1] = punycode2.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                } catch (e) {
                  mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                }
              } else {
                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
              }
              to[_x2] = addr.join("@");
            }
            return mailtoComponents;
          },
          serialize: function serialize$$1(mailtoComponents, options) {
            var components = mailtoComponents;
            var to = toArray(mailtoComponents.to);
            if (to) {
              for (var x = 0, xl = to.length; x < xl; ++x) {
                var toAddr = String(to[x]);
                var atIdx = toAddr.lastIndexOf("@");
                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                var domain = toAddr.slice(atIdx + 1);
                try {
                  domain = !options.iri ? punycode2.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode2.toUnicode(domain);
                } catch (e) {
                  components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
                to[x] = localPart + "@" + domain;
              }
              components.path = to.join(",");
            }
            var headers = mailtoComponents.headers = mailtoComponents.headers || {};
            if (mailtoComponents.subject)
              headers["subject"] = mailtoComponents.subject;
            if (mailtoComponents.body)
              headers["body"] = mailtoComponents.body;
            var fields = [];
            for (var name in headers) {
              if (headers[name] !== O[name]) {
                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
              }
            }
            if (fields.length) {
              components.query = fields.join("&");
            }
            return components;
          }
        };
        var URN_PARSE = /^([^\:]+)\:(.*)/;
        var handler$5 = {
          scheme: "urn",
          parse: function parse$$1(components, options) {
            var matches = components.path && components.path.match(URN_PARSE);
            var urnComponents = components;
            if (matches) {
              var scheme = options.scheme || urnComponents.scheme || "urn";
              var nid = matches[1].toLowerCase();
              var nss = matches[2];
              var urnScheme = scheme + ":" + (options.nid || nid);
              var schemeHandler = SCHEMES[urnScheme];
              urnComponents.nid = nid;
              urnComponents.nss = nss;
              urnComponents.path = void 0;
              if (schemeHandler) {
                urnComponents = schemeHandler.parse(urnComponents, options);
              }
            } else {
              urnComponents.error = urnComponents.error || "URN can not be parsed.";
            }
            return urnComponents;
          },
          serialize: function serialize$$1(urnComponents, options) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = urnComponents.nid;
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            if (schemeHandler) {
              urnComponents = schemeHandler.serialize(urnComponents, options);
            }
            var uriComponents = urnComponents;
            var nss = urnComponents.nss;
            uriComponents.path = (nid || options.nid) + ":" + nss;
            return uriComponents;
          }
        };
        var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
        var handler$6 = {
          scheme: "urn:uuid",
          parse: function parse3(urnComponents, options) {
            var uuidComponents = urnComponents;
            uuidComponents.uuid = uuidComponents.nss;
            uuidComponents.nss = void 0;
            if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
              uuidComponents.error = uuidComponents.error || "UUID is not valid.";
            }
            return uuidComponents;
          },
          serialize: function serialize2(uuidComponents, options) {
            var urnComponents = uuidComponents;
            urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
            return urnComponents;
          }
        };
        SCHEMES[handler.scheme] = handler;
        SCHEMES[handler$1.scheme] = handler$1;
        SCHEMES[handler$2.scheme] = handler$2;
        SCHEMES[handler$3.scheme] = handler$3;
        SCHEMES[handler$4.scheme] = handler$4;
        SCHEMES[handler$5.scheme] = handler$5;
        SCHEMES[handler$6.scheme] = handler$6;
        exports3.SCHEMES = SCHEMES;
        exports3.pctEncChar = pctEncChar;
        exports3.pctDecChars = pctDecChars;
        exports3.parse = parse2;
        exports3.removeDotSegments = removeDotSegments;
        exports3.serialize = serialize;
        exports3.resolveComponents = resolveComponents;
        exports3.resolve = resolve2;
        exports3.normalize = normalize2;
        exports3.equal = equal2;
        exports3.escapeComponent = escapeComponent;
        exports3.unescapeComponent = unescapeComponent;
        Object.defineProperty(exports3, "__esModule", { value: true });
      });
    })(uri_all, uri_all.exports);
    var uri_allExports = uri_all.exports;
    Object.defineProperty(uri$1, "__esModule", { value: true });
    const uri = uri_allExports;
    uri.code = 'require("ajv/dist/runtime/uri").default';
    uri$1.default = uri;
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
      var validate_12 = validate;
      Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
        return validate_12.KeywordCxt;
      } });
      var codegen_12 = codegen;
      Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
        return codegen_12._;
      } });
      Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
        return codegen_12.str;
      } });
      Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
        return codegen_12.stringify;
      } });
      Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
        return codegen_12.nil;
      } });
      Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
        return codegen_12.Name;
      } });
      Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
        return codegen_12.CodeGen;
      } });
      const validation_error_12 = validation_error;
      const ref_error_12 = ref_error;
      const rules_1 = rules;
      const compile_12 = compile$2;
      const codegen_2 = codegen;
      const resolve_12 = resolve$1;
      const dataType_12 = dataType;
      const util_12 = util;
      const $dataRefSchema = require$$9;
      const uri_1 = uri$1;
      const defaultRegExp = (str, flags) => new RegExp(str, flags);
      defaultRegExp.code = "new RegExp";
      const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
      const EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
        "validate",
        "serialize",
        "parse",
        "wrapper",
        "root",
        "schema",
        "keyword",
        "pattern",
        "formats",
        "validate$data",
        "func",
        "obj",
        "Error"
      ]);
      const removedOptions = {
        errorDataPath: "",
        format: "`validateFormats: false` can be used instead.",
        nullable: '"nullable" keyword is supported by default.',
        jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
        extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
        missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
        processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
        sourceCode: "Use option `code: {source: true}`",
        strictDefaults: "It is default now, see option `strict`.",
        strictKeywords: "It is default now, see option `strict`.",
        uniqueItems: '"uniqueItems" keyword is always validated.',
        unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
        cache: "Map is used as cache, schema object as key.",
        serialize: "Map is used as cache, schema object as key.",
        ajvErrors: "It is default now."
      };
      const deprecatedOptions = {
        ignoreKeywordsWithRef: "",
        jsPropertySyntax: "",
        unicode: '"minLength"/"maxLength" account for unicode characters by default.'
      };
      const MAX_EXPRESSION = 200;
      function requiredOptions(o) {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
        const s = o.strict;
        const _optz = (_a2 = o.code) === null || _a2 === void 0 ? void 0 : _a2.optimize;
        const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
        const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
        const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
        return {
          strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
          strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
          strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
          strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
          strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
          code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
          loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
          loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
          meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
          messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
          inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
          schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
          addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
          validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
          validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
          unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
          int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
          uriResolver
        };
      }
      class Ajv2 {
        constructor(opts = {}) {
          this.schemas = {};
          this.refs = {};
          this.formats = {};
          this._compilations = /* @__PURE__ */ new Set();
          this._loading = {};
          this._cache = /* @__PURE__ */ new Map();
          opts = this.opts = { ...opts, ...requiredOptions(opts) };
          const { es5, lines } = this.opts.code;
          this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
          this.logger = getLogger(opts.logger);
          const formatOpt = opts.validateFormats;
          opts.validateFormats = false;
          this.RULES = (0, rules_1.getRules)();
          checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
          checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
          this._metaOpts = getMetaSchemaOptions.call(this);
          if (opts.formats)
            addInitialFormats.call(this);
          this._addVocabularies();
          this._addDefaultMetaSchema();
          if (opts.keywords)
            addInitialKeywords.call(this, opts.keywords);
          if (typeof opts.meta == "object")
            this.addMetaSchema(opts.meta);
          addInitialSchemas.call(this);
          opts.validateFormats = formatOpt;
        }
        _addVocabularies() {
          this.addKeyword("$async");
        }
        _addDefaultMetaSchema() {
          const { $data, meta, schemaId } = this.opts;
          let _dataRefSchema = $dataRefSchema;
          if (schemaId === "id") {
            _dataRefSchema = { ...$dataRefSchema };
            _dataRefSchema.id = _dataRefSchema.$id;
            delete _dataRefSchema.$id;
          }
          if (meta && $data)
            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
        }
        defaultMeta() {
          const { meta, schemaId } = this.opts;
          return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
        }
        validate(schemaKeyRef, data) {
          let v;
          if (typeof schemaKeyRef == "string") {
            v = this.getSchema(schemaKeyRef);
            if (!v)
              throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
          } else {
            v = this.compile(schemaKeyRef);
          }
          const valid = v(data);
          if (!("$async" in v))
            this.errors = v.errors;
          return valid;
        }
        compile(schema, _meta) {
          const sch = this._addSchema(schema, _meta);
          return sch.validate || this._compileSchemaEnv(sch);
        }
        compileAsync(schema, meta) {
          if (typeof this.opts.loadSchema != "function") {
            throw new Error("options.loadSchema should be a function");
          }
          const { loadSchema } = this.opts;
          return runCompileAsync.call(this, schema, meta);
          async function runCompileAsync(_schema, _meta) {
            await loadMetaSchema.call(this, _schema.$schema);
            const sch = this._addSchema(_schema, _meta);
            return sch.validate || _compileAsync.call(this, sch);
          }
          async function loadMetaSchema($ref) {
            if ($ref && !this.getSchema($ref)) {
              await runCompileAsync.call(this, { $ref }, true);
            }
          }
          async function _compileAsync(sch) {
            try {
              return this._compileSchemaEnv(sch);
            } catch (e) {
              if (!(e instanceof ref_error_12.default))
                throw e;
              checkLoaded.call(this, e);
              await loadMissingSchema.call(this, e.missingSchema);
              return _compileAsync.call(this, sch);
            }
          }
          function checkLoaded({ missingSchema: ref2, missingRef }) {
            if (this.refs[ref2]) {
              throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
            }
          }
          async function loadMissingSchema(ref2) {
            const _schema = await _loadSchema.call(this, ref2);
            if (!this.refs[ref2])
              await loadMetaSchema.call(this, _schema.$schema);
            if (!this.refs[ref2])
              this.addSchema(_schema, ref2, meta);
          }
          async function _loadSchema(ref2) {
            const p2 = this._loading[ref2];
            if (p2)
              return p2;
            try {
              return await (this._loading[ref2] = loadSchema(ref2));
            } finally {
              delete this._loading[ref2];
            }
          }
        }
        // Adds schema to the instance
        addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
          if (Array.isArray(schema)) {
            for (const sch of schema)
              this.addSchema(sch, void 0, _meta, _validateSchema);
            return this;
          }
          let id2;
          if (typeof schema === "object") {
            const { schemaId } = this.opts;
            id2 = schema[schemaId];
            if (id2 !== void 0 && typeof id2 != "string") {
              throw new Error(`schema ${schemaId} must be string`);
            }
          }
          key = (0, resolve_12.normalizeId)(key || id2);
          this._checkUnique(key);
          this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
          return this;
        }
        // Add schema that will be used to validate other schemas
        // options in META_IGNORE_OPTIONS are alway set to false
        addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
          this.addSchema(schema, key, true, _validateSchema);
          return this;
        }
        //  Validate schema against its meta-schema
        validateSchema(schema, throwOrLogError) {
          if (typeof schema == "boolean")
            return true;
          let $schema2;
          $schema2 = schema.$schema;
          if ($schema2 !== void 0 && typeof $schema2 != "string") {
            throw new Error("$schema must be a string");
          }
          $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
          if (!$schema2) {
            this.logger.warn("meta-schema not available");
            this.errors = null;
            return true;
          }
          const valid = this.validate($schema2, schema);
          if (!valid && throwOrLogError) {
            const message = "schema is invalid: " + this.errorsText();
            if (this.opts.validateSchema === "log")
              this.logger.error(message);
            else
              throw new Error(message);
          }
          return valid;
        }
        // Get compiled schema by `key` or `ref`.
        // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
        getSchema(keyRef) {
          let sch;
          while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
            keyRef = sch;
          if (sch === void 0) {
            const { schemaId } = this.opts;
            const root = new compile_12.SchemaEnv({ schema: {}, schemaId });
            sch = compile_12.resolveSchema.call(this, root, keyRef);
            if (!sch)
              return;
            this.refs[keyRef] = sch;
          }
          return sch.validate || this._compileSchemaEnv(sch);
        }
        // Remove cached schema(s).
        // If no parameter is passed all schemas but meta-schemas are removed.
        // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
        // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
        removeSchema(schemaKeyRef) {
          if (schemaKeyRef instanceof RegExp) {
            this._removeAllSchemas(this.schemas, schemaKeyRef);
            this._removeAllSchemas(this.refs, schemaKeyRef);
            return this;
          }
          switch (typeof schemaKeyRef) {
            case "undefined":
              this._removeAllSchemas(this.schemas);
              this._removeAllSchemas(this.refs);
              this._cache.clear();
              return this;
            case "string": {
              const sch = getSchEnv.call(this, schemaKeyRef);
              if (typeof sch == "object")
                this._cache.delete(sch.schema);
              delete this.schemas[schemaKeyRef];
              delete this.refs[schemaKeyRef];
              return this;
            }
            case "object": {
              const cacheKey = schemaKeyRef;
              this._cache.delete(cacheKey);
              let id2 = schemaKeyRef[this.opts.schemaId];
              if (id2) {
                id2 = (0, resolve_12.normalizeId)(id2);
                delete this.schemas[id2];
                delete this.refs[id2];
              }
              return this;
            }
            default:
              throw new Error("ajv.removeSchema: invalid parameter");
          }
        }
        // add "vocabulary" - a collection of keywords
        addVocabulary(definitions2) {
          for (const def2 of definitions2)
            this.addKeyword(def2);
          return this;
        }
        addKeyword(kwdOrDef, def2) {
          let keyword2;
          if (typeof kwdOrDef == "string") {
            keyword2 = kwdOrDef;
            if (typeof def2 == "object") {
              this.logger.warn("these parameters are deprecated, see docs for addKeyword");
              def2.keyword = keyword2;
            }
          } else if (typeof kwdOrDef == "object" && def2 === void 0) {
            def2 = kwdOrDef;
            keyword2 = def2.keyword;
            if (Array.isArray(keyword2) && !keyword2.length) {
              throw new Error("addKeywords: keyword must be string or non-empty array");
            }
          } else {
            throw new Error("invalid addKeywords parameters");
          }
          checkKeyword.call(this, keyword2, def2);
          if (!def2) {
            (0, util_12.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
            return this;
          }
          keywordMetaschema.call(this, def2);
          const definition = {
            ...def2,
            type: (0, dataType_12.getJSONTypes)(def2.type),
            schemaType: (0, dataType_12.getJSONTypes)(def2.schemaType)
          };
          (0, util_12.eachItem)(keyword2, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
          return this;
        }
        getKeyword(keyword2) {
          const rule = this.RULES.all[keyword2];
          return typeof rule == "object" ? rule.definition : !!rule;
        }
        // Remove keyword
        removeKeyword(keyword2) {
          const { RULES: RULES2 } = this;
          delete RULES2.keywords[keyword2];
          delete RULES2.all[keyword2];
          for (const group of RULES2.rules) {
            const i2 = group.rules.findIndex((rule) => rule.keyword === keyword2);
            if (i2 >= 0)
              group.rules.splice(i2, 1);
          }
          return this;
        }
        // Add format
        addFormat(name, format2) {
          if (typeof format2 == "string")
            format2 = new RegExp(format2);
          this.formats[name] = format2;
          return this;
        }
        errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
          if (!errors2 || errors2.length === 0)
            return "No errors";
          return errors2.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text2, msg) => text2 + separator + msg);
        }
        $dataMetaSchema(metaSchema2, keywordsJsonPointers) {
          const rules2 = this.RULES.all;
          metaSchema2 = JSON.parse(JSON.stringify(metaSchema2));
          for (const jsonPointer of keywordsJsonPointers) {
            const segments = jsonPointer.split("/").slice(1);
            let keywords = metaSchema2;
            for (const seg of segments)
              keywords = keywords[seg];
            for (const key in rules2) {
              const rule = rules2[key];
              if (typeof rule != "object")
                continue;
              const { $data } = rule.definition;
              const schema = keywords[key];
              if ($data && schema)
                keywords[key] = schemaOrData(schema);
            }
          }
          return metaSchema2;
        }
        _removeAllSchemas(schemas, regex2) {
          for (const keyRef in schemas) {
            const sch = schemas[keyRef];
            if (!regex2 || regex2.test(keyRef)) {
              if (typeof sch == "string") {
                delete schemas[keyRef];
              } else if (sch && !sch.meta) {
                this._cache.delete(sch.schema);
                delete schemas[keyRef];
              }
            }
          }
        }
        _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
          let id2;
          const { schemaId } = this.opts;
          if (typeof schema == "object") {
            id2 = schema[schemaId];
          } else {
            if (this.opts.jtd)
              throw new Error("schema must be object");
            else if (typeof schema != "boolean")
              throw new Error("schema must be object or boolean");
          }
          let sch = this._cache.get(schema);
          if (sch !== void 0)
            return sch;
          baseId = (0, resolve_12.normalizeId)(id2 || baseId);
          const localRefs = resolve_12.getSchemaRefs.call(this, schema, baseId);
          sch = new compile_12.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
          this._cache.set(sch.schema, sch);
          if (addSchema && !baseId.startsWith("#")) {
            if (baseId)
              this._checkUnique(baseId);
            this.refs[baseId] = sch;
          }
          if (validateSchema)
            this.validateSchema(schema, true);
          return sch;
        }
        _checkUnique(id2) {
          if (this.schemas[id2] || this.refs[id2]) {
            throw new Error(`schema with key or id "${id2}" already exists`);
          }
        }
        _compileSchemaEnv(sch) {
          if (sch.meta)
            this._compileMetaSchema(sch);
          else
            compile_12.compileSchema.call(this, sch);
          if (!sch.validate)
            throw new Error("ajv implementation error");
          return sch.validate;
        }
        _compileMetaSchema(sch) {
          const currentOpts = this.opts;
          this.opts = this._metaOpts;
          try {
            compile_12.compileSchema.call(this, sch);
          } finally {
            this.opts = currentOpts;
          }
        }
      }
      exports2.default = Ajv2;
      Ajv2.ValidationError = validation_error_12.default;
      Ajv2.MissingRefError = ref_error_12.default;
      function checkOptions(checkOpts, options, msg, log = "error") {
        for (const key in checkOpts) {
          const opt = key;
          if (opt in options)
            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
        }
      }
      function getSchEnv(keyRef) {
        keyRef = (0, resolve_12.normalizeId)(keyRef);
        return this.schemas[keyRef] || this.refs[keyRef];
      }
      function addInitialSchemas() {
        const optsSchemas = this.opts.schemas;
        if (!optsSchemas)
          return;
        if (Array.isArray(optsSchemas))
          this.addSchema(optsSchemas);
        else
          for (const key in optsSchemas)
            this.addSchema(optsSchemas[key], key);
      }
      function addInitialFormats() {
        for (const name in this.opts.formats) {
          const format2 = this.opts.formats[name];
          if (format2)
            this.addFormat(name, format2);
        }
      }
      function addInitialKeywords(defs) {
        if (Array.isArray(defs)) {
          this.addVocabulary(defs);
          return;
        }
        this.logger.warn("keywords option as map is deprecated, pass array");
        for (const keyword2 in defs) {
          const def2 = defs[keyword2];
          if (!def2.keyword)
            def2.keyword = keyword2;
          this.addKeyword(def2);
        }
      }
      function getMetaSchemaOptions() {
        const metaOpts = { ...this.opts };
        for (const opt of META_IGNORE_OPTIONS)
          delete metaOpts[opt];
        return metaOpts;
      }
      const noLogs = { log() {
      }, warn() {
      }, error() {
      } };
      function getLogger(logger) {
        if (logger === false)
          return noLogs;
        if (logger === void 0)
          return console;
        if (logger.log && logger.warn && logger.error)
          return logger;
        throw new Error("logger must implement log, warn and error methods");
      }
      const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
      function checkKeyword(keyword2, def2) {
        const { RULES: RULES2 } = this;
        (0, util_12.eachItem)(keyword2, (kwd) => {
          if (RULES2.keywords[kwd])
            throw new Error(`Keyword ${kwd} is already defined`);
          if (!KEYWORD_NAME.test(kwd))
            throw new Error(`Keyword ${kwd} has invalid name`);
        });
        if (!def2)
          return;
        if (def2.$data && !("code" in def2 || "validate" in def2)) {
          throw new Error('$data keyword must have "code" or "validate" function');
        }
      }
      function addRule(keyword2, definition, dataType2) {
        var _a2;
        const post = definition === null || definition === void 0 ? void 0 : definition.post;
        if (dataType2 && post)
          throw new Error('keyword with "post" flag cannot have "type"');
        const { RULES: RULES2 } = this;
        let ruleGroup = post ? RULES2.post : RULES2.rules.find(({ type: t }) => t === dataType2);
        if (!ruleGroup) {
          ruleGroup = { type: dataType2, rules: [] };
          RULES2.rules.push(ruleGroup);
        }
        RULES2.keywords[keyword2] = true;
        if (!definition)
          return;
        const rule = {
          keyword: keyword2,
          definition: {
            ...definition,
            type: (0, dataType_12.getJSONTypes)(definition.type),
            schemaType: (0, dataType_12.getJSONTypes)(definition.schemaType)
          }
        };
        if (definition.before)
          addBeforeRule.call(this, ruleGroup, rule, definition.before);
        else
          ruleGroup.rules.push(rule);
        RULES2.all[keyword2] = rule;
        (_a2 = definition.implements) === null || _a2 === void 0 ? void 0 : _a2.forEach((kwd) => this.addKeyword(kwd));
      }
      function addBeforeRule(ruleGroup, rule, before) {
        const i2 = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
        if (i2 >= 0) {
          ruleGroup.rules.splice(i2, 0, rule);
        } else {
          ruleGroup.rules.push(rule);
          this.logger.warn(`rule ${before} is not defined`);
        }
      }
      function keywordMetaschema(def2) {
        let { metaSchema: metaSchema2 } = def2;
        if (metaSchema2 === void 0)
          return;
        if (def2.$data && this.opts.$data)
          metaSchema2 = schemaOrData(metaSchema2);
        def2.validateSchema = this.compile(metaSchema2, true);
      }
      const $dataRef = {
        $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
      };
      function schemaOrData(schema) {
        return { anyOf: [schema, $dataRef] };
      }
    })(core$3);
    var draft7 = {};
    var core$2 = {};
    var id$1 = {};
    Object.defineProperty(id$1, "__esModule", { value: true });
    const def$B = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    id$1.default = def$B;
    var ref = {};
    Object.defineProperty(ref, "__esModule", { value: true });
    ref.callRef = ref.getValidate = void 0;
    const ref_error_1 = ref_error;
    const code_1$8 = code$1;
    const codegen_1$p = codegen;
    const names_1$4 = names$2;
    const compile_1$2 = compile$2;
    const util_1$n = util;
    const def$A = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it: it2 } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it2;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1$2.resolveRef.call(self2, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it2.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1$2.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1$p._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1$p.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1$p.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1$p._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    ref.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it: it2 } = cxt;
      const { allErrors, schemaEnv: env, opts } = it2;
      const passCxt = opts.passContext ? names_1$4.default.this : codegen_1$p.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1$p._)`await ${(0, code_1$8.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1$p._)`!(${e} instanceof ${it2.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1$8.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1$p._)`${source}.errors`;
        gen.assign(names_1$4.default.vErrors, (0, codegen_1$p._)`${names_1$4.default.vErrors} === null ? ${errs} : ${names_1$4.default.vErrors}.concat(${errs})`);
        gen.assign(names_1$4.default.errors, (0, codegen_1$p._)`${names_1$4.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a2;
        if (!it2.opts.unevaluated)
          return;
        const schEvaluated = (_a2 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a2 === void 0 ? void 0 : _a2.evaluated;
        if (it2.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it2.props = util_1$n.mergeEvaluated.props(gen, schEvaluated.props, it2.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1$p._)`${source}.evaluated.props`);
            it2.props = util_1$n.mergeEvaluated.props(gen, props, it2.props, codegen_1$p.Name);
          }
        }
        if (it2.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it2.items = util_1$n.mergeEvaluated.items(gen, schEvaluated.items, it2.items);
            }
          } else {
            const items2 = gen.var("items", (0, codegen_1$p._)`${source}.evaluated.items`);
            it2.items = util_1$n.mergeEvaluated.items(gen, items2, it2.items, codegen_1$p.Name);
          }
        }
      }
    }
    ref.callRef = callRef;
    ref.default = def$A;
    Object.defineProperty(core$2, "__esModule", { value: true });
    const id_1 = id$1;
    const ref_1$2 = ref;
    const core$1 = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1$2.default
    ];
    core$2.default = core$1;
    var validation$2 = {};
    var limitNumber = {};
    Object.defineProperty(limitNumber, "__esModule", { value: true });
    const codegen_1$o = codegen;
    const ops = codegen_1$o.operators;
    const KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    const error$l = {
      message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$o.str)`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
      params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$o._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
    };
    const def$z = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error: error$l,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1$o._)`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    limitNumber.default = def$z;
    var multipleOf = {};
    Object.defineProperty(multipleOf, "__esModule", { value: true });
    const codegen_1$n = codegen;
    const error$k = {
      message: ({ schemaCode }) => (0, codegen_1$n.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1$n._)`{multipleOf: ${schemaCode}}`
    };
    const def$y = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error: error$k,
      code(cxt) {
        const { gen, data, schemaCode, it: it2 } = cxt;
        const prec2 = it2.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec2 ? (0, codegen_1$n._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec2}` : (0, codegen_1$n._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1$n._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    multipleOf.default = def$y;
    var limitLength = {};
    var ucs2length$1 = {};
    Object.defineProperty(ucs2length$1, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    ucs2length$1.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
    Object.defineProperty(limitLength, "__esModule", { value: true });
    const codegen_1$m = codegen;
    const util_1$m = util;
    const ucs2length_1 = ucs2length$1;
    const error$j = {
      message({ keyword: keyword2, schemaCode }) {
        const comp2 = keyword2 === "maxLength" ? "more" : "fewer";
        return (0, codegen_1$m.str)`must NOT have ${comp2} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1$m._)`{limit: ${schemaCode}}`
    };
    const def$x = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error: error$j,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode, it: it2 } = cxt;
        const op = keyword2 === "maxLength" ? codegen_1$m.operators.GT : codegen_1$m.operators.LT;
        const len = it2.opts.unicode === false ? (0, codegen_1$m._)`${data}.length` : (0, codegen_1$m._)`${(0, util_1$m.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1$m._)`${len} ${op} ${schemaCode}`);
      }
    };
    limitLength.default = def$x;
    var pattern = {};
    Object.defineProperty(pattern, "__esModule", { value: true });
    const code_1$7 = code$1;
    const codegen_1$l = codegen;
    const error$i = {
      message: ({ schemaCode }) => (0, codegen_1$l.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1$l._)`{pattern: ${schemaCode}}`
    };
    const def$w = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error: error$i,
      code(cxt) {
        const { data, $data, schema, schemaCode, it: it2 } = cxt;
        const u = it2.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1$l._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1$7.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1$l._)`!${regExp}.test(${data})`);
      }
    };
    pattern.default = def$w;
    var limitProperties = {};
    Object.defineProperty(limitProperties, "__esModule", { value: true });
    const codegen_1$k = codegen;
    const error$h = {
      message({ keyword: keyword2, schemaCode }) {
        const comp2 = keyword2 === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1$k.str)`must NOT have ${comp2} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1$k._)`{limit: ${schemaCode}}`
    };
    const def$v = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error: error$h,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode } = cxt;
        const op = keyword2 === "maxProperties" ? codegen_1$k.operators.GT : codegen_1$k.operators.LT;
        cxt.fail$data((0, codegen_1$k._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    limitProperties.default = def$v;
    var required = {};
    Object.defineProperty(required, "__esModule", { value: true });
    const code_1$6 = code$1;
    const codegen_1$j = codegen;
    const util_1$l = util;
    const error$g = {
      message: ({ params: { missingProperty } }) => (0, codegen_1$j.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1$j._)`{missingProperty: ${missingProperty}}`
    };
    const def$u = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error: error$g,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it: it2 } = cxt;
        const { opts } = it2;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it2.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1$l.checkStrictMode)(it2, msg, it2.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1$j.nil, loopAllRequired);
          } else {
            for (const prop2 of schema) {
              (0, code_1$6.checkReportMissingProp)(cxt, prop2);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1$6.checkMissingProp)(cxt, schema, missing));
            (0, code_1$6.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop2) => {
            cxt.setParams({ missingProperty: prop2 });
            gen.if((0, code_1$6.noPropertyInData)(gen, data, prop2, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1$6.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1$j.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1$j.nil);
        }
      }
    };
    required.default = def$u;
    var limitItems = {};
    Object.defineProperty(limitItems, "__esModule", { value: true });
    const codegen_1$i = codegen;
    const error$f = {
      message({ keyword: keyword2, schemaCode }) {
        const comp2 = keyword2 === "maxItems" ? "more" : "fewer";
        return (0, codegen_1$i.str)`must NOT have ${comp2} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1$i._)`{limit: ${schemaCode}}`
    };
    const def$t = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error: error$f,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode } = cxt;
        const op = keyword2 === "maxItems" ? codegen_1$i.operators.GT : codegen_1$i.operators.LT;
        cxt.fail$data((0, codegen_1$i._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    limitItems.default = def$t;
    var uniqueItems = {};
    var equal$1 = {};
    Object.defineProperty(equal$1, "__esModule", { value: true });
    const equal = fastDeepEqual;
    equal.code = 'require("ajv/dist/runtime/equal").default';
    equal$1.default = equal;
    Object.defineProperty(uniqueItems, "__esModule", { value: true });
    const dataType_1 = dataType;
    const codegen_1$h = codegen;
    const util_1$k = util;
    const equal_1$2 = equal$1;
    const error$e = {
      message: ({ params: { i: i2, j } }) => (0, codegen_1$h.str)`must NOT have duplicate items (items ## ${j} and ${i2} are identical)`,
      params: ({ params: { i: i2, j } }) => (0, codegen_1$h._)`{i: ${i2}, j: ${j}}`
    };
    const def$s = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error: error$e,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it: it2 } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1$h._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i2 = gen.let("i", (0, codegen_1$h._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i: i2, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1$h._)`${i2} > 1`, () => (canOptimize() ? loopN : loopN2)(i2, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i2, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it2.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1$h._)`{}`);
          gen.for((0, codegen_1$h._)`;${i2}--;`, () => {
            gen.let(item, (0, codegen_1$h._)`${data}[${i2}]`);
            gen.if(wrongType, (0, codegen_1$h._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1$h._)`typeof ${item} == "string"`, (0, codegen_1$h._)`${item} += "_"`);
            gen.if((0, codegen_1$h._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1$h._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1$h._)`${indices}[${item}] = ${i2}`);
          });
        }
        function loopN2(i2, j) {
          const eql = (0, util_1$k.useFunc)(gen, equal_1$2.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1$h._)`;${i2}--;`, () => gen.for((0, codegen_1$h._)`${j} = ${i2}; ${j}--;`, () => gen.if((0, codegen_1$h._)`${eql}(${data}[${i2}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    uniqueItems.default = def$s;
    var _const = {};
    Object.defineProperty(_const, "__esModule", { value: true });
    const codegen_1$g = codegen;
    const util_1$j = util;
    const equal_1$1 = equal$1;
    const error$d = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1$g._)`{allowedValue: ${schemaCode}}`
    };
    const def$r = {
      keyword: "const",
      $data: true,
      error: error$d,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1$g._)`!${(0, util_1$j.useFunc)(gen, equal_1$1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1$g._)`${schema} !== ${data}`);
        }
      }
    };
    _const.default = def$r;
    var _enum = {};
    Object.defineProperty(_enum, "__esModule", { value: true });
    const codegen_1$f = codegen;
    const util_1$i = util;
    const equal_1 = equal$1;
    const error$c = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1$f._)`{allowedValues: ${schemaCode}}`
    };
    const def$q = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error: error$c,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it2.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1$i.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1$f.or)(...schema.map((_x, i2) => equalCode(vSchema, i2)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1$f._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i2) {
          const sch = schema[i2];
          return typeof sch === "object" && sch !== null ? (0, codegen_1$f._)`${getEql()}(${data}, ${vSchema}[${i2}])` : (0, codegen_1$f._)`${data} === ${sch}`;
        }
      }
    };
    _enum.default = def$q;
    Object.defineProperty(validation$2, "__esModule", { value: true });
    const limitNumber_1 = limitNumber;
    const multipleOf_1 = multipleOf;
    const limitLength_1 = limitLength;
    const pattern_1 = pattern;
    const limitProperties_1 = limitProperties;
    const required_1 = required;
    const limitItems_1 = limitItems;
    const uniqueItems_1 = uniqueItems;
    const const_1 = _const;
    const enum_1 = _enum;
    const validation$1 = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    validation$2.default = validation$1;
    var applicator$1 = {};
    var additionalItems = {};
    Object.defineProperty(additionalItems, "__esModule", { value: true });
    additionalItems.validateAdditionalItems = void 0;
    const codegen_1$e = codegen;
    const util_1$h = util;
    const error$b = {
      message: ({ params: { len } }) => (0, codegen_1$e.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1$e._)`{limit: ${len}}`
    };
    const def$p = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error: error$b,
      code(cxt) {
        const { parentSchema, it: it2 } = cxt;
        const { items: items2 } = parentSchema;
        if (!Array.isArray(items2)) {
          (0, util_1$h.checkStrictMode)(it2, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items2);
      }
    };
    function validateAdditionalItems(cxt, items2) {
      const { gen, schema, data, keyword: keyword2, it: it2 } = cxt;
      it2.items = true;
      const len = gen.const("len", (0, codegen_1$e._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items2.length });
        cxt.pass((0, codegen_1$e._)`${len} <= ${items2.length}`);
      } else if (typeof schema == "object" && !(0, util_1$h.alwaysValidSchema)(it2, schema)) {
        const valid = gen.var("valid", (0, codegen_1$e._)`${len} <= ${items2.length}`);
        gen.if((0, codegen_1$e.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items2.length, len, (i2) => {
          cxt.subschema({ keyword: keyword2, dataProp: i2, dataPropType: util_1$h.Type.Num }, valid);
          if (!it2.allErrors)
            gen.if((0, codegen_1$e.not)(valid), () => gen.break());
        });
      }
    }
    additionalItems.validateAdditionalItems = validateAdditionalItems;
    additionalItems.default = def$p;
    var prefixItems = {};
    var items = {};
    Object.defineProperty(items, "__esModule", { value: true });
    items.validateTuple = void 0;
    const codegen_1$d = codegen;
    const util_1$g = util;
    const code_1$5 = code$1;
    const def$o = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it: it2 } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it2.items = true;
        if ((0, util_1$g.alwaysValidSchema)(it2, schema))
          return;
        cxt.ok((0, code_1$5.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword: keyword2, it: it2 } = cxt;
      checkStrictTuple(parentSchema);
      if (it2.opts.unevaluated && schArr.length && it2.items !== true) {
        it2.items = util_1$g.mergeEvaluated.items(gen, schArr.length, it2.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1$d._)`${data}.length`);
      schArr.forEach((sch, i2) => {
        if ((0, util_1$g.alwaysValidSchema)(it2, sch))
          return;
        gen.if((0, codegen_1$d._)`${len} > ${i2}`, () => cxt.subschema({
          keyword: keyword2,
          schemaProp: i2,
          dataProp: i2
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it2;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1$g.checkStrictMode)(it2, msg, opts.strictTuples);
        }
      }
    }
    items.validateTuple = validateTuple;
    items.default = def$o;
    Object.defineProperty(prefixItems, "__esModule", { value: true });
    const items_1$1 = items;
    const def$n = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1$1.validateTuple)(cxt, "items")
    };
    prefixItems.default = def$n;
    var items2020 = {};
    Object.defineProperty(items2020, "__esModule", { value: true });
    const codegen_1$c = codegen;
    const util_1$f = util;
    const code_1$4 = code$1;
    const additionalItems_1$1 = additionalItems;
    const error$a = {
      message: ({ params: { len } }) => (0, codegen_1$c.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1$c._)`{limit: ${len}}`
    };
    const def$m = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error: error$a,
      code(cxt) {
        const { schema, parentSchema, it: it2 } = cxt;
        const { prefixItems: prefixItems2 } = parentSchema;
        it2.items = true;
        if ((0, util_1$f.alwaysValidSchema)(it2, schema))
          return;
        if (prefixItems2)
          (0, additionalItems_1$1.validateAdditionalItems)(cxt, prefixItems2);
        else
          cxt.ok((0, code_1$4.validateArray)(cxt));
      }
    };
    items2020.default = def$m;
    var contains = {};
    Object.defineProperty(contains, "__esModule", { value: true });
    const codegen_1$b = codegen;
    const util_1$e = util;
    const error$9 = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$b.str)`must contain at least ${min} valid item(s)` : (0, codegen_1$b.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$b._)`{minContains: ${min}}` : (0, codegen_1$b._)`{minContains: ${min}, maxContains: ${max}}`
    };
    const def$l = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error: error$9,
      code(cxt) {
        const { gen, schema, parentSchema, data, it: it2 } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it2.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1$b._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1$e.checkStrictMode)(it2, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1$e.checkStrictMode)(it2, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1$e.alwaysValidSchema)(it2, schema)) {
          let cond = (0, codegen_1$b._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1$b._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it2.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1$b._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block2) {
          gen.forRange("i", 0, len, (i2) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i2,
              dataPropType: util_1$e.Type.Num,
              compositeRule: true
            }, _valid);
            block2();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1$b._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1$b._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1$b._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1$b._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    contains.default = def$l;
    var dependencies = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.validateSchemaDeps = exports2.validatePropertyDeps = exports2.error = void 0;
      const codegen_12 = codegen;
      const util_12 = util;
      const code_12 = code$1;
      exports2.error = {
        message: ({ params: { property, depsCount, deps } }) => {
          const property_ies = depsCount === 1 ? "property" : "properties";
          return (0, codegen_12.str)`must have ${property_ies} ${deps} when property ${property} is present`;
        },
        params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_12._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
        // TODO change to reference
      };
      const def2 = {
        keyword: "dependencies",
        type: "object",
        schemaType: "object",
        error: exports2.error,
        code(cxt) {
          const [propDeps, schDeps] = splitDependencies(cxt);
          validatePropertyDeps(cxt, propDeps);
          validateSchemaDeps(cxt, schDeps);
        }
      };
      function splitDependencies({ schema }) {
        const propertyDeps = {};
        const schemaDeps = {};
        for (const key in schema) {
          if (key === "__proto__")
            continue;
          const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
          deps[key] = schema[key];
        }
        return [propertyDeps, schemaDeps];
      }
      function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
        const { gen, data, it: it2 } = cxt;
        if (Object.keys(propertyDeps).length === 0)
          return;
        const missing = gen.let("missing");
        for (const prop2 in propertyDeps) {
          const deps = propertyDeps[prop2];
          if (deps.length === 0)
            continue;
          const hasProperty = (0, code_12.propertyInData)(gen, data, prop2, it2.opts.ownProperties);
          cxt.setParams({
            property: prop2,
            depsCount: deps.length,
            deps: deps.join(", ")
          });
          if (it2.allErrors) {
            gen.if(hasProperty, () => {
              for (const depProp of deps) {
                (0, code_12.checkReportMissingProp)(cxt, depProp);
              }
            });
          } else {
            gen.if((0, codegen_12._)`${hasProperty} && (${(0, code_12.checkMissingProp)(cxt, deps, missing)})`);
            (0, code_12.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
      }
      exports2.validatePropertyDeps = validatePropertyDeps;
      function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
        const { gen, data, keyword: keyword2, it: it2 } = cxt;
        const valid = gen.name("valid");
        for (const prop2 in schemaDeps) {
          if ((0, util_12.alwaysValidSchema)(it2, schemaDeps[prop2]))
            continue;
          gen.if(
            (0, code_12.propertyInData)(gen, data, prop2, it2.opts.ownProperties),
            () => {
              const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop2 }, valid);
              cxt.mergeValidEvaluated(schCxt, valid);
            },
            () => gen.var(valid, true)
            // TODO var
          );
          cxt.ok(valid);
        }
      }
      exports2.validateSchemaDeps = validateSchemaDeps;
      exports2.default = def2;
    })(dependencies);
    var propertyNames = {};
    Object.defineProperty(propertyNames, "__esModule", { value: true });
    const codegen_1$a = codegen;
    const util_1$d = util;
    const error$8 = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1$a._)`{propertyName: ${params.propertyName}}`
    };
    const def$k = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error: error$8,
      code(cxt) {
        const { gen, schema, data, it: it2 } = cxt;
        if ((0, util_1$d.alwaysValidSchema)(it2, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1$a.not)(valid), () => {
            cxt.error(true);
            if (!it2.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    propertyNames.default = def$k;
    var additionalProperties = {};
    Object.defineProperty(additionalProperties, "__esModule", { value: true });
    const code_1$3 = code$1;
    const codegen_1$9 = codegen;
    const names_1$3 = names$2;
    const util_1$c = util;
    const error$7 = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1$9._)`{additionalProperty: ${params.additionalProperty}}`
    };
    const def$j = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error: error$7,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it: it2 } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it2;
        it2.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1$c.alwaysValidSchema)(it2, schema))
          return;
        const props = (0, code_1$3.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1$3.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1$9._)`${errsCount} === ${names_1$3.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1$c.schemaRefOrVal)(it2, parentSchema.properties, "properties");
            definedProp = (0, code_1$3.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1$9.or)(...props.map((p2) => (0, codegen_1$9._)`${key} === ${p2}`));
          } else {
            definedProp = codegen_1$9.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1$9.or)(definedProp, ...patProps.map((p2) => (0, codegen_1$9._)`${(0, code_1$3.usePattern)(cxt, p2)}.test(${key})`));
          }
          return (0, codegen_1$9.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1$9._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1$c.alwaysValidSchema)(it2, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1$9.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1$9.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors2) {
          const subschema2 = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1$c.Type.Str
          };
          if (errors2 === false) {
            Object.assign(subschema2, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema2, valid);
        }
      }
    };
    additionalProperties.default = def$j;
    var properties$8 = {};
    Object.defineProperty(properties$8, "__esModule", { value: true });
    const validate_1 = validate;
    const code_1$2 = code$1;
    const util_1$b = util;
    const additionalProperties_1$1 = additionalProperties;
    const def$i = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it: it2 } = cxt;
        if (it2.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1$1.default.code(new validate_1.KeywordCxt(it2, additionalProperties_1$1.default, "additionalProperties"));
        }
        const allProps = (0, code_1$2.allSchemaProperties)(schema);
        for (const prop2 of allProps) {
          it2.definedProperties.add(prop2);
        }
        if (it2.opts.unevaluated && allProps.length && it2.props !== true) {
          it2.props = util_1$b.mergeEvaluated.props(gen, (0, util_1$b.toHash)(allProps), it2.props);
        }
        const properties2 = allProps.filter((p2) => !(0, util_1$b.alwaysValidSchema)(it2, schema[p2]));
        if (properties2.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop2 of properties2) {
          if (hasDefault(prop2)) {
            applyPropertySchema(prop2);
          } else {
            gen.if((0, code_1$2.propertyInData)(gen, data, prop2, it2.opts.ownProperties));
            applyPropertySchema(prop2);
            if (!it2.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop2);
          cxt.ok(valid);
        }
        function hasDefault(prop2) {
          return it2.opts.useDefaults && !it2.compositeRule && schema[prop2].default !== void 0;
        }
        function applyPropertySchema(prop2) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop2,
            dataProp: prop2
          }, valid);
        }
      }
    };
    properties$8.default = def$i;
    var patternProperties = {};
    Object.defineProperty(patternProperties, "__esModule", { value: true });
    const code_1$1 = code$1;
    const codegen_1$8 = codegen;
    const util_1$a = util;
    const util_2 = util;
    const def$h = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it: it2 } = cxt;
        const { opts } = it2;
        const patterns = (0, code_1$1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p2) => (0, util_1$a.alwaysValidSchema)(it2, schema[p2]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it2.opts.unevaluated || it2.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it2.props !== true && !(it2.props instanceof codegen_1$8.Name)) {
          it2.props = (0, util_2.evaluatedPropsToName)(gen, it2.props);
        }
        const { props } = it2;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it2.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop2 in checkProperties) {
            if (new RegExp(pat).test(prop2)) {
              (0, util_1$a.checkStrictMode)(it2, `property ${prop2} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1$8._)`${(0, code_1$1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it2.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1$8._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it2.allErrors) {
                gen.if((0, codegen_1$8.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    patternProperties.default = def$h;
    var not$1 = {};
    Object.defineProperty(not$1, "__esModule", { value: true });
    const util_1$9 = util;
    const def$g = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it: it2 } = cxt;
        if ((0, util_1$9.alwaysValidSchema)(it2, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    not$1.default = def$g;
    var anyOf = {};
    Object.defineProperty(anyOf, "__esModule", { value: true });
    const code_1 = code$1;
    const def$f = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    anyOf.default = def$f;
    var oneOf = {};
    Object.defineProperty(oneOf, "__esModule", { value: true });
    const codegen_1$7 = codegen;
    const util_1$8 = util;
    const error$6 = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1$7._)`{passingSchemas: ${params.passing}}`
    };
    const def$e = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error: error$6,
      code(cxt) {
        const { gen, schema, parentSchema, it: it2 } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it2.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i2) => {
            let schCxt;
            if ((0, util_1$8.alwaysValidSchema)(it2, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i2,
                compositeRule: true
              }, schValid);
            }
            if (i2 > 0) {
              gen.if((0, codegen_1$7._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1$7._)`[${passing}, ${i2}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i2);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1$7.Name);
            });
          });
        }
      }
    };
    oneOf.default = def$e;
    var allOf$1 = {};
    Object.defineProperty(allOf$1, "__esModule", { value: true });
    const util_1$7 = util;
    const def$d = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it: it2 } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i2) => {
          if ((0, util_1$7.alwaysValidSchema)(it2, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i2 }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    allOf$1.default = def$d;
    var _if = {};
    Object.defineProperty(_if, "__esModule", { value: true });
    const codegen_1$6 = codegen;
    const util_1$6 = util;
    const error$5 = {
      message: ({ params }) => (0, codegen_1$6.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1$6._)`{failingKeyword: ${params.ifClause}}`
    };
    const def$c = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error: error$5,
      code(cxt) {
        const { gen, parentSchema, it: it2 } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1$6.checkStrictMode)(it2, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it2, "then");
        const hasElse = hasSchema(it2, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1$6.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword2, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1$6._)`${keyword2}`);
            else
              cxt.setParams({ ifClause: keyword2 });
          };
        }
      }
    };
    function hasSchema(it2, keyword2) {
      const schema = it2.schema[keyword2];
      return schema !== void 0 && !(0, util_1$6.alwaysValidSchema)(it2, schema);
    }
    _if.default = def$c;
    var thenElse = {};
    Object.defineProperty(thenElse, "__esModule", { value: true });
    const util_1$5 = util;
    const def$b = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword: keyword2, parentSchema, it: it2 }) {
        if (parentSchema.if === void 0)
          (0, util_1$5.checkStrictMode)(it2, `"${keyword2}" without "if" is ignored`);
      }
    };
    thenElse.default = def$b;
    Object.defineProperty(applicator$1, "__esModule", { value: true });
    const additionalItems_1 = additionalItems;
    const prefixItems_1 = prefixItems;
    const items_1 = items;
    const items2020_1 = items2020;
    const contains_1 = contains;
    const dependencies_1$2 = dependencies;
    const propertyNames_1 = propertyNames;
    const additionalProperties_1 = additionalProperties;
    const properties_1 = properties$8;
    const patternProperties_1 = patternProperties;
    const not_1 = not$1;
    const anyOf_1 = anyOf;
    const oneOf_1 = oneOf;
    const allOf_1 = allOf$1;
    const if_1 = _if;
    const thenElse_1 = thenElse;
    function getApplicator(draft2020 = false) {
      const applicator2 = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1$2.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator2.push(prefixItems_1.default, items2020_1.default);
      else
        applicator2.push(additionalItems_1.default, items_1.default);
      applicator2.push(contains_1.default);
      return applicator2;
    }
    applicator$1.default = getApplicator;
    var format$4 = {};
    var format$3 = {};
    Object.defineProperty(format$3, "__esModule", { value: true });
    const codegen_1$5 = codegen;
    const error$4 = {
      message: ({ schemaCode }) => (0, codegen_1$5.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1$5._)`{format: ${schemaCode}}`
    };
    const def$a = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error: error$4,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
        const { opts, errSchemaPath, schemaEnv, self: self2 } = it2;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1$5._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format2 = gen.let("format");
          gen.if((0, codegen_1$5._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1$5._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1$5._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1$5._)`"string"`).assign(format2, fDef));
          cxt.fail$data((0, codegen_1$5.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1$5.nil;
            return (0, codegen_1$5._)`${schemaCode} && !${format2}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1$5._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1$5._)`${format2}(${data})`;
            const validData = (0, codegen_1$5._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
            return (0, codegen_1$5._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self2.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format2, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code2 = fmtDef instanceof RegExp ? (0, codegen_1$5.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1$5._)`${opts.code.formats}${(0, codegen_1$5.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code: code2 });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1$5._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1$5._)`await ${fmtRef}(${data})`;
            }
            return typeof format2 == "function" ? (0, codegen_1$5._)`${fmtRef}(${data})` : (0, codegen_1$5._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    format$3.default = def$a;
    Object.defineProperty(format$4, "__esModule", { value: true });
    const format_1$1 = format$3;
    const format$2 = [format_1$1.default];
    format$4.default = format$2;
    var metadata$1 = {};
    Object.defineProperty(metadata$1, "__esModule", { value: true });
    metadata$1.contentVocabulary = metadata$1.metadataVocabulary = void 0;
    metadata$1.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    metadata$1.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
    Object.defineProperty(draft7, "__esModule", { value: true });
    const core_1 = core$2;
    const validation_1 = validation$2;
    const applicator_1 = applicator$1;
    const format_1 = format$4;
    const metadata_1 = metadata$1;
    const draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    draft7.default = draft7Vocabularies;
    var dynamic$1 = {};
    var dynamicAnchor$1 = {};
    Object.defineProperty(dynamicAnchor$1, "__esModule", { value: true });
    dynamicAnchor$1.dynamicAnchor = void 0;
    const codegen_1$4 = codegen;
    const names_1$2 = names$2;
    const compile_1$1 = compile$2;
    const ref_1$1 = ref;
    const def$9 = {
      keyword: "$dynamicAnchor",
      schemaType: "string",
      code: (cxt) => dynamicAnchor(cxt, cxt.schema)
    };
    function dynamicAnchor(cxt, anchor) {
      const { gen, it: it2 } = cxt;
      it2.schemaEnv.root.dynamicAnchors[anchor] = true;
      const v = (0, codegen_1$4._)`${names_1$2.default.dynamicAnchors}${(0, codegen_1$4.getProperty)(anchor)}`;
      const validate2 = it2.errSchemaPath === "#" ? it2.validateName : _getValidate(cxt);
      gen.if((0, codegen_1$4._)`!${v}`, () => gen.assign(v, validate2));
    }
    dynamicAnchor$1.dynamicAnchor = dynamicAnchor;
    function _getValidate(cxt) {
      const { schemaEnv, schema, self: self2 } = cxt.it;
      const { root, baseId, localRefs, meta } = schemaEnv.root;
      const { schemaId } = self2.opts;
      const sch = new compile_1$1.SchemaEnv({ schema, schemaId, root, baseId, localRefs, meta });
      compile_1$1.compileSchema.call(self2, sch);
      return (0, ref_1$1.getValidate)(cxt, sch);
    }
    dynamicAnchor$1.default = def$9;
    var dynamicRef$1 = {};
    Object.defineProperty(dynamicRef$1, "__esModule", { value: true });
    dynamicRef$1.dynamicRef = void 0;
    const codegen_1$3 = codegen;
    const names_1$1 = names$2;
    const ref_1 = ref;
    const def$8 = {
      keyword: "$dynamicRef",
      schemaType: "string",
      code: (cxt) => dynamicRef(cxt, cxt.schema)
    };
    function dynamicRef(cxt, ref2) {
      const { gen, keyword: keyword2, it: it2 } = cxt;
      if (ref2[0] !== "#")
        throw new Error(`"${keyword2}" only supports hash fragment reference`);
      const anchor = ref2.slice(1);
      if (it2.allErrors) {
        _dynamicRef();
      } else {
        const valid = gen.let("valid", false);
        _dynamicRef(valid);
        cxt.ok(valid);
      }
      function _dynamicRef(valid) {
        if (it2.schemaEnv.root.dynamicAnchors[anchor]) {
          const v = gen.let("_v", (0, codegen_1$3._)`${names_1$1.default.dynamicAnchors}${(0, codegen_1$3.getProperty)(anchor)}`);
          gen.if(v, _callRef(v, valid), _callRef(it2.validateName, valid));
        } else {
          _callRef(it2.validateName, valid)();
        }
      }
      function _callRef(validate2, valid) {
        return valid ? () => gen.block(() => {
          (0, ref_1.callRef)(cxt, validate2);
          gen.let(valid, true);
        }) : () => (0, ref_1.callRef)(cxt, validate2);
      }
    }
    dynamicRef$1.dynamicRef = dynamicRef;
    dynamicRef$1.default = def$8;
    var recursiveAnchor = {};
    Object.defineProperty(recursiveAnchor, "__esModule", { value: true });
    const dynamicAnchor_1$1 = dynamicAnchor$1;
    const util_1$4 = util;
    const def$7 = {
      keyword: "$recursiveAnchor",
      schemaType: "boolean",
      code(cxt) {
        if (cxt.schema)
          (0, dynamicAnchor_1$1.dynamicAnchor)(cxt, "");
        else
          (0, util_1$4.checkStrictMode)(cxt.it, "$recursiveAnchor: false is ignored");
      }
    };
    recursiveAnchor.default = def$7;
    var recursiveRef = {};
    Object.defineProperty(recursiveRef, "__esModule", { value: true });
    const dynamicRef_1$1 = dynamicRef$1;
    const def$6 = {
      keyword: "$recursiveRef",
      schemaType: "string",
      code: (cxt) => (0, dynamicRef_1$1.dynamicRef)(cxt, cxt.schema)
    };
    recursiveRef.default = def$6;
    Object.defineProperty(dynamic$1, "__esModule", { value: true });
    const dynamicAnchor_1 = dynamicAnchor$1;
    const dynamicRef_1 = dynamicRef$1;
    const recursiveAnchor_1 = recursiveAnchor;
    const recursiveRef_1 = recursiveRef;
    const dynamic = [dynamicAnchor_1.default, dynamicRef_1.default, recursiveAnchor_1.default, recursiveRef_1.default];
    dynamic$1.default = dynamic;
    var next$1 = {};
    var dependentRequired = {};
    Object.defineProperty(dependentRequired, "__esModule", { value: true });
    const dependencies_1$1 = dependencies;
    const def$5 = {
      keyword: "dependentRequired",
      type: "object",
      schemaType: "object",
      error: dependencies_1$1.error,
      code: (cxt) => (0, dependencies_1$1.validatePropertyDeps)(cxt)
    };
    dependentRequired.default = def$5;
    var dependentSchemas = {};
    Object.defineProperty(dependentSchemas, "__esModule", { value: true });
    const dependencies_1 = dependencies;
    const def$4 = {
      keyword: "dependentSchemas",
      type: "object",
      schemaType: "object",
      code: (cxt) => (0, dependencies_1.validateSchemaDeps)(cxt)
    };
    dependentSchemas.default = def$4;
    var limitContains = {};
    Object.defineProperty(limitContains, "__esModule", { value: true });
    const util_1$3 = util;
    const def$3 = {
      keyword: ["maxContains", "minContains"],
      type: "array",
      schemaType: "number",
      code({ keyword: keyword2, parentSchema, it: it2 }) {
        if (parentSchema.contains === void 0) {
          (0, util_1$3.checkStrictMode)(it2, `"${keyword2}" without "contains" is ignored`);
        }
      }
    };
    limitContains.default = def$3;
    Object.defineProperty(next$1, "__esModule", { value: true });
    const dependentRequired_1 = dependentRequired;
    const dependentSchemas_1 = dependentSchemas;
    const limitContains_1 = limitContains;
    const next = [dependentRequired_1.default, dependentSchemas_1.default, limitContains_1.default];
    next$1.default = next;
    var unevaluated$1 = {};
    var unevaluatedProperties = {};
    Object.defineProperty(unevaluatedProperties, "__esModule", { value: true });
    const codegen_1$2 = codegen;
    const util_1$2 = util;
    const names_1 = names$2;
    const error$3 = {
      message: "must NOT have unevaluated properties",
      params: ({ params }) => (0, codegen_1$2._)`{unevaluatedProperty: ${params.unevaluatedProperty}}`
    };
    const def$2 = {
      keyword: "unevaluatedProperties",
      type: "object",
      schemaType: ["boolean", "object"],
      trackErrors: true,
      error: error$3,
      code(cxt) {
        const { gen, schema, data, errsCount, it: it2 } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, props } = it2;
        if (props instanceof codegen_1$2.Name) {
          gen.if((0, codegen_1$2._)`${props} !== true`, () => gen.forIn("key", data, (key) => gen.if(unevaluatedDynamic(props, key), () => unevaluatedPropCode(key))));
        } else if (props !== true) {
          gen.forIn("key", data, (key) => props === void 0 ? unevaluatedPropCode(key) : gen.if(unevaluatedStatic(props, key), () => unevaluatedPropCode(key)));
        }
        it2.props = true;
        cxt.ok((0, codegen_1$2._)`${errsCount} === ${names_1.default.errors}`);
        function unevaluatedPropCode(key) {
          if (schema === false) {
            cxt.setParams({ unevaluatedProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (!(0, util_1$2.alwaysValidSchema)(it2, schema)) {
            const valid = gen.name("valid");
            cxt.subschema({
              keyword: "unevaluatedProperties",
              dataProp: key,
              dataPropType: util_1$2.Type.Str
            }, valid);
            if (!allErrors)
              gen.if((0, codegen_1$2.not)(valid), () => gen.break());
          }
        }
        function unevaluatedDynamic(evaluatedProps, key) {
          return (0, codegen_1$2._)`!${evaluatedProps} || !${evaluatedProps}[${key}]`;
        }
        function unevaluatedStatic(evaluatedProps, key) {
          const ps = [];
          for (const p2 in evaluatedProps) {
            if (evaluatedProps[p2] === true)
              ps.push((0, codegen_1$2._)`${key} !== ${p2}`);
          }
          return (0, codegen_1$2.and)(...ps);
        }
      }
    };
    unevaluatedProperties.default = def$2;
    var unevaluatedItems = {};
    Object.defineProperty(unevaluatedItems, "__esModule", { value: true });
    const codegen_1$1 = codegen;
    const util_1$1 = util;
    const error$2 = {
      message: ({ params: { len } }) => (0, codegen_1$1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1$1._)`{limit: ${len}}`
    };
    const def$1 = {
      keyword: "unevaluatedItems",
      type: "array",
      schemaType: ["boolean", "object"],
      error: error$2,
      code(cxt) {
        const { gen, schema, data, it: it2 } = cxt;
        const items2 = it2.items || 0;
        if (items2 === true)
          return;
        const len = gen.const("len", (0, codegen_1$1._)`${data}.length`);
        if (schema === false) {
          cxt.setParams({ len: items2 });
          cxt.fail((0, codegen_1$1._)`${len} > ${items2}`);
        } else if (typeof schema == "object" && !(0, util_1$1.alwaysValidSchema)(it2, schema)) {
          const valid = gen.var("valid", (0, codegen_1$1._)`${len} <= ${items2}`);
          gen.if((0, codegen_1$1.not)(valid), () => validateItems(valid, items2));
          cxt.ok(valid);
        }
        it2.items = true;
        function validateItems(valid, from) {
          gen.forRange("i", from, len, (i2) => {
            cxt.subschema({ keyword: "unevaluatedItems", dataProp: i2, dataPropType: util_1$1.Type.Num }, valid);
            if (!it2.allErrors)
              gen.if((0, codegen_1$1.not)(valid), () => gen.break());
          });
        }
      }
    };
    unevaluatedItems.default = def$1;
    Object.defineProperty(unevaluated$1, "__esModule", { value: true });
    const unevaluatedProperties_1 = unevaluatedProperties;
    const unevaluatedItems_1 = unevaluatedItems;
    const unevaluated = [unevaluatedProperties_1.default, unevaluatedItems_1.default];
    unevaluated$1.default = unevaluated;
    var discriminator = {};
    var types = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DiscrError = void 0;
      (function(DiscrError) {
        DiscrError["Tag"] = "tag";
        DiscrError["Mapping"] = "mapping";
      })(exports2.DiscrError || (exports2.DiscrError = {}));
    })(types);
    Object.defineProperty(discriminator, "__esModule", { value: true });
    const codegen_1 = codegen;
    const types_1 = types;
    const compile_1 = compile$2;
    const util_1 = util;
    const error$1 = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    const def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error: error$1,
      code(cxt) {
        const { gen, data, schema, parentSchema, it: it2 } = cxt;
        const { oneOf: oneOf2 } = parentSchema;
        if (!it2.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf2)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a2;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i2 = 0; i2 < oneOf2.length; i2++) {
            let sch = oneOf2[i2];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it2.self.RULES)) {
              sch = compile_1.resolveRef.call(it2.self, it2.schemaEnv.root, it2.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
            }
            const propSch = (_a2 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a2 === void 0 ? void 0 : _a2[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i2);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required: required2 }) {
            return Array.isArray(required2) && required2.includes(tagName);
          }
          function addMappings(sch, i2) {
            if (sch.const) {
              addMapping(sch.const, i2);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i2);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i2) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i2;
          }
        }
      }
    };
    discriminator.default = def;
    var jsonSchema201909 = {};
    const $schema$7 = "https://json-schema.org/draft/2019-09/schema";
    const $id$7 = "https://json-schema.org/draft/2019-09/schema";
    const $vocabulary$6 = {
      "https://json-schema.org/draft/2019-09/vocab/core": true,
      "https://json-schema.org/draft/2019-09/vocab/applicator": true,
      "https://json-schema.org/draft/2019-09/vocab/validation": true,
      "https://json-schema.org/draft/2019-09/vocab/meta-data": true,
      "https://json-schema.org/draft/2019-09/vocab/format": false,
      "https://json-schema.org/draft/2019-09/vocab/content": true
    };
    const $recursiveAnchor$6 = true;
    const title$7 = "Core and Validation specifications meta-schema";
    const allOf = [
      {
        $ref: "meta/core"
      },
      {
        $ref: "meta/applicator"
      },
      {
        $ref: "meta/validation"
      },
      {
        $ref: "meta/meta-data"
      },
      {
        $ref: "meta/format"
      },
      {
        $ref: "meta/content"
      }
    ];
    const type$7 = [
      "object",
      "boolean"
    ];
    const properties$7 = {
      definitions: {
        $comment: "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",
        type: "object",
        additionalProperties: {
          $recursiveRef: "#"
        },
        "default": {}
      },
      dependencies: {
        $comment: '"dependencies" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to "dependentSchemas" and "dependentRequired"',
        type: "object",
        additionalProperties: {
          anyOf: [
            {
              $recursiveRef: "#"
            },
            {
              $ref: "meta/validation#/$defs/stringArray"
            }
          ]
        }
      }
    };
    const require$$0$1 = {
      $schema: $schema$7,
      $id: $id$7,
      $vocabulary: $vocabulary$6,
      $recursiveAnchor: $recursiveAnchor$6,
      title: title$7,
      allOf,
      type: type$7,
      properties: properties$7
    };
    const $schema$6 = "https://json-schema.org/draft/2019-09/schema";
    const $id$6 = "https://json-schema.org/draft/2019-09/meta/applicator";
    const $vocabulary$5 = {
      "https://json-schema.org/draft/2019-09/vocab/applicator": true
    };
    const $recursiveAnchor$5 = true;
    const title$6 = "Applicator vocabulary meta-schema";
    const type$6 = [
      "object",
      "boolean"
    ];
    const properties$6 = {
      additionalItems: {
        $recursiveRef: "#"
      },
      unevaluatedItems: {
        $recursiveRef: "#"
      },
      items: {
        anyOf: [
          {
            $recursiveRef: "#"
          },
          {
            $ref: "#/$defs/schemaArray"
          }
        ]
      },
      contains: {
        $recursiveRef: "#"
      },
      additionalProperties: {
        $recursiveRef: "#"
      },
      unevaluatedProperties: {
        $recursiveRef: "#"
      },
      properties: {
        type: "object",
        additionalProperties: {
          $recursiveRef: "#"
        },
        "default": {}
      },
      patternProperties: {
        type: "object",
        additionalProperties: {
          $recursiveRef: "#"
        },
        propertyNames: {
          format: "regex"
        },
        "default": {}
      },
      dependentSchemas: {
        type: "object",
        additionalProperties: {
          $recursiveRef: "#"
        }
      },
      propertyNames: {
        $recursiveRef: "#"
      },
      "if": {
        $recursiveRef: "#"
      },
      then: {
        $recursiveRef: "#"
      },
      "else": {
        $recursiveRef: "#"
      },
      allOf: {
        $ref: "#/$defs/schemaArray"
      },
      anyOf: {
        $ref: "#/$defs/schemaArray"
      },
      oneOf: {
        $ref: "#/$defs/schemaArray"
      },
      not: {
        $recursiveRef: "#"
      }
    };
    const $defs$1 = {
      schemaArray: {
        type: "array",
        minItems: 1,
        items: {
          $recursiveRef: "#"
        }
      }
    };
    const require$$1 = {
      $schema: $schema$6,
      $id: $id$6,
      $vocabulary: $vocabulary$5,
      $recursiveAnchor: $recursiveAnchor$5,
      title: title$6,
      type: type$6,
      properties: properties$6,
      $defs: $defs$1
    };
    const $schema$5 = "https://json-schema.org/draft/2019-09/schema";
    const $id$5 = "https://json-schema.org/draft/2019-09/meta/content";
    const $vocabulary$4 = {
      "https://json-schema.org/draft/2019-09/vocab/content": true
    };
    const $recursiveAnchor$4 = true;
    const title$5 = "Content vocabulary meta-schema";
    const type$5 = [
      "object",
      "boolean"
    ];
    const properties$5 = {
      contentMediaType: {
        type: "string"
      },
      contentEncoding: {
        type: "string"
      },
      contentSchema: {
        $recursiveRef: "#"
      }
    };
    const require$$2 = {
      $schema: $schema$5,
      $id: $id$5,
      $vocabulary: $vocabulary$4,
      $recursiveAnchor: $recursiveAnchor$4,
      title: title$5,
      type: type$5,
      properties: properties$5
    };
    const $schema$4 = "https://json-schema.org/draft/2019-09/schema";
    const $id$4 = "https://json-schema.org/draft/2019-09/meta/core";
    const $vocabulary$3 = {
      "https://json-schema.org/draft/2019-09/vocab/core": true
    };
    const $recursiveAnchor$3 = true;
    const title$4 = "Core vocabulary meta-schema";
    const type$4 = [
      "object",
      "boolean"
    ];
    const properties$4 = {
      $id: {
        type: "string",
        format: "uri-reference",
        $comment: "Non-empty fragments not allowed.",
        pattern: "^[^#]*#?$"
      },
      $schema: {
        type: "string",
        format: "uri"
      },
      $anchor: {
        type: "string",
        pattern: "^[A-Za-z][-A-Za-z0-9.:_]*$"
      },
      $ref: {
        type: "string",
        format: "uri-reference"
      },
      $recursiveRef: {
        type: "string",
        format: "uri-reference"
      },
      $recursiveAnchor: {
        type: "boolean",
        "default": false
      },
      $vocabulary: {
        type: "object",
        propertyNames: {
          type: "string",
          format: "uri"
        },
        additionalProperties: {
          type: "boolean"
        }
      },
      $comment: {
        type: "string"
      },
      $defs: {
        type: "object",
        additionalProperties: {
          $recursiveRef: "#"
        },
        "default": {}
      }
    };
    const require$$3$1 = {
      $schema: $schema$4,
      $id: $id$4,
      $vocabulary: $vocabulary$3,
      $recursiveAnchor: $recursiveAnchor$3,
      title: title$4,
      type: type$4,
      properties: properties$4
    };
    const $schema$3 = "https://json-schema.org/draft/2019-09/schema";
    const $id$3 = "https://json-schema.org/draft/2019-09/meta/format";
    const $vocabulary$2 = {
      "https://json-schema.org/draft/2019-09/vocab/format": true
    };
    const $recursiveAnchor$2 = true;
    const title$3 = "Format vocabulary meta-schema";
    const type$3 = [
      "object",
      "boolean"
    ];
    const properties$3 = {
      format: {
        type: "string"
      }
    };
    const require$$4 = {
      $schema: $schema$3,
      $id: $id$3,
      $vocabulary: $vocabulary$2,
      $recursiveAnchor: $recursiveAnchor$2,
      title: title$3,
      type: type$3,
      properties: properties$3
    };
    const $schema$2 = "https://json-schema.org/draft/2019-09/schema";
    const $id$2 = "https://json-schema.org/draft/2019-09/meta/meta-data";
    const $vocabulary$1 = {
      "https://json-schema.org/draft/2019-09/vocab/meta-data": true
    };
    const $recursiveAnchor$1 = true;
    const title$2 = "Meta-data vocabulary meta-schema";
    const type$2 = [
      "object",
      "boolean"
    ];
    const properties$2 = {
      title: {
        type: "string"
      },
      description: {
        type: "string"
      },
      "default": true,
      deprecated: {
        type: "boolean",
        "default": false
      },
      readOnly: {
        type: "boolean",
        "default": false
      },
      writeOnly: {
        type: "boolean",
        "default": false
      },
      examples: {
        type: "array",
        items: true
      }
    };
    const require$$5 = {
      $schema: $schema$2,
      $id: $id$2,
      $vocabulary: $vocabulary$1,
      $recursiveAnchor: $recursiveAnchor$1,
      title: title$2,
      type: type$2,
      properties: properties$2
    };
    const $schema$1 = "https://json-schema.org/draft/2019-09/schema";
    const $id$1 = "https://json-schema.org/draft/2019-09/meta/validation";
    const $vocabulary = {
      "https://json-schema.org/draft/2019-09/vocab/validation": true
    };
    const $recursiveAnchor = true;
    const title$1 = "Validation vocabulary meta-schema";
    const type$1 = [
      "object",
      "boolean"
    ];
    const properties$1 = {
      multipleOf: {
        type: "number",
        exclusiveMinimum: 0
      },
      maximum: {
        type: "number"
      },
      exclusiveMaximum: {
        type: "number"
      },
      minimum: {
        type: "number"
      },
      exclusiveMinimum: {
        type: "number"
      },
      maxLength: {
        $ref: "#/$defs/nonNegativeInteger"
      },
      minLength: {
        $ref: "#/$defs/nonNegativeIntegerDefault0"
      },
      pattern: {
        type: "string",
        format: "regex"
      },
      maxItems: {
        $ref: "#/$defs/nonNegativeInteger"
      },
      minItems: {
        $ref: "#/$defs/nonNegativeIntegerDefault0"
      },
      uniqueItems: {
        type: "boolean",
        "default": false
      },
      maxContains: {
        $ref: "#/$defs/nonNegativeInteger"
      },
      minContains: {
        $ref: "#/$defs/nonNegativeInteger",
        "default": 1
      },
      maxProperties: {
        $ref: "#/$defs/nonNegativeInteger"
      },
      minProperties: {
        $ref: "#/$defs/nonNegativeIntegerDefault0"
      },
      required: {
        $ref: "#/$defs/stringArray"
      },
      dependentRequired: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/stringArray"
        }
      },
      "const": true,
      "enum": {
        type: "array",
        items: true
      },
      type: {
        anyOf: [
          {
            $ref: "#/$defs/simpleTypes"
          },
          {
            type: "array",
            items: {
              $ref: "#/$defs/simpleTypes"
            },
            minItems: 1,
            uniqueItems: true
          }
        ]
      }
    };
    const $defs = {
      nonNegativeInteger: {
        type: "integer",
        minimum: 0
      },
      nonNegativeIntegerDefault0: {
        $ref: "#/$defs/nonNegativeInteger",
        "default": 0
      },
      simpleTypes: {
        "enum": [
          "array",
          "boolean",
          "integer",
          "null",
          "number",
          "object",
          "string"
        ]
      },
      stringArray: {
        type: "array",
        items: {
          type: "string"
        },
        uniqueItems: true,
        "default": []
      }
    };
    const require$$6 = {
      $schema: $schema$1,
      $id: $id$1,
      $vocabulary,
      $recursiveAnchor,
      title: title$1,
      type: type$1,
      properties: properties$1,
      $defs
    };
    Object.defineProperty(jsonSchema201909, "__esModule", { value: true });
    const metaSchema = require$$0$1;
    const applicator = require$$1;
    const content = require$$2;
    const core = require$$3$1;
    const format$1 = require$$4;
    const metadata = require$$5;
    const validation = require$$6;
    const META_SUPPORT_DATA = ["/properties"];
    function addMetaSchema2019($data) {
      [
        metaSchema,
        applicator,
        content,
        core,
        with$data(this, format$1),
        metadata,
        with$data(this, validation)
      ].forEach((sch) => this.addMetaSchema(sch, void 0, false));
      return this;
      function with$data(ajv2, sch) {
        return $data ? ajv2.$dataMetaSchema(sch, META_SUPPORT_DATA) : sch;
      }
    }
    jsonSchema201909.default = addMetaSchema2019;
    (function(module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MissingRefError = exports2.ValidationError = exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
      const core_12 = core$3;
      const draft7_1 = draft7;
      const dynamic_1 = dynamic$1;
      const next_1 = next$1;
      const unevaluated_1 = unevaluated$1;
      const discriminator_1 = discriminator;
      const json_schema_2019_09_1 = jsonSchema201909;
      const META_SCHEMA_ID = "https://json-schema.org/draft/2019-09/schema";
      class Ajv2019 extends core_12.default {
        constructor(opts = {}) {
          super({
            ...opts,
            dynamicRef: true,
            next: true,
            unevaluated: true
          });
        }
        _addVocabularies() {
          super._addVocabularies();
          this.addVocabulary(dynamic_1.default);
          draft7_1.default.forEach((v) => this.addVocabulary(v));
          this.addVocabulary(next_1.default);
          this.addVocabulary(unevaluated_1.default);
          if (this.opts.discriminator)
            this.addKeyword(discriminator_1.default);
        }
        _addDefaultMetaSchema() {
          super._addDefaultMetaSchema();
          const { $data, meta } = this.opts;
          if (!meta)
            return;
          json_schema_2019_09_1.default.call(this, $data);
          this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
        }
        defaultMeta() {
          return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
        }
      }
      module2.exports = exports2 = Ajv2019;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = Ajv2019;
      var validate_12 = validate;
      Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
        return validate_12.KeywordCxt;
      } });
      var codegen_12 = codegen;
      Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
        return codegen_12._;
      } });
      Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
        return codegen_12.str;
      } });
      Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
        return codegen_12.stringify;
      } });
      Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
        return codegen_12.nil;
      } });
      Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
        return codegen_12.Name;
      } });
      Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
        return codegen_12.CodeGen;
      } });
      var validation_error_12 = validation_error;
      Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
        return validation_error_12.default;
      } });
      var ref_error_12 = ref_error;
      Object.defineProperty(exports2, "MissingRefError", { enumerable: true, get: function() {
        return ref_error_12.default;
      } });
    })(_2019, _2019.exports);
    var _2019Exports = _2019.exports;
    const ajvModule = /* @__PURE__ */ getDefaultExportFromCjs(_2019Exports);
    var dist$1 = { exports: {} };
    var formats = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.formatNames = exports2.fastFormats = exports2.fullFormats = void 0;
      function fmtDef(validate2, compare) {
        return { validate: validate2, compare };
      }
      exports2.fullFormats = {
        // date: http://tools.ietf.org/html/rfc3339#section-5.6
        date: fmtDef(date2, compareDate),
        // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
        time: fmtDef(time, compareTime),
        "date-time": fmtDef(date_time, compareDateTime),
        // duration: https://tools.ietf.org/html/rfc3339#appendix-A
        duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
        uri: uri2,
        "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
        // uri-template: https://tools.ietf.org/html/rfc6570
        "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
        // For the source: https://gist.github.com/dperini/729294
        // For test cases: https://mathiasbynens.be/demo/url-regex
        url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
        email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
        hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
        // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
        ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
        regex: regex2,
        // uuid: http://tools.ietf.org/html/rfc4122
        uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
        // JSON-pointer: https://tools.ietf.org/html/rfc6901
        // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
        "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
        "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
        // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
        "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
        // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
        // byte: https://github.com/miguelmota/is-base64
        byte,
        // signed 32 bit integer
        int32: { type: "number", validate: validateInt32 },
        // signed 64 bit integer
        int64: { type: "number", validate: validateInt64 },
        // C-type float
        float: { type: "number", validate: validateNumber },
        // C-type double
        double: { type: "number", validate: validateNumber },
        // hint to the UI to hide input strings
        password: true,
        // unchecked string payload
        binary: true
      };
      exports2.fastFormats = {
        ...exports2.fullFormats,
        date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
        time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
        "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
        // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
        uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
        "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
        // email (sources from jsen validator):
        // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
        // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
        email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
      };
      exports2.formatNames = Object.keys(exports2.fullFormats);
      function isLeapYear(year) {
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
      }
      const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
      const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function date2(str) {
        const matches = DATE.exec(str);
        if (!matches)
          return false;
        const year = +matches[1];
        const month = +matches[2];
        const day = +matches[3];
        return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
      }
      function compareDate(d1, d2) {
        if (!(d1 && d2))
          return void 0;
        if (d1 > d2)
          return 1;
        if (d1 < d2)
          return -1;
        return 0;
      }
      const TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
      function time(str, withTimeZone) {
        const matches = TIME.exec(str);
        if (!matches)
          return false;
        const hour = +matches[1];
        const minute = +matches[2];
        const second = +matches[3];
        const timeZone = matches[5];
        return (hour <= 23 && minute <= 59 && second <= 59 || hour === 23 && minute === 59 && second === 60) && (!withTimeZone || timeZone !== "");
      }
      function compareTime(t1, t2) {
        if (!(t1 && t2))
          return void 0;
        const a1 = TIME.exec(t1);
        const a2 = TIME.exec(t2);
        if (!(a1 && a2))
          return void 0;
        t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
        t2 = a2[1] + a2[2] + a2[3] + (a2[4] || "");
        if (t1 > t2)
          return 1;
        if (t1 < t2)
          return -1;
        return 0;
      }
      const DATE_TIME_SEPARATOR = /t|\s/i;
      function date_time(str) {
        const dateTime = str.split(DATE_TIME_SEPARATOR);
        return dateTime.length === 2 && date2(dateTime[0]) && time(dateTime[1], true);
      }
      function compareDateTime(dt1, dt2) {
        if (!(dt1 && dt2))
          return void 0;
        const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
        const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
        const res = compareDate(d1, d2);
        if (res === void 0)
          return void 0;
        return res || compareTime(t1, t2);
      }
      const NOT_URI_FRAGMENT = /\/|:/;
      const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
      function uri2(str) {
        return NOT_URI_FRAGMENT.test(str) && URI.test(str);
      }
      const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
      function byte(str) {
        BYTE.lastIndex = 0;
        return BYTE.test(str);
      }
      const MIN_INT32 = -(2 ** 31);
      const MAX_INT32 = 2 ** 31 - 1;
      function validateInt32(value) {
        return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
      }
      function validateInt64(value) {
        return Number.isInteger(value);
      }
      function validateNumber() {
        return true;
      }
      const Z_ANCHOR = /[^\\]\\Z/;
      function regex2(str) {
        if (Z_ANCHOR.test(str))
          return false;
        try {
          new RegExp(str);
          return true;
        } catch (e) {
          return false;
        }
      }
    })(formats);
    var limit = {};
    var ajv = { exports: {} };
    const $schema = "http://json-schema.org/draft-07/schema#";
    const $id = "http://json-schema.org/draft-07/schema#";
    const title = "Core schema meta-schema";
    const definitions = {
      schemaArray: {
        type: "array",
        minItems: 1,
        items: {
          $ref: "#"
        }
      },
      nonNegativeInteger: {
        type: "integer",
        minimum: 0
      },
      nonNegativeIntegerDefault0: {
        allOf: [
          {
            $ref: "#/definitions/nonNegativeInteger"
          },
          {
            "default": 0
          }
        ]
      },
      simpleTypes: {
        "enum": [
          "array",
          "boolean",
          "integer",
          "null",
          "number",
          "object",
          "string"
        ]
      },
      stringArray: {
        type: "array",
        items: {
          type: "string"
        },
        uniqueItems: true,
        "default": []
      }
    };
    const type = [
      "object",
      "boolean"
    ];
    const properties = {
      $id: {
        type: "string",
        format: "uri-reference"
      },
      $schema: {
        type: "string",
        format: "uri"
      },
      $ref: {
        type: "string",
        format: "uri-reference"
      },
      $comment: {
        type: "string"
      },
      title: {
        type: "string"
      },
      description: {
        type: "string"
      },
      "default": true,
      readOnly: {
        type: "boolean",
        "default": false
      },
      examples: {
        type: "array",
        items: true
      },
      multipleOf: {
        type: "number",
        exclusiveMinimum: 0
      },
      maximum: {
        type: "number"
      },
      exclusiveMaximum: {
        type: "number"
      },
      minimum: {
        type: "number"
      },
      exclusiveMinimum: {
        type: "number"
      },
      maxLength: {
        $ref: "#/definitions/nonNegativeInteger"
      },
      minLength: {
        $ref: "#/definitions/nonNegativeIntegerDefault0"
      },
      pattern: {
        type: "string",
        format: "regex"
      },
      additionalItems: {
        $ref: "#"
      },
      items: {
        anyOf: [
          {
            $ref: "#"
          },
          {
            $ref: "#/definitions/schemaArray"
          }
        ],
        "default": true
      },
      maxItems: {
        $ref: "#/definitions/nonNegativeInteger"
      },
      minItems: {
        $ref: "#/definitions/nonNegativeIntegerDefault0"
      },
      uniqueItems: {
        type: "boolean",
        "default": false
      },
      contains: {
        $ref: "#"
      },
      maxProperties: {
        $ref: "#/definitions/nonNegativeInteger"
      },
      minProperties: {
        $ref: "#/definitions/nonNegativeIntegerDefault0"
      },
      required: {
        $ref: "#/definitions/stringArray"
      },
      additionalProperties: {
        $ref: "#"
      },
      definitions: {
        type: "object",
        additionalProperties: {
          $ref: "#"
        },
        "default": {}
      },
      properties: {
        type: "object",
        additionalProperties: {
          $ref: "#"
        },
        "default": {}
      },
      patternProperties: {
        type: "object",
        additionalProperties: {
          $ref: "#"
        },
        propertyNames: {
          format: "regex"
        },
        "default": {}
      },
      dependencies: {
        type: "object",
        additionalProperties: {
          anyOf: [
            {
              $ref: "#"
            },
            {
              $ref: "#/definitions/stringArray"
            }
          ]
        }
      },
      propertyNames: {
        $ref: "#"
      },
      "const": true,
      "enum": {
        type: "array",
        items: true,
        minItems: 1,
        uniqueItems: true
      },
      type: {
        anyOf: [
          {
            $ref: "#/definitions/simpleTypes"
          },
          {
            type: "array",
            items: {
              $ref: "#/definitions/simpleTypes"
            },
            minItems: 1,
            uniqueItems: true
          }
        ]
      },
      format: {
        type: "string"
      },
      contentMediaType: {
        type: "string"
      },
      contentEncoding: {
        type: "string"
      },
      "if": {
        $ref: "#"
      },
      then: {
        $ref: "#"
      },
      "else": {
        $ref: "#"
      },
      allOf: {
        $ref: "#/definitions/schemaArray"
      },
      anyOf: {
        $ref: "#/definitions/schemaArray"
      },
      oneOf: {
        $ref: "#/definitions/schemaArray"
      },
      not: {
        $ref: "#"
      }
    };
    const require$$3 = {
      $schema,
      $id,
      title,
      definitions,
      type,
      properties,
      "default": true
    };
    (function(module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MissingRefError = exports2.ValidationError = exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
      const core_12 = core$3;
      const draft7_1 = draft7;
      const discriminator_1 = discriminator;
      const draft7MetaSchema = require$$3;
      const META_SUPPORT_DATA2 = ["/properties"];
      const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
      class Ajv2 extends core_12.default {
        _addVocabularies() {
          super._addVocabularies();
          draft7_1.default.forEach((v) => this.addVocabulary(v));
          if (this.opts.discriminator)
            this.addKeyword(discriminator_1.default);
        }
        _addDefaultMetaSchema() {
          super._addDefaultMetaSchema();
          if (!this.opts.meta)
            return;
          const metaSchema2 = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA2) : draft7MetaSchema;
          this.addMetaSchema(metaSchema2, META_SCHEMA_ID, false);
          this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
        }
        defaultMeta() {
          return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
        }
      }
      module2.exports = exports2 = Ajv2;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = Ajv2;
      var validate_12 = validate;
      Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
        return validate_12.KeywordCxt;
      } });
      var codegen_12 = codegen;
      Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
        return codegen_12._;
      } });
      Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
        return codegen_12.str;
      } });
      Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
        return codegen_12.stringify;
      } });
      Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
        return codegen_12.nil;
      } });
      Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
        return codegen_12.Name;
      } });
      Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
        return codegen_12.CodeGen;
      } });
      var validation_error_12 = validation_error;
      Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
        return validation_error_12.default;
      } });
      var ref_error_12 = ref_error;
      Object.defineProperty(exports2, "MissingRefError", { enumerable: true, get: function() {
        return ref_error_12.default;
      } });
    })(ajv, ajv.exports);
    var ajvExports = ajv.exports;
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.formatLimitDefinition = void 0;
      const ajv_1 = ajvExports;
      const codegen_12 = codegen;
      const ops2 = codegen_12.operators;
      const KWDs2 = {
        formatMaximum: { okStr: "<=", ok: ops2.LTE, fail: ops2.GT },
        formatMinimum: { okStr: ">=", ok: ops2.GTE, fail: ops2.LT },
        formatExclusiveMaximum: { okStr: "<", ok: ops2.LT, fail: ops2.GTE },
        formatExclusiveMinimum: { okStr: ">", ok: ops2.GT, fail: ops2.LTE }
      };
      const error2 = {
        message: ({ keyword: keyword2, schemaCode }) => codegen_12.str`should be ${KWDs2[keyword2].okStr} ${schemaCode}`,
        params: ({ keyword: keyword2, schemaCode }) => codegen_12._`{comparison: ${KWDs2[keyword2].okStr}, limit: ${schemaCode}}`
      };
      exports2.formatLimitDefinition = {
        keyword: Object.keys(KWDs2),
        type: "string",
        schemaType: "string",
        $data: true,
        error: error2,
        code(cxt) {
          const { gen, data, schemaCode, keyword: keyword2, it: it2 } = cxt;
          const { opts, self: self2 } = it2;
          if (!opts.validateFormats)
            return;
          const fCxt = new ajv_1.KeywordCxt(it2, self2.RULES.all.format.definition, "format");
          if (fCxt.$data)
            validate$DataFormat();
          else
            validateFormat();
          function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
              ref: self2.formats,
              code: opts.code.formats
            });
            const fmt = gen.const("fmt", codegen_12._`${fmts}[${fCxt.schemaCode}]`);
            cxt.fail$data(codegen_12.or(codegen_12._`typeof ${fmt} != "object"`, codegen_12._`${fmt} instanceof RegExp`, codegen_12._`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
          }
          function validateFormat() {
            const format2 = fCxt.schema;
            const fmtDef = self2.formats[format2];
            if (!fmtDef || fmtDef === true)
              return;
            if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
              throw new Error(`"${keyword2}": format "${format2}" does not define "compare" function`);
            }
            const fmt = gen.scopeValue("formats", {
              key: format2,
              ref: fmtDef,
              code: opts.code.formats ? codegen_12._`${opts.code.formats}${codegen_12.getProperty(format2)}` : void 0
            });
            cxt.fail$data(compareCode(fmt));
          }
          function compareCode(fmt) {
            return codegen_12._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs2[keyword2].fail} 0`;
          }
        },
        dependencies: ["format"]
      };
      const formatLimitPlugin = (ajv2) => {
        ajv2.addKeyword(exports2.formatLimitDefinition);
        return ajv2;
      };
      exports2.default = formatLimitPlugin;
    })(limit);
    (function(module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      const formats_1 = formats;
      const limit_1 = limit;
      const codegen_12 = codegen;
      const fullName = new codegen_12.Name("fullFormats");
      const fastName = new codegen_12.Name("fastFormats");
      const formatsPlugin = (ajv2, opts = { keywords: true }) => {
        if (Array.isArray(opts)) {
          addFormats2(ajv2, opts, formats_1.fullFormats, fullName);
          return ajv2;
        }
        const [formats2, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
        const list2 = opts.formats || formats_1.formatNames;
        addFormats2(ajv2, list2, formats2, exportName);
        if (opts.keywords)
          limit_1.default(ajv2);
        return ajv2;
      };
      formatsPlugin.get = (name, mode = "full") => {
        const formats2 = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
        const f = formats2[name];
        if (!f)
          throw new Error(`Unknown format "${name}"`);
        return f;
      };
      function addFormats2(ajv2, list2, fs, exportName) {
        var _a2;
        var _b;
        (_a2 = (_b = ajv2.opts.code).formats) !== null && _a2 !== void 0 ? _a2 : _b.formats = codegen_12._`require("ajv-formats/dist/formats").${exportName}`;
        for (const f of list2)
          ajv2.addFormat(f, fs[f]);
      }
      module2.exports = exports2 = formatsPlugin;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = formatsPlugin;
    })(dist$1, dist$1.exports);
    var distExports$1 = dist$1.exports;
    const addFormats = /* @__PURE__ */ getDefaultExportFromCjs(distExports$1);
    var dist = { exports: {} };
    (function(module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      const ajv_1 = ajvExports;
      const codegen_12 = codegen;
      const code_12 = code$2;
      const validate_12 = validate;
      const errors_12 = errors$1;
      const names_12 = names$2;
      const keyword2 = "errorMessage";
      const used = new ajv_1.Name("emUsed");
      const KEYWORD_PROPERTY_PARAMS = {
        required: "missingProperty",
        dependencies: "property",
        dependentRequired: "property"
      };
      const INTERPOLATION = /\$\{[^}]+\}/;
      const INTERPOLATION_REPLACE = /\$\{([^}]+)\}/g;
      const EMPTY_STR = /^""\s*\+\s*|\s*\+\s*""$/g;
      function errorMessage(options) {
        return {
          keyword: keyword2,
          schemaType: ["string", "object"],
          post: true,
          code(cxt) {
            const { gen, data, schema, schemaValue, it: it2 } = cxt;
            if (it2.createErrors === false)
              return;
            const sch = schema;
            const instancePath = codegen_12.strConcat(names_12.default.instancePath, it2.errorPath);
            gen.if(ajv_1._`${names_12.default.errors} > 0`, () => {
              if (typeof sch == "object") {
                const [kwdPropErrors, kwdErrors] = keywordErrorsConfig(sch);
                if (kwdErrors)
                  processKeywordErrors(kwdErrors);
                if (kwdPropErrors)
                  processKeywordPropErrors(kwdPropErrors);
                processChildErrors(childErrorsConfig(sch));
              }
              const schMessage = typeof sch == "string" ? sch : sch._;
              if (schMessage)
                processAllErrors(schMessage);
              if (!options.keepErrors)
                removeUsedErrors();
            });
            function childErrorsConfig({ properties: properties2, items: items2 }) {
              const errors2 = {};
              if (properties2) {
                errors2.props = {};
                for (const p2 in properties2)
                  errors2.props[p2] = [];
              }
              if (items2) {
                errors2.items = {};
                for (let i2 = 0; i2 < items2.length; i2++)
                  errors2.items[i2] = [];
              }
              return errors2;
            }
            function keywordErrorsConfig(emSchema) {
              let propErrors;
              let errors2;
              for (const k in emSchema) {
                if (k === "properties" || k === "items")
                  continue;
                const kwdSch = emSchema[k];
                if (typeof kwdSch == "object") {
                  propErrors || (propErrors = {});
                  const errMap = propErrors[k] = {};
                  for (const p2 in kwdSch)
                    errMap[p2] = [];
                } else {
                  errors2 || (errors2 = {});
                  errors2[k] = [];
                }
              }
              return [propErrors, errors2];
            }
            function processKeywordErrors(kwdErrors) {
              const kwdErrs = gen.const("emErrors", ajv_1.stringify(kwdErrors));
              const templates = gen.const("templates", getTemplatesCode(kwdErrors, schema));
              gen.forOf("err", names_12.default.vErrors, (err) => gen.if(matchKeywordError(err, kwdErrs), () => gen.code(ajv_1._`${kwdErrs}[${err}.keyword].push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
              const { singleError } = options;
              if (singleError) {
                const message = gen.let("message", ajv_1._`""`);
                const paramsErrors = gen.let("paramsErrors", ajv_1._`[]`);
                loopErrors((key) => {
                  gen.if(message, () => gen.code(ajv_1._`${message} += ${typeof singleError == "string" ? singleError : ";"}`));
                  gen.code(ajv_1._`${message} += ${errMessage(key)}`);
                  gen.assign(paramsErrors, ajv_1._`${paramsErrors}.concat(${kwdErrs}[${key}])`);
                });
                errors_12.reportError(cxt, { message, params: ajv_1._`{errors: ${paramsErrors}}` });
              } else {
                loopErrors((key) => errors_12.reportError(cxt, {
                  message: errMessage(key),
                  params: ajv_1._`{errors: ${kwdErrs}[${key}]}`
                }));
              }
              function loopErrors(body) {
                gen.forIn("key", kwdErrs, (key) => gen.if(ajv_1._`${kwdErrs}[${key}].length`, () => body(key)));
              }
              function errMessage(key) {
                return ajv_1._`${key} in ${templates} ? ${templates}[${key}]() : ${schemaValue}[${key}]`;
              }
            }
            function processKeywordPropErrors(kwdPropErrors) {
              const kwdErrs = gen.const("emErrors", ajv_1.stringify(kwdPropErrors));
              const templatesCode = [];
              for (const k in kwdPropErrors) {
                templatesCode.push([
                  k,
                  getTemplatesCode(kwdPropErrors[k], schema[k])
                ]);
              }
              const templates = gen.const("templates", gen.object(...templatesCode));
              const kwdPropParams = gen.scopeValue("obj", {
                ref: KEYWORD_PROPERTY_PARAMS,
                code: ajv_1.stringify(KEYWORD_PROPERTY_PARAMS)
              });
              const propParam = gen.let("emPropParams");
              const paramsErrors = gen.let("emParamsErrors");
              gen.forOf("err", names_12.default.vErrors, (err) => gen.if(matchKeywordError(err, kwdErrs), () => {
                gen.assign(propParam, ajv_1._`${kwdPropParams}[${err}.keyword]`);
                gen.assign(paramsErrors, ajv_1._`${kwdErrs}[${err}.keyword][${err}.params[${propParam}]]`);
                gen.if(paramsErrors, () => gen.code(ajv_1._`${paramsErrors}.push(${err})`).assign(ajv_1._`${err}.${used}`, true));
              }));
              gen.forIn("key", kwdErrs, (key) => gen.forIn("keyProp", ajv_1._`${kwdErrs}[${key}]`, (keyProp) => {
                gen.assign(paramsErrors, ajv_1._`${kwdErrs}[${key}][${keyProp}]`);
                gen.if(ajv_1._`${paramsErrors}.length`, () => {
                  const tmpl = gen.const("tmpl", ajv_1._`${templates}[${key}] && ${templates}[${key}][${keyProp}]`);
                  errors_12.reportError(cxt, {
                    message: ajv_1._`${tmpl} ? ${tmpl}() : ${schemaValue}[${key}][${keyProp}]`,
                    params: ajv_1._`{errors: ${paramsErrors}}`
                  });
                });
              }));
            }
            function processChildErrors(childErrors) {
              const { props, items: items2 } = childErrors;
              if (!props && !items2)
                return;
              const isObj = ajv_1._`typeof ${data} == "object"`;
              const isArr = ajv_1._`Array.isArray(${data})`;
              const childErrs = gen.let("emErrors");
              let childKwd;
              let childProp;
              const templates = gen.let("templates");
              if (props && items2) {
                childKwd = gen.let("emChildKwd");
                gen.if(isObj);
                gen.if(isArr, () => {
                  init(items2, schema.items);
                  gen.assign(childKwd, ajv_1.str`items`);
                }, () => {
                  init(props, schema.properties);
                  gen.assign(childKwd, ajv_1.str`properties`);
                });
                childProp = ajv_1._`[${childKwd}]`;
              } else if (items2) {
                gen.if(isArr);
                init(items2, schema.items);
                childProp = ajv_1._`.items`;
              } else if (props) {
                gen.if(codegen_12.and(isObj, codegen_12.not(isArr)));
                init(props, schema.properties);
                childProp = ajv_1._`.properties`;
              }
              gen.forOf("err", names_12.default.vErrors, (err) => ifMatchesChildError(err, childErrs, (child) => gen.code(ajv_1._`${childErrs}[${child}].push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
              gen.forIn("key", childErrs, (key) => gen.if(ajv_1._`${childErrs}[${key}].length`, () => {
                errors_12.reportError(cxt, {
                  message: ajv_1._`${key} in ${templates} ? ${templates}[${key}]() : ${schemaValue}${childProp}[${key}]`,
                  params: ajv_1._`{errors: ${childErrs}[${key}]}`
                });
                gen.assign(ajv_1._`${names_12.default.vErrors}[${names_12.default.errors}-1].instancePath`, ajv_1._`${instancePath} + "/" + ${key}.replace(/~/g, "~0").replace(/\\//g, "~1")`);
              }));
              gen.endIf();
              function init(children, msgs) {
                gen.assign(childErrs, ajv_1.stringify(children));
                gen.assign(templates, getTemplatesCode(children, msgs));
              }
            }
            function processAllErrors(schMessage) {
              const errs = gen.const("emErrs", ajv_1._`[]`);
              gen.forOf("err", names_12.default.vErrors, (err) => gen.if(matchAnyError(err), () => gen.code(ajv_1._`${errs}.push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
              gen.if(ajv_1._`${errs}.length`, () => errors_12.reportError(cxt, {
                message: templateExpr(schMessage),
                params: ajv_1._`{errors: ${errs}}`
              }));
            }
            function removeUsedErrors() {
              const errs = gen.const("emErrs", ajv_1._`[]`);
              gen.forOf("err", names_12.default.vErrors, (err) => gen.if(ajv_1._`!${err}.${used}`, () => gen.code(ajv_1._`${errs}.push(${err})`)));
              gen.assign(names_12.default.vErrors, errs).assign(names_12.default.errors, ajv_1._`${errs}.length`);
            }
            function matchKeywordError(err, kwdErrs) {
              return codegen_12.and(
                ajv_1._`${err}.keyword !== ${keyword2}`,
                ajv_1._`!${err}.${used}`,
                ajv_1._`${err}.instancePath === ${instancePath}`,
                ajv_1._`${err}.keyword in ${kwdErrs}`,
                // TODO match the end of the string?
                ajv_1._`${err}.schemaPath.indexOf(${it2.errSchemaPath}) === 0`,
                ajv_1._`/^\\/[^\\/]*$/.test(${err}.schemaPath.slice(${it2.errSchemaPath.length}))`
              );
            }
            function ifMatchesChildError(err, childErrs, thenBody) {
              gen.if(codegen_12.and(ajv_1._`${err}.keyword !== ${keyword2}`, ajv_1._`!${err}.${used}`, ajv_1._`${err}.instancePath.indexOf(${instancePath}) === 0`), () => {
                const childRegex = gen.scopeValue("pattern", {
                  ref: /^\/([^/]*)(?:\/|$)/,
                  code: ajv_1._`new RegExp("^\\\/([^/]*)(?:\\\/|$)")`
                });
                const matches = gen.const("emMatches", ajv_1._`${childRegex}.exec(${err}.instancePath.slice(${instancePath}.length))`);
                const child = gen.const("emChild", ajv_1._`${matches} && ${matches}[1].replace(/~1/g, "/").replace(/~0/g, "~")`);
                gen.if(ajv_1._`${child} !== undefined && ${child} in ${childErrs}`, () => thenBody(child));
              });
            }
            function matchAnyError(err) {
              return codegen_12.and(ajv_1._`${err}.keyword !== ${keyword2}`, ajv_1._`!${err}.${used}`, codegen_12.or(ajv_1._`${err}.instancePath === ${instancePath}`, codegen_12.and(ajv_1._`${err}.instancePath.indexOf(${instancePath}) === 0`, ajv_1._`${err}.instancePath[${instancePath}.length] === "/"`)), ajv_1._`${err}.schemaPath.indexOf(${it2.errSchemaPath}) === 0`, ajv_1._`${err}.schemaPath[${it2.errSchemaPath}.length] === "/"`);
            }
            function getTemplatesCode(keys2, msgs) {
              const templatesCode = [];
              for (const k in keys2) {
                const msg = msgs[k];
                if (INTERPOLATION.test(msg))
                  templatesCode.push([k, templateFunc(msg)]);
              }
              return gen.object(...templatesCode);
            }
            function templateExpr(msg) {
              if (!INTERPOLATION.test(msg))
                return ajv_1.stringify(msg);
              return new code_12._Code(code_12.safeStringify(msg).replace(INTERPOLATION_REPLACE, (_s, ptr) => `" + JSON.stringify(${validate_12.getData(ptr, it2)}) + "`).replace(EMPTY_STR, ""));
            }
            function templateFunc(msg) {
              return ajv_1._`function(){return ${templateExpr(msg)}}`;
            }
          },
          metaSchema: {
            anyOf: [
              { type: "string" },
              {
                type: "object",
                properties: {
                  properties: { $ref: "#/$defs/stringMap" },
                  items: { $ref: "#/$defs/stringList" },
                  required: { $ref: "#/$defs/stringOrMap" },
                  dependencies: { $ref: "#/$defs/stringOrMap" }
                },
                additionalProperties: { type: "string" }
              }
            ],
            $defs: {
              stringMap: {
                type: "object",
                additionalProperties: { type: "string" }
              },
              stringOrMap: {
                anyOf: [{ type: "string" }, { $ref: "#/$defs/stringMap" }]
              },
              stringList: { type: "array", items: { type: "string" } }
            }
          }
        };
      }
      const ajvErrors2 = (ajv2, options = {}) => {
        if (!ajv2.opts.allErrors)
          throw new Error("ajv-errors: Ajv option allErrors must be true");
        if (ajv2.opts.jsPropertySyntax) {
          throw new Error("ajv-errors: ajv option jsPropertySyntax is not supported");
        }
        return ajv2.addKeyword(errorMessage(options));
      };
      exports2.default = ajvErrors2;
      module2.exports = ajvErrors2;
      module2.exports.default = ajvErrors2;
    })(dist, dist.exports);
    var distExports = dist.exports;
    const ajvErrors = /* @__PURE__ */ getDefaultExportFromCjs(distExports);
    var en$1 = function localize_en(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "additionalProperties":
            out = "must NOT have additional properties";
            break;
          case "anyOf":
            out = 'must match a schema in "anyOf"';
            break;
          case "const":
            out = "must be equal to constant";
            break;
          case "contains":
            out = "must contain a valid item";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "must have propert";
            if (n == 1) {
              out += "y";
            } else {
              out += "ies";
            }
            out += " " + e.params.deps + " when property " + e.params.property + " is present";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = 'must pass "' + e.keyword + '" keyword validation';
            }
            break;
          case "enum":
            out = "must be equal to one of the allowed values";
            break;
          case "false schema":
            out = "boolean schema is false";
            break;
          case "format":
            out = 'must match format "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "must be " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "must be " + cond;
            break;
          case "if":
            out = 'must match "' + e.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "must be " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "must NOT be longer than " + n + " character";
            if (n != 1) {
              out += "s";
            }
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "must NOT have more than " + n + " propert";
            if (n == 1) {
              out += "y";
            } else {
              out += "ies";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "must be " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "must NOT have less than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "must NOT be shorter than " + n + " character";
            if (n != 1) {
              out += "s";
            }
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "must NOT have less than " + n + " propert";
            if (n == 1) {
              out += "y";
            } else {
              out += "ies";
            }
            break;
          case "multipleOf":
            out = "must be a multiple of " + e.params.multipleOf;
            break;
          case "not":
            out = 'must NOT be valid according to schema in "not"';
            break;
          case "oneOf":
            out = 'must match exactly one schema in "oneOf"';
            break;
          case "pattern":
            out = 'must match pattern "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'must have property matching pattern "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "property name is invalid";
            break;
          case "required":
            out = "must have required property " + e.params.missingProperty;
            break;
          case "type":
            out = "must be " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "must NOT have duplicate items (items ## " + e.params.j + " and " + e.params.i + " are identical)";
            break;
          default:
            out = 'must pass "' + e.keyword + '" keyword validation';
        }
        e.message = out;
      }
    };
    var ar = function localize_ar(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "       " + n + " ";
            break;
          case "additionalProperties":
            out = "     ";
            break;
          case "anyOf":
            out = '       "anyOf"';
            break;
          case "const":
            out = "   ";
            break;
          case "contains":
            out = "    ";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "     " + e.params.deps + "    " + e.params.property + " ";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = '      "' + e.keyword + '"';
            }
            break;
          case "enum":
            out = "          ";
            break;
          case "false schema":
            out = "   ";
            break;
          case "format":
            out = '    "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "    " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "    " + cond;
            break;
          case "if":
            out = '    "' + e.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "    " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "       " + n + " ";
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "       " + n + " ";
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "       " + n + " ";
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "    " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "       " + n + " ";
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "       " + n + " ";
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "       " + n + " ";
            break;
          case "multipleOf":
            out = "      " + e.params.multipleOf;
            break;
          case "not":
            out = '       "not"';
            break;
          case "oneOf":
            out = '        "oneOf"';
            break;
          case "pattern":
            out = '    "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = '      "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "   ";
            break;
          case "required":
            out = "  ";
            break;
          case "type":
            out = "    ";
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "      ( ## " + e.params.j + "  " + e.params.i + " )";
            break;
          default:
            out = '      "' + e.keyword + '"';
        }
        e.message = out;
      }
    };
    var ca = function localize_ca(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "no ha de tenir ms de " + n + " element";
            if (n != 1) {
              out += "s";
            }
            break;
          case "additionalProperties":
            out = "no ha de tenir propietats addicionals";
            break;
          case "anyOf":
            out = 'ha de coincidir amb algun esquema definit a "anyOf"';
            break;
          case "const":
            out = "ha de ser igual a la constant";
            break;
          case "contains":
            out = "ha de contenir un tem vlid";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "ha de contenir la propietat";
            if (n != 1) {
              out += "s";
            }
            out += " " + e.params.deps + " quan la propietat " + e.params.property + " s present";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = 'ha de passar la validaci de la clau "' + e.keyword + '"';
            }
            break;
          case "enum":
            out = "ha de ser igual a un dels valors predefinits";
            break;
          case "false schema":
            out = "lesquema s fals";
            break;
          case "format":
            out = 'ha de coincidir amb el format "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "ha de ser " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "ha de ser " + cond;
            break;
          case "if":
            out = 'ha de correspondres amb lesquema "' + e.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "ha de ser " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "no ha de tenir ms de " + n + " tem";
            if (n != 1) {
              out += "s";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "no pot contenir ms de " + n + " carcter";
            if (n != 1) {
              out += "s";
            }
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "no pot contenir ms de " + n + " propietat";
            if (n != 1) {
              out += "s";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "ha de ser " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "no ha de tenir menys de " + n + " tem";
            if (n != 1) {
              out += "s";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "no pot contenir menys de " + n + " carcter";
            if (n != 1) {
              out += "s";
            }
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "no pot contenir menys de " + n + " propietat";
            if (n != 1) {
              out += "s";
            }
            break;
          case "multipleOf":
            out = "ha de ser mltiple de " + e.params.multipleOf;
            break;
          case "not":
            out = 'no ha de ser vlid dacord amb lesquema definit a "not"';
            break;
          case "oneOf":
            out = 'ha de coincidir noms amb un esquema definit a "oneOf"';
            break;
          case "pattern":
            out = 'ha de coincidir amb el patr "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'la propietat ha de coincidir amb el patr "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "la propietat no s vlida";
            break;
          case "required":
            out = "ha de tenir la propietat requerida " + e.params.missingProperty;
            break;
          case "type":
            out = "ha de ser del tipus " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "no ha de tenir tems duplicats (els tems ## " + e.params.j + " i " + e.params.i + " sn idntics)";
            break;
          default:
            out = 'ha de passar la validaci de la clau "' + e.keyword + '"';
        }
        e.message = out;
      }
    };
    var cs = function localize_cs(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "neme mt vc, ne " + n + " prv";
            if (n >= 2 && n <= 4) {
              out += "ky";
            } else if (n != 1) {
              out += "ek";
            } else {
              out += "k";
            }
            break;
          case "additionalProperties":
            out = "neme mt dal poloky";
            break;
          case "anyOf":
            out = 'mus vyhovt alespo jednomu schmatu v "anyOf"';
            break;
          case "const":
            out = "mus bt roven konstant";
            break;
          case "contains":
            out = "mus obsahovat prvek odpovdajc schmatu";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "mus mt polo";
            if (n >= 2 && n <= 4) {
              out += "ky";
            } else if (n != 1) {
              out += "ek";
            } else {
              out += "ka";
            }
            out += ": " + e.params.deps + ", pokud obsahuje " + e.params.property;
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = 'mus vyhovt "' + e.keyword + '" validaci';
            }
            break;
          case "enum":
            out = "mus bt rovno jedn hodnot z vtu";
            break;
          case "false schema":
            out = "schma je false";
            break;
          case "format":
            out = 'mus bt ve formtu "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "mus bt " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "mus bt " + cond;
            break;
          case "if":
            out = 'mus vyhovt "' + e.params.failingKeyword + '" schmatu';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "mus bt " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "nesm obsahovat vc ne " + n + " prv";
            if (n >= 2 && n <= 4) {
              out += "ky";
            } else if (n != 1) {
              out += "ek";
            } else {
              out += "k";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "nesm bt del ne " + n + " zna";
            if (n >= 2 && n <= 4) {
              out += "ky";
            } else if (n != 1) {
              out += "k";
            } else {
              out += "k";
            }
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "nesm mt vc ne " + n + " polo";
            if (n >= 2 && n <= 4) {
              out += "ky";
            } else if (n != 1) {
              out += "ek";
            } else {
              out += "ka";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "mus bt " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "nesm obsahovat mn ne " + n + " prv";
            if (n >= 2 && n <= 4) {
              out += "ky";
            } else if (n != 1) {
              out += "ek";
            } else {
              out += "k";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "nesm bt krat ne " + n + " zna";
            if (n >= 2 && n <= 4) {
              out += "ky";
            } else if (n != 1) {
              out += "k";
            } else {
              out += "k";
            }
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "nesm mt mn ne " + n + " polo";
            if (n >= 2 && n <= 4) {
              out += "ky";
            } else if (n != 1) {
              out += "ek";
            } else {
              out += "ka";
            }
            break;
          case "multipleOf":
            out = "mus bt nsobkem " + e.params.multipleOf;
            break;
          case "not":
            out = 'nesm vyhovt schmatu v "not"';
            break;
          case "oneOf":
            out = 'mus vyhovt prv jednomu schmatu v "oneOf"';
            break;
          case "pattern":
            out = 'mus vyhovt regulrnmu vrazu "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'mus obsahovat poloku vyhovujc regulrnmu vrazu "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "nzev poloky nen platn";
            break;
          case "required":
            out = "mus obsahovat poadovanou poloku " + e.params.missingProperty;
            break;
          case "type":
            out = "mus bt " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "nesm obsahovat duplicitn prvky (prvky ## " + e.params.j + " a " + e.params.i + " jsou identick)";
            break;
          default:
            out = 'mus vyhovt "' + e.keyword + '" validaci';
        }
        e.message = out;
      }
    };
    var de = function localize_de(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "darf nicht mehr als " + n + " Element";
            if (n != 1) {
              out += "e";
            }
            out += " enthalten";
            break;
          case "additionalProperties":
            out = "darf keine zustzlichen Attribute haben";
            break;
          case "anyOf":
            out = 'muss einem der Schemata in "anyOf" entsprechen';
            break;
          case "const":
            out = "muss gleich der Konstanten sein";
            break;
          case "contains":
            out = "muss ein valides Element enthalten";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "muss Attribut";
            if (n != 1) {
              out += "e";
            }
            out += " " + e.params.deps + " aufweisen, wenn Attribut " + e.params.property + " gesetzt ist";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'der Tag "' + e.params.tag + '" muss eine Zeichenkette sein';
                break;
              case "mapping":
                out = 'der Wert vom Tag "' + e.params.tag + '" muss im oneOf enthalten sein';
                break;
              default:
                out = 'muss die Validierung "' + e.keyword + '" bestehen';
            }
            break;
          case "enum":
            out = "muss einem der vorgegebenen Werte entsprechen";
            break;
          case "false schema":
            out = "boolesches Schema ist falsch";
            break;
          case "format":
            out = 'muss diesem Format entsprechen: "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "muss " + cond + " sein";
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "muss " + cond + " sein";
            break;
          case "if":
            out = 'muss dem Schema "' + e.params.failingKeyword + '" entsprechen';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "muss " + cond + " sein";
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "darf nicht mehr als " + n + " Element";
            if (n != 1) {
              out += "e";
            }
            out += " haben";
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "darf nicht lnger als " + n + " Zeichen sein";
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "darf nicht mehr als " + n + " Attribut";
            if (n != 1) {
              out += "e";
            }
            out += " haben";
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "muss " + cond + " sein";
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "darf nicht weniger als " + n + " Element";
            if (n != 1) {
              out += "e";
            }
            out += " haben";
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "darf nicht krzer als " + n + " Zeichen sein";
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "darf nicht weniger als " + n + " Attribut";
            if (n != 1) {
              out += "e";
            }
            out += " haben";
            break;
          case "multipleOf":
            out = "muss ein Vielfaches von " + e.params.multipleOf + " sein";
            break;
          case "not":
            out = 'muss dem in "not" angegebenen Schema widersprechen';
            break;
          case "oneOf":
            out = 'muss genau einem der Schemata in "oneOf" entsprechen';
            break;
          case "pattern":
            out = 'muss diesem Muster entsprechen: "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'muss ein Attribut nach folgendem Muster haben "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "Attributname ist ungltig";
            break;
          case "required":
            out = "muss das erforderliche Attribut " + e.params.missingProperty + " enthalten";
            break;
          case "type":
            out = "muss sein: " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "darf nicht mehr als " + n + " Element";
            if (n != 1) {
              out += "e";
            }
            out += " haben";
            break;
          case "unevaluatedProperties":
            out = "darf keine unausgewerteten Attribute haben";
            break;
          case "uniqueItems":
            out = "darf keine Duplikate enthalten (Elemente #" + e.params.j + " und #" + e.params.i + " sind gleich)";
            break;
          default:
            out = 'muss die Validierung "' + e.keyword + '" bestehen';
        }
        e.message = out;
      }
    };
    var es = function localize_es(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "no debe tener ms de " + n + " elemento";
            if (n != 1) {
              out += "s";
            }
            break;
          case "additionalProperties":
            out = "no debe tener propiedades adicionales";
            break;
          case "anyOf":
            out = 'debe coincidir con algn esquema en "anyOf"';
            break;
          case "const":
            out = "debe ser igual a la constante";
            break;
          case "contains":
            out = "debe contener un elemento vlido";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "debe contener la";
            if (n != 1) {
              out += "s";
            }
            out += " propiedad";
            if (n != 1) {
              out += "es";
            }
            out += " " + e.params.deps + " cuando la propiedad " + e.params.property + " se encuentra presente";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = 'debe pasar la validacin de palabra clave "' + e.keyword + '"';
            }
            break;
          case "enum":
            out = "deber ser igual a uno de los valores predefinidos";
            break;
          case "false schema":
            out = "el esquema s falso";
            break;
          case "format":
            out = 'debe coincidir con el formato "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "debe ser " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "debe ser " + cond;
            break;
          case "if":
            out = 'debe corresponderse con el esquema "' + e.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "debe ser " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "no debe contener ms de " + n + " elemento";
            if (n != 1) {
              out += "s";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "no debe contener ms de " + n + " caracter";
            if (n != 1) {
              out += "es";
            }
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "no debe contener ms de " + n + " propiedad";
            if (n != 1) {
              out += "es";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "debe ser " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "no debe contener menos de " + n + " elemento";
            if (n != 1) {
              out += "s";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "no debe contener menos de " + n + " caracter";
            if (n != 1) {
              out += "es";
            }
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "no debe contener menos de " + n + " propiedad";
            if (n != 1) {
              out += "es";
            }
            break;
          case "multipleOf":
            out = "debe ser mltiplo de " + e.params.multipleOf;
            break;
          case "not":
            out = 'no debe ser vlido segn el esquema en "not"';
            break;
          case "oneOf":
            out = 'debe coincidir con un solo esquema en "oneOf"';
            break;
          case "pattern":
            out = 'debe coincidir con el patron "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'la propiedad debe coincidir con el patrn "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "la propiedad no s vlida";
            break;
          case "required":
            out = "debe tener la propiedad requerida " + e.params.missingProperty;
            break;
          case "type":
            out = "debe ser " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "no debe contener elementos duplicados, (los elementos ## " + e.params.j + " y " + e.params.i + " son idnticos)";
            break;
          default:
            out = 'debe pasar la validacin de palabra clave "' + e.keyword + '"';
        }
        e.message = out;
      }
    };
    var fi = function localize_fi(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "saa sislt enintn " + n;
            if (n == 1) {
              out += ":n elementin";
            } else {
              out += " elementti";
            }
            break;
          case "additionalProperties":
            out = "ei saa sislt ylimrisi ominaisuuksia";
            break;
          case "anyOf":
            out = 'tytyy vastata "anyOf" skeemaa';
            break;
          case "const":
            out = "tytyy olla yht kuin vakio";
            break;
          case "contains":
            out = "tytyy sislt kelvollinen elementti";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "tytyy sislt " + e.params.deps + " ominaisuu";
            if (n == 1) {
              out += "s";
            } else {
              out += "det";
            }
            out += " kun " + e.params.property + "-ominaisuus on lsn";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tunniste "' + e.params.tag + '" tytyy olla merkkijono';
                break;
              case "mapping":
                out = 'tunnisteen "' + e.params.tag + '" arvon muoto pit olla oneOf';
                break;
              default:
                out = 'tytyy lpist "' + e.keyword + '" avainsanatarkistus';
            }
            break;
          case "enum":
            out = "tytyy olla yht kuin jokin sallituista arvoista";
            break;
          case "false schema":
            out = "boolean skeema on vr";
            break;
          case "format":
            out = 'tytyy vastata muotoa "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "tytyy olla " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "tytyy olla " + cond;
            break;
          case "if":
            out = 'tytyy vastata "' + e.params.failingKeyword + '" skeemaa';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "tytyy olla " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "tulee sislt enintn " + n + " ";
            if (n == 1) {
              out += "elementti";
            } else {
              out += "elementti";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "ei saa olla pidempi kuin " + n + " merkki";
            if (n != 1) {
              out += "";
            }
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "tulee sislt enintn " + n + " ";
            if (n == 1) {
              out += "ominaisuus";
            } else {
              out += "ominaisuutta";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "tytyy olla " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "tulee sislt vhintn " + n + " ";
            if (n == 1) {
              out += "elementti";
            } else {
              out += "elementti";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "ei saa olla lyhyempi kuin " + n + " merkki";
            if (n != 1) {
              out += "";
            }
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "tulee sislt vhintn " + n + " ";
            if (n == 1) {
              out += "ominaisuus";
            } else {
              out += "ominaisuutta";
            }
            break;
          case "multipleOf":
            out = "tytyy olla moninkertainen: " + e.params.multipleOf;
            break;
          case "not":
            out = 'ei saa olla hyvksytty skeeman "not" mukaan';
            break;
          case "oneOf":
            out = 'tytyy vastata tsmlleen yht "oneOf" -kohdassa mritelty skeemaa';
            break;
          case "pattern":
            out = 'tytyy vastata muotoa "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'tytyy sislt ominaisuus joka vastaa kaavaa "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "ominaisuuden nimi on virheellinen";
            break;
          case "required":
            out = "tytyy sislt vaadittu ominaisuus " + e.params.missingProperty;
            break;
          case "type":
            out = "";
            var t = e.params.type;
            out += "tytyy olla ";
            if (t == "number") {
              out += "numero";
            } else if (t == "integer") {
              out += "kokonaisluku";
            } else if (t == "string") {
              out += "merkkijono";
            } else if (t == "boolean") {
              out += "boolean";
            } else {
              out += t;
            }
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "ei saa olla enemmn kuin " + n + " elementti";
            if (n != 1) {
              out += "";
            }
            break;
          case "unevaluatedProperties":
            out = "ei saa sislt arvioimattomia ominaisuuksia";
            break;
          case "uniqueItems":
            out = "ei saa sislt duplikaatteja (elementit ## " + e.params.j + " ja " + e.params.i + " ovat identtiset)";
            break;
          default:
            out = 'tytyy lpist "' + e.keyword + '" avainsanatarkistus';
        }
        e.message = out;
      }
    };
    var fr$1 = function localize_fr(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "ne doit pas contenir plus de " + n + " lmnt";
            if (n != 1) {
              out += "s";
            }
            break;
          case "additionalProperties":
            out = "ne doit pas contenir de proprits additionnelles";
            break;
          case "anyOf":
            out = 'doit correspondre  un schma de "anyOf"';
            break;
          case "const":
            out = "doit tre gal  la constante";
            break;
          case "contains":
            out = "doit contenir un lment valide";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "doit avoir la proprit " + e.params.deps + " quand la proprit " + e.params.property + " est prsente";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = 'doit tre valide selon le critre "' + e.keyword + '"';
            }
            break;
          case "enum":
            out = "doit tre gal  une des valeurs prdfinies";
            break;
          case "false schema":
            out = 'le schema est "false"';
            break;
          case "format":
            out = 'doit correspondre au format "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "doit tre " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "doit tre " + cond;
            break;
          case "if":
            out = 'doit correspondre au schma "' + e.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "doit tre " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "ne doit pas contenir plus de " + n + " lment";
            if (n != 1) {
              out += "s";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "ne doit pas dpasser " + n + " caractre";
            if (n != 1) {
              out += "s";
            }
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "ne doit pas contenir plus de " + n + " proprit";
            if (n != 1) {
              out += "s";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "doit tre " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "ne doit pas contenir moins de " + n + " lment";
            if (n != 1) {
              out += "s";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "ne doit pas faire moins de " + n + " caractre";
            if (n != 1) {
              out += "s";
            }
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "ne doit pas contenir moins de " + n + " proprit";
            if (n != 1) {
              out += "s";
            }
            break;
          case "multipleOf":
            out = "doit tre un multiple de " + e.params.multipleOf;
            break;
          case "not":
            out = 'est invalide selon le schma "not"';
            break;
          case "oneOf":
            out = 'doit correspondre  exactement un schma de "oneOf"';
            break;
          case "pattern":
            out = 'doit correspondre au format "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'la proprit doit correspondre au format "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "le nom de proprit est invalide";
            break;
          case "required":
            out = "requiert la proprit " + e.params.missingProperty;
            break;
          case "type":
            out = "doit tre de type " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "ne doit pas contenir de doublons (les lments ## " + e.params.j + " et " + e.params.i + " sont identiques)";
            break;
          default:
            out = 'doit tre valide selon le critre "' + e.keyword + '"';
        }
        e.message = out;
      }
    };
    var hu = function localize_hu(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "nem lehet tbb, mint " + n + " eleme";
            break;
          case "additionalProperties":
            out = "nem lehetnek tovbbi elemei";
            break;
          case "anyOf":
            out = 'meg kell feleljen legalbb egy "anyOf" alaknak';
            break;
          case "const":
            out = "must be equal to constant";
            break;
          case "contains":
            out = "must contain a valid item";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "-nak kell legyen";
            if (n > 1) {
              out += "ek";
            }
            out += " a kvetkez tulajdonsga";
            if (n != 1) {
              out += "i";
            }
            out += ": " + e.params.deps + ", ha van " + e.params.property + " tulajdonsga";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = 'must pass "' + e.keyword + '" keyword validation';
            }
            break;
          case "enum":
            out = "egyenl kell legyen valamely elre meghatrozott rtkkel";
            break;
          case "false schema":
            out = "boolean schema is false";
            break;
          case "format":
            out = 'meg kell feleljen a kvetkez formtumnak: "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "must be " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "must be " + cond;
            break;
          case "if":
            out = 'must match "' + e.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "kell legyen " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "nem lehet tbb, mint " + n + " eleme";
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "nem lehet hosszabb, mint " + n + " szimblum";
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "nem lehet tbb, mint " + n + " tulajdonsga";
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "kell legyen " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "nem lehet kevesebb, mint " + n + " eleme";
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "nem lehet rvidebb, mint " + n + " szimblum";
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "nem lehet kevesebb, mint " + n + " tulajdonsga";
            break;
          case "multipleOf":
            out = "a tbbszrse kell legyen a kvetkez szmnak: " + e.params.multipleOf;
            break;
          case "not":
            out = 'nem lehet rvnyes a "not" alaknak megfelelen';
            break;
          case "oneOf":
            out = 'meg kell feleljen pontosan egy "oneOf" alaknak';
            break;
          case "pattern":
            out = 'meg kell feleljen a kvetkez mintnak: "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'must have property matching pattern "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "property name is invalid";
            break;
          case "required":
            out = "kell legyen " + e.params.missingProperty + " tulajdonsga";
            break;
          case "type":
            out = "" + e.params.type + " kell legyen";
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "nem lehetnek azonos elemei (" + e.params.j + " s " + e.params.i + " elemek azonosak)";
            break;
          default:
            out = 'must pass "' + e.keyword + '" keyword validation';
        }
        e.message = out;
      }
    };
    var id = function localize_id(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += " tidak boleh memiliki lebih dari " + n + " item";
            break;
          case "additionalProperties":
            out = "tidak boleh memiliki properti tambahan";
            break;
          case "anyOf":
            out = 'harus cocok dengan beberapa skema pada "anyOf"';
            break;
          case "const":
            out = "harus sama dengan konstan";
            break;
          case "contains":
            out = "harus berisi item yang valid";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += " harus memiliki properti " + e.params.deps + " ketika properti " + e.params.property + " hadir";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = 'harus lulus validasi kata kunci "' + e.keyword + '"';
            }
            break;
          case "enum":
            out = "harus sama dengan salah satu dari nilai yang telah ditentukan";
            break;
          case "false schema":
            out = "skema boolean salah";
            break;
          case "format":
            out = 'harus cocok dengan format "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "harus " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "harus " + cond;
            break;
          case "if":
            out = 'harus cocok dengan skema "' + e.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "harus " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += " tidak boleh memiliki lebih dari " + n + " item";
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += " tidak boleh lebih dari " + n + " karakter";
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += " tidak boleh memiliki lebih dari " + n + " properti";
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "harus " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += " tidak boleh kurang dari " + n + " item";
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += " tidak boleh lebih pendek dari " + n + " karakter";
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += " tidak boleh kurang dari " + n + " properti";
            break;
          case "multipleOf":
            out = "harus merupakan kelipatan dari " + e.params.multipleOf;
            break;
          case "not":
            out = 'tidak boleh valid sesuai dengan skema pada "not"';
            break;
          case "oneOf":
            out = 'harus sama persis dengan satu skema pada "oneOf"';
            break;
          case "pattern":
            out = 'harus cocok dengan pola "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'harus memiliki pola pencocokan properti "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "nama properti tidak valid";
            break;
          case "required":
            out = "harus memiliki properti " + e.params.missingProperty;
            break;
          case "type":
            out = "harus berupa " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "tidak boleh memiliki item duplikat (item ## " + e.params.j + " dan " + e.params.i + " identik)";
            break;
          default:
            out = 'harus lulus validasi kata kunci "' + e.keyword + '"';
        }
        e.message = out;
      }
    };
    var it$1 = function localize_it(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "non dovrebbe avere pi di " + n + " element";
            if (n == 1) {
              out += "o";
            } else {
              out += "i";
            }
            break;
          case "additionalProperties":
            out = "non deve avere attributi aggiuntivi";
            break;
          case "anyOf":
            out = 'deve corrispondere ad uno degli schema in "anyOf"';
            break;
          case "const":
            out = "deve essere uguale alla costante";
            break;
          case "contains":
            out = "deve contentere un elemento valido";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "dovrebbe avere ";
            if (n == 1) {
              out += "l'";
            } else {
              out += "gli ";
            }
            out += "attribut";
            if (n == 1) {
              out += "o";
            } else {
              out += "i";
            }
            out += " " + e.params.deps + " quando l'attributo " + e.params.property + "  presente";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'il tag "' + e.params.tag + '" deve essere di tipo stringa';
                break;
              case "mapping":
                out = 'il valore del tag "' + e.params.tag + '" deve essere nei oneOf';
                break;
              default:
                out = 'deve essere valido secondo il criterio "' + e.keyword + '"';
            }
            break;
          case "enum":
            out = "deve essere uguale ad uno dei valori consentiti";
            break;
          case "false schema":
            out = "lo schema booleano  falso";
            break;
          case "format":
            out = 'deve corrispondere al formato "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "deve essere " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "deve essere " + cond;
            break;
          case "if":
            out = 'deve corrispondere allo schema "' + e.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "deve essere " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "non deve avere pi di " + n + " element";
            if (n == 1) {
              out += "o";
            } else {
              out += "i";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "non deve essere pi lungo di " + n + " caratter";
            if (n == 1) {
              out += "e";
            } else {
              out += "i";
            }
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "non deve avere pi di " + n + " attribut";
            if (n == 1) {
              out += "o";
            } else {
              out += "i";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "deve essere " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "non deve avere meno di " + n + " element";
            if (n == 1) {
              out += "o";
            } else {
              out += "i";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "non deve essere meno lungo di " + n + " caratter";
            if (n == 1) {
              out += "e";
            } else {
              out += "i";
            }
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "non deve avere meno di " + n + " attribut";
            if (n == 1) {
              out += "o";
            } else {
              out += "i";
            }
            break;
          case "multipleOf":
            out = "deve essere un multiplo di " + e.params.multipleOf;
            break;
          case "not":
            out = 'non deve essere valido in base allo schema di "non"';
            break;
          case "oneOf":
            out = 'deve corrispondere esattamente ad uno degli schema in "oneOf"';
            break;
          case "pattern":
            out = 'deve corrispondere al formato "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'deve avere un attributo che corrisponda al formato "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "il nome dell'attritbuto non  valido";
            break;
          case "required":
            out = "deve avere l'attributo obbligatorio " + e.params.missingProperty;
            break;
          case "type":
            out = "deve essere di tipo " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "non deve avere pi di " + n + " elementi";
            if (n == 1) {
              out += "o";
            } else {
              out += "i";
            }
            break;
          case "unevaluatedProperties":
            out = "non deve avere attributi non valutati";
            break;
          case "uniqueItems":
            out = "non deve avere duplicati (gli elementi ## " + e.params.j + " e " + e.params.i + " sono uguali)";
            break;
          default:
            out = 'deve essere valido secondo il criterio "' + e.keyword + '"';
        }
        e.message = out;
      }
    };
    var ja = function localize_ja(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "" + n + "";
            break;
          case "additionalProperties":
            out = "";
            break;
          case "anyOf":
            out = '"anyOf"';
            break;
          case "const":
            out = "must be equal to constant";
            break;
          case "contains":
            out = "must contain a valid item";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "" + e.params.property + "";
            var n = e.params.depsCount;
            out += "" + e.params.deps + "";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = 'must pass "' + e.keyword + '" keyword validation';
            }
            break;
          case "enum":
            out = "";
            break;
          case "false schema":
            out = "boolean schema is false";
            break;
          case "format":
            out = '"' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "must be " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "must be " + cond;
            break;
          case "if":
            out = 'must match "' + e.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += cond + "";
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "" + n + "";
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "" + n + "";
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "" + n + "";
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += cond + "";
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "" + n + "";
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "" + n + "";
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "" + n + "";
            break;
          case "multipleOf":
            out = "" + e.params.multipleOf + "";
            break;
          case "not":
            out = '"not"';
            break;
          case "oneOf":
            out = '"oneOf"';
            break;
          case "pattern":
            out = '"' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'must have property matching pattern "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "property name is invalid";
            break;
          case "required":
            out = "" + e.params.missingProperty + "";
            break;
          case "type":
            out = "" + e.params.type + "";
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "" + e.params.j + "" + e.params.i + "";
            break;
          default:
            out = 'must pass "' + e.keyword + '" keyword validation';
        }
        e.message = out;
      }
    };
    var ko = function localize_ko(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "   " + n + "    ";
            break;
          case "additionalProperties":
            out = "   ";
            break;
          case "anyOf":
            out = '"anyOf"   ';
            break;
          case "const":
            out = " ";
            break;
          case "contains":
            out = "   ";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += e.params.property + "  , " + e.params.deps + "  ";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = '"' + e.params.tag + '"   ';
                break;
              case "mapping":
                out = '"' + e.params.tag + '"   oneOf  ';
                break;
              default:
                out = '"' + e.keyword + '"   ';
            }
            break;
          case "enum":
            out = "    ";
            break;
          case "false schema":
            out = "boolean   ";
            break;
          case "format":
            out = '"' + e.params.format + '"   ';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += " " + cond + "  ";
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += " " + cond + "  ";
            break;
          case "if":
            out = '"' + e.params.failingKeyword + '"   ';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += " " + cond + "  ";
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "  " + n + " ";
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += " " + n + " ";
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "  " + n + "  ";
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += " " + cond + "  ";
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "  " + n + " ";
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += " " + n + " ";
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "  " + n + "  ";
            break;
          case "multipleOf":
            out = "" + e.params.multipleOf + "  ";
            break;
          case "not":
            out = '"not"    ';
            break;
          case "oneOf":
            out = '"oneOf"     ';
            break;
          case "pattern":
            out = '"' + e.params.pattern + '"  ';
            break;
          case "patternRequired":
            out = '"' + e.params.missingPattern + '"    ';
            break;
          case "propertyNames":
            out = "  ";
            break;
          case "required":
            out = "" + e.params.missingProperty + "  ";
            break;
          case "type":
            out = "" + e.params.type + " ";
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += " " + n + "   ";
            break;
          case "unevaluatedProperties":
            out = "   .";
            break;
          case "uniqueItems":
            out = "    (" + e.params.j + " " + e.params.i + " )";
            break;
          default:
            out = '"' + e.keyword + '"   ';
        }
        e.message = out;
      }
    };
    var nb = function localize_nb(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "kan ikke ha mer enn " + n + " element";
            if (n != 1) {
              out += "er";
            }
            break;
          case "additionalProperties":
            out = "kan ikke ha flere egenskaper";
            break;
          case "anyOf":
            out = 'm samsvare med et schema i "anyOf"';
            break;
          case "const":
            out = "m vre lik konstanten";
            break;
          case "contains":
            out = "m inneholde et gyldig element";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "m ha egenskapen";
            if (n != 1) {
              out += "e";
            }
            out += " " + e.params.deps + " nr egenskapen " + e.params.property + " er angitt";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = "m samsvare med valideringen for " + e.keyword;
            }
            break;
          case "enum":
            out = "m vre lik en av de forhndsdefinerte verdiene";
            break;
          case "false schema":
            out = "boolsk schema er usannt";
            break;
          case "format":
            out = 'm stemme overens med formatet "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "m vre " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "m vre " + cond;
            break;
          case "if":
            out = 'must match "' + e.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "m vre " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "kan ikke ha fler enn " + n + " element";
            if (n != 1) {
              out += "er";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "kan ikke vre lengre enn " + n + " tegn";
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "kan ikke ha mer enn " + n + " egenskap";
            if (n != 1) {
              out += "er";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "m vre " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "kan ikke ha frre enn " + n + " element";
            if (n != 1) {
              out += "er";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "kan ikke vre kortere enn " + n + " tegn";
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "kan ikke ha mindre enn " + n + " egenskap";
            if (n != 1) {
              out += "er";
            }
            break;
          case "multipleOf":
            out = "m vre et multiplum av " + e.params.multipleOf;
            break;
          case "not":
            out = 'kan ikke samsvare med schema i "not"';
            break;
          case "oneOf":
            out = 'm samsvare med nyaktig ett schema i "oneOf"';
            break;
          case "pattern":
            out = 'm samsvare med mnsteret "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'm ha en egenskap som samsvarer med mnsteret "' + e.params.missingPattern;
            break;
          case "propertyNames":
            out = "egenskapen med navnet '";
            e.params.propertyNameout += "' er ugyldig";
            break;
          case "required":
            out = "m ha den pkrevde egenskapen " + e.params.missingProperty;
            break;
          case "type":
            out = "";
            var t = e.params.type;
            out += "m vre ";
            if (t == "number") {
              out += "et tall";
            } else if (t == "integer") {
              out += "et heltall";
            } else if (t == "string") {
              out += "en streng";
            } else if (t == "boolean") {
              out += "ja eller nei";
            } else {
              out += t;
            }
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "kan ikke ha duplikate elemeneter (elementene ## " + e.params.j + " og " + e.params.i + " er identiske)";
            break;
          default:
            out = "m samsvare med valideringen for " + e.keyword;
        }
        e.message = out;
      }
    };
    var nl = function localize_nl(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "mag niet meer dan " + n + " item";
            if (n != 1) {
              out += "s";
            }
            out += " bevatten";
            break;
          case "additionalProperties":
            out = "mag geen extra eigenschappen bevatten";
            break;
          case "anyOf":
            out = 'moet overeenkomen met een schema in "anyOf"';
            break;
          case "const":
            out = "moet gelijk zijn aan constante";
            break;
          case "contains":
            out = "moet een geldig item bevatten";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "moet de eigenschap";
            if (n != 1) {
              out += "pen";
            }
            out += " " + e.params.deps + " bevatten als " + e.params.property + " is gedefinieerd";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" moet een tekenreeks zijn';
                break;
              case "mapping":
                out = 'de waarde van het veld "' + e.params.tag + '" moet voorkomen in de oneOf';
                break;
              default:
                out = 'moet sleutelwoord validatie "' + e.keyword + '" doorstaan';
            }
            break;
          case "enum":
            out = "moet overeenkomen met n van de voorgedefinieerde waarden";
            break;
          case "false schema":
            out = "boolean schema is fout";
            break;
          case "format":
            out = 'moet overeenkomen met het volgende formaat: "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "moet " + cond + " zijn";
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "moet " + cond + " zijn";
            break;
          case "if":
            out = 'moet overeenkomen met "' + e.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "moet " + cond + " zijn";
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "mag niet meer dan " + n + " item";
            if (n != 1) {
              out += "s";
            }
            out += " bevatten";
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "mag niet langer dan " + n + " karakter";
            if (n != 1) {
              out += "s";
            }
            out += " zijn";
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "mag niet meer dan " + n + " eigenschap";
            if (n != 1) {
              out += "pen";
            }
            out += " bevatten";
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "moet " + cond + " zijn";
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "mag niet minder dan " + n + " item";
            if (n != 1) {
              out += "s";
            }
            out += " bevatten";
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "mag niet korter dan " + n + " karakter";
            if (n != 1) {
              out += "s";
            }
            out += " zijn";
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "mag niet minder dan " + n + " eigenschap";
            if (n != 1) {
              out += "pen";
            }
            out += " bevatten";
            break;
          case "multipleOf":
            out = "moet een veelvoud van " + e.params.multipleOf + " zijn";
            break;
          case "not":
            out = 'mag niet overeenkomen met een schema in "not"';
            break;
          case "oneOf":
            out = 'moet overeenkomen met n schema in "oneOf"';
            break;
          case "pattern":
            out = 'moet overeenkomen met het volgende patroon: "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'moet een eigenschap bevatten die overeenkomt met het pattroon: "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "eigenschapnaam is ongeldig";
            break;
          case "required":
            out = "moet de eigenschap " + e.params.missingProperty + " bevatten";
            break;
          case "type":
            out = "";
            var t = e.params.type;
            out += "moet een ";
            if (t == "number") {
              out += "nummer";
            } else if (t == "integer") {
              out += "geheel getal";
            } else if (t == "string") {
              out += "tekenreeks";
            } else if (t == "boolean") {
              out += "ja of nee waarde";
            }
            out += " (" + t + ") bevatten";
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "mag niet meer dan " + n + " item";
            if (n != 1) {
              out += "s";
            }
            out += " bevatten";
            break;
          case "unevaluatedProperties":
            out = "mag geen ongecontroleerde eigenschappen bevatten";
            break;
          case "uniqueItems":
            out = "mag geen gedupliceerde items bevatten (items ## " + e.params.j + " en " + e.params.i + " zijn identiek)";
            break;
          default:
            out = 'moet sleutelwoord validatie "' + e.keyword + '" doorstaan';
        }
        e.message = out;
      }
    };
    var pl = function localize_pl(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "nie powinien mie wicej ni " + n + " element";
            if (n == 1) {
              out += "u";
            } else {
              out += "w";
            }
            break;
          case "additionalProperties":
            out = "nie powinien zawiera dodatkowych pl";
            break;
          case "anyOf":
            out = 'powinien pasowa do wzoru z sekcji "anyOf"';
            break;
          case "const":
            out = "powinien by rwny staej";
            break;
          case "contains":
            out = "must contain a valid item";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "powinien zawiera pol";
            if (n == 1) {
              out += "e";
            } else {
              out += "a";
            }
            out += " " + e.params.deps + " kiedy pole " + e.params.property + " jest obecne";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = 'powinien przej walidacj "' + e.keyword + '"';
            }
            break;
          case "enum":
            out = "powinien by rwny jednej z predefiniowanych wartoci";
            break;
          case "false schema":
            out = "boolean schema is false";
            break;
          case "format":
            out = 'powinien zgadza si z formatem "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "powinien by " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "powinien by " + cond;
            break;
          case "if":
            out = 'must match "' + e.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "powinien by " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "nie powinien mie wicej ni " + n + " element";
            if (n == 1) {
              out += "u";
            } else {
              out += "w";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "nie powinien by duszy ni " + n + " znak";
            if (n != 1) {
              out += "w";
            }
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "nie powinien zawiera wicej ni " + n + " ";
            if (n == 1) {
              out += "pole";
            } else {
              out += "pl";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "powinien by " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "nie powinien mie mniej ni " + n + " element";
            if (n == 1) {
              out += "u";
            } else {
              out += "w";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "nie powinien by krtszy ni " + n + " znak";
            if (n != 1) {
              out += "w";
            }
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "nie powinien zawiera mniej ni " + n + " ";
            if (n == 1) {
              out += "pole";
            } else {
              out += "pl";
            }
            break;
          case "multipleOf":
            out = "powinien by wielokrotnoci " + e.params.multipleOf;
            break;
          case "not":
            out = 'nie powinien pasowa do wzoru z sekcji "not"';
            break;
          case "oneOf":
            out = 'powinien pasowa do jednego wzoru z sekcji "oneOf"';
            break;
          case "pattern":
            out = 'powinien zgadza si ze wzorem "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'powinien mie pole pasujce do wzorca "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "property name is invalid";
            break;
          case "required":
            out = "powinien zawiera wymagane pole " + e.params.missingProperty;
            break;
          case "type":
            out = "powinien by " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "nie powinien zawiera elementw ktre si powtarzaj (elementy " + e.params.j + " i " + e.params.i + " s identyczne)";
            break;
          default:
            out = 'powinien przej walidacj "' + e.keyword + '"';
        }
        e.message = out;
      }
    };
    var ptBR = function localize_pt_BR(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "no so permitidos itens adicionais (mais do que " + n + ")";
            break;
          case "additionalProperties":
            out = "no so permitidas propriedades adicionais";
            break;
          case "anyOf":
            out = 'os dados no correspondem a nenhum schema de "anyOf"';
            break;
          case "const":
            out = "deve ser igual  constante";
            break;
          case "contains":
            out = "deve conter um item vlido";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += " deve ter propriedade";
            if (n != 1) {
              out += "s";
            }
            out += " " + e.params.deps + " quando a propriedade " + e.params.property + " estiver presente";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'a tag "' + e.params.tag + '" deve ser uma string';
                break;
              case "mapping":
                out = 'o valor da tag "' + e.params.tag + '" deve estar no oneOf';
                break;
              default:
                out = 'deve passar a validao da keyword "' + e.keyword + '"';
            }
            break;
          case "enum":
            out = "deve ser igual a um dos valores permitidos";
            break;
          case "false schema":
            out = 'o schema booleano  "false"';
            break;
          case "format":
            out = 'deve corresponder ao formato "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "deve ser " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "deve ser " + cond;
            break;
          case "if":
            out = 'deve corresponder ao schema "' + e.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "deve ser " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "no deve ter mais que " + n + " elemento";
            if (n != 1) {
              out += "s";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "no deve ser maior que " + n + " caracter";
            if (n != 1) {
              out += "es";
            }
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "no deve ter mais que " + n + " propriedade";
            if (n != 1) {
              out += "s";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "deve ser " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "no deve ter menos que " + n + " elemento";
            if (n != 1) {
              out += "s";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "no deve ser mais curta que " + n + " caracter";
            if (n != 1) {
              out += "es";
            }
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "no deve ter menos que " + n + " propriedade";
            if (n != 1) {
              out += "s";
            }
            break;
          case "multipleOf":
            out = "deve ser mltiplo de " + e.params.multipleOf;
            break;
          case "not":
            out = 'no deve ser valido segundo o schema em "not"';
            break;
          case "oneOf":
            out = 'deve corresponder exatamente com um schema em "oneOf"';
            break;
          case "pattern":
            out = 'deve corresponder ao padro "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'deve ter a propriedade correspondente ao padro "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "o nome da propriedade  invlido";
            break;
          case "required":
            out = "deve ter a propriedade obrigatria " + e.params.missingProperty;
            break;
          case "type":
            out = "";
            var t = e.params.type;
            out += "deve ser ";
            if (t == "number") {
              out += "um nmero";
            } else if (t == "integer") {
              out += "um nmero inteiro";
            } else if (t == "string") {
              out += "um texto";
            } else if (t == "boolean") {
              out += "um booleano";
            } else {
              out += t;
            }
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "no pode possuir mais que " + n + " ";
            if (n == 1) {
              out += "item";
            } else {
              out += "itens";
            }
            break;
          case "unevaluatedProperties":
            out = "no pode possuir propridades no avaliadas";
            break;
          case "uniqueItems":
            out = "no deve ter itens duplicados (os itens ## " + e.params.j + " e " + e.params.i + " so idnticos)";
            break;
          default:
            out = 'deve passar a validao da keyword "' + e.keyword + '"';
        }
        e.message = out;
      }
    };
    var ru = function localize_ru(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "   ,  " + n + " ";
            if (n >= 2 && n <= 4) {
              out += "";
            } else if (n != 1) {
              out += "";
            }
            break;
          case "additionalProperties":
            out = "    ";
            break;
          case "anyOf":
            out = '      "anyOf"';
            break;
          case "const":
            out = "    ";
            break;
          case "contains":
            out = "    ";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "  ";
            if (n == 1) {
              out += "";
            } else {
              out += "";
            }
            out += " " + e.params.deps + ",    " + e.params.property;
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = ' "' + e.params.tag + '"   ';
                break;
              case "mapping":
                out = '  "' + e.params.tag + '"      oneOf  ';
                break;
              default:
                out = '   "' + e.keyword + '"';
            }
            break;
          case "enum":
            out = "      ";
            break;
          case "false schema":
            out = "  false";
            break;
          case "format":
            out = '   "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "  " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "  " + cond;
            break;
          case "if":
            out = '  e "' + e.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "  " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "   ,  " + n + " ";
            if (n >= 2 && n <= 4) {
              out += "";
            } else if (n != 1) {
              out += "";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "   ,  " + n + " ";
            if (n >= 2 && n <= 4) {
              out += "";
            } else if (n != 1) {
              out += "";
            }
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "   ,  " + n + " ";
            if (n == 1) {
              out += "";
            } else if (n >= 2 && n <= 4) {
              out += "";
            } else {
              out += "";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "  " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "   ,  " + n + " ";
            if (n >= 2 && n <= 4) {
              out += "";
            } else if (n != 1) {
              out += "";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "   ,  " + n + " ";
            if (n >= 2 && n <= 4) {
              out += "";
            } else if (n != 1) {
              out += "";
            }
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "   ,  " + n + " ";
            if (n == 1) {
              out += "";
            } else if (n >= 2 && n <= 4) {
              out += "";
            } else {
              out += "";
            }
            break;
          case "multipleOf":
            out = "   " + e.params.multipleOf;
            break;
          case "not":
            out = '     "not"';
            break;
          case "oneOf":
            out = '     e  "oneOf"';
            break;
          case "pattern":
            out = '   "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = '  ,   "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "    ";
            break;
          case "required":
            out = "    " + e.params.missingProperty;
            break;
          case "type":
            out = "  " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "   ,  " + n + " ";
            if (n >= 2 && n <= 4) {
              out += "";
            } else if (n != 1) {
              out += "";
            }
            break;
          case "unevaluatedProperties":
            out = "    ";
            break;
          case "uniqueItems":
            out = "     ( " + e.params.j + "  " + e.params.i + " )";
            break;
          default:
            out = '   "' + e.keyword + '"';
        }
        e.message = out;
      }
    };
    var sk = function localize_sk(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "neme obsahova viac, ne " + n + " prv";
            if (n == 1) {
              out += "ok";
            } else {
              out += "kov";
            }
            break;
          case "additionalProperties":
            out = "neme obsahova alie poloky";
            break;
          case "anyOf":
            out = 'mus splova aspo jednu zo schm v "anyOf"';
            break;
          case "const":
            out = "mus by kontanta";
            break;
          case "contains":
            out = "mus obsahova prvok zodpovedajci schme";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += " mus obsahova polo";
            if (n >= 2 && n <= 4) {
              out += "ky";
            } else if (n != 1) {
              out += "iek";
            } else {
              out += "ka";
            }
            out += ": " + e.params.deps + ", ak obsahuje " + e.params.property;
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = 'mus splni "' + e.keyword + '" validciu';
            }
            break;
          case "enum":
            out = "mus by jedna z definovanch hodnt";
            break;
          case "false schema":
            out = "schma je false";
            break;
          case "format":
            out = 'mus obsahova formt "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "mus by " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "mus by " + cond;
            break;
          case "if":
            out = 'must match "' + e.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "mus by " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "nesmie obsahova viac ne " + n + " prv";
            if (n == 1) {
              out += "ok";
            } else {
              out += "kov";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "nesmie by dlh ne " + n + " znak";
            if (n != 1) {
              out += "ov";
            }
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "nesmie obsahova viac ne " + n + " polo";
            if (n >= 2 && n <= 4) {
              out += "ky";
            } else if (n != 1) {
              out += "iek";
            } else {
              out += "ka";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "mus by " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "nesmie obsahova menej ne " + n + " prv";
            if (n == 1) {
              out += "ok";
            } else {
              out += "kov";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "nesmie by krat ne " + n + " znak";
            if (n != 1) {
              out += "ov";
            }
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "nesmie obsahova menej ne " + n + " polo";
            if (n >= 2 && n <= 4) {
              out += "ky";
            } else if (n != 1) {
              out += "iek";
            } else {
              out += "ka";
            }
            break;
          case "multipleOf":
            out = "mus by nsobkom " + e.params.multipleOf;
            break;
          case "not":
            out = 'nesmie splova schmu v "not"';
            break;
          case "oneOf":
            out = 'mus splova prve jednu schmu v "oneOf"';
            break;
          case "pattern":
            out = 'mus splova regulrny vraz "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'mus obsahova poloku spljcu regulrny vraz "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "nzov poloky nezodpoved schme";
            break;
          case "required":
            out = "mus obsahova poadovan poloku " + e.params.missingProperty;
            break;
          case "type":
            out = "mus by " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "nesmie obsahova duplicitn prvky (prvky ## " + e.params.j + " a " + e.params.i + " s rovnak)";
            break;
          default:
            out = 'mus splni "' + e.keyword + '" validciu';
        }
        e.message = out;
      }
    };
    var sv = function localize_sv(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "borde ha fler n " + n + " sak";
            if (n != 1) {
              out += "er";
            }
            break;
          case "additionalProperties":
            out = "borde inte ha fler egenskaper";
            break;
          case "anyOf":
            out = 'borde matcha ngot schema i "anyOf"';
            break;
          case "const":
            out = "br vara en konstant";
            break;
          case "contains":
            out = "br innehlla ett giltigt objekt";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "borde ha egenskap";
            if (n != 1) {
              out += "er";
            }
            out += " " + e.params.deps + " nr egenskap " + e.params.property + " finns tillgngligt";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = 'br passera "' + e.keyword + '" nyckelord validering';
            }
            break;
          case "enum":
            out = "borde vara ekvivalent med en av dess frdefinierade vrden";
            break;
          case "false schema":
            out = "boolean schema r falskt";
            break;
          case "format":
            out = 'borde matcha formatet "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "br vara " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "br vara " + cond;
            break;
          case "if":
            out = 'must match "' + e.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "borde vara " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "borde inte ha fler n " + n + " sak";
            if (n != 1) {
              out += "er";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "borde inte vara lngre n " + n + " tecken";
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "borde inte ha fler n " + n + " egenskap";
            if (n != 1) {
              out += "er";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "borde vara " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "borde inte ha frre n " + n + " sak";
            if (n != 1) {
              out += "er";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "borde inte vara kortare n " + n + " tecken";
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "borde inte ha frre n " + n + " egenskap";
            if (n != 1) {
              out += "er";
            }
            break;
          case "multipleOf":
            out = "borde vara en multipel av " + e.params.multipleOf;
            break;
          case "not":
            out = 'borde inte vara giltigt enligt schema i "not"';
            break;
          case "oneOf":
            out = 'borde matcha exakt ett schema i "oneOf"';
            break;
          case "pattern":
            out = 'borde matcha mnstret "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'br ha en egenskap som matchar mnstret "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "egenskap med namnet r inte giltig";
            break;
          case "required":
            out = "borde ha den ndvndiga egenskapen " + e.params.missingProperty;
            break;
          case "type":
            out = "borde vara " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "borde inte ha duplicerade saker (sakerna ## " + e.params.j + " och " + e.params.i + " r identiska)";
            break;
          default:
            out = 'br passera "' + e.keyword + '" nyckelord validering';
        }
        e.message = out;
      }
    };
    var th = function localize_th(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += " " + n + " ";
            break;
          case "additionalProperties":
            out = " property  ";
            break;
          case "anyOf":
            out = ' schema  "anyOf"';
            break;
          case "const":
            out = "";
            break;
          case "contains":
            out = "";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += " property " + e.params.property + "  property " + e.params.deps + " ";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '"  string';
                break;
              case "mapping":
                out = ' tag "' + e.params.tag + '"  oneOf';
                break;
              default:
                out = ' "' + e.keyword + '"';
            }
            break;
          case "enum":
            out = "";
            break;
          case "false schema":
            out = "schema  false";
            break;
          case "format":
            out = ' "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += " " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += " " + cond;
            break;
          case "if":
            out = ' schema "' + e.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += " " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += " " + n;
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += " " + n + " ";
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += " property  " + n + " ";
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += " " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += " " + n;
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += " " + n + " ";
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += " property  " + n + " ";
            break;
          case "multipleOf":
            out = " " + e.params.multipleOf + " ";
            break;
          case "not":
            out = ' schema  "not"';
            break;
          case "oneOf":
            out = ' schema  "oneOf" ';
            break;
          case "pattern":
            out = ' pattern "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = ' property  pattern "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = " property ";
            break;
          case "required":
            out = " property " + e.params.missingProperty + " ";
            break;
          case "type":
            out = " " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += " " + n + " ";
            break;
          case "unevaluatedProperties":
            out = " property ";
            break;
          case "uniqueItems":
            out = " ( " + e.params.j + "  " + e.params.i + " )";
            break;
          default:
            out = ' "' + e.keyword + '"';
        }
        e.message = out;
      }
    };
    var zh = function localize_zh(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "" + n + "";
            break;
          case "additionalProperties":
            out = "";
            break;
          case "anyOf":
            out = " anyOf ";
            break;
          case "const":
            out = "";
            break;
          case "contains":
            out = "";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "" + e.params.property + "" + e.params.deps;
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = ' "' + e.params.tag + '" ';
                break;
              case "mapping":
                out = ' "' + e.params.tag + '"  oneOf ';
                break;
              default:
                out = ' "' + e.keyword + ' "';
            }
            break;
          case "enum":
            out = "";
            break;
          case "false schema":
            out = "";
            break;
          case "format":
            out = ' "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += " " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += " " + cond;
            break;
          case "if":
            out = ' "' + e.params.failingKeyword + '" ';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += " " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += " " + n + " ";
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += " " + n + " ";
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += " " + n + " ";
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += " " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += " " + n + " ";
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += " " + n + " ";
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += " " + n + " ";
            break;
          case "multipleOf":
            out = " " + e.params.multipleOf + " ";
            break;
          case "not":
            out = ' "not" schema';
            break;
          case "oneOf":
            out = ' "oneOf"  schema';
            break;
          case "pattern":
            out = ' "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = " " + e.params.missingPattern;
            break;
          case "propertyNames":
            out = " ";
            break;
          case "required":
            out = " " + e.params.missingProperty;
            break;
          case "type":
            out = " " + e.params.type + " ";
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "  " + n + " ";
            break;
          case "unevaluatedProperties":
            out = "";
            break;
          case "uniqueItems":
            out = " ( " + e.params.j + "  " + e.params.i + " )";
            break;
          default:
            out = ' "' + e.keyword + ' "';
        }
        e.message = out;
      }
    };
    var zhTW = function localize_zh_TW(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "" + n + "";
            break;
          case "additionalProperties":
            out = "";
            break;
          case "anyOf":
            out = " anyOf ";
            break;
          case "const":
            out = "";
            break;
          case "contains":
            out = "";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "" + e.params.property + "" + e.params.deps;
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = ' "' + e.params.tag + '" ';
                break;
              case "mapping":
                out = ' "' + e.params.tag + '"  oneOf ';
                break;
              default:
                out = ' "' + e.keyword + ' "';
            }
            break;
          case "enum":
            out = "";
            break;
          case "false schema":
            out = "";
            break;
          case "format":
            out = "" + e.params.format + "";
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += " " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += " " + cond;
            break;
          case "if":
            out = ' "' + e.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += " " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += " " + n + " ";
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += " " + n + " ";
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += " " + n + " ";
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += " " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += " " + n + " ";
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += " " + n + " ";
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += " " + n + " ";
            break;
          case "multipleOf":
            out = " " + e.params.multipleOf + " ";
            break;
          case "not":
            out = ' "not" schema';
            break;
          case "oneOf":
            out = ' "oneOf"  schema';
            break;
          case "pattern":
            out = ' "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = " " + e.params.missingPattern;
            break;
          case "propertyNames":
            out = " ";
            break;
          case "required":
            out = " " + e.params.missingProperty;
            break;
          case "type":
            out = " " + e.params.type + " ";
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "  " + n + " ";
            break;
          case "unevaluatedProperties":
            out = "";
            break;
          case "uniqueItems":
            out = " ( " + e.params.j + "  " + e.params.i + " )";
            break;
          default:
            out = ' "' + e.keyword + ' "';
        }
        e.message = out;
      }
    };
    var localize = {
      en: en$1,
      ar,
      ca,
      cs,
      de,
      es,
      fi,
      fr: fr$1,
      hu,
      id,
      it: it$1,
      ja,
      ko,
      nb,
      nl,
      pl,
      "pt-BR": ptBR,
      ru,
      sk,
      sv,
      th,
      zh,
      "zh-TW": zhTW
    };
    const ajvLocalizeModule = /* @__PURE__ */ getDefaultExportFromCjs(localize);
    var utils$1 = {};
    const Aacute = "";
    const aacute = "";
    const Abreve = "";
    const abreve = "";
    const ac = "";
    const acd = "";
    const acE = "";
    const Acirc = "";
    const acirc = "";
    const acute = "";
    const Acy = "";
    const acy = "";
    const AElig = "";
    const aelig = "";
    const af = "";
    const Afr = "";
    const afr = "";
    const Agrave = "";
    const agrave = "";
    const alefsym = "";
    const aleph = "";
    const Alpha = "";
    const alpha = "";
    const Amacr = "";
    const amacr = "";
    const amalg = "";
    const amp = "&";
    const AMP = "&";
    const andand = "";
    const And = "";
    const and = "";
    const andd = "";
    const andslope = "";
    const andv = "";
    const ang = "";
    const ange = "";
    const angle = "";
    const angmsdaa = "";
    const angmsdab = "";
    const angmsdac = "";
    const angmsdad = "";
    const angmsdae = "";
    const angmsdaf = "";
    const angmsdag = "";
    const angmsdah = "";
    const angmsd = "";
    const angrt = "";
    const angrtvb = "";
    const angrtvbd = "";
    const angsph = "";
    const angst = "";
    const angzarr = "";
    const Aogon = "";
    const aogon = "";
    const Aopf = "";
    const aopf = "";
    const apacir = "";
    const ap = "";
    const apE = "";
    const ape = "";
    const apid = "";
    const apos = "'";
    const ApplyFunction = "";
    const approx = "";
    const approxeq = "";
    const Aring = "";
    const aring = "";
    const Ascr = "";
    const ascr = "";
    const Assign = "";
    const ast = "*";
    const asymp = "";
    const asympeq = "";
    const Atilde = "";
    const atilde = "";
    const Auml = "";
    const auml = "";
    const awconint = "";
    const awint = "";
    const backcong = "";
    const backepsilon = "";
    const backprime = "";
    const backsim = "";
    const backsimeq = "";
    const Backslash = "";
    const Barv = "";
    const barvee = "";
    const barwed = "";
    const Barwed = "";
    const barwedge = "";
    const bbrk = "";
    const bbrktbrk = "";
    const bcong = "";
    const Bcy = "";
    const bcy = "";
    const bdquo = "";
    const becaus = "";
    const because = "";
    const Because = "";
    const bemptyv = "";
    const bepsi = "";
    const bernou = "";
    const Bernoullis = "";
    const Beta = "";
    const beta = "";
    const beth = "";
    const between = "";
    const Bfr = "";
    const bfr = "";
    const bigcap = "";
    const bigcirc = "";
    const bigcup = "";
    const bigodot = "";
    const bigoplus = "";
    const bigotimes = "";
    const bigsqcup = "";
    const bigstar = "";
    const bigtriangledown = "";
    const bigtriangleup = "";
    const biguplus = "";
    const bigvee = "";
    const bigwedge = "";
    const bkarow = "";
    const blacklozenge = "";
    const blacksquare = "";
    const blacktriangle = "";
    const blacktriangledown = "";
    const blacktriangleleft = "";
    const blacktriangleright = "";
    const blank = "";
    const blk12 = "";
    const blk14 = "";
    const blk34 = "";
    const block$1 = "";
    const bne = "=";
    const bnequiv = "";
    const bNot = "";
    const bnot = "";
    const Bopf = "";
    const bopf = "";
    const bot = "";
    const bottom = "";
    const bowtie = "";
    const boxbox = "";
    const boxdl = "";
    const boxdL = "";
    const boxDl = "";
    const boxDL = "";
    const boxdr = "";
    const boxdR = "";
    const boxDr = "";
    const boxDR = "";
    const boxh = "";
    const boxH = "";
    const boxhd = "";
    const boxHd = "";
    const boxhD = "";
    const boxHD = "";
    const boxhu = "";
    const boxHu = "";
    const boxhU = "";
    const boxHU = "";
    const boxminus = "";
    const boxplus = "";
    const boxtimes = "";
    const boxul = "";
    const boxuL = "";
    const boxUl = "";
    const boxUL = "";
    const boxur = "";
    const boxuR = "";
    const boxUr = "";
    const boxUR = "";
    const boxv = "";
    const boxV = "";
    const boxvh = "";
    const boxvH = "";
    const boxVh = "";
    const boxVH = "";
    const boxvl = "";
    const boxvL = "";
    const boxVl = "";
    const boxVL = "";
    const boxvr = "";
    const boxvR = "";
    const boxVr = "";
    const boxVR = "";
    const bprime = "";
    const breve = "";
    const Breve = "";
    const brvbar = "";
    const bscr = "";
    const Bscr = "";
    const bsemi = "";
    const bsim = "";
    const bsime = "";
    const bsolb = "";
    const bsol = "\\";
    const bsolhsub = "";
    const bull = "";
    const bullet = "";
    const bump = "";
    const bumpE = "";
    const bumpe = "";
    const Bumpeq = "";
    const bumpeq = "";
    const Cacute = "";
    const cacute = "";
    const capand = "";
    const capbrcup = "";
    const capcap = "";
    const cap = "";
    const Cap = "";
    const capcup = "";
    const capdot = "";
    const CapitalDifferentialD = "";
    const caps = "";
    const caret = "";
    const caron = "";
    const Cayleys = "";
    const ccaps = "";
    const Ccaron = "";
    const ccaron = "";
    const Ccedil = "";
    const ccedil = "";
    const Ccirc = "";
    const ccirc = "";
    const Cconint = "";
    const ccups = "";
    const ccupssm = "";
    const Cdot = "";
    const cdot = "";
    const cedil = "";
    const Cedilla = "";
    const cemptyv = "";
    const cent = "";
    const centerdot = "";
    const CenterDot = "";
    const cfr = "";
    const Cfr = "";
    const CHcy = "";
    const chcy = "";
    const check = "";
    const checkmark = "";
    const Chi = "";
    const chi = "";
    const circ = "";
    const circeq = "";
    const circlearrowleft = "";
    const circlearrowright = "";
    const circledast = "";
    const circledcirc = "";
    const circleddash = "";
    const CircleDot = "";
    const circledR = "";
    const circledS = "";
    const CircleMinus = "";
    const CirclePlus = "";
    const CircleTimes = "";
    const cir = "";
    const cirE = "";
    const cire = "";
    const cirfnint = "";
    const cirmid = "";
    const cirscir = "";
    const ClockwiseContourIntegral = "";
    const CloseCurlyDoubleQuote = "";
    const CloseCurlyQuote = "";
    const clubs = "";
    const clubsuit = "";
    const colon = ":";
    const Colon = "";
    const Colone = "";
    const colone = "";
    const coloneq = "";
    const comma = ",";
    const commat = "@";
    const comp = "";
    const compfn = "";
    const complement = "";
    const complexes = "";
    const cong = "";
    const congdot = "";
    const Congruent = "";
    const conint = "";
    const Conint = "";
    const ContourIntegral = "";
    const copf = "";
    const Copf = "";
    const coprod = "";
    const Coproduct = "";
    const copy = "";
    const COPY = "";
    const copysr = "";
    const CounterClockwiseContourIntegral = "";
    const crarr = "";
    const cross = "";
    const Cross = "";
    const Cscr = "";
    const cscr = "";
    const csub = "";
    const csube = "";
    const csup = "";
    const csupe = "";
    const ctdot = "";
    const cudarrl = "";
    const cudarrr = "";
    const cuepr = "";
    const cuesc = "";
    const cularr = "";
    const cularrp = "";
    const cupbrcap = "";
    const cupcap = "";
    const CupCap = "";
    const cup = "";
    const Cup = "";
    const cupcup = "";
    const cupdot = "";
    const cupor = "";
    const cups = "";
    const curarr = "";
    const curarrm = "";
    const curlyeqprec = "";
    const curlyeqsucc = "";
    const curlyvee = "";
    const curlywedge = "";
    const curren = "";
    const curvearrowleft = "";
    const curvearrowright = "";
    const cuvee = "";
    const cuwed = "";
    const cwconint = "";
    const cwint = "";
    const cylcty = "";
    const dagger = "";
    const Dagger = "";
    const daleth = "";
    const darr = "";
    const Darr = "";
    const dArr = "";
    const dash = "";
    const Dashv = "";
    const dashv = "";
    const dbkarow = "";
    const dblac = "";
    const Dcaron = "";
    const dcaron = "";
    const Dcy = "";
    const dcy = "";
    const ddagger = "";
    const ddarr = "";
    const DD = "";
    const dd = "";
    const DDotrahd = "";
    const ddotseq = "";
    const deg = "";
    const Del = "";
    const Delta = "";
    const delta = "";
    const demptyv = "";
    const dfisht = "";
    const Dfr = "";
    const dfr = "";
    const dHar = "";
    const dharl = "";
    const dharr = "";
    const DiacriticalAcute = "";
    const DiacriticalDot = "";
    const DiacriticalDoubleAcute = "";
    const DiacriticalGrave = "`";
    const DiacriticalTilde = "";
    const diam = "";
    const diamond = "";
    const Diamond = "";
    const diamondsuit = "";
    const diams = "";
    const die$1 = "";
    const DifferentialD = "";
    const digamma = "";
    const disin = "";
    const div = "";
    const divide = "";
    const divideontimes = "";
    const divonx = "";
    const DJcy = "";
    const djcy = "";
    const dlcorn = "";
    const dlcrop = "";
    const dollar = "$";
    const Dopf = "";
    const dopf = "";
    const Dot = "";
    const dot = "";
    const DotDot = "";
    const doteq = "";
    const doteqdot = "";
    const DotEqual = "";
    const dotminus = "";
    const dotplus = "";
    const dotsquare = "";
    const doublebarwedge = "";
    const DoubleContourIntegral = "";
    const DoubleDot = "";
    const DoubleDownArrow = "";
    const DoubleLeftArrow = "";
    const DoubleLeftRightArrow = "";
    const DoubleLeftTee = "";
    const DoubleLongLeftArrow = "";
    const DoubleLongLeftRightArrow = "";
    const DoubleLongRightArrow = "";
    const DoubleRightArrow = "";
    const DoubleRightTee = "";
    const DoubleUpArrow = "";
    const DoubleUpDownArrow = "";
    const DoubleVerticalBar = "";
    const DownArrowBar = "";
    const downarrow = "";
    const DownArrow = "";
    const Downarrow = "";
    const DownArrowUpArrow = "";
    const DownBreve = "";
    const downdownarrows = "";
    const downharpoonleft = "";
    const downharpoonright = "";
    const DownLeftRightVector = "";
    const DownLeftTeeVector = "";
    const DownLeftVectorBar = "";
    const DownLeftVector = "";
    const DownRightTeeVector = "";
    const DownRightVectorBar = "";
    const DownRightVector = "";
    const DownTeeArrow = "";
    const DownTee = "";
    const drbkarow = "";
    const drcorn = "";
    const drcrop = "";
    const Dscr = "";
    const dscr = "";
    const DScy = "";
    const dscy = "";
    const dsol = "";
    const Dstrok = "";
    const dstrok = "";
    const dtdot = "";
    const dtri = "";
    const dtrif = "";
    const duarr = "";
    const duhar = "";
    const dwangle = "";
    const DZcy = "";
    const dzcy = "";
    const dzigrarr = "";
    const Eacute = "";
    const eacute = "";
    const easter = "";
    const Ecaron = "";
    const ecaron = "";
    const Ecirc = "";
    const ecirc = "";
    const ecir = "";
    const ecolon = "";
    const Ecy = "";
    const ecy = "";
    const eDDot = "";
    const Edot = "";
    const edot = "";
    const eDot = "";
    const ee = "";
    const efDot = "";
    const Efr = "";
    const efr = "";
    const eg = "";
    const Egrave = "";
    const egrave = "";
    const egs = "";
    const egsdot = "";
    const el = "";
    const Element$1 = "";
    const elinters = "";
    const ell = "";
    const els = "";
    const elsdot = "";
    const Emacr = "";
    const emacr = "";
    const empty = "";
    const emptyset = "";
    const EmptySmallSquare = "";
    const emptyv = "";
    const EmptyVerySmallSquare = "";
    const emsp13 = "";
    const emsp14 = "";
    const emsp = "";
    const ENG = "";
    const eng = "";
    const ensp = "";
    const Eogon = "";
    const eogon = "";
    const Eopf = "";
    const eopf = "";
    const epar = "";
    const eparsl = "";
    const eplus = "";
    const epsi = "";
    const Epsilon = "";
    const epsilon = "";
    const epsiv = "";
    const eqcirc = "";
    const eqcolon = "";
    const eqsim = "";
    const eqslantgtr = "";
    const eqslantless = "";
    const Equal = "";
    const equals = "=";
    const EqualTilde = "";
    const equest = "";
    const Equilibrium = "";
    const equiv = "";
    const equivDD = "";
    const eqvparsl = "";
    const erarr = "";
    const erDot = "";
    const escr = "";
    const Escr = "";
    const esdot = "";
    const Esim = "";
    const esim = "";
    const Eta = "";
    const eta = "";
    const ETH = "";
    const eth = "";
    const Euml = "";
    const euml = "";
    const euro = "";
    const excl = "!";
    const exist = "";
    const Exists = "";
    const expectation = "";
    const exponentiale = "";
    const ExponentialE = "";
    const fallingdotseq = "";
    const Fcy = "";
    const fcy = "";
    const female = "";
    const ffilig = "";
    const fflig = "";
    const ffllig = "";
    const Ffr = "";
    const ffr = "";
    const filig = "";
    const FilledSmallSquare = "";
    const FilledVerySmallSquare = "";
    const fjlig = "fj";
    const flat = "";
    const fllig = "";
    const fltns = "";
    const fnof = "";
    const Fopf = "";
    const fopf = "";
    const forall = "";
    const ForAll = "";
    const fork = "";
    const forkv = "";
    const Fouriertrf = "";
    const fpartint = "";
    const frac12 = "";
    const frac13 = "";
    const frac14 = "";
    const frac15 = "";
    const frac16 = "";
    const frac18 = "";
    const frac23 = "";
    const frac25 = "";
    const frac34 = "";
    const frac35 = "";
    const frac38 = "";
    const frac45 = "";
    const frac56 = "";
    const frac58 = "";
    const frac78 = "";
    const frasl = "";
    const frown = "";
    const fscr = "";
    const Fscr = "";
    const gacute = "";
    const Gamma = "";
    const gamma = "";
    const Gammad = "";
    const gammad = "";
    const gap = "";
    const Gbreve = "";
    const gbreve = "";
    const Gcedil = "";
    const Gcirc = "";
    const gcirc = "";
    const Gcy = "";
    const gcy = "";
    const Gdot = "";
    const gdot = "";
    const ge = "";
    const gE = "";
    const gEl = "";
    const gel = "";
    const geq = "";
    const geqq = "";
    const geqslant = "";
    const gescc = "";
    const ges = "";
    const gesdot = "";
    const gesdoto = "";
    const gesdotol = "";
    const gesl = "";
    const gesles = "";
    const Gfr = "";
    const gfr = "";
    const gg = "";
    const Gg = "";
    const ggg = "";
    const gimel = "";
    const GJcy = "";
    const gjcy = "";
    const gla = "";
    const gl = "";
    const glE = "";
    const glj = "";
    const gnap = "";
    const gnapprox = "";
    const gne = "";
    const gnE = "";
    const gneq = "";
    const gneqq = "";
    const gnsim = "";
    const Gopf = "";
    const gopf = "";
    const grave = "`";
    const GreaterEqual = "";
    const GreaterEqualLess = "";
    const GreaterFullEqual = "";
    const GreaterGreater = "";
    const GreaterLess = "";
    const GreaterSlantEqual = "";
    const GreaterTilde = "";
    const Gscr = "";
    const gscr = "";
    const gsim = "";
    const gsime = "";
    const gsiml = "";
    const gtcc = "";
    const gtcir = "";
    const gt = ">";
    const GT = ">";
    const Gt = "";
    const gtdot = "";
    const gtlPar = "";
    const gtquest = "";
    const gtrapprox = "";
    const gtrarr = "";
    const gtrdot = "";
    const gtreqless = "";
    const gtreqqless = "";
    const gtrless = "";
    const gtrsim = "";
    const gvertneqq = "";
    const gvnE = "";
    const Hacek = "";
    const hairsp = "";
    const half = "";
    const hamilt = "";
    const HARDcy = "";
    const hardcy = "";
    const harrcir = "";
    const harr = "";
    const hArr = "";
    const harrw = "";
    const Hat = "^";
    const hbar = "";
    const Hcirc = "";
    const hcirc = "";
    const hearts = "";
    const heartsuit = "";
    const hellip = "";
    const hercon = "";
    const hfr = "";
    const Hfr = "";
    const HilbertSpace = "";
    const hksearow = "";
    const hkswarow = "";
    const hoarr = "";
    const homtht = "";
    const hookleftarrow = "";
    const hookrightarrow = "";
    const hopf = "";
    const Hopf = "";
    const horbar = "";
    const HorizontalLine = "";
    const hscr = "";
    const Hscr = "";
    const hslash = "";
    const Hstrok = "";
    const hstrok = "";
    const HumpDownHump = "";
    const HumpEqual = "";
    const hybull = "";
    const hyphen = "";
    const Iacute = "";
    const iacute = "";
    const ic = "";
    const Icirc = "";
    const icirc = "";
    const Icy = "";
    const icy = "";
    const Idot = "";
    const IEcy = "";
    const iecy = "";
    const iexcl = "";
    const iff = "";
    const ifr = "";
    const Ifr = "";
    const Igrave = "";
    const igrave = "";
    const ii = "";
    const iiiint = "";
    const iiint = "";
    const iinfin = "";
    const iiota = "";
    const IJlig = "";
    const ijlig = "";
    const Imacr = "";
    const imacr = "";
    const image$1 = "";
    const ImaginaryI = "";
    const imagline = "";
    const imagpart = "";
    const imath = "";
    const Im = "";
    const imof = "";
    const imped = "";
    const Implies = "";
    const incare = "";
    const infin = "";
    const infintie = "";
    const inodot = "";
    const intcal = "";
    const int = "";
    const Int = "";
    const integers = "";
    const Integral = "";
    const intercal = "";
    const Intersection = "";
    const intlarhk = "";
    const intprod = "";
    const InvisibleComma = "";
    const InvisibleTimes = "";
    const IOcy = "";
    const iocy = "";
    const Iogon = "";
    const iogon = "";
    const Iopf = "";
    const iopf = "";
    const Iota = "";
    const iota = "";
    const iprod = "";
    const iquest = "";
    const iscr = "";
    const Iscr = "";
    const isin = "";
    const isindot = "";
    const isinE = "";
    const isins = "";
    const isinsv = "";
    const isinv = "";
    const it = "";
    const Itilde = "";
    const itilde = "";
    const Iukcy = "";
    const iukcy = "";
    const Iuml = "";
    const iuml = "";
    const Jcirc = "";
    const jcirc = "";
    const Jcy = "";
    const jcy = "";
    const Jfr = "";
    const jfr = "";
    const jmath = "";
    const Jopf = "";
    const jopf = "";
    const Jscr = "";
    const jscr = "";
    const Jsercy = "";
    const jsercy = "";
    const Jukcy = "";
    const jukcy = "";
    const Kappa = "";
    const kappa = "";
    const kappav = "";
    const Kcedil = "";
    const kcedil = "";
    const Kcy = "";
    const kcy = "";
    const Kfr = "";
    const kfr = "";
    const kgreen = "";
    const KHcy = "";
    const khcy = "";
    const KJcy = "";
    const kjcy = "";
    const Kopf = "";
    const kopf = "";
    const Kscr = "";
    const kscr = "";
    const lAarr = "";
    const Lacute = "";
    const lacute = "";
    const laemptyv = "";
    const lagran = "";
    const Lambda = "";
    const lambda = "";
    const lang = "";
    const Lang = "";
    const langd = "";
    const langle = "";
    const lap = "";
    const Laplacetrf = "";
    const laquo = "";
    const larrb = "";
    const larrbfs = "";
    const larr = "";
    const Larr = "";
    const lArr = "";
    const larrfs = "";
    const larrhk = "";
    const larrlp = "";
    const larrpl = "";
    const larrsim = "";
    const larrtl = "";
    const latail = "";
    const lAtail = "";
    const lat = "";
    const late = "";
    const lates = "";
    const lbarr = "";
    const lBarr = "";
    const lbbrk = "";
    const lbrace = "{";
    const lbrack = "[";
    const lbrke = "";
    const lbrksld = "";
    const lbrkslu = "";
    const Lcaron = "";
    const lcaron = "";
    const Lcedil = "";
    const lcedil = "";
    const lceil = "";
    const lcub = "{";
    const Lcy = "";
    const lcy = "";
    const ldca = "";
    const ldquo = "";
    const ldquor = "";
    const ldrdhar = "";
    const ldrushar = "";
    const ldsh = "";
    const le = "";
    const lE = "";
    const LeftAngleBracket = "";
    const LeftArrowBar = "";
    const leftarrow = "";
    const LeftArrow = "";
    const Leftarrow = "";
    const LeftArrowRightArrow = "";
    const leftarrowtail = "";
    const LeftCeiling = "";
    const LeftDoubleBracket = "";
    const LeftDownTeeVector = "";
    const LeftDownVectorBar = "";
    const LeftDownVector = "";
    const LeftFloor = "";
    const leftharpoondown = "";
    const leftharpoonup = "";
    const leftleftarrows = "";
    const leftrightarrow = "";
    const LeftRightArrow = "";
    const Leftrightarrow = "";
    const leftrightarrows = "";
    const leftrightharpoons = "";
    const leftrightsquigarrow = "";
    const LeftRightVector = "";
    const LeftTeeArrow = "";
    const LeftTee = "";
    const LeftTeeVector = "";
    const leftthreetimes = "";
    const LeftTriangleBar = "";
    const LeftTriangle = "";
    const LeftTriangleEqual = "";
    const LeftUpDownVector = "";
    const LeftUpTeeVector = "";
    const LeftUpVectorBar = "";
    const LeftUpVector = "";
    const LeftVectorBar = "";
    const LeftVector = "";
    const lEg = "";
    const leg = "";
    const leq = "";
    const leqq = "";
    const leqslant = "";
    const lescc = "";
    const les = "";
    const lesdot = "";
    const lesdoto = "";
    const lesdotor = "";
    const lesg = "";
    const lesges = "";
    const lessapprox = "";
    const lessdot = "";
    const lesseqgtr = "";
    const lesseqqgtr = "";
    const LessEqualGreater = "";
    const LessFullEqual = "";
    const LessGreater = "";
    const lessgtr = "";
    const LessLess = "";
    const lesssim = "";
    const LessSlantEqual = "";
    const LessTilde = "";
    const lfisht = "";
    const lfloor = "";
    const Lfr = "";
    const lfr = "";
    const lg = "";
    const lgE = "";
    const lHar = "";
    const lhard = "";
    const lharu = "";
    const lharul = "";
    const lhblk = "";
    const LJcy = "";
    const ljcy = "";
    const llarr = "";
    const ll = "";
    const Ll = "";
    const llcorner = "";
    const Lleftarrow = "";
    const llhard = "";
    const lltri = "";
    const Lmidot = "";
    const lmidot = "";
    const lmoustache = "";
    const lmoust = "";
    const lnap = "";
    const lnapprox = "";
    const lne = "";
    const lnE = "";
    const lneq = "";
    const lneqq = "";
    const lnsim = "";
    const loang = "";
    const loarr = "";
    const lobrk = "";
    const longleftarrow = "";
    const LongLeftArrow = "";
    const Longleftarrow = "";
    const longleftrightarrow = "";
    const LongLeftRightArrow = "";
    const Longleftrightarrow = "";
    const longmapsto = "";
    const longrightarrow = "";
    const LongRightArrow = "";
    const Longrightarrow = "";
    const looparrowleft = "";
    const looparrowright = "";
    const lopar = "";
    const Lopf = "";
    const lopf = "";
    const loplus = "";
    const lotimes = "";
    const lowast = "";
    const lowbar = "_";
    const LowerLeftArrow = "";
    const LowerRightArrow = "";
    const loz = "";
    const lozenge = "";
    const lozf = "";
    const lpar = "(";
    const lparlt = "";
    const lrarr = "";
    const lrcorner = "";
    const lrhar = "";
    const lrhard = "";
    const lrm = "";
    const lrtri = "";
    const lsaquo = "";
    const lscr = "";
    const Lscr = "";
    const lsh = "";
    const Lsh = "";
    const lsim = "";
    const lsime = "";
    const lsimg = "";
    const lsqb = "[";
    const lsquo = "";
    const lsquor = "";
    const Lstrok = "";
    const lstrok = "";
    const ltcc = "";
    const ltcir = "";
    const lt = "<";
    const LT = "<";
    const Lt = "";
    const ltdot = "";
    const lthree = "";
    const ltimes = "";
    const ltlarr = "";
    const ltquest = "";
    const ltri = "";
    const ltrie = "";
    const ltrif = "";
    const ltrPar = "";
    const lurdshar = "";
    const luruhar = "";
    const lvertneqq = "";
    const lvnE = "";
    const macr = "";
    const male = "";
    const malt = "";
    const maltese = "";
    const map$1 = "";
    const mapsto = "";
    const mapstodown = "";
    const mapstoleft = "";
    const mapstoup = "";
    const marker = "";
    const mcomma = "";
    const Mcy = "";
    const mcy = "";
    const mdash = "";
    const mDDot = "";
    const measuredangle = "";
    const MediumSpace = "";
    const Mellintrf = "";
    const Mfr = "";
    const mfr = "";
    const mho = "";
    const micro = "";
    const midast = "*";
    const midcir = "";
    const mid = "";
    const middot = "";
    const minusb = "";
    const minus = "";
    const minusd = "";
    const minusdu = "";
    const MinusPlus = "";
    const mlcp = "";
    const mldr = "";
    const mnplus = "";
    const models = "";
    const Mopf = "";
    const mopf = "";
    const mp = "";
    const mscr = "";
    const Mscr = "";
    const mstpos = "";
    const Mu = "";
    const mu = "";
    const multimap = "";
    const mumap = "";
    const nabla = "";
    const Nacute = "";
    const nacute = "";
    const nang = "";
    const nap = "";
    const napE = "";
    const napid = "";
    const napos = "";
    const napprox = "";
    const natural = "";
    const naturals = "";
    const natur = "";
    const nbsp = "";
    const nbump = "";
    const nbumpe = "";
    const ncap = "";
    const Ncaron = "";
    const ncaron = "";
    const Ncedil = "";
    const ncedil = "";
    const ncong = "";
    const ncongdot = "";
    const ncup = "";
    const Ncy = "";
    const ncy = "";
    const ndash = "";
    const nearhk = "";
    const nearr = "";
    const neArr = "";
    const nearrow = "";
    const ne = "";
    const nedot = "";
    const NegativeMediumSpace = "";
    const NegativeThickSpace = "";
    const NegativeThinSpace = "";
    const NegativeVeryThinSpace = "";
    const nequiv = "";
    const nesear = "";
    const nesim = "";
    const NestedGreaterGreater = "";
    const NestedLessLess = "";
    const NewLine = "\n";
    const nexist = "";
    const nexists = "";
    const Nfr = "";
    const nfr = "";
    const ngE = "";
    const nge = "";
    const ngeq = "";
    const ngeqq = "";
    const ngeqslant = "";
    const nges = "";
    const nGg = "";
    const ngsim = "";
    const nGt = "";
    const ngt = "";
    const ngtr = "";
    const nGtv = "";
    const nharr = "";
    const nhArr = "";
    const nhpar = "";
    const ni = "";
    const nis = "";
    const nisd = "";
    const niv = "";
    const NJcy = "";
    const njcy = "";
    const nlarr = "";
    const nlArr = "";
    const nldr = "";
    const nlE = "";
    const nle = "";
    const nleftarrow = "";
    const nLeftarrow = "";
    const nleftrightarrow = "";
    const nLeftrightarrow = "";
    const nleq = "";
    const nleqq = "";
    const nleqslant = "";
    const nles = "";
    const nless = "";
    const nLl = "";
    const nlsim = "";
    const nLt = "";
    const nlt = "";
    const nltri = "";
    const nltrie = "";
    const nLtv = "";
    const nmid = "";
    const NoBreak = "";
    const NonBreakingSpace = "";
    const nopf = "";
    const Nopf = "";
    const Not = "";
    const not = "";
    const NotCongruent = "";
    const NotCupCap = "";
    const NotDoubleVerticalBar = "";
    const NotElement = "";
    const NotEqual = "";
    const NotEqualTilde = "";
    const NotExists = "";
    const NotGreater = "";
    const NotGreaterEqual = "";
    const NotGreaterFullEqual = "";
    const NotGreaterGreater = "";
    const NotGreaterLess = "";
    const NotGreaterSlantEqual = "";
    const NotGreaterTilde = "";
    const NotHumpDownHump = "";
    const NotHumpEqual = "";
    const notin = "";
    const notindot = "";
    const notinE = "";
    const notinva = "";
    const notinvb = "";
    const notinvc = "";
    const NotLeftTriangleBar = "";
    const NotLeftTriangle = "";
    const NotLeftTriangleEqual = "";
    const NotLess = "";
    const NotLessEqual = "";
    const NotLessGreater = "";
    const NotLessLess = "";
    const NotLessSlantEqual = "";
    const NotLessTilde = "";
    const NotNestedGreaterGreater = "";
    const NotNestedLessLess = "";
    const notni = "";
    const notniva = "";
    const notnivb = "";
    const notnivc = "";
    const NotPrecedes = "";
    const NotPrecedesEqual = "";
    const NotPrecedesSlantEqual = "";
    const NotReverseElement = "";
    const NotRightTriangleBar = "";
    const NotRightTriangle = "";
    const NotRightTriangleEqual = "";
    const NotSquareSubset = "";
    const NotSquareSubsetEqual = "";
    const NotSquareSuperset = "";
    const NotSquareSupersetEqual = "";
    const NotSubset = "";
    const NotSubsetEqual = "";
    const NotSucceeds = "";
    const NotSucceedsEqual = "";
    const NotSucceedsSlantEqual = "";
    const NotSucceedsTilde = "";
    const NotSuperset = "";
    const NotSupersetEqual = "";
    const NotTilde = "";
    const NotTildeEqual = "";
    const NotTildeFullEqual = "";
    const NotTildeTilde = "";
    const NotVerticalBar = "";
    const nparallel = "";
    const npar = "";
    const nparsl = "";
    const npart = "";
    const npolint = "";
    const npr = "";
    const nprcue = "";
    const nprec = "";
    const npreceq = "";
    const npre = "";
    const nrarrc = "";
    const nrarr = "";
    const nrArr = "";
    const nrarrw = "";
    const nrightarrow = "";
    const nRightarrow = "";
    const nrtri = "";
    const nrtrie = "";
    const nsc = "";
    const nsccue = "";
    const nsce = "";
    const Nscr = "";
    const nscr = "";
    const nshortmid = "";
    const nshortparallel = "";
    const nsim = "";
    const nsime = "";
    const nsimeq = "";
    const nsmid = "";
    const nspar = "";
    const nsqsube = "";
    const nsqsupe = "";
    const nsub = "";
    const nsubE = "";
    const nsube = "";
    const nsubset = "";
    const nsubseteq = "";
    const nsubseteqq = "";
    const nsucc = "";
    const nsucceq = "";
    const nsup = "";
    const nsupE = "";
    const nsupe = "";
    const nsupset = "";
    const nsupseteq = "";
    const nsupseteqq = "";
    const ntgl = "";
    const Ntilde = "";
    const ntilde = "";
    const ntlg = "";
    const ntriangleleft = "";
    const ntrianglelefteq = "";
    const ntriangleright = "";
    const ntrianglerighteq = "";
    const Nu = "";
    const nu = "";
    const num = "#";
    const numero = "";
    const numsp = "";
    const nvap = "";
    const nvdash = "";
    const nvDash = "";
    const nVdash = "";
    const nVDash = "";
    const nvge = "";
    const nvgt = ">";
    const nvHarr = "";
    const nvinfin = "";
    const nvlArr = "";
    const nvle = "";
    const nvlt = "<";
    const nvltrie = "";
    const nvrArr = "";
    const nvrtrie = "";
    const nvsim = "";
    const nwarhk = "";
    const nwarr = "";
    const nwArr = "";
    const nwarrow = "";
    const nwnear = "";
    const Oacute = "";
    const oacute = "";
    const oast = "";
    const Ocirc = "";
    const ocirc = "";
    const ocir = "";
    const Ocy = "";
    const ocy = "";
    const odash = "";
    const Odblac = "";
    const odblac = "";
    const odiv = "";
    const odot = "";
    const odsold = "";
    const OElig = "";
    const oelig = "";
    const ofcir = "";
    const Ofr = "";
    const ofr = "";
    const ogon = "";
    const Ograve = "";
    const ograve = "";
    const ogt = "";
    const ohbar = "";
    const ohm = "";
    const oint = "";
    const olarr = "";
    const olcir = "";
    const olcross = "";
    const oline = "";
    const olt = "";
    const Omacr = "";
    const omacr = "";
    const Omega = "";
    const omega = "";
    const Omicron = "";
    const omicron = "";
    const omid = "";
    const ominus = "";
    const Oopf = "";
    const oopf = "";
    const opar = "";
    const OpenCurlyDoubleQuote = "";
    const OpenCurlyQuote = "";
    const operp = "";
    const oplus = "";
    const orarr = "";
    const Or = "";
    const or = "";
    const ord = "";
    const order = "";
    const orderof = "";
    const ordf = "";
    const ordm = "";
    const origof = "";
    const oror = "";
    const orslope = "";
    const orv = "";
    const oS = "";
    const Oscr = "";
    const oscr = "";
    const Oslash = "";
    const oslash = "";
    const osol = "";
    const Otilde = "";
    const otilde = "";
    const otimesas = "";
    const Otimes = "";
    const otimes = "";
    const Ouml = "";
    const ouml = "";
    const ovbar = "";
    const OverBar = "";
    const OverBrace = "";
    const OverBracket = "";
    const OverParenthesis = "";
    const para = "";
    const parallel = "";
    const par = "";
    const parsim = "";
    const parsl = "";
    const part = "";
    const PartialD = "";
    const Pcy = "";
    const pcy = "";
    const percnt = "%";
    const period = ".";
    const permil = "";
    const perp = "";
    const pertenk = "";
    const Pfr = "";
    const pfr = "";
    const Phi = "";
    const phi = "";
    const phiv = "";
    const phmmat = "";
    const phone = "";
    const Pi = "";
    const pi = "";
    const pitchfork = "";
    const piv = "";
    const planck = "";
    const planckh = "";
    const plankv = "";
    const plusacir = "";
    const plusb = "";
    const pluscir = "";
    const plus = "+";
    const plusdo = "";
    const plusdu = "";
    const pluse = "";
    const PlusMinus = "";
    const plusmn = "";
    const plussim = "";
    const plustwo = "";
    const pm = "";
    const Poincareplane = "";
    const pointint = "";
    const popf = "";
    const Popf = "";
    const pound = "";
    const prap = "";
    const Pr = "";
    const pr = "";
    const prcue = "";
    const precapprox = "";
    const prec = "";
    const preccurlyeq = "";
    const Precedes = "";
    const PrecedesEqual = "";
    const PrecedesSlantEqual = "";
    const PrecedesTilde = "";
    const preceq = "";
    const precnapprox = "";
    const precneqq = "";
    const precnsim = "";
    const pre = "";
    const prE = "";
    const precsim = "";
    const prime = "";
    const Prime = "";
    const primes = "";
    const prnap = "";
    const prnE = "";
    const prnsim = "";
    const prod = "";
    const Product = "";
    const profalar = "";
    const profline = "";
    const profsurf = "";
    const prop = "";
    const Proportional = "";
    const Proportion = "";
    const propto = "";
    const prsim = "";
    const prurel = "";
    const Pscr = "";
    const pscr = "";
    const Psi = "";
    const psi = "";
    const puncsp = "";
    const Qfr = "";
    const qfr = "";
    const qint = "";
    const qopf = "";
    const Qopf = "";
    const qprime = "";
    const Qscr = "";
    const qscr = "";
    const quaternions = "";
    const quatint = "";
    const quest = "?";
    const questeq = "";
    const quot = '"';
    const QUOT = '"';
    const rAarr = "";
    const race = "";
    const Racute = "";
    const racute = "";
    const radic = "";
    const raemptyv = "";
    const rang = "";
    const Rang = "";
    const rangd = "";
    const range = "";
    const rangle = "";
    const raquo = "";
    const rarrap = "";
    const rarrb = "";
    const rarrbfs = "";
    const rarrc = "";
    const rarr = "";
    const Rarr = "";
    const rArr = "";
    const rarrfs = "";
    const rarrhk = "";
    const rarrlp = "";
    const rarrpl = "";
    const rarrsim = "";
    const Rarrtl = "";
    const rarrtl = "";
    const rarrw = "";
    const ratail = "";
    const rAtail = "";
    const ratio = "";
    const rationals = "";
    const rbarr = "";
    const rBarr = "";
    const RBarr = "";
    const rbbrk = "";
    const rbrace = "}";
    const rbrack = "]";
    const rbrke = "";
    const rbrksld = "";
    const rbrkslu = "";
    const Rcaron = "";
    const rcaron = "";
    const Rcedil = "";
    const rcedil = "";
    const rceil = "";
    const rcub = "}";
    const Rcy = "";
    const rcy = "";
    const rdca = "";
    const rdldhar = "";
    const rdquo = "";
    const rdquor = "";
    const rdsh = "";
    const real = "";
    const realine = "";
    const realpart = "";
    const reals = "";
    const Re = "";
    const rect = "";
    const reg = "";
    const REG = "";
    const ReverseElement = "";
    const ReverseEquilibrium = "";
    const ReverseUpEquilibrium = "";
    const rfisht = "";
    const rfloor = "";
    const rfr = "";
    const Rfr = "";
    const rHar = "";
    const rhard = "";
    const rharu = "";
    const rharul = "";
    const Rho = "";
    const rho = "";
    const rhov = "";
    const RightAngleBracket = "";
    const RightArrowBar = "";
    const rightarrow = "";
    const RightArrow = "";
    const Rightarrow = "";
    const RightArrowLeftArrow = "";
    const rightarrowtail = "";
    const RightCeiling = "";
    const RightDoubleBracket = "";
    const RightDownTeeVector = "";
    const RightDownVectorBar = "";
    const RightDownVector = "";
    const RightFloor = "";
    const rightharpoondown = "";
    const rightharpoonup = "";
    const rightleftarrows = "";
    const rightleftharpoons = "";
    const rightrightarrows = "";
    const rightsquigarrow = "";
    const RightTeeArrow = "";
    const RightTee = "";
    const RightTeeVector = "";
    const rightthreetimes = "";
    const RightTriangleBar = "";
    const RightTriangle = "";
    const RightTriangleEqual = "";
    const RightUpDownVector = "";
    const RightUpTeeVector = "";
    const RightUpVectorBar = "";
    const RightUpVector = "";
    const RightVectorBar = "";
    const RightVector = "";
    const ring = "";
    const risingdotseq = "";
    const rlarr = "";
    const rlhar = "";
    const rlm = "";
    const rmoustache = "";
    const rmoust = "";
    const rnmid = "";
    const roang = "";
    const roarr = "";
    const robrk = "";
    const ropar = "";
    const ropf = "";
    const Ropf = "";
    const roplus = "";
    const rotimes = "";
    const RoundImplies = "";
    const rpar = ")";
    const rpargt = "";
    const rppolint = "";
    const rrarr = "";
    const Rrightarrow = "";
    const rsaquo = "";
    const rscr = "";
    const Rscr = "";
    const rsh = "";
    const Rsh = "";
    const rsqb = "]";
    const rsquo = "";
    const rsquor = "";
    const rthree = "";
    const rtimes = "";
    const rtri = "";
    const rtrie = "";
    const rtrif = "";
    const rtriltri = "";
    const RuleDelayed = "";
    const ruluhar = "";
    const rx = "";
    const Sacute = "";
    const sacute = "";
    const sbquo = "";
    const scap = "";
    const Scaron = "";
    const scaron = "";
    const Sc = "";
    const sc = "";
    const sccue = "";
    const sce = "";
    const scE = "";
    const Scedil = "";
    const scedil = "";
    const Scirc = "";
    const scirc = "";
    const scnap = "";
    const scnE = "";
    const scnsim = "";
    const scpolint = "";
    const scsim = "";
    const Scy = "";
    const scy = "";
    const sdotb = "";
    const sdot = "";
    const sdote = "";
    const searhk = "";
    const searr = "";
    const seArr = "";
    const searrow = "";
    const sect = "";
    const semi = ";";
    const seswar = "";
    const setminus = "";
    const setmn = "";
    const sext = "";
    const Sfr = "";
    const sfr = "";
    const sfrown = "";
    const sharp = "";
    const SHCHcy = "";
    const shchcy = "";
    const SHcy = "";
    const shcy = "";
    const ShortDownArrow = "";
    const ShortLeftArrow = "";
    const shortmid = "";
    const shortparallel = "";
    const ShortRightArrow = "";
    const ShortUpArrow = "";
    const shy = "";
    const Sigma = "";
    const sigma = "";
    const sigmaf = "";
    const sigmav = "";
    const sim = "";
    const simdot = "";
    const sime = "";
    const simeq = "";
    const simg = "";
    const simgE = "";
    const siml = "";
    const simlE = "";
    const simne = "";
    const simplus = "";
    const simrarr = "";
    const slarr = "";
    const SmallCircle = "";
    const smallsetminus = "";
    const smashp = "";
    const smeparsl = "";
    const smid = "";
    const smile = "";
    const smt = "";
    const smte = "";
    const smtes = "";
    const SOFTcy = "";
    const softcy = "";
    const solbar = "";
    const solb = "";
    const sol = "/";
    const Sopf = "";
    const sopf = "";
    const spades = "";
    const spadesuit = "";
    const spar = "";
    const sqcap = "";
    const sqcaps = "";
    const sqcup = "";
    const sqcups = "";
    const Sqrt = "";
    const sqsub = "";
    const sqsube = "";
    const sqsubset = "";
    const sqsubseteq = "";
    const sqsup = "";
    const sqsupe = "";
    const sqsupset = "";
    const sqsupseteq = "";
    const square = "";
    const Square = "";
    const SquareIntersection = "";
    const SquareSubset = "";
    const SquareSubsetEqual = "";
    const SquareSuperset = "";
    const SquareSupersetEqual = "";
    const SquareUnion = "";
    const squarf = "";
    const squ = "";
    const squf = "";
    const srarr = "";
    const Sscr = "";
    const sscr = "";
    const ssetmn = "";
    const ssmile = "";
    const sstarf = "";
    const Star = "";
    const star = "";
    const starf = "";
    const straightepsilon = "";
    const straightphi = "";
    const strns = "";
    const sub = "";
    const Sub = "";
    const subdot = "";
    const subE = "";
    const sube = "";
    const subedot = "";
    const submult = "";
    const subnE = "";
    const subne = "";
    const subplus = "";
    const subrarr = "";
    const subset = "";
    const Subset = "";
    const subseteq = "";
    const subseteqq = "";
    const SubsetEqual = "";
    const subsetneq = "";
    const subsetneqq = "";
    const subsim = "";
    const subsub = "";
    const subsup = "";
    const succapprox = "";
    const succ = "";
    const succcurlyeq = "";
    const Succeeds = "";
    const SucceedsEqual = "";
    const SucceedsSlantEqual = "";
    const SucceedsTilde = "";
    const succeq = "";
    const succnapprox = "";
    const succneqq = "";
    const succnsim = "";
    const succsim = "";
    const SuchThat = "";
    const sum = "";
    const Sum = "";
    const sung = "";
    const sup1 = "";
    const sup2 = "";
    const sup3 = "";
    const sup = "";
    const Sup = "";
    const supdot = "";
    const supdsub = "";
    const supE = "";
    const supe = "";
    const supedot = "";
    const Superset = "";
    const SupersetEqual = "";
    const suphsol = "";
    const suphsub = "";
    const suplarr = "";
    const supmult = "";
    const supnE = "";
    const supne = "";
    const supplus = "";
    const supset = "";
    const Supset = "";
    const supseteq = "";
    const supseteqq = "";
    const supsetneq = "";
    const supsetneqq = "";
    const supsim = "";
    const supsub = "";
    const supsup = "";
    const swarhk = "";
    const swarr = "";
    const swArr = "";
    const swarrow = "";
    const swnwar = "";
    const szlig = "";
    const Tab = "	";
    const target = "";
    const Tau = "";
    const tau = "";
    const tbrk = "";
    const Tcaron = "";
    const tcaron = "";
    const Tcedil = "";
    const tcedil = "";
    const Tcy = "";
    const tcy = "";
    const tdot = "";
    const telrec = "";
    const Tfr = "";
    const tfr = "";
    const there4 = "";
    const therefore = "";
    const Therefore = "";
    const Theta = "";
    const theta = "";
    const thetasym = "";
    const thetav = "";
    const thickapprox = "";
    const thicksim = "";
    const ThickSpace = "";
    const ThinSpace = "";
    const thinsp = "";
    const thkap = "";
    const thksim = "";
    const THORN = "";
    const thorn = "";
    const tilde = "";
    const Tilde = "";
    const TildeEqual = "";
    const TildeFullEqual = "";
    const TildeTilde = "";
    const timesbar = "";
    const timesb = "";
    const times = "";
    const timesd = "";
    const tint = "";
    const toea = "";
    const topbot = "";
    const topcir = "";
    const top = "";
    const Topf = "";
    const topf = "";
    const topfork = "";
    const tosa = "";
    const tprime = "";
    const trade = "";
    const TRADE = "";
    const triangle = "";
    const triangledown = "";
    const triangleleft = "";
    const trianglelefteq = "";
    const triangleq = "";
    const triangleright = "";
    const trianglerighteq = "";
    const tridot = "";
    const trie = "";
    const triminus = "";
    const TripleDot = "";
    const triplus = "";
    const trisb = "";
    const tritime = "";
    const trpezium = "";
    const Tscr = "";
    const tscr = "";
    const TScy = "";
    const tscy = "";
    const TSHcy = "";
    const tshcy = "";
    const Tstrok = "";
    const tstrok = "";
    const twixt = "";
    const twoheadleftarrow = "";
    const twoheadrightarrow = "";
    const Uacute = "";
    const uacute = "";
    const uarr = "";
    const Uarr = "";
    const uArr = "";
    const Uarrocir = "";
    const Ubrcy = "";
    const ubrcy = "";
    const Ubreve = "";
    const ubreve = "";
    const Ucirc = "";
    const ucirc = "";
    const Ucy = "";
    const ucy = "";
    const udarr = "";
    const Udblac = "";
    const udblac = "";
    const udhar = "";
    const ufisht = "";
    const Ufr = "";
    const ufr = "";
    const Ugrave = "";
    const ugrave = "";
    const uHar = "";
    const uharl = "";
    const uharr = "";
    const uhblk = "";
    const ulcorn = "";
    const ulcorner = "";
    const ulcrop = "";
    const ultri = "";
    const Umacr = "";
    const umacr = "";
    const uml = "";
    const UnderBar = "_";
    const UnderBrace = "";
    const UnderBracket = "";
    const UnderParenthesis = "";
    const Union = "";
    const UnionPlus = "";
    const Uogon = "";
    const uogon = "";
    const Uopf = "";
    const uopf = "";
    const UpArrowBar = "";
    const uparrow = "";
    const UpArrow = "";
    const Uparrow = "";
    const UpArrowDownArrow = "";
    const updownarrow = "";
    const UpDownArrow = "";
    const Updownarrow = "";
    const UpEquilibrium = "";
    const upharpoonleft = "";
    const upharpoonright = "";
    const uplus = "";
    const UpperLeftArrow = "";
    const UpperRightArrow = "";
    const upsi = "";
    const Upsi = "";
    const upsih = "";
    const Upsilon = "";
    const upsilon = "";
    const UpTeeArrow = "";
    const UpTee = "";
    const upuparrows = "";
    const urcorn = "";
    const urcorner = "";
    const urcrop = "";
    const Uring = "";
    const uring = "";
    const urtri = "";
    const Uscr = "";
    const uscr = "";
    const utdot = "";
    const Utilde = "";
    const utilde = "";
    const utri = "";
    const utrif = "";
    const uuarr = "";
    const Uuml = "";
    const uuml = "";
    const uwangle = "";
    const vangrt = "";
    const varepsilon = "";
    const varkappa = "";
    const varnothing = "";
    const varphi = "";
    const varpi = "";
    const varpropto = "";
    const varr = "";
    const vArr = "";
    const varrho = "";
    const varsigma = "";
    const varsubsetneq = "";
    const varsubsetneqq = "";
    const varsupsetneq = "";
    const varsupsetneqq = "";
    const vartheta = "";
    const vartriangleleft = "";
    const vartriangleright = "";
    const vBar = "";
    const Vbar = "";
    const vBarv = "";
    const Vcy = "";
    const vcy = "";
    const vdash = "";
    const vDash = "";
    const Vdash = "";
    const VDash = "";
    const Vdashl = "";
    const veebar = "";
    const vee = "";
    const Vee = "";
    const veeeq = "";
    const vellip = "";
    const verbar = "|";
    const Verbar = "";
    const vert = "|";
    const Vert = "";
    const VerticalBar = "";
    const VerticalLine = "|";
    const VerticalSeparator = "";
    const VerticalTilde = "";
    const VeryThinSpace = "";
    const Vfr = "";
    const vfr = "";
    const vltri = "";
    const vnsub = "";
    const vnsup = "";
    const Vopf = "";
    const vopf = "";
    const vprop = "";
    const vrtri = "";
    const Vscr = "";
    const vscr = "";
    const vsubnE = "";
    const vsubne = "";
    const vsupnE = "";
    const vsupne = "";
    const Vvdash = "";
    const vzigzag = "";
    const Wcirc = "";
    const wcirc = "";
    const wedbar = "";
    const wedge = "";
    const Wedge = "";
    const wedgeq = "";
    const weierp = "";
    const Wfr = "";
    const wfr = "";
    const Wopf = "";
    const wopf = "";
    const wp = "";
    const wr = "";
    const wreath = "";
    const Wscr = "";
    const wscr = "";
    const xcap = "";
    const xcirc = "";
    const xcup = "";
    const xdtri = "";
    const Xfr = "";
    const xfr = "";
    const xharr = "";
    const xhArr = "";
    const Xi = "";
    const xi = "";
    const xlarr = "";
    const xlArr = "";
    const xmap = "";
    const xnis = "";
    const xodot = "";
    const Xopf = "";
    const xopf = "";
    const xoplus = "";
    const xotime = "";
    const xrarr = "";
    const xrArr = "";
    const Xscr = "";
    const xscr = "";
    const xsqcup = "";
    const xuplus = "";
    const xutri = "";
    const xvee = "";
    const xwedge = "";
    const Yacute = "";
    const yacute = "";
    const YAcy = "";
    const yacy = "";
    const Ycirc = "";
    const ycirc = "";
    const Ycy = "";
    const ycy = "";
    const yen = "";
    const Yfr = "";
    const yfr = "";
    const YIcy = "";
    const yicy = "";
    const Yopf = "";
    const yopf = "";
    const Yscr = "";
    const yscr = "";
    const YUcy = "";
    const yucy = "";
    const yuml = "";
    const Yuml = "";
    const Zacute = "";
    const zacute = "";
    const Zcaron = "";
    const zcaron = "";
    const Zcy = "";
    const zcy = "";
    const Zdot = "";
    const zdot = "";
    const zeetrf = "";
    const ZeroWidthSpace = "";
    const Zeta = "";
    const zeta = "";
    const zfr = "";
    const Zfr = "";
    const ZHcy = "";
    const zhcy = "";
    const zigrarr = "";
    const zopf = "";
    const Zopf = "";
    const Zscr = "";
    const zscr = "";
    const zwj = "";
    const zwnj = "";
    const require$$0 = {
      Aacute,
      aacute,
      Abreve,
      abreve,
      ac,
      acd,
      acE,
      Acirc,
      acirc,
      acute,
      Acy,
      acy,
      AElig,
      aelig,
      af,
      Afr,
      afr,
      Agrave,
      agrave,
      alefsym,
      aleph,
      Alpha,
      alpha,
      Amacr,
      amacr,
      amalg,
      amp,
      AMP,
      andand,
      And,
      and,
      andd,
      andslope,
      andv,
      ang,
      ange,
      angle,
      angmsdaa,
      angmsdab,
      angmsdac,
      angmsdad,
      angmsdae,
      angmsdaf,
      angmsdag,
      angmsdah,
      angmsd,
      angrt,
      angrtvb,
      angrtvbd,
      angsph,
      angst,
      angzarr,
      Aogon,
      aogon,
      Aopf,
      aopf,
      apacir,
      ap,
      apE,
      ape,
      apid,
      apos,
      ApplyFunction,
      approx,
      approxeq,
      Aring,
      aring,
      Ascr,
      ascr,
      Assign,
      ast,
      asymp,
      asympeq,
      Atilde,
      atilde,
      Auml,
      auml,
      awconint,
      awint,
      backcong,
      backepsilon,
      backprime,
      backsim,
      backsimeq,
      Backslash,
      Barv,
      barvee,
      barwed,
      Barwed,
      barwedge,
      bbrk,
      bbrktbrk,
      bcong,
      Bcy,
      bcy,
      bdquo,
      becaus,
      because,
      Because,
      bemptyv,
      bepsi,
      bernou,
      Bernoullis,
      Beta,
      beta,
      beth,
      between,
      Bfr,
      bfr,
      bigcap,
      bigcirc,
      bigcup,
      bigodot,
      bigoplus,
      bigotimes,
      bigsqcup,
      bigstar,
      bigtriangledown,
      bigtriangleup,
      biguplus,
      bigvee,
      bigwedge,
      bkarow,
      blacklozenge,
      blacksquare,
      blacktriangle,
      blacktriangledown,
      blacktriangleleft,
      blacktriangleright,
      blank,
      blk12,
      blk14,
      blk34,
      block: block$1,
      bne,
      bnequiv,
      bNot,
      bnot,
      Bopf,
      bopf,
      bot,
      bottom,
      bowtie,
      boxbox,
      boxdl,
      boxdL,
      boxDl,
      boxDL,
      boxdr,
      boxdR,
      boxDr,
      boxDR,
      boxh,
      boxH,
      boxhd,
      boxHd,
      boxhD,
      boxHD,
      boxhu,
      boxHu,
      boxhU,
      boxHU,
      boxminus,
      boxplus,
      boxtimes,
      boxul,
      boxuL,
      boxUl,
      boxUL,
      boxur,
      boxuR,
      boxUr,
      boxUR,
      boxv,
      boxV,
      boxvh,
      boxvH,
      boxVh,
      boxVH,
      boxvl,
      boxvL,
      boxVl,
      boxVL,
      boxvr,
      boxvR,
      boxVr,
      boxVR,
      bprime,
      breve,
      Breve,
      brvbar,
      bscr,
      Bscr,
      bsemi,
      bsim,
      bsime,
      bsolb,
      bsol,
      bsolhsub,
      bull,
      bullet,
      bump,
      bumpE,
      bumpe,
      Bumpeq,
      bumpeq,
      Cacute,
      cacute,
      capand,
      capbrcup,
      capcap,
      cap,
      Cap,
      capcup,
      capdot,
      CapitalDifferentialD,
      caps,
      caret,
      caron,
      Cayleys,
      ccaps,
      Ccaron,
      ccaron,
      Ccedil,
      ccedil,
      Ccirc,
      ccirc,
      Cconint,
      ccups,
      ccupssm,
      Cdot,
      cdot,
      cedil,
      Cedilla,
      cemptyv,
      cent,
      centerdot,
      CenterDot,
      cfr,
      Cfr,
      CHcy,
      chcy,
      check,
      checkmark,
      Chi,
      chi,
      circ,
      circeq,
      circlearrowleft,
      circlearrowright,
      circledast,
      circledcirc,
      circleddash,
      CircleDot,
      circledR,
      circledS,
      CircleMinus,
      CirclePlus,
      CircleTimes,
      cir,
      cirE,
      cire,
      cirfnint,
      cirmid,
      cirscir,
      ClockwiseContourIntegral,
      CloseCurlyDoubleQuote,
      CloseCurlyQuote,
      clubs,
      clubsuit,
      colon,
      Colon,
      Colone,
      colone,
      coloneq,
      comma,
      commat,
      comp,
      compfn,
      complement,
      complexes,
      cong,
      congdot,
      Congruent,
      conint,
      Conint,
      ContourIntegral,
      copf,
      Copf,
      coprod,
      Coproduct,
      copy,
      COPY,
      copysr,
      CounterClockwiseContourIntegral,
      crarr,
      cross,
      Cross,
      Cscr,
      cscr,
      csub,
      csube,
      csup,
      csupe,
      ctdot,
      cudarrl,
      cudarrr,
      cuepr,
      cuesc,
      cularr,
      cularrp,
      cupbrcap,
      cupcap,
      CupCap,
      cup,
      Cup,
      cupcup,
      cupdot,
      cupor,
      cups,
      curarr,
      curarrm,
      curlyeqprec,
      curlyeqsucc,
      curlyvee,
      curlywedge,
      curren,
      curvearrowleft,
      curvearrowright,
      cuvee,
      cuwed,
      cwconint,
      cwint,
      cylcty,
      dagger,
      Dagger,
      daleth,
      darr,
      Darr,
      dArr,
      dash,
      Dashv,
      dashv,
      dbkarow,
      dblac,
      Dcaron,
      dcaron,
      Dcy,
      dcy,
      ddagger,
      ddarr,
      DD,
      dd,
      DDotrahd,
      ddotseq,
      deg,
      Del,
      Delta,
      delta,
      demptyv,
      dfisht,
      Dfr,
      dfr,
      dHar,
      dharl,
      dharr,
      DiacriticalAcute,
      DiacriticalDot,
      DiacriticalDoubleAcute,
      DiacriticalGrave,
      DiacriticalTilde,
      diam,
      diamond,
      Diamond,
      diamondsuit,
      diams,
      die: die$1,
      DifferentialD,
      digamma,
      disin,
      div,
      divide,
      divideontimes,
      divonx,
      DJcy,
      djcy,
      dlcorn,
      dlcrop,
      dollar,
      Dopf,
      dopf,
      Dot,
      dot,
      DotDot,
      doteq,
      doteqdot,
      DotEqual,
      dotminus,
      dotplus,
      dotsquare,
      doublebarwedge,
      DoubleContourIntegral,
      DoubleDot,
      DoubleDownArrow,
      DoubleLeftArrow,
      DoubleLeftRightArrow,
      DoubleLeftTee,
      DoubleLongLeftArrow,
      DoubleLongLeftRightArrow,
      DoubleLongRightArrow,
      DoubleRightArrow,
      DoubleRightTee,
      DoubleUpArrow,
      DoubleUpDownArrow,
      DoubleVerticalBar,
      DownArrowBar,
      downarrow,
      DownArrow,
      Downarrow,
      DownArrowUpArrow,
      DownBreve,
      downdownarrows,
      downharpoonleft,
      downharpoonright,
      DownLeftRightVector,
      DownLeftTeeVector,
      DownLeftVectorBar,
      DownLeftVector,
      DownRightTeeVector,
      DownRightVectorBar,
      DownRightVector,
      DownTeeArrow,
      DownTee,
      drbkarow,
      drcorn,
      drcrop,
      Dscr,
      dscr,
      DScy,
      dscy,
      dsol,
      Dstrok,
      dstrok,
      dtdot,
      dtri,
      dtrif,
      duarr,
      duhar,
      dwangle,
      DZcy,
      dzcy,
      dzigrarr,
      Eacute,
      eacute,
      easter,
      Ecaron,
      ecaron,
      Ecirc,
      ecirc,
      ecir,
      ecolon,
      Ecy,
      ecy,
      eDDot,
      Edot,
      edot,
      eDot,
      ee,
      efDot,
      Efr,
      efr,
      eg,
      Egrave,
      egrave,
      egs,
      egsdot,
      el,
      Element: Element$1,
      elinters,
      ell,
      els,
      elsdot,
      Emacr,
      emacr,
      empty,
      emptyset,
      EmptySmallSquare,
      emptyv,
      EmptyVerySmallSquare,
      emsp13,
      emsp14,
      emsp,
      ENG,
      eng,
      ensp,
      Eogon,
      eogon,
      Eopf,
      eopf,
      epar,
      eparsl,
      eplus,
      epsi,
      Epsilon,
      epsilon,
      epsiv,
      eqcirc,
      eqcolon,
      eqsim,
      eqslantgtr,
      eqslantless,
      Equal,
      equals,
      EqualTilde,
      equest,
      Equilibrium,
      equiv,
      equivDD,
      eqvparsl,
      erarr,
      erDot,
      escr,
      Escr,
      esdot,
      Esim,
      esim,
      Eta,
      eta,
      ETH,
      eth,
      Euml,
      euml,
      euro,
      excl,
      exist,
      Exists,
      expectation,
      exponentiale,
      ExponentialE,
      fallingdotseq,
      Fcy,
      fcy,
      female,
      ffilig,
      fflig,
      ffllig,
      Ffr,
      ffr,
      filig,
      FilledSmallSquare,
      FilledVerySmallSquare,
      fjlig,
      flat,
      fllig,
      fltns,
      fnof,
      Fopf,
      fopf,
      forall,
      ForAll,
      fork,
      forkv,
      Fouriertrf,
      fpartint,
      frac12,
      frac13,
      frac14,
      frac15,
      frac16,
      frac18,
      frac23,
      frac25,
      frac34,
      frac35,
      frac38,
      frac45,
      frac56,
      frac58,
      frac78,
      frasl,
      frown,
      fscr,
      Fscr,
      gacute,
      Gamma,
      gamma,
      Gammad,
      gammad,
      gap,
      Gbreve,
      gbreve,
      Gcedil,
      Gcirc,
      gcirc,
      Gcy,
      gcy,
      Gdot,
      gdot,
      ge,
      gE,
      gEl,
      gel,
      geq,
      geqq,
      geqslant,
      gescc,
      ges,
      gesdot,
      gesdoto,
      gesdotol,
      gesl,
      gesles,
      Gfr,
      gfr,
      gg,
      Gg,
      ggg,
      gimel,
      GJcy,
      gjcy,
      gla,
      gl,
      glE,
      glj,
      gnap,
      gnapprox,
      gne,
      gnE,
      gneq,
      gneqq,
      gnsim,
      Gopf,
      gopf,
      grave,
      GreaterEqual,
      GreaterEqualLess,
      GreaterFullEqual,
      GreaterGreater,
      GreaterLess,
      GreaterSlantEqual,
      GreaterTilde,
      Gscr,
      gscr,
      gsim,
      gsime,
      gsiml,
      gtcc,
      gtcir,
      gt,
      GT,
      Gt,
      gtdot,
      gtlPar,
      gtquest,
      gtrapprox,
      gtrarr,
      gtrdot,
      gtreqless,
      gtreqqless,
      gtrless,
      gtrsim,
      gvertneqq,
      gvnE,
      Hacek,
      hairsp,
      half,
      hamilt,
      HARDcy,
      hardcy,
      harrcir,
      harr,
      hArr,
      harrw,
      Hat,
      hbar,
      Hcirc,
      hcirc,
      hearts,
      heartsuit,
      hellip,
      hercon,
      hfr,
      Hfr,
      HilbertSpace,
      hksearow,
      hkswarow,
      hoarr,
      homtht,
      hookleftarrow,
      hookrightarrow,
      hopf,
      Hopf,
      horbar,
      HorizontalLine,
      hscr,
      Hscr,
      hslash,
      Hstrok,
      hstrok,
      HumpDownHump,
      HumpEqual,
      hybull,
      hyphen,
      Iacute,
      iacute,
      ic,
      Icirc,
      icirc,
      Icy,
      icy,
      Idot,
      IEcy,
      iecy,
      iexcl,
      iff,
      ifr,
      Ifr,
      Igrave,
      igrave,
      ii,
      iiiint,
      iiint,
      iinfin,
      iiota,
      IJlig,
      ijlig,
      Imacr,
      imacr,
      image: image$1,
      ImaginaryI,
      imagline,
      imagpart,
      imath,
      Im,
      imof,
      imped,
      Implies,
      incare,
      "in": "",
      infin,
      infintie,
      inodot,
      intcal,
      int,
      Int,
      integers,
      Integral,
      intercal,
      Intersection,
      intlarhk,
      intprod,
      InvisibleComma,
      InvisibleTimes,
      IOcy,
      iocy,
      Iogon,
      iogon,
      Iopf,
      iopf,
      Iota,
      iota,
      iprod,
      iquest,
      iscr,
      Iscr,
      isin,
      isindot,
      isinE,
      isins,
      isinsv,
      isinv,
      it,
      Itilde,
      itilde,
      Iukcy,
      iukcy,
      Iuml,
      iuml,
      Jcirc,
      jcirc,
      Jcy,
      jcy,
      Jfr,
      jfr,
      jmath,
      Jopf,
      jopf,
      Jscr,
      jscr,
      Jsercy,
      jsercy,
      Jukcy,
      jukcy,
      Kappa,
      kappa,
      kappav,
      Kcedil,
      kcedil,
      Kcy,
      kcy,
      Kfr,
      kfr,
      kgreen,
      KHcy,
      khcy,
      KJcy,
      kjcy,
      Kopf,
      kopf,
      Kscr,
      kscr,
      lAarr,
      Lacute,
      lacute,
      laemptyv,
      lagran,
      Lambda,
      lambda,
      lang,
      Lang,
      langd,
      langle,
      lap,
      Laplacetrf,
      laquo,
      larrb,
      larrbfs,
      larr,
      Larr,
      lArr,
      larrfs,
      larrhk,
      larrlp,
      larrpl,
      larrsim,
      larrtl,
      latail,
      lAtail,
      lat,
      late,
      lates,
      lbarr,
      lBarr,
      lbbrk,
      lbrace,
      lbrack,
      lbrke,
      lbrksld,
      lbrkslu,
      Lcaron,
      lcaron,
      Lcedil,
      lcedil,
      lceil,
      lcub,
      Lcy,
      lcy,
      ldca,
      ldquo,
      ldquor,
      ldrdhar,
      ldrushar,
      ldsh,
      le,
      lE,
      LeftAngleBracket,
      LeftArrowBar,
      leftarrow,
      LeftArrow,
      Leftarrow,
      LeftArrowRightArrow,
      leftarrowtail,
      LeftCeiling,
      LeftDoubleBracket,
      LeftDownTeeVector,
      LeftDownVectorBar,
      LeftDownVector,
      LeftFloor,
      leftharpoondown,
      leftharpoonup,
      leftleftarrows,
      leftrightarrow,
      LeftRightArrow,
      Leftrightarrow,
      leftrightarrows,
      leftrightharpoons,
      leftrightsquigarrow,
      LeftRightVector,
      LeftTeeArrow,
      LeftTee,
      LeftTeeVector,
      leftthreetimes,
      LeftTriangleBar,
      LeftTriangle,
      LeftTriangleEqual,
      LeftUpDownVector,
      LeftUpTeeVector,
      LeftUpVectorBar,
      LeftUpVector,
      LeftVectorBar,
      LeftVector,
      lEg,
      leg,
      leq,
      leqq,
      leqslant,
      lescc,
      les,
      lesdot,
      lesdoto,
      lesdotor,
      lesg,
      lesges,
      lessapprox,
      lessdot,
      lesseqgtr,
      lesseqqgtr,
      LessEqualGreater,
      LessFullEqual,
      LessGreater,
      lessgtr,
      LessLess,
      lesssim,
      LessSlantEqual,
      LessTilde,
      lfisht,
      lfloor,
      Lfr,
      lfr,
      lg,
      lgE,
      lHar,
      lhard,
      lharu,
      lharul,
      lhblk,
      LJcy,
      ljcy,
      llarr,
      ll,
      Ll,
      llcorner,
      Lleftarrow,
      llhard,
      lltri,
      Lmidot,
      lmidot,
      lmoustache,
      lmoust,
      lnap,
      lnapprox,
      lne,
      lnE,
      lneq,
      lneqq,
      lnsim,
      loang,
      loarr,
      lobrk,
      longleftarrow,
      LongLeftArrow,
      Longleftarrow,
      longleftrightarrow,
      LongLeftRightArrow,
      Longleftrightarrow,
      longmapsto,
      longrightarrow,
      LongRightArrow,
      Longrightarrow,
      looparrowleft,
      looparrowright,
      lopar,
      Lopf,
      lopf,
      loplus,
      lotimes,
      lowast,
      lowbar,
      LowerLeftArrow,
      LowerRightArrow,
      loz,
      lozenge,
      lozf,
      lpar,
      lparlt,
      lrarr,
      lrcorner,
      lrhar,
      lrhard,
      lrm,
      lrtri,
      lsaquo,
      lscr,
      Lscr,
      lsh,
      Lsh,
      lsim,
      lsime,
      lsimg,
      lsqb,
      lsquo,
      lsquor,
      Lstrok,
      lstrok,
      ltcc,
      ltcir,
      lt,
      LT,
      Lt,
      ltdot,
      lthree,
      ltimes,
      ltlarr,
      ltquest,
      ltri,
      ltrie,
      ltrif,
      ltrPar,
      lurdshar,
      luruhar,
      lvertneqq,
      lvnE,
      macr,
      male,
      malt,
      maltese,
      "Map": "",
      map: map$1,
      mapsto,
      mapstodown,
      mapstoleft,
      mapstoup,
      marker,
      mcomma,
      Mcy,
      mcy,
      mdash,
      mDDot,
      measuredangle,
      MediumSpace,
      Mellintrf,
      Mfr,
      mfr,
      mho,
      micro,
      midast,
      midcir,
      mid,
      middot,
      minusb,
      minus,
      minusd,
      minusdu,
      MinusPlus,
      mlcp,
      mldr,
      mnplus,
      models,
      Mopf,
      mopf,
      mp,
      mscr,
      Mscr,
      mstpos,
      Mu,
      mu,
      multimap,
      mumap,
      nabla,
      Nacute,
      nacute,
      nang,
      nap,
      napE,
      napid,
      napos,
      napprox,
      natural,
      naturals,
      natur,
      nbsp,
      nbump,
      nbumpe,
      ncap,
      Ncaron,
      ncaron,
      Ncedil,
      ncedil,
      ncong,
      ncongdot,
      ncup,
      Ncy,
      ncy,
      ndash,
      nearhk,
      nearr,
      neArr,
      nearrow,
      ne,
      nedot,
      NegativeMediumSpace,
      NegativeThickSpace,
      NegativeThinSpace,
      NegativeVeryThinSpace,
      nequiv,
      nesear,
      nesim,
      NestedGreaterGreater,
      NestedLessLess,
      NewLine,
      nexist,
      nexists,
      Nfr,
      nfr,
      ngE,
      nge,
      ngeq,
      ngeqq,
      ngeqslant,
      nges,
      nGg,
      ngsim,
      nGt,
      ngt,
      ngtr,
      nGtv,
      nharr,
      nhArr,
      nhpar,
      ni,
      nis,
      nisd,
      niv,
      NJcy,
      njcy,
      nlarr,
      nlArr,
      nldr,
      nlE,
      nle,
      nleftarrow,
      nLeftarrow,
      nleftrightarrow,
      nLeftrightarrow,
      nleq,
      nleqq,
      nleqslant,
      nles,
      nless,
      nLl,
      nlsim,
      nLt,
      nlt,
      nltri,
      nltrie,
      nLtv,
      nmid,
      NoBreak,
      NonBreakingSpace,
      nopf,
      Nopf,
      Not,
      not,
      NotCongruent,
      NotCupCap,
      NotDoubleVerticalBar,
      NotElement,
      NotEqual,
      NotEqualTilde,
      NotExists,
      NotGreater,
      NotGreaterEqual,
      NotGreaterFullEqual,
      NotGreaterGreater,
      NotGreaterLess,
      NotGreaterSlantEqual,
      NotGreaterTilde,
      NotHumpDownHump,
      NotHumpEqual,
      notin,
      notindot,
      notinE,
      notinva,
      notinvb,
      notinvc,
      NotLeftTriangleBar,
      NotLeftTriangle,
      NotLeftTriangleEqual,
      NotLess,
      NotLessEqual,
      NotLessGreater,
      NotLessLess,
      NotLessSlantEqual,
      NotLessTilde,
      NotNestedGreaterGreater,
      NotNestedLessLess,
      notni,
      notniva,
      notnivb,
      notnivc,
      NotPrecedes,
      NotPrecedesEqual,
      NotPrecedesSlantEqual,
      NotReverseElement,
      NotRightTriangleBar,
      NotRightTriangle,
      NotRightTriangleEqual,
      NotSquareSubset,
      NotSquareSubsetEqual,
      NotSquareSuperset,
      NotSquareSupersetEqual,
      NotSubset,
      NotSubsetEqual,
      NotSucceeds,
      NotSucceedsEqual,
      NotSucceedsSlantEqual,
      NotSucceedsTilde,
      NotSuperset,
      NotSupersetEqual,
      NotTilde,
      NotTildeEqual,
      NotTildeFullEqual,
      NotTildeTilde,
      NotVerticalBar,
      nparallel,
      npar,
      nparsl,
      npart,
      npolint,
      npr,
      nprcue,
      nprec,
      npreceq,
      npre,
      nrarrc,
      nrarr,
      nrArr,
      nrarrw,
      nrightarrow,
      nRightarrow,
      nrtri,
      nrtrie,
      nsc,
      nsccue,
      nsce,
      Nscr,
      nscr,
      nshortmid,
      nshortparallel,
      nsim,
      nsime,
      nsimeq,
      nsmid,
      nspar,
      nsqsube,
      nsqsupe,
      nsub,
      nsubE,
      nsube,
      nsubset,
      nsubseteq,
      nsubseteqq,
      nsucc,
      nsucceq,
      nsup,
      nsupE,
      nsupe,
      nsupset,
      nsupseteq,
      nsupseteqq,
      ntgl,
      Ntilde,
      ntilde,
      ntlg,
      ntriangleleft,
      ntrianglelefteq,
      ntriangleright,
      ntrianglerighteq,
      Nu,
      nu,
      num,
      numero,
      numsp,
      nvap,
      nvdash,
      nvDash,
      nVdash,
      nVDash,
      nvge,
      nvgt,
      nvHarr,
      nvinfin,
      nvlArr,
      nvle,
      nvlt,
      nvltrie,
      nvrArr,
      nvrtrie,
      nvsim,
      nwarhk,
      nwarr,
      nwArr,
      nwarrow,
      nwnear,
      Oacute,
      oacute,
      oast,
      Ocirc,
      ocirc,
      ocir,
      Ocy,
      ocy,
      odash,
      Odblac,
      odblac,
      odiv,
      odot,
      odsold,
      OElig,
      oelig,
      ofcir,
      Ofr,
      ofr,
      ogon,
      Ograve,
      ograve,
      ogt,
      ohbar,
      ohm,
      oint,
      olarr,
      olcir,
      olcross,
      oline,
      olt,
      Omacr,
      omacr,
      Omega,
      omega,
      Omicron,
      omicron,
      omid,
      ominus,
      Oopf,
      oopf,
      opar,
      OpenCurlyDoubleQuote,
      OpenCurlyQuote,
      operp,
      oplus,
      orarr,
      Or,
      or,
      ord,
      order,
      orderof,
      ordf,
      ordm,
      origof,
      oror,
      orslope,
      orv,
      oS,
      Oscr,
      oscr,
      Oslash,
      oslash,
      osol,
      Otilde,
      otilde,
      otimesas,
      Otimes,
      otimes,
      Ouml,
      ouml,
      ovbar,
      OverBar,
      OverBrace,
      OverBracket,
      OverParenthesis,
      para,
      parallel,
      par,
      parsim,
      parsl,
      part,
      PartialD,
      Pcy,
      pcy,
      percnt,
      period,
      permil,
      perp,
      pertenk,
      Pfr,
      pfr,
      Phi,
      phi,
      phiv,
      phmmat,
      phone,
      Pi,
      pi,
      pitchfork,
      piv,
      planck,
      planckh,
      plankv,
      plusacir,
      plusb,
      pluscir,
      plus,
      plusdo,
      plusdu,
      pluse,
      PlusMinus,
      plusmn,
      plussim,
      plustwo,
      pm,
      Poincareplane,
      pointint,
      popf,
      Popf,
      pound,
      prap,
      Pr,
      pr,
      prcue,
      precapprox,
      prec,
      preccurlyeq,
      Precedes,
      PrecedesEqual,
      PrecedesSlantEqual,
      PrecedesTilde,
      preceq,
      precnapprox,
      precneqq,
      precnsim,
      pre,
      prE,
      precsim,
      prime,
      Prime,
      primes,
      prnap,
      prnE,
      prnsim,
      prod,
      Product,
      profalar,
      profline,
      profsurf,
      prop,
      Proportional,
      Proportion,
      propto,
      prsim,
      prurel,
      Pscr,
      pscr,
      Psi,
      psi,
      puncsp,
      Qfr,
      qfr,
      qint,
      qopf,
      Qopf,
      qprime,
      Qscr,
      qscr,
      quaternions,
      quatint,
      quest,
      questeq,
      quot,
      QUOT,
      rAarr,
      race,
      Racute,
      racute,
      radic,
      raemptyv,
      rang,
      Rang,
      rangd,
      range,
      rangle,
      raquo,
      rarrap,
      rarrb,
      rarrbfs,
      rarrc,
      rarr,
      Rarr,
      rArr,
      rarrfs,
      rarrhk,
      rarrlp,
      rarrpl,
      rarrsim,
      Rarrtl,
      rarrtl,
      rarrw,
      ratail,
      rAtail,
      ratio,
      rationals,
      rbarr,
      rBarr,
      RBarr,
      rbbrk,
      rbrace,
      rbrack,
      rbrke,
      rbrksld,
      rbrkslu,
      Rcaron,
      rcaron,
      Rcedil,
      rcedil,
      rceil,
      rcub,
      Rcy,
      rcy,
      rdca,
      rdldhar,
      rdquo,
      rdquor,
      rdsh,
      real,
      realine,
      realpart,
      reals,
      Re,
      rect,
      reg,
      REG,
      ReverseElement,
      ReverseEquilibrium,
      ReverseUpEquilibrium,
      rfisht,
      rfloor,
      rfr,
      Rfr,
      rHar,
      rhard,
      rharu,
      rharul,
      Rho,
      rho,
      rhov,
      RightAngleBracket,
      RightArrowBar,
      rightarrow,
      RightArrow,
      Rightarrow,
      RightArrowLeftArrow,
      rightarrowtail,
      RightCeiling,
      RightDoubleBracket,
      RightDownTeeVector,
      RightDownVectorBar,
      RightDownVector,
      RightFloor,
      rightharpoondown,
      rightharpoonup,
      rightleftarrows,
      rightleftharpoons,
      rightrightarrows,
      rightsquigarrow,
      RightTeeArrow,
      RightTee,
      RightTeeVector,
      rightthreetimes,
      RightTriangleBar,
      RightTriangle,
      RightTriangleEqual,
      RightUpDownVector,
      RightUpTeeVector,
      RightUpVectorBar,
      RightUpVector,
      RightVectorBar,
      RightVector,
      ring,
      risingdotseq,
      rlarr,
      rlhar,
      rlm,
      rmoustache,
      rmoust,
      rnmid,
      roang,
      roarr,
      robrk,
      ropar,
      ropf,
      Ropf,
      roplus,
      rotimes,
      RoundImplies,
      rpar,
      rpargt,
      rppolint,
      rrarr,
      Rrightarrow,
      rsaquo,
      rscr,
      Rscr,
      rsh,
      Rsh,
      rsqb,
      rsquo,
      rsquor,
      rthree,
      rtimes,
      rtri,
      rtrie,
      rtrif,
      rtriltri,
      RuleDelayed,
      ruluhar,
      rx,
      Sacute,
      sacute,
      sbquo,
      scap,
      Scaron,
      scaron,
      Sc,
      sc,
      sccue,
      sce,
      scE,
      Scedil,
      scedil,
      Scirc,
      scirc,
      scnap,
      scnE,
      scnsim,
      scpolint,
      scsim,
      Scy,
      scy,
      sdotb,
      sdot,
      sdote,
      searhk,
      searr,
      seArr,
      searrow,
      sect,
      semi,
      seswar,
      setminus,
      setmn,
      sext,
      Sfr,
      sfr,
      sfrown,
      sharp,
      SHCHcy,
      shchcy,
      SHcy,
      shcy,
      ShortDownArrow,
      ShortLeftArrow,
      shortmid,
      shortparallel,
      ShortRightArrow,
      ShortUpArrow,
      shy,
      Sigma,
      sigma,
      sigmaf,
      sigmav,
      sim,
      simdot,
      sime,
      simeq,
      simg,
      simgE,
      siml,
      simlE,
      simne,
      simplus,
      simrarr,
      slarr,
      SmallCircle,
      smallsetminus,
      smashp,
      smeparsl,
      smid,
      smile,
      smt,
      smte,
      smtes,
      SOFTcy,
      softcy,
      solbar,
      solb,
      sol,
      Sopf,
      sopf,
      spades,
      spadesuit,
      spar,
      sqcap,
      sqcaps,
      sqcup,
      sqcups,
      Sqrt,
      sqsub,
      sqsube,
      sqsubset,
      sqsubseteq,
      sqsup,
      sqsupe,
      sqsupset,
      sqsupseteq,
      square,
      Square,
      SquareIntersection,
      SquareSubset,
      SquareSubsetEqual,
      SquareSuperset,
      SquareSupersetEqual,
      SquareUnion,
      squarf,
      squ,
      squf,
      srarr,
      Sscr,
      sscr,
      ssetmn,
      ssmile,
      sstarf,
      Star,
      star,
      starf,
      straightepsilon,
      straightphi,
      strns,
      sub,
      Sub,
      subdot,
      subE,
      sube,
      subedot,
      submult,
      subnE,
      subne,
      subplus,
      subrarr,
      subset,
      Subset,
      subseteq,
      subseteqq,
      SubsetEqual,
      subsetneq,
      subsetneqq,
      subsim,
      subsub,
      subsup,
      succapprox,
      succ,
      succcurlyeq,
      Succeeds,
      SucceedsEqual,
      SucceedsSlantEqual,
      SucceedsTilde,
      succeq,
      succnapprox,
      succneqq,
      succnsim,
      succsim,
      SuchThat,
      sum,
      Sum,
      sung,
      sup1,
      sup2,
      sup3,
      sup,
      Sup,
      supdot,
      supdsub,
      supE,
      supe,
      supedot,
      Superset,
      SupersetEqual,
      suphsol,
      suphsub,
      suplarr,
      supmult,
      supnE,
      supne,
      supplus,
      supset,
      Supset,
      supseteq,
      supseteqq,
      supsetneq,
      supsetneqq,
      supsim,
      supsub,
      supsup,
      swarhk,
      swarr,
      swArr,
      swarrow,
      swnwar,
      szlig,
      Tab,
      target,
      Tau,
      tau,
      tbrk,
      Tcaron,
      tcaron,
      Tcedil,
      tcedil,
      Tcy,
      tcy,
      tdot,
      telrec,
      Tfr,
      tfr,
      there4,
      therefore,
      Therefore,
      Theta,
      theta,
      thetasym,
      thetav,
      thickapprox,
      thicksim,
      ThickSpace,
      ThinSpace,
      thinsp,
      thkap,
      thksim,
      THORN,
      thorn,
      tilde,
      Tilde,
      TildeEqual,
      TildeFullEqual,
      TildeTilde,
      timesbar,
      timesb,
      times,
      timesd,
      tint,
      toea,
      topbot,
      topcir,
      top,
      Topf,
      topf,
      topfork,
      tosa,
      tprime,
      trade,
      TRADE,
      triangle,
      triangledown,
      triangleleft,
      trianglelefteq,
      triangleq,
      triangleright,
      trianglerighteq,
      tridot,
      trie,
      triminus,
      TripleDot,
      triplus,
      trisb,
      tritime,
      trpezium,
      Tscr,
      tscr,
      TScy,
      tscy,
      TSHcy,
      tshcy,
      Tstrok,
      tstrok,
      twixt,
      twoheadleftarrow,
      twoheadrightarrow,
      Uacute,
      uacute,
      uarr,
      Uarr,
      uArr,
      Uarrocir,
      Ubrcy,
      ubrcy,
      Ubreve,
      ubreve,
      Ucirc,
      ucirc,
      Ucy,
      ucy,
      udarr,
      Udblac,
      udblac,
      udhar,
      ufisht,
      Ufr,
      ufr,
      Ugrave,
      ugrave,
      uHar,
      uharl,
      uharr,
      uhblk,
      ulcorn,
      ulcorner,
      ulcrop,
      ultri,
      Umacr,
      umacr,
      uml,
      UnderBar,
      UnderBrace,
      UnderBracket,
      UnderParenthesis,
      Union,
      UnionPlus,
      Uogon,
      uogon,
      Uopf,
      uopf,
      UpArrowBar,
      uparrow,
      UpArrow,
      Uparrow,
      UpArrowDownArrow,
      updownarrow,
      UpDownArrow,
      Updownarrow,
      UpEquilibrium,
      upharpoonleft,
      upharpoonright,
      uplus,
      UpperLeftArrow,
      UpperRightArrow,
      upsi,
      Upsi,
      upsih,
      Upsilon,
      upsilon,
      UpTeeArrow,
      UpTee,
      upuparrows,
      urcorn,
      urcorner,
      urcrop,
      Uring,
      uring,
      urtri,
      Uscr,
      uscr,
      utdot,
      Utilde,
      utilde,
      utri,
      utrif,
      uuarr,
      Uuml,
      uuml,
      uwangle,
      vangrt,
      varepsilon,
      varkappa,
      varnothing,
      varphi,
      varpi,
      varpropto,
      varr,
      vArr,
      varrho,
      varsigma,
      varsubsetneq,
      varsubsetneqq,
      varsupsetneq,
      varsupsetneqq,
      vartheta,
      vartriangleleft,
      vartriangleright,
      vBar,
      Vbar,
      vBarv,
      Vcy,
      vcy,
      vdash,
      vDash,
      Vdash,
      VDash,
      Vdashl,
      veebar,
      vee,
      Vee,
      veeeq,
      vellip,
      verbar,
      Verbar,
      vert,
      Vert,
      VerticalBar,
      VerticalLine,
      VerticalSeparator,
      VerticalTilde,
      VeryThinSpace,
      Vfr,
      vfr,
      vltri,
      vnsub,
      vnsup,
      Vopf,
      vopf,
      vprop,
      vrtri,
      Vscr,
      vscr,
      vsubnE,
      vsubne,
      vsupnE,
      vsupne,
      Vvdash,
      vzigzag,
      Wcirc,
      wcirc,
      wedbar,
      wedge,
      Wedge,
      wedgeq,
      weierp,
      Wfr,
      wfr,
      Wopf,
      wopf,
      wp,
      wr,
      wreath,
      Wscr,
      wscr,
      xcap,
      xcirc,
      xcup,
      xdtri,
      Xfr,
      xfr,
      xharr,
      xhArr,
      Xi,
      xi,
      xlarr,
      xlArr,
      xmap,
      xnis,
      xodot,
      Xopf,
      xopf,
      xoplus,
      xotime,
      xrarr,
      xrArr,
      Xscr,
      xscr,
      xsqcup,
      xuplus,
      xutri,
      xvee,
      xwedge,
      Yacute,
      yacute,
      YAcy,
      yacy,
      Ycirc,
      ycirc,
      Ycy,
      ycy,
      yen,
      Yfr,
      yfr,
      YIcy,
      yicy,
      Yopf,
      yopf,
      Yscr,
      yscr,
      YUcy,
      yucy,
      yuml,
      Yuml,
      Zacute,
      zacute,
      Zcaron,
      zcaron,
      Zcy,
      zcy,
      Zdot,
      zdot,
      zeetrf,
      ZeroWidthSpace,
      Zeta,
      zeta,
      zfr,
      Zfr,
      ZHcy,
      zhcy,
      zigrarr,
      zopf,
      Zopf,
      Zscr,
      zscr,
      zwj,
      zwnj
    };
    var entities$1 = require$$0;
    var regex$4 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
    var mdurl$1 = {};
    var encodeCache = {};
    function getEncodeCache(exclude) {
      var i2, ch, cache = encodeCache[exclude];
      if (cache) {
        return cache;
      }
      cache = encodeCache[exclude] = [];
      for (i2 = 0; i2 < 128; i2++) {
        ch = String.fromCharCode(i2);
        if (/^[0-9a-z]$/i.test(ch)) {
          cache.push(ch);
        } else {
          cache.push("%" + ("0" + i2.toString(16).toUpperCase()).slice(-2));
        }
      }
      for (i2 = 0; i2 < exclude.length; i2++) {
        cache[exclude.charCodeAt(i2)] = exclude[i2];
      }
      return cache;
    }
    function encode$1(string, exclude, keepEscaped) {
      var i2, l, code2, nextCode, cache, result = "";
      if (typeof exclude !== "string") {
        keepEscaped = exclude;
        exclude = encode$1.defaultChars;
      }
      if (typeof keepEscaped === "undefined") {
        keepEscaped = true;
      }
      cache = getEncodeCache(exclude);
      for (i2 = 0, l = string.length; i2 < l; i2++) {
        code2 = string.charCodeAt(i2);
        if (keepEscaped && code2 === 37 && i2 + 2 < l) {
          if (/^[0-9a-f]{2}$/i.test(string.slice(i2 + 1, i2 + 3))) {
            result += string.slice(i2, i2 + 3);
            i2 += 2;
            continue;
          }
        }
        if (code2 < 128) {
          result += cache[code2];
          continue;
        }
        if (code2 >= 55296 && code2 <= 57343) {
          if (code2 >= 55296 && code2 <= 56319 && i2 + 1 < l) {
            nextCode = string.charCodeAt(i2 + 1);
            if (nextCode >= 56320 && nextCode <= 57343) {
              result += encodeURIComponent(string[i2] + string[i2 + 1]);
              i2++;
              continue;
            }
          }
          result += "%EF%BF%BD";
          continue;
        }
        result += encodeURIComponent(string[i2]);
      }
      return result;
    }
    encode$1.defaultChars = ";/?:@&=+$,-_.!~*'()#";
    encode$1.componentChars = "-_.!~*'()";
    var encode_1 = encode$1;
    var decodeCache = {};
    function getDecodeCache(exclude) {
      var i2, ch, cache = decodeCache[exclude];
      if (cache) {
        return cache;
      }
      cache = decodeCache[exclude] = [];
      for (i2 = 0; i2 < 128; i2++) {
        ch = String.fromCharCode(i2);
        cache.push(ch);
      }
      for (i2 = 0; i2 < exclude.length; i2++) {
        ch = exclude.charCodeAt(i2);
        cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
      }
      return cache;
    }
    function decode$1(string, exclude) {
      var cache;
      if (typeof exclude !== "string") {
        exclude = decode$1.defaultChars;
      }
      cache = getDecodeCache(exclude);
      return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
        var i2, l, b1, b2, b3, b4, chr, result = "";
        for (i2 = 0, l = seq.length; i2 < l; i2 += 3) {
          b1 = parseInt(seq.slice(i2 + 1, i2 + 3), 16);
          if (b1 < 128) {
            result += cache[b1];
            continue;
          }
          if ((b1 & 224) === 192 && i2 + 3 < l) {
            b2 = parseInt(seq.slice(i2 + 4, i2 + 6), 16);
            if ((b2 & 192) === 128) {
              chr = b1 << 6 & 1984 | b2 & 63;
              if (chr < 128) {
                result += "";
              } else {
                result += String.fromCharCode(chr);
              }
              i2 += 3;
              continue;
            }
          }
          if ((b1 & 240) === 224 && i2 + 6 < l) {
            b2 = parseInt(seq.slice(i2 + 4, i2 + 6), 16);
            b3 = parseInt(seq.slice(i2 + 7, i2 + 9), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128) {
              chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
              if (chr < 2048 || chr >= 55296 && chr <= 57343) {
                result += "";
              } else {
                result += String.fromCharCode(chr);
              }
              i2 += 6;
              continue;
            }
          }
          if ((b1 & 248) === 240 && i2 + 9 < l) {
            b2 = parseInt(seq.slice(i2 + 4, i2 + 6), 16);
            b3 = parseInt(seq.slice(i2 + 7, i2 + 9), 16);
            b4 = parseInt(seq.slice(i2 + 10, i2 + 12), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
              chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
              if (chr < 65536 || chr > 1114111) {
                result += "";
              } else {
                chr -= 65536;
                result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
              }
              i2 += 9;
              continue;
            }
          }
          result += "";
        }
        return result;
      });
    }
    decode$1.defaultChars = ";/?:@&=+$,#";
    decode$1.componentChars = "";
    var decode_1 = decode$1;
    var format = function format2(url) {
      var result = "";
      result += url.protocol || "";
      result += url.slashes ? "//" : "";
      result += url.auth ? url.auth + "@" : "";
      if (url.hostname && url.hostname.indexOf(":") !== -1) {
        result += "[" + url.hostname + "]";
      } else {
        result += url.hostname || "";
      }
      result += url.port ? ":" + url.port : "";
      result += url.pathname || "";
      result += url.search || "";
      result += url.hash || "";
      return result;
    };
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.pathname = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    }, slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    function urlParse(url, slashesDenoteHost) {
      if (url && url instanceof Url) {
        return url;
      }
      var u = new Url();
      u.parse(url, slashesDenoteHost);
      return u;
    }
    Url.prototype.parse = function(url, slashesDenoteHost) {
      var i2, l, lowerProto, hec, slashes, rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        lowerProto = proto.toLowerCase();
        this.protocol = proto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (i2 = 0; i2 < hostEndingChars.length; i2++) {
          hec = rest.indexOf(hostEndingChars[i2]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = auth;
        }
        hostEnd = -1;
        for (i2 = 0; i2 < nonHostChars.length; i2++) {
          hec = rest.indexOf(nonHostChars[i2]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        if (rest[hostEnd - 1] === ":") {
          hostEnd--;
        }
        var host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost(host);
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (i2 = 0, l = hostparts.length; i2 < l; i2++) {
            var part2 = hostparts[i2];
            if (!part2) {
              continue;
            }
            if (!part2.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j = 0, k = part2.length; j < k; j++) {
                if (part2.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part2[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i2);
                var notHost = hostparts.slice(i2 + 1);
                var bit = part2.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        }
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        rest = rest.slice(0, qm);
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "";
      }
      return this;
    };
    Url.prototype.parseHost = function(host) {
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    var parse = urlParse;
    mdurl$1.encode = encode_1;
    mdurl$1.decode = decode_1;
    mdurl$1.format = format;
    mdurl$1.parse = parse;
    var uc_micro = {};
    var regex$3;
    var hasRequiredRegex$3;
    function requireRegex$3() {
      if (hasRequiredRegex$3)
        return regex$3;
      hasRequiredRegex$3 = 1;
      regex$3 = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      return regex$3;
    }
    var regex$2;
    var hasRequiredRegex$2;
    function requireRegex$2() {
      if (hasRequiredRegex$2)
        return regex$2;
      hasRequiredRegex$2 = 1;
      regex$2 = /[\0-\x1F\x7F-\x9F]/;
      return regex$2;
    }
    var regex$1;
    var hasRequiredRegex$1;
    function requireRegex$1() {
      if (hasRequiredRegex$1)
        return regex$1;
      hasRequiredRegex$1 = 1;
      regex$1 = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
      return regex$1;
    }
    var regex;
    var hasRequiredRegex;
    function requireRegex() {
      if (hasRequiredRegex)
        return regex;
      hasRequiredRegex = 1;
      regex = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
      return regex;
    }
    var hasRequiredUc_micro;
    function requireUc_micro() {
      if (hasRequiredUc_micro)
        return uc_micro;
      hasRequiredUc_micro = 1;
      uc_micro.Any = requireRegex$3();
      uc_micro.Cc = requireRegex$2();
      uc_micro.Cf = requireRegex$1();
      uc_micro.P = regex$4;
      uc_micro.Z = requireRegex();
      return uc_micro;
    }
    (function(exports2) {
      function _class2(obj) {
        return Object.prototype.toString.call(obj);
      }
      function isString2(obj) {
        return _class2(obj) === "[object String]";
      }
      var _hasOwnProperty = Object.prototype.hasOwnProperty;
      function has2(object, key) {
        return _hasOwnProperty.call(object, key);
      }
      function assign2(obj) {
        var sources = Array.prototype.slice.call(arguments, 1);
        sources.forEach(function(source) {
          if (!source) {
            return;
          }
          if (typeof source !== "object") {
            throw new TypeError(source + "must be object");
          }
          Object.keys(source).forEach(function(key) {
            obj[key] = source[key];
          });
        });
        return obj;
      }
      function arrayReplaceAt2(src, pos, newElements) {
        return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
      }
      function isValidEntityCode2(c) {
        if (c >= 55296 && c <= 57343) {
          return false;
        }
        if (c >= 64976 && c <= 65007) {
          return false;
        }
        if ((c & 65535) === 65535 || (c & 65535) === 65534) {
          return false;
        }
        if (c >= 0 && c <= 8) {
          return false;
        }
        if (c === 11) {
          return false;
        }
        if (c >= 14 && c <= 31) {
          return false;
        }
        if (c >= 127 && c <= 159) {
          return false;
        }
        if (c > 1114111) {
          return false;
        }
        return true;
      }
      function fromCodePoint2(c) {
        if (c > 65535) {
          c -= 65536;
          var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);
          return String.fromCharCode(surrogate1, surrogate2);
        }
        return String.fromCharCode(c);
      }
      var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
      var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
      var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
      var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
      var entities2 = entities$1;
      function replaceEntityPattern(match, name) {
        var code2;
        if (has2(entities2, name)) {
          return entities2[name];
        }
        if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {
          code2 = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
          if (isValidEntityCode2(code2)) {
            return fromCodePoint2(code2);
          }
        }
        return match;
      }
      function unescapeMd(str) {
        if (str.indexOf("\\") < 0) {
          return str;
        }
        return str.replace(UNESCAPE_MD_RE, "$1");
      }
      function unescapeAll2(str) {
        if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
          return str;
        }
        return str.replace(UNESCAPE_ALL_RE, function(match, escaped, entity2) {
          if (escaped) {
            return escaped;
          }
          return replaceEntityPattern(match, entity2);
        });
      }
      var HTML_ESCAPE_TEST_RE = /[&<>"]/;
      var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
      var HTML_REPLACEMENTS = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;"
      };
      function replaceUnsafeChar(ch) {
        return HTML_REPLACEMENTS[ch];
      }
      function escapeHtml2(str) {
        if (HTML_ESCAPE_TEST_RE.test(str)) {
          return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
        }
        return str;
      }
      var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
      function escapeRE2(str) {
        return str.replace(REGEXP_ESCAPE_RE, "\\$&");
      }
      function isSpace2(code2) {
        switch (code2) {
          case 9:
          case 32:
            return true;
        }
        return false;
      }
      function isWhiteSpace2(code2) {
        if (code2 >= 8192 && code2 <= 8202) {
          return true;
        }
        switch (code2) {
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 32:
          case 160:
          case 5760:
          case 8239:
          case 8287:
          case 12288:
            return true;
        }
        return false;
      }
      var UNICODE_PUNCT_RE = regex$4;
      function isPunctChar2(ch) {
        return UNICODE_PUNCT_RE.test(ch);
      }
      function isMdAsciiPunct2(ch) {
        switch (ch) {
          case 33:
          case 34:
          case 35:
          case 36:
          case 37:
          case 38:
          case 39:
          case 40:
          case 41:
          case 42:
          case 43:
          case 44:
          case 45:
          case 46:
          case 47:
          case 58:
          case 59:
          case 60:
          case 61:
          case 62:
          case 63:
          case 64:
          case 91:
          case 92:
          case 93:
          case 94:
          case 95:
          case 96:
          case 123:
          case 124:
          case 125:
          case 126:
            return true;
          default:
            return false;
        }
      }
      function normalizeReference2(str) {
        str = str.trim().replace(/\s+/g, " ");
        if ("".toLowerCase() === "") {
          str = str.replace(//g, "");
        }
        return str.toLowerCase().toUpperCase();
      }
      exports2.lib = {};
      exports2.lib.mdurl = mdurl$1;
      exports2.lib.ucmicro = requireUc_micro();
      exports2.assign = assign2;
      exports2.isString = isString2;
      exports2.has = has2;
      exports2.unescapeMd = unescapeMd;
      exports2.unescapeAll = unescapeAll2;
      exports2.isValidEntityCode = isValidEntityCode2;
      exports2.fromCodePoint = fromCodePoint2;
      exports2.escapeHtml = escapeHtml2;
      exports2.arrayReplaceAt = arrayReplaceAt2;
      exports2.isSpace = isSpace2;
      exports2.isWhiteSpace = isWhiteSpace2;
      exports2.isMdAsciiPunct = isMdAsciiPunct2;
      exports2.isPunctChar = isPunctChar2;
      exports2.escapeRE = escapeRE2;
      exports2.normalizeReference = normalizeReference2;
    })(utils$1);
    var helpers$1 = {};
    var parse_link_label = function parseLinkLabel(state, start, disableNested) {
      var level, found, marker2, prevPos, labelEnd = -1, max = state.posMax, oldPos = state.pos;
      state.pos = start + 1;
      level = 1;
      while (state.pos < max) {
        marker2 = state.src.charCodeAt(state.pos);
        if (marker2 === 93) {
          level--;
          if (level === 0) {
            found = true;
            break;
          }
        }
        prevPos = state.pos;
        state.md.inline.skipToken(state);
        if (marker2 === 91) {
          if (prevPos === state.pos - 1) {
            level++;
          } else if (disableNested) {
            state.pos = oldPos;
            return -1;
          }
        }
      }
      if (found) {
        labelEnd = state.pos;
      }
      state.pos = oldPos;
      return labelEnd;
    };
    var unescapeAll$2 = utils$1.unescapeAll;
    var parse_link_destination = function parseLinkDestination(str, start, max) {
      var code2, level, pos = start, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (str.charCodeAt(pos) === 60) {
        pos++;
        while (pos < max) {
          code2 = str.charCodeAt(pos);
          if (code2 === 10) {
            return result;
          }
          if (code2 === 60) {
            return result;
          }
          if (code2 === 62) {
            result.pos = pos + 1;
            result.str = unescapeAll$2(str.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
          if (code2 === 92 && pos + 1 < max) {
            pos += 2;
            continue;
          }
          pos++;
        }
        return result;
      }
      level = 0;
      while (pos < max) {
        code2 = str.charCodeAt(pos);
        if (code2 === 32) {
          break;
        }
        if (code2 < 32 || code2 === 127) {
          break;
        }
        if (code2 === 92 && pos + 1 < max) {
          if (str.charCodeAt(pos + 1) === 32) {
            break;
          }
          pos += 2;
          continue;
        }
        if (code2 === 40) {
          level++;
          if (level > 32) {
            return result;
          }
        }
        if (code2 === 41) {
          if (level === 0) {
            break;
          }
          level--;
        }
        pos++;
      }
      if (start === pos) {
        return result;
      }
      if (level !== 0) {
        return result;
      }
      result.str = unescapeAll$2(str.slice(start, pos));
      result.pos = pos;
      result.ok = true;
      return result;
    };
    var unescapeAll$1 = utils$1.unescapeAll;
    var parse_link_title = function parseLinkTitle(str, start, max) {
      var code2, marker2, lines = 0, pos = start, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (pos >= max) {
        return result;
      }
      marker2 = str.charCodeAt(pos);
      if (marker2 !== 34 && marker2 !== 39 && marker2 !== 40) {
        return result;
      }
      pos++;
      if (marker2 === 40) {
        marker2 = 41;
      }
      while (pos < max) {
        code2 = str.charCodeAt(pos);
        if (code2 === marker2) {
          result.pos = pos + 1;
          result.lines = lines;
          result.str = unescapeAll$1(str.slice(start + 1, pos));
          result.ok = true;
          return result;
        } else if (code2 === 40 && marker2 === 41) {
          return result;
        } else if (code2 === 10) {
          lines++;
        } else if (code2 === 92 && pos + 1 < max) {
          pos++;
          if (str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
        pos++;
      }
      return result;
    };
    helpers$1.parseLinkLabel = parse_link_label;
    helpers$1.parseLinkDestination = parse_link_destination;
    helpers$1.parseLinkTitle = parse_link_title;
    var assign$1 = utils$1.assign;
    var unescapeAll = utils$1.unescapeAll;
    var escapeHtml = utils$1.escapeHtml;
    var default_rules = {};
    default_rules.code_inline = function(tokens, idx, options, env, slf) {
      var token2 = tokens[idx];
      return "<code" + slf.renderAttrs(token2) + ">" + escapeHtml(token2.content) + "</code>";
    };
    default_rules.code_block = function(tokens, idx, options, env, slf) {
      var token2 = tokens[idx];
      return "<pre" + slf.renderAttrs(token2) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
    };
    default_rules.fence = function(tokens, idx, options, env, slf) {
      var token2 = tokens[idx], info = token2.info ? unescapeAll(token2.info).trim() : "", langName = "", langAttrs = "", highlighted, i2, arr, tmpAttrs, tmpToken;
      if (info) {
        arr = info.split(/(\s+)/g);
        langName = arr[0];
        langAttrs = arr.slice(2).join("");
      }
      if (options.highlight) {
        highlighted = options.highlight(token2.content, langName, langAttrs) || escapeHtml(token2.content);
      } else {
        highlighted = escapeHtml(token2.content);
      }
      if (highlighted.indexOf("<pre") === 0) {
        return highlighted + "\n";
      }
      if (info) {
        i2 = token2.attrIndex("class");
        tmpAttrs = token2.attrs ? token2.attrs.slice() : [];
        if (i2 < 0) {
          tmpAttrs.push(["class", options.langPrefix + langName]);
        } else {
          tmpAttrs[i2] = tmpAttrs[i2].slice();
          tmpAttrs[i2][1] += " " + options.langPrefix + langName;
        }
        tmpToken = {
          attrs: tmpAttrs
        };
        return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
      }
      return "<pre><code" + slf.renderAttrs(token2) + ">" + highlighted + "</code></pre>\n";
    };
    default_rules.image = function(tokens, idx, options, env, slf) {
      var token2 = tokens[idx];
      token2.attrs[token2.attrIndex("alt")][1] = slf.renderInlineAsText(token2.children, options, env);
      return slf.renderToken(tokens, idx, options);
    };
    default_rules.hardbreak = function(tokens, idx, options) {
      return options.xhtmlOut ? "<br />\n" : "<br>\n";
    };
    default_rules.softbreak = function(tokens, idx, options) {
      return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
    };
    default_rules.text = function(tokens, idx) {
      return escapeHtml(tokens[idx].content);
    };
    default_rules.html_block = function(tokens, idx) {
      return tokens[idx].content;
    };
    default_rules.html_inline = function(tokens, idx) {
      return tokens[idx].content;
    };
    function Renderer$1() {
      this.rules = assign$1({}, default_rules);
    }
    Renderer$1.prototype.renderAttrs = function renderAttrs(token2) {
      var i2, l, result;
      if (!token2.attrs) {
        return "";
      }
      result = "";
      for (i2 = 0, l = token2.attrs.length; i2 < l; i2++) {
        result += " " + escapeHtml(token2.attrs[i2][0]) + '="' + escapeHtml(token2.attrs[i2][1]) + '"';
      }
      return result;
    };
    Renderer$1.prototype.renderToken = function renderToken(tokens, idx, options) {
      var nextToken, result = "", needLf = false, token2 = tokens[idx];
      if (token2.hidden) {
        return "";
      }
      if (token2.block && token2.nesting !== -1 && idx && tokens[idx - 1].hidden) {
        result += "\n";
      }
      result += (token2.nesting === -1 ? "</" : "<") + token2.tag;
      result += this.renderAttrs(token2);
      if (token2.nesting === 0 && options.xhtmlOut) {
        result += " /";
      }
      if (token2.block) {
        needLf = true;
        if (token2.nesting === 1) {
          if (idx + 1 < tokens.length) {
            nextToken = tokens[idx + 1];
            if (nextToken.type === "inline" || nextToken.hidden) {
              needLf = false;
            } else if (nextToken.nesting === -1 && nextToken.tag === token2.tag) {
              needLf = false;
            }
          }
        }
      }
      result += needLf ? ">\n" : ">";
      return result;
    };
    Renderer$1.prototype.renderInline = function(tokens, options, env) {
      var type2, result = "", rules2 = this.rules;
      for (var i2 = 0, len = tokens.length; i2 < len; i2++) {
        type2 = tokens[i2].type;
        if (typeof rules2[type2] !== "undefined") {
          result += rules2[type2](tokens, i2, options, env, this);
        } else {
          result += this.renderToken(tokens, i2, options);
        }
      }
      return result;
    };
    Renderer$1.prototype.renderInlineAsText = function(tokens, options, env) {
      var result = "";
      for (var i2 = 0, len = tokens.length; i2 < len; i2++) {
        if (tokens[i2].type === "text") {
          result += tokens[i2].content;
        } else if (tokens[i2].type === "image") {
          result += this.renderInlineAsText(tokens[i2].children, options, env);
        } else if (tokens[i2].type === "softbreak") {
          result += "\n";
        }
      }
      return result;
    };
    Renderer$1.prototype.render = function(tokens, options, env) {
      var i2, len, type2, result = "", rules2 = this.rules;
      for (i2 = 0, len = tokens.length; i2 < len; i2++) {
        type2 = tokens[i2].type;
        if (type2 === "inline") {
          result += this.renderInline(tokens[i2].children, options, env);
        } else if (typeof rules2[type2] !== "undefined") {
          result += rules2[type2](tokens, i2, options, env, this);
        } else {
          result += this.renderToken(tokens, i2, options, env);
        }
      }
      return result;
    };
    var renderer = Renderer$1;
    function Ruler$3() {
      this.__rules__ = [];
      this.__cache__ = null;
    }
    Ruler$3.prototype.__find__ = function(name) {
      for (var i2 = 0; i2 < this.__rules__.length; i2++) {
        if (this.__rules__[i2].name === name) {
          return i2;
        }
      }
      return -1;
    };
    Ruler$3.prototype.__compile__ = function() {
      var self2 = this;
      var chains = [""];
      self2.__rules__.forEach(function(rule) {
        if (!rule.enabled) {
          return;
        }
        rule.alt.forEach(function(altName) {
          if (chains.indexOf(altName) < 0) {
            chains.push(altName);
          }
        });
      });
      self2.__cache__ = {};
      chains.forEach(function(chain) {
        self2.__cache__[chain] = [];
        self2.__rules__.forEach(function(rule) {
          if (!rule.enabled) {
            return;
          }
          if (chain && rule.alt.indexOf(chain) < 0) {
            return;
          }
          self2.__cache__[chain].push(rule.fn);
        });
      });
    };
    Ruler$3.prototype.at = function(name, fn, options) {
      var index = this.__find__(name);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + name);
      }
      this.__rules__[index].fn = fn;
      this.__rules__[index].alt = opt.alt || [];
      this.__cache__ = null;
    };
    Ruler$3.prototype.before = function(beforeName, ruleName, fn, options) {
      var index = this.__find__(beforeName);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + beforeName);
      }
      this.__rules__.splice(index, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler$3.prototype.after = function(afterName, ruleName, fn, options) {
      var index = this.__find__(afterName);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + afterName);
      }
      this.__rules__.splice(index + 1, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler$3.prototype.push = function(ruleName, fn, options) {
      var opt = options || {};
      this.__rules__.push({
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler$3.prototype.enable = function(list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      var result = [];
      list2.forEach(function(name) {
        var idx = this.__find__(name);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name);
        }
        this.__rules__[idx].enabled = true;
        result.push(name);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler$3.prototype.enableOnly = function(list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      this.__rules__.forEach(function(rule) {
        rule.enabled = false;
      });
      this.enable(list2, ignoreInvalid);
    };
    Ruler$3.prototype.disable = function(list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      var result = [];
      list2.forEach(function(name) {
        var idx = this.__find__(name);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name);
        }
        this.__rules__[idx].enabled = false;
        result.push(name);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler$3.prototype.getRules = function(chainName) {
      if (this.__cache__ === null) {
        this.__compile__();
      }
      return this.__cache__[chainName] || [];
    };
    var ruler = Ruler$3;
    var NEWLINES_RE = /\r\n?|\n/g;
    var NULL_RE = /\0/g;
    var normalize = function normalize2(state) {
      var str;
      str = state.src.replace(NEWLINES_RE, "\n");
      str = str.replace(NULL_RE, "");
      state.src = str;
    };
    var block = function block2(state) {
      var token2;
      if (state.inlineMode) {
        token2 = new state.Token("inline", "", 0);
        token2.content = state.src;
        token2.map = [0, 1];
        token2.children = [];
        state.tokens.push(token2);
      } else {
        state.md.block.parse(state.src, state.md, state.env, state.tokens);
      }
    };
    var inline = function inline2(state) {
      var tokens = state.tokens, tok, i2, l;
      for (i2 = 0, l = tokens.length; i2 < l; i2++) {
        tok = tokens[i2];
        if (tok.type === "inline") {
          state.md.inline.parse(tok.content, state.md, state.env, tok.children);
        }
      }
    };
    var arrayReplaceAt = utils$1.arrayReplaceAt;
    function isLinkOpen$1(str) {
      return /^<a[>\s]/i.test(str);
    }
    function isLinkClose$1(str) {
      return /^<\/a\s*>/i.test(str);
    }
    var linkify$1 = function linkify2(state) {
      var i2, j, l, tokens, token2, currentToken, nodes, ln, text2, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;
      if (!state.md.options.linkify) {
        return;
      }
      for (j = 0, l = blockTokens.length; j < l; j++) {
        if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
          continue;
        }
        tokens = blockTokens[j].children;
        htmlLinkLevel = 0;
        for (i2 = tokens.length - 1; i2 >= 0; i2--) {
          currentToken = tokens[i2];
          if (currentToken.type === "link_close") {
            i2--;
            while (tokens[i2].level !== currentToken.level && tokens[i2].type !== "link_open") {
              i2--;
            }
            continue;
          }
          if (currentToken.type === "html_inline") {
            if (isLinkOpen$1(currentToken.content) && htmlLinkLevel > 0) {
              htmlLinkLevel--;
            }
            if (isLinkClose$1(currentToken.content)) {
              htmlLinkLevel++;
            }
          }
          if (htmlLinkLevel > 0) {
            continue;
          }
          if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
            text2 = currentToken.content;
            links = state.md.linkify.match(text2);
            nodes = [];
            level = currentToken.level;
            lastPos = 0;
            if (links.length > 0 && links[0].index === 0 && i2 > 0 && tokens[i2 - 1].type === "text_special") {
              links = links.slice(1);
            }
            for (ln = 0; ln < links.length; ln++) {
              url = links[ln].url;
              fullUrl = state.md.normalizeLink(url);
              if (!state.md.validateLink(fullUrl)) {
                continue;
              }
              urlText = links[ln].text;
              if (!links[ln].schema) {
                urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
              } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
                urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
              } else {
                urlText = state.md.normalizeLinkText(urlText);
              }
              pos = links[ln].index;
              if (pos > lastPos) {
                token2 = new state.Token("text", "", 0);
                token2.content = text2.slice(lastPos, pos);
                token2.level = level;
                nodes.push(token2);
              }
              token2 = new state.Token("link_open", "a", 1);
              token2.attrs = [["href", fullUrl]];
              token2.level = level++;
              token2.markup = "linkify";
              token2.info = "auto";
              nodes.push(token2);
              token2 = new state.Token("text", "", 0);
              token2.content = urlText;
              token2.level = level;
              nodes.push(token2);
              token2 = new state.Token("link_close", "a", -1);
              token2.level = --level;
              token2.markup = "linkify";
              token2.info = "auto";
              nodes.push(token2);
              lastPos = links[ln].lastIndex;
            }
            if (lastPos < text2.length) {
              token2 = new state.Token("text", "", 0);
              token2.content = text2.slice(lastPos);
              token2.level = level;
              nodes.push(token2);
            }
            blockTokens[j].children = tokens = arrayReplaceAt(tokens, i2, nodes);
          }
        }
      }
    };
    var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
    var SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
    var SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
    var SCOPED_ABBR = {
      c: "",
      r: "",
      tm: ""
    };
    function replaceFn(match, name) {
      return SCOPED_ABBR[name.toLowerCase()];
    }
    function replace_scoped(inlineTokens) {
      var i2, token2, inside_autolink = 0;
      for (i2 = inlineTokens.length - 1; i2 >= 0; i2--) {
        token2 = inlineTokens[i2];
        if (token2.type === "text" && !inside_autolink) {
          token2.content = token2.content.replace(SCOPED_ABBR_RE, replaceFn);
        }
        if (token2.type === "link_open" && token2.info === "auto") {
          inside_autolink--;
        }
        if (token2.type === "link_close" && token2.info === "auto") {
          inside_autolink++;
        }
      }
    }
    function replace_rare(inlineTokens) {
      var i2, token2, inside_autolink = 0;
      for (i2 = inlineTokens.length - 1; i2 >= 0; i2--) {
        token2 = inlineTokens[i2];
        if (token2.type === "text" && !inside_autolink) {
          if (RARE_RE.test(token2.content)) {
            token2.content = token2.content.replace(/\+-/g, "").replace(/\.{2,}/g, "").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1").replace(/(^|\s)--(?=\s|$)/mg, "$1").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1");
          }
        }
        if (token2.type === "link_open" && token2.info === "auto") {
          inside_autolink--;
        }
        if (token2.type === "link_close" && token2.info === "auto") {
          inside_autolink++;
        }
      }
    }
    var replacements = function replace2(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline") {
          continue;
        }
        if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
          replace_scoped(state.tokens[blkIdx].children);
        }
        if (RARE_RE.test(state.tokens[blkIdx].content)) {
          replace_rare(state.tokens[blkIdx].children);
        }
      }
    };
    var isWhiteSpace$1 = utils$1.isWhiteSpace;
    var isPunctChar$1 = utils$1.isPunctChar;
    var isMdAsciiPunct$1 = utils$1.isMdAsciiPunct;
    var QUOTE_TEST_RE = /['"]/;
    var QUOTE_RE = /['"]/g;
    var APOSTROPHE = "";
    function replaceAt(str, index, ch) {
      return str.slice(0, index) + ch + str.slice(index + 1);
    }
    function process_inlines(tokens, state) {
      var i2, token2, text2, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack2, openQuote, closeQuote;
      stack2 = [];
      for (i2 = 0; i2 < tokens.length; i2++) {
        token2 = tokens[i2];
        thisLevel = tokens[i2].level;
        for (j = stack2.length - 1; j >= 0; j--) {
          if (stack2[j].level <= thisLevel) {
            break;
          }
        }
        stack2.length = j + 1;
        if (token2.type !== "text") {
          continue;
        }
        text2 = token2.content;
        pos = 0;
        max = text2.length;
        OUTER:
          while (pos < max) {
            QUOTE_RE.lastIndex = pos;
            t = QUOTE_RE.exec(text2);
            if (!t) {
              break;
            }
            canOpen = canClose = true;
            pos = t.index + 1;
            isSingle = t[0] === "'";
            lastChar = 32;
            if (t.index - 1 >= 0) {
              lastChar = text2.charCodeAt(t.index - 1);
            } else {
              for (j = i2 - 1; j >= 0; j--) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
                break;
              }
            }
            nextChar = 32;
            if (pos < max) {
              nextChar = text2.charCodeAt(pos);
            } else {
              for (j = i2 + 1; j < tokens.length; j++) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                nextChar = tokens[j].content.charCodeAt(0);
                break;
              }
            }
            isLastPunctChar = isMdAsciiPunct$1(lastChar) || isPunctChar$1(String.fromCharCode(lastChar));
            isNextPunctChar = isMdAsciiPunct$1(nextChar) || isPunctChar$1(String.fromCharCode(nextChar));
            isLastWhiteSpace = isWhiteSpace$1(lastChar);
            isNextWhiteSpace = isWhiteSpace$1(nextChar);
            if (isNextWhiteSpace) {
              canOpen = false;
            } else if (isNextPunctChar) {
              if (!(isLastWhiteSpace || isLastPunctChar)) {
                canOpen = false;
              }
            }
            if (isLastWhiteSpace) {
              canClose = false;
            } else if (isLastPunctChar) {
              if (!(isNextWhiteSpace || isNextPunctChar)) {
                canClose = false;
              }
            }
            if (nextChar === 34 && t[0] === '"') {
              if (lastChar >= 48 && lastChar <= 57) {
                canClose = canOpen = false;
              }
            }
            if (canOpen && canClose) {
              canOpen = isLastPunctChar;
              canClose = isNextPunctChar;
            }
            if (!canOpen && !canClose) {
              if (isSingle) {
                token2.content = replaceAt(token2.content, t.index, APOSTROPHE);
              }
              continue;
            }
            if (canClose) {
              for (j = stack2.length - 1; j >= 0; j--) {
                item = stack2[j];
                if (stack2[j].level < thisLevel) {
                  break;
                }
                if (item.single === isSingle && stack2[j].level === thisLevel) {
                  item = stack2[j];
                  if (isSingle) {
                    openQuote = state.md.options.quotes[2];
                    closeQuote = state.md.options.quotes[3];
                  } else {
                    openQuote = state.md.options.quotes[0];
                    closeQuote = state.md.options.quotes[1];
                  }
                  token2.content = replaceAt(token2.content, t.index, closeQuote);
                  tokens[item.token].content = replaceAt(
                    tokens[item.token].content,
                    item.pos,
                    openQuote
                  );
                  pos += closeQuote.length - 1;
                  if (item.token === i2) {
                    pos += openQuote.length - 1;
                  }
                  text2 = token2.content;
                  max = text2.length;
                  stack2.length = j;
                  continue OUTER;
                }
              }
            }
            if (canOpen) {
              stack2.push({
                token: i2,
                pos: t.index,
                single: isSingle,
                level: thisLevel
              });
            } else if (canClose && isSingle) {
              token2.content = replaceAt(token2.content, t.index, APOSTROPHE);
            }
          }
      }
    }
    var smartquotes = function smartquotes2(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
          continue;
        }
        process_inlines(state.tokens[blkIdx].children, state);
      }
    };
    var text_join = function text_join2(state) {
      var j, l, tokens, curr, max, last, blockTokens = state.tokens;
      for (j = 0, l = blockTokens.length; j < l; j++) {
        if (blockTokens[j].type !== "inline")
          continue;
        tokens = blockTokens[j].children;
        max = tokens.length;
        for (curr = 0; curr < max; curr++) {
          if (tokens[curr].type === "text_special") {
            tokens[curr].type = "text";
          }
        }
        for (curr = last = 0; curr < max; curr++) {
          if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
            tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
          } else {
            if (curr !== last) {
              tokens[last] = tokens[curr];
            }
            last++;
          }
        }
        if (curr !== last) {
          tokens.length = last;
        }
      }
    };
    function Token$3(type2, tag, nesting) {
      this.type = type2;
      this.tag = tag;
      this.attrs = null;
      this.map = null;
      this.nesting = nesting;
      this.level = 0;
      this.children = null;
      this.content = "";
      this.markup = "";
      this.info = "";
      this.meta = null;
      this.block = false;
      this.hidden = false;
    }
    Token$3.prototype.attrIndex = function attrIndex(name) {
      var attrs, i2, len;
      if (!this.attrs) {
        return -1;
      }
      attrs = this.attrs;
      for (i2 = 0, len = attrs.length; i2 < len; i2++) {
        if (attrs[i2][0] === name) {
          return i2;
        }
      }
      return -1;
    };
    Token$3.prototype.attrPush = function attrPush(attrData) {
      if (this.attrs) {
        this.attrs.push(attrData);
      } else {
        this.attrs = [attrData];
      }
    };
    Token$3.prototype.attrSet = function attrSet(name, value) {
      var idx = this.attrIndex(name), attrData = [name, value];
      if (idx < 0) {
        this.attrPush(attrData);
      } else {
        this.attrs[idx] = attrData;
      }
    };
    Token$3.prototype.attrGet = function attrGet(name) {
      var idx = this.attrIndex(name), value = null;
      if (idx >= 0) {
        value = this.attrs[idx][1];
      }
      return value;
    };
    Token$3.prototype.attrJoin = function attrJoin(name, value) {
      var idx = this.attrIndex(name);
      if (idx < 0) {
        this.attrPush([name, value]);
      } else {
        this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
      }
    };
    var token = Token$3;
    var Token$2 = token;
    function StateCore(src, md, env) {
      this.src = src;
      this.env = env;
      this.tokens = [];
      this.inlineMode = false;
      this.md = md;
    }
    StateCore.prototype.Token = Token$2;
    var state_core = StateCore;
    var Ruler$2 = ruler;
    var _rules$2 = [
      ["normalize", normalize],
      ["block", block],
      ["inline", inline],
      ["linkify", linkify$1],
      ["replacements", replacements],
      ["smartquotes", smartquotes],
      // `text_join` finds `text_special` tokens (for escape sequences)
      // and joins them with the rest of the text
      ["text_join", text_join]
    ];
    function Core() {
      this.ruler = new Ruler$2();
      for (var i2 = 0; i2 < _rules$2.length; i2++) {
        this.ruler.push(_rules$2[i2][0], _rules$2[i2][1]);
      }
    }
    Core.prototype.process = function(state) {
      var i2, l, rules2;
      rules2 = this.ruler.getRules("");
      for (i2 = 0, l = rules2.length; i2 < l; i2++) {
        rules2[i2](state);
      }
    };
    Core.prototype.State = state_core;
    var parser_core = Core;
    var isSpace$a = utils$1.isSpace;
    function getLine(state, line) {
      var pos = state.bMarks[line] + state.tShift[line], max = state.eMarks[line];
      return state.src.slice(pos, max);
    }
    function escapedSplit(str) {
      var result = [], pos = 0, max = str.length, ch, isEscaped = false, lastPos = 0, current2 = "";
      ch = str.charCodeAt(pos);
      while (pos < max) {
        if (ch === 124) {
          if (!isEscaped) {
            result.push(current2 + str.substring(lastPos, pos));
            current2 = "";
            lastPos = pos + 1;
          } else {
            current2 += str.substring(lastPos, pos - 1);
            lastPos = pos;
          }
        }
        isEscaped = ch === 92;
        pos++;
        ch = str.charCodeAt(pos);
      }
      result.push(current2 + str.substring(lastPos));
      return result;
    }
    var table = function table2(state, startLine, endLine, silent) {
      var ch, lineText, pos, i2, l, nextLine, columns, columnCount, token2, aligns, t, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
      if (startLine + 2 > endLine) {
        return false;
      }
      nextLine = startLine + 1;
      if (state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      firstCh = state.src.charCodeAt(pos++);
      if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
        return false;
      }
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      secondCh = state.src.charCodeAt(pos++);
      if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace$a(secondCh)) {
        return false;
      }
      if (firstCh === 45 && isSpace$a(secondCh)) {
        return false;
      }
      while (pos < state.eMarks[nextLine]) {
        ch = state.src.charCodeAt(pos);
        if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace$a(ch)) {
          return false;
        }
        pos++;
      }
      lineText = getLine(state, startLine + 1);
      columns = lineText.split("|");
      aligns = [];
      for (i2 = 0; i2 < columns.length; i2++) {
        t = columns[i2].trim();
        if (!t) {
          if (i2 === 0 || i2 === columns.length - 1) {
            continue;
          } else {
            return false;
          }
        }
        if (!/^:?-+:?$/.test(t)) {
          return false;
        }
        if (t.charCodeAt(t.length - 1) === 58) {
          aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
        } else if (t.charCodeAt(0) === 58) {
          aligns.push("left");
        } else {
          aligns.push("");
        }
      }
      lineText = getLine(state, startLine).trim();
      if (lineText.indexOf("|") === -1) {
        return false;
      }
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      columns = escapedSplit(lineText);
      if (columns.length && columns[0] === "")
        columns.shift();
      if (columns.length && columns[columns.length - 1] === "")
        columns.pop();
      columnCount = columns.length;
      if (columnCount === 0 || columnCount !== aligns.length) {
        return false;
      }
      if (silent) {
        return true;
      }
      oldParentType = state.parentType;
      state.parentType = "table";
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      token2 = state.push("table_open", "table", 1);
      token2.map = tableLines = [startLine, 0];
      token2 = state.push("thead_open", "thead", 1);
      token2.map = [startLine, startLine + 1];
      token2 = state.push("tr_open", "tr", 1);
      token2.map = [startLine, startLine + 1];
      for (i2 = 0; i2 < columns.length; i2++) {
        token2 = state.push("th_open", "th", 1);
        if (aligns[i2]) {
          token2.attrs = [["style", "text-align:" + aligns[i2]]];
        }
        token2 = state.push("inline", "", 0);
        token2.content = columns[i2].trim();
        token2.children = [];
        token2 = state.push("th_close", "th", -1);
      }
      token2 = state.push("tr_close", "tr", -1);
      token2 = state.push("thead_close", "thead", -1);
      for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        terminate = false;
        for (i2 = 0, l = terminatorRules.length; i2 < l; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        lineText = getLine(state, nextLine).trim();
        if (!lineText) {
          break;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        columns = escapedSplit(lineText);
        if (columns.length && columns[0] === "")
          columns.shift();
        if (columns.length && columns[columns.length - 1] === "")
          columns.pop();
        if (nextLine === startLine + 2) {
          token2 = state.push("tbody_open", "tbody", 1);
          token2.map = tbodyLines = [startLine + 2, 0];
        }
        token2 = state.push("tr_open", "tr", 1);
        token2.map = [nextLine, nextLine + 1];
        for (i2 = 0; i2 < columnCount; i2++) {
          token2 = state.push("td_open", "td", 1);
          if (aligns[i2]) {
            token2.attrs = [["style", "text-align:" + aligns[i2]]];
          }
          token2 = state.push("inline", "", 0);
          token2.content = columns[i2] ? columns[i2].trim() : "";
          token2.children = [];
          token2 = state.push("td_close", "td", -1);
        }
        token2 = state.push("tr_close", "tr", -1);
      }
      if (tbodyLines) {
        token2 = state.push("tbody_close", "tbody", -1);
        tbodyLines[1] = nextLine;
      }
      token2 = state.push("table_close", "table", -1);
      tableLines[1] = nextLine;
      state.parentType = oldParentType;
      state.line = nextLine;
      return true;
    };
    var code = function code2(state, startLine, endLine) {
      var nextLine, last, token2;
      if (state.sCount[startLine] - state.blkIndent < 4) {
        return false;
      }
      last = nextLine = startLine + 1;
      while (nextLine < endLine) {
        if (state.isEmpty(nextLine)) {
          nextLine++;
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          nextLine++;
          last = nextLine;
          continue;
        }
        break;
      }
      state.line = last;
      token2 = state.push("code_block", "code", 0);
      token2.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
      token2.map = [startLine, state.line];
      return true;
    };
    var fence = function fence2(state, startLine, endLine, silent) {
      var marker2, len, params, nextLine, mem, token2, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (pos + 3 > max) {
        return false;
      }
      marker2 = state.src.charCodeAt(pos);
      if (marker2 !== 126 && marker2 !== 96) {
        return false;
      }
      mem = pos;
      pos = state.skipChars(pos, marker2);
      len = pos - mem;
      if (len < 3) {
        return false;
      }
      markup = state.src.slice(mem, pos);
      params = state.src.slice(pos, max);
      if (marker2 === 96) {
        if (params.indexOf(String.fromCharCode(marker2)) >= 0) {
          return false;
        }
      }
      if (silent) {
        return true;
      }
      nextLine = startLine;
      for (; ; ) {
        nextLine++;
        if (nextLine >= endLine) {
          break;
        }
        pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos < max && state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.src.charCodeAt(pos) !== marker2) {
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          continue;
        }
        pos = state.skipChars(pos, marker2);
        if (pos - mem < len) {
          continue;
        }
        pos = state.skipSpaces(pos);
        if (pos < max) {
          continue;
        }
        haveEndMarker = true;
        break;
      }
      len = state.sCount[startLine];
      state.line = nextLine + (haveEndMarker ? 1 : 0);
      token2 = state.push("fence", "code", 0);
      token2.info = params;
      token2.content = state.getLines(startLine + 1, nextLine, len, true);
      token2.markup = markup;
      token2.map = [startLine, state.line];
      return true;
    };
    var isSpace$9 = utils$1.isSpace;
    var blockquote = function blockquote2(state, startLine, endLine, silent) {
      var adjustTab, ch, i2, initial, l, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token2, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 62) {
        return false;
      }
      if (silent) {
        return true;
      }
      oldBMarks = [];
      oldBSCount = [];
      oldSCount = [];
      oldTShift = [];
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      oldParentType = state.parentType;
      state.parentType = "blockquote";
      for (nextLine = startLine; nextLine < endLine; nextLine++) {
        isOutdented = state.sCount[nextLine] < state.blkIndent;
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos >= max) {
          break;
        }
        if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
          initial = state.sCount[nextLine] + 1;
          if (state.src.charCodeAt(pos) === 32) {
            pos++;
            initial++;
            adjustTab = false;
            spaceAfterMarker = true;
          } else if (state.src.charCodeAt(pos) === 9) {
            spaceAfterMarker = true;
            if ((state.bsCount[nextLine] + initial) % 4 === 3) {
              pos++;
              initial++;
              adjustTab = false;
            } else {
              adjustTab = true;
            }
          } else {
            spaceAfterMarker = false;
          }
          offset = initial;
          oldBMarks.push(state.bMarks[nextLine]);
          state.bMarks[nextLine] = pos;
          while (pos < max) {
            ch = state.src.charCodeAt(pos);
            if (isSpace$9(ch)) {
              if (ch === 9) {
                offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
              } else {
                offset++;
              }
            } else {
              break;
            }
            pos++;
          }
          lastLineEmpty = pos >= max;
          oldBSCount.push(state.bsCount[nextLine]);
          state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] = offset - initial;
          oldTShift.push(state.tShift[nextLine]);
          state.tShift[nextLine] = pos - state.bMarks[nextLine];
          continue;
        }
        if (lastLineEmpty) {
          break;
        }
        terminate = false;
        for (i2 = 0, l = terminatorRules.length; i2 < l; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          state.lineMax = nextLine;
          if (state.blkIndent !== 0) {
            oldBMarks.push(state.bMarks[nextLine]);
            oldBSCount.push(state.bsCount[nextLine]);
            oldTShift.push(state.tShift[nextLine]);
            oldSCount.push(state.sCount[nextLine]);
            state.sCount[nextLine] -= state.blkIndent;
          }
          break;
        }
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] = -1;
      }
      oldIndent = state.blkIndent;
      state.blkIndent = 0;
      token2 = state.push("blockquote_open", "blockquote", 1);
      token2.markup = ">";
      token2.map = lines = [startLine, 0];
      state.md.block.tokenize(state, startLine, nextLine);
      token2 = state.push("blockquote_close", "blockquote", -1);
      token2.markup = ">";
      state.lineMax = oldLineMax;
      state.parentType = oldParentType;
      lines[1] = state.line;
      for (i2 = 0; i2 < oldTShift.length; i2++) {
        state.bMarks[i2 + startLine] = oldBMarks[i2];
        state.tShift[i2 + startLine] = oldTShift[i2];
        state.sCount[i2 + startLine] = oldSCount[i2];
        state.bsCount[i2 + startLine] = oldBSCount[i2];
      }
      state.blkIndent = oldIndent;
      return true;
    };
    var isSpace$8 = utils$1.isSpace;
    var hr = function hr2(state, startLine, endLine, silent) {
      var marker2, cnt, ch, token2, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      marker2 = state.src.charCodeAt(pos++);
      if (marker2 !== 42 && marker2 !== 45 && marker2 !== 95) {
        return false;
      }
      cnt = 1;
      while (pos < max) {
        ch = state.src.charCodeAt(pos++);
        if (ch !== marker2 && !isSpace$8(ch)) {
          return false;
        }
        if (ch === marker2) {
          cnt++;
        }
      }
      if (cnt < 3) {
        return false;
      }
      if (silent) {
        return true;
      }
      state.line = startLine + 1;
      token2 = state.push("hr", "hr", 0);
      token2.map = [startLine, state.line];
      token2.markup = Array(cnt + 1).join(String.fromCharCode(marker2));
      return true;
    };
    var isSpace$7 = utils$1.isSpace;
    function skipBulletListMarker(state, startLine) {
      var marker2, pos, max, ch;
      pos = state.bMarks[startLine] + state.tShift[startLine];
      max = state.eMarks[startLine];
      marker2 = state.src.charCodeAt(pos++);
      if (marker2 !== 42 && marker2 !== 45 && marker2 !== 43) {
        return -1;
      }
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace$7(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function skipOrderedListMarker(state, startLine) {
      var ch, start = state.bMarks[startLine] + state.tShift[startLine], pos = start, max = state.eMarks[startLine];
      if (pos + 1 >= max) {
        return -1;
      }
      ch = state.src.charCodeAt(pos++);
      if (ch < 48 || ch > 57) {
        return -1;
      }
      for (; ; ) {
        if (pos >= max) {
          return -1;
        }
        ch = state.src.charCodeAt(pos++);
        if (ch >= 48 && ch <= 57) {
          if (pos - start >= 10) {
            return -1;
          }
          continue;
        }
        if (ch === 41 || ch === 46) {
          break;
        }
        return -1;
      }
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace$7(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function markTightParagraphs(state, idx) {
      var i2, l, level = state.level + 2;
      for (i2 = idx + 2, l = state.tokens.length - 2; i2 < l; i2++) {
        if (state.tokens[i2].level === level && state.tokens[i2].type === "paragraph_open") {
          state.tokens[i2 + 2].hidden = true;
          state.tokens[i2].hidden = true;
          i2 += 2;
        }
      }
    }
    var list = function list2(state, startLine, endLine, silent) {
      var ch, contentStart, i2, indent, indentAfterMarker, initial, isOrdered, itemLines, l, listLines, listTokIdx, markerCharCode, markerValue, max, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start, terminate, terminatorRules, token2, nextLine = startLine, isTerminatingParagraph = false, tight = true;
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.listIndent >= 0 && state.sCount[nextLine] - state.listIndent >= 4 && state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      if (silent && state.parentType === "paragraph") {
        if (state.sCount[nextLine] >= state.blkIndent) {
          isTerminatingParagraph = true;
        }
      }
      if ((posAfterMarker = skipOrderedListMarker(state, nextLine)) >= 0) {
        isOrdered = true;
        start = state.bMarks[nextLine] + state.tShift[nextLine];
        markerValue = Number(state.src.slice(start, posAfterMarker - 1));
        if (isTerminatingParagraph && markerValue !== 1)
          return false;
      } else if ((posAfterMarker = skipBulletListMarker(state, nextLine)) >= 0) {
        isOrdered = false;
      } else {
        return false;
      }
      if (isTerminatingParagraph) {
        if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine])
          return false;
      }
      if (silent) {
        return true;
      }
      markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
      listTokIdx = state.tokens.length;
      if (isOrdered) {
        token2 = state.push("ordered_list_open", "ol", 1);
        if (markerValue !== 1) {
          token2.attrs = [["start", markerValue]];
        }
      } else {
        token2 = state.push("bullet_list_open", "ul", 1);
      }
      token2.map = listLines = [nextLine, 0];
      token2.markup = String.fromCharCode(markerCharCode);
      prevEmptyEnd = false;
      terminatorRules = state.md.block.ruler.getRules("list");
      oldParentType = state.parentType;
      state.parentType = "list";
      while (nextLine < endLine) {
        pos = posAfterMarker;
        max = state.eMarks[nextLine];
        initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine]);
        while (pos < max) {
          ch = state.src.charCodeAt(pos);
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[nextLine]) % 4;
          } else if (ch === 32) {
            offset++;
          } else {
            break;
          }
          pos++;
        }
        contentStart = pos;
        if (contentStart >= max) {
          indentAfterMarker = 1;
        } else {
          indentAfterMarker = offset - initial;
        }
        if (indentAfterMarker > 4) {
          indentAfterMarker = 1;
        }
        indent = initial + indentAfterMarker;
        token2 = state.push("list_item_open", "li", 1);
        token2.markup = String.fromCharCode(markerCharCode);
        token2.map = itemLines = [nextLine, 0];
        if (isOrdered) {
          token2.info = state.src.slice(start, posAfterMarker - 1);
        }
        oldTight = state.tight;
        oldTShift = state.tShift[nextLine];
        oldSCount = state.sCount[nextLine];
        oldListIndent = state.listIndent;
        state.listIndent = state.blkIndent;
        state.blkIndent = indent;
        state.tight = true;
        state.tShift[nextLine] = contentStart - state.bMarks[nextLine];
        state.sCount[nextLine] = offset;
        if (contentStart >= max && state.isEmpty(nextLine + 1)) {
          state.line = Math.min(state.line + 2, endLine);
        } else {
          state.md.block.tokenize(state, nextLine, endLine, true);
        }
        if (!state.tight || prevEmptyEnd) {
          tight = false;
        }
        prevEmptyEnd = state.line - nextLine > 1 && state.isEmpty(state.line - 1);
        state.blkIndent = state.listIndent;
        state.listIndent = oldListIndent;
        state.tShift[nextLine] = oldTShift;
        state.sCount[nextLine] = oldSCount;
        state.tight = oldTight;
        token2 = state.push("list_item_close", "li", -1);
        token2.markup = String.fromCharCode(markerCharCode);
        nextLine = state.line;
        itemLines[1] = nextLine;
        if (nextLine >= endLine) {
          break;
        }
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        terminate = false;
        for (i2 = 0, l = terminatorRules.length; i2 < l; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        if (isOrdered) {
          posAfterMarker = skipOrderedListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
          start = state.bMarks[nextLine] + state.tShift[nextLine];
        } else {
          posAfterMarker = skipBulletListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
        }
        if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
          break;
        }
      }
      if (isOrdered) {
        token2 = state.push("ordered_list_close", "ol", -1);
      } else {
        token2 = state.push("bullet_list_close", "ul", -1);
      }
      token2.markup = String.fromCharCode(markerCharCode);
      listLines[1] = nextLine;
      state.line = nextLine;
      state.parentType = oldParentType;
      if (tight) {
        markTightParagraphs(state, listTokIdx);
      }
      return true;
    };
    var normalizeReference$2 = utils$1.normalizeReference;
    var isSpace$6 = utils$1.isSpace;
    var reference = function reference2(state, startLine, _endLine, silent) {
      var ch, destEndPos, destEndLineNo, endLine, href, i2, l, label, labelEnd, oldParentType, res, start, str, terminate, terminatorRules, title2, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine], nextLine = startLine + 1;
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 91) {
        return false;
      }
      while (++pos < max) {
        if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
          if (pos + 1 === max) {
            return false;
          }
          if (state.src.charCodeAt(pos + 1) !== 58) {
            return false;
          }
          break;
        }
      }
      endLine = state.lineMax;
      terminatorRules = state.md.block.ruler.getRules("reference");
      oldParentType = state.parentType;
      state.parentType = "reference";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i2 = 0, l = terminatorRules.length; i2 < l; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      max = str.length;
      for (pos = 1; pos < max; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 91) {
          return false;
        } else if (ch === 93) {
          labelEnd = pos;
          break;
        } else if (ch === 10) {
          lines++;
        } else if (ch === 92) {
          pos++;
          if (pos < max && str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
      }
      if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
        return false;
      }
      for (pos = labelEnd + 2; pos < max; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace$6(ch))
          ;
        else {
          break;
        }
      }
      res = state.md.helpers.parseLinkDestination(str, pos, max);
      if (!res.ok) {
        return false;
      }
      href = state.md.normalizeLink(res.str);
      if (!state.md.validateLink(href)) {
        return false;
      }
      pos = res.pos;
      lines += res.lines;
      destEndPos = pos;
      destEndLineNo = lines;
      start = pos;
      for (; pos < max; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace$6(ch))
          ;
        else {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(str, pos, max);
      if (pos < max && start !== pos && res.ok) {
        title2 = res.str;
        pos = res.pos;
        lines += res.lines;
      } else {
        title2 = "";
        pos = destEndPos;
        lines = destEndLineNo;
      }
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace$6(ch)) {
          break;
        }
        pos++;
      }
      if (pos < max && str.charCodeAt(pos) !== 10) {
        if (title2) {
          title2 = "";
          pos = destEndPos;
          lines = destEndLineNo;
          while (pos < max) {
            ch = str.charCodeAt(pos);
            if (!isSpace$6(ch)) {
              break;
            }
            pos++;
          }
        }
      }
      if (pos < max && str.charCodeAt(pos) !== 10) {
        return false;
      }
      label = normalizeReference$2(str.slice(1, labelEnd));
      if (!label) {
        return false;
      }
      if (silent) {
        return true;
      }
      if (typeof state.env.references === "undefined") {
        state.env.references = {};
      }
      if (typeof state.env.references[label] === "undefined") {
        state.env.references[label] = { title: title2, href };
      }
      state.parentType = oldParentType;
      state.line = startLine + lines + 1;
      return true;
    };
    var html_blocks = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "section",
      "source",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul"
    ];
    var html_re = {};
    var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
    var unquoted = "[^\"'=<>`\\x00-\\x20]+";
    var single_quoted = "'[^']*'";
    var double_quoted = '"[^"]*"';
    var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
    var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
    var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
    var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
    var comment = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
    var processing = "<[?][\\s\\S]*?[?]>";
    var declaration = "<![A-Z]+\\s+[^>]*>";
    var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
    var HTML_TAG_RE$1 = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
    var HTML_OPEN_CLOSE_TAG_RE$1 = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
    html_re.HTML_TAG_RE = HTML_TAG_RE$1;
    html_re.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE$1;
    var block_names = html_blocks;
    var HTML_OPEN_CLOSE_TAG_RE = html_re.HTML_OPEN_CLOSE_TAG_RE;
    var HTML_SEQUENCES = [
      [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
      [/^<!--/, /-->/, true],
      [/^<\?/, /\?>/, true],
      [/^<![A-Z]/, />/, true],
      [/^<!\[CDATA\[/, /\]\]>/, true],
      [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
      [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
    ];
    var html_block = function html_block2(state, startLine, endLine, silent) {
      var i2, nextLine, token2, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (!state.md.options.html) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      lineText = state.src.slice(pos, max);
      for (i2 = 0; i2 < HTML_SEQUENCES.length; i2++) {
        if (HTML_SEQUENCES[i2][0].test(lineText)) {
          break;
        }
      }
      if (i2 === HTML_SEQUENCES.length) {
        return false;
      }
      if (silent) {
        return HTML_SEQUENCES[i2][2];
      }
      nextLine = startLine + 1;
      if (!HTML_SEQUENCES[i2][1].test(lineText)) {
        for (; nextLine < endLine; nextLine++) {
          if (state.sCount[nextLine] < state.blkIndent) {
            break;
          }
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          lineText = state.src.slice(pos, max);
          if (HTML_SEQUENCES[i2][1].test(lineText)) {
            if (lineText.length !== 0) {
              nextLine++;
            }
            break;
          }
        }
      }
      state.line = nextLine;
      token2 = state.push("html_block", "", 0);
      token2.map = [startLine, nextLine];
      token2.content = state.getLines(startLine, nextLine, state.blkIndent, true);
      return true;
    };
    var isSpace$5 = utils$1.isSpace;
    var heading = function heading2(state, startLine, endLine, silent) {
      var ch, level, tmp, token2, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      ch = state.src.charCodeAt(pos);
      if (ch !== 35 || pos >= max) {
        return false;
      }
      level = 1;
      ch = state.src.charCodeAt(++pos);
      while (ch === 35 && pos < max && level <= 6) {
        level++;
        ch = state.src.charCodeAt(++pos);
      }
      if (level > 6 || pos < max && !isSpace$5(ch)) {
        return false;
      }
      if (silent) {
        return true;
      }
      max = state.skipSpacesBack(max, pos);
      tmp = state.skipCharsBack(max, 35, pos);
      if (tmp > pos && isSpace$5(state.src.charCodeAt(tmp - 1))) {
        max = tmp;
      }
      state.line = startLine + 1;
      token2 = state.push("heading_open", "h" + String(level), 1);
      token2.markup = "########".slice(0, level);
      token2.map = [startLine, state.line];
      token2 = state.push("inline", "", 0);
      token2.content = state.src.slice(pos, max).trim();
      token2.map = [startLine, state.line];
      token2.children = [];
      token2 = state.push("heading_close", "h" + String(level), -1);
      token2.markup = "########".slice(0, level);
      return true;
    };
    var lheading = function lheading2(state, startLine, endLine) {
      var content2, terminate, i2, l, token2, pos, max, level, marker2, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules("paragraph");
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] >= state.blkIndent) {
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          if (pos < max) {
            marker2 = state.src.charCodeAt(pos);
            if (marker2 === 45 || marker2 === 61) {
              pos = state.skipChars(pos, marker2);
              pos = state.skipSpaces(pos);
              if (pos >= max) {
                level = marker2 === 61 ? 1 : 2;
                break;
              }
            }
          }
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i2 = 0, l = terminatorRules.length; i2 < l; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      if (!level) {
        return false;
      }
      content2 = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine + 1;
      token2 = state.push("heading_open", "h" + String(level), 1);
      token2.markup = String.fromCharCode(marker2);
      token2.map = [startLine, state.line];
      token2 = state.push("inline", "", 0);
      token2.content = content2;
      token2.map = [startLine, state.line - 1];
      token2.children = [];
      token2 = state.push("heading_close", "h" + String(level), -1);
      token2.markup = String.fromCharCode(marker2);
      state.parentType = oldParentType;
      return true;
    };
    var paragraph = function paragraph2(state, startLine, endLine) {
      var content2, terminate, i2, l, token2, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph");
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i2 = 0, l = terminatorRules.length; i2 < l; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      content2 = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine;
      token2 = state.push("paragraph_open", "p", 1);
      token2.map = [startLine, state.line];
      token2 = state.push("inline", "", 0);
      token2.content = content2;
      token2.map = [startLine, state.line];
      token2.children = [];
      token2 = state.push("paragraph_close", "p", -1);
      state.parentType = oldParentType;
      return true;
    };
    var Token$1 = token;
    var isSpace$4 = utils$1.isSpace;
    function StateBlock(src, md, env, tokens) {
      var ch, s, start, pos, len, indent, offset, indent_found;
      this.src = src;
      this.md = md;
      this.env = env;
      this.tokens = tokens;
      this.bMarks = [];
      this.eMarks = [];
      this.tShift = [];
      this.sCount = [];
      this.bsCount = [];
      this.blkIndent = 0;
      this.line = 0;
      this.lineMax = 0;
      this.tight = false;
      this.ddIndent = -1;
      this.listIndent = -1;
      this.parentType = "root";
      this.level = 0;
      this.result = "";
      s = this.src;
      indent_found = false;
      for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
        ch = s.charCodeAt(pos);
        if (!indent_found) {
          if (isSpace$4(ch)) {
            indent++;
            if (ch === 9) {
              offset += 4 - offset % 4;
            } else {
              offset++;
            }
            continue;
          } else {
            indent_found = true;
          }
        }
        if (ch === 10 || pos === len - 1) {
          if (ch !== 10) {
            pos++;
          }
          this.bMarks.push(start);
          this.eMarks.push(pos);
          this.tShift.push(indent);
          this.sCount.push(offset);
          this.bsCount.push(0);
          indent_found = false;
          indent = 0;
          offset = 0;
          start = pos + 1;
        }
      }
      this.bMarks.push(s.length);
      this.eMarks.push(s.length);
      this.tShift.push(0);
      this.sCount.push(0);
      this.bsCount.push(0);
      this.lineMax = this.bMarks.length - 1;
    }
    StateBlock.prototype.push = function(type2, tag, nesting) {
      var token2 = new Token$1(type2, tag, nesting);
      token2.block = true;
      if (nesting < 0)
        this.level--;
      token2.level = this.level;
      if (nesting > 0)
        this.level++;
      this.tokens.push(token2);
      return token2;
    };
    StateBlock.prototype.isEmpty = function isEmpty(line) {
      return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
    };
    StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
      for (var max = this.lineMax; from < max; from++) {
        if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
          break;
        }
      }
      return from;
    };
    StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
      var ch;
      for (var max = this.src.length; pos < max; pos++) {
        ch = this.src.charCodeAt(pos);
        if (!isSpace$4(ch)) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (!isSpace$4(this.src.charCodeAt(--pos))) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipChars = function skipChars(pos, code2) {
      for (var max = this.src.length; pos < max; pos++) {
        if (this.src.charCodeAt(pos) !== code2) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (code2 !== this.src.charCodeAt(--pos)) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
      var i2, lineIndent, ch, first, last, queue2, lineStart, line = begin;
      if (begin >= end) {
        return "";
      }
      queue2 = new Array(end - begin);
      for (i2 = 0; line < end; line++, i2++) {
        lineIndent = 0;
        lineStart = first = this.bMarks[line];
        if (line + 1 < end || keepLastLF) {
          last = this.eMarks[line] + 1;
        } else {
          last = this.eMarks[line];
        }
        while (first < last && lineIndent < indent) {
          ch = this.src.charCodeAt(first);
          if (isSpace$4(ch)) {
            if (ch === 9) {
              lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
            } else {
              lineIndent++;
            }
          } else if (first - lineStart < this.tShift[line]) {
            lineIndent++;
          } else {
            break;
          }
          first++;
        }
        if (lineIndent > indent) {
          queue2[i2] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
        } else {
          queue2[i2] = this.src.slice(first, last);
        }
      }
      return queue2.join("");
    };
    StateBlock.prototype.Token = Token$1;
    var state_block = StateBlock;
    var Ruler$1 = ruler;
    var _rules$1 = [
      // First 2 params - rule name & source. Secondary array - list of rules,
      // which can be terminated by this one.
      ["table", table, ["paragraph", "reference"]],
      ["code", code],
      ["fence", fence, ["paragraph", "reference", "blockquote", "list"]],
      ["blockquote", blockquote, ["paragraph", "reference", "blockquote", "list"]],
      ["hr", hr, ["paragraph", "reference", "blockquote", "list"]],
      ["list", list, ["paragraph", "reference", "blockquote"]],
      ["reference", reference],
      ["html_block", html_block, ["paragraph", "reference", "blockquote"]],
      ["heading", heading, ["paragraph", "reference", "blockquote"]],
      ["lheading", lheading],
      ["paragraph", paragraph]
    ];
    function ParserBlock$1() {
      this.ruler = new Ruler$1();
      for (var i2 = 0; i2 < _rules$1.length; i2++) {
        this.ruler.push(_rules$1[i2][0], _rules$1[i2][1], { alt: (_rules$1[i2][2] || []).slice() });
      }
    }
    ParserBlock$1.prototype.tokenize = function(state, startLine, endLine) {
      var ok, i2, prevLine, rules2 = this.ruler.getRules(""), len = rules2.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
      while (line < endLine) {
        state.line = line = state.skipEmptyLines(line);
        if (line >= endLine) {
          break;
        }
        if (state.sCount[line] < state.blkIndent) {
          break;
        }
        if (state.level >= maxNesting) {
          state.line = endLine;
          break;
        }
        prevLine = state.line;
        for (i2 = 0; i2 < len; i2++) {
          ok = rules2[i2](state, line, endLine, false);
          if (ok) {
            if (prevLine >= state.line) {
              throw new Error("block rule didn't increment state.line");
            }
            break;
          }
        }
        if (!ok)
          throw new Error("none of the block rules matched");
        state.tight = !hasEmptyLines;
        if (state.isEmpty(state.line - 1)) {
          hasEmptyLines = true;
        }
        line = state.line;
        if (line < endLine && state.isEmpty(line)) {
          hasEmptyLines = true;
          line++;
          state.line = line;
        }
      }
    };
    ParserBlock$1.prototype.parse = function(src, md, env, outTokens) {
      var state;
      if (!src) {
        return;
      }
      state = new this.State(src, md, env, outTokens);
      this.tokenize(state, state.line, state.lineMax);
    };
    ParserBlock$1.prototype.State = state_block;
    var parser_block = ParserBlock$1;
    function isTerminatorChar(ch) {
      switch (ch) {
        case 10:
        case 33:
        case 35:
        case 36:
        case 37:
        case 38:
        case 42:
        case 43:
        case 45:
        case 58:
        case 60:
        case 61:
        case 62:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    var text = function text2(state, silent) {
      var pos = state.pos;
      while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
        pos++;
      }
      if (pos === state.pos) {
        return false;
      }
      if (!silent) {
        state.pending += state.src.slice(state.pos, pos);
      }
      state.pos = pos;
      return true;
    };
    var SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
    var linkify = function linkify2(state, silent) {
      var pos, max, match, proto, link2, url, fullUrl, token2;
      if (!state.md.options.linkify)
        return false;
      if (state.linkLevel > 0)
        return false;
      pos = state.pos;
      max = state.posMax;
      if (pos + 3 > max)
        return false;
      if (state.src.charCodeAt(pos) !== 58)
        return false;
      if (state.src.charCodeAt(pos + 1) !== 47)
        return false;
      if (state.src.charCodeAt(pos + 2) !== 47)
        return false;
      match = state.pending.match(SCHEME_RE);
      if (!match)
        return false;
      proto = match[1];
      link2 = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length));
      if (!link2)
        return false;
      url = link2.url;
      if (url.length <= proto.length)
        return false;
      url = url.replace(/\*+$/, "");
      fullUrl = state.md.normalizeLink(url);
      if (!state.md.validateLink(fullUrl))
        return false;
      if (!silent) {
        state.pending = state.pending.slice(0, -proto.length);
        token2 = state.push("link_open", "a", 1);
        token2.attrs = [["href", fullUrl]];
        token2.markup = "linkify";
        token2.info = "auto";
        token2 = state.push("text", "", 0);
        token2.content = state.md.normalizeLinkText(url);
        token2 = state.push("link_close", "a", -1);
        token2.markup = "linkify";
        token2.info = "auto";
      }
      state.pos += url.length - proto.length;
      return true;
    };
    var isSpace$3 = utils$1.isSpace;
    var newline = function newline2(state, silent) {
      var pmax, max, ws, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 10) {
        return false;
      }
      pmax = state.pending.length - 1;
      max = state.posMax;
      if (!silent) {
        if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
          if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
            ws = pmax - 1;
            while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)
              ws--;
            state.pending = state.pending.slice(0, ws);
            state.push("hardbreak", "br", 0);
          } else {
            state.pending = state.pending.slice(0, -1);
            state.push("softbreak", "br", 0);
          }
        } else {
          state.push("softbreak", "br", 0);
        }
      }
      pos++;
      while (pos < max && isSpace$3(state.src.charCodeAt(pos))) {
        pos++;
      }
      state.pos = pos;
      return true;
    };
    var isSpace$2 = utils$1.isSpace;
    var ESCAPED = [];
    for (var i = 0; i < 256; i++) {
      ESCAPED.push(0);
    }
    "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
      ESCAPED[ch.charCodeAt(0)] = 1;
    });
    var _escape = function escape(state, silent) {
      var ch1, ch2, origStr, escapedStr, token2, pos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(pos) !== 92)
        return false;
      pos++;
      if (pos >= max)
        return false;
      ch1 = state.src.charCodeAt(pos);
      if (ch1 === 10) {
        if (!silent) {
          state.push("hardbreak", "br", 0);
        }
        pos++;
        while (pos < max) {
          ch1 = state.src.charCodeAt(pos);
          if (!isSpace$2(ch1))
            break;
          pos++;
        }
        state.pos = pos;
        return true;
      }
      escapedStr = state.src[pos];
      if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max) {
        ch2 = state.src.charCodeAt(pos + 1);
        if (ch2 >= 56320 && ch2 <= 57343) {
          escapedStr += state.src[pos + 1];
          pos++;
        }
      }
      origStr = "\\" + escapedStr;
      if (!silent) {
        token2 = state.push("text_special", "", 0);
        if (ch1 < 256 && ESCAPED[ch1] !== 0) {
          token2.content = escapedStr;
        } else {
          token2.content = origStr;
        }
        token2.markup = origStr;
        token2.info = "escape";
      }
      state.pos = pos + 1;
      return true;
    };
    var backticks = function backtick(state, silent) {
      var start, max, marker2, token2, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch = state.src.charCodeAt(pos);
      if (ch !== 96) {
        return false;
      }
      start = pos;
      pos++;
      max = state.posMax;
      while (pos < max && state.src.charCodeAt(pos) === 96) {
        pos++;
      }
      marker2 = state.src.slice(start, pos);
      openerLength = marker2.length;
      if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
        if (!silent)
          state.pending += marker2;
        state.pos += openerLength;
        return true;
      }
      matchEnd = pos;
      while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
        matchEnd = matchStart + 1;
        while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
          matchEnd++;
        }
        closerLength = matchEnd - matchStart;
        if (closerLength === openerLength) {
          if (!silent) {
            token2 = state.push("code_inline", "code", 0);
            token2.markup = marker2;
            token2.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
          }
          state.pos = matchEnd;
          return true;
        }
        state.backticks[closerLength] = matchStart;
      }
      state.backticksScanned = true;
      if (!silent)
        state.pending += marker2;
      state.pos += openerLength;
      return true;
    };
    var strikethrough = {};
    strikethrough.tokenize = function strikethrough2(state, silent) {
      var i2, scanned, token2, len, ch, start = state.pos, marker2 = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker2 !== 126) {
        return false;
      }
      scanned = state.scanDelims(state.pos, true);
      len = scanned.length;
      ch = String.fromCharCode(marker2);
      if (len < 2) {
        return false;
      }
      if (len % 2) {
        token2 = state.push("text", "", 0);
        token2.content = ch;
        len--;
      }
      for (i2 = 0; i2 < len; i2 += 2) {
        token2 = state.push("text", "", 0);
        token2.content = ch + ch;
        state.delimiters.push({
          marker: marker2,
          length: 0,
          // disable "rule of 3" length checks meant for emphasis
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess$1(state, delimiters) {
      var i2, j, startDelim, endDelim, token2, loneMarkers = [], max = delimiters.length;
      for (i2 = 0; i2 < max; i2++) {
        startDelim = delimiters[i2];
        if (startDelim.marker !== 126) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        token2 = state.tokens[startDelim.token];
        token2.type = "s_open";
        token2.tag = "s";
        token2.nesting = 1;
        token2.markup = "~~";
        token2.content = "";
        token2 = state.tokens[endDelim.token];
        token2.type = "s_close";
        token2.tag = "s";
        token2.nesting = -1;
        token2.markup = "~~";
        token2.content = "";
        if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
          loneMarkers.push(endDelim.token - 1);
        }
      }
      while (loneMarkers.length) {
        i2 = loneMarkers.pop();
        j = i2 + 1;
        while (j < state.tokens.length && state.tokens[j].type === "s_close") {
          j++;
        }
        j--;
        if (i2 !== j) {
          token2 = state.tokens[j];
          state.tokens[j] = state.tokens[i2];
          state.tokens[i2] = token2;
        }
      }
    }
    strikethrough.postProcess = function strikethrough2(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      postProcess$1(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess$1(state, tokens_meta[curr].delimiters);
        }
      }
    };
    var emphasis = {};
    emphasis.tokenize = function emphasis2(state, silent) {
      var i2, scanned, token2, start = state.pos, marker2 = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker2 !== 95 && marker2 !== 42) {
        return false;
      }
      scanned = state.scanDelims(state.pos, marker2 === 42);
      for (i2 = 0; i2 < scanned.length; i2++) {
        token2 = state.push("text", "", 0);
        token2.content = String.fromCharCode(marker2);
        state.delimiters.push({
          // Char code of the starting marker (number).
          //
          marker: marker2,
          // Total length of these series of delimiters.
          //
          length: scanned.length,
          // A position of the token this delimiter corresponds to.
          //
          token: state.tokens.length - 1,
          // If this delimiter is matched as a valid opener, `end` will be
          // equal to its position, otherwise it's `-1`.
          //
          end: -1,
          // Boolean flags that determine if this delimiter could open or close
          // an emphasis.
          //
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i2, startDelim, endDelim, token2, ch, isStrong, max = delimiters.length;
      for (i2 = max - 1; i2 >= 0; i2--) {
        startDelim = delimiters[i2];
        if (startDelim.marker !== 95 && startDelim.marker !== 42) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        isStrong = i2 > 0 && delimiters[i2 - 1].end === startDelim.end + 1 && // check that first two markers match and adjacent
        delimiters[i2 - 1].marker === startDelim.marker && delimiters[i2 - 1].token === startDelim.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
        delimiters[startDelim.end + 1].token === endDelim.token + 1;
        ch = String.fromCharCode(startDelim.marker);
        token2 = state.tokens[startDelim.token];
        token2.type = isStrong ? "strong_open" : "em_open";
        token2.tag = isStrong ? "strong" : "em";
        token2.nesting = 1;
        token2.markup = isStrong ? ch + ch : ch;
        token2.content = "";
        token2 = state.tokens[endDelim.token];
        token2.type = isStrong ? "strong_close" : "em_close";
        token2.tag = isStrong ? "strong" : "em";
        token2.nesting = -1;
        token2.markup = isStrong ? ch + ch : ch;
        token2.content = "";
        if (isStrong) {
          state.tokens[delimiters[i2 - 1].token].content = "";
          state.tokens[delimiters[startDelim.end + 1].token].content = "";
          i2--;
        }
      }
    }
    emphasis.postProcess = function emphasis2(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
    var normalizeReference$1 = utils$1.normalizeReference;
    var isSpace$1 = utils$1.isSpace;
    var link = function link2(state, silent) {
      var attrs, code2, label, labelEnd, labelStart, pos, res, ref2, token2, href = "", title2 = "", oldPos = state.pos, max = state.posMax, start = state.pos, parseReference = true;
      if (state.src.charCodeAt(state.pos) !== 91) {
        return false;
      }
      labelStart = state.pos + 1;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        parseReference = false;
        pos++;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace$1(code2) && code2 !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
          start = pos;
          for (; pos < max; pos++) {
            code2 = state.src.charCodeAt(pos);
            if (!isSpace$1(code2) && code2 !== 10) {
              break;
            }
          }
          res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
          if (pos < max && start !== pos && res.ok) {
            title2 = res.str;
            pos = res.pos;
            for (; pos < max; pos++) {
              code2 = state.src.charCodeAt(pos);
              if (!isSpace$1(code2) && code2 !== 10) {
                break;
              }
            }
          }
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          parseReference = true;
        }
        pos++;
      }
      if (parseReference) {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref2 = state.env.references[normalizeReference$1(label)];
        if (!ref2) {
          state.pos = oldPos;
          return false;
        }
        href = ref2.href;
        title2 = ref2.title;
      }
      if (!silent) {
        state.pos = labelStart;
        state.posMax = labelEnd;
        token2 = state.push("link_open", "a", 1);
        token2.attrs = attrs = [["href", href]];
        if (title2) {
          attrs.push(["title", title2]);
        }
        state.linkLevel++;
        state.md.inline.tokenize(state);
        state.linkLevel--;
        token2 = state.push("link_close", "a", -1);
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    };
    var normalizeReference = utils$1.normalizeReference;
    var isSpace = utils$1.isSpace;
    var image = function image2(state, silent) {
      var attrs, code2, content2, label, labelEnd, labelStart, pos, ref2, res, title2, token2, tokens, start, href = "", oldPos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(state.pos) !== 33) {
        return false;
      }
      if (state.src.charCodeAt(state.pos + 1) !== 91) {
        return false;
      }
      labelStart = state.pos + 2;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        pos++;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
        }
        start = pos;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          title2 = res.str;
          pos = res.pos;
          for (; pos < max; pos++) {
            code2 = state.src.charCodeAt(pos);
            if (!isSpace(code2) && code2 !== 10) {
              break;
            }
          }
        } else {
          title2 = "";
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          state.pos = oldPos;
          return false;
        }
        pos++;
      } else {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref2 = state.env.references[normalizeReference(label)];
        if (!ref2) {
          state.pos = oldPos;
          return false;
        }
        href = ref2.href;
        title2 = ref2.title;
      }
      if (!silent) {
        content2 = state.src.slice(labelStart, labelEnd);
        state.md.inline.parse(
          content2,
          state.md,
          state.env,
          tokens = []
        );
        token2 = state.push("image", "img", 0);
        token2.attrs = attrs = [["src", href], ["alt", ""]];
        token2.children = tokens;
        token2.content = content2;
        if (title2) {
          attrs.push(["title", title2]);
        }
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    };
    var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
    var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
    var autolink = function autolink2(state, silent) {
      var url, fullUrl, token2, ch, start, max, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      start = state.pos;
      max = state.posMax;
      for (; ; ) {
        if (++pos >= max)
          return false;
        ch = state.src.charCodeAt(pos);
        if (ch === 60)
          return false;
        if (ch === 62)
          break;
      }
      url = state.src.slice(start + 1, pos);
      if (AUTOLINK_RE.test(url)) {
        fullUrl = state.md.normalizeLink(url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token2 = state.push("link_open", "a", 1);
          token2.attrs = [["href", fullUrl]];
          token2.markup = "autolink";
          token2.info = "auto";
          token2 = state.push("text", "", 0);
          token2.content = state.md.normalizeLinkText(url);
          token2 = state.push("link_close", "a", -1);
          token2.markup = "autolink";
          token2.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      if (EMAIL_RE.test(url)) {
        fullUrl = state.md.normalizeLink("mailto:" + url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token2 = state.push("link_open", "a", 1);
          token2.attrs = [["href", fullUrl]];
          token2.markup = "autolink";
          token2.info = "auto";
          token2 = state.push("text", "", 0);
          token2.content = state.md.normalizeLinkText(url);
          token2 = state.push("link_close", "a", -1);
          token2.markup = "autolink";
          token2.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      return false;
    };
    var HTML_TAG_RE = html_re.HTML_TAG_RE;
    function isLinkOpen(str) {
      return /^<a[>\s]/i.test(str);
    }
    function isLinkClose(str) {
      return /^<\/a\s*>/i.test(str);
    }
    function isLetter(ch) {
      var lc = ch | 32;
      return lc >= 97 && lc <= 122;
    }
    var html_inline = function html_inline2(state, silent) {
      var ch, match, max, token2, pos = state.pos;
      if (!state.md.options.html) {
        return false;
      }
      max = state.posMax;
      if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
        return false;
      }
      ch = state.src.charCodeAt(pos + 1);
      if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
        return false;
      }
      match = state.src.slice(pos).match(HTML_TAG_RE);
      if (!match) {
        return false;
      }
      if (!silent) {
        token2 = state.push("html_inline", "", 0);
        token2.content = match[0];
        if (isLinkOpen(token2.content))
          state.linkLevel++;
        if (isLinkClose(token2.content))
          state.linkLevel--;
      }
      state.pos += match[0].length;
      return true;
    };
    var entities = entities$1;
    var has$1 = utils$1.has;
    var isValidEntityCode = utils$1.isValidEntityCode;
    var fromCodePoint = utils$1.fromCodePoint;
    var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
    var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
    var entity = function entity2(state, silent) {
      var ch, code2, match, token2, pos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(pos) !== 38)
        return false;
      if (pos + 1 >= max)
        return false;
      ch = state.src.charCodeAt(pos + 1);
      if (ch === 35) {
        match = state.src.slice(pos).match(DIGITAL_RE);
        if (match) {
          if (!silent) {
            code2 = match[1][0].toLowerCase() === "x" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            token2 = state.push("text_special", "", 0);
            token2.content = isValidEntityCode(code2) ? fromCodePoint(code2) : fromCodePoint(65533);
            token2.markup = match[0];
            token2.info = "entity";
          }
          state.pos += match[0].length;
          return true;
        }
      } else {
        match = state.src.slice(pos).match(NAMED_RE);
        if (match) {
          if (has$1(entities, match[1])) {
            if (!silent) {
              token2 = state.push("text_special", "", 0);
              token2.content = entities[match[1]];
              token2.markup = match[0];
              token2.info = "entity";
            }
            state.pos += match[0].length;
            return true;
          }
        }
      }
      return false;
    };
    function processDelimiters(delimiters) {
      var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max = delimiters.length;
      if (!max)
        return;
      var headerIdx = 0;
      var lastTokenIdx = -2;
      var jumps = [];
      for (closerIdx = 0; closerIdx < max; closerIdx++) {
        closer = delimiters[closerIdx];
        jumps.push(0);
        if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
          headerIdx = closerIdx;
        }
        lastTokenIdx = closer.token;
        closer.length = closer.length || 0;
        if (!closer.close)
          continue;
        if (!openersBottom.hasOwnProperty(closer.marker)) {
          openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
        }
        minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
        openerIdx = headerIdx - jumps[headerIdx] - 1;
        newMinOpenerIdx = openerIdx;
        for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
          opener = delimiters[openerIdx];
          if (opener.marker !== closer.marker)
            continue;
          if (opener.open && opener.end < 0) {
            isOddMatch = false;
            if (opener.close || closer.open) {
              if ((opener.length + closer.length) % 3 === 0) {
                if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                  isOddMatch = true;
                }
              }
            }
            if (!isOddMatch) {
              lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
              jumps[closerIdx] = closerIdx - openerIdx + lastJump;
              jumps[openerIdx] = lastJump;
              closer.open = false;
              opener.end = closerIdx;
              opener.close = false;
              newMinOpenerIdx = -1;
              lastTokenIdx = -2;
              break;
            }
          }
        }
        if (newMinOpenerIdx !== -1) {
          openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
        }
      }
    }
    var balance_pairs = function link_pairs(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      processDelimiters(state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          processDelimiters(tokens_meta[curr].delimiters);
        }
      }
    };
    var fragments_join = function fragments_join2(state) {
      var curr, last, level = 0, tokens = state.tokens, max = state.tokens.length;
      for (curr = last = 0; curr < max; curr++) {
        if (tokens[curr].nesting < 0)
          level--;
        tokens[curr].level = level;
        if (tokens[curr].nesting > 0)
          level++;
        if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
          tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
        } else {
          if (curr !== last) {
            tokens[last] = tokens[curr];
          }
          last++;
        }
      }
      if (curr !== last) {
        tokens.length = last;
      }
    };
    var Token = token;
    var isWhiteSpace = utils$1.isWhiteSpace;
    var isPunctChar = utils$1.isPunctChar;
    var isMdAsciiPunct = utils$1.isMdAsciiPunct;
    function StateInline(src, md, env, outTokens) {
      this.src = src;
      this.env = env;
      this.md = md;
      this.tokens = outTokens;
      this.tokens_meta = Array(outTokens.length);
      this.pos = 0;
      this.posMax = this.src.length;
      this.level = 0;
      this.pending = "";
      this.pendingLevel = 0;
      this.cache = {};
      this.delimiters = [];
      this._prev_delimiters = [];
      this.backticks = {};
      this.backticksScanned = false;
      this.linkLevel = 0;
    }
    StateInline.prototype.pushPending = function() {
      var token2 = new Token("text", "", 0);
      token2.content = this.pending;
      token2.level = this.pendingLevel;
      this.tokens.push(token2);
      this.pending = "";
      return token2;
    };
    StateInline.prototype.push = function(type2, tag, nesting) {
      if (this.pending) {
        this.pushPending();
      }
      var token2 = new Token(type2, tag, nesting);
      var token_meta = null;
      if (nesting < 0) {
        this.level--;
        this.delimiters = this._prev_delimiters.pop();
      }
      token2.level = this.level;
      if (nesting > 0) {
        this.level++;
        this._prev_delimiters.push(this.delimiters);
        this.delimiters = [];
        token_meta = { delimiters: this.delimiters };
      }
      this.pendingLevel = this.level;
      this.tokens.push(token2);
      this.tokens_meta.push(token_meta);
      return token2;
    };
    StateInline.prototype.scanDelims = function(start, canSplitWord) {
      var pos = start, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max = this.posMax, marker2 = this.src.charCodeAt(start);
      lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
      while (pos < max && this.src.charCodeAt(pos) === marker2) {
        pos++;
      }
      count = pos - start;
      nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);
      if (isNextWhiteSpace) {
        left_flanking = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          left_flanking = false;
        }
      }
      if (isLastWhiteSpace) {
        right_flanking = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          right_flanking = false;
        }
      }
      if (!canSplitWord) {
        can_open = left_flanking && (!right_flanking || isLastPunctChar);
        can_close = right_flanking && (!left_flanking || isNextPunctChar);
      } else {
        can_open = left_flanking;
        can_close = right_flanking;
      }
      return {
        can_open,
        can_close,
        length: count
      };
    };
    StateInline.prototype.Token = Token;
    var state_inline = StateInline;
    var Ruler = ruler;
    var _rules = [
      ["text", text],
      ["linkify", linkify],
      ["newline", newline],
      ["escape", _escape],
      ["backticks", backticks],
      ["strikethrough", strikethrough.tokenize],
      ["emphasis", emphasis.tokenize],
      ["link", link],
      ["image", image],
      ["autolink", autolink],
      ["html_inline", html_inline],
      ["entity", entity]
    ];
    var _rules2 = [
      ["balance_pairs", balance_pairs],
      ["strikethrough", strikethrough.postProcess],
      ["emphasis", emphasis.postProcess],
      // rules for pairs separate '**' into its own text tokens, which may be left unused,
      // rule below merges unused segments back with the rest of the text
      ["fragments_join", fragments_join]
    ];
    function ParserInline$1() {
      var i2;
      this.ruler = new Ruler();
      for (i2 = 0; i2 < _rules.length; i2++) {
        this.ruler.push(_rules[i2][0], _rules[i2][1]);
      }
      this.ruler2 = new Ruler();
      for (i2 = 0; i2 < _rules2.length; i2++) {
        this.ruler2.push(_rules2[i2][0], _rules2[i2][1]);
      }
    }
    ParserInline$1.prototype.skipToken = function(state) {
      var ok, i2, pos = state.pos, rules2 = this.ruler.getRules(""), len = rules2.length, maxNesting = state.md.options.maxNesting, cache = state.cache;
      if (typeof cache[pos] !== "undefined") {
        state.pos = cache[pos];
        return;
      }
      if (state.level < maxNesting) {
        for (i2 = 0; i2 < len; i2++) {
          state.level++;
          ok = rules2[i2](state, true);
          state.level--;
          if (ok) {
            if (pos >= state.pos) {
              throw new Error("inline rule didn't increment state.pos");
            }
            break;
          }
        }
      } else {
        state.pos = state.posMax;
      }
      if (!ok) {
        state.pos++;
      }
      cache[pos] = state.pos;
    };
    ParserInline$1.prototype.tokenize = function(state) {
      var ok, i2, prevPos, rules2 = this.ruler.getRules(""), len = rules2.length, end = state.posMax, maxNesting = state.md.options.maxNesting;
      while (state.pos < end) {
        prevPos = state.pos;
        if (state.level < maxNesting) {
          for (i2 = 0; i2 < len; i2++) {
            ok = rules2[i2](state, false);
            if (ok) {
              if (prevPos >= state.pos) {
                throw new Error("inline rule didn't increment state.pos");
              }
              break;
            }
          }
        }
        if (ok) {
          if (state.pos >= end) {
            break;
          }
          continue;
        }
        state.pending += state.src[state.pos++];
      }
      if (state.pending) {
        state.pushPending();
      }
    };
    ParserInline$1.prototype.parse = function(str, md, env, outTokens) {
      var i2, rules2, len;
      var state = new this.State(str, md, env, outTokens);
      this.tokenize(state);
      rules2 = this.ruler2.getRules("");
      len = rules2.length;
      for (i2 = 0; i2 < len; i2++) {
        rules2[i2](state);
      }
    };
    ParserInline$1.prototype.State = state_inline;
    var parser_inline = ParserInline$1;
    var re;
    var hasRequiredRe;
    function requireRe() {
      if (hasRequiredRe)
        return re;
      hasRequiredRe = 1;
      re = function(opts) {
        var re2 = {};
        opts = opts || {};
        re2.src_Any = requireRegex$3().source;
        re2.src_Cc = requireRegex$2().source;
        re2.src_Z = requireRegex().source;
        re2.src_P = regex$4.source;
        re2.src_ZPCc = [re2.src_Z, re2.src_P, re2.src_Cc].join("|");
        re2.src_ZCc = [re2.src_Z, re2.src_Cc].join("|");
        var text_separators = "[><]";
        re2.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re2.src_ZPCc + ")" + re2.src_Any + ")";
        re2.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
        re2.src_auth = "(?:(?:(?!" + re2.src_ZCc + "|[@/\\[\\]()]).)+@)?";
        re2.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
        re2.src_host_terminator = "(?=$|" + text_separators + "|" + re2.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re2.src_ZPCc + "))";
        re2.src_path = "(?:[/?#](?:(?!" + re2.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re2.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re2.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re2.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re2.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re2.src_ZCc + "|[']).)+\\'|\\'(?=" + re2.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re2.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re2.src_ZCc + "|$)|;(?!" + re2.src_ZCc + "|$)|\\!+(?!" + re2.src_ZCc + "|[!]|$)|\\?(?!" + re2.src_ZCc + "|[?]|$))+|\\/)?";
        re2.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
        re2.src_xn = "xn--[a-z0-9\\-]{1,59}";
        re2.src_domain_root = // Allow letters & digits (http://test1)
        "(?:" + re2.src_xn + "|" + re2.src_pseudo_letter + "{1,63})";
        re2.src_domain = "(?:" + re2.src_xn + "|(?:" + re2.src_pseudo_letter + ")|(?:" + re2.src_pseudo_letter + "(?:-|" + re2.src_pseudo_letter + "){0,61}" + re2.src_pseudo_letter + "))";
        re2.src_host = "(?:(?:(?:(?:" + re2.src_domain + ")\\.)*" + re2.src_domain + "))";
        re2.tpl_host_fuzzy = "(?:" + re2.src_ip4 + "|(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%)))";
        re2.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%))";
        re2.src_host_strict = re2.src_host + re2.src_host_terminator;
        re2.tpl_host_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_host_terminator;
        re2.src_host_port_strict = re2.src_host + re2.src_port + re2.src_host_terminator;
        re2.tpl_host_port_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_port + re2.src_host_terminator;
        re2.tpl_host_port_no_ip_fuzzy_strict = re2.tpl_host_no_ip_fuzzy + re2.src_port + re2.src_host_terminator;
        re2.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re2.src_ZPCc + "|>|$))";
        re2.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re2.src_ZCc + ")(" + re2.src_email_name + "@" + re2.tpl_host_fuzzy_strict + ")";
        re2.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
        // but can start with > (markdown blockquote)
        "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + re2.src_ZPCc + "))((?![$+<=>^`|])" + re2.tpl_host_port_fuzzy_strict + re2.src_path + ")";
        re2.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
        // but can start with > (markdown blockquote)
        "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + re2.src_ZPCc + "))((?![$+<=>^`|])" + re2.tpl_host_port_no_ip_fuzzy_strict + re2.src_path + ")";
        return re2;
      };
      return re;
    }
    function assign(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class(obj) === "[object String]";
    }
    function isObject(obj) {
      return _class(obj) === "[object Object]";
    }
    function isRegExp(obj) {
      return _class(obj) === "[object RegExp]";
    }
    function isFunction(obj) {
      return _class(obj) === "[object Function]";
    }
    function escapeRE(str) {
      return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
    }
    var defaultOptions$1 = {
      fuzzyLink: true,
      fuzzyEmail: true,
      fuzzyIP: false
    };
    function isOptionsObj(obj) {
      return Object.keys(obj || {}).reduce(function(acc, k) {
        return acc || defaultOptions$1.hasOwnProperty(k);
      }, false);
    }
    var defaultSchemas = {
      "http:": {
        validate: function(text2, pos, self2) {
          var tail = text2.slice(pos);
          if (!self2.re.http) {
            self2.re.http = new RegExp(
              "^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path,
              "i"
            );
          }
          if (self2.re.http.test(tail)) {
            return tail.match(self2.re.http)[0].length;
          }
          return 0;
        }
      },
      "https:": "http:",
      "ftp:": "http:",
      "//": {
        validate: function(text2, pos, self2) {
          var tail = text2.slice(pos);
          if (!self2.re.no_http) {
            self2.re.no_http = new RegExp(
              "^" + self2.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
              // with code comments
              "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path,
              "i"
            );
          }
          if (self2.re.no_http.test(tail)) {
            if (pos >= 3 && text2[pos - 3] === ":") {
              return 0;
            }
            if (pos >= 3 && text2[pos - 3] === "/") {
              return 0;
            }
            return tail.match(self2.re.no_http)[0].length;
          }
          return 0;
        }
      },
      "mailto:": {
        validate: function(text2, pos, self2) {
          var tail = text2.slice(pos);
          if (!self2.re.mailto) {
            self2.re.mailto = new RegExp(
              "^" + self2.re.src_email_name + "@" + self2.re.src_host_strict,
              "i"
            );
          }
          if (self2.re.mailto.test(tail)) {
            return tail.match(self2.re.mailto)[0].length;
          }
          return 0;
        }
      }
    };
    var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
    var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|".split("|");
    function resetScanCache(self2) {
      self2.__index__ = -1;
      self2.__text_cache__ = "";
    }
    function createValidator(re2) {
      return function(text2, pos) {
        var tail = text2.slice(pos);
        if (re2.test(tail)) {
          return tail.match(re2)[0].length;
        }
        return 0;
      };
    }
    function createNormalizer() {
      return function(match, self2) {
        self2.normalize(match);
      };
    }
    function compile$1(self2) {
      var re2 = self2.re = requireRe()(self2.__opts__);
      var tlds = self2.__tlds__.slice();
      self2.onCompile();
      if (!self2.__tlds_replaced__) {
        tlds.push(tlds_2ch_src_re);
      }
      tlds.push(re2.src_xn);
      re2.src_tlds = tlds.join("|");
      function untpl(tpl) {
        return tpl.replace("%TLDS%", re2.src_tlds);
      }
      re2.email_fuzzy = RegExp(untpl(re2.tpl_email_fuzzy), "i");
      re2.link_fuzzy = RegExp(untpl(re2.tpl_link_fuzzy), "i");
      re2.link_no_ip_fuzzy = RegExp(untpl(re2.tpl_link_no_ip_fuzzy), "i");
      re2.host_fuzzy_test = RegExp(untpl(re2.tpl_host_fuzzy_test), "i");
      var aliases2 = [];
      self2.__compiled__ = {};
      function schemaError(name, val) {
        throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
      }
      Object.keys(self2.__schemas__).forEach(function(name) {
        var val = self2.__schemas__[name];
        if (val === null) {
          return;
        }
        var compiled = { validate: null, link: null };
        self2.__compiled__[name] = compiled;
        if (isObject(val)) {
          if (isRegExp(val.validate)) {
            compiled.validate = createValidator(val.validate);
          } else if (isFunction(val.validate)) {
            compiled.validate = val.validate;
          } else {
            schemaError(name, val);
          }
          if (isFunction(val.normalize)) {
            compiled.normalize = val.normalize;
          } else if (!val.normalize) {
            compiled.normalize = createNormalizer();
          } else {
            schemaError(name, val);
          }
          return;
        }
        if (isString(val)) {
          aliases2.push(name);
          return;
        }
        schemaError(name, val);
      });
      aliases2.forEach(function(alias) {
        if (!self2.__compiled__[self2.__schemas__[alias]]) {
          return;
        }
        self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
        self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
      });
      self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
      var slist = Object.keys(self2.__compiled__).filter(function(name) {
        return name.length > 0 && self2.__compiled__[name];
      }).map(escapeRE).join("|");
      self2.re.schema_test = RegExp("(^|(?!_)(?:[><]|" + re2.src_ZPCc + "))(" + slist + ")", "i");
      self2.re.schema_search = RegExp("(^|(?!_)(?:[><]|" + re2.src_ZPCc + "))(" + slist + ")", "ig");
      self2.re.schema_at_start = RegExp("^" + self2.re.schema_search.source, "i");
      self2.re.pretest = RegExp(
        "(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@",
        "i"
      );
      resetScanCache(self2);
    }
    function Match(self2, shift) {
      var start = self2.__index__, end = self2.__last_index__, text2 = self2.__text_cache__.slice(start, end);
      this.schema = self2.__schema__.toLowerCase();
      this.index = start + shift;
      this.lastIndex = end + shift;
      this.raw = text2;
      this.text = text2;
      this.url = text2;
    }
    function createMatch(self2, shift) {
      var match = new Match(self2, shift);
      self2.__compiled__[match.schema].normalize(match, self2);
      return match;
    }
    function LinkifyIt$1(schemas, options) {
      if (!(this instanceof LinkifyIt$1)) {
        return new LinkifyIt$1(schemas, options);
      }
      if (!options) {
        if (isOptionsObj(schemas)) {
          options = schemas;
          schemas = {};
        }
      }
      this.__opts__ = assign({}, defaultOptions$1, options);
      this.__index__ = -1;
      this.__last_index__ = -1;
      this.__schema__ = "";
      this.__text_cache__ = "";
      this.__schemas__ = assign({}, defaultSchemas, schemas);
      this.__compiled__ = {};
      this.__tlds__ = tlds_default;
      this.__tlds_replaced__ = false;
      this.re = {};
      compile$1(this);
    }
    LinkifyIt$1.prototype.add = function add2(schema, definition) {
      this.__schemas__[schema] = definition;
      compile$1(this);
      return this;
    };
    LinkifyIt$1.prototype.set = function set2(options) {
      this.__opts__ = assign(this.__opts__, options);
      return this;
    };
    LinkifyIt$1.prototype.test = function test(text2) {
      this.__text_cache__ = text2;
      this.__index__ = -1;
      if (!text2.length) {
        return false;
      }
      var m, ml, me, len, shift, next2, re2, tld_pos, at_pos;
      if (this.re.schema_test.test(text2)) {
        re2 = this.re.schema_search;
        re2.lastIndex = 0;
        while ((m = re2.exec(text2)) !== null) {
          len = this.testSchemaAt(text2, m[2], re2.lastIndex);
          if (len) {
            this.__schema__ = m[2];
            this.__index__ = m.index + m[1].length;
            this.__last_index__ = m.index + m[0].length + len;
            break;
          }
        }
      }
      if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
        tld_pos = text2.search(this.re.host_fuzzy_test);
        if (tld_pos >= 0) {
          if (this.__index__ < 0 || tld_pos < this.__index__) {
            if ((ml = text2.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
              shift = ml.index + ml[1].length;
              if (this.__index__ < 0 || shift < this.__index__) {
                this.__schema__ = "";
                this.__index__ = shift;
                this.__last_index__ = ml.index + ml[0].length;
              }
            }
          }
        }
      }
      if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
        at_pos = text2.indexOf("@");
        if (at_pos >= 0) {
          if ((me = text2.match(this.re.email_fuzzy)) !== null) {
            shift = me.index + me[1].length;
            next2 = me.index + me[0].length;
            if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next2 > this.__last_index__) {
              this.__schema__ = "mailto:";
              this.__index__ = shift;
              this.__last_index__ = next2;
            }
          }
        }
      }
      return this.__index__ >= 0;
    };
    LinkifyIt$1.prototype.pretest = function pretest(text2) {
      return this.re.pretest.test(text2);
    };
    LinkifyIt$1.prototype.testSchemaAt = function testSchemaAt(text2, schema, pos) {
      if (!this.__compiled__[schema.toLowerCase()]) {
        return 0;
      }
      return this.__compiled__[schema.toLowerCase()].validate(text2, pos, this);
    };
    LinkifyIt$1.prototype.match = function match(text2) {
      var shift = 0, result = [];
      if (this.__index__ >= 0 && this.__text_cache__ === text2) {
        result.push(createMatch(this, shift));
        shift = this.__last_index__;
      }
      var tail = shift ? text2.slice(shift) : text2;
      while (this.test(tail)) {
        result.push(createMatch(this, shift));
        tail = tail.slice(this.__last_index__);
        shift += this.__last_index__;
      }
      if (result.length) {
        return result;
      }
      return null;
    };
    LinkifyIt$1.prototype.matchAtStart = function matchAtStart(text2) {
      this.__text_cache__ = text2;
      this.__index__ = -1;
      if (!text2.length)
        return null;
      var m = this.re.schema_at_start.exec(text2);
      if (!m)
        return null;
      var len = this.testSchemaAt(text2, m[2], m[0].length);
      if (!len)
        return null;
      this.__schema__ = m[2];
      this.__index__ = m.index + m[1].length;
      this.__last_index__ = m.index + m[0].length + len;
      return createMatch(this, 0);
    };
    LinkifyIt$1.prototype.tlds = function tlds(list2, keepOld) {
      list2 = Array.isArray(list2) ? list2 : [list2];
      if (!keepOld) {
        this.__tlds__ = list2.slice();
        this.__tlds_replaced__ = true;
        compile$1(this);
        return this;
      }
      this.__tlds__ = this.__tlds__.concat(list2).sort().filter(function(el2, idx, arr) {
        return el2 !== arr[idx - 1];
      }).reverse();
      compile$1(this);
      return this;
    };
    LinkifyIt$1.prototype.normalize = function normalize2(match) {
      if (!match.schema) {
        match.url = "http://" + match.url;
      }
      if (match.schema === "mailto:" && !/^mailto:/i.test(match.url)) {
        match.url = "mailto:" + match.url;
      }
    };
    LinkifyIt$1.prototype.onCompile = function onCompile() {
    };
    var linkifyIt = LinkifyIt$1;
    const maxInt = 2147483647;
    const base = 36;
    const tMin = 1;
    const tMax = 26;
    const skew = 38;
    const damp = 700;
    const initialBias = 72;
    const initialN = 128;
    const delimiter = "-";
    const regexPunycode = /^xn--/;
    const regexNonASCII = /[^\0-\x7F]/;
    const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    const errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    const baseMinusTMin = base - tMin;
    const floor = Math.floor;
    const stringFromCharCode = String.fromCharCode;
    function error(type2) {
      throw new RangeError(errors[type2]);
    }
    function map(array, callback) {
      const result = [];
      let length = array.length;
      while (length--) {
        result[length] = callback(array[length]);
      }
      return result;
    }
    function mapDomain(domain, callback) {
      const parts = domain.split("@");
      let result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        domain = parts[1];
      }
      domain = domain.replace(regexSeparators, ".");
      const labels = domain.split(".");
      const encoded = map(labels, callback).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      const output = [];
      let counter = 0;
      const length = string.length;
      while (counter < length) {
        const value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          const extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    const ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
    const basicToDigit = function(codePoint) {
      if (codePoint >= 48 && codePoint < 58) {
        return 26 + (codePoint - 48);
      }
      if (codePoint >= 65 && codePoint < 91) {
        return codePoint - 65;
      }
      if (codePoint >= 97 && codePoint < 123) {
        return codePoint - 97;
      }
      return base;
    };
    const digitToBasic = function(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    const adapt = function(delta2, numPoints, firstTime) {
      let k = 0;
      delta2 = firstTime ? floor(delta2 / damp) : delta2 >> 1;
      delta2 += floor(delta2 / numPoints);
      for (; delta2 > baseMinusTMin * tMax >> 1; k += base) {
        delta2 = floor(delta2 / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta2 / (delta2 + skew));
    };
    const decode = function(input) {
      const output = [];
      const inputLength = input.length;
      let i2 = 0;
      let n = initialN;
      let bias2 = initialBias;
      let basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (let j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        const oldi = i2;
        for (let w = 1, k = base; ; k += base) {
          if (index >= inputLength) {
            error("invalid-input");
          }
          const digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base) {
            error("invalid-input");
          }
          if (digit > floor((maxInt - i2) / w)) {
            error("overflow");
          }
          i2 += digit * w;
          const t = k <= bias2 ? tMin : k >= bias2 + tMax ? tMax : k - bias2;
          if (digit < t) {
            break;
          }
          const baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error("overflow");
          }
          w *= baseMinusT;
        }
        const out = output.length + 1;
        bias2 = adapt(i2 - oldi, out, oldi == 0);
        if (floor(i2 / out) > maxInt - n) {
          error("overflow");
        }
        n += floor(i2 / out);
        i2 %= out;
        output.splice(i2++, 0, n);
      }
      return String.fromCodePoint(...output);
    };
    const encode = function(input) {
      const output = [];
      input = ucs2decode(input);
      const inputLength = input.length;
      let n = initialN;
      let delta2 = 0;
      let bias2 = initialBias;
      for (const currentValue of input) {
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      const basicLength = output.length;
      let handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        let m = maxInt;
        for (const currentValue of input) {
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta2) / handledCPCountPlusOne)) {
          error("overflow");
        }
        delta2 += (m - n) * handledCPCountPlusOne;
        n = m;
        for (const currentValue of input) {
          if (currentValue < n && ++delta2 > maxInt) {
            error("overflow");
          }
          if (currentValue === n) {
            let q = delta2;
            for (let k = base; ; k += base) {
              const t = k <= bias2 ? tMin : k >= bias2 + tMax ? tMax : k - bias2;
              if (q < t) {
                break;
              }
              const qMinusT = q - t;
              const baseMinusT = base - t;
              output.push(
                stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
              );
              q = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias2 = adapt(delta2, handledCPCountPlusOne, handledCPCount === basicLength);
            delta2 = 0;
            ++handledCPCount;
          }
        }
        ++delta2;
        ++n;
      }
      return output.join("");
    };
    const toUnicode = function(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    const toASCII = function(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    const punycode$1 = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      "version": "2.3.1",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode,
      "encode": encode,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    const punycode_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      decode,
      default: punycode$1,
      encode,
      toASCII,
      toUnicode,
      ucs2decode,
      ucs2encode
    }, Symbol.toStringTag, { value: "Module" }));
    const require$$8 = /* @__PURE__ */ getAugmentedNamespace(punycode_es6);
    var _default = {
      options: {
        html: false,
        // Enable HTML tags in source
        xhtmlOut: false,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '' for Russian, '' for German,
        // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
        quotes: "",
        /*  */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 100
        // Internal protection, recursion limit
      },
      components: {
        core: {},
        block: {},
        inline: {}
      }
    };
    var zero = {
      options: {
        html: false,
        // Enable HTML tags in source
        xhtmlOut: false,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '' for Russian, '' for German,
        // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
        quotes: "",
        /*  */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 20
        // Internal protection, recursion limit
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline",
            "text_join"
          ]
        },
        block: {
          rules: [
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "text"
          ],
          rules2: [
            "balance_pairs",
            "fragments_join"
          ]
        }
      }
    };
    var commonmark = {
      options: {
        html: true,
        // Enable HTML tags in source
        xhtmlOut: true,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '' for Russian, '' for German,
        // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
        quotes: "",
        /*  */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 20
        // Internal protection, recursion limit
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline",
            "text_join"
          ]
        },
        block: {
          rules: [
            "blockquote",
            "code",
            "fence",
            "heading",
            "hr",
            "html_block",
            "lheading",
            "list",
            "reference",
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "autolink",
            "backticks",
            "emphasis",
            "entity",
            "escape",
            "html_inline",
            "image",
            "link",
            "newline",
            "text"
          ],
          rules2: [
            "balance_pairs",
            "emphasis",
            "fragments_join"
          ]
        }
      }
    };
    var utils = utils$1;
    var helpers = helpers$1;
    var Renderer = renderer;
    var ParserCore = parser_core;
    var ParserBlock = parser_block;
    var ParserInline = parser_inline;
    var LinkifyIt = linkifyIt;
    var mdurl = mdurl$1;
    var punycode = require$$8;
    var config = {
      default: _default,
      zero,
      commonmark
    };
    var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
    var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
    function validateLink(url) {
      var str = url.trim().toLowerCase();
      return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
    }
    var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
    function normalizeLink(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toASCII(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.encode(mdurl.format(parsed));
    }
    function normalizeLinkText(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toUnicode(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
    }
    function MarkdownIt$1(presetName, options) {
      if (!(this instanceof MarkdownIt$1)) {
        return new MarkdownIt$1(presetName, options);
      }
      if (!options) {
        if (!utils.isString(presetName)) {
          options = presetName || {};
          presetName = "default";
        }
      }
      this.inline = new ParserInline();
      this.block = new ParserBlock();
      this.core = new ParserCore();
      this.renderer = new Renderer();
      this.linkify = new LinkifyIt();
      this.validateLink = validateLink;
      this.normalizeLink = normalizeLink;
      this.normalizeLinkText = normalizeLinkText;
      this.utils = utils;
      this.helpers = utils.assign({}, helpers);
      this.options = {};
      this.configure(presetName);
      if (options) {
        this.set(options);
      }
    }
    MarkdownIt$1.prototype.set = function(options) {
      utils.assign(this.options, options);
      return this;
    };
    MarkdownIt$1.prototype.configure = function(presets) {
      var self2 = this, presetName;
      if (utils.isString(presets)) {
        presetName = presets;
        presets = config[presetName];
        if (!presets) {
          throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
        }
      }
      if (!presets) {
        throw new Error("Wrong `markdown-it` preset, can't be empty");
      }
      if (presets.options) {
        self2.set(presets.options);
      }
      if (presets.components) {
        Object.keys(presets.components).forEach(function(name) {
          if (presets.components[name].rules) {
            self2[name].ruler.enableOnly(presets.components[name].rules);
          }
          if (presets.components[name].rules2) {
            self2[name].ruler2.enableOnly(presets.components[name].rules2);
          }
        });
      }
      return this;
    };
    MarkdownIt$1.prototype.enable = function(list2, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.enable(list2, true));
      }, this);
      result = result.concat(this.inline.ruler2.enable(list2, true));
      var missed = list2.filter(function(name) {
        return result.indexOf(name) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt$1.prototype.disable = function(list2, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.disable(list2, true));
      }, this);
      result = result.concat(this.inline.ruler2.disable(list2, true));
      var missed = list2.filter(function(name) {
        return result.indexOf(name) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt$1.prototype.use = function(plugin) {
      var args = [this].concat(Array.prototype.slice.call(arguments, 1));
      plugin.apply(plugin, args);
      return this;
    };
    MarkdownIt$1.prototype.parse = function(src, env) {
      if (typeof src !== "string") {
        throw new Error("Input data should be a String");
      }
      var state = new this.core.State(src, this, env);
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt$1.prototype.render = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parse(src, env), this.options, env);
    };
    MarkdownIt$1.prototype.parseInline = function(src, env) {
      var state = new this.core.State(src, this, env);
      state.inlineMode = true;
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt$1.prototype.renderInline = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parseInline(src, env), this.options, env);
    };
    var lib = MarkdownIt$1;
    var markdownIt = lib;
    const MarkdownIt = /* @__PURE__ */ getDefaultExportFromCjs(markdownIt);
    const en = {
      errorOneOf: "chose one",
      errorRequired: "required information",
      addItem: "Add item",
      delete: "Delete",
      edit: "Edit",
      duplicate: "Duplicate",
      sort: "Sort",
      up: "Move up",
      down: "Move down",
      showHelp: "Show a help message",
      mdeLink1: "[Link title",
      mdeLink2: "](link url)",
      mdeImg1: "![](",
      mdeImg2: "image url)",
      mdeTable1: "",
      mdeTable2: "\n\n| Column 1 | Column 2 | ColoColumnnne 3 |\n| -------- | -------- | -------- |\n| Text     | Text     | Text     |\n\n",
      bold: "Bold",
      italic: "Italic",
      heading: "Title",
      quote: "Quote",
      unorderedList: "Unordered list",
      orderedList: "Ordered list",
      createLink: "Create a link",
      insertImage: "Insert an image",
      createTable: "Create a table",
      preview: "Aperu du rendu",
      mdeGuide: "Documentation de la syntaxe",
      undo: "Undo",
      redo: "Redo"
    };
    const fr = {
      errorOneOf: "choisissez une valeur",
      errorRequired: "information obligatoire",
      addItem: "Ajouter un lment",
      delete: "Supprimer",
      edit: "diter",
      duplicate: "Dupliquer",
      sort: "Trier",
      up: "Dcaler vers le haut",
      down: "Dcaler vers le bas",
      showHelp: "Afficher un message d'aide",
      mdeLink1: "[titre du lien",
      mdeLink2: "](adresse du lien)",
      mdeImg1: "![](",
      mdeImg2: "adresse de l'image)",
      mdeTable1: "",
      mdeTable2: "\n\n| Colonne 1 | Colonne 2 | Colonne 3 |\n| -------- | -------- | -------- |\n| Texte     | Texte     | Texte     |\n\n",
      bold: "Gras",
      italic: "Italique",
      heading: "Titre",
      quote: "Citation",
      unorderedList: "Liste  puce",
      orderedList: "Liste numrote",
      createLink: "Crer un lien",
      insertImage: "Insrer une image",
      createTable: "Crer un tableau",
      preview: "Preview",
      mdeGuide: "Syntax documentation",
      undo: "Dfaire",
      redo: "Refaire"
    };
    const i18n = {
      en,
      fr
    };
    const schema26 = { "$id": "https://json-layout.github.io/layout-keyword", "title": "layout keyword", "errorMessage": { "anyOf": "layout keyword must be a string with a valid component name, or a more complete object definition, or an array of children, or a switch structure" }, "anyOf": [{ "$ref": "#/$defs/comp-name" }, { "$ref": "#/$defs/partial-children" }, { "$ref": "#/$defs/partial-comp-object" }, { "$ref": "#/$defs/partial-switch" }], "$defs": { "partial-switch": { "type": "object", "required": ["switch"], "additionalProperties": false, "properties": { "switch": { "type": "array", "items": { "$ref": "#/$defs/partial-comp-object" } } } }, "partial-comp-object": { "title": "partial comp object", "type": "object", "properties": { "comp": { "$ref": "#/$defs/comp-name" }, "help": { "type": "string" }, "children": { "$ref": "#/$defs/partial-children" }, "label": { "type": "string" }, "title": { "type": ["string", "null"] }, "subtitle": { "type": ["string", "null"] }, "step": { "type": "number" }, "if": { "$ref": "#/$defs/partial-expression" }, "items": { "type": "array", "items": { "$ref": "#/$defs/partial-select-item" } }, "getItems": { "$ref": "#/$defs/partial-get-items" }, "listEditMode": { "type": "string", "enum": ["inline", "inline-single", "menu", "dialog"] }, "listActions": { "type": "array", "items": { "type": "string", "enum": ["add", "edit", "delete", "sort", "duplicate"] } }, "cols": { "$ref": "#/$defs/partial-cols" }, "props": { "type": "object" }, "getProps": { "$ref": "#/$defs/partial-expression" }, "slots": { "type": "object", "patternProperties": { ".*": { "$ref": "#/$defs/partial-slot" } } }, "options": { "type": "object" }, "getOptions": { "$ref": "#/$defs/partial-expression" }, "messages": { "type": "object" }, "defaultData": {}, "getDefaultData": { "$ref": "#/$defs/partial-expression" }, "constData": {}, "getConstData": { "$ref": "#/$defs/partial-expression" }, "transformData": { "$ref": "#/$defs/partial-expression" }, "autofocus": { "type": "boolean" } } }, "comp-name": { "title": "component name", "type": "string", "errorMessage": { "enum": "component name is unknown" }, "enum": ["none", "text-field", "number-field", "textarea", "markdown", "checkbox", "switch", "slider", "date-picker", "date-time-picker", "time-picker", "color-picker", "combobox", "number-combobox", "section", "list", "select", "autocomplete", "tabs", "vertical-tabs", "expansion-panels", "stepper", "one-of-select", "file-input"] }, "partial-child": { "type": "object", "unevaluatedProperties": false, "properties": { "key": { "type": ["string", "integer"] }, "cols": { "$ref": "#/$defs/partial-cols" } }, "allOf": [{ "$ref": "#/$defs/partial-comp-object" }, {}] }, "partial-children": { "type": "array", "items": { "oneOf": [{ "type": "string" }, { "$ref": "#/$defs/partial-child" }] } }, "partial-expression": { "oneOf": [{ "type": "string" }, { "$ref": "#/$defs/partial-expression-obj" }] }, "partial-expression-obj": { "type": "object", "required": ["expr"], "properties": { "type": { "type": "string", "enum": ["js-fn", "js-eval", "js-tpl"] }, "expr": { "type": "string" } } }, "partial-select-item": { "oneOf": [{ "type": "string" }, { "type": "object", "properties": { "key": { "type": "string" }, "title": { "type": "string" }, "value": {} } }] }, "partial-get-items": { "oneOf": [{ "type": "string" }, { "$ref": "#/$defs/partial-get-items-obj" }] }, "partial-get-items-obj": { "type": "object", "allOf": [{ "properties": { "itemTitle": { "$ref": "#/$defs/partial-expression" }, "itemKey": { "$ref": "#/$defs/partial-expression" }, "itemValue": { "$ref": "#/$defs/partial-expression" }, "itemIcon": { "$ref": "#/$defs/partial-expression" }, "itemsResults": { "$ref": "#/$defs/partial-expression" } } }, { "anyOf": [{ "type": "object" }, { "$ref": "#/$defs/partial-expression-obj" }, { "$ref": "#/$defs/partial-get-items-fetch" }] }] }, "partial-get-items-fetch": { "type": "object", "required": ["url"], "properties": { "url": { "$ref": "#/$defs/partial-expression" } } }, "partial-cols": { "oneOf": [{ "$ref": "#/$defs/partial-cols-number" }, { "$ref": "#/$defs/partial-cols-obj" }] }, "partial-cols-obj": { "type": "object", "additionalProperties": false, "properties": { "xs": { "$ref": "#/$defs/partial-cols-number" }, "sm": { "$ref": "#/$defs/partial-cols-number" }, "md": { "$ref": "#/$defs/partial-cols-number" }, "lg": { "$ref": "#/$defs/partial-cols-number" }, "xl": { "$ref": "#/$defs/partial-cols-number" }, "xxl": { "$ref": "#/$defs/partial-cols-number" } } }, "partial-cols-number": { "type": "integer", "minimum": 0, "maximum": 12 }, "partial-slot": { "oneOf": [{ "type": "string" }, { "$ref": "#/$defs/partial-slot-text" }, { "$ref": "#/$defs/partial-slot-markdown" }, { "$ref": "#/$defs/partial-slot-name" }] }, "partial-slot-text": { "type": "object", "additionalProperties": false, "required": ["text"], "properties": { "text": { "type": "string" } } }, "partial-slot-markdown": { "type": "object", "additionalProperties": false, "required": ["markdown"], "properties": { "markdown": { "type": "string" } } }, "partial-slot-name": { "type": "object", "additionalProperties": false, "required": ["name"], "properties": { "name": { "type": "string" } } } } };
    const schema27 = { "title": "component name", "type": "string", "errorMessage": { "enum": "component name is unknown" }, "enum": ["none", "text-field", "number-field", "textarea", "markdown", "checkbox", "switch", "slider", "date-picker", "date-time-picker", "time-picker", "color-picker", "combobox", "number-combobox", "section", "list", "select", "autocomplete", "tabs", "vertical-tabs", "expansion-panels", "stepper", "one-of-select", "file-input"] };
    const schema29 = { "type": "object", "unevaluatedProperties": false, "properties": { "key": { "type": ["string", "integer"] }, "cols": { "$ref": "#/$defs/partial-cols" } }, "allOf": [{ "$ref": "#/$defs/partial-comp-object" }, {}] };
    const schema30 = { "title": "partial comp object", "type": "object", "properties": { "comp": { "$ref": "#/$defs/comp-name" }, "help": { "type": "string" }, "children": { "$ref": "#/$defs/partial-children" }, "label": { "type": "string" }, "title": { "type": ["string", "null"] }, "subtitle": { "type": ["string", "null"] }, "step": { "type": "number" }, "if": { "$ref": "#/$defs/partial-expression" }, "items": { "type": "array", "items": { "$ref": "#/$defs/partial-select-item" } }, "getItems": { "$ref": "#/$defs/partial-get-items" }, "listEditMode": { "type": "string", "enum": ["inline", "inline-single", "menu", "dialog"] }, "listActions": { "type": "array", "items": { "type": "string", "enum": ["add", "edit", "delete", "sort", "duplicate"] } }, "cols": { "$ref": "#/$defs/partial-cols" }, "props": { "type": "object" }, "getProps": { "$ref": "#/$defs/partial-expression" }, "slots": { "type": "object", "patternProperties": { ".*": { "$ref": "#/$defs/partial-slot" } } }, "options": { "type": "object" }, "getOptions": { "$ref": "#/$defs/partial-expression" }, "messages": { "type": "object" }, "defaultData": {}, "getDefaultData": { "$ref": "#/$defs/partial-expression" }, "constData": {}, "getConstData": { "$ref": "#/$defs/partial-expression" }, "transformData": { "$ref": "#/$defs/partial-expression" }, "autofocus": { "type": "boolean" } } };
    const wrapper0 = { validate: validate23 };
    const schema33 = { "type": "object", "required": ["expr"], "properties": { "type": { "type": "string", "enum": ["js-fn", "js-eval", "js-tpl"] }, "expr": { "type": "string" } } };
    function validate26(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate26.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      const _errs0 = errors2;
      let valid0 = false;
      let passing0 = null;
      const _errs1 = errors2;
      if (typeof data !== "string") {
        const err0 = { instancePath, schemaPath: "#/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors2++;
      }
      var _valid0 = _errs1 === errors2;
      if (_valid0) {
        valid0 = true;
        passing0 = 0;
      }
      const _errs3 = errors2;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.expr === void 0) {
          const err1 = { instancePath, schemaPath: "#/$defs/partial-expression-obj/required", keyword: "required", params: { missingProperty: "expr" }, message: "must have required property 'expr'" };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors2++;
        }
        if (data.type !== void 0) {
          let data0 = data.type;
          if (typeof data0 !== "string") {
            const err2 = { instancePath: instancePath + "/type", schemaPath: "#/$defs/partial-expression-obj/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors2++;
          }
          if (!(data0 === "js-fn" || data0 === "js-eval" || data0 === "js-tpl")) {
            const err3 = { instancePath: instancePath + "/type", schemaPath: "#/$defs/partial-expression-obj/properties/type/enum", keyword: "enum", params: { allowedValues: schema33.properties.type.enum }, message: "must be equal to one of the allowed values" };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors2++;
          }
        }
        if (data.expr !== void 0) {
          if (typeof data.expr !== "string") {
            const err4 = { instancePath: instancePath + "/expr", schemaPath: "#/$defs/partial-expression-obj/properties/expr/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors2++;
          }
        }
      } else {
        const err5 = { instancePath, schemaPath: "#/$defs/partial-expression-obj/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err5];
        } else {
          vErrors.push(err5);
        }
        errors2++;
      }
      var _valid0 = _errs3 === errors2;
      if (_valid0 && valid0) {
        valid0 = false;
        passing0 = [passing0, 1];
      } else {
        if (_valid0) {
          valid0 = true;
          passing0 = 1;
          var props0 = {};
          props0.type = true;
          props0.expr = true;
        }
      }
      if (!valid0) {
        const err6 = { instancePath, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
        if (vErrors === null) {
          vErrors = [err6];
        } else {
          vErrors.push(err6);
        }
        errors2++;
      } else {
        errors2 = _errs0;
        if (vErrors !== null) {
          if (_errs0) {
            vErrors.length = _errs0;
          } else {
            vErrors = null;
          }
        }
      }
      validate26.errors = vErrors;
      evaluated0.props = props0;
      return errors2 === 0;
    }
    validate26.evaluated = { "dynamicProps": true, "dynamicItems": false };
    function validate35(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate35.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.url === void 0) {
          const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "url" }, message: "must have required property 'url'" };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors2++;
        }
        if (data.url !== void 0) {
          if (!validate26(data.url, { instancePath: instancePath + "/url", parentData: data, parentDataProperty: "url", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate26.errors : vErrors.concat(validate26.errors);
            errors2 = vErrors.length;
          }
        }
      } else {
        const err1 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err1];
        } else {
          vErrors.push(err1);
        }
        errors2++;
      }
      validate35.errors = vErrors;
      return errors2 === 0;
    }
    validate35.evaluated = { "props": { "url": true }, "dynamicProps": false, "dynamicItems": false };
    function validate29(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate29.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (!(data && typeof data == "object" && !Array.isArray(data))) {
        const err0 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors2++;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.itemTitle !== void 0) {
          if (!validate26(data.itemTitle, { instancePath: instancePath + "/itemTitle", parentData: data, parentDataProperty: "itemTitle", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate26.errors : vErrors.concat(validate26.errors);
            errors2 = vErrors.length;
          }
        }
        if (data.itemKey !== void 0) {
          if (!validate26(data.itemKey, { instancePath: instancePath + "/itemKey", parentData: data, parentDataProperty: "itemKey", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate26.errors : vErrors.concat(validate26.errors);
            errors2 = vErrors.length;
          }
        }
        if (data.itemValue !== void 0) {
          if (!validate26(data.itemValue, { instancePath: instancePath + "/itemValue", parentData: data, parentDataProperty: "itemValue", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate26.errors : vErrors.concat(validate26.errors);
            errors2 = vErrors.length;
          }
        }
        if (data.itemIcon !== void 0) {
          if (!validate26(data.itemIcon, { instancePath: instancePath + "/itemIcon", parentData: data, parentDataProperty: "itemIcon", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate26.errors : vErrors.concat(validate26.errors);
            errors2 = vErrors.length;
          }
        }
        if (data.itemsResults !== void 0) {
          if (!validate26(data.itemsResults, { instancePath: instancePath + "/itemsResults", parentData: data, parentDataProperty: "itemsResults", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate26.errors : vErrors.concat(validate26.errors);
            errors2 = vErrors.length;
          }
        }
      }
      const _errs8 = errors2;
      let valid2 = false;
      const _errs9 = errors2;
      if (!(data && typeof data == "object" && !Array.isArray(data))) {
        const err1 = { instancePath, schemaPath: "#/allOf/1/anyOf/0/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err1];
        } else {
          vErrors.push(err1);
        }
        errors2++;
      }
      var _valid0 = _errs9 === errors2;
      valid2 = valid2 || _valid0;
      const _errs11 = errors2;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.expr === void 0) {
          const err2 = { instancePath, schemaPath: "#/$defs/partial-expression-obj/required", keyword: "required", params: { missingProperty: "expr" }, message: "must have required property 'expr'" };
          if (vErrors === null) {
            vErrors = [err2];
          } else {
            vErrors.push(err2);
          }
          errors2++;
        }
        if (data.type !== void 0) {
          let data5 = data.type;
          if (typeof data5 !== "string") {
            const err3 = { instancePath: instancePath + "/type", schemaPath: "#/$defs/partial-expression-obj/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors2++;
          }
          if (!(data5 === "js-fn" || data5 === "js-eval" || data5 === "js-tpl")) {
            const err4 = { instancePath: instancePath + "/type", schemaPath: "#/$defs/partial-expression-obj/properties/type/enum", keyword: "enum", params: { allowedValues: schema33.properties.type.enum }, message: "must be equal to one of the allowed values" };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors2++;
          }
        }
        if (data.expr !== void 0) {
          if (typeof data.expr !== "string") {
            const err5 = { instancePath: instancePath + "/expr", schemaPath: "#/$defs/partial-expression-obj/properties/expr/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err5];
            } else {
              vErrors.push(err5);
            }
            errors2++;
          }
        }
      } else {
        const err6 = { instancePath, schemaPath: "#/$defs/partial-expression-obj/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err6];
        } else {
          vErrors.push(err6);
        }
        errors2++;
      }
      var _valid0 = _errs11 === errors2;
      valid2 = valid2 || _valid0;
      if (_valid0) {
        var props5 = {};
        props5.type = true;
        props5.expr = true;
      }
      const _errs18 = errors2;
      if (!validate35(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
        vErrors = vErrors === null ? validate35.errors : vErrors.concat(validate35.errors);
        errors2 = vErrors.length;
      }
      var _valid0 = _errs18 === errors2;
      valid2 = valid2 || _valid0;
      if (_valid0) {
        if (props5 !== true) {
          props5 = props5 || {};
          props5.url = true;
        }
      }
      if (!valid2) {
        const err7 = { instancePath, schemaPath: "#/allOf/1/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
        if (vErrors === null) {
          vErrors = [err7];
        } else {
          vErrors.push(err7);
        }
        errors2++;
      } else {
        errors2 = _errs8;
        if (vErrors !== null) {
          if (_errs8) {
            vErrors.length = _errs8;
          } else {
            vErrors = null;
          }
        }
      }
      if (props5 !== true) {
        props5 = props5 || {};
        props5.itemTitle = true;
        props5.itemKey = true;
        props5.itemValue = true;
        props5.itemIcon = true;
        props5.itemsResults = true;
      }
      validate29.errors = vErrors;
      evaluated0.props = props5;
      return errors2 === 0;
    }
    validate29.evaluated = { "dynamicProps": true, "dynamicItems": false };
    function validate28(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate28.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      const _errs0 = errors2;
      let valid0 = false;
      let passing0 = null;
      const _errs1 = errors2;
      if (typeof data !== "string") {
        const err0 = { instancePath, schemaPath: "#/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors2++;
      }
      var _valid0 = _errs1 === errors2;
      if (_valid0) {
        valid0 = true;
        passing0 = 0;
      }
      const _errs3 = errors2;
      if (!validate29(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
        vErrors = vErrors === null ? validate29.errors : vErrors.concat(validate29.errors);
        errors2 = vErrors.length;
      } else {
        var props0 = validate29.evaluated.props;
      }
      var _valid0 = _errs3 === errors2;
      if (_valid0 && valid0) {
        valid0 = false;
        passing0 = [passing0, 1];
      } else {
        if (_valid0) {
          valid0 = true;
          passing0 = 1;
        }
      }
      if (!valid0) {
        const err1 = { instancePath, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
        if (vErrors === null) {
          vErrors = [err1];
        } else {
          vErrors.push(err1);
        }
        errors2++;
      } else {
        errors2 = _errs0;
        if (vErrors !== null) {
          if (_errs0) {
            vErrors.length = _errs0;
          } else {
            vErrors = null;
          }
        }
      }
      validate28.errors = vErrors;
      evaluated0.props = props0;
      return errors2 === 0;
    }
    validate28.evaluated = { "dynamicProps": true, "dynamicItems": false };
    function validate41(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate41.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        for (const key0 in data) {
          if (!(key0 === "xs" || key0 === "sm" || key0 === "md" || key0 === "lg" || key0 === "xl" || key0 === "xxl")) {
            const err0 = { instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" };
            if (vErrors === null) {
              vErrors = [err0];
            } else {
              vErrors.push(err0);
            }
            errors2++;
          }
        }
        if (data.xs !== void 0) {
          let data0 = data.xs;
          if (!(typeof data0 == "number" && (!(data0 % 1) && !isNaN(data0)) && isFinite(data0))) {
            const err1 = { instancePath: instancePath + "/xs", schemaPath: "#/$defs/partial-cols-number/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }
            errors2++;
          }
          if (typeof data0 == "number" && isFinite(data0)) {
            if (data0 > 12 || isNaN(data0)) {
              const err2 = { instancePath: instancePath + "/xs", schemaPath: "#/$defs/partial-cols-number/maximum", keyword: "maximum", params: { comparison: "<=", limit: 12 }, message: "must be <= 12" };
              if (vErrors === null) {
                vErrors = [err2];
              } else {
                vErrors.push(err2);
              }
              errors2++;
            }
            if (data0 < 0 || isNaN(data0)) {
              const err3 = { instancePath: instancePath + "/xs", schemaPath: "#/$defs/partial-cols-number/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" };
              if (vErrors === null) {
                vErrors = [err3];
              } else {
                vErrors.push(err3);
              }
              errors2++;
            }
          }
        }
        if (data.sm !== void 0) {
          let data1 = data.sm;
          if (!(typeof data1 == "number" && (!(data1 % 1) && !isNaN(data1)) && isFinite(data1))) {
            const err4 = { instancePath: instancePath + "/sm", schemaPath: "#/$defs/partial-cols-number/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors2++;
          }
          if (typeof data1 == "number" && isFinite(data1)) {
            if (data1 > 12 || isNaN(data1)) {
              const err5 = { instancePath: instancePath + "/sm", schemaPath: "#/$defs/partial-cols-number/maximum", keyword: "maximum", params: { comparison: "<=", limit: 12 }, message: "must be <= 12" };
              if (vErrors === null) {
                vErrors = [err5];
              } else {
                vErrors.push(err5);
              }
              errors2++;
            }
            if (data1 < 0 || isNaN(data1)) {
              const err6 = { instancePath: instancePath + "/sm", schemaPath: "#/$defs/partial-cols-number/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" };
              if (vErrors === null) {
                vErrors = [err6];
              } else {
                vErrors.push(err6);
              }
              errors2++;
            }
          }
        }
        if (data.md !== void 0) {
          let data2 = data.md;
          if (!(typeof data2 == "number" && (!(data2 % 1) && !isNaN(data2)) && isFinite(data2))) {
            const err7 = { instancePath: instancePath + "/md", schemaPath: "#/$defs/partial-cols-number/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
            if (vErrors === null) {
              vErrors = [err7];
            } else {
              vErrors.push(err7);
            }
            errors2++;
          }
          if (typeof data2 == "number" && isFinite(data2)) {
            if (data2 > 12 || isNaN(data2)) {
              const err8 = { instancePath: instancePath + "/md", schemaPath: "#/$defs/partial-cols-number/maximum", keyword: "maximum", params: { comparison: "<=", limit: 12 }, message: "must be <= 12" };
              if (vErrors === null) {
                vErrors = [err8];
              } else {
                vErrors.push(err8);
              }
              errors2++;
            }
            if (data2 < 0 || isNaN(data2)) {
              const err9 = { instancePath: instancePath + "/md", schemaPath: "#/$defs/partial-cols-number/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" };
              if (vErrors === null) {
                vErrors = [err9];
              } else {
                vErrors.push(err9);
              }
              errors2++;
            }
          }
        }
        if (data.lg !== void 0) {
          let data3 = data.lg;
          if (!(typeof data3 == "number" && (!(data3 % 1) && !isNaN(data3)) && isFinite(data3))) {
            const err10 = { instancePath: instancePath + "/lg", schemaPath: "#/$defs/partial-cols-number/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
            if (vErrors === null) {
              vErrors = [err10];
            } else {
              vErrors.push(err10);
            }
            errors2++;
          }
          if (typeof data3 == "number" && isFinite(data3)) {
            if (data3 > 12 || isNaN(data3)) {
              const err11 = { instancePath: instancePath + "/lg", schemaPath: "#/$defs/partial-cols-number/maximum", keyword: "maximum", params: { comparison: "<=", limit: 12 }, message: "must be <= 12" };
              if (vErrors === null) {
                vErrors = [err11];
              } else {
                vErrors.push(err11);
              }
              errors2++;
            }
            if (data3 < 0 || isNaN(data3)) {
              const err12 = { instancePath: instancePath + "/lg", schemaPath: "#/$defs/partial-cols-number/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" };
              if (vErrors === null) {
                vErrors = [err12];
              } else {
                vErrors.push(err12);
              }
              errors2++;
            }
          }
        }
        if (data.xl !== void 0) {
          let data4 = data.xl;
          if (!(typeof data4 == "number" && (!(data4 % 1) && !isNaN(data4)) && isFinite(data4))) {
            const err13 = { instancePath: instancePath + "/xl", schemaPath: "#/$defs/partial-cols-number/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
            if (vErrors === null) {
              vErrors = [err13];
            } else {
              vErrors.push(err13);
            }
            errors2++;
          }
          if (typeof data4 == "number" && isFinite(data4)) {
            if (data4 > 12 || isNaN(data4)) {
              const err14 = { instancePath: instancePath + "/xl", schemaPath: "#/$defs/partial-cols-number/maximum", keyword: "maximum", params: { comparison: "<=", limit: 12 }, message: "must be <= 12" };
              if (vErrors === null) {
                vErrors = [err14];
              } else {
                vErrors.push(err14);
              }
              errors2++;
            }
            if (data4 < 0 || isNaN(data4)) {
              const err15 = { instancePath: instancePath + "/xl", schemaPath: "#/$defs/partial-cols-number/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" };
              if (vErrors === null) {
                vErrors = [err15];
              } else {
                vErrors.push(err15);
              }
              errors2++;
            }
          }
        }
        if (data.xxl !== void 0) {
          let data5 = data.xxl;
          if (!(typeof data5 == "number" && (!(data5 % 1) && !isNaN(data5)) && isFinite(data5))) {
            const err16 = { instancePath: instancePath + "/xxl", schemaPath: "#/$defs/partial-cols-number/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
            if (vErrors === null) {
              vErrors = [err16];
            } else {
              vErrors.push(err16);
            }
            errors2++;
          }
          if (typeof data5 == "number" && isFinite(data5)) {
            if (data5 > 12 || isNaN(data5)) {
              const err17 = { instancePath: instancePath + "/xxl", schemaPath: "#/$defs/partial-cols-number/maximum", keyword: "maximum", params: { comparison: "<=", limit: 12 }, message: "must be <= 12" };
              if (vErrors === null) {
                vErrors = [err17];
              } else {
                vErrors.push(err17);
              }
              errors2++;
            }
            if (data5 < 0 || isNaN(data5)) {
              const err18 = { instancePath: instancePath + "/xxl", schemaPath: "#/$defs/partial-cols-number/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" };
              if (vErrors === null) {
                vErrors = [err18];
              } else {
                vErrors.push(err18);
              }
              errors2++;
            }
          }
        }
      } else {
        const err19 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err19];
        } else {
          vErrors.push(err19);
        }
        errors2++;
      }
      validate41.errors = vErrors;
      return errors2 === 0;
    }
    validate41.evaluated = { "props": true, "dynamicProps": false, "dynamicItems": false };
    function validate40(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate40.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      const _errs0 = errors2;
      let valid0 = false;
      let passing0 = null;
      const _errs1 = errors2;
      if (!(typeof data == "number" && (!(data % 1) && !isNaN(data)) && isFinite(data))) {
        const err0 = { instancePath, schemaPath: "#/$defs/partial-cols-number/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors2++;
      }
      if (typeof data == "number" && isFinite(data)) {
        if (data > 12 || isNaN(data)) {
          const err1 = { instancePath, schemaPath: "#/$defs/partial-cols-number/maximum", keyword: "maximum", params: { comparison: "<=", limit: 12 }, message: "must be <= 12" };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors2++;
        }
        if (data < 0 || isNaN(data)) {
          const err2 = { instancePath, schemaPath: "#/$defs/partial-cols-number/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" };
          if (vErrors === null) {
            vErrors = [err2];
          } else {
            vErrors.push(err2);
          }
          errors2++;
        }
      }
      var _valid0 = _errs1 === errors2;
      if (_valid0) {
        valid0 = true;
        passing0 = 0;
      }
      const _errs4 = errors2;
      if (!validate41(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
        vErrors = vErrors === null ? validate41.errors : vErrors.concat(validate41.errors);
        errors2 = vErrors.length;
      }
      var _valid0 = _errs4 === errors2;
      if (_valid0 && valid0) {
        valid0 = false;
        passing0 = [passing0, 1];
      } else {
        if (_valid0) {
          valid0 = true;
          passing0 = 1;
          var props0 = true;
        }
      }
      if (!valid0) {
        const err3 = { instancePath, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
        if (vErrors === null) {
          vErrors = [err3];
        } else {
          vErrors.push(err3);
        }
        errors2++;
      } else {
        errors2 = _errs0;
        if (vErrors !== null) {
          if (_errs0) {
            vErrors.length = _errs0;
          } else {
            vErrors = null;
          }
        }
      }
      validate40.errors = vErrors;
      evaluated0.props = props0;
      return errors2 === 0;
    }
    validate40.evaluated = { "dynamicProps": true, "dynamicItems": false };
    function validate45(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate45.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      const _errs0 = errors2;
      let valid0 = false;
      let passing0 = null;
      const _errs1 = errors2;
      if (typeof data !== "string") {
        const err0 = { instancePath, schemaPath: "#/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors2++;
      }
      var _valid0 = _errs1 === errors2;
      if (_valid0) {
        valid0 = true;
        passing0 = 0;
      }
      const _errs3 = errors2;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.text === void 0) {
          const err1 = { instancePath, schemaPath: "#/$defs/partial-slot-text/required", keyword: "required", params: { missingProperty: "text" }, message: "must have required property 'text'" };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors2++;
        }
        for (const key0 in data) {
          if (!(key0 === "text")) {
            const err2 = { instancePath, schemaPath: "#/$defs/partial-slot-text/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors2++;
          }
        }
        if (data.text !== void 0) {
          if (typeof data.text !== "string") {
            const err3 = { instancePath: instancePath + "/text", schemaPath: "#/$defs/partial-slot-text/properties/text/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors2++;
          }
        }
      } else {
        const err4 = { instancePath, schemaPath: "#/$defs/partial-slot-text/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err4];
        } else {
          vErrors.push(err4);
        }
        errors2++;
      }
      var _valid0 = _errs3 === errors2;
      if (_valid0 && valid0) {
        valid0 = false;
        passing0 = [passing0, 1];
      } else {
        if (_valid0) {
          valid0 = true;
          passing0 = 1;
          var props0 = true;
        }
        const _errs9 = errors2;
        if (data && typeof data == "object" && !Array.isArray(data)) {
          if (data.markdown === void 0) {
            const err5 = { instancePath, schemaPath: "#/$defs/partial-slot-markdown/required", keyword: "required", params: { missingProperty: "markdown" }, message: "must have required property 'markdown'" };
            if (vErrors === null) {
              vErrors = [err5];
            } else {
              vErrors.push(err5);
            }
            errors2++;
          }
          for (const key1 in data) {
            if (!(key1 === "markdown")) {
              const err6 = { instancePath, schemaPath: "#/$defs/partial-slot-markdown/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties" };
              if (vErrors === null) {
                vErrors = [err6];
              } else {
                vErrors.push(err6);
              }
              errors2++;
            }
          }
          if (data.markdown !== void 0) {
            if (typeof data.markdown !== "string") {
              const err7 = { instancePath: instancePath + "/markdown", schemaPath: "#/$defs/partial-slot-markdown/properties/markdown/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err7];
              } else {
                vErrors.push(err7);
              }
              errors2++;
            }
          }
        } else {
          const err8 = { instancePath, schemaPath: "#/$defs/partial-slot-markdown/type", keyword: "type", params: { type: "object" }, message: "must be object" };
          if (vErrors === null) {
            vErrors = [err8];
          } else {
            vErrors.push(err8);
          }
          errors2++;
        }
        var _valid0 = _errs9 === errors2;
        if (_valid0 && valid0) {
          valid0 = false;
          passing0 = [passing0, 2];
        } else {
          if (_valid0) {
            valid0 = true;
            passing0 = 2;
            if (props0 !== true) {
              props0 = true;
            }
          }
          const _errs15 = errors2;
          if (data && typeof data == "object" && !Array.isArray(data)) {
            if (data.name === void 0) {
              const err9 = { instancePath, schemaPath: "#/$defs/partial-slot-name/required", keyword: "required", params: { missingProperty: "name" }, message: "must have required property 'name'" };
              if (vErrors === null) {
                vErrors = [err9];
              } else {
                vErrors.push(err9);
              }
              errors2++;
            }
            for (const key2 in data) {
              if (!(key2 === "name")) {
                const err10 = { instancePath, schemaPath: "#/$defs/partial-slot-name/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key2 }, message: "must NOT have additional properties" };
                if (vErrors === null) {
                  vErrors = [err10];
                } else {
                  vErrors.push(err10);
                }
                errors2++;
              }
            }
            if (data.name !== void 0) {
              if (typeof data.name !== "string") {
                const err11 = { instancePath: instancePath + "/name", schemaPath: "#/$defs/partial-slot-name/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err11];
                } else {
                  vErrors.push(err11);
                }
                errors2++;
              }
            }
          } else {
            const err12 = { instancePath, schemaPath: "#/$defs/partial-slot-name/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err12];
            } else {
              vErrors.push(err12);
            }
            errors2++;
          }
          var _valid0 = _errs15 === errors2;
          if (_valid0 && valid0) {
            valid0 = false;
            passing0 = [passing0, 3];
          } else {
            if (_valid0) {
              valid0 = true;
              passing0 = 3;
              if (props0 !== true) {
                props0 = true;
              }
            }
          }
        }
      }
      if (!valid0) {
        const err13 = { instancePath, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
        if (vErrors === null) {
          vErrors = [err13];
        } else {
          vErrors.push(err13);
        }
        errors2++;
      } else {
        errors2 = _errs0;
        if (vErrors !== null) {
          if (_errs0) {
            vErrors.length = _errs0;
          } else {
            vErrors = null;
          }
        }
      }
      validate45.errors = vErrors;
      evaluated0.props = props0;
      return errors2 === 0;
    }
    validate45.evaluated = { "dynamicProps": true, "dynamicItems": false };
    const pattern2$1 = new RegExp(".*", "u");
    function validate25(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate25.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.comp !== void 0) {
          let data0 = data.comp;
          if (typeof data0 !== "string") {
            const err0 = { instancePath: instancePath + "/comp", schemaPath: "#/$defs/comp-name/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err0];
            } else {
              vErrors.push(err0);
            }
            errors2++;
          }
          if (!(data0 === "none" || data0 === "text-field" || data0 === "number-field" || data0 === "textarea" || data0 === "markdown" || data0 === "checkbox" || data0 === "switch" || data0 === "slider" || data0 === "date-picker" || data0 === "date-time-picker" || data0 === "time-picker" || data0 === "color-picker" || data0 === "combobox" || data0 === "number-combobox" || data0 === "section" || data0 === "list" || data0 === "select" || data0 === "autocomplete" || data0 === "tabs" || data0 === "vertical-tabs" || data0 === "expansion-panels" || data0 === "stepper" || data0 === "one-of-select" || data0 === "file-input")) {
            const err1 = { instancePath: instancePath + "/comp", schemaPath: "#/$defs/comp-name/enum", keyword: "enum", params: { allowedValues: schema27.enum }, message: "must be equal to one of the allowed values" };
            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }
            errors2++;
          }
          if (errors2 > 0) {
            const emErrors0 = { "enum": [] };
            const templates0 = {};
            for (const err2 of vErrors) {
              if (err2.keyword !== "errorMessage" && !err2.emUsed && err2.instancePath === instancePath + "/comp" && err2.keyword in emErrors0 && err2.schemaPath.indexOf("#/$defs/comp-name") === 0 && /^\/[^\/]*$/.test(err2.schemaPath.slice(17))) {
                emErrors0[err2.keyword].push(err2);
                err2.emUsed = true;
              }
            }
            for (const key0 in emErrors0) {
              if (emErrors0[key0].length) {
                const err3 = { instancePath: instancePath + "/comp", schemaPath: "#/$defs/comp-name/errorMessage", keyword: "errorMessage", params: { errors: emErrors0[key0] }, message: key0 in templates0 ? templates0[key0]() : schema27.errorMessage[key0] };
                if (vErrors === null) {
                  vErrors = [err3];
                } else {
                  vErrors.push(err3);
                }
                errors2++;
              }
            }
            const emErrs0 = [];
            for (const err4 of vErrors) {
              if (!err4.emUsed) {
                emErrs0.push(err4);
              }
            }
            vErrors = emErrs0;
            errors2 = emErrs0.length;
          }
        }
        if (data.help !== void 0) {
          if (typeof data.help !== "string") {
            const err5 = { instancePath: instancePath + "/help", schemaPath: "#/properties/help/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err5];
            } else {
              vErrors.push(err5);
            }
            errors2++;
          }
        }
        if (data.children !== void 0) {
          if (!wrapper0.validate(data.children, { instancePath: instancePath + "/children", parentData: data, parentDataProperty: "children", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? wrapper0.validate.errors : vErrors.concat(wrapper0.validate.errors);
            errors2 = vErrors.length;
          }
        }
        if (data.label !== void 0) {
          if (typeof data.label !== "string") {
            const err6 = { instancePath: instancePath + "/label", schemaPath: "#/properties/label/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err6];
            } else {
              vErrors.push(err6);
            }
            errors2++;
          }
        }
        if (data.title !== void 0) {
          let data4 = data.title;
          if (typeof data4 !== "string" && data4 !== null) {
            const err7 = { instancePath: instancePath + "/title", schemaPath: "#/properties/title/type", keyword: "type", params: { type: schema30.properties.title.type }, message: "must be string,null" };
            if (vErrors === null) {
              vErrors = [err7];
            } else {
              vErrors.push(err7);
            }
            errors2++;
          }
        }
        if (data.subtitle !== void 0) {
          let data5 = data.subtitle;
          if (typeof data5 !== "string" && data5 !== null) {
            const err8 = { instancePath: instancePath + "/subtitle", schemaPath: "#/properties/subtitle/type", keyword: "type", params: { type: schema30.properties.subtitle.type }, message: "must be string,null" };
            if (vErrors === null) {
              vErrors = [err8];
            } else {
              vErrors.push(err8);
            }
            errors2++;
          }
        }
        if (data.step !== void 0) {
          let data6 = data.step;
          if (!(typeof data6 == "number" && isFinite(data6))) {
            const err9 = { instancePath: instancePath + "/step", schemaPath: "#/properties/step/type", keyword: "type", params: { type: "number" }, message: "must be number" };
            if (vErrors === null) {
              vErrors = [err9];
            } else {
              vErrors.push(err9);
            }
            errors2++;
          }
        }
        if (data.if !== void 0) {
          if (!validate26(data.if, { instancePath: instancePath + "/if", parentData: data, parentDataProperty: "if", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate26.errors : vErrors.concat(validate26.errors);
            errors2 = vErrors.length;
          }
        }
        if (data.items !== void 0) {
          let data8 = data.items;
          if (Array.isArray(data8)) {
            const len0 = data8.length;
            for (let i0 = 0; i0 < len0; i0++) {
              let data9 = data8[i0];
              const _errs20 = errors2;
              let valid5 = false;
              let passing0 = null;
              const _errs21 = errors2;
              if (typeof data9 !== "string") {
                const err10 = { instancePath: instancePath + "/items/" + i0, schemaPath: "#/$defs/partial-select-item/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err10];
                } else {
                  vErrors.push(err10);
                }
                errors2++;
              }
              var _valid0 = _errs21 === errors2;
              if (_valid0) {
                valid5 = true;
                passing0 = 0;
              }
              const _errs23 = errors2;
              if (data9 && typeof data9 == "object" && !Array.isArray(data9)) {
                if (data9.key !== void 0) {
                  if (typeof data9.key !== "string") {
                    const err11 = { instancePath: instancePath + "/items/" + i0 + "/key", schemaPath: "#/$defs/partial-select-item/oneOf/1/properties/key/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                      vErrors = [err11];
                    } else {
                      vErrors.push(err11);
                    }
                    errors2++;
                  }
                }
                if (data9.title !== void 0) {
                  if (typeof data9.title !== "string") {
                    const err12 = { instancePath: instancePath + "/items/" + i0 + "/title", schemaPath: "#/$defs/partial-select-item/oneOf/1/properties/title/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                      vErrors = [err12];
                    } else {
                      vErrors.push(err12);
                    }
                    errors2++;
                  }
                }
              } else {
                const err13 = { instancePath: instancePath + "/items/" + i0, schemaPath: "#/$defs/partial-select-item/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                if (vErrors === null) {
                  vErrors = [err13];
                } else {
                  vErrors.push(err13);
                }
                errors2++;
              }
              var _valid0 = _errs23 === errors2;
              if (_valid0 && valid5) {
                valid5 = false;
                passing0 = [passing0, 1];
              } else {
                if (_valid0) {
                  valid5 = true;
                  passing0 = 1;
                  var props2 = {};
                  props2.key = true;
                  props2.title = true;
                  props2.value = true;
                }
              }
              if (!valid5) {
                const err14 = { instancePath: instancePath + "/items/" + i0, schemaPath: "#/$defs/partial-select-item/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
                if (vErrors === null) {
                  vErrors = [err14];
                } else {
                  vErrors.push(err14);
                }
                errors2++;
              } else {
                errors2 = _errs20;
                if (vErrors !== null) {
                  if (_errs20) {
                    vErrors.length = _errs20;
                  } else {
                    vErrors = null;
                  }
                }
              }
            }
          } else {
            const err15 = { instancePath: instancePath + "/items", schemaPath: "#/properties/items/type", keyword: "type", params: { type: "array" }, message: "must be array" };
            if (vErrors === null) {
              vErrors = [err15];
            } else {
              vErrors.push(err15);
            }
            errors2++;
          }
        }
        if (data.getItems !== void 0) {
          if (!validate28(data.getItems, { instancePath: instancePath + "/getItems", parentData: data, parentDataProperty: "getItems", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate28.errors : vErrors.concat(validate28.errors);
            errors2 = vErrors.length;
          }
        }
        if (data.listEditMode !== void 0) {
          let data13 = data.listEditMode;
          if (typeof data13 !== "string") {
            const err16 = { instancePath: instancePath + "/listEditMode", schemaPath: "#/properties/listEditMode/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err16];
            } else {
              vErrors.push(err16);
            }
            errors2++;
          }
          if (!(data13 === "inline" || data13 === "inline-single" || data13 === "menu" || data13 === "dialog")) {
            const err17 = { instancePath: instancePath + "/listEditMode", schemaPath: "#/properties/listEditMode/enum", keyword: "enum", params: { allowedValues: schema30.properties.listEditMode.enum }, message: "must be equal to one of the allowed values" };
            if (vErrors === null) {
              vErrors = [err17];
            } else {
              vErrors.push(err17);
            }
            errors2++;
          }
        }
        if (data.listActions !== void 0) {
          let data14 = data.listActions;
          if (Array.isArray(data14)) {
            const len1 = data14.length;
            for (let i1 = 0; i1 < len1; i1++) {
              let data15 = data14[i1];
              if (typeof data15 !== "string") {
                const err18 = { instancePath: instancePath + "/listActions/" + i1, schemaPath: "#/properties/listActions/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err18];
                } else {
                  vErrors.push(err18);
                }
                errors2++;
              }
              if (!(data15 === "add" || data15 === "edit" || data15 === "delete" || data15 === "sort" || data15 === "duplicate")) {
                const err19 = { instancePath: instancePath + "/listActions/" + i1, schemaPath: "#/properties/listActions/items/enum", keyword: "enum", params: { allowedValues: schema30.properties.listActions.items.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err19];
                } else {
                  vErrors.push(err19);
                }
                errors2++;
              }
            }
          } else {
            const err20 = { instancePath: instancePath + "/listActions", schemaPath: "#/properties/listActions/type", keyword: "type", params: { type: "array" }, message: "must be array" };
            if (vErrors === null) {
              vErrors = [err20];
            } else {
              vErrors.push(err20);
            }
            errors2++;
          }
        }
        if (data.cols !== void 0) {
          if (!validate40(data.cols, { instancePath: instancePath + "/cols", parentData: data, parentDataProperty: "cols", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate40.errors : vErrors.concat(validate40.errors);
            errors2 = vErrors.length;
          }
        }
        if (data.props !== void 0) {
          let data17 = data.props;
          if (!(data17 && typeof data17 == "object" && !Array.isArray(data17))) {
            const err21 = { instancePath: instancePath + "/props", schemaPath: "#/properties/props/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err21];
            } else {
              vErrors.push(err21);
            }
            errors2++;
          }
        }
        if (data.getProps !== void 0) {
          if (!validate26(data.getProps, { instancePath: instancePath + "/getProps", parentData: data, parentDataProperty: "getProps", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate26.errors : vErrors.concat(validate26.errors);
            errors2 = vErrors.length;
          }
        }
        if (data.slots !== void 0) {
          let data19 = data.slots;
          if (data19 && typeof data19 == "object" && !Array.isArray(data19)) {
            var props6 = {};
            for (const key1 in data19) {
              if (pattern2$1.test(key1)) {
                if (!validate45(data19[key1], { instancePath: instancePath + "/slots/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data19, parentDataProperty: key1, rootData, dynamicAnchors })) {
                  vErrors = vErrors === null ? validate45.errors : vErrors.concat(validate45.errors);
                  errors2 = vErrors.length;
                }
                props6[key1] = true;
              }
            }
          } else {
            const err22 = { instancePath: instancePath + "/slots", schemaPath: "#/properties/slots/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err22];
            } else {
              vErrors.push(err22);
            }
            errors2++;
          }
        }
        if (data.options !== void 0) {
          let data21 = data.options;
          if (!(data21 && typeof data21 == "object" && !Array.isArray(data21))) {
            const err23 = { instancePath: instancePath + "/options", schemaPath: "#/properties/options/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err23];
            } else {
              vErrors.push(err23);
            }
            errors2++;
          }
        }
        if (data.getOptions !== void 0) {
          if (!validate26(data.getOptions, { instancePath: instancePath + "/getOptions", parentData: data, parentDataProperty: "getOptions", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate26.errors : vErrors.concat(validate26.errors);
            errors2 = vErrors.length;
          }
        }
        if (data.messages !== void 0) {
          let data23 = data.messages;
          if (!(data23 && typeof data23 == "object" && !Array.isArray(data23))) {
            const err24 = { instancePath: instancePath + "/messages", schemaPath: "#/properties/messages/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err24];
            } else {
              vErrors.push(err24);
            }
            errors2++;
          }
        }
        if (data.getDefaultData !== void 0) {
          if (!validate26(data.getDefaultData, { instancePath: instancePath + "/getDefaultData", parentData: data, parentDataProperty: "getDefaultData", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate26.errors : vErrors.concat(validate26.errors);
            errors2 = vErrors.length;
          }
        }
        if (data.getConstData !== void 0) {
          if (!validate26(data.getConstData, { instancePath: instancePath + "/getConstData", parentData: data, parentDataProperty: "getConstData", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate26.errors : vErrors.concat(validate26.errors);
            errors2 = vErrors.length;
          }
        }
        if (data.transformData !== void 0) {
          if (!validate26(data.transformData, { instancePath: instancePath + "/transformData", parentData: data, parentDataProperty: "transformData", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate26.errors : vErrors.concat(validate26.errors);
            errors2 = vErrors.length;
          }
        }
        if (data.autofocus !== void 0) {
          if (typeof data.autofocus !== "boolean") {
            const err25 = { instancePath: instancePath + "/autofocus", schemaPath: "#/properties/autofocus/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
            if (vErrors === null) {
              vErrors = [err25];
            } else {
              vErrors.push(err25);
            }
            errors2++;
          }
        }
      } else {
        const err26 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err26];
        } else {
          vErrors.push(err26);
        }
        errors2++;
      }
      validate25.errors = vErrors;
      return errors2 === 0;
    }
    validate25.evaluated = { "props": { "comp": true, "help": true, "children": true, "label": true, "title": true, "subtitle": true, "step": true, "if": true, "items": true, "getItems": true, "listEditMode": true, "listActions": true, "cols": true, "props": true, "getProps": true, "slots": true, "options": true, "getOptions": true, "messages": true, "defaultData": true, "getDefaultData": true, "constData": true, "getConstData": true, "transformData": true, "autofocus": true }, "dynamicProps": false, "dynamicItems": false };
    function validate24(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate24.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (!validate25(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
        vErrors = vErrors === null ? validate25.errors : vErrors.concat(validate25.errors);
        errors2 = vErrors.length;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.key !== void 0) {
          let data0 = data.key;
          if (typeof data0 !== "string" && !(typeof data0 == "number" && (!(data0 % 1) && !isNaN(data0)) && isFinite(data0))) {
            const err0 = { instancePath: instancePath + "/key", schemaPath: "#/properties/key/type", keyword: "type", params: { type: schema29.properties.key.type }, message: "must be string,integer" };
            if (vErrors === null) {
              vErrors = [err0];
            } else {
              vErrors.push(err0);
            }
            errors2++;
          }
        }
        if (data.cols !== void 0) {
          if (!validate40(data.cols, { instancePath: instancePath + "/cols", parentData: data, parentDataProperty: "cols", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate40.errors : vErrors.concat(validate40.errors);
            errors2 = vErrors.length;
          }
        }
        for (const key0 in data) {
          if (key0 !== "key" && key0 !== "cols" && key0 !== "comp" && key0 !== "help" && key0 !== "children" && key0 !== "label" && key0 !== "title" && key0 !== "subtitle" && key0 !== "step" && key0 !== "if" && key0 !== "items" && key0 !== "getItems" && key0 !== "listEditMode" && key0 !== "listActions" && key0 !== "props" && key0 !== "getProps" && key0 !== "slots" && key0 !== "options" && key0 !== "getOptions" && key0 !== "messages" && key0 !== "defaultData" && key0 !== "getDefaultData" && key0 !== "constData" && key0 !== "getConstData" && key0 !== "transformData" && key0 !== "autofocus") {
            const err1 = { instancePath, schemaPath: "#/unevaluatedProperties", keyword: "unevaluatedProperties", params: { unevaluatedProperty: key0 }, message: "must NOT have unevaluated properties" };
            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }
            errors2++;
          }
        }
      } else {
        const err2 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err2];
        } else {
          vErrors.push(err2);
        }
        errors2++;
      }
      validate24.errors = vErrors;
      return errors2 === 0;
    }
    validate24.evaluated = { "props": true, "dynamicProps": false, "dynamicItems": false };
    function validate23(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate23.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (Array.isArray(data)) {
        const len0 = data.length;
        for (let i0 = 0; i0 < len0; i0++) {
          let data0 = data[i0];
          const _errs2 = errors2;
          let valid2 = false;
          let passing0 = null;
          const _errs3 = errors2;
          if (typeof data0 !== "string") {
            const err0 = { instancePath: instancePath + "/" + i0, schemaPath: "#/items/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err0];
            } else {
              vErrors.push(err0);
            }
            errors2++;
          }
          var _valid0 = _errs3 === errors2;
          if (_valid0) {
            valid2 = true;
            passing0 = 0;
          }
          const _errs5 = errors2;
          if (!validate24(data0, { instancePath: instancePath + "/" + i0, parentData: data, parentDataProperty: i0, rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate24.errors : vErrors.concat(validate24.errors);
            errors2 = vErrors.length;
          }
          var _valid0 = _errs5 === errors2;
          if (_valid0 && valid2) {
            valid2 = false;
            passing0 = [passing0, 1];
          } else {
            if (_valid0) {
              valid2 = true;
              passing0 = 1;
            }
          }
          if (!valid2) {
            const err1 = { instancePath: instancePath + "/" + i0, schemaPath: "#/items/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }
            errors2++;
          } else {
            errors2 = _errs2;
            if (vErrors !== null) {
              if (_errs2) {
                vErrors.length = _errs2;
              } else {
                vErrors = null;
              }
            }
          }
        }
      } else {
        const err2 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "array" }, message: "must be array" };
        if (vErrors === null) {
          vErrors = [err2];
        } else {
          vErrors.push(err2);
        }
        errors2++;
      }
      validate23.errors = vErrors;
      return errors2 === 0;
    }
    validate23.evaluated = { "items": true, "dynamicProps": false, "dynamicItems": false };
    function validate56(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate56.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.switch === void 0) {
          const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "switch" }, message: "must have required property 'switch'" };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors2++;
        }
        for (const key0 in data) {
          if (!(key0 === "switch")) {
            const err1 = { instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" };
            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }
            errors2++;
          }
        }
        if (data.switch !== void 0) {
          let data0 = data.switch;
          if (Array.isArray(data0)) {
            const len0 = data0.length;
            for (let i0 = 0; i0 < len0; i0++) {
              if (!validate25(data0[i0], { instancePath: instancePath + "/switch/" + i0, parentData: data0, parentDataProperty: i0, rootData, dynamicAnchors })) {
                vErrors = vErrors === null ? validate25.errors : vErrors.concat(validate25.errors);
                errors2 = vErrors.length;
              }
            }
          } else {
            const err2 = { instancePath: instancePath + "/switch", schemaPath: "#/properties/switch/type", keyword: "type", params: { type: "array" }, message: "must be array" };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors2++;
          }
        }
      } else {
        const err3 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err3];
        } else {
          vErrors.push(err3);
        }
        errors2++;
      }
      validate56.errors = vErrors;
      return errors2 === 0;
    }
    validate56.evaluated = { "props": true, "dynamicProps": false, "dynamicItems": false };
    function validate22(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate22.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      const _errs0 = errors2;
      let valid0 = false;
      const _errs1 = errors2;
      if (typeof data !== "string") {
        const err0 = { instancePath, schemaPath: "#/$defs/comp-name/type", keyword: "type", params: { type: "string" }, message: "must be string" };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors2++;
      }
      if (!(data === "none" || data === "text-field" || data === "number-field" || data === "textarea" || data === "markdown" || data === "checkbox" || data === "switch" || data === "slider" || data === "date-picker" || data === "date-time-picker" || data === "time-picker" || data === "color-picker" || data === "combobox" || data === "number-combobox" || data === "section" || data === "list" || data === "select" || data === "autocomplete" || data === "tabs" || data === "vertical-tabs" || data === "expansion-panels" || data === "stepper" || data === "one-of-select" || data === "file-input")) {
        const err1 = { instancePath, schemaPath: "#/$defs/comp-name/enum", keyword: "enum", params: { allowedValues: schema27.enum }, message: "must be equal to one of the allowed values" };
        if (vErrors === null) {
          vErrors = [err1];
        } else {
          vErrors.push(err1);
        }
        errors2++;
      }
      if (errors2 > 0) {
        const emErrors0 = { "enum": [] };
        const templates0 = {};
        for (const err2 of vErrors) {
          if (err2.keyword !== "errorMessage" && !err2.emUsed && err2.instancePath === instancePath && err2.keyword in emErrors0 && err2.schemaPath.indexOf("#/$defs/comp-name") === 0 && /^\/[^\/]*$/.test(err2.schemaPath.slice(17))) {
            emErrors0[err2.keyword].push(err2);
            err2.emUsed = true;
          }
        }
        for (const key0 in emErrors0) {
          if (emErrors0[key0].length) {
            const err3 = { instancePath, schemaPath: "#/$defs/comp-name/errorMessage", keyword: "errorMessage", params: { errors: emErrors0[key0] }, message: key0 in templates0 ? templates0[key0]() : schema27.errorMessage[key0] };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors2++;
          }
        }
        const emErrs0 = [];
        for (const err4 of vErrors) {
          if (!err4.emUsed) {
            emErrs0.push(err4);
          }
        }
        vErrors = emErrs0;
        errors2 = emErrs0.length;
      }
      var _valid0 = _errs1 === errors2;
      valid0 = valid0 || _valid0;
      const _errs4 = errors2;
      if (!validate23(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
        vErrors = vErrors === null ? validate23.errors : vErrors.concat(validate23.errors);
        errors2 = vErrors.length;
      }
      var _valid0 = _errs4 === errors2;
      valid0 = valid0 || _valid0;
      if (_valid0) {
        var items0 = true;
      }
      const _errs5 = errors2;
      if (!validate25(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
        vErrors = vErrors === null ? validate25.errors : vErrors.concat(validate25.errors);
        errors2 = vErrors.length;
      }
      var _valid0 = _errs5 === errors2;
      valid0 = valid0 || _valid0;
      if (_valid0) {
        var props0 = {};
        props0.comp = true;
        props0.help = true;
        props0.children = true;
        props0.label = true;
        props0.title = true;
        props0.subtitle = true;
        props0.step = true;
        props0.if = true;
        props0.items = true;
        props0.getItems = true;
        props0.listEditMode = true;
        props0.listActions = true;
        props0.cols = true;
        props0.props = true;
        props0.getProps = true;
        props0.slots = true;
        props0.options = true;
        props0.getOptions = true;
        props0.messages = true;
        props0.defaultData = true;
        props0.getDefaultData = true;
        props0.constData = true;
        props0.getConstData = true;
        props0.transformData = true;
        props0.autofocus = true;
      }
      const _errs6 = errors2;
      if (!validate56(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
        vErrors = vErrors === null ? validate56.errors : vErrors.concat(validate56.errors);
        errors2 = vErrors.length;
      }
      var _valid0 = _errs6 === errors2;
      valid0 = valid0 || _valid0;
      if (_valid0) {
        if (props0 !== true) {
          props0 = true;
        }
      }
      if (!valid0) {
        const err5 = { instancePath, schemaPath: "#/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
        if (vErrors === null) {
          vErrors = [err5];
        } else {
          vErrors.push(err5);
        }
        errors2++;
      } else {
        errors2 = _errs0;
        if (vErrors !== null) {
          if (_errs0) {
            vErrors.length = _errs0;
          } else {
            vErrors = null;
          }
        }
      }
      if (errors2 > 0) {
        const emErrors1 = { "anyOf": [] };
        const templates1 = {};
        for (const err6 of vErrors) {
          if (err6.keyword !== "errorMessage" && !err6.emUsed && err6.instancePath === instancePath && err6.keyword in emErrors1 && err6.schemaPath.indexOf("#") === 0 && /^\/[^\/]*$/.test(err6.schemaPath.slice(1))) {
            emErrors1[err6.keyword].push(err6);
            err6.emUsed = true;
          }
        }
        for (const key1 in emErrors1) {
          if (emErrors1[key1].length) {
            const err7 = { instancePath, schemaPath: "#/errorMessage", keyword: "errorMessage", params: { errors: emErrors1[key1] }, message: key1 in templates1 ? templates1[key1]() : schema26.errorMessage[key1] };
            if (vErrors === null) {
              vErrors = [err7];
            } else {
              vErrors.push(err7);
            }
            errors2++;
          }
        }
        const emErrs1 = [];
        for (const err8 of vErrors) {
          if (!err8.emUsed) {
            emErrs1.push(err8);
          }
        }
        vErrors = emErrs1;
        errors2 = emErrs1.length;
      }
      validate22.errors = vErrors;
      evaluated0.props = props0;
      evaluated0.items = items0;
      return errors2 === 0;
    }
    validate22.evaluated = { "dynamicProps": true, "dynamicItems": true };
    const validateLayoutKeyword = (
      /** @type {any} */
      validate22
    );
    function isComponentName(layoutKeyword) {
      return typeof layoutKeyword === "string";
    }
    function isPartialSwitch(layoutKeyword) {
      return typeof layoutKeyword === "object" && "switch" in layoutKeyword;
    }
    function isPartialChildren(layoutKeyword) {
      return Array.isArray(layoutKeyword);
    }
    function isPartialCompObject(layoutKeyword) {
      return typeof layoutKeyword === "object" && !Array.isArray(layoutKeyword);
    }
    function isPartialGetItemsExpr(getItems) {
      return typeof getItems === "string" || !!getItems.expr;
    }
    function isPartialGetItemsObj(getItems) {
      return typeof getItems === "object";
    }
    function isPartialGetItemsFetch(getItems) {
      return typeof getItems === "object" && !!getItems.url;
    }
    function isPartialSlotMarkdown(partialSlot) {
      return typeof partialSlot == "object" && !!/** @type {PartialSlotMarkdown} */
      partialSlot.markdown;
    }
    const schema56 = { "type": "object", "required": ["type", "expr", "pure"], "properties": { "type": { "type": "string", "enum": ["js-fn", "js-eval", "js-tpl"] }, "expr": { "type": "string" }, "pure": { "type": "boolean" }, "ref": { "type": "integer", "readOnly": true } } };
    const schema112 = { "type": "object", "required": ["comp", "label"], "properties": { "comp": { "const": "date-picker" }, "label": { "type": "string" }, "min": { "type": "string", "format": "date" }, "max": { "type": "string", "format": "date" }, "format": { "type": "string", "enum": ["date", "date-time"], "default": "date" } } };
    const schema57 = { "type": "object", "allOf": [{ "$ref": "#/$defs/state-node-options-base-lib" }, { "properties": { "readOnly": { "type": "boolean", "default": false }, "summary": { "type": "boolean", "default": false }, "titleDepth": { "type": "integer", "minimum": 1, "maximum": 6, "default": 2 }, "density": { "type": "string", "enum": ["default", "comfortable", "compact"] } } }] };
    const pattern2 = new RegExp(".*", "u");
    function validate62(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate62.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (!(data && typeof data == "object" && !Array.isArray(data))) {
        const err0 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors2++;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        var props0 = {};
        for (const key0 in data) {
          if (pattern2.test(key0)) {
            props0[key0] = true;
          }
        }
      } else {
        const err1 = { instancePath, schemaPath: "#/$defs/state-node-options-base-lib/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err1];
        } else {
          vErrors.push(err1);
        }
        errors2++;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.readOnly !== void 0) {
          if (typeof data.readOnly !== "boolean") {
            const err2 = { instancePath: instancePath + "/readOnly", schemaPath: "#/allOf/1/properties/readOnly/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors2++;
          }
        }
        if (data.summary !== void 0) {
          if (typeof data.summary !== "boolean") {
            const err3 = { instancePath: instancePath + "/summary", schemaPath: "#/allOf/1/properties/summary/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors2++;
          }
        }
        if (data.titleDepth !== void 0) {
          let data2 = data.titleDepth;
          if (!(typeof data2 == "number" && (!(data2 % 1) && !isNaN(data2)) && isFinite(data2))) {
            const err4 = { instancePath: instancePath + "/titleDepth", schemaPath: "#/allOf/1/properties/titleDepth/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors2++;
          }
          if (typeof data2 == "number" && isFinite(data2)) {
            if (data2 > 6 || isNaN(data2)) {
              const err5 = { instancePath: instancePath + "/titleDepth", schemaPath: "#/allOf/1/properties/titleDepth/maximum", keyword: "maximum", params: { comparison: "<=", limit: 6 }, message: "must be <= 6" };
              if (vErrors === null) {
                vErrors = [err5];
              } else {
                vErrors.push(err5);
              }
              errors2++;
            }
            if (data2 < 1 || isNaN(data2)) {
              const err6 = { instancePath: instancePath + "/titleDepth", schemaPath: "#/allOf/1/properties/titleDepth/minimum", keyword: "minimum", params: { comparison: ">=", limit: 1 }, message: "must be >= 1" };
              if (vErrors === null) {
                vErrors = [err6];
              } else {
                vErrors.push(err6);
              }
              errors2++;
            }
          }
        }
        if (data.density !== void 0) {
          let data3 = data.density;
          if (typeof data3 !== "string") {
            const err7 = { instancePath: instancePath + "/density", schemaPath: "#/allOf/1/properties/density/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err7];
            } else {
              vErrors.push(err7);
            }
            errors2++;
          }
          if (!(data3 === "default" || data3 === "comfortable" || data3 === "compact")) {
            const err8 = { instancePath: instancePath + "/density", schemaPath: "#/allOf/1/properties/density/enum", keyword: "enum", params: { allowedValues: schema57.allOf[1].properties.density.enum }, message: "must be equal to one of the allowed values" };
            if (vErrors === null) {
              vErrors = [err8];
            } else {
              vErrors.push(err8);
            }
            errors2++;
          }
        }
      }
      if (props0 !== true) {
        props0 = props0 || {};
        props0.readOnly = true;
        props0.summary = true;
        props0.titleDepth = true;
        props0.density = true;
      }
      validate62.errors = vErrors;
      evaluated0.props = props0;
      return errors2 === 0;
    }
    validate62.evaluated = { "dynamicProps": true, "dynamicItems": false };
    function validate64(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate64.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.xs === void 0) {
          const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "xs" }, message: "must have required property 'xs'" };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors2++;
        }
        for (const key0 in data) {
          if (!(key0 === "xs" || key0 === "sm" || key0 === "md" || key0 === "lg" || key0 === "xl" || key0 === "xxl")) {
            const err1 = { instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" };
            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }
            errors2++;
          }
        }
        if (data.xs !== void 0) {
          let data0 = data.xs;
          if (!(typeof data0 == "number" && (!(data0 % 1) && !isNaN(data0)) && isFinite(data0))) {
            const err2 = { instancePath: instancePath + "/xs", schemaPath: "#/$defs/cols/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors2++;
          }
          if (typeof data0 == "number" && isFinite(data0)) {
            if (data0 > 12 || isNaN(data0)) {
              const err3 = { instancePath: instancePath + "/xs", schemaPath: "#/$defs/cols/maximum", keyword: "maximum", params: { comparison: "<=", limit: 12 }, message: "must be <= 12" };
              if (vErrors === null) {
                vErrors = [err3];
              } else {
                vErrors.push(err3);
              }
              errors2++;
            }
            if (data0 < 0 || isNaN(data0)) {
              const err4 = { instancePath: instancePath + "/xs", schemaPath: "#/$defs/cols/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" };
              if (vErrors === null) {
                vErrors = [err4];
              } else {
                vErrors.push(err4);
              }
              errors2++;
            }
          }
        }
        if (data.sm !== void 0) {
          let data1 = data.sm;
          if (!(typeof data1 == "number" && (!(data1 % 1) && !isNaN(data1)) && isFinite(data1))) {
            const err5 = { instancePath: instancePath + "/sm", schemaPath: "#/$defs/cols/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
            if (vErrors === null) {
              vErrors = [err5];
            } else {
              vErrors.push(err5);
            }
            errors2++;
          }
          if (typeof data1 == "number" && isFinite(data1)) {
            if (data1 > 12 || isNaN(data1)) {
              const err6 = { instancePath: instancePath + "/sm", schemaPath: "#/$defs/cols/maximum", keyword: "maximum", params: { comparison: "<=", limit: 12 }, message: "must be <= 12" };
              if (vErrors === null) {
                vErrors = [err6];
              } else {
                vErrors.push(err6);
              }
              errors2++;
            }
            if (data1 < 0 || isNaN(data1)) {
              const err7 = { instancePath: instancePath + "/sm", schemaPath: "#/$defs/cols/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" };
              if (vErrors === null) {
                vErrors = [err7];
              } else {
                vErrors.push(err7);
              }
              errors2++;
            }
          }
        }
        if (data.md !== void 0) {
          let data2 = data.md;
          if (!(typeof data2 == "number" && (!(data2 % 1) && !isNaN(data2)) && isFinite(data2))) {
            const err8 = { instancePath: instancePath + "/md", schemaPath: "#/$defs/cols/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
            if (vErrors === null) {
              vErrors = [err8];
            } else {
              vErrors.push(err8);
            }
            errors2++;
          }
          if (typeof data2 == "number" && isFinite(data2)) {
            if (data2 > 12 || isNaN(data2)) {
              const err9 = { instancePath: instancePath + "/md", schemaPath: "#/$defs/cols/maximum", keyword: "maximum", params: { comparison: "<=", limit: 12 }, message: "must be <= 12" };
              if (vErrors === null) {
                vErrors = [err9];
              } else {
                vErrors.push(err9);
              }
              errors2++;
            }
            if (data2 < 0 || isNaN(data2)) {
              const err10 = { instancePath: instancePath + "/md", schemaPath: "#/$defs/cols/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" };
              if (vErrors === null) {
                vErrors = [err10];
              } else {
                vErrors.push(err10);
              }
              errors2++;
            }
          }
        }
        if (data.lg !== void 0) {
          let data3 = data.lg;
          if (!(typeof data3 == "number" && (!(data3 % 1) && !isNaN(data3)) && isFinite(data3))) {
            const err11 = { instancePath: instancePath + "/lg", schemaPath: "#/$defs/cols/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
            if (vErrors === null) {
              vErrors = [err11];
            } else {
              vErrors.push(err11);
            }
            errors2++;
          }
          if (typeof data3 == "number" && isFinite(data3)) {
            if (data3 > 12 || isNaN(data3)) {
              const err12 = { instancePath: instancePath + "/lg", schemaPath: "#/$defs/cols/maximum", keyword: "maximum", params: { comparison: "<=", limit: 12 }, message: "must be <= 12" };
              if (vErrors === null) {
                vErrors = [err12];
              } else {
                vErrors.push(err12);
              }
              errors2++;
            }
            if (data3 < 0 || isNaN(data3)) {
              const err13 = { instancePath: instancePath + "/lg", schemaPath: "#/$defs/cols/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" };
              if (vErrors === null) {
                vErrors = [err13];
              } else {
                vErrors.push(err13);
              }
              errors2++;
            }
          }
        }
        if (data.xl !== void 0) {
          let data4 = data.xl;
          if (!(typeof data4 == "number" && (!(data4 % 1) && !isNaN(data4)) && isFinite(data4))) {
            const err14 = { instancePath: instancePath + "/xl", schemaPath: "#/$defs/cols/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
            if (vErrors === null) {
              vErrors = [err14];
            } else {
              vErrors.push(err14);
            }
            errors2++;
          }
          if (typeof data4 == "number" && isFinite(data4)) {
            if (data4 > 12 || isNaN(data4)) {
              const err15 = { instancePath: instancePath + "/xl", schemaPath: "#/$defs/cols/maximum", keyword: "maximum", params: { comparison: "<=", limit: 12 }, message: "must be <= 12" };
              if (vErrors === null) {
                vErrors = [err15];
              } else {
                vErrors.push(err15);
              }
              errors2++;
            }
            if (data4 < 0 || isNaN(data4)) {
              const err16 = { instancePath: instancePath + "/xl", schemaPath: "#/$defs/cols/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" };
              if (vErrors === null) {
                vErrors = [err16];
              } else {
                vErrors.push(err16);
              }
              errors2++;
            }
          }
        }
        if (data.xxl !== void 0) {
          let data5 = data.xxl;
          if (!(typeof data5 == "number" && (!(data5 % 1) && !isNaN(data5)) && isFinite(data5))) {
            const err17 = { instancePath: instancePath + "/xxl", schemaPath: "#/$defs/cols/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
            if (vErrors === null) {
              vErrors = [err17];
            } else {
              vErrors.push(err17);
            }
            errors2++;
          }
          if (typeof data5 == "number" && isFinite(data5)) {
            if (data5 > 12 || isNaN(data5)) {
              const err18 = { instancePath: instancePath + "/xxl", schemaPath: "#/$defs/cols/maximum", keyword: "maximum", params: { comparison: "<=", limit: 12 }, message: "must be <= 12" };
              if (vErrors === null) {
                vErrors = [err18];
              } else {
                vErrors.push(err18);
              }
              errors2++;
            }
            if (data5 < 0 || isNaN(data5)) {
              const err19 = { instancePath: instancePath + "/xxl", schemaPath: "#/$defs/cols/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" };
              if (vErrors === null) {
                vErrors = [err19];
              } else {
                vErrors.push(err19);
              }
              errors2++;
            }
          }
        }
      } else {
        const err20 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err20];
        } else {
          vErrors.push(err20);
        }
        errors2++;
      }
      validate64.errors = vErrors;
      return errors2 === 0;
    }
    validate64.evaluated = { "props": true, "dynamicProps": false, "dynamicItems": false };
    function validate66(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate66.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        var props0 = {};
        for (const key0 in data) {
          if (pattern2.test(key0)) {
            let data0 = data[key0];
            const _errs3 = errors2;
            let valid2 = false;
            let passing0 = null;
            const _errs4 = errors2;
            if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
              if (data0.text === void 0) {
                const err0 = { instancePath: instancePath + "/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/$defs/slot/oneOf/0/required", keyword: "required", params: { missingProperty: "text" }, message: "must have required property 'text'" };
                if (vErrors === null) {
                  vErrors = [err0];
                } else {
                  vErrors.push(err0);
                }
                errors2++;
              }
              for (const key1 in data0) {
                if (!(key1 === "text")) {
                  const err1 = { instancePath: instancePath + "/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/$defs/slot/oneOf/0/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties" };
                  if (vErrors === null) {
                    vErrors = [err1];
                  } else {
                    vErrors.push(err1);
                  }
                  errors2++;
                }
              }
              if (data0.text !== void 0) {
                if (typeof data0.text !== "string") {
                  const err2 = { instancePath: instancePath + "/" + key0.replace(/~/g, "~0").replace(/\//g, "~1") + "/text", schemaPath: "#/$defs/slot/oneOf/0/properties/text/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err2];
                  } else {
                    vErrors.push(err2);
                  }
                  errors2++;
                }
              }
            } else {
              const err3 = { instancePath: instancePath + "/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/$defs/slot/oneOf/0/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err3];
              } else {
                vErrors.push(err3);
              }
              errors2++;
            }
            var _valid0 = _errs4 === errors2;
            if (_valid0) {
              valid2 = true;
              passing0 = 0;
            }
            const _errs9 = errors2;
            if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
              if (data0.markdown === void 0) {
                const err4 = { instancePath: instancePath + "/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/$defs/slot/oneOf/1/required", keyword: "required", params: { missingProperty: "markdown" }, message: "must have required property 'markdown'" };
                if (vErrors === null) {
                  vErrors = [err4];
                } else {
                  vErrors.push(err4);
                }
                errors2++;
              }
              for (const key2 in data0) {
                if (!(key2 === "markdown")) {
                  const err5 = { instancePath: instancePath + "/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/$defs/slot/oneOf/1/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key2 }, message: "must NOT have additional properties" };
                  if (vErrors === null) {
                    vErrors = [err5];
                  } else {
                    vErrors.push(err5);
                  }
                  errors2++;
                }
              }
              if (data0.markdown !== void 0) {
                if (typeof data0.markdown !== "string") {
                  const err6 = { instancePath: instancePath + "/" + key0.replace(/~/g, "~0").replace(/\//g, "~1") + "/markdown", schemaPath: "#/$defs/slot/oneOf/1/properties/markdown/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err6];
                  } else {
                    vErrors.push(err6);
                  }
                  errors2++;
                }
              }
            } else {
              const err7 = { instancePath: instancePath + "/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/$defs/slot/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err7];
              } else {
                vErrors.push(err7);
              }
              errors2++;
            }
            var _valid0 = _errs9 === errors2;
            if (_valid0 && valid2) {
              valid2 = false;
              passing0 = [passing0, 1];
            } else {
              if (_valid0) {
                valid2 = true;
                passing0 = 1;
              }
              const _errs14 = errors2;
              if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
                if (data0.name === void 0) {
                  const err8 = { instancePath: instancePath + "/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/$defs/slot/oneOf/2/required", keyword: "required", params: { missingProperty: "name" }, message: "must have required property 'name'" };
                  if (vErrors === null) {
                    vErrors = [err8];
                  } else {
                    vErrors.push(err8);
                  }
                  errors2++;
                }
                for (const key3 in data0) {
                  if (!(key3 === "name")) {
                    const err9 = { instancePath: instancePath + "/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/$defs/slot/oneOf/2/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key3 }, message: "must NOT have additional properties" };
                    if (vErrors === null) {
                      vErrors = [err9];
                    } else {
                      vErrors.push(err9);
                    }
                    errors2++;
                  }
                }
                if (data0.name !== void 0) {
                  if (typeof data0.name !== "string") {
                    const err10 = { instancePath: instancePath + "/" + key0.replace(/~/g, "~0").replace(/\//g, "~1") + "/name", schemaPath: "#/$defs/slot/oneOf/2/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                      vErrors = [err10];
                    } else {
                      vErrors.push(err10);
                    }
                    errors2++;
                  }
                }
              } else {
                const err11 = { instancePath: instancePath + "/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/$defs/slot/oneOf/2/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                if (vErrors === null) {
                  vErrors = [err11];
                } else {
                  vErrors.push(err11);
                }
                errors2++;
              }
              var _valid0 = _errs14 === errors2;
              if (_valid0 && valid2) {
                valid2 = false;
                passing0 = [passing0, 2];
              } else {
                if (_valid0) {
                  valid2 = true;
                  passing0 = 2;
                }
              }
            }
            if (!valid2) {
              const err12 = { instancePath: instancePath + "/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/$defs/slot/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
              if (vErrors === null) {
                vErrors = [err12];
              } else {
                vErrors.push(err12);
              }
              errors2++;
            } else {
              errors2 = _errs3;
              if (vErrors !== null) {
                if (_errs3) {
                  vErrors.length = _errs3;
                } else {
                  vErrors = null;
                }
              }
            }
            props0[key0] = true;
          }
        }
      } else {
        const err13 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err13];
        } else {
          vErrors.push(err13);
        }
        errors2++;
      }
      validate66.errors = vErrors;
      evaluated0.props = props0;
      return errors2 === 0;
    }
    validate66.evaluated = { "dynamicProps": true, "dynamicItems": false };
    const schema77 = { "type": "object", "required": ["comp", "listEditMode", "listActions"], "properties": { "comp": { "const": "list" }, "title": { "type": "string" }, "listEditMode": { "type": "string", "enum": ["inline", "inline-single", "menu", "dialog"] }, "listActions": { "type": "array", "items": { "type": "string", "enum": ["add", "edit", "delete", "sort", "duplicate"] } }, "itemTitle": { "$ref": "#/$defs/expression" }, "itemSubtitle": { "$ref": "#/$defs/expression" }, "messages": { "type": "object", "additionalProperties": false, "properties": { "addItem": { "type": "string" }, "delete": { "type": "string" }, "edit": { "type": "string" }, "duplicate": { "type": "string" }, "sort": { "type": "string" } } } } };
    function validate68(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate68.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.comp === void 0) {
          const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors2++;
        }
        if (data.listEditMode === void 0) {
          const err1 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "listEditMode" }, message: "must have required property 'listEditMode'" };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors2++;
        }
        if (data.listActions === void 0) {
          const err2 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "listActions" }, message: "must have required property 'listActions'" };
          if (vErrors === null) {
            vErrors = [err2];
          } else {
            vErrors.push(err2);
          }
          errors2++;
        }
        if (data.comp !== void 0) {
          if ("list" !== data.comp) {
            const err3 = { instancePath: instancePath + "/comp", schemaPath: "#/properties/comp/const", keyword: "const", params: { allowedValue: "list" }, message: "must be equal to constant" };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors2++;
          }
        }
        if (data.title !== void 0) {
          if (typeof data.title !== "string") {
            const err4 = { instancePath: instancePath + "/title", schemaPath: "#/properties/title/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors2++;
          }
        }
        if (data.listEditMode !== void 0) {
          let data2 = data.listEditMode;
          if (typeof data2 !== "string") {
            const err5 = { instancePath: instancePath + "/listEditMode", schemaPath: "#/properties/listEditMode/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err5];
            } else {
              vErrors.push(err5);
            }
            errors2++;
          }
          if (!(data2 === "inline" || data2 === "inline-single" || data2 === "menu" || data2 === "dialog")) {
            const err6 = { instancePath: instancePath + "/listEditMode", schemaPath: "#/properties/listEditMode/enum", keyword: "enum", params: { allowedValues: schema77.properties.listEditMode.enum }, message: "must be equal to one of the allowed values" };
            if (vErrors === null) {
              vErrors = [err6];
            } else {
              vErrors.push(err6);
            }
            errors2++;
          }
        }
        if (data.listActions !== void 0) {
          let data3 = data.listActions;
          if (Array.isArray(data3)) {
            const len0 = data3.length;
            for (let i0 = 0; i0 < len0; i0++) {
              let data4 = data3[i0];
              if (typeof data4 !== "string") {
                const err7 = { instancePath: instancePath + "/listActions/" + i0, schemaPath: "#/properties/listActions/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err7];
                } else {
                  vErrors.push(err7);
                }
                errors2++;
              }
              if (!(data4 === "add" || data4 === "edit" || data4 === "delete" || data4 === "sort" || data4 === "duplicate")) {
                const err8 = { instancePath: instancePath + "/listActions/" + i0, schemaPath: "#/properties/listActions/items/enum", keyword: "enum", params: { allowedValues: schema77.properties.listActions.items.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err8];
                } else {
                  vErrors.push(err8);
                }
                errors2++;
              }
            }
          } else {
            const err9 = { instancePath: instancePath + "/listActions", schemaPath: "#/properties/listActions/type", keyword: "type", params: { type: "array" }, message: "must be array" };
            if (vErrors === null) {
              vErrors = [err9];
            } else {
              vErrors.push(err9);
            }
            errors2++;
          }
        }
        if (data.itemTitle !== void 0) {
          let data5 = data.itemTitle;
          if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
            if (data5.type === void 0) {
              const err10 = { instancePath: instancePath + "/itemTitle", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'" };
              if (vErrors === null) {
                vErrors = [err10];
              } else {
                vErrors.push(err10);
              }
              errors2++;
            }
            if (data5.expr === void 0) {
              const err11 = { instancePath: instancePath + "/itemTitle", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "expr" }, message: "must have required property 'expr'" };
              if (vErrors === null) {
                vErrors = [err11];
              } else {
                vErrors.push(err11);
              }
              errors2++;
            }
            if (data5.pure === void 0) {
              const err12 = { instancePath: instancePath + "/itemTitle", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "pure" }, message: "must have required property 'pure'" };
              if (vErrors === null) {
                vErrors = [err12];
              } else {
                vErrors.push(err12);
              }
              errors2++;
            }
            if (data5.type !== void 0) {
              let data6 = data5.type;
              if (typeof data6 !== "string") {
                const err13 = { instancePath: instancePath + "/itemTitle/type", schemaPath: "#/$defs/expression/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err13];
                } else {
                  vErrors.push(err13);
                }
                errors2++;
              }
              if (!(data6 === "js-fn" || data6 === "js-eval" || data6 === "js-tpl")) {
                const err14 = { instancePath: instancePath + "/itemTitle/type", schemaPath: "#/$defs/expression/properties/type/enum", keyword: "enum", params: { allowedValues: schema56.properties.type.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err14];
                } else {
                  vErrors.push(err14);
                }
                errors2++;
              }
            }
            if (data5.expr !== void 0) {
              if (typeof data5.expr !== "string") {
                const err15 = { instancePath: instancePath + "/itemTitle/expr", schemaPath: "#/$defs/expression/properties/expr/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err15];
                } else {
                  vErrors.push(err15);
                }
                errors2++;
              }
            }
            if (data5.pure !== void 0) {
              if (typeof data5.pure !== "boolean") {
                const err16 = { instancePath: instancePath + "/itemTitle/pure", schemaPath: "#/$defs/expression/properties/pure/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                if (vErrors === null) {
                  vErrors = [err16];
                } else {
                  vErrors.push(err16);
                }
                errors2++;
              }
            }
            if (data5.ref !== void 0) {
              let data9 = data5.ref;
              if (!(typeof data9 == "number" && (!(data9 % 1) && !isNaN(data9)) && isFinite(data9))) {
                const err17 = { instancePath: instancePath + "/itemTitle/ref", schemaPath: "#/$defs/expression/properties/ref/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
                if (vErrors === null) {
                  vErrors = [err17];
                } else {
                  vErrors.push(err17);
                }
                errors2++;
              }
            }
          } else {
            const err18 = { instancePath: instancePath + "/itemTitle", schemaPath: "#/$defs/expression/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err18];
            } else {
              vErrors.push(err18);
            }
            errors2++;
          }
        }
        if (data.itemSubtitle !== void 0) {
          let data10 = data.itemSubtitle;
          if (data10 && typeof data10 == "object" && !Array.isArray(data10)) {
            if (data10.type === void 0) {
              const err19 = { instancePath: instancePath + "/itemSubtitle", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'" };
              if (vErrors === null) {
                vErrors = [err19];
              } else {
                vErrors.push(err19);
              }
              errors2++;
            }
            if (data10.expr === void 0) {
              const err20 = { instancePath: instancePath + "/itemSubtitle", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "expr" }, message: "must have required property 'expr'" };
              if (vErrors === null) {
                vErrors = [err20];
              } else {
                vErrors.push(err20);
              }
              errors2++;
            }
            if (data10.pure === void 0) {
              const err21 = { instancePath: instancePath + "/itemSubtitle", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "pure" }, message: "must have required property 'pure'" };
              if (vErrors === null) {
                vErrors = [err21];
              } else {
                vErrors.push(err21);
              }
              errors2++;
            }
            if (data10.type !== void 0) {
              let data11 = data10.type;
              if (typeof data11 !== "string") {
                const err22 = { instancePath: instancePath + "/itemSubtitle/type", schemaPath: "#/$defs/expression/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err22];
                } else {
                  vErrors.push(err22);
                }
                errors2++;
              }
              if (!(data11 === "js-fn" || data11 === "js-eval" || data11 === "js-tpl")) {
                const err23 = { instancePath: instancePath + "/itemSubtitle/type", schemaPath: "#/$defs/expression/properties/type/enum", keyword: "enum", params: { allowedValues: schema56.properties.type.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err23];
                } else {
                  vErrors.push(err23);
                }
                errors2++;
              }
            }
            if (data10.expr !== void 0) {
              if (typeof data10.expr !== "string") {
                const err24 = { instancePath: instancePath + "/itemSubtitle/expr", schemaPath: "#/$defs/expression/properties/expr/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err24];
                } else {
                  vErrors.push(err24);
                }
                errors2++;
              }
            }
            if (data10.pure !== void 0) {
              if (typeof data10.pure !== "boolean") {
                const err25 = { instancePath: instancePath + "/itemSubtitle/pure", schemaPath: "#/$defs/expression/properties/pure/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                if (vErrors === null) {
                  vErrors = [err25];
                } else {
                  vErrors.push(err25);
                }
                errors2++;
              }
            }
            if (data10.ref !== void 0) {
              let data14 = data10.ref;
              if (!(typeof data14 == "number" && (!(data14 % 1) && !isNaN(data14)) && isFinite(data14))) {
                const err26 = { instancePath: instancePath + "/itemSubtitle/ref", schemaPath: "#/$defs/expression/properties/ref/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
                if (vErrors === null) {
                  vErrors = [err26];
                } else {
                  vErrors.push(err26);
                }
                errors2++;
              }
            }
          } else {
            const err27 = { instancePath: instancePath + "/itemSubtitle", schemaPath: "#/$defs/expression/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err27];
            } else {
              vErrors.push(err27);
            }
            errors2++;
          }
        }
        if (data.messages !== void 0) {
          let data15 = data.messages;
          if (data15 && typeof data15 == "object" && !Array.isArray(data15)) {
            for (const key0 in data15) {
              if (!(key0 === "addItem" || key0 === "delete" || key0 === "edit" || key0 === "duplicate" || key0 === "sort")) {
                const err28 = { instancePath: instancePath + "/messages", schemaPath: "#/properties/messages/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" };
                if (vErrors === null) {
                  vErrors = [err28];
                } else {
                  vErrors.push(err28);
                }
                errors2++;
              }
            }
            if (data15.addItem !== void 0) {
              if (typeof data15.addItem !== "string") {
                const err29 = { instancePath: instancePath + "/messages/addItem", schemaPath: "#/properties/messages/properties/addItem/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err29];
                } else {
                  vErrors.push(err29);
                }
                errors2++;
              }
            }
            if (data15.delete !== void 0) {
              if (typeof data15.delete !== "string") {
                const err30 = { instancePath: instancePath + "/messages/delete", schemaPath: "#/properties/messages/properties/delete/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err30];
                } else {
                  vErrors.push(err30);
                }
                errors2++;
              }
            }
            if (data15.edit !== void 0) {
              if (typeof data15.edit !== "string") {
                const err31 = { instancePath: instancePath + "/messages/edit", schemaPath: "#/properties/messages/properties/edit/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err31];
                } else {
                  vErrors.push(err31);
                }
                errors2++;
              }
            }
            if (data15.duplicate !== void 0) {
              if (typeof data15.duplicate !== "string") {
                const err32 = { instancePath: instancePath + "/messages/duplicate", schemaPath: "#/properties/messages/properties/duplicate/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err32];
                } else {
                  vErrors.push(err32);
                }
                errors2++;
              }
            }
            if (data15.sort !== void 0) {
              if (typeof data15.sort !== "string") {
                const err33 = { instancePath: instancePath + "/messages/sort", schemaPath: "#/properties/messages/properties/sort/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err33];
                } else {
                  vErrors.push(err33);
                }
                errors2++;
              }
            }
          } else {
            const err34 = { instancePath: instancePath + "/messages", schemaPath: "#/properties/messages/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err34];
            } else {
              vErrors.push(err34);
            }
            errors2++;
          }
        }
      } else {
        const err35 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err35];
        } else {
          vErrors.push(err35);
        }
        errors2++;
      }
      validate68.errors = vErrors;
      return errors2 === 0;
    }
    validate68.evaluated = { "props": { "comp": true, "title": true, "listEditMode": true, "listActions": true, "itemTitle": true, "itemSubtitle": true, "messages": true }, "dynamicProps": false, "dynamicItems": false };
    function validate70(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate70.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (Array.isArray(data)) {
        const len0 = data.length;
        for (let i0 = 0; i0 < len0; i0++) {
          let data0 = data[i0];
          if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
            if (data0.title === void 0) {
              const err0 = { instancePath: instancePath + "/" + i0, schemaPath: "#/$defs/select-item/required", keyword: "required", params: { missingProperty: "title" }, message: "must have required property 'title'" };
              if (vErrors === null) {
                vErrors = [err0];
              } else {
                vErrors.push(err0);
              }
              errors2++;
            }
            if (data0.key === void 0) {
              const err1 = { instancePath: instancePath + "/" + i0, schemaPath: "#/$defs/select-item/required", keyword: "required", params: { missingProperty: "key" }, message: "must have required property 'key'" };
              if (vErrors === null) {
                vErrors = [err1];
              } else {
                vErrors.push(err1);
              }
              errors2++;
            }
            if (data0.value === void 0) {
              const err2 = { instancePath: instancePath + "/" + i0, schemaPath: "#/$defs/select-item/required", keyword: "required", params: { missingProperty: "value" }, message: "must have required property 'value'" };
              if (vErrors === null) {
                vErrors = [err2];
              } else {
                vErrors.push(err2);
              }
              errors2++;
            }
            if (data0.title !== void 0) {
              if (typeof data0.title !== "string") {
                const err3 = { instancePath: instancePath + "/" + i0 + "/title", schemaPath: "#/$defs/select-item/properties/title/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err3];
                } else {
                  vErrors.push(err3);
                }
                errors2++;
              }
            }
            if (data0.key !== void 0) {
              if (typeof data0.key !== "string") {
                const err4 = { instancePath: instancePath + "/" + i0 + "/key", schemaPath: "#/$defs/select-item/properties/key/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err4];
                } else {
                  vErrors.push(err4);
                }
                errors2++;
              }
            }
            if (data0.icon !== void 0) {
              if (typeof data0.icon !== "string") {
                const err5 = { instancePath: instancePath + "/" + i0 + "/icon", schemaPath: "#/$defs/select-item/properties/icon/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err5];
                } else {
                  vErrors.push(err5);
                }
                errors2++;
              }
            }
          } else {
            const err6 = { instancePath: instancePath + "/" + i0, schemaPath: "#/$defs/select-item/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err6];
            } else {
              vErrors.push(err6);
            }
            errors2++;
          }
        }
      } else {
        const err7 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "array" }, message: "must be array" };
        if (vErrors === null) {
          vErrors = [err7];
        } else {
          vErrors.push(err7);
        }
        errors2++;
      }
      validate70.errors = vErrors;
      return errors2 === 0;
    }
    validate70.evaluated = { "items": true, "dynamicProps": false, "dynamicItems": false };
    function validate73(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate73.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.url === void 0) {
          const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "url" }, message: "must have required property 'url'" };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors2++;
        }
        if (data.url !== void 0) {
          let data0 = data.url;
          if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
            if (data0.type === void 0) {
              const err1 = { instancePath: instancePath + "/url", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'" };
              if (vErrors === null) {
                vErrors = [err1];
              } else {
                vErrors.push(err1);
              }
              errors2++;
            }
            if (data0.expr === void 0) {
              const err2 = { instancePath: instancePath + "/url", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "expr" }, message: "must have required property 'expr'" };
              if (vErrors === null) {
                vErrors = [err2];
              } else {
                vErrors.push(err2);
              }
              errors2++;
            }
            if (data0.pure === void 0) {
              const err3 = { instancePath: instancePath + "/url", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "pure" }, message: "must have required property 'pure'" };
              if (vErrors === null) {
                vErrors = [err3];
              } else {
                vErrors.push(err3);
              }
              errors2++;
            }
            if (data0.type !== void 0) {
              let data1 = data0.type;
              if (typeof data1 !== "string") {
                const err4 = { instancePath: instancePath + "/url/type", schemaPath: "#/$defs/expression/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err4];
                } else {
                  vErrors.push(err4);
                }
                errors2++;
              }
              if (!(data1 === "js-fn" || data1 === "js-eval" || data1 === "js-tpl")) {
                const err5 = { instancePath: instancePath + "/url/type", schemaPath: "#/$defs/expression/properties/type/enum", keyword: "enum", params: { allowedValues: schema56.properties.type.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err5];
                } else {
                  vErrors.push(err5);
                }
                errors2++;
              }
            }
            if (data0.expr !== void 0) {
              if (typeof data0.expr !== "string") {
                const err6 = { instancePath: instancePath + "/url/expr", schemaPath: "#/$defs/expression/properties/expr/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err6];
                } else {
                  vErrors.push(err6);
                }
                errors2++;
              }
            }
            if (data0.pure !== void 0) {
              if (typeof data0.pure !== "boolean") {
                const err7 = { instancePath: instancePath + "/url/pure", schemaPath: "#/$defs/expression/properties/pure/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                if (vErrors === null) {
                  vErrors = [err7];
                } else {
                  vErrors.push(err7);
                }
                errors2++;
              }
            }
            if (data0.ref !== void 0) {
              let data4 = data0.ref;
              if (!(typeof data4 == "number" && (!(data4 % 1) && !isNaN(data4)) && isFinite(data4))) {
                const err8 = { instancePath: instancePath + "/url/ref", schemaPath: "#/$defs/expression/properties/ref/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
                if (vErrors === null) {
                  vErrors = [err8];
                } else {
                  vErrors.push(err8);
                }
                errors2++;
              }
            }
          } else {
            const err9 = { instancePath: instancePath + "/url", schemaPath: "#/$defs/expression/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err9];
            } else {
              vErrors.push(err9);
            }
            errors2++;
          }
        }
        if (data.qSearchParam !== void 0) {
          if (typeof data.qSearchParam !== "string") {
            const err10 = { instancePath: instancePath + "/qSearchParam", schemaPath: "#/properties/qSearchParam/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err10];
            } else {
              vErrors.push(err10);
            }
            errors2++;
          }
        }
        if (data.searchParams !== void 0) {
          let data6 = data.searchParams;
          if (data6 && typeof data6 == "object" && !Array.isArray(data6)) {
            var props0 = {};
            for (const key0 in data6) {
              if (pattern2.test(key0)) {
                let data7 = data6[key0];
                if (data7 && typeof data7 == "object" && !Array.isArray(data7)) {
                  if (data7.type === void 0) {
                    const err11 = { instancePath: instancePath + "/searchParams/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'" };
                    if (vErrors === null) {
                      vErrors = [err11];
                    } else {
                      vErrors.push(err11);
                    }
                    errors2++;
                  }
                  if (data7.expr === void 0) {
                    const err12 = { instancePath: instancePath + "/searchParams/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "expr" }, message: "must have required property 'expr'" };
                    if (vErrors === null) {
                      vErrors = [err12];
                    } else {
                      vErrors.push(err12);
                    }
                    errors2++;
                  }
                  if (data7.pure === void 0) {
                    const err13 = { instancePath: instancePath + "/searchParams/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "pure" }, message: "must have required property 'pure'" };
                    if (vErrors === null) {
                      vErrors = [err13];
                    } else {
                      vErrors.push(err13);
                    }
                    errors2++;
                  }
                  if (data7.type !== void 0) {
                    let data8 = data7.type;
                    if (typeof data8 !== "string") {
                      const err14 = { instancePath: instancePath + "/searchParams/" + key0.replace(/~/g, "~0").replace(/\//g, "~1") + "/type", schemaPath: "#/$defs/expression/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                      if (vErrors === null) {
                        vErrors = [err14];
                      } else {
                        vErrors.push(err14);
                      }
                      errors2++;
                    }
                    if (!(data8 === "js-fn" || data8 === "js-eval" || data8 === "js-tpl")) {
                      const err15 = { instancePath: instancePath + "/searchParams/" + key0.replace(/~/g, "~0").replace(/\//g, "~1") + "/type", schemaPath: "#/$defs/expression/properties/type/enum", keyword: "enum", params: { allowedValues: schema56.properties.type.enum }, message: "must be equal to one of the allowed values" };
                      if (vErrors === null) {
                        vErrors = [err15];
                      } else {
                        vErrors.push(err15);
                      }
                      errors2++;
                    }
                  }
                  if (data7.expr !== void 0) {
                    if (typeof data7.expr !== "string") {
                      const err16 = { instancePath: instancePath + "/searchParams/" + key0.replace(/~/g, "~0").replace(/\//g, "~1") + "/expr", schemaPath: "#/$defs/expression/properties/expr/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                      if (vErrors === null) {
                        vErrors = [err16];
                      } else {
                        vErrors.push(err16);
                      }
                      errors2++;
                    }
                  }
                  if (data7.pure !== void 0) {
                    if (typeof data7.pure !== "boolean") {
                      const err17 = { instancePath: instancePath + "/searchParams/" + key0.replace(/~/g, "~0").replace(/\//g, "~1") + "/pure", schemaPath: "#/$defs/expression/properties/pure/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                      if (vErrors === null) {
                        vErrors = [err17];
                      } else {
                        vErrors.push(err17);
                      }
                      errors2++;
                    }
                  }
                  if (data7.ref !== void 0) {
                    let data11 = data7.ref;
                    if (!(typeof data11 == "number" && (!(data11 % 1) && !isNaN(data11)) && isFinite(data11))) {
                      const err18 = { instancePath: instancePath + "/searchParams/" + key0.replace(/~/g, "~0").replace(/\//g, "~1") + "/ref", schemaPath: "#/$defs/expression/properties/ref/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
                      if (vErrors === null) {
                        vErrors = [err18];
                      } else {
                        vErrors.push(err18);
                      }
                      errors2++;
                    }
                  }
                } else {
                  const err19 = { instancePath: instancePath + "/searchParams/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/$defs/expression/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                  if (vErrors === null) {
                    vErrors = [err19];
                  } else {
                    vErrors.push(err19);
                  }
                  errors2++;
                }
                props0[key0] = true;
              }
            }
          } else {
            const err20 = { instancePath: instancePath + "/searchParams", schemaPath: "#/properties/searchParams/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err20];
            } else {
              vErrors.push(err20);
            }
            errors2++;
          }
        }
      } else {
        const err21 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err21];
        } else {
          vErrors.push(err21);
        }
        errors2++;
      }
      validate73.errors = vErrors;
      return errors2 === 0;
    }
    validate73.evaluated = { "props": { "url": true, "qSearchParam": true, "searchParams": true }, "dynamicProps": false, "dynamicItems": false };
    function validate72(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate72.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (!(data && typeof data == "object" && !Array.isArray(data))) {
        const err0 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors2++;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.returnObjects !== void 0) {
          if (typeof data.returnObjects !== "boolean") {
            const err1 = { instancePath: instancePath + "/returnObjects", schemaPath: "#/allOf/0/properties/returnObjects/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }
            errors2++;
          }
        }
        if (data.itemsResults !== void 0) {
          let data1 = data.itemsResults;
          if (data1 && typeof data1 == "object" && !Array.isArray(data1)) {
            if (data1.type === void 0) {
              const err2 = { instancePath: instancePath + "/itemsResults", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'" };
              if (vErrors === null) {
                vErrors = [err2];
              } else {
                vErrors.push(err2);
              }
              errors2++;
            }
            if (data1.expr === void 0) {
              const err3 = { instancePath: instancePath + "/itemsResults", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "expr" }, message: "must have required property 'expr'" };
              if (vErrors === null) {
                vErrors = [err3];
              } else {
                vErrors.push(err3);
              }
              errors2++;
            }
            if (data1.pure === void 0) {
              const err4 = { instancePath: instancePath + "/itemsResults", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "pure" }, message: "must have required property 'pure'" };
              if (vErrors === null) {
                vErrors = [err4];
              } else {
                vErrors.push(err4);
              }
              errors2++;
            }
            if (data1.type !== void 0) {
              let data2 = data1.type;
              if (typeof data2 !== "string") {
                const err5 = { instancePath: instancePath + "/itemsResults/type", schemaPath: "#/$defs/expression/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err5];
                } else {
                  vErrors.push(err5);
                }
                errors2++;
              }
              if (!(data2 === "js-fn" || data2 === "js-eval" || data2 === "js-tpl")) {
                const err6 = { instancePath: instancePath + "/itemsResults/type", schemaPath: "#/$defs/expression/properties/type/enum", keyword: "enum", params: { allowedValues: schema56.properties.type.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err6];
                } else {
                  vErrors.push(err6);
                }
                errors2++;
              }
            }
            if (data1.expr !== void 0) {
              if (typeof data1.expr !== "string") {
                const err7 = { instancePath: instancePath + "/itemsResults/expr", schemaPath: "#/$defs/expression/properties/expr/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err7];
                } else {
                  vErrors.push(err7);
                }
                errors2++;
              }
            }
            if (data1.pure !== void 0) {
              if (typeof data1.pure !== "boolean") {
                const err8 = { instancePath: instancePath + "/itemsResults/pure", schemaPath: "#/$defs/expression/properties/pure/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                if (vErrors === null) {
                  vErrors = [err8];
                } else {
                  vErrors.push(err8);
                }
                errors2++;
              }
            }
            if (data1.ref !== void 0) {
              let data5 = data1.ref;
              if (!(typeof data5 == "number" && (!(data5 % 1) && !isNaN(data5)) && isFinite(data5))) {
                const err9 = { instancePath: instancePath + "/itemsResults/ref", schemaPath: "#/$defs/expression/properties/ref/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
                if (vErrors === null) {
                  vErrors = [err9];
                } else {
                  vErrors.push(err9);
                }
                errors2++;
              }
            }
          } else {
            const err10 = { instancePath: instancePath + "/itemsResults", schemaPath: "#/$defs/expression/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err10];
            } else {
              vErrors.push(err10);
            }
            errors2++;
          }
        }
        if (data.itemTitle !== void 0) {
          let data6 = data.itemTitle;
          if (data6 && typeof data6 == "object" && !Array.isArray(data6)) {
            if (data6.type === void 0) {
              const err11 = { instancePath: instancePath + "/itemTitle", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'" };
              if (vErrors === null) {
                vErrors = [err11];
              } else {
                vErrors.push(err11);
              }
              errors2++;
            }
            if (data6.expr === void 0) {
              const err12 = { instancePath: instancePath + "/itemTitle", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "expr" }, message: "must have required property 'expr'" };
              if (vErrors === null) {
                vErrors = [err12];
              } else {
                vErrors.push(err12);
              }
              errors2++;
            }
            if (data6.pure === void 0) {
              const err13 = { instancePath: instancePath + "/itemTitle", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "pure" }, message: "must have required property 'pure'" };
              if (vErrors === null) {
                vErrors = [err13];
              } else {
                vErrors.push(err13);
              }
              errors2++;
            }
            if (data6.type !== void 0) {
              let data7 = data6.type;
              if (typeof data7 !== "string") {
                const err14 = { instancePath: instancePath + "/itemTitle/type", schemaPath: "#/$defs/expression/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err14];
                } else {
                  vErrors.push(err14);
                }
                errors2++;
              }
              if (!(data7 === "js-fn" || data7 === "js-eval" || data7 === "js-tpl")) {
                const err15 = { instancePath: instancePath + "/itemTitle/type", schemaPath: "#/$defs/expression/properties/type/enum", keyword: "enum", params: { allowedValues: schema56.properties.type.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err15];
                } else {
                  vErrors.push(err15);
                }
                errors2++;
              }
            }
            if (data6.expr !== void 0) {
              if (typeof data6.expr !== "string") {
                const err16 = { instancePath: instancePath + "/itemTitle/expr", schemaPath: "#/$defs/expression/properties/expr/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err16];
                } else {
                  vErrors.push(err16);
                }
                errors2++;
              }
            }
            if (data6.pure !== void 0) {
              if (typeof data6.pure !== "boolean") {
                const err17 = { instancePath: instancePath + "/itemTitle/pure", schemaPath: "#/$defs/expression/properties/pure/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                if (vErrors === null) {
                  vErrors = [err17];
                } else {
                  vErrors.push(err17);
                }
                errors2++;
              }
            }
            if (data6.ref !== void 0) {
              let data10 = data6.ref;
              if (!(typeof data10 == "number" && (!(data10 % 1) && !isNaN(data10)) && isFinite(data10))) {
                const err18 = { instancePath: instancePath + "/itemTitle/ref", schemaPath: "#/$defs/expression/properties/ref/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
                if (vErrors === null) {
                  vErrors = [err18];
                } else {
                  vErrors.push(err18);
                }
                errors2++;
              }
            }
          } else {
            const err19 = { instancePath: instancePath + "/itemTitle", schemaPath: "#/$defs/expression/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err19];
            } else {
              vErrors.push(err19);
            }
            errors2++;
          }
        }
        if (data.itemKey !== void 0) {
          let data11 = data.itemKey;
          if (data11 && typeof data11 == "object" && !Array.isArray(data11)) {
            if (data11.type === void 0) {
              const err20 = { instancePath: instancePath + "/itemKey", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'" };
              if (vErrors === null) {
                vErrors = [err20];
              } else {
                vErrors.push(err20);
              }
              errors2++;
            }
            if (data11.expr === void 0) {
              const err21 = { instancePath: instancePath + "/itemKey", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "expr" }, message: "must have required property 'expr'" };
              if (vErrors === null) {
                vErrors = [err21];
              } else {
                vErrors.push(err21);
              }
              errors2++;
            }
            if (data11.pure === void 0) {
              const err22 = { instancePath: instancePath + "/itemKey", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "pure" }, message: "must have required property 'pure'" };
              if (vErrors === null) {
                vErrors = [err22];
              } else {
                vErrors.push(err22);
              }
              errors2++;
            }
            if (data11.type !== void 0) {
              let data12 = data11.type;
              if (typeof data12 !== "string") {
                const err23 = { instancePath: instancePath + "/itemKey/type", schemaPath: "#/$defs/expression/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err23];
                } else {
                  vErrors.push(err23);
                }
                errors2++;
              }
              if (!(data12 === "js-fn" || data12 === "js-eval" || data12 === "js-tpl")) {
                const err24 = { instancePath: instancePath + "/itemKey/type", schemaPath: "#/$defs/expression/properties/type/enum", keyword: "enum", params: { allowedValues: schema56.properties.type.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err24];
                } else {
                  vErrors.push(err24);
                }
                errors2++;
              }
            }
            if (data11.expr !== void 0) {
              if (typeof data11.expr !== "string") {
                const err25 = { instancePath: instancePath + "/itemKey/expr", schemaPath: "#/$defs/expression/properties/expr/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err25];
                } else {
                  vErrors.push(err25);
                }
                errors2++;
              }
            }
            if (data11.pure !== void 0) {
              if (typeof data11.pure !== "boolean") {
                const err26 = { instancePath: instancePath + "/itemKey/pure", schemaPath: "#/$defs/expression/properties/pure/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                if (vErrors === null) {
                  vErrors = [err26];
                } else {
                  vErrors.push(err26);
                }
                errors2++;
              }
            }
            if (data11.ref !== void 0) {
              let data15 = data11.ref;
              if (!(typeof data15 == "number" && (!(data15 % 1) && !isNaN(data15)) && isFinite(data15))) {
                const err27 = { instancePath: instancePath + "/itemKey/ref", schemaPath: "#/$defs/expression/properties/ref/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
                if (vErrors === null) {
                  vErrors = [err27];
                } else {
                  vErrors.push(err27);
                }
                errors2++;
              }
            }
          } else {
            const err28 = { instancePath: instancePath + "/itemKey", schemaPath: "#/$defs/expression/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err28];
            } else {
              vErrors.push(err28);
            }
            errors2++;
          }
        }
        if (data.itemValue !== void 0) {
          let data16 = data.itemValue;
          if (data16 && typeof data16 == "object" && !Array.isArray(data16)) {
            if (data16.type === void 0) {
              const err29 = { instancePath: instancePath + "/itemValue", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'" };
              if (vErrors === null) {
                vErrors = [err29];
              } else {
                vErrors.push(err29);
              }
              errors2++;
            }
            if (data16.expr === void 0) {
              const err30 = { instancePath: instancePath + "/itemValue", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "expr" }, message: "must have required property 'expr'" };
              if (vErrors === null) {
                vErrors = [err30];
              } else {
                vErrors.push(err30);
              }
              errors2++;
            }
            if (data16.pure === void 0) {
              const err31 = { instancePath: instancePath + "/itemValue", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "pure" }, message: "must have required property 'pure'" };
              if (vErrors === null) {
                vErrors = [err31];
              } else {
                vErrors.push(err31);
              }
              errors2++;
            }
            if (data16.type !== void 0) {
              let data17 = data16.type;
              if (typeof data17 !== "string") {
                const err32 = { instancePath: instancePath + "/itemValue/type", schemaPath: "#/$defs/expression/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err32];
                } else {
                  vErrors.push(err32);
                }
                errors2++;
              }
              if (!(data17 === "js-fn" || data17 === "js-eval" || data17 === "js-tpl")) {
                const err33 = { instancePath: instancePath + "/itemValue/type", schemaPath: "#/$defs/expression/properties/type/enum", keyword: "enum", params: { allowedValues: schema56.properties.type.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err33];
                } else {
                  vErrors.push(err33);
                }
                errors2++;
              }
            }
            if (data16.expr !== void 0) {
              if (typeof data16.expr !== "string") {
                const err34 = { instancePath: instancePath + "/itemValue/expr", schemaPath: "#/$defs/expression/properties/expr/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err34];
                } else {
                  vErrors.push(err34);
                }
                errors2++;
              }
            }
            if (data16.pure !== void 0) {
              if (typeof data16.pure !== "boolean") {
                const err35 = { instancePath: instancePath + "/itemValue/pure", schemaPath: "#/$defs/expression/properties/pure/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                if (vErrors === null) {
                  vErrors = [err35];
                } else {
                  vErrors.push(err35);
                }
                errors2++;
              }
            }
            if (data16.ref !== void 0) {
              let data20 = data16.ref;
              if (!(typeof data20 == "number" && (!(data20 % 1) && !isNaN(data20)) && isFinite(data20))) {
                const err36 = { instancePath: instancePath + "/itemValue/ref", schemaPath: "#/$defs/expression/properties/ref/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
                if (vErrors === null) {
                  vErrors = [err36];
                } else {
                  vErrors.push(err36);
                }
                errors2++;
              }
            }
          } else {
            const err37 = { instancePath: instancePath + "/itemValue", schemaPath: "#/$defs/expression/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err37];
            } else {
              vErrors.push(err37);
            }
            errors2++;
          }
        }
        if (data.itemIcon !== void 0) {
          let data21 = data.itemIcon;
          if (data21 && typeof data21 == "object" && !Array.isArray(data21)) {
            if (data21.type === void 0) {
              const err38 = { instancePath: instancePath + "/itemIcon", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'" };
              if (vErrors === null) {
                vErrors = [err38];
              } else {
                vErrors.push(err38);
              }
              errors2++;
            }
            if (data21.expr === void 0) {
              const err39 = { instancePath: instancePath + "/itemIcon", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "expr" }, message: "must have required property 'expr'" };
              if (vErrors === null) {
                vErrors = [err39];
              } else {
                vErrors.push(err39);
              }
              errors2++;
            }
            if (data21.pure === void 0) {
              const err40 = { instancePath: instancePath + "/itemIcon", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "pure" }, message: "must have required property 'pure'" };
              if (vErrors === null) {
                vErrors = [err40];
              } else {
                vErrors.push(err40);
              }
              errors2++;
            }
            if (data21.type !== void 0) {
              let data22 = data21.type;
              if (typeof data22 !== "string") {
                const err41 = { instancePath: instancePath + "/itemIcon/type", schemaPath: "#/$defs/expression/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err41];
                } else {
                  vErrors.push(err41);
                }
                errors2++;
              }
              if (!(data22 === "js-fn" || data22 === "js-eval" || data22 === "js-tpl")) {
                const err42 = { instancePath: instancePath + "/itemIcon/type", schemaPath: "#/$defs/expression/properties/type/enum", keyword: "enum", params: { allowedValues: schema56.properties.type.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err42];
                } else {
                  vErrors.push(err42);
                }
                errors2++;
              }
            }
            if (data21.expr !== void 0) {
              if (typeof data21.expr !== "string") {
                const err43 = { instancePath: instancePath + "/itemIcon/expr", schemaPath: "#/$defs/expression/properties/expr/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err43];
                } else {
                  vErrors.push(err43);
                }
                errors2++;
              }
            }
            if (data21.pure !== void 0) {
              if (typeof data21.pure !== "boolean") {
                const err44 = { instancePath: instancePath + "/itemIcon/pure", schemaPath: "#/$defs/expression/properties/pure/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                if (vErrors === null) {
                  vErrors = [err44];
                } else {
                  vErrors.push(err44);
                }
                errors2++;
              }
            }
            if (data21.ref !== void 0) {
              let data25 = data21.ref;
              if (!(typeof data25 == "number" && (!(data25 % 1) && !isNaN(data25)) && isFinite(data25))) {
                const err45 = { instancePath: instancePath + "/itemIcon/ref", schemaPath: "#/$defs/expression/properties/ref/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
                if (vErrors === null) {
                  vErrors = [err45];
                } else {
                  vErrors.push(err45);
                }
                errors2++;
              }
            }
          } else {
            const err46 = { instancePath: instancePath + "/itemIcon", schemaPath: "#/$defs/expression/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err46];
            } else {
              vErrors.push(err46);
            }
            errors2++;
          }
        }
      }
      const _errs60 = errors2;
      let valid12 = false;
      let passing0 = null;
      const _errs61 = errors2;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.type === void 0) {
          const err47 = { instancePath, schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'" };
          if (vErrors === null) {
            vErrors = [err47];
          } else {
            vErrors.push(err47);
          }
          errors2++;
        }
        if (data.expr === void 0) {
          const err48 = { instancePath, schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "expr" }, message: "must have required property 'expr'" };
          if (vErrors === null) {
            vErrors = [err48];
          } else {
            vErrors.push(err48);
          }
          errors2++;
        }
        if (data.pure === void 0) {
          const err49 = { instancePath, schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "pure" }, message: "must have required property 'pure'" };
          if (vErrors === null) {
            vErrors = [err49];
          } else {
            vErrors.push(err49);
          }
          errors2++;
        }
        if (data.type !== void 0) {
          let data26 = data.type;
          if (typeof data26 !== "string") {
            const err50 = { instancePath: instancePath + "/type", schemaPath: "#/$defs/expression/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err50];
            } else {
              vErrors.push(err50);
            }
            errors2++;
          }
          if (!(data26 === "js-fn" || data26 === "js-eval" || data26 === "js-tpl")) {
            const err51 = { instancePath: instancePath + "/type", schemaPath: "#/$defs/expression/properties/type/enum", keyword: "enum", params: { allowedValues: schema56.properties.type.enum }, message: "must be equal to one of the allowed values" };
            if (vErrors === null) {
              vErrors = [err51];
            } else {
              vErrors.push(err51);
            }
            errors2++;
          }
        }
        if (data.expr !== void 0) {
          if (typeof data.expr !== "string") {
            const err52 = { instancePath: instancePath + "/expr", schemaPath: "#/$defs/expression/properties/expr/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err52];
            } else {
              vErrors.push(err52);
            }
            errors2++;
          }
        }
        if (data.pure !== void 0) {
          if (typeof data.pure !== "boolean") {
            const err53 = { instancePath: instancePath + "/pure", schemaPath: "#/$defs/expression/properties/pure/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
            if (vErrors === null) {
              vErrors = [err53];
            } else {
              vErrors.push(err53);
            }
            errors2++;
          }
        }
        if (data.ref !== void 0) {
          let data29 = data.ref;
          if (!(typeof data29 == "number" && (!(data29 % 1) && !isNaN(data29)) && isFinite(data29))) {
            const err54 = { instancePath: instancePath + "/ref", schemaPath: "#/$defs/expression/properties/ref/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
            if (vErrors === null) {
              vErrors = [err54];
            } else {
              vErrors.push(err54);
            }
            errors2++;
          }
        }
      } else {
        const err55 = { instancePath, schemaPath: "#/$defs/expression/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err55];
        } else {
          vErrors.push(err55);
        }
        errors2++;
      }
      var _valid0 = _errs61 === errors2;
      if (_valid0) {
        valid12 = true;
        passing0 = 0;
        var props0 = {};
        props0.type = true;
        props0.expr = true;
        props0.pure = true;
        props0.ref = true;
      }
      const _errs72 = errors2;
      if (!validate73(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
        vErrors = vErrors === null ? validate73.errors : vErrors.concat(validate73.errors);
        errors2 = vErrors.length;
      }
      var _valid0 = _errs72 === errors2;
      if (_valid0 && valid12) {
        valid12 = false;
        passing0 = [passing0, 1];
      } else {
        if (_valid0) {
          valid12 = true;
          passing0 = 1;
          if (props0 !== true) {
            props0 = props0 || {};
            props0.url = true;
            props0.qSearchParam = true;
            props0.searchParams = true;
          }
        }
      }
      if (!valid12) {
        const err56 = { instancePath, schemaPath: "#/allOf/1/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
        if (vErrors === null) {
          vErrors = [err56];
        } else {
          vErrors.push(err56);
        }
        errors2++;
      } else {
        errors2 = _errs60;
        if (vErrors !== null) {
          if (_errs60) {
            vErrors.length = _errs60;
          } else {
            vErrors = null;
          }
        }
      }
      if (props0 !== true) {
        props0 = props0 || {};
        props0.returnObjects = true;
        props0.itemsResults = true;
        props0.itemTitle = true;
        props0.itemKey = true;
        props0.itemValue = true;
        props0.itemIcon = true;
      }
      validate72.errors = vErrors;
      evaluated0.props = props0;
      return errors2 === 0;
    }
    validate72.evaluated = { "dynamicProps": true, "dynamicItems": false };
    function validate69(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate69.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.comp === void 0) {
          const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors2++;
        }
        if (data.label === void 0) {
          const err1 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "label" }, message: "must have required property 'label'" };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors2++;
        }
        if (data.comp !== void 0) {
          if ("combobox" !== data.comp) {
            const err2 = { instancePath: instancePath + "/comp", schemaPath: "#/properties/comp/const", keyword: "const", params: { allowedValue: "combobox" }, message: "must be equal to constant" };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors2++;
          }
        }
        if (data.label !== void 0) {
          if (typeof data.label !== "string") {
            const err3 = { instancePath: instancePath + "/label", schemaPath: "#/properties/label/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors2++;
          }
        }
        if (data.autofocus !== void 0) {
          if (typeof data.autofocus !== "boolean") {
            const err4 = { instancePath: instancePath + "/autofocus", schemaPath: "#/properties/autofocus/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors2++;
          }
        }
        if (data.items !== void 0) {
          if (!validate70(data.items, { instancePath: instancePath + "/items", parentData: data, parentDataProperty: "items", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate70.errors : vErrors.concat(validate70.errors);
            errors2 = vErrors.length;
          }
        }
        if (data.getItems !== void 0) {
          if (!validate72(data.getItems, { instancePath: instancePath + "/getItems", parentData: data, parentDataProperty: "getItems", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate72.errors : vErrors.concat(validate72.errors);
            errors2 = vErrors.length;
          }
        }
        if (data.multiple !== void 0) {
          if (typeof data.multiple !== "boolean") {
            const err5 = { instancePath: instancePath + "/multiple", schemaPath: "#/properties/multiple/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
            if (vErrors === null) {
              vErrors = [err5];
            } else {
              vErrors.push(err5);
            }
            errors2++;
          }
        }
      } else {
        const err6 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err6];
        } else {
          vErrors.push(err6);
        }
        errors2++;
      }
      validate69.errors = vErrors;
      return errors2 === 0;
    }
    validate69.evaluated = { "props": { "comp": true, "label": true, "autofocus": true, "items": true, "getItems": true, "multiple": true }, "dynamicProps": false, "dynamicItems": false };
    function validate76(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate76.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.comp === void 0) {
          const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors2++;
        }
        if (data.label === void 0) {
          const err1 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "label" }, message: "must have required property 'label'" };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors2++;
        }
        if (data.comp !== void 0) {
          if ("number-combobox" !== data.comp) {
            const err2 = { instancePath: instancePath + "/comp", schemaPath: "#/properties/comp/const", keyword: "const", params: { allowedValue: "number-combobox" }, message: "must be equal to constant" };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors2++;
          }
        }
        if (data.label !== void 0) {
          if (typeof data.label !== "string") {
            const err3 = { instancePath: instancePath + "/label", schemaPath: "#/properties/label/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors2++;
          }
        }
        if (data.autofocus !== void 0) {
          if (typeof data.autofocus !== "boolean") {
            const err4 = { instancePath: instancePath + "/autofocus", schemaPath: "#/properties/autofocus/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors2++;
          }
        }
        if (data.items !== void 0) {
          if (!validate70(data.items, { instancePath: instancePath + "/items", parentData: data, parentDataProperty: "items", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate70.errors : vErrors.concat(validate70.errors);
            errors2 = vErrors.length;
          }
        }
        if (data.getItems !== void 0) {
          if (!validate72(data.getItems, { instancePath: instancePath + "/getItems", parentData: data, parentDataProperty: "getItems", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate72.errors : vErrors.concat(validate72.errors);
            errors2 = vErrors.length;
          }
        }
        if (data.multiple !== void 0) {
          if (typeof data.multiple !== "boolean") {
            const err5 = { instancePath: instancePath + "/multiple", schemaPath: "#/properties/multiple/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
            if (vErrors === null) {
              vErrors = [err5];
            } else {
              vErrors.push(err5);
            }
            errors2++;
          }
        }
        if (data.step !== void 0) {
          let data6 = data.step;
          if (!(typeof data6 == "number" && isFinite(data6))) {
            const err6 = { instancePath: instancePath + "/step", schemaPath: "#/properties/step/type", keyword: "type", params: { type: "number" }, message: "must be number" };
            if (vErrors === null) {
              vErrors = [err6];
            } else {
              vErrors.push(err6);
            }
            errors2++;
          }
        }
        if (data.min !== void 0) {
          let data7 = data.min;
          if (!(typeof data7 == "number" && isFinite(data7))) {
            const err7 = { instancePath: instancePath + "/min", schemaPath: "#/properties/min/type", keyword: "type", params: { type: "number" }, message: "must be number" };
            if (vErrors === null) {
              vErrors = [err7];
            } else {
              vErrors.push(err7);
            }
            errors2++;
          }
        }
        if (data.max !== void 0) {
          let data8 = data.max;
          if (!(typeof data8 == "number" && isFinite(data8))) {
            const err8 = { instancePath: instancePath + "/max", schemaPath: "#/properties/max/type", keyword: "type", params: { type: "number" }, message: "must be number" };
            if (vErrors === null) {
              vErrors = [err8];
            } else {
              vErrors.push(err8);
            }
            errors2++;
          }
        }
      } else {
        const err9 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err9];
        } else {
          vErrors.push(err9);
        }
        errors2++;
      }
      validate76.errors = vErrors;
      return errors2 === 0;
    }
    validate76.evaluated = { "props": { "comp": true, "label": true, "autofocus": true, "items": true, "getItems": true, "multiple": true, "step": true, "min": true, "max": true }, "dynamicProps": false, "dynamicItems": false };
    function validate79(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate79.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.comp === void 0) {
          const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors2++;
        }
        if (data.label === void 0) {
          const err1 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "label" }, message: "must have required property 'label'" };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors2++;
        }
        if (data.comp !== void 0) {
          if ("select" !== data.comp) {
            const err2 = { instancePath: instancePath + "/comp", schemaPath: "#/properties/comp/const", keyword: "const", params: { allowedValue: "select" }, message: "must be equal to constant" };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors2++;
          }
        }
        if (data.label !== void 0) {
          if (typeof data.label !== "string") {
            const err3 = { instancePath: instancePath + "/label", schemaPath: "#/properties/label/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors2++;
          }
        }
        if (data.autofocus !== void 0) {
          if (typeof data.autofocus !== "boolean") {
            const err4 = { instancePath: instancePath + "/autofocus", schemaPath: "#/properties/autofocus/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors2++;
          }
        }
        if (data.items !== void 0) {
          if (!validate70(data.items, { instancePath: instancePath + "/items", parentData: data, parentDataProperty: "items", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate70.errors : vErrors.concat(validate70.errors);
            errors2 = vErrors.length;
          }
        }
        if (data.getItems !== void 0) {
          if (!validate72(data.getItems, { instancePath: instancePath + "/getItems", parentData: data, parentDataProperty: "getItems", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate72.errors : vErrors.concat(validate72.errors);
            errors2 = vErrors.length;
          }
        }
        if (data.multiple !== void 0) {
          if (typeof data.multiple !== "boolean") {
            const err5 = { instancePath: instancePath + "/multiple", schemaPath: "#/properties/multiple/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
            if (vErrors === null) {
              vErrors = [err5];
            } else {
              vErrors.push(err5);
            }
            errors2++;
          }
        }
      } else {
        const err6 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err6];
        } else {
          vErrors.push(err6);
        }
        errors2++;
      }
      validate79.errors = vErrors;
      return errors2 === 0;
    }
    validate79.evaluated = { "props": { "comp": true, "label": true, "autofocus": true, "items": true, "getItems": true, "multiple": true }, "dynamicProps": false, "dynamicItems": false };
    function validate82(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate82.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.comp === void 0) {
          const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors2++;
        }
        if (data.label === void 0) {
          const err1 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "label" }, message: "must have required property 'label'" };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors2++;
        }
        if (data.comp !== void 0) {
          if ("autocomplete" !== data.comp) {
            const err2 = { instancePath: instancePath + "/comp", schemaPath: "#/properties/comp/const", keyword: "const", params: { allowedValue: "autocomplete" }, message: "must be equal to constant" };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors2++;
          }
        }
        if (data.label !== void 0) {
          if (typeof data.label !== "string") {
            const err3 = { instancePath: instancePath + "/label", schemaPath: "#/properties/label/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors2++;
          }
        }
        if (data.autofocus !== void 0) {
          if (typeof data.autofocus !== "boolean") {
            const err4 = { instancePath: instancePath + "/autofocus", schemaPath: "#/properties/autofocus/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors2++;
          }
        }
        if (data.items !== void 0) {
          if (!validate70(data.items, { instancePath: instancePath + "/items", parentData: data, parentDataProperty: "items", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate70.errors : vErrors.concat(validate70.errors);
            errors2 = vErrors.length;
          }
        }
        if (data.getItems !== void 0) {
          if (!validate72(data.getItems, { instancePath: instancePath + "/getItems", parentData: data, parentDataProperty: "getItems", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate72.errors : vErrors.concat(validate72.errors);
            errors2 = vErrors.length;
          }
        }
        if (data.multiple !== void 0) {
          if (typeof data.multiple !== "boolean") {
            const err5 = { instancePath: instancePath + "/multiple", schemaPath: "#/properties/multiple/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
            if (vErrors === null) {
              vErrors = [err5];
            } else {
              vErrors.push(err5);
            }
            errors2++;
          }
        }
      } else {
        const err6 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err6];
        } else {
          vErrors.push(err6);
        }
        errors2++;
      }
      validate82.errors = vErrors;
      return errors2 === 0;
    }
    validate82.evaluated = { "props": { "comp": true, "label": true, "autofocus": true, "items": true, "getItems": true, "multiple": true }, "dynamicProps": false, "dynamicItems": false };
    const schema96 = { "type": "object", "required": ["comp", "children"], "properties": { "comp": { "const": "section" }, "title": { "type": ["string", "null"] }, "subtitle": { "type": ["string", "null"] }, "children": { "$ref": "#/$defs/children" } } };
    const schema98 = { "type": "object", "unevaluatedProperties": false, "required": ["key"], "properties": { "key": { "type": ["string", "integer"] }, "cols": { "$ref": "#/$defs/cols-obj" } }, "anyOf": [{}, { "$ref": "#/$defs/composite-comp-object" }] };
    const wrapper4 = { validate: validate85 };
    const schema100 = { "type": "object", "required": ["comp", "children"], "properties": { "comp": { "const": "tabs" }, "title": { "type": ["string", "null"] }, "subtitle": { "type": ["string", "null"] }, "children": { "$ref": "#/$defs/children" } } };
    const wrapper1 = { validate: validate86 };
    function validate89(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate89.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.comp === void 0) {
          const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors2++;
        }
        if (data.children === void 0) {
          const err1 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "children" }, message: "must have required property 'children'" };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors2++;
        }
        if (data.comp !== void 0) {
          if ("tabs" !== data.comp) {
            const err2 = { instancePath: instancePath + "/comp", schemaPath: "#/properties/comp/const", keyword: "const", params: { allowedValue: "tabs" }, message: "must be equal to constant" };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors2++;
          }
        }
        if (data.title !== void 0) {
          let data1 = data.title;
          if (typeof data1 !== "string" && data1 !== null) {
            const err3 = { instancePath: instancePath + "/title", schemaPath: "#/properties/title/type", keyword: "type", params: { type: schema100.properties.title.type }, message: "must be string,null" };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors2++;
          }
        }
        if (data.subtitle !== void 0) {
          let data2 = data.subtitle;
          if (typeof data2 !== "string" && data2 !== null) {
            const err4 = { instancePath: instancePath + "/subtitle", schemaPath: "#/properties/subtitle/type", keyword: "type", params: { type: schema100.properties.subtitle.type }, message: "must be string,null" };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors2++;
          }
        }
        if (data.children !== void 0) {
          if (!wrapper1.validate(data.children, { instancePath: instancePath + "/children", parentData: data, parentDataProperty: "children", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? wrapper1.validate.errors : vErrors.concat(wrapper1.validate.errors);
            errors2 = vErrors.length;
          }
        }
      } else {
        const err5 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err5];
        } else {
          vErrors.push(err5);
        }
        errors2++;
      }
      validate89.errors = vErrors;
      return errors2 === 0;
    }
    validate89.evaluated = { "props": { "comp": true, "title": true, "subtitle": true, "children": true }, "dynamicProps": false, "dynamicItems": false };
    const schema101 = { "type": "object", "required": ["comp", "children"], "properties": { "comp": { "const": "vertical-tabs" }, "title": { "type": ["string", "null"] }, "subtitle": { "type": ["string", "null"] }, "children": { "$ref": "#/$defs/children" } } };
    function validate90(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate90.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.comp === void 0) {
          const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors2++;
        }
        if (data.children === void 0) {
          const err1 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "children" }, message: "must have required property 'children'" };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors2++;
        }
        if (data.comp !== void 0) {
          if ("vertical-tabs" !== data.comp) {
            const err2 = { instancePath: instancePath + "/comp", schemaPath: "#/properties/comp/const", keyword: "const", params: { allowedValue: "vertical-tabs" }, message: "must be equal to constant" };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors2++;
          }
        }
        if (data.title !== void 0) {
          let data1 = data.title;
          if (typeof data1 !== "string" && data1 !== null) {
            const err3 = { instancePath: instancePath + "/title", schemaPath: "#/properties/title/type", keyword: "type", params: { type: schema101.properties.title.type }, message: "must be string,null" };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors2++;
          }
        }
        if (data.subtitle !== void 0) {
          let data2 = data.subtitle;
          if (typeof data2 !== "string" && data2 !== null) {
            const err4 = { instancePath: instancePath + "/subtitle", schemaPath: "#/properties/subtitle/type", keyword: "type", params: { type: schema101.properties.subtitle.type }, message: "must be string,null" };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors2++;
          }
        }
        if (data.children !== void 0) {
          if (!wrapper1.validate(data.children, { instancePath: instancePath + "/children", parentData: data, parentDataProperty: "children", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? wrapper1.validate.errors : vErrors.concat(wrapper1.validate.errors);
            errors2 = vErrors.length;
          }
        }
      } else {
        const err5 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err5];
        } else {
          vErrors.push(err5);
        }
        errors2++;
      }
      validate90.errors = vErrors;
      return errors2 === 0;
    }
    validate90.evaluated = { "props": { "comp": true, "title": true, "subtitle": true, "children": true }, "dynamicProps": false, "dynamicItems": false };
    const schema102 = { "type": "object", "required": ["comp", "children"], "properties": { "comp": { "const": "expansion-panels" }, "title": { "type": ["string", "null"] }, "subtitle": { "type": ["string", "null"] }, "children": { "$ref": "#/$defs/children" } } };
    function validate91(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate91.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.comp === void 0) {
          const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors2++;
        }
        if (data.children === void 0) {
          const err1 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "children" }, message: "must have required property 'children'" };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors2++;
        }
        if (data.comp !== void 0) {
          if ("expansion-panels" !== data.comp) {
            const err2 = { instancePath: instancePath + "/comp", schemaPath: "#/properties/comp/const", keyword: "const", params: { allowedValue: "expansion-panels" }, message: "must be equal to constant" };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors2++;
          }
        }
        if (data.title !== void 0) {
          let data1 = data.title;
          if (typeof data1 !== "string" && data1 !== null) {
            const err3 = { instancePath: instancePath + "/title", schemaPath: "#/properties/title/type", keyword: "type", params: { type: schema102.properties.title.type }, message: "must be string,null" };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors2++;
          }
        }
        if (data.subtitle !== void 0) {
          let data2 = data.subtitle;
          if (typeof data2 !== "string" && data2 !== null) {
            const err4 = { instancePath: instancePath + "/subtitle", schemaPath: "#/properties/subtitle/type", keyword: "type", params: { type: schema102.properties.subtitle.type }, message: "must be string,null" };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors2++;
          }
        }
        if (data.children !== void 0) {
          if (!wrapper1.validate(data.children, { instancePath: instancePath + "/children", parentData: data, parentDataProperty: "children", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? wrapper1.validate.errors : vErrors.concat(wrapper1.validate.errors);
            errors2 = vErrors.length;
          }
        }
      } else {
        const err5 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err5];
        } else {
          vErrors.push(err5);
        }
        errors2++;
      }
      validate91.errors = vErrors;
      return errors2 === 0;
    }
    validate91.evaluated = { "props": { "comp": true, "title": true, "subtitle": true, "children": true }, "dynamicProps": false, "dynamicItems": false };
    function validate88(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate88.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        const tag0 = data.comp;
        if (typeof tag0 == "string") {
          if (tag0 === "section") {
            if (!wrapper4.validate(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
              vErrors = vErrors === null ? wrapper4.validate.errors : vErrors.concat(wrapper4.validate.errors);
              errors2 = vErrors.length;
            } else {
              var props0 = wrapper4.validate.evaluated.props;
              var items0 = wrapper4.validate.evaluated.items;
            }
          } else if (tag0 === "tabs") {
            if (!validate89(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
              vErrors = vErrors === null ? validate89.errors : vErrors.concat(validate89.errors);
              errors2 = vErrors.length;
            }
            if (props0 !== true) {
              props0 = props0 || {};
              props0.comp = true;
              props0.title = true;
              props0.subtitle = true;
              props0.children = true;
            }
          } else if (tag0 === "vertical-tabs") {
            if (!validate90(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
              vErrors = vErrors === null ? validate90.errors : vErrors.concat(validate90.errors);
              errors2 = vErrors.length;
            }
            if (props0 !== true) {
              props0 = props0 || {};
              props0.comp = true;
              props0.title = true;
              props0.subtitle = true;
              props0.children = true;
            }
          } else if (tag0 === "expansion-panels") {
            if (!validate91(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
              vErrors = vErrors === null ? validate91.errors : vErrors.concat(validate91.errors);
              errors2 = vErrors.length;
            }
            if (props0 !== true) {
              props0 = props0 || {};
              props0.comp = true;
              props0.title = true;
              props0.subtitle = true;
              props0.children = true;
            }
          } else {
            const err0 = { instancePath, schemaPath: "#/discriminator", keyword: "discriminator", params: { error: "mapping", tag: "comp", tagValue: tag0 }, message: 'value of tag "comp" must be in oneOf' };
            if (vErrors === null) {
              vErrors = [err0];
            } else {
              vErrors.push(err0);
            }
            errors2++;
          }
        } else {
          const err1 = { instancePath, schemaPath: "#/discriminator", keyword: "discriminator", params: { error: "tag", tag: "comp", tagValue: tag0 }, message: 'tag "comp" must be string' };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors2++;
        }
      } else {
        const err2 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err2];
        } else {
          vErrors.push(err2);
        }
        errors2++;
      }
      validate88.errors = vErrors;
      evaluated0.props = props0;
      evaluated0.items = items0;
      return errors2 === 0;
    }
    validate88.evaluated = { "dynamicProps": true, "dynamicItems": true };
    function validate87(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate87.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      const _errs1 = errors2;
      let valid0 = false;
      var _valid0 = true;
      valid0 = valid0 || _valid0;
      const _errs2 = errors2;
      if (!validate88(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
        vErrors = vErrors === null ? validate88.errors : vErrors.concat(validate88.errors);
        errors2 = vErrors.length;
      } else {
        var props0 = validate88.evaluated.props;
        var items0 = validate88.evaluated.items;
      }
      var _valid0 = _errs2 === errors2;
      valid0 = valid0 || _valid0;
      if (!valid0) {
        const err0 = { instancePath, schemaPath: "#/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors2++;
      } else {
        errors2 = _errs1;
        if (vErrors !== null) {
          if (_errs1) {
            vErrors.length = _errs1;
          } else {
            vErrors = null;
          }
        }
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.key === void 0) {
          const err1 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "key" }, message: "must have required property 'key'" };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors2++;
        }
        if (props0 !== true) {
          props0 = props0 || {};
          props0.key = true;
          props0.cols = true;
        }
        if (data.key !== void 0) {
          let data0 = data.key;
          if (typeof data0 !== "string" && !(typeof data0 == "number" && (!(data0 % 1) && !isNaN(data0)) && isFinite(data0))) {
            const err2 = { instancePath: instancePath + "/key", schemaPath: "#/properties/key/type", keyword: "type", params: { type: schema98.properties.key.type }, message: "must be string,integer" };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors2++;
          }
        }
        if (data.cols !== void 0) {
          if (!validate64(data.cols, { instancePath: instancePath + "/cols", parentData: data, parentDataProperty: "cols", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate64.errors : vErrors.concat(validate64.errors);
            errors2 = vErrors.length;
          }
        }
        if (props0 !== true) {
          for (const key0 in data) {
            if (!props0 || !props0[key0]) {
              const err3 = { instancePath, schemaPath: "#/unevaluatedProperties", keyword: "unevaluatedProperties", params: { unevaluatedProperty: key0 }, message: "must NOT have unevaluated properties" };
              if (vErrors === null) {
                vErrors = [err3];
              } else {
                vErrors.push(err3);
              }
              errors2++;
            }
          }
        }
      } else {
        const err4 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err4];
        } else {
          vErrors.push(err4);
        }
        errors2++;
      }
      validate87.errors = vErrors;
      evaluated0.items = items0;
      return errors2 === 0;
    }
    validate87.evaluated = { "props": true, "dynamicProps": false, "dynamicItems": true };
    function validate86(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate86.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (Array.isArray(data)) {
        const len0 = data.length;
        for (let i0 = 0; i0 < len0; i0++) {
          if (!validate87(data[i0], { instancePath: instancePath + "/" + i0, parentData: data, parentDataProperty: i0, rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate87.errors : vErrors.concat(validate87.errors);
            errors2 = vErrors.length;
          }
        }
      } else {
        const err0 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "array" }, message: "must be array" };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors2++;
      }
      validate86.errors = vErrors;
      return errors2 === 0;
    }
    validate86.evaluated = { "items": true, "dynamicProps": false, "dynamicItems": false };
    function validate85(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate85.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.comp === void 0) {
          const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors2++;
        }
        if (data.children === void 0) {
          const err1 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "children" }, message: "must have required property 'children'" };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors2++;
        }
        if (data.comp !== void 0) {
          if ("section" !== data.comp) {
            const err2 = { instancePath: instancePath + "/comp", schemaPath: "#/properties/comp/const", keyword: "const", params: { allowedValue: "section" }, message: "must be equal to constant" };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors2++;
          }
        }
        if (data.title !== void 0) {
          let data1 = data.title;
          if (typeof data1 !== "string" && data1 !== null) {
            const err3 = { instancePath: instancePath + "/title", schemaPath: "#/properties/title/type", keyword: "type", params: { type: schema96.properties.title.type }, message: "must be string,null" };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors2++;
          }
        }
        if (data.subtitle !== void 0) {
          let data2 = data.subtitle;
          if (typeof data2 !== "string" && data2 !== null) {
            const err4 = { instancePath: instancePath + "/subtitle", schemaPath: "#/properties/subtitle/type", keyword: "type", params: { type: schema96.properties.subtitle.type }, message: "must be string,null" };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors2++;
          }
        }
        if (data.children !== void 0) {
          if (!validate86(data.children, { instancePath: instancePath + "/children", parentData: data, parentDataProperty: "children", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate86.errors : vErrors.concat(validate86.errors);
            errors2 = vErrors.length;
          }
        }
      } else {
        const err5 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err5];
        } else {
          vErrors.push(err5);
        }
        errors2++;
      }
      validate85.errors = vErrors;
      return errors2 === 0;
    }
    validate85.evaluated = { "props": { "comp": true, "title": true, "subtitle": true, "children": true }, "dynamicProps": false, "dynamicItems": false };
    const schema103 = { "type": "object", "required": ["comp", "children"], "properties": { "comp": { "const": "stepper" }, "title": { "type": ["string", "null"] }, "subtitle": { "type": ["string", "null"] }, "children": { "$ref": "#/$defs/children" } } };
    function validate99(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate99.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.comp === void 0) {
          const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors2++;
        }
        if (data.children === void 0) {
          const err1 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "children" }, message: "must have required property 'children'" };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors2++;
        }
        if (data.comp !== void 0) {
          if ("stepper" !== data.comp) {
            const err2 = { instancePath: instancePath + "/comp", schemaPath: "#/properties/comp/const", keyword: "const", params: { allowedValue: "stepper" }, message: "must be equal to constant" };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors2++;
          }
        }
        if (data.title !== void 0) {
          let data1 = data.title;
          if (typeof data1 !== "string" && data1 !== null) {
            const err3 = { instancePath: instancePath + "/title", schemaPath: "#/properties/title/type", keyword: "type", params: { type: schema103.properties.title.type }, message: "must be string,null" };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors2++;
          }
        }
        if (data.subtitle !== void 0) {
          let data2 = data.subtitle;
          if (typeof data2 !== "string" && data2 !== null) {
            const err4 = { instancePath: instancePath + "/subtitle", schemaPath: "#/properties/subtitle/type", keyword: "type", params: { type: schema103.properties.subtitle.type }, message: "must be string,null" };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors2++;
          }
        }
        if (data.children !== void 0) {
          if (!validate86(data.children, { instancePath: instancePath + "/children", parentData: data, parentDataProperty: "children", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate86.errors : vErrors.concat(validate86.errors);
            errors2 = vErrors.length;
          }
        }
      } else {
        const err5 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err5];
        } else {
          vErrors.push(err5);
        }
        errors2++;
      }
      validate99.errors = vErrors;
      return errors2 === 0;
    }
    validate99.evaluated = { "props": { "comp": true, "title": true, "subtitle": true, "children": true }, "dynamicProps": false, "dynamicItems": false };
    const formats0 = formats.fullFormats.date;
    const formats4 = formats.fullFormats["date-time"];
    const formats8 = formats.fullFormats.time;
    function validate61(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate61.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.if !== void 0) {
          let data0 = data.if;
          if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
            if (data0.type === void 0) {
              const err0 = { instancePath: instancePath + "/if", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'" };
              if (vErrors === null) {
                vErrors = [err0];
              } else {
                vErrors.push(err0);
              }
              errors2++;
            }
            if (data0.expr === void 0) {
              const err1 = { instancePath: instancePath + "/if", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "expr" }, message: "must have required property 'expr'" };
              if (vErrors === null) {
                vErrors = [err1];
              } else {
                vErrors.push(err1);
              }
              errors2++;
            }
            if (data0.pure === void 0) {
              const err2 = { instancePath: instancePath + "/if", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "pure" }, message: "must have required property 'pure'" };
              if (vErrors === null) {
                vErrors = [err2];
              } else {
                vErrors.push(err2);
              }
              errors2++;
            }
            if (data0.type !== void 0) {
              let data1 = data0.type;
              if (typeof data1 !== "string") {
                const err3 = { instancePath: instancePath + "/if/type", schemaPath: "#/$defs/expression/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err3];
                } else {
                  vErrors.push(err3);
                }
                errors2++;
              }
              if (!(data1 === "js-fn" || data1 === "js-eval" || data1 === "js-tpl")) {
                const err4 = { instancePath: instancePath + "/if/type", schemaPath: "#/$defs/expression/properties/type/enum", keyword: "enum", params: { allowedValues: schema56.properties.type.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err4];
                } else {
                  vErrors.push(err4);
                }
                errors2++;
              }
            }
            if (data0.expr !== void 0) {
              if (typeof data0.expr !== "string") {
                const err5 = { instancePath: instancePath + "/if/expr", schemaPath: "#/$defs/expression/properties/expr/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err5];
                } else {
                  vErrors.push(err5);
                }
                errors2++;
              }
            }
            if (data0.pure !== void 0) {
              if (typeof data0.pure !== "boolean") {
                const err6 = { instancePath: instancePath + "/if/pure", schemaPath: "#/$defs/expression/properties/pure/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                if (vErrors === null) {
                  vErrors = [err6];
                } else {
                  vErrors.push(err6);
                }
                errors2++;
              }
            }
            if (data0.ref !== void 0) {
              let data4 = data0.ref;
              if (!(typeof data4 == "number" && (!(data4 % 1) && !isNaN(data4)) && isFinite(data4))) {
                const err7 = { instancePath: instancePath + "/if/ref", schemaPath: "#/$defs/expression/properties/ref/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
                if (vErrors === null) {
                  vErrors = [err7];
                } else {
                  vErrors.push(err7);
                }
                errors2++;
              }
            }
          } else {
            const err8 = { instancePath: instancePath + "/if", schemaPath: "#/$defs/expression/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err8];
            } else {
              vErrors.push(err8);
            }
            errors2++;
          }
        }
        if (data.options !== void 0) {
          if (!validate62(data.options, { instancePath: instancePath + "/options", parentData: data, parentDataProperty: "options", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate62.errors : vErrors.concat(validate62.errors);
            errors2 = vErrors.length;
          }
        }
        if (data.getOptions !== void 0) {
          let data6 = data.getOptions;
          if (data6 && typeof data6 == "object" && !Array.isArray(data6)) {
            if (data6.type === void 0) {
              const err9 = { instancePath: instancePath + "/getOptions", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'" };
              if (vErrors === null) {
                vErrors = [err9];
              } else {
                vErrors.push(err9);
              }
              errors2++;
            }
            if (data6.expr === void 0) {
              const err10 = { instancePath: instancePath + "/getOptions", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "expr" }, message: "must have required property 'expr'" };
              if (vErrors === null) {
                vErrors = [err10];
              } else {
                vErrors.push(err10);
              }
              errors2++;
            }
            if (data6.pure === void 0) {
              const err11 = { instancePath: instancePath + "/getOptions", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "pure" }, message: "must have required property 'pure'" };
              if (vErrors === null) {
                vErrors = [err11];
              } else {
                vErrors.push(err11);
              }
              errors2++;
            }
            if (data6.type !== void 0) {
              let data7 = data6.type;
              if (typeof data7 !== "string") {
                const err12 = { instancePath: instancePath + "/getOptions/type", schemaPath: "#/$defs/expression/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err12];
                } else {
                  vErrors.push(err12);
                }
                errors2++;
              }
              if (!(data7 === "js-fn" || data7 === "js-eval" || data7 === "js-tpl")) {
                const err13 = { instancePath: instancePath + "/getOptions/type", schemaPath: "#/$defs/expression/properties/type/enum", keyword: "enum", params: { allowedValues: schema56.properties.type.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err13];
                } else {
                  vErrors.push(err13);
                }
                errors2++;
              }
            }
            if (data6.expr !== void 0) {
              if (typeof data6.expr !== "string") {
                const err14 = { instancePath: instancePath + "/getOptions/expr", schemaPath: "#/$defs/expression/properties/expr/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err14];
                } else {
                  vErrors.push(err14);
                }
                errors2++;
              }
            }
            if (data6.pure !== void 0) {
              if (typeof data6.pure !== "boolean") {
                const err15 = { instancePath: instancePath + "/getOptions/pure", schemaPath: "#/$defs/expression/properties/pure/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                if (vErrors === null) {
                  vErrors = [err15];
                } else {
                  vErrors.push(err15);
                }
                errors2++;
              }
            }
            if (data6.ref !== void 0) {
              let data10 = data6.ref;
              if (!(typeof data10 == "number" && (!(data10 % 1) && !isNaN(data10)) && isFinite(data10))) {
                const err16 = { instancePath: instancePath + "/getOptions/ref", schemaPath: "#/$defs/expression/properties/ref/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
                if (vErrors === null) {
                  vErrors = [err16];
                } else {
                  vErrors.push(err16);
                }
                errors2++;
              }
            }
          } else {
            const err17 = { instancePath: instancePath + "/getOptions", schemaPath: "#/$defs/expression/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err17];
            } else {
              vErrors.push(err17);
            }
            errors2++;
          }
        }
        if (data.getDefaultData !== void 0) {
          let data11 = data.getDefaultData;
          if (data11 && typeof data11 == "object" && !Array.isArray(data11)) {
            if (data11.type === void 0) {
              const err18 = { instancePath: instancePath + "/getDefaultData", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'" };
              if (vErrors === null) {
                vErrors = [err18];
              } else {
                vErrors.push(err18);
              }
              errors2++;
            }
            if (data11.expr === void 0) {
              const err19 = { instancePath: instancePath + "/getDefaultData", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "expr" }, message: "must have required property 'expr'" };
              if (vErrors === null) {
                vErrors = [err19];
              } else {
                vErrors.push(err19);
              }
              errors2++;
            }
            if (data11.pure === void 0) {
              const err20 = { instancePath: instancePath + "/getDefaultData", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "pure" }, message: "must have required property 'pure'" };
              if (vErrors === null) {
                vErrors = [err20];
              } else {
                vErrors.push(err20);
              }
              errors2++;
            }
            if (data11.type !== void 0) {
              let data12 = data11.type;
              if (typeof data12 !== "string") {
                const err21 = { instancePath: instancePath + "/getDefaultData/type", schemaPath: "#/$defs/expression/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err21];
                } else {
                  vErrors.push(err21);
                }
                errors2++;
              }
              if (!(data12 === "js-fn" || data12 === "js-eval" || data12 === "js-tpl")) {
                const err22 = { instancePath: instancePath + "/getDefaultData/type", schemaPath: "#/$defs/expression/properties/type/enum", keyword: "enum", params: { allowedValues: schema56.properties.type.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err22];
                } else {
                  vErrors.push(err22);
                }
                errors2++;
              }
            }
            if (data11.expr !== void 0) {
              if (typeof data11.expr !== "string") {
                const err23 = { instancePath: instancePath + "/getDefaultData/expr", schemaPath: "#/$defs/expression/properties/expr/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err23];
                } else {
                  vErrors.push(err23);
                }
                errors2++;
              }
            }
            if (data11.pure !== void 0) {
              if (typeof data11.pure !== "boolean") {
                const err24 = { instancePath: instancePath + "/getDefaultData/pure", schemaPath: "#/$defs/expression/properties/pure/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                if (vErrors === null) {
                  vErrors = [err24];
                } else {
                  vErrors.push(err24);
                }
                errors2++;
              }
            }
            if (data11.ref !== void 0) {
              let data15 = data11.ref;
              if (!(typeof data15 == "number" && (!(data15 % 1) && !isNaN(data15)) && isFinite(data15))) {
                const err25 = { instancePath: instancePath + "/getDefaultData/ref", schemaPath: "#/$defs/expression/properties/ref/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
                if (vErrors === null) {
                  vErrors = [err25];
                } else {
                  vErrors.push(err25);
                }
                errors2++;
              }
            }
          } else {
            const err26 = { instancePath: instancePath + "/getDefaultData", schemaPath: "#/$defs/expression/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err26];
            } else {
              vErrors.push(err26);
            }
            errors2++;
          }
        }
        if (data.getConstData !== void 0) {
          let data16 = data.getConstData;
          if (data16 && typeof data16 == "object" && !Array.isArray(data16)) {
            if (data16.type === void 0) {
              const err27 = { instancePath: instancePath + "/getConstData", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'" };
              if (vErrors === null) {
                vErrors = [err27];
              } else {
                vErrors.push(err27);
              }
              errors2++;
            }
            if (data16.expr === void 0) {
              const err28 = { instancePath: instancePath + "/getConstData", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "expr" }, message: "must have required property 'expr'" };
              if (vErrors === null) {
                vErrors = [err28];
              } else {
                vErrors.push(err28);
              }
              errors2++;
            }
            if (data16.pure === void 0) {
              const err29 = { instancePath: instancePath + "/getConstData", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "pure" }, message: "must have required property 'pure'" };
              if (vErrors === null) {
                vErrors = [err29];
              } else {
                vErrors.push(err29);
              }
              errors2++;
            }
            if (data16.type !== void 0) {
              let data17 = data16.type;
              if (typeof data17 !== "string") {
                const err30 = { instancePath: instancePath + "/getConstData/type", schemaPath: "#/$defs/expression/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err30];
                } else {
                  vErrors.push(err30);
                }
                errors2++;
              }
              if (!(data17 === "js-fn" || data17 === "js-eval" || data17 === "js-tpl")) {
                const err31 = { instancePath: instancePath + "/getConstData/type", schemaPath: "#/$defs/expression/properties/type/enum", keyword: "enum", params: { allowedValues: schema56.properties.type.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err31];
                } else {
                  vErrors.push(err31);
                }
                errors2++;
              }
            }
            if (data16.expr !== void 0) {
              if (typeof data16.expr !== "string") {
                const err32 = { instancePath: instancePath + "/getConstData/expr", schemaPath: "#/$defs/expression/properties/expr/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err32];
                } else {
                  vErrors.push(err32);
                }
                errors2++;
              }
            }
            if (data16.pure !== void 0) {
              if (typeof data16.pure !== "boolean") {
                const err33 = { instancePath: instancePath + "/getConstData/pure", schemaPath: "#/$defs/expression/properties/pure/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                if (vErrors === null) {
                  vErrors = [err33];
                } else {
                  vErrors.push(err33);
                }
                errors2++;
              }
            }
            if (data16.ref !== void 0) {
              let data20 = data16.ref;
              if (!(typeof data20 == "number" && (!(data20 % 1) && !isNaN(data20)) && isFinite(data20))) {
                const err34 = { instancePath: instancePath + "/getConstData/ref", schemaPath: "#/$defs/expression/properties/ref/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
                if (vErrors === null) {
                  vErrors = [err34];
                } else {
                  vErrors.push(err34);
                }
                errors2++;
              }
            }
          } else {
            const err35 = { instancePath: instancePath + "/getConstData", schemaPath: "#/$defs/expression/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err35];
            } else {
              vErrors.push(err35);
            }
            errors2++;
          }
        }
        if (data.transformData !== void 0) {
          let data21 = data.transformData;
          if (data21 && typeof data21 == "object" && !Array.isArray(data21)) {
            if (data21.type === void 0) {
              const err36 = { instancePath: instancePath + "/transformData", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'" };
              if (vErrors === null) {
                vErrors = [err36];
              } else {
                vErrors.push(err36);
              }
              errors2++;
            }
            if (data21.expr === void 0) {
              const err37 = { instancePath: instancePath + "/transformData", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "expr" }, message: "must have required property 'expr'" };
              if (vErrors === null) {
                vErrors = [err37];
              } else {
                vErrors.push(err37);
              }
              errors2++;
            }
            if (data21.pure === void 0) {
              const err38 = { instancePath: instancePath + "/transformData", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "pure" }, message: "must have required property 'pure'" };
              if (vErrors === null) {
                vErrors = [err38];
              } else {
                vErrors.push(err38);
              }
              errors2++;
            }
            if (data21.type !== void 0) {
              let data22 = data21.type;
              if (typeof data22 !== "string") {
                const err39 = { instancePath: instancePath + "/transformData/type", schemaPath: "#/$defs/expression/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err39];
                } else {
                  vErrors.push(err39);
                }
                errors2++;
              }
              if (!(data22 === "js-fn" || data22 === "js-eval" || data22 === "js-tpl")) {
                const err40 = { instancePath: instancePath + "/transformData/type", schemaPath: "#/$defs/expression/properties/type/enum", keyword: "enum", params: { allowedValues: schema56.properties.type.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err40];
                } else {
                  vErrors.push(err40);
                }
                errors2++;
              }
            }
            if (data21.expr !== void 0) {
              if (typeof data21.expr !== "string") {
                const err41 = { instancePath: instancePath + "/transformData/expr", schemaPath: "#/$defs/expression/properties/expr/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err41];
                } else {
                  vErrors.push(err41);
                }
                errors2++;
              }
            }
            if (data21.pure !== void 0) {
              if (typeof data21.pure !== "boolean") {
                const err42 = { instancePath: instancePath + "/transformData/pure", schemaPath: "#/$defs/expression/properties/pure/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                if (vErrors === null) {
                  vErrors = [err42];
                } else {
                  vErrors.push(err42);
                }
                errors2++;
              }
            }
            if (data21.ref !== void 0) {
              let data25 = data21.ref;
              if (!(typeof data25 == "number" && (!(data25 % 1) && !isNaN(data25)) && isFinite(data25))) {
                const err43 = { instancePath: instancePath + "/transformData/ref", schemaPath: "#/$defs/expression/properties/ref/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
                if (vErrors === null) {
                  vErrors = [err43];
                } else {
                  vErrors.push(err43);
                }
                errors2++;
              }
            }
          } else {
            const err44 = { instancePath: instancePath + "/transformData", schemaPath: "#/$defs/expression/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err44];
            } else {
              vErrors.push(err44);
            }
            errors2++;
          }
        }
        if (data.nullable !== void 0) {
          if (typeof data.nullable !== "boolean") {
            const err45 = { instancePath: instancePath + "/nullable", schemaPath: "#/allOf/0/properties/nullable/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
            if (vErrors === null) {
              vErrors = [err45];
            } else {
              vErrors.push(err45);
            }
            errors2++;
          }
        }
        if (data.help !== void 0) {
          if (typeof data.help !== "string") {
            const err46 = { instancePath: instancePath + "/help", schemaPath: "#/allOf/0/properties/help/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err46];
            } else {
              vErrors.push(err46);
            }
            errors2++;
          }
        }
        if (data.cols !== void 0) {
          if (!validate64(data.cols, { instancePath: instancePath + "/cols", parentData: data, parentDataProperty: "cols", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate64.errors : vErrors.concat(validate64.errors);
            errors2 = vErrors.length;
          }
        }
        if (data.props !== void 0) {
          let data29 = data.props;
          if (data29 && typeof data29 == "object" && !Array.isArray(data29)) {
            var props1 = {};
            for (const key0 in data29) {
              if (pattern2.test(key0)) {
                props1[key0] = true;
              }
            }
          } else {
            const err47 = { instancePath: instancePath + "/props", schemaPath: "#/$defs/state-node-props-lib/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err47];
            } else {
              vErrors.push(err47);
            }
            errors2++;
          }
        }
        if (data.getProps !== void 0) {
          let data30 = data.getProps;
          if (data30 && typeof data30 == "object" && !Array.isArray(data30)) {
            if (data30.type === void 0) {
              const err48 = { instancePath: instancePath + "/getProps", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'" };
              if (vErrors === null) {
                vErrors = [err48];
              } else {
                vErrors.push(err48);
              }
              errors2++;
            }
            if (data30.expr === void 0) {
              const err49 = { instancePath: instancePath + "/getProps", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "expr" }, message: "must have required property 'expr'" };
              if (vErrors === null) {
                vErrors = [err49];
              } else {
                vErrors.push(err49);
              }
              errors2++;
            }
            if (data30.pure === void 0) {
              const err50 = { instancePath: instancePath + "/getProps", schemaPath: "#/$defs/expression/required", keyword: "required", params: { missingProperty: "pure" }, message: "must have required property 'pure'" };
              if (vErrors === null) {
                vErrors = [err50];
              } else {
                vErrors.push(err50);
              }
              errors2++;
            }
            if (data30.type !== void 0) {
              let data31 = data30.type;
              if (typeof data31 !== "string") {
                const err51 = { instancePath: instancePath + "/getProps/type", schemaPath: "#/$defs/expression/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err51];
                } else {
                  vErrors.push(err51);
                }
                errors2++;
              }
              if (!(data31 === "js-fn" || data31 === "js-eval" || data31 === "js-tpl")) {
                const err52 = { instancePath: instancePath + "/getProps/type", schemaPath: "#/$defs/expression/properties/type/enum", keyword: "enum", params: { allowedValues: schema56.properties.type.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err52];
                } else {
                  vErrors.push(err52);
                }
                errors2++;
              }
            }
            if (data30.expr !== void 0) {
              if (typeof data30.expr !== "string") {
                const err53 = { instancePath: instancePath + "/getProps/expr", schemaPath: "#/$defs/expression/properties/expr/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err53];
                } else {
                  vErrors.push(err53);
                }
                errors2++;
              }
            }
            if (data30.pure !== void 0) {
              if (typeof data30.pure !== "boolean") {
                const err54 = { instancePath: instancePath + "/getProps/pure", schemaPath: "#/$defs/expression/properties/pure/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                if (vErrors === null) {
                  vErrors = [err54];
                } else {
                  vErrors.push(err54);
                }
                errors2++;
              }
            }
            if (data30.ref !== void 0) {
              let data34 = data30.ref;
              if (!(typeof data34 == "number" && (!(data34 % 1) && !isNaN(data34)) && isFinite(data34))) {
                const err55 = { instancePath: instancePath + "/getProps/ref", schemaPath: "#/$defs/expression/properties/ref/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
                if (vErrors === null) {
                  vErrors = [err55];
                } else {
                  vErrors.push(err55);
                }
                errors2++;
              }
            }
          } else {
            const err56 = { instancePath: instancePath + "/getProps", schemaPath: "#/$defs/expression/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err56];
            } else {
              vErrors.push(err56);
            }
            errors2++;
          }
        }
        if (data.slots !== void 0) {
          let data35 = data.slots;
          if (!(data35 && typeof data35 == "object" && !Array.isArray(data35))) {
            const err57 = { instancePath: instancePath + "/slots", schemaPath: "#/allOf/0/properties/slots/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err57];
            } else {
              vErrors.push(err57);
            }
            errors2++;
          }
          if (!validate66(data35, { instancePath: instancePath + "/slots", parentData: data, parentDataProperty: "slots", rootData, dynamicAnchors })) {
            vErrors = vErrors === null ? validate66.errors : vErrors.concat(validate66.errors);
            errors2 = vErrors.length;
          } else {
            var props2 = validate66.evaluated.props;
          }
          if (data35 && typeof data35 == "object" && !Array.isArray(data35)) {
            if (data35.before !== void 0) {
              let data36 = data35.before;
              const _errs83 = errors2;
              let valid19 = false;
              let passing0 = null;
              const _errs84 = errors2;
              if (data36 && typeof data36 == "object" && !Array.isArray(data36)) {
                if (data36.text === void 0) {
                  const err58 = { instancePath: instancePath + "/slots/before", schemaPath: "#/$defs/slot/oneOf/0/required", keyword: "required", params: { missingProperty: "text" }, message: "must have required property 'text'" };
                  if (vErrors === null) {
                    vErrors = [err58];
                  } else {
                    vErrors.push(err58);
                  }
                  errors2++;
                }
                for (const key1 in data36) {
                  if (!(key1 === "text")) {
                    const err59 = { instancePath: instancePath + "/slots/before", schemaPath: "#/$defs/slot/oneOf/0/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties" };
                    if (vErrors === null) {
                      vErrors = [err59];
                    } else {
                      vErrors.push(err59);
                    }
                    errors2++;
                  }
                }
                if (data36.text !== void 0) {
                  if (typeof data36.text !== "string") {
                    const err60 = { instancePath: instancePath + "/slots/before/text", schemaPath: "#/$defs/slot/oneOf/0/properties/text/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                      vErrors = [err60];
                    } else {
                      vErrors.push(err60);
                    }
                    errors2++;
                  }
                }
              } else {
                const err61 = { instancePath: instancePath + "/slots/before", schemaPath: "#/$defs/slot/oneOf/0/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                if (vErrors === null) {
                  vErrors = [err61];
                } else {
                  vErrors.push(err61);
                }
                errors2++;
              }
              var _valid0 = _errs84 === errors2;
              if (_valid0) {
                valid19 = true;
                passing0 = 0;
              }
              const _errs89 = errors2;
              if (data36 && typeof data36 == "object" && !Array.isArray(data36)) {
                if (data36.markdown === void 0) {
                  const err62 = { instancePath: instancePath + "/slots/before", schemaPath: "#/$defs/slot/oneOf/1/required", keyword: "required", params: { missingProperty: "markdown" }, message: "must have required property 'markdown'" };
                  if (vErrors === null) {
                    vErrors = [err62];
                  } else {
                    vErrors.push(err62);
                  }
                  errors2++;
                }
                for (const key2 in data36) {
                  if (!(key2 === "markdown")) {
                    const err63 = { instancePath: instancePath + "/slots/before", schemaPath: "#/$defs/slot/oneOf/1/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key2 }, message: "must NOT have additional properties" };
                    if (vErrors === null) {
                      vErrors = [err63];
                    } else {
                      vErrors.push(err63);
                    }
                    errors2++;
                  }
                }
                if (data36.markdown !== void 0) {
                  if (typeof data36.markdown !== "string") {
                    const err64 = { instancePath: instancePath + "/slots/before/markdown", schemaPath: "#/$defs/slot/oneOf/1/properties/markdown/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                      vErrors = [err64];
                    } else {
                      vErrors.push(err64);
                    }
                    errors2++;
                  }
                }
              } else {
                const err65 = { instancePath: instancePath + "/slots/before", schemaPath: "#/$defs/slot/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                if (vErrors === null) {
                  vErrors = [err65];
                } else {
                  vErrors.push(err65);
                }
                errors2++;
              }
              var _valid0 = _errs89 === errors2;
              if (_valid0 && valid19) {
                valid19 = false;
                passing0 = [passing0, 1];
              } else {
                if (_valid0) {
                  valid19 = true;
                  passing0 = 1;
                }
                const _errs94 = errors2;
                if (data36 && typeof data36 == "object" && !Array.isArray(data36)) {
                  if (data36.name === void 0) {
                    const err66 = { instancePath: instancePath + "/slots/before", schemaPath: "#/$defs/slot/oneOf/2/required", keyword: "required", params: { missingProperty: "name" }, message: "must have required property 'name'" };
                    if (vErrors === null) {
                      vErrors = [err66];
                    } else {
                      vErrors.push(err66);
                    }
                    errors2++;
                  }
                  for (const key3 in data36) {
                    if (!(key3 === "name")) {
                      const err67 = { instancePath: instancePath + "/slots/before", schemaPath: "#/$defs/slot/oneOf/2/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key3 }, message: "must NOT have additional properties" };
                      if (vErrors === null) {
                        vErrors = [err67];
                      } else {
                        vErrors.push(err67);
                      }
                      errors2++;
                    }
                  }
                  if (data36.name !== void 0) {
                    if (typeof data36.name !== "string") {
                      const err68 = { instancePath: instancePath + "/slots/before/name", schemaPath: "#/$defs/slot/oneOf/2/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                      if (vErrors === null) {
                        vErrors = [err68];
                      } else {
                        vErrors.push(err68);
                      }
                      errors2++;
                    }
                  }
                } else {
                  const err69 = { instancePath: instancePath + "/slots/before", schemaPath: "#/$defs/slot/oneOf/2/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                  if (vErrors === null) {
                    vErrors = [err69];
                  } else {
                    vErrors.push(err69);
                  }
                  errors2++;
                }
                var _valid0 = _errs94 === errors2;
                if (_valid0 && valid19) {
                  valid19 = false;
                  passing0 = [passing0, 2];
                } else {
                  if (_valid0) {
                    valid19 = true;
                    passing0 = 2;
                  }
                }
              }
              if (!valid19) {
                const err70 = { instancePath: instancePath + "/slots/before", schemaPath: "#/$defs/slot/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
                if (vErrors === null) {
                  vErrors = [err70];
                } else {
                  vErrors.push(err70);
                }
                errors2++;
              } else {
                errors2 = _errs83;
                if (vErrors !== null) {
                  if (_errs83) {
                    vErrors.length = _errs83;
                  } else {
                    vErrors = null;
                  }
                }
              }
            }
            if (data35.after !== void 0) {
              let data40 = data35.after;
              const _errs101 = errors2;
              let valid24 = false;
              let passing1 = null;
              const _errs102 = errors2;
              if (data40 && typeof data40 == "object" && !Array.isArray(data40)) {
                if (data40.text === void 0) {
                  const err71 = { instancePath: instancePath + "/slots/after", schemaPath: "#/$defs/slot/oneOf/0/required", keyword: "required", params: { missingProperty: "text" }, message: "must have required property 'text'" };
                  if (vErrors === null) {
                    vErrors = [err71];
                  } else {
                    vErrors.push(err71);
                  }
                  errors2++;
                }
                for (const key4 in data40) {
                  if (!(key4 === "text")) {
                    const err72 = { instancePath: instancePath + "/slots/after", schemaPath: "#/$defs/slot/oneOf/0/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key4 }, message: "must NOT have additional properties" };
                    if (vErrors === null) {
                      vErrors = [err72];
                    } else {
                      vErrors.push(err72);
                    }
                    errors2++;
                  }
                }
                if (data40.text !== void 0) {
                  if (typeof data40.text !== "string") {
                    const err73 = { instancePath: instancePath + "/slots/after/text", schemaPath: "#/$defs/slot/oneOf/0/properties/text/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                      vErrors = [err73];
                    } else {
                      vErrors.push(err73);
                    }
                    errors2++;
                  }
                }
              } else {
                const err74 = { instancePath: instancePath + "/slots/after", schemaPath: "#/$defs/slot/oneOf/0/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                if (vErrors === null) {
                  vErrors = [err74];
                } else {
                  vErrors.push(err74);
                }
                errors2++;
              }
              var _valid1 = _errs102 === errors2;
              if (_valid1) {
                valid24 = true;
                passing1 = 0;
              }
              const _errs107 = errors2;
              if (data40 && typeof data40 == "object" && !Array.isArray(data40)) {
                if (data40.markdown === void 0) {
                  const err75 = { instancePath: instancePath + "/slots/after", schemaPath: "#/$defs/slot/oneOf/1/required", keyword: "required", params: { missingProperty: "markdown" }, message: "must have required property 'markdown'" };
                  if (vErrors === null) {
                    vErrors = [err75];
                  } else {
                    vErrors.push(err75);
                  }
                  errors2++;
                }
                for (const key5 in data40) {
                  if (!(key5 === "markdown")) {
                    const err76 = { instancePath: instancePath + "/slots/after", schemaPath: "#/$defs/slot/oneOf/1/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key5 }, message: "must NOT have additional properties" };
                    if (vErrors === null) {
                      vErrors = [err76];
                    } else {
                      vErrors.push(err76);
                    }
                    errors2++;
                  }
                }
                if (data40.markdown !== void 0) {
                  if (typeof data40.markdown !== "string") {
                    const err77 = { instancePath: instancePath + "/slots/after/markdown", schemaPath: "#/$defs/slot/oneOf/1/properties/markdown/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                      vErrors = [err77];
                    } else {
                      vErrors.push(err77);
                    }
                    errors2++;
                  }
                }
              } else {
                const err78 = { instancePath: instancePath + "/slots/after", schemaPath: "#/$defs/slot/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                if (vErrors === null) {
                  vErrors = [err78];
                } else {
                  vErrors.push(err78);
                }
                errors2++;
              }
              var _valid1 = _errs107 === errors2;
              if (_valid1 && valid24) {
                valid24 = false;
                passing1 = [passing1, 1];
              } else {
                if (_valid1) {
                  valid24 = true;
                  passing1 = 1;
                }
                const _errs112 = errors2;
                if (data40 && typeof data40 == "object" && !Array.isArray(data40)) {
                  if (data40.name === void 0) {
                    const err79 = { instancePath: instancePath + "/slots/after", schemaPath: "#/$defs/slot/oneOf/2/required", keyword: "required", params: { missingProperty: "name" }, message: "must have required property 'name'" };
                    if (vErrors === null) {
                      vErrors = [err79];
                    } else {
                      vErrors.push(err79);
                    }
                    errors2++;
                  }
                  for (const key6 in data40) {
                    if (!(key6 === "name")) {
                      const err80 = { instancePath: instancePath + "/slots/after", schemaPath: "#/$defs/slot/oneOf/2/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key6 }, message: "must NOT have additional properties" };
                      if (vErrors === null) {
                        vErrors = [err80];
                      } else {
                        vErrors.push(err80);
                      }
                      errors2++;
                    }
                  }
                  if (data40.name !== void 0) {
                    if (typeof data40.name !== "string") {
                      const err81 = { instancePath: instancePath + "/slots/after/name", schemaPath: "#/$defs/slot/oneOf/2/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                      if (vErrors === null) {
                        vErrors = [err81];
                      } else {
                        vErrors.push(err81);
                      }
                      errors2++;
                    }
                  }
                } else {
                  const err82 = { instancePath: instancePath + "/slots/after", schemaPath: "#/$defs/slot/oneOf/2/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                  if (vErrors === null) {
                    vErrors = [err82];
                  } else {
                    vErrors.push(err82);
                  }
                  errors2++;
                }
                var _valid1 = _errs112 === errors2;
                if (_valid1 && valid24) {
                  valid24 = false;
                  passing1 = [passing1, 2];
                } else {
                  if (_valid1) {
                    valid24 = true;
                    passing1 = 2;
                  }
                }
              }
              if (!valid24) {
                const err83 = { instancePath: instancePath + "/slots/after", schemaPath: "#/$defs/slot/oneOf", keyword: "oneOf", params: { passingSchemas: passing1 }, message: "must match exactly one schema in oneOf" };
                if (vErrors === null) {
                  vErrors = [err83];
                } else {
                  vErrors.push(err83);
                }
                errors2++;
              } else {
                errors2 = _errs101;
                if (vErrors !== null) {
                  if (_errs101) {
                    vErrors.length = _errs101;
                  } else {
                    vErrors = null;
                  }
                }
              }
            }
            if (data35.component !== void 0) {
              let data44 = data35.component;
              const _errs119 = errors2;
              let valid29 = false;
              let passing2 = null;
              const _errs120 = errors2;
              if (data44 && typeof data44 == "object" && !Array.isArray(data44)) {
                if (data44.text === void 0) {
                  const err84 = { instancePath: instancePath + "/slots/component", schemaPath: "#/$defs/slot/oneOf/0/required", keyword: "required", params: { missingProperty: "text" }, message: "must have required property 'text'" };
                  if (vErrors === null) {
                    vErrors = [err84];
                  } else {
                    vErrors.push(err84);
                  }
                  errors2++;
                }
                for (const key7 in data44) {
                  if (!(key7 === "text")) {
                    const err85 = { instancePath: instancePath + "/slots/component", schemaPath: "#/$defs/slot/oneOf/0/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key7 }, message: "must NOT have additional properties" };
                    if (vErrors === null) {
                      vErrors = [err85];
                    } else {
                      vErrors.push(err85);
                    }
                    errors2++;
                  }
                }
                if (data44.text !== void 0) {
                  if (typeof data44.text !== "string") {
                    const err86 = { instancePath: instancePath + "/slots/component/text", schemaPath: "#/$defs/slot/oneOf/0/properties/text/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                      vErrors = [err86];
                    } else {
                      vErrors.push(err86);
                    }
                    errors2++;
                  }
                }
              } else {
                const err87 = { instancePath: instancePath + "/slots/component", schemaPath: "#/$defs/slot/oneOf/0/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                if (vErrors === null) {
                  vErrors = [err87];
                } else {
                  vErrors.push(err87);
                }
                errors2++;
              }
              var _valid2 = _errs120 === errors2;
              if (_valid2) {
                valid29 = true;
                passing2 = 0;
              }
              const _errs125 = errors2;
              if (data44 && typeof data44 == "object" && !Array.isArray(data44)) {
                if (data44.markdown === void 0) {
                  const err88 = { instancePath: instancePath + "/slots/component", schemaPath: "#/$defs/slot/oneOf/1/required", keyword: "required", params: { missingProperty: "markdown" }, message: "must have required property 'markdown'" };
                  if (vErrors === null) {
                    vErrors = [err88];
                  } else {
                    vErrors.push(err88);
                  }
                  errors2++;
                }
                for (const key8 in data44) {
                  if (!(key8 === "markdown")) {
                    const err89 = { instancePath: instancePath + "/slots/component", schemaPath: "#/$defs/slot/oneOf/1/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key8 }, message: "must NOT have additional properties" };
                    if (vErrors === null) {
                      vErrors = [err89];
                    } else {
                      vErrors.push(err89);
                    }
                    errors2++;
                  }
                }
                if (data44.markdown !== void 0) {
                  if (typeof data44.markdown !== "string") {
                    const err90 = { instancePath: instancePath + "/slots/component/markdown", schemaPath: "#/$defs/slot/oneOf/1/properties/markdown/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                      vErrors = [err90];
                    } else {
                      vErrors.push(err90);
                    }
                    errors2++;
                  }
                }
              } else {
                const err91 = { instancePath: instancePath + "/slots/component", schemaPath: "#/$defs/slot/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                if (vErrors === null) {
                  vErrors = [err91];
                } else {
                  vErrors.push(err91);
                }
                errors2++;
              }
              var _valid2 = _errs125 === errors2;
              if (_valid2 && valid29) {
                valid29 = false;
                passing2 = [passing2, 1];
              } else {
                if (_valid2) {
                  valid29 = true;
                  passing2 = 1;
                }
                const _errs130 = errors2;
                if (data44 && typeof data44 == "object" && !Array.isArray(data44)) {
                  if (data44.name === void 0) {
                    const err92 = { instancePath: instancePath + "/slots/component", schemaPath: "#/$defs/slot/oneOf/2/required", keyword: "required", params: { missingProperty: "name" }, message: "must have required property 'name'" };
                    if (vErrors === null) {
                      vErrors = [err92];
                    } else {
                      vErrors.push(err92);
                    }
                    errors2++;
                  }
                  for (const key9 in data44) {
                    if (!(key9 === "name")) {
                      const err93 = { instancePath: instancePath + "/slots/component", schemaPath: "#/$defs/slot/oneOf/2/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key9 }, message: "must NOT have additional properties" };
                      if (vErrors === null) {
                        vErrors = [err93];
                      } else {
                        vErrors.push(err93);
                      }
                      errors2++;
                    }
                  }
                  if (data44.name !== void 0) {
                    if (typeof data44.name !== "string") {
                      const err94 = { instancePath: instancePath + "/slots/component/name", schemaPath: "#/$defs/slot/oneOf/2/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                      if (vErrors === null) {
                        vErrors = [err94];
                      } else {
                        vErrors.push(err94);
                      }
                      errors2++;
                    }
                  }
                } else {
                  const err95 = { instancePath: instancePath + "/slots/component", schemaPath: "#/$defs/slot/oneOf/2/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                  if (vErrors === null) {
                    vErrors = [err95];
                  } else {
                    vErrors.push(err95);
                  }
                  errors2++;
                }
                var _valid2 = _errs130 === errors2;
                if (_valid2 && valid29) {
                  valid29 = false;
                  passing2 = [passing2, 2];
                } else {
                  if (_valid2) {
                    valid29 = true;
                    passing2 = 2;
                  }
                }
              }
              if (!valid29) {
                const err96 = { instancePath: instancePath + "/slots/component", schemaPath: "#/$defs/slot/oneOf", keyword: "oneOf", params: { passingSchemas: passing2 }, message: "must match exactly one schema in oneOf" };
                if (vErrors === null) {
                  vErrors = [err96];
                } else {
                  vErrors.push(err96);
                }
                errors2++;
              } else {
                errors2 = _errs119;
                if (vErrors !== null) {
                  if (_errs119) {
                    vErrors.length = _errs119;
                  } else {
                    vErrors = null;
                  }
                }
              }
            }
          }
          if (props2 !== true) {
            props2 = props2 || {};
            props2.before = true;
            props2.after = true;
            props2.component = true;
          }
        }
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        const tag0 = data.comp;
        if (typeof tag0 == "string") {
          if (tag0 === "none") {
            if (data && typeof data == "object" && !Array.isArray(data)) {
              if (data.comp === void 0) {
                const err97 = { instancePath, schemaPath: "#/$defs/none/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
                if (vErrors === null) {
                  vErrors = [err97];
                } else {
                  vErrors.push(err97);
                }
                errors2++;
              }
              if (data.comp !== void 0) {
                if ("none" !== data.comp) {
                  const err98 = { instancePath: instancePath + "/comp", schemaPath: "#/$defs/none/properties/comp/const", keyword: "const", params: { allowedValue: "none" }, message: "must be equal to constant" };
                  if (vErrors === null) {
                    vErrors = [err98];
                  } else {
                    vErrors.push(err98);
                  }
                  errors2++;
                }
              }
            } else {
              const err99 = { instancePath, schemaPath: "#/$defs/none/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err99];
              } else {
                vErrors.push(err99);
              }
              errors2++;
            }
            var props6 = {};
            props6.comp = true;
          } else if (tag0 === "list") {
            if (!validate68(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
              vErrors = vErrors === null ? validate68.errors : vErrors.concat(validate68.errors);
              errors2 = vErrors.length;
            }
            if (props6 !== true) {
              props6 = props6 || {};
              props6.comp = true;
              props6.title = true;
              props6.listEditMode = true;
              props6.listActions = true;
              props6.itemTitle = true;
              props6.itemSubtitle = true;
              props6.messages = true;
            }
          } else if (tag0 === "text-field") {
            if (data && typeof data == "object" && !Array.isArray(data)) {
              if (data.comp === void 0) {
                const err100 = { instancePath, schemaPath: "#/$defs/text-field/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
                if (vErrors === null) {
                  vErrors = [err100];
                } else {
                  vErrors.push(err100);
                }
                errors2++;
              }
              if (data.label === void 0) {
                const err101 = { instancePath, schemaPath: "#/$defs/text-field/required", keyword: "required", params: { missingProperty: "label" }, message: "must have required property 'label'" };
                if (vErrors === null) {
                  vErrors = [err101];
                } else {
                  vErrors.push(err101);
                }
                errors2++;
              }
              if (data.comp !== void 0) {
                if ("text-field" !== data.comp) {
                  const err102 = { instancePath: instancePath + "/comp", schemaPath: "#/$defs/text-field/properties/comp/const", keyword: "const", params: { allowedValue: "text-field" }, message: "must be equal to constant" };
                  if (vErrors === null) {
                    vErrors = [err102];
                  } else {
                    vErrors.push(err102);
                  }
                  errors2++;
                }
              }
              if (data.label !== void 0) {
                if (typeof data.label !== "string") {
                  const err103 = { instancePath: instancePath + "/label", schemaPath: "#/$defs/text-field/properties/label/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err103];
                  } else {
                    vErrors.push(err103);
                  }
                  errors2++;
                }
              }
              if (data.autofocus !== void 0) {
                if (typeof data.autofocus !== "boolean") {
                  const err104 = { instancePath: instancePath + "/autofocus", schemaPath: "#/$defs/text-field/properties/autofocus/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                  if (vErrors === null) {
                    vErrors = [err104];
                  } else {
                    vErrors.push(err104);
                  }
                  errors2++;
                }
              }
            } else {
              const err105 = { instancePath, schemaPath: "#/$defs/text-field/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err105];
              } else {
                vErrors.push(err105);
              }
              errors2++;
            }
            if (props6 !== true) {
              props6 = props6 || {};
              props6.comp = true;
              props6.label = true;
              props6.autofocus = true;
            }
          } else if (tag0 === "number-field") {
            if (data && typeof data == "object" && !Array.isArray(data)) {
              if (data.comp === void 0) {
                const err106 = { instancePath, schemaPath: "#/$defs/number-field/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
                if (vErrors === null) {
                  vErrors = [err106];
                } else {
                  vErrors.push(err106);
                }
                errors2++;
              }
              if (data.label === void 0) {
                const err107 = { instancePath, schemaPath: "#/$defs/number-field/required", keyword: "required", params: { missingProperty: "label" }, message: "must have required property 'label'" };
                if (vErrors === null) {
                  vErrors = [err107];
                } else {
                  vErrors.push(err107);
                }
                errors2++;
              }
              if (data.comp !== void 0) {
                if ("number-field" !== data.comp) {
                  const err108 = { instancePath: instancePath + "/comp", schemaPath: "#/$defs/number-field/properties/comp/const", keyword: "const", params: { allowedValue: "number-field" }, message: "must be equal to constant" };
                  if (vErrors === null) {
                    vErrors = [err108];
                  } else {
                    vErrors.push(err108);
                  }
                  errors2++;
                }
              }
              if (data.label !== void 0) {
                if (typeof data.label !== "string") {
                  const err109 = { instancePath: instancePath + "/label", schemaPath: "#/$defs/number-field/properties/label/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err109];
                  } else {
                    vErrors.push(err109);
                  }
                  errors2++;
                }
              }
              if (data.autofocus !== void 0) {
                if (typeof data.autofocus !== "boolean") {
                  const err110 = { instancePath: instancePath + "/autofocus", schemaPath: "#/$defs/number-field/properties/autofocus/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                  if (vErrors === null) {
                    vErrors = [err110];
                  } else {
                    vErrors.push(err110);
                  }
                  errors2++;
                }
              }
              if (data.step !== void 0) {
                let data55 = data.step;
                if (!(typeof data55 == "number" && isFinite(data55))) {
                  const err111 = { instancePath: instancePath + "/step", schemaPath: "#/$defs/number-field/properties/step/type", keyword: "type", params: { type: "number" }, message: "must be number" };
                  if (vErrors === null) {
                    vErrors = [err111];
                  } else {
                    vErrors.push(err111);
                  }
                  errors2++;
                }
              }
              if (data.min !== void 0) {
                let data56 = data.min;
                if (!(typeof data56 == "number" && isFinite(data56))) {
                  const err112 = { instancePath: instancePath + "/min", schemaPath: "#/$defs/number-field/properties/min/type", keyword: "type", params: { type: "number" }, message: "must be number" };
                  if (vErrors === null) {
                    vErrors = [err112];
                  } else {
                    vErrors.push(err112);
                  }
                  errors2++;
                }
              }
              if (data.max !== void 0) {
                let data57 = data.max;
                if (!(typeof data57 == "number" && isFinite(data57))) {
                  const err113 = { instancePath: instancePath + "/max", schemaPath: "#/$defs/number-field/properties/max/type", keyword: "type", params: { type: "number" }, message: "must be number" };
                  if (vErrors === null) {
                    vErrors = [err113];
                  } else {
                    vErrors.push(err113);
                  }
                  errors2++;
                }
              }
            } else {
              const err114 = { instancePath, schemaPath: "#/$defs/number-field/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err114];
              } else {
                vErrors.push(err114);
              }
              errors2++;
            }
            if (props6 !== true) {
              props6 = props6 || {};
              props6.comp = true;
              props6.label = true;
              props6.autofocus = true;
              props6.step = true;
              props6.min = true;
              props6.max = true;
            }
          } else if (tag0 === "textarea") {
            if (data && typeof data == "object" && !Array.isArray(data)) {
              if (data.comp === void 0) {
                const err115 = { instancePath, schemaPath: "#/$defs/textarea/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
                if (vErrors === null) {
                  vErrors = [err115];
                } else {
                  vErrors.push(err115);
                }
                errors2++;
              }
              if (data.label === void 0) {
                const err116 = { instancePath, schemaPath: "#/$defs/textarea/required", keyword: "required", params: { missingProperty: "label" }, message: "must have required property 'label'" };
                if (vErrors === null) {
                  vErrors = [err116];
                } else {
                  vErrors.push(err116);
                }
                errors2++;
              }
              if (data.comp !== void 0) {
                if ("textarea" !== data.comp) {
                  const err117 = { instancePath: instancePath + "/comp", schemaPath: "#/$defs/textarea/properties/comp/const", keyword: "const", params: { allowedValue: "textarea" }, message: "must be equal to constant" };
                  if (vErrors === null) {
                    vErrors = [err117];
                  } else {
                    vErrors.push(err117);
                  }
                  errors2++;
                }
              }
              if (data.label !== void 0) {
                if (typeof data.label !== "string") {
                  const err118 = { instancePath: instancePath + "/label", schemaPath: "#/$defs/textarea/properties/label/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err118];
                  } else {
                    vErrors.push(err118);
                  }
                  errors2++;
                }
              }
              if (data.autofocus !== void 0) {
                if (typeof data.autofocus !== "boolean") {
                  const err119 = { instancePath: instancePath + "/autofocus", schemaPath: "#/$defs/textarea/properties/autofocus/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                  if (vErrors === null) {
                    vErrors = [err119];
                  } else {
                    vErrors.push(err119);
                  }
                  errors2++;
                }
              }
            } else {
              const err120 = { instancePath, schemaPath: "#/$defs/textarea/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err120];
              } else {
                vErrors.push(err120);
              }
              errors2++;
            }
            if (props6 !== true) {
              props6 = props6 || {};
              props6.comp = true;
              props6.label = true;
              props6.autofocus = true;
            }
          } else if (tag0 === "markdown") {
            if (data && typeof data == "object" && !Array.isArray(data)) {
              if (data.comp === void 0) {
                const err121 = { instancePath, schemaPath: "#/$defs/markdown/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
                if (vErrors === null) {
                  vErrors = [err121];
                } else {
                  vErrors.push(err121);
                }
                errors2++;
              }
              if (data.label === void 0) {
                const err122 = { instancePath, schemaPath: "#/$defs/markdown/required", keyword: "required", params: { missingProperty: "label" }, message: "must have required property 'label'" };
                if (vErrors === null) {
                  vErrors = [err122];
                } else {
                  vErrors.push(err122);
                }
                errors2++;
              }
              if (data.comp !== void 0) {
                if ("markdown" !== data.comp) {
                  const err123 = { instancePath: instancePath + "/comp", schemaPath: "#/$defs/markdown/properties/comp/const", keyword: "const", params: { allowedValue: "markdown" }, message: "must be equal to constant" };
                  if (vErrors === null) {
                    vErrors = [err123];
                  } else {
                    vErrors.push(err123);
                  }
                  errors2++;
                }
              }
              if (data.label !== void 0) {
                if (typeof data.label !== "string") {
                  const err124 = { instancePath: instancePath + "/label", schemaPath: "#/$defs/markdown/properties/label/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err124];
                  } else {
                    vErrors.push(err124);
                  }
                  errors2++;
                }
              }
              if (data.autofocus !== void 0) {
                if (typeof data.autofocus !== "boolean") {
                  const err125 = { instancePath: instancePath + "/autofocus", schemaPath: "#/$defs/markdown/properties/autofocus/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                  if (vErrors === null) {
                    vErrors = [err125];
                  } else {
                    vErrors.push(err125);
                  }
                  errors2++;
                }
              }
            } else {
              const err126 = { instancePath, schemaPath: "#/$defs/markdown/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err126];
              } else {
                vErrors.push(err126);
              }
              errors2++;
            }
            if (props6 !== true) {
              props6 = props6 || {};
              props6.comp = true;
              props6.label = true;
              props6.autofocus = true;
            }
          } else if (tag0 === "checkbox") {
            if (data && typeof data == "object" && !Array.isArray(data)) {
              if (data.comp === void 0) {
                const err127 = { instancePath, schemaPath: "#/$defs/checkbox/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
                if (vErrors === null) {
                  vErrors = [err127];
                } else {
                  vErrors.push(err127);
                }
                errors2++;
              }
              if (data.label === void 0) {
                const err128 = { instancePath, schemaPath: "#/$defs/checkbox/required", keyword: "required", params: { missingProperty: "label" }, message: "must have required property 'label'" };
                if (vErrors === null) {
                  vErrors = [err128];
                } else {
                  vErrors.push(err128);
                }
                errors2++;
              }
              if (data.comp !== void 0) {
                if ("checkbox" !== data.comp) {
                  const err129 = { instancePath: instancePath + "/comp", schemaPath: "#/$defs/checkbox/properties/comp/const", keyword: "const", params: { allowedValue: "checkbox" }, message: "must be equal to constant" };
                  if (vErrors === null) {
                    vErrors = [err129];
                  } else {
                    vErrors.push(err129);
                  }
                  errors2++;
                }
              }
              if (data.label !== void 0) {
                if (typeof data.label !== "string") {
                  const err130 = { instancePath: instancePath + "/label", schemaPath: "#/$defs/checkbox/properties/label/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err130];
                  } else {
                    vErrors.push(err130);
                  }
                  errors2++;
                }
              }
            } else {
              const err131 = { instancePath, schemaPath: "#/$defs/checkbox/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err131];
              } else {
                vErrors.push(err131);
              }
              errors2++;
            }
            if (props6 !== true) {
              props6 = props6 || {};
              props6.comp = true;
              props6.label = true;
            }
          } else if (tag0 === "switch") {
            if (data && typeof data == "object" && !Array.isArray(data)) {
              if (data.comp === void 0) {
                const err132 = { instancePath, schemaPath: "#/$defs/switch/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
                if (vErrors === null) {
                  vErrors = [err132];
                } else {
                  vErrors.push(err132);
                }
                errors2++;
              }
              if (data.label === void 0) {
                const err133 = { instancePath, schemaPath: "#/$defs/switch/required", keyword: "required", params: { missingProperty: "label" }, message: "must have required property 'label'" };
                if (vErrors === null) {
                  vErrors = [err133];
                } else {
                  vErrors.push(err133);
                }
                errors2++;
              }
              if (data.comp !== void 0) {
                if ("switch" !== data.comp) {
                  const err134 = { instancePath: instancePath + "/comp", schemaPath: "#/$defs/switch/properties/comp/const", keyword: "const", params: { allowedValue: "switch" }, message: "must be equal to constant" };
                  if (vErrors === null) {
                    vErrors = [err134];
                  } else {
                    vErrors.push(err134);
                  }
                  errors2++;
                }
              }
              if (data.label !== void 0) {
                if (typeof data.label !== "string") {
                  const err135 = { instancePath: instancePath + "/label", schemaPath: "#/$defs/switch/properties/label/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err135];
                  } else {
                    vErrors.push(err135);
                  }
                  errors2++;
                }
              }
            } else {
              const err136 = { instancePath, schemaPath: "#/$defs/switch/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err136];
              } else {
                vErrors.push(err136);
              }
              errors2++;
            }
            if (props6 !== true) {
              props6 = props6 || {};
              props6.comp = true;
              props6.label = true;
            }
          } else if (tag0 === "slider") {
            if (data && typeof data == "object" && !Array.isArray(data)) {
              if (data.comp === void 0) {
                const err137 = { instancePath, schemaPath: "#/$defs/slider/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
                if (vErrors === null) {
                  vErrors = [err137];
                } else {
                  vErrors.push(err137);
                }
                errors2++;
              }
              if (data.label === void 0) {
                const err138 = { instancePath, schemaPath: "#/$defs/slider/required", keyword: "required", params: { missingProperty: "label" }, message: "must have required property 'label'" };
                if (vErrors === null) {
                  vErrors = [err138];
                } else {
                  vErrors.push(err138);
                }
                errors2++;
              }
              if (data.min === void 0) {
                const err139 = { instancePath, schemaPath: "#/$defs/slider/required", keyword: "required", params: { missingProperty: "min" }, message: "must have required property 'min'" };
                if (vErrors === null) {
                  vErrors = [err139];
                } else {
                  vErrors.push(err139);
                }
                errors2++;
              }
              if (data.max === void 0) {
                const err140 = { instancePath, schemaPath: "#/$defs/slider/required", keyword: "required", params: { missingProperty: "max" }, message: "must have required property 'max'" };
                if (vErrors === null) {
                  vErrors = [err140];
                } else {
                  vErrors.push(err140);
                }
                errors2++;
              }
              if (data.comp !== void 0) {
                if ("slider" !== data.comp) {
                  const err141 = { instancePath: instancePath + "/comp", schemaPath: "#/$defs/slider/properties/comp/const", keyword: "const", params: { allowedValue: "slider" }, message: "must be equal to constant" };
                  if (vErrors === null) {
                    vErrors = [err141];
                  } else {
                    vErrors.push(err141);
                  }
                  errors2++;
                }
              }
              if (data.label !== void 0) {
                if (typeof data.label !== "string") {
                  const err142 = { instancePath: instancePath + "/label", schemaPath: "#/$defs/slider/properties/label/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err142];
                  } else {
                    vErrors.push(err142);
                  }
                  errors2++;
                }
              }
              if (data.step !== void 0) {
                let data70 = data.step;
                if (!(typeof data70 == "number" && isFinite(data70))) {
                  const err143 = { instancePath: instancePath + "/step", schemaPath: "#/$defs/slider/properties/step/type", keyword: "type", params: { type: "number" }, message: "must be number" };
                  if (vErrors === null) {
                    vErrors = [err143];
                  } else {
                    vErrors.push(err143);
                  }
                  errors2++;
                }
              }
              if (data.min !== void 0) {
                let data71 = data.min;
                if (!(typeof data71 == "number" && isFinite(data71))) {
                  const err144 = { instancePath: instancePath + "/min", schemaPath: "#/$defs/slider/properties/min/type", keyword: "type", params: { type: "number" }, message: "must be number" };
                  if (vErrors === null) {
                    vErrors = [err144];
                  } else {
                    vErrors.push(err144);
                  }
                  errors2++;
                }
              }
              if (data.max !== void 0) {
                let data72 = data.max;
                if (!(typeof data72 == "number" && isFinite(data72))) {
                  const err145 = { instancePath: instancePath + "/max", schemaPath: "#/$defs/slider/properties/max/type", keyword: "type", params: { type: "number" }, message: "must be number" };
                  if (vErrors === null) {
                    vErrors = [err145];
                  } else {
                    vErrors.push(err145);
                  }
                  errors2++;
                }
              }
            } else {
              const err146 = { instancePath, schemaPath: "#/$defs/slider/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err146];
              } else {
                vErrors.push(err146);
              }
              errors2++;
            }
            if (props6 !== true) {
              props6 = props6 || {};
              props6.comp = true;
              props6.label = true;
              props6.step = true;
              props6.min = true;
              props6.max = true;
            }
          } else if (tag0 === "date-picker") {
            if (data && typeof data == "object" && !Array.isArray(data)) {
              if (data.comp === void 0) {
                const err147 = { instancePath, schemaPath: "#/$defs/date-picker/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
                if (vErrors === null) {
                  vErrors = [err147];
                } else {
                  vErrors.push(err147);
                }
                errors2++;
              }
              if (data.label === void 0) {
                const err148 = { instancePath, schemaPath: "#/$defs/date-picker/required", keyword: "required", params: { missingProperty: "label" }, message: "must have required property 'label'" };
                if (vErrors === null) {
                  vErrors = [err148];
                } else {
                  vErrors.push(err148);
                }
                errors2++;
              }
              if (data.comp !== void 0) {
                if ("date-picker" !== data.comp) {
                  const err149 = { instancePath: instancePath + "/comp", schemaPath: "#/$defs/date-picker/properties/comp/const", keyword: "const", params: { allowedValue: "date-picker" }, message: "must be equal to constant" };
                  if (vErrors === null) {
                    vErrors = [err149];
                  } else {
                    vErrors.push(err149);
                  }
                  errors2++;
                }
              }
              if (data.label !== void 0) {
                if (typeof data.label !== "string") {
                  const err150 = { instancePath: instancePath + "/label", schemaPath: "#/$defs/date-picker/properties/label/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err150];
                  } else {
                    vErrors.push(err150);
                  }
                  errors2++;
                }
              }
              if (data.min !== void 0) {
                let data75 = data.min;
                if (typeof data75 === "string") {
                  if (!formats0.validate(data75)) {
                    const err151 = { instancePath: instancePath + "/min", schemaPath: "#/$defs/date-picker/properties/min/format", keyword: "format", params: { format: "date" }, message: 'must match format "date"' };
                    if (vErrors === null) {
                      vErrors = [err151];
                    } else {
                      vErrors.push(err151);
                    }
                    errors2++;
                  }
                } else {
                  const err152 = { instancePath: instancePath + "/min", schemaPath: "#/$defs/date-picker/properties/min/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err152];
                  } else {
                    vErrors.push(err152);
                  }
                  errors2++;
                }
              }
              if (data.max !== void 0) {
                let data76 = data.max;
                if (typeof data76 === "string") {
                  if (!formats0.validate(data76)) {
                    const err153 = { instancePath: instancePath + "/max", schemaPath: "#/$defs/date-picker/properties/max/format", keyword: "format", params: { format: "date" }, message: 'must match format "date"' };
                    if (vErrors === null) {
                      vErrors = [err153];
                    } else {
                      vErrors.push(err153);
                    }
                    errors2++;
                  }
                } else {
                  const err154 = { instancePath: instancePath + "/max", schemaPath: "#/$defs/date-picker/properties/max/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err154];
                  } else {
                    vErrors.push(err154);
                  }
                  errors2++;
                }
              }
              if (data.format !== void 0) {
                let data77 = data.format;
                if (typeof data77 !== "string") {
                  const err155 = { instancePath: instancePath + "/format", schemaPath: "#/$defs/date-picker/properties/format/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err155];
                  } else {
                    vErrors.push(err155);
                  }
                  errors2++;
                }
                if (!(data77 === "date" || data77 === "date-time")) {
                  const err156 = { instancePath: instancePath + "/format", schemaPath: "#/$defs/date-picker/properties/format/enum", keyword: "enum", params: { allowedValues: schema112.properties.format.enum }, message: "must be equal to one of the allowed values" };
                  if (vErrors === null) {
                    vErrors = [err156];
                  } else {
                    vErrors.push(err156);
                  }
                  errors2++;
                }
              }
            } else {
              const err157 = { instancePath, schemaPath: "#/$defs/date-picker/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err157];
              } else {
                vErrors.push(err157);
              }
              errors2++;
            }
            if (props6 !== true) {
              props6 = props6 || {};
              props6.comp = true;
              props6.label = true;
              props6.min = true;
              props6.max = true;
              props6.format = true;
            }
          } else if (tag0 === "date-time-picker") {
            if (data && typeof data == "object" && !Array.isArray(data)) {
              if (data.comp === void 0) {
                const err158 = { instancePath, schemaPath: "#/$defs/date-time-picker/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
                if (vErrors === null) {
                  vErrors = [err158];
                } else {
                  vErrors.push(err158);
                }
                errors2++;
              }
              if (data.label === void 0) {
                const err159 = { instancePath, schemaPath: "#/$defs/date-time-picker/required", keyword: "required", params: { missingProperty: "label" }, message: "must have required property 'label'" };
                if (vErrors === null) {
                  vErrors = [err159];
                } else {
                  vErrors.push(err159);
                }
                errors2++;
              }
              if (data.comp !== void 0) {
                if ("date-time-picker" !== data.comp) {
                  const err160 = { instancePath: instancePath + "/comp", schemaPath: "#/$defs/date-time-picker/properties/comp/const", keyword: "const", params: { allowedValue: "date-time-picker" }, message: "must be equal to constant" };
                  if (vErrors === null) {
                    vErrors = [err160];
                  } else {
                    vErrors.push(err160);
                  }
                  errors2++;
                }
              }
              if (data.label !== void 0) {
                if (typeof data.label !== "string") {
                  const err161 = { instancePath: instancePath + "/label", schemaPath: "#/$defs/date-time-picker/properties/label/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err161];
                  } else {
                    vErrors.push(err161);
                  }
                  errors2++;
                }
              }
              if (data.min !== void 0) {
                let data80 = data.min;
                if (typeof data80 === "string") {
                  if (!formats4.validate(data80)) {
                    const err162 = { instancePath: instancePath + "/min", schemaPath: "#/$defs/date-time-picker/properties/min/format", keyword: "format", params: { format: "date-time" }, message: 'must match format "date-time"' };
                    if (vErrors === null) {
                      vErrors = [err162];
                    } else {
                      vErrors.push(err162);
                    }
                    errors2++;
                  }
                } else {
                  const err163 = { instancePath: instancePath + "/min", schemaPath: "#/$defs/date-time-picker/properties/min/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err163];
                  } else {
                    vErrors.push(err163);
                  }
                  errors2++;
                }
              }
              if (data.max !== void 0) {
                let data81 = data.max;
                if (typeof data81 === "string") {
                  if (!formats4.validate(data81)) {
                    const err164 = { instancePath: instancePath + "/max", schemaPath: "#/$defs/date-time-picker/properties/max/format", keyword: "format", params: { format: "date-time" }, message: 'must match format "date-time"' };
                    if (vErrors === null) {
                      vErrors = [err164];
                    } else {
                      vErrors.push(err164);
                    }
                    errors2++;
                  }
                } else {
                  const err165 = { instancePath: instancePath + "/max", schemaPath: "#/$defs/date-time-picker/properties/max/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err165];
                  } else {
                    vErrors.push(err165);
                  }
                  errors2++;
                }
              }
            } else {
              const err166 = { instancePath, schemaPath: "#/$defs/date-time-picker/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err166];
              } else {
                vErrors.push(err166);
              }
              errors2++;
            }
            if (props6 !== true) {
              props6 = props6 || {};
              props6.comp = true;
              props6.label = true;
              props6.min = true;
              props6.max = true;
            }
          } else if (tag0 === "time-picker") {
            if (data && typeof data == "object" && !Array.isArray(data)) {
              if (data.comp === void 0) {
                const err167 = { instancePath, schemaPath: "#/$defs/time-picker/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
                if (vErrors === null) {
                  vErrors = [err167];
                } else {
                  vErrors.push(err167);
                }
                errors2++;
              }
              if (data.label === void 0) {
                const err168 = { instancePath, schemaPath: "#/$defs/time-picker/required", keyword: "required", params: { missingProperty: "label" }, message: "must have required property 'label'" };
                if (vErrors === null) {
                  vErrors = [err168];
                } else {
                  vErrors.push(err168);
                }
                errors2++;
              }
              if (data.comp !== void 0) {
                if ("time-picker" !== data.comp) {
                  const err169 = { instancePath: instancePath + "/comp", schemaPath: "#/$defs/time-picker/properties/comp/const", keyword: "const", params: { allowedValue: "time-picker" }, message: "must be equal to constant" };
                  if (vErrors === null) {
                    vErrors = [err169];
                  } else {
                    vErrors.push(err169);
                  }
                  errors2++;
                }
              }
              if (data.label !== void 0) {
                if (typeof data.label !== "string") {
                  const err170 = { instancePath: instancePath + "/label", schemaPath: "#/$defs/time-picker/properties/label/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err170];
                  } else {
                    vErrors.push(err170);
                  }
                  errors2++;
                }
              }
              if (data.min !== void 0) {
                let data84 = data.min;
                if (typeof data84 === "string") {
                  if (!formats8.validate(data84)) {
                    const err171 = { instancePath: instancePath + "/min", schemaPath: "#/$defs/time-picker/properties/min/format", keyword: "format", params: { format: "time" }, message: 'must match format "time"' };
                    if (vErrors === null) {
                      vErrors = [err171];
                    } else {
                      vErrors.push(err171);
                    }
                    errors2++;
                  }
                } else {
                  const err172 = { instancePath: instancePath + "/min", schemaPath: "#/$defs/time-picker/properties/min/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err172];
                  } else {
                    vErrors.push(err172);
                  }
                  errors2++;
                }
              }
              if (data.max !== void 0) {
                let data85 = data.max;
                if (typeof data85 === "string") {
                  if (!formats8.validate(data85)) {
                    const err173 = { instancePath: instancePath + "/max", schemaPath: "#/$defs/time-picker/properties/max/format", keyword: "format", params: { format: "time" }, message: 'must match format "time"' };
                    if (vErrors === null) {
                      vErrors = [err173];
                    } else {
                      vErrors.push(err173);
                    }
                    errors2++;
                  }
                } else {
                  const err174 = { instancePath: instancePath + "/max", schemaPath: "#/$defs/time-picker/properties/max/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err174];
                  } else {
                    vErrors.push(err174);
                  }
                  errors2++;
                }
              }
            } else {
              const err175 = { instancePath, schemaPath: "#/$defs/time-picker/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err175];
              } else {
                vErrors.push(err175);
              }
              errors2++;
            }
            if (props6 !== true) {
              props6 = props6 || {};
              props6.comp = true;
              props6.label = true;
              props6.min = true;
              props6.max = true;
            }
          } else if (tag0 === "color-picker") {
            if (data && typeof data == "object" && !Array.isArray(data)) {
              if (data.comp === void 0) {
                const err176 = { instancePath, schemaPath: "#/$defs/color-picker/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
                if (vErrors === null) {
                  vErrors = [err176];
                } else {
                  vErrors.push(err176);
                }
                errors2++;
              }
              if (data.label === void 0) {
                const err177 = { instancePath, schemaPath: "#/$defs/color-picker/required", keyword: "required", params: { missingProperty: "label" }, message: "must have required property 'label'" };
                if (vErrors === null) {
                  vErrors = [err177];
                } else {
                  vErrors.push(err177);
                }
                errors2++;
              }
              if (data.comp !== void 0) {
                if ("color-picker" !== data.comp) {
                  const err178 = { instancePath: instancePath + "/comp", schemaPath: "#/$defs/color-picker/properties/comp/const", keyword: "const", params: { allowedValue: "color-picker" }, message: "must be equal to constant" };
                  if (vErrors === null) {
                    vErrors = [err178];
                  } else {
                    vErrors.push(err178);
                  }
                  errors2++;
                }
              }
              if (data.label !== void 0) {
                if (typeof data.label !== "string") {
                  const err179 = { instancePath: instancePath + "/label", schemaPath: "#/$defs/color-picker/properties/label/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err179];
                  } else {
                    vErrors.push(err179);
                  }
                  errors2++;
                }
              }
            } else {
              const err180 = { instancePath, schemaPath: "#/$defs/color-picker/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err180];
              } else {
                vErrors.push(err180);
              }
              errors2++;
            }
            if (props6 !== true) {
              props6 = props6 || {};
              props6.comp = true;
              props6.label = true;
            }
          } else if (tag0 === "combobox") {
            if (!validate69(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
              vErrors = vErrors === null ? validate69.errors : vErrors.concat(validate69.errors);
              errors2 = vErrors.length;
            }
            if (props6 !== true) {
              props6 = props6 || {};
              props6.comp = true;
              props6.label = true;
              props6.autofocus = true;
              props6.items = true;
              props6.getItems = true;
              props6.multiple = true;
            }
          } else if (tag0 === "number-combobox") {
            if (!validate76(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
              vErrors = vErrors === null ? validate76.errors : vErrors.concat(validate76.errors);
              errors2 = vErrors.length;
            }
            if (props6 !== true) {
              props6 = props6 || {};
              props6.comp = true;
              props6.label = true;
              props6.autofocus = true;
              props6.items = true;
              props6.getItems = true;
              props6.multiple = true;
              props6.step = true;
              props6.min = true;
              props6.max = true;
            }
          } else if (tag0 === "select") {
            if (!validate79(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
              vErrors = vErrors === null ? validate79.errors : vErrors.concat(validate79.errors);
              errors2 = vErrors.length;
            }
            if (props6 !== true) {
              props6 = props6 || {};
              props6.comp = true;
              props6.label = true;
              props6.autofocus = true;
              props6.items = true;
              props6.getItems = true;
              props6.multiple = true;
            }
          } else if (tag0 === "autocomplete") {
            if (!validate82(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
              vErrors = vErrors === null ? validate82.errors : vErrors.concat(validate82.errors);
              errors2 = vErrors.length;
            }
            if (props6 !== true) {
              props6 = props6 || {};
              props6.comp = true;
              props6.label = true;
              props6.autofocus = true;
              props6.items = true;
              props6.getItems = true;
              props6.multiple = true;
            }
          } else if (tag0 === "one-of-select") {
            if (data && typeof data == "object" && !Array.isArray(data)) {
              if (data.comp === void 0) {
                const err181 = { instancePath, schemaPath: "#/$defs/one-of-select/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
                if (vErrors === null) {
                  vErrors = [err181];
                } else {
                  vErrors.push(err181);
                }
                errors2++;
              }
              if (data.label === void 0) {
                const err182 = { instancePath, schemaPath: "#/$defs/one-of-select/required", keyword: "required", params: { missingProperty: "label" }, message: "must have required property 'label'" };
                if (vErrors === null) {
                  vErrors = [err182];
                } else {
                  vErrors.push(err182);
                }
                errors2++;
              }
              if (data.comp !== void 0) {
                if ("one-of-select" !== data.comp) {
                  const err183 = { instancePath: instancePath + "/comp", schemaPath: "#/$defs/one-of-select/properties/comp/const", keyword: "const", params: { allowedValue: "one-of-select" }, message: "must be equal to constant" };
                  if (vErrors === null) {
                    vErrors = [err183];
                  } else {
                    vErrors.push(err183);
                  }
                  errors2++;
                }
              }
              if (data.label !== void 0) {
                if (typeof data.label !== "string") {
                  const err184 = { instancePath: instancePath + "/label", schemaPath: "#/$defs/one-of-select/properties/label/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err184];
                  } else {
                    vErrors.push(err184);
                  }
                  errors2++;
                }
              }
            } else {
              const err185 = { instancePath, schemaPath: "#/$defs/one-of-select/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err185];
              } else {
                vErrors.push(err185);
              }
              errors2++;
            }
            if (props6 !== true) {
              props6 = props6 || {};
              props6.comp = true;
              props6.label = true;
            }
          } else if (tag0 === "section") {
            if (!validate85(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
              vErrors = vErrors === null ? validate85.errors : vErrors.concat(validate85.errors);
              errors2 = vErrors.length;
            }
            if (props6 !== true) {
              props6 = props6 || {};
              props6.comp = true;
              props6.title = true;
              props6.subtitle = true;
              props6.children = true;
            }
          } else if (tag0 === "tabs") {
            if (!validate89(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
              vErrors = vErrors === null ? validate89.errors : vErrors.concat(validate89.errors);
              errors2 = vErrors.length;
            }
            if (props6 !== true) {
              props6 = props6 || {};
              props6.comp = true;
              props6.title = true;
              props6.subtitle = true;
              props6.children = true;
            }
          } else if (tag0 === "vertical-tabs") {
            if (!validate90(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
              vErrors = vErrors === null ? validate90.errors : vErrors.concat(validate90.errors);
              errors2 = vErrors.length;
            }
            if (props6 !== true) {
              props6 = props6 || {};
              props6.comp = true;
              props6.title = true;
              props6.subtitle = true;
              props6.children = true;
            }
          } else if (tag0 === "expansion-panels") {
            if (!validate91(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
              vErrors = vErrors === null ? validate91.errors : vErrors.concat(validate91.errors);
              errors2 = vErrors.length;
            }
            if (props6 !== true) {
              props6 = props6 || {};
              props6.comp = true;
              props6.title = true;
              props6.subtitle = true;
              props6.children = true;
            }
          } else if (tag0 === "stepper") {
            if (!validate99(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
              vErrors = vErrors === null ? validate99.errors : vErrors.concat(validate99.errors);
              errors2 = vErrors.length;
            }
            if (props6 !== true) {
              props6 = props6 || {};
              props6.comp = true;
              props6.title = true;
              props6.subtitle = true;
              props6.children = true;
            }
          } else if (tag0 === "file-input") {
            if (data && typeof data == "object" && !Array.isArray(data)) {
              if (data.comp === void 0) {
                const err186 = { instancePath, schemaPath: "#/$defs/file-input/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
                if (vErrors === null) {
                  vErrors = [err186];
                } else {
                  vErrors.push(err186);
                }
                errors2++;
              }
              if (data.label === void 0) {
                const err187 = { instancePath, schemaPath: "#/$defs/file-input/required", keyword: "required", params: { missingProperty: "label" }, message: "must have required property 'label'" };
                if (vErrors === null) {
                  vErrors = [err187];
                } else {
                  vErrors.push(err187);
                }
                errors2++;
              }
              if (data.comp !== void 0) {
                if ("file-input" !== data.comp) {
                  const err188 = { instancePath: instancePath + "/comp", schemaPath: "#/$defs/file-input/properties/comp/const", keyword: "const", params: { allowedValue: "file-input" }, message: "must be equal to constant" };
                  if (vErrors === null) {
                    vErrors = [err188];
                  } else {
                    vErrors.push(err188);
                  }
                  errors2++;
                }
              }
              if (data.label !== void 0) {
                if (typeof data.label !== "string") {
                  const err189 = { instancePath: instancePath + "/label", schemaPath: "#/$defs/file-input/properties/label/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err189];
                  } else {
                    vErrors.push(err189);
                  }
                  errors2++;
                }
              }
              if (data.accept !== void 0) {
                if (typeof data.accept !== "string") {
                  const err190 = { instancePath: instancePath + "/accept", schemaPath: "#/$defs/file-input/properties/accept/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err190];
                  } else {
                    vErrors.push(err190);
                  }
                  errors2++;
                }
              }
              if (data.multiple !== void 0) {
                if (typeof data.multiple !== "boolean") {
                  const err191 = { instancePath: instancePath + "/multiple", schemaPath: "#/$defs/file-input/properties/multiple/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                  if (vErrors === null) {
                    vErrors = [err191];
                  } else {
                    vErrors.push(err191);
                  }
                  errors2++;
                }
              }
            } else {
              const err192 = { instancePath, schemaPath: "#/$defs/file-input/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err192];
              } else {
                vErrors.push(err192);
              }
              errors2++;
            }
            if (props6 !== true) {
              props6 = props6 || {};
              props6.comp = true;
              props6.label = true;
              props6.accept = true;
              props6.multiple = true;
            }
          } else {
            const err193 = { instancePath, schemaPath: "#/allOf/1/discriminator", keyword: "discriminator", params: { error: "mapping", tag: "comp", tagValue: tag0 }, message: 'value of tag "comp" must be in oneOf' };
            if (vErrors === null) {
              vErrors = [err193];
            } else {
              vErrors.push(err193);
            }
            errors2++;
          }
        } else {
          const err194 = { instancePath, schemaPath: "#/allOf/1/discriminator", keyword: "discriminator", params: { error: "tag", tag: "comp", tagValue: tag0 }, message: 'tag "comp" must be string' };
          if (vErrors === null) {
            vErrors = [err194];
          } else {
            vErrors.push(err194);
          }
          errors2++;
        }
      }
      if (props6 !== true) {
        props6 = props6 || {};
        props6.if = true;
        props6.options = true;
        props6.getOptions = true;
        props6.defaultData = true;
        props6.getDefaultData = true;
        props6.constData = true;
        props6.getConstData = true;
        props6.transformData = true;
        props6.nullable = true;
        props6.help = true;
        props6.cols = true;
        props6.props = true;
        props6.getProps = true;
        props6.slots = true;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.comp === void 0) {
          const err195 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "comp" }, message: "must have required property 'comp'" };
          if (vErrors === null) {
            vErrors = [err195];
          } else {
            vErrors.push(err195);
          }
          errors2++;
        }
        if (props6 !== true) {
          for (const key10 in data) {
            if (!props6 || !props6[key10]) {
              const err196 = { instancePath, schemaPath: "#/unevaluatedProperties", keyword: "unevaluatedProperties", params: { unevaluatedProperty: key10 }, message: "must NOT have unevaluated properties" };
              if (vErrors === null) {
                vErrors = [err196];
              } else {
                vErrors.push(err196);
              }
              errors2++;
            }
          }
        }
      } else {
        const err197 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err197];
        } else {
          vErrors.push(err197);
        }
        errors2++;
      }
      validate61.errors = vErrors;
      return errors2 === 0;
    }
    validate61.evaluated = { "props": true, "dynamicProps": false, "dynamicItems": false };
    function validate60(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate60.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.switch === void 0) {
          const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "switch" }, message: "must have required property 'switch'" };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors2++;
        }
        for (const key0 in data) {
          if (!(key0 === "switch")) {
            const err1 = { instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" };
            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }
            errors2++;
          }
        }
        if (data.switch !== void 0) {
          let data0 = data.switch;
          if (Array.isArray(data0)) {
            const len0 = data0.length;
            for (let i0 = 0; i0 < len0; i0++) {
              if (!validate61(data0[i0], { instancePath: instancePath + "/switch/" + i0, parentData: data0, parentDataProperty: i0, rootData, dynamicAnchors })) {
                vErrors = vErrors === null ? validate61.errors : vErrors.concat(validate61.errors);
                errors2 = vErrors.length;
              }
            }
          } else {
            const err2 = { instancePath: instancePath + "/switch", schemaPath: "#/properties/switch/type", keyword: "type", params: { type: "array" }, message: "must be array" };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors2++;
          }
        }
      } else {
        const err3 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err3];
        } else {
          vErrors.push(err3);
        }
        errors2++;
      }
      validate60.errors = vErrors;
      return errors2 === 0;
    }
    validate60.evaluated = { "props": true, "dynamicProps": false, "dynamicItems": false };
    function validate59(data, { instancePath = "", parentData, parentDataProperty, rootData = data, dynamicAnchors = {} } = {}) {
      let vErrors = null;
      let errors2 = 0;
      const evaluated0 = validate59.evaluated;
      if (evaluated0.dynamicProps) {
        evaluated0.props = void 0;
      }
      if (evaluated0.dynamicItems) {
        evaluated0.items = void 0;
      }
      const _errs0 = errors2;
      let valid0 = false;
      let passing0 = null;
      const _errs1 = errors2;
      if (!validate60(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
        vErrors = vErrors === null ? validate60.errors : vErrors.concat(validate60.errors);
        errors2 = vErrors.length;
      }
      var _valid0 = _errs1 === errors2;
      if (_valid0) {
        valid0 = true;
        passing0 = 0;
        var props0 = true;
      }
      const _errs2 = errors2;
      if (!validate61(data, { instancePath, parentData, parentDataProperty, rootData, dynamicAnchors })) {
        vErrors = vErrors === null ? validate61.errors : vErrors.concat(validate61.errors);
        errors2 = vErrors.length;
      }
      var _valid0 = _errs2 === errors2;
      if (_valid0 && valid0) {
        valid0 = false;
        passing0 = [passing0, 1];
      } else {
        if (_valid0) {
          valid0 = true;
          passing0 = 1;
          if (props0 !== true) {
            props0 = true;
          }
        }
      }
      if (!valid0) {
        const err0 = { instancePath, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors2++;
      } else {
        errors2 = _errs0;
        if (vErrors !== null) {
          if (_errs0) {
            vErrors.length = _errs0;
          } else {
            vErrors = null;
          }
        }
      }
      validate59.errors = vErrors;
      evaluated0.props = props0;
      return errors2 === 0;
    }
    validate59.evaluated = { "dynamicProps": true, "dynamicItems": false };
    const validateNormalizedLayout = (
      /** @type {any} */
      validate59
    );
    function isSwitchStruct(layout) {
      return typeof layout === "object" && "switch" in layout;
    }
    function childIsCompObject(child) {
      return !!child.comp;
    }
    const compositeCompNames = ["section", "tabs", "vertical-tabs", "expansion-panels", "stepper"];
    function isCompositeLayout(layout) {
      return compositeCompNames.includes(layout.comp);
    }
    function isFileLayout(layout) {
      return layout.comp === "file-input";
    }
    function isFocusableLayout(layout) {
      return ["text-field", "number-field", "textarea", "select", "combobox", "number-combobox", "autocomplete", "markdown"].includes(layout.comp);
    }
    function isItemsLayout(layout) {
      return layout.comp === "select" || layout.comp === "combobox" || layout.comp === "autocomplete";
    }
    function isGetItemsExpression(getItems) {
      return !!getItems.expr;
    }
    function isGetItemsFetch(getItems) {
      return !!getItems.url;
    }
    function isTextSlot(slot) {
      return !!slot.text;
    }
    function isMarkdownSlot(slot) {
      return !!slot.markdown;
    }
    function isNameSlot(slot) {
      return !!slot.name;
    }
    function getDefaultChildren(schemaFragment) {
      var _a2;
      const { type: type2 } = getType(schemaFragment);
      const children = [];
      if (type2 === "object") {
        if (schemaFragment.properties) {
          for (const key of Object.keys(schemaFragment.properties)) {
            children.push({ key });
          }
        }
        if ((_a2 = schemaFragment.allOf) == null ? void 0 : _a2.length) {
          for (let i2 = 0; i2 < schemaFragment.allOf.length; i2++) {
            children.push({ key: `$allOf-${i2}` });
          }
        }
        if (schemaFragment.oneOf) {
          children.push({ key: "$oneOf" });
        }
      }
      if (type2 === "array" && Array.isArray(schemaFragment.items)) {
        for (let i2 = 0; i2 < schemaFragment.items.length; i2++) {
          children.push({ key: i2 });
        }
      }
      return children;
    }
    function getChildren(defaultChildren, partialChildren) {
      if (!partialChildren)
        return defaultChildren;
      let compI = 0;
      return partialChildren.map((partialChild) => {
        if (typeof partialChild === "string") {
          const matchingDefaultChild = defaultChildren.find((c) => c.key === partialChild);
          if (!matchingDefaultChild)
            throw new Error(`child unknown ${partialChild}`);
          return matchingDefaultChild;
        } else {
          if (typeof partialChild.cols === "number")
            partialChild.cols = { sm: partialChild.cols };
          if (typeof partialChild.cols === "object" && partialChild.cols.xs === void 0)
            partialChild.cols.xs = 12;
          if (partialChild.key) {
            const matchingDefaultChild = defaultChildren.find((c) => c.key === partialChild.key);
            if (!matchingDefaultChild)
              throw new Error(`child unknown ${partialChild.key}`);
            return (
              /** @type {Child} */
              partialChild
            );
          } else {
            const child = partialChild;
            if (partialChild.children) {
              if (!partialChild.comp)
                child.comp = "section";
              child.children = getChildren(defaultChildren, partialChild.children);
            }
            if (!("key" in partialChild)) {
              child.key = `$comp-${compI}`;
              compI++;
            }
            return (
              /** @type {Child} */
              child
            );
          }
        }
      });
    }
    function getDefaultComp(partial, schemaFragment, arrayChild) {
      const { type: type2 } = getType(schemaFragment);
      const hasSimpleType = ["string", "integer", "number"].includes(type2);
      if (arrayChild === "oneOf")
        return "one-of-select";
      if (hasSimpleType && schemaFragment.enum)
        return schemaFragment.enum.length > 20 ? "autocomplete" : "select";
      if (hasSimpleType && schemaFragment.oneOf)
        return schemaFragment.oneOf.length > 20 ? "autocomplete" : "select";
      if (hasSimpleType && schemaFragment.examples)
        return type2 === "string" ? "combobox" : "number-combobox";
      if (hasSimpleType && schemaFragment.anyOf && schemaFragment.anyOf.length && Object.keys(schemaFragment.anyOf[schemaFragment.anyOf.length - 1]).length === 0) {
        return type2 === "string" ? "combobox" : "number-combobox";
      }
      if (partial.items)
        return partial.items.length > 20 ? "autocomplete" : "select";
      if (partial.getItems) {
        if (isPartialGetItemsFetch(partial.getItems)) {
          if (partial.getItems.qSearchParam)
            return "autocomplete";
          if (typeof partial.getItems.url === "string" && partial.getItems.url.includes("{q}"))
            return "autocomplete";
        }
        return "select";
      }
      if (type2 === "array" && schemaFragment.items) {
        const hasSimpleTypeItems = ["string", "integer", "number"].includes(schemaFragment.items.type);
        if (hasSimpleTypeItems && (schemaFragment.items.enum || schemaFragment.items.oneOf)) {
          return (schemaFragment.items.enum || schemaFragment.items.oneOf).length > 20 ? "autocomplete" : "select";
        }
        if (hasSimpleTypeItems && schemaFragment.items.examples) {
          return schemaFragment.items.type === "string" ? "combobox" : "number-combobox";
        }
        if (hasSimpleTypeItems && schemaFragment.items.anyOf && schemaFragment.items.anyOf.length && Object.keys(schemaFragment.items.anyOf[schemaFragment.items.anyOf.length - 1]).length === 0) {
          return schemaFragment.items.type === "string" ? "combobox" : "number-combobox";
        }
        if (hasSimpleTypeItems && !schemaFragment.items.layout && !["date", "date-time", "time"].includes(schemaFragment.items.format)) {
          return schemaFragment.items.type === "string" ? "combobox" : "number-combobox";
        }
      }
      if (type2 === "object")
        return "section";
      if (type2 === "array") {
        if (Array.isArray(schemaFragment.items))
          return "section";
        else
          return "list";
      }
      if (type2 === "string") {
        if (schemaFragment.format === "date")
          return "date-picker";
        if (schemaFragment.format === "date-time")
          return "date-time-picker";
        if (schemaFragment.format === "time")
          return "time-picker";
        return "text-field";
      }
      if (type2 === "integer" || type2 === "number")
        return "number-field";
      if (type2 === "boolean")
        return "checkbox";
      throw new Error("failed to calculate default component for schema fragment");
    }
    function getPartialCompObject(layoutKeyword) {
      if (isPartialCompObject(layoutKeyword))
        return { ...layoutKeyword };
      else if (isComponentName(layoutKeyword))
        return { comp: layoutKeyword };
      else if (isPartialChildren(layoutKeyword))
        return { children: layoutKeyword };
      return {};
    }
    function normalizeExpression(expression, defaultType = "js-eval") {
      if (typeof expression === "string")
        return { type: defaultType, expr: expression, pure: true };
      else
        return { pure: true, type: defaultType, ...expression };
    }
    function getItemsFromSchema(schemaFragment) {
      if (!schemaFragment)
        return null;
      const { type: type2 } = getType(schemaFragment);
      const hasSimpleType = ["string", "integer", "number"].includes(type2);
      if (schemaFragment.enum && hasSimpleType) {
        return schemaFragment.enum.map((value) => ({ key: value + "", title: value + "", value }));
      }
      if (schemaFragment.examples && hasSimpleType) {
        return schemaFragment.examples.map((value) => ({ key: value + "", title: value + "", value }));
      }
      if (schemaFragment.anyOf && hasSimpleType && schemaFragment.anyOf.length && Object.keys(schemaFragment.anyOf[schemaFragment.anyOf.length - 1]).length === 0) {
        const nonEmptyAnyOf = schemaFragment.anyOf.slice(0, -1);
        if (!nonEmptyAnyOf.find((oneOfItem) => !("const" in oneOfItem))) {
          return nonEmptyAnyOf.map((anyOfItem) => ({
            ...anyOfItem,
            key: anyOfItem.const + "",
            title: (anyOfItem.title ?? anyOfItem.const) + "",
            value: anyOfItem.const
          }));
        }
      }
      if (schemaFragment.oneOf && hasSimpleType && !schemaFragment.oneOf.find((oneOfItem) => !("const" in oneOfItem))) {
        return schemaFragment.oneOf.map((oneOfItem) => ({
          ...oneOfItem,
          key: oneOfItem.const + "",
          title: (oneOfItem.title ?? oneOfItem.const) + "",
          value: oneOfItem.const
        }));
      }
      return null;
    }
    const getType = (schemaFragment) => {
      if (Array.isArray(schemaFragment.type) && schemaFragment.type.length === 2 && schemaFragment.type.includes("null")) {
        const type2 = schemaFragment.type.find((t) => t !== "null");
        return { type: type2, nullable: true };
      }
      return { type: schemaFragment.type, nullable: false };
    };
    function getCompObject$1(layoutKeyword, schemaFragment, schemaPath, markdown, arrayChild) {
      const errors2 = [];
      const key = schemaPath.slice(schemaPath.lastIndexOf("/") + 1);
      const { type: type2, nullable } = getType(schemaFragment);
      if ("const" in schemaFragment)
        return { normalized: { comp: "none" }, errors: errors2 };
      if (!type2)
        return { normalized: { comp: "none" }, errors: errors2 };
      const partial = getPartialCompObject(layoutKeyword);
      if (type2 === "array" && !schemaFragment.items && partial.comp !== "file-input") {
        return { normalized: { comp: "none" }, errors: errors2 };
      }
      if (!partial.comp) {
        try {
          partial.comp = getDefaultComp(partial, schemaFragment, arrayChild);
        } catch (err) {
          errors2.push(err.message);
          partial.comp = "none";
        }
      }
      if (partial.comp === "none")
        return { normalized: { comp: "none" }, errors: errors2 };
      if (nullable)
        partial.nullable = nullable;
      if (compositeCompNames.includes(partial.comp)) {
        partial.title = partial.title ?? schemaFragment.title ?? null;
        partial.children = getChildren(getDefaultChildren(schemaFragment), partial.children);
      } else if (partial.comp === "list") {
        partial.title = partial.title ?? schemaFragment.title ?? key;
        partial.listEditMode = partial.listEditMode ?? (schemaFragment.items.type === "object" ? "inline-single" : "inline");
        partial.listActions = partial.listActions ?? ["add", "edit", "delete", "duplicate", "sort"];
      } else {
        partial.label = partial.label ?? schemaFragment.title ?? key;
      }
      if (["select", "autocomplete", "combobox"].includes(partial.comp) && !partial.items) {
        let items2;
        if (type2 === "array") {
          items2 = getItemsFromSchema(schemaFragment.items);
          partial.multiple = true;
        } else {
          items2 = getItemsFromSchema(schemaFragment);
        }
        if (items2) {
          if (partial.getItems && isPartialGetItemsObj(partial.getItems)) {
            partial.getItems.expr = JSON.stringify(items2);
          } else {
            partial.getItems = JSON.stringify(items2);
          }
        }
      }
      if (["combobox", "number-combobox", "file-input"].includes(partial.comp)) {
        if (type2 === "array") {
          partial.multiple = true;
        }
      }
      if (partial.comp === "date-picker") {
        if (schemaFragment.format === "date")
          partial.format = "date";
        if (schemaFragment.format === "date-time")
          partial.format = "date-time";
      }
      if (["date-picker", "date-time-picker", "time-picker"].includes(partial.comp)) {
        if ("formatMinimum" in schemaFragment)
          partial.min = partial.min ?? schemaFragment.formatMinimum;
        if ("formatMaximum" in schemaFragment)
          partial.max = partial.max ?? schemaFragment.formatMaximum;
      }
      if (["number-field", "slider"].includes(partial.comp)) {
        if (type2 === "integer")
          partial.step = partial.step ?? 1;
        if ("minimum" in schemaFragment)
          partial.min = partial.min ?? schemaFragment.minimum;
        if ("maximum" in schemaFragment)
          partial.max = partial.max ?? schemaFragment.maximum;
      }
      if (partial.if)
        partial.if = normalizeExpression(partial.if);
      if (!partial.defaultData && schemaFragment.type === "string" && schemaPath.split("#").pop() === "") {
        partial.defaultData = "";
      }
      if (partial.getOptions !== void 0)
        partial.getOptions = normalizeExpression(partial.getOptions);
      if (partial.getDefaultData !== void 0)
        partial.getDefaultData = normalizeExpression(partial.getDefaultData);
      if (partial.getConstData !== void 0)
        partial.getConstData = normalizeExpression(partial.getConstData);
      if (partial.transformData !== void 0)
        partial.transformData = normalizeExpression(partial.transformData);
      if (partial.getProps !== void 0)
        partial.getProps = normalizeExpression(partial.getProps);
      if (partial.getItems && isPartialGetItemsExpr(partial.getItems))
        partial.getItems = normalizeExpression(partial.getItems);
      if (partial.getItems && isPartialGetItemsObj(partial.getItems)) {
        if (type2 === "object")
          partial.getItems.returnObjects = true;
        if (partial.getItems.itemTitle)
          partial.getItems.itemTitle = normalizeExpression(partial.getItems.itemTitle);
        if (partial.getItems.itemKey)
          partial.getItems.itemKey = normalizeExpression(partial.getItems.itemKey);
        if (partial.getItems.itemValue)
          partial.getItems.itemValue = normalizeExpression(partial.getItems.itemValue);
        if (partial.getItems.itemIcon)
          partial.getItems.itemIcon = normalizeExpression(partial.getItems.itemIcon);
        if (partial.getItems.itemsResults)
          partial.getItems.itemsResults = normalizeExpression(partial.getItems.itemsResults);
      }
      if (partial.getItems && isPartialGetItemsFetch(partial.getItems)) {
        partial.getItems.url = normalizeExpression(partial.getItems.url, "js-tpl");
      }
      if (partial.items) {
        partial.items = partial.items.map((item) => {
          if (["string", "integer", "number"].includes(typeof item)) {
            return { title: item + "", key: item + "", value: item };
          } else if (typeof item === "object") {
            return {
              key: (item.key ?? item.value) + "",
              title: (item.title ?? item.key ?? item.value) + "",
              value: item.value ?? item.key
            };
          } else {
            throw new Error(`bad item for select: ${JSON.stringify(item)}`);
          }
        });
      }
      if (!partial.comp && (partial.items ?? partial.getItems)) {
        partial.comp = "select";
      }
      if (partial.comp === "date-picker" && schemaFragment.format === "date-time") {
        partial.format = "date-time";
      }
      if (partial.slots) {
        for (const [name, slot] of Object.entries(partial.slots)) {
          if (typeof slot === "string") {
            if (["before", "after"].includes(name)) {
              partial.slots[name] = { markdown: slot };
            } else {
              partial.slots[name] = { name: slot };
            }
          }
          const slotObj = partial.slots[name];
          if (isPartialSlotMarkdown(slotObj)) {
            slotObj.markdown = markdown(slotObj.markdown).trim();
          }
        }
      }
      if (schemaFragment.description && !partial.help)
        partial.help = schemaFragment.description;
      if (partial.help)
        partial.help = markdown(partial.help).trim();
      if (typeof partial.cols === "number")
        partial.cols = { xs: partial.cols };
      if (typeof partial.cols === "object" && partial.cols.xs === void 0)
        partial.cols.xs = 12;
      return { normalized: (
        /** @type {CompObject} */
        partial
      ), errors: errors2 };
    }
    function getNormalizedLayout(layoutKeyword, schemaFragment, schemaPath, markdown, arrayChild) {
      if (isPartialSwitch(layoutKeyword)) {
        const normalizedSwitchCases = [];
        const errors2 = [];
        const switchCases = [...layoutKeyword.switch];
        if (!switchCases.find((s) => !s.if)) {
          switchCases.push({});
        }
        for (let i2 = 0; i2 < switchCases.length; i2++) {
          const switchCase = switchCases[i2];
          const compObjectResult = getCompObject$1(switchCase, schemaFragment, schemaPath, markdown, arrayChild);
          normalizedSwitchCases.push(compObjectResult.normalized);
          for (const error2 of compObjectResult.errors)
            errors2.push(`switch ${i2} - ${error2}`);
        }
        return { normalized: { switch: normalizedSwitchCases }, errors: [] };
      } else {
        return getCompObject$1(layoutKeyword, schemaFragment, schemaPath, markdown, arrayChild);
      }
    }
    function matchValidationError(error2, fn) {
      if (error2.keyword === "errorMessage") {
        error2 = error2.params.errors[0];
      }
      return fn(error2);
    }
    function lighterValidationErrors(errors2) {
      const compositeErrors = errors2.filter((e) => matchValidationError(e, (e2) => e2.keyword === "anyOf" || e2.keyword === "oneOf"));
      for (const compositeError of compositeErrors) {
        const explicitError = errors2.find((e) => matchValidationError(e, (e2) => e2.instancePath === compositeError.instancePath && e2.keyword !== "type"));
        if (explicitError) {
          errors2 = errors2.filter((e) => matchValidationError(e, (e2) => e2.instancePath !== compositeError.instancePath || e2.keyword !== "type"));
        }
      }
      return errors2.map((e) => e.message ?? e.keyword);
    }
    function normalizeLayoutFragment(schemaFragment, schemaPath, markdown = (src) => src, arrayChild) {
      let layoutKeyword;
      if (arrayChild === "oneOf") {
        layoutKeyword = schemaFragment.oneOfLayout ?? {};
      } else {
        layoutKeyword = schemaFragment.layout ?? {};
      }
      if (!validateLayoutKeyword(layoutKeyword)) {
        console.error(`layout keyword validation errors at path ${schemaPath}`, layoutKeyword, validateLayoutKeyword.errors);
        return {
          layout: getNormalizedLayout({}, schemaFragment, schemaPath, markdown, arrayChild).normalized,
          errors: lighterValidationErrors(validateLayoutKeyword.errors)
        };
      }
      const normalizedLayout = getNormalizedLayout(layoutKeyword, schemaFragment, schemaPath, markdown, arrayChild);
      if (!validateNormalizedLayout(normalizedLayout.normalized)) {
        console.error(`normalized layout validation errors at path ${schemaPath}`, normalizedLayout, validateNormalizedLayout.errors);
        return {
          layout: getNormalizedLayout({}, schemaFragment, schemaPath, markdown, arrayChild).normalized,
          errors: lighterValidationErrors(validateNormalizedLayout.errors)
        };
      }
      return { layout: normalizedLayout.normalized, errors: [] };
    }
    function makeSkeletonNode(schema, options, validates, validationErrors, normalizedLayouts, expressions, key, pointer, parentPointer, required2) {
      var _a2, _b;
      if (!schema.type && schema.properties)
        schema.type = "object";
      schema.errorMessage = schema.errorMessage ?? {};
      if (!normalizedLayouts[pointer]) {
        const normalizationResult = normalizeLayoutFragment(
          /** @type {import('@json-layout/vocabulary').SchemaFragment} */
          schema,
          pointer,
          options.markdown
        );
        normalizedLayouts[pointer] = normalizationResult.layout;
        if (normalizationResult.errors.length) {
          validationErrors[pointer.replace("_jl#", "/")] = normalizationResult.errors;
        }
      }
      const normalizedLayout = normalizedLayouts[pointer];
      let defaultData;
      if ("default" in schema)
        defaultData = schema.default;
      else if (required2) {
        if (schema.type === "object")
          defaultData = {};
        if (schema.type === "array")
          defaultData = [];
      }
      let pure = true;
      const pushExpression = (expressions2, expression) => {
        if (!expression.pure)
          pure = false;
        const index = expressions2.findIndex((e) => e.type === expression.type && e.expr === expression.expr);
        if (index !== -1) {
          expression.ref = index;
        } else {
          expression.ref = expressions2.length;
          expressions2.push(expression);
        }
      };
      const compObjects = isSwitchStruct(normalizedLayout) ? normalizedLayout.switch : [normalizedLayout];
      for (const compObject of compObjects) {
        if (schema.description && !compObject.help)
          compObject.help = schema.description;
        if (compObject.if)
          pushExpression(expressions, compObject.if);
        if (schema.const !== void 0 && compObject.constData === void 0)
          compObject.constData = schema.const;
        if (compObject.constData !== void 0 && !compObject.getConstData)
          compObject.getConstData = { type: "js-eval", expr: "layout.constData", pure: true };
        if (compObject.getConstData)
          pushExpression(expressions, compObject.getConstData);
        if (defaultData !== void 0 && compObject.defaultData === void 0)
          compObject.defaultData = defaultData;
        if (compObject.defaultData !== void 0 && !compObject.getDefaultData)
          compObject.getDefaultData = { type: "js-eval", expr: "layout.defaultData", pure: true };
        if (compObject.getDefaultData)
          pushExpression(expressions, compObject.getDefaultData);
        if (compObject.options !== void 0 && !compObject.getOptions)
          compObject.getOptions = { type: "js-eval", expr: "layout.options", pure: true };
        if (compObject.getOptions)
          pushExpression(expressions, compObject.getOptions);
        if (compObject.transformData)
          pushExpression(expressions, compObject.transformData);
        if (isItemsLayout(compObject) && compObject.getItems) {
          if (isGetItemsExpression(compObject.getItems))
            pushExpression(expressions, compObject.getItems);
          if (isGetItemsFetch(compObject.getItems))
            pushExpression(expressions, compObject.getItems.url);
          if (compObject.getItems.itemTitle)
            pushExpression(expressions, compObject.getItems.itemTitle);
          if (compObject.getItems.itemKey)
            pushExpression(expressions, compObject.getItems.itemKey);
          if (compObject.getItems.itemValue)
            pushExpression(expressions, compObject.getItems.itemValue);
          if (compObject.getItems.itemIcon)
            pushExpression(expressions, compObject.getItems.itemIcon);
          if (compObject.getItems.itemsResults)
            pushExpression(expressions, compObject.getItems.itemsResults);
        }
      }
      const node = { key: key ?? "", pointer, parentPointer, pure, propertyKeys: [] };
      if (schema.type === "object") {
        if (schema.properties) {
          node.children = node.children ?? [];
          for (const propertyKey of Object.keys(schema.properties)) {
            node.propertyKeys.push(propertyKey);
            node.children.push(makeSkeletonNode(
              schema.properties[propertyKey],
              options,
              validates,
              validationErrors,
              normalizedLayouts,
              expressions,
              propertyKey,
              `${pointer}/properties/${propertyKey}`,
              pointer,
              (_a2 = schema.required) == null ? void 0 : _a2.includes(propertyKey)
            ));
            if ((_b = schema == null ? void 0 : schema.required) == null ? void 0 : _b.includes(propertyKey)) {
              schema.errorMessage.required = schema.errorMessage.required ?? {};
              schema.errorMessage.required[propertyKey] = options.messages.errorRequired;
            }
          }
        }
        if (schema.allOf) {
          node.children = node.children ?? [];
          for (let i2 = 0; i2 < schema.allOf.length; i2++) {
            const allOfNode = makeSkeletonNode(
              schema.allOf[i2],
              options,
              validates,
              validationErrors,
              normalizedLayouts,
              expressions,
              `$allOf-${i2}`,
              `${pointer}/allOf/${i2}`,
              pointer,
              false
            );
            node.propertyKeys = node.propertyKeys.concat(allOfNode.propertyKeys);
            node.children.push(allOfNode);
          }
        }
        if (schema.oneOf) {
          const oneOfPointer = `${pointer}/oneOf`;
          if (!normalizedLayouts[oneOfPointer]) {
            const normalizationResult = normalizeLayoutFragment(schema, oneOfPointer, options.markdown, "oneOf");
            normalizedLayouts[oneOfPointer] = normalizationResult.layout;
            if (normalizationResult.errors.length) {
              validationErrors[oneOfPointer.replace("_jl#", "/")] = normalizationResult.errors;
            }
          }
          const childrenTrees = [];
          for (let i2 = 0; i2 < schema.oneOf.length; i2++) {
            if (!schema.oneOf[i2].type)
              schema.oneOf[i2].type = schema.type;
            const title2 = schema.oneOf[i2].title ?? `option ${i2}`;
            delete schema.oneOf[i2].title;
            childrenTrees.push(makeSkeletonTree(
              schema.oneOf[i2],
              options,
              validates,
              validationErrors,
              normalizedLayouts,
              expressions,
              `${oneOfPointer}/${i2}`,
              title2
            ));
          }
          node.children = node.children ?? [];
          node.children.push({
            key: "$oneOf",
            pointer: `${pointer}/oneOf`,
            parentPointer: pointer,
            childrenTrees,
            pure: childrenTrees[0].root.pure,
            propertyKeys: []
          });
          schema.errorMessage.oneOf = options.messages.errorOneOf;
        }
      }
      if (schema.type === "array" && schema.items) {
        if (Array.isArray(schema.items)) {
          node.children = schema.items.map((itemSchema, i2) => {
            return makeSkeletonNode(
              itemSchema,
              options,
              validates,
              validationErrors,
              normalizedLayouts,
              expressions,
              i2,
              `${pointer}/items/${i2}`,
              pointer,
              true
            );
          });
        } else {
          node.childrenTrees = [
            makeSkeletonTree(
              schema.items,
              options,
              validates,
              validationErrors,
              normalizedLayouts,
              expressions,
              `${pointer}/items`,
              schema.items.title
            )
          ];
        }
      }
      for (const child of node.children || [])
        if (!child.pure)
          node.pure = false;
      for (const childTree of node.childrenTrees || [])
        if (!childTree.root.pure)
          node.pure = false;
      return node;
    }
    function makeSkeletonTree(schema, options, validates, validationErrors, normalizedLayouts, expressions, pointer, title2) {
      const root = makeSkeletonNode(schema, options, validates, validationErrors, normalizedLayouts, expressions, "", pointer, null, true);
      validates.push(pointer);
      return { title: title2, root };
    }
    const Ajv$1 = ajvModule.default;
    const getJSONRef = (schemas, ref2, ajv2) => {
      var _a2;
      const [schemaId, pointer] = ref2.split("#");
      schemas[schemaId] = schemas[schemaId] ?? ((_a2 = ajv2.getSchema(schemaId)) == null ? void 0 : _a2.schema);
      if (!schemas[schemaId])
        throw new Error(`reference not found ${schemaId}`);
      const pointerParts = pointer.split("/").filter((p2) => !!p2);
      const { value: fragment } = pointerParts.reduce((a, pointerPart) => {
        a.path.push(pointerPart);
        if (!(pointerPart in a.value))
          throw new Error(`reference not found ${schemaId}#${a.path.join("/")}`);
        a.value = a.value[pointerPart];
        return a;
      }, { path: ["/"], value: schemas[schemaId] });
      return [fragment, schemaId];
    };
    const recurse = (schemas, schemaFragment, schemaId, ajv2, locale = "en") => {
      for (const key of Object.keys(schemaFragment)) {
        if (schemaFragment[key] && typeof schemaFragment[key] === "object") {
          if ("$ref" in schemaFragment[key]) {
            const fullRef = ajv2.opts.uriResolver.resolve(schemaId, schemaFragment[key].$ref).replace("~$locale~", locale);
            const fullRefDefaultLocale = ajv2.opts.uriResolver.resolve(schemaId, schemaFragment[key].$ref).replace("~$locale~", "en");
            let refFragment, refSchemaId;
            try {
              [refFragment, refSchemaId] = getJSONRef(schemas, fullRef, ajv2);
            } catch (err) {
              [refFragment, refSchemaId] = getJSONRef(schemas, fullRefDefaultLocale, ajv2);
            }
            if (typeof refFragment === "object" && !Array.isArray(refFragment)) {
              schemaFragment[key] = { ...refFragment, ...schemaFragment[key] };
              delete schemaFragment[key].$ref;
            } else {
              schemaFragment[key] = refFragment;
            }
            recurse(schemas, schemaFragment[key], refSchemaId, ajv2, locale);
          } else {
            recurse(schemas, schemaFragment[key], schemaId, ajv2, locale);
          }
        }
      }
      return schemaFragment;
    };
    function resolveRefs(schema, ajv2, locale = "en") {
      if (!schema.$id)
        throw new Error("missing schema id");
      return recurse({ [schema.$id]: schema }, schema, schema.$id, ajv2 ?? new Ajv$1(), locale);
    }
    function copyBuffer(cur) {
      if (cur instanceof Buffer) {
        return Buffer.from(cur);
      }
      return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
    }
    function rfdc() {
      return clone2;
      function cloneArray(a, fn) {
        const keys2 = Object.keys(a);
        const a2 = new Array(keys2.length);
        for (let i2 = 0; i2 < keys2.length; i2++) {
          const k = keys2[i2];
          const cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur instanceof Date) {
            a2[k] = new Date(cur);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            a2[k] = fn(cur);
          }
        }
        return a2;
      }
      function clone2(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, clone2);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), clone2));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), clone2));
        const o2 = {};
        for (const k in o) {
          if (Object.hasOwnProperty.call(o, k) === false)
            continue;
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), clone2));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), clone2));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = clone2(cur);
          }
        }
        return o2;
      }
    }
    const clone$1 = rfdc();
    const Ajv = (
      /** @type {typeof ajvModule.default} */
      ajvModule
    );
    const ajvLocalize = (
      /** @type {typeof ajvLocalizeModule.default} */
      ajvLocalizeModule
    );
    const fillOptions$1 = (partialOptions) => {
      let ajv2 = partialOptions.ajv;
      if (!ajv2) {
        const ajvOpts = { allErrors: true, strict: false };
        if (partialOptions.ajvOptions)
          Object.assign(ajvOpts, partialOptions.ajvOptions);
        if (partialOptions.code)
          ajvOpts.code = { source: true, esm: true, lines: true };
        const newAjv = new Ajv(ajvOpts);
        addFormats.default(newAjv);
        ajvErrors.default(newAjv);
        ajv2 = newAjv;
      }
      ajv2.addKeyword("layout");
      let markdown = partialOptions.markdown;
      if (!markdown) {
        const markdownIt2 = new MarkdownIt(partialOptions.markdownItOptions ?? {});
        markdown = markdownIt2.render.bind(markdownIt2);
      }
      const locale = partialOptions.locale || "en";
      const messages = { ...i18n[locale] || i18n.en };
      if (partialOptions.messages)
        Object.assign(messages, partialOptions.messages);
      return {
        ajv: ajv2,
        code: false,
        markdown,
        ...partialOptions,
        locale,
        messages
      };
    };
    function compile(_schema, partialOptions = {}) {
      const options = fillOptions$1(partialOptions);
      const schema = (
        /** @type {import('ajv').SchemaObject} */
        clone$1(_schema)
      );
      schema.$id = schema.$id ?? "_jl";
      resolveRefs(schema, options.ajv, options.locale);
      const validatePointers = [];
      const normalizedLayouts = {};
      const expressionsDefinitions = [];
      const validationErrors = {};
      const skeletonTree = makeSkeletonTree(
        schema,
        options,
        validatePointers,
        validationErrors,
        normalizedLayouts,
        expressionsDefinitions,
        `${schema.$id}#`,
        "main"
      );
      options.ajv.addSchema(schema);
      const uriResolver = options.ajv.opts.uriResolver;
      const validates = {};
      for (const pointer of validatePointers) {
        const fullPointer = uriResolver.resolve(schema.$id, pointer);
        validates[pointer] = options.ajv.compile({ $ref: fullPointer });
      }
      const expressions = [];
      for (const expression of expressionsDefinitions) {
        const expressionsParams = expression.pure ? ["data", "options", "context", "display", "layout"] : ["data", "options", "context", "display", "layout", "parentData", "rootData"];
        if (expression.type === "js-fn") {
          expressions.push(
            /** @type {CompiledExpression} */
            new Function(...expressionsParams, expression.expr)
          );
        }
        if (expression.type === "js-eval") {
          expressions.push(
            /** @type {CompiledExpression} */
            new Function(...expressionsParams, "return (" + expression.expr + ")")
          );
        }
        if (expression.type === "js-tpl") {
          expressions.push(
            /** @type {CompiledExpression} */
            new Function(...expressionsParams, "return `" + expression.expr + "`")
          );
        }
      }
      return {
        options,
        schema,
        skeletonTree,
        validates,
        validationErrors,
        normalizedLayouts,
        expressions,
        locale: options.locale,
        messages: options.messages,
        // @ts-ignore
        localizeErrors: ajvLocalize[options.locale] || ajvLocalize.en
      };
    }
    function mittModule(n) {
      return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
        var i2 = n.get(t);
        i2 ? i2.push(e) : n.set(t, [e]);
      }, off: function(t, e) {
        var i2 = n.get(t);
        i2 && (e ? i2.splice(i2.indexOf(e) >>> 0, 1) : n.set(t, []));
      }, emit: function(t, e) {
        var i2 = n.get(t);
        i2 && i2.slice().map(function(n2) {
          n2(e);
        }), (i2 = n.get("*")) && i2.slice().map(function(n2) {
          n2(t, e);
        });
      } };
    }
    var browser = { exports: {} };
    var ms;
    var hasRequiredMs;
    function requireMs() {
      if (hasRequiredMs)
        return ms;
      hasRequiredMs = 1;
      var s = 1e3;
      var m = s * 60;
      var h2 = m * 60;
      var d = h2 * 24;
      var w = d * 7;
      var y = d * 365.25;
      ms = function(val, options) {
        options = options || {};
        var type2 = typeof val;
        if (type2 === "string" && val.length > 0) {
          return parse2(val);
        } else if (type2 === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
        );
      };
      function parse2(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str
        );
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type2 = (match[2] || "ms").toLowerCase();
        switch (type2) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h2;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return void 0;
        }
      }
      function fmtShort(ms2) {
        var msAbs = Math.abs(ms2);
        if (msAbs >= d) {
          return Math.round(ms2 / d) + "d";
        }
        if (msAbs >= h2) {
          return Math.round(ms2 / h2) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms2 / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms2 / s) + "s";
        }
        return ms2 + "ms";
      }
      function fmtLong(ms2) {
        var msAbs = Math.abs(ms2);
        if (msAbs >= d) {
          return plural(ms2, msAbs, d, "day");
        }
        if (msAbs >= h2) {
          return plural(ms2, msAbs, h2, "hour");
        }
        if (msAbs >= m) {
          return plural(ms2, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms2, msAbs, s, "second");
        }
        return ms2 + " ms";
      }
      function plural(ms2, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
      }
      return ms;
    }
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = requireMs();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i2);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms2 = curr - (prevTime || curr);
          self2.diff = ms2;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend2;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend2(namespace, delimiter2) {
        const newDebug = createDebug(this.namespace + (typeof delimiter2 === "undefined" ? ":" : delimiter2) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i2;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i2 = 0; i2 < len; i2++) {
          if (!split[i2]) {
            continue;
          }
          namespaces = split[i2].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i2;
        let len;
        for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
          if (createDebug.skips[i2].test(name)) {
            return false;
          }
        }
        for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
          if (createDebug.names[i2].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    var common = setup;
    var define_process_env_default = {};
    (function(module2, exports2) {
      exports2.formatArgs = formatArgs;
      exports2.save = save;
      exports2.load = load;
      exports2.useColors = useColors;
      exports2.storage = localstorage();
      exports2.destroy = /* @__PURE__ */ (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports2.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      exports2.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports2.storage.setItem("debug", namespaces);
          } else {
            exports2.storage.removeItem("debug");
          }
        } catch (error2) {
        }
      }
      function load() {
        let r;
        try {
          r = exports2.storage.getItem("debug");
        } catch (error2) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = define_process_env_default.DEBUG;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error2) {
        }
      }
      module2.exports = common(exports2);
      const { formatters } = module2.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error2) {
          return "[UnexpectedJSONParseError]: " + error2.message;
        }
      };
    })(browser, browser.exports);
    var browserExports = browser.exports;
    const debug = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
    var NOTHING = Symbol.for("immer-nothing");
    var DRAFTABLE = Symbol.for("immer-draftable");
    var DRAFT_STATE = Symbol.for("immer-state");
    function die(error2, ...args) {
      throw new Error(
        `[Immer] minified error nr: ${error2}. Full error at: https://bit.ly/3cXEKWf`
      );
    }
    var getPrototypeOf = Object.getPrototypeOf;
    function isDraft(value) {
      return !!value && !!value[DRAFT_STATE];
    }
    function isDraftable(value) {
      var _a2;
      if (!value)
        return false;
      return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_a2 = value.constructor) == null ? void 0 : _a2[DRAFTABLE]) || isMap(value) || isSet(value);
    }
    var objectCtorString = Object.prototype.constructor.toString();
    function isPlainObject(value) {
      if (!value || typeof value !== "object")
        return false;
      const proto = getPrototypeOf(value);
      if (proto === null) {
        return true;
      }
      const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
      if (Ctor === Object)
        return true;
      return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
    }
    function each(obj, iter) {
      if (getArchtype(obj) === 0) {
        Object.entries(obj).forEach(([key, value]) => {
          iter(key, value, obj);
        });
      } else {
        obj.forEach((entry, index) => iter(index, entry, obj));
      }
    }
    function getArchtype(thing) {
      const state = thing[DRAFT_STATE];
      return state ? state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
    }
    function has(thing, prop2) {
      return getArchtype(thing) === 2 ? thing.has(prop2) : Object.prototype.hasOwnProperty.call(thing, prop2);
    }
    function set(thing, propOrOldValue, value) {
      const t = getArchtype(thing);
      if (t === 2)
        thing.set(propOrOldValue, value);
      else if (t === 3) {
        thing.add(value);
      } else
        thing[propOrOldValue] = value;
    }
    function is(x, y) {
      if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
      } else {
        return x !== x && y !== y;
      }
    }
    function isMap(target2) {
      return target2 instanceof Map;
    }
    function isSet(target2) {
      return target2 instanceof Set;
    }
    function latest(state) {
      return state.copy_ || state.base_;
    }
    function shallowCopy(base2, strict) {
      if (isMap(base2)) {
        return new Map(base2);
      }
      if (isSet(base2)) {
        return new Set(base2);
      }
      if (Array.isArray(base2))
        return Array.prototype.slice.call(base2);
      if (!strict && isPlainObject(base2)) {
        if (!getPrototypeOf(base2)) {
          const obj = /* @__PURE__ */ Object.create(null);
          return Object.assign(obj, base2);
        }
        return { ...base2 };
      }
      const descriptors = Object.getOwnPropertyDescriptors(base2);
      delete descriptors[DRAFT_STATE];
      let keys2 = Reflect.ownKeys(descriptors);
      for (let i2 = 0; i2 < keys2.length; i2++) {
        const key = keys2[i2];
        const desc = descriptors[key];
        if (desc.writable === false) {
          desc.writable = true;
          desc.configurable = true;
        }
        if (desc.get || desc.set)
          descriptors[key] = {
            configurable: true,
            writable: true,
            // could live with !!desc.set as well here...
            enumerable: desc.enumerable,
            value: base2[key]
          };
      }
      return Object.create(getPrototypeOf(base2), descriptors);
    }
    function freeze(obj, deep = false) {
      if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
        return obj;
      if (getArchtype(obj) > 1) {
        obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
      }
      Object.freeze(obj);
      if (deep)
        each(obj, (_key, value) => freeze(value, true));
      return obj;
    }
    function dontMutateFrozenCollections() {
      die(2);
    }
    function isFrozen(obj) {
      return Object.isFrozen(obj);
    }
    var plugins = {};
    function getPlugin(pluginKey) {
      const plugin = plugins[pluginKey];
      if (!plugin) {
        die(0, pluginKey);
      }
      return plugin;
    }
    var currentScope;
    function getCurrentScope() {
      return currentScope;
    }
    function createScope(parent_, immer_) {
      return {
        drafts_: [],
        parent_,
        immer_,
        // Whenever the modified draft contains a draft from another scope, we
        // need to prevent auto-freezing so the unowned draft can be finalized.
        canAutoFreeze_: true,
        unfinalizedDrafts_: 0
      };
    }
    function usePatchesInScope(scope2, patchListener) {
      if (patchListener) {
        getPlugin("Patches");
        scope2.patches_ = [];
        scope2.inversePatches_ = [];
        scope2.patchListener_ = patchListener;
      }
    }
    function revokeScope(scope2) {
      leaveScope(scope2);
      scope2.drafts_.forEach(revokeDraft);
      scope2.drafts_ = null;
    }
    function leaveScope(scope2) {
      if (scope2 === currentScope) {
        currentScope = scope2.parent_;
      }
    }
    function enterScope(immer2) {
      return currentScope = createScope(currentScope, immer2);
    }
    function revokeDraft(draft) {
      const state = draft[DRAFT_STATE];
      if (state.type_ === 0 || state.type_ === 1)
        state.revoke_();
      else
        state.revoked_ = true;
    }
    function processResult(result, scope2) {
      scope2.unfinalizedDrafts_ = scope2.drafts_.length;
      const baseDraft = scope2.drafts_[0];
      const isReplaced = result !== void 0 && result !== baseDraft;
      if (isReplaced) {
        if (baseDraft[DRAFT_STATE].modified_) {
          revokeScope(scope2);
          die(4);
        }
        if (isDraftable(result)) {
          result = finalize(scope2, result);
          if (!scope2.parent_)
            maybeFreeze(scope2, result);
        }
        if (scope2.patches_) {
          getPlugin("Patches").generateReplacementPatches_(
            baseDraft[DRAFT_STATE].base_,
            result,
            scope2.patches_,
            scope2.inversePatches_
          );
        }
      } else {
        result = finalize(scope2, baseDraft, []);
      }
      revokeScope(scope2);
      if (scope2.patches_) {
        scope2.patchListener_(scope2.patches_, scope2.inversePatches_);
      }
      return result !== NOTHING ? result : void 0;
    }
    function finalize(rootScope, value, path) {
      if (isFrozen(value))
        return value;
      const state = value[DRAFT_STATE];
      if (!state) {
        each(
          value,
          (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path)
        );
        return value;
      }
      if (state.scope_ !== rootScope)
        return value;
      if (!state.modified_) {
        maybeFreeze(rootScope, state.base_, true);
        return state.base_;
      }
      if (!state.finalized_) {
        state.finalized_ = true;
        state.scope_.unfinalizedDrafts_--;
        const result = state.copy_;
        let resultEach = result;
        let isSet2 = false;
        if (state.type_ === 3) {
          resultEach = new Set(result);
          result.clear();
          isSet2 = true;
        }
        each(
          resultEach,
          (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2)
        );
        maybeFreeze(rootScope, result, false);
        if (path && rootScope.patches_) {
          getPlugin("Patches").generatePatches_(
            state,
            path,
            rootScope.patches_,
            rootScope.inversePatches_
          );
        }
      }
      return state.copy_;
    }
    function finalizeProperty(rootScope, parentState, targetObject, prop2, childValue, rootPath, targetIsSet) {
      if (isDraft(childValue)) {
        const path = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
        !has(parentState.assigned_, prop2) ? rootPath.concat(prop2) : void 0;
        const res = finalize(rootScope, childValue, path);
        set(targetObject, prop2, res);
        if (isDraft(res)) {
          rootScope.canAutoFreeze_ = false;
        } else
          return;
      } else if (targetIsSet) {
        targetObject.add(childValue);
      }
      if (isDraftable(childValue) && !isFrozen(childValue)) {
        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
          return;
        }
        finalize(rootScope, childValue);
        if (!parentState || !parentState.scope_.parent_)
          maybeFreeze(rootScope, childValue);
      }
    }
    function maybeFreeze(scope2, value, deep = false) {
      if (!scope2.parent_ && scope2.immer_.autoFreeze_ && scope2.canAutoFreeze_) {
        freeze(value, deep);
      }
    }
    function createProxyProxy(base2, parent) {
      const isArray2 = Array.isArray(base2);
      const state = {
        type_: isArray2 ? 1 : 0,
        // Track which produce call this is associated with.
        scope_: parent ? parent.scope_ : getCurrentScope(),
        // True for both shallow and deep changes.
        modified_: false,
        // Used during finalization.
        finalized_: false,
        // Track which properties have been assigned (true) or deleted (false).
        assigned_: {},
        // The parent draft state.
        parent_: parent,
        // The base state.
        base_: base2,
        // The base proxy.
        draft_: null,
        // set below
        // The base copy with any updated values.
        copy_: null,
        // Called by the `produce` function.
        revoke_: null,
        isManual_: false
      };
      let target2 = state;
      let traps = objectTraps;
      if (isArray2) {
        target2 = [state];
        traps = arrayTraps;
      }
      const { revoke, proxy } = Proxy.revocable(target2, traps);
      state.draft_ = proxy;
      state.revoke_ = revoke;
      return proxy;
    }
    var objectTraps = {
      get(state, prop2) {
        if (prop2 === DRAFT_STATE)
          return state;
        const source = latest(state);
        if (!has(source, prop2)) {
          return readPropFromProto(state, source, prop2);
        }
        const value = source[prop2];
        if (state.finalized_ || !isDraftable(value)) {
          return value;
        }
        if (value === peek(state.base_, prop2)) {
          prepareCopy(state);
          return state.copy_[prop2] = createProxy(value, state);
        }
        return value;
      },
      has(state, prop2) {
        return prop2 in latest(state);
      },
      ownKeys(state) {
        return Reflect.ownKeys(latest(state));
      },
      set(state, prop2, value) {
        const desc = getDescriptorFromProto(latest(state), prop2);
        if (desc == null ? void 0 : desc.set) {
          desc.set.call(state.draft_, value);
          return true;
        }
        if (!state.modified_) {
          const current2 = peek(latest(state), prop2);
          const currentState = current2 == null ? void 0 : current2[DRAFT_STATE];
          if (currentState && currentState.base_ === value) {
            state.copy_[prop2] = value;
            state.assigned_[prop2] = false;
            return true;
          }
          if (is(value, current2) && (value !== void 0 || has(state.base_, prop2)))
            return true;
          prepareCopy(state);
          markChanged(state);
        }
        if (state.copy_[prop2] === value && // special case: handle new props with value 'undefined'
        (value !== void 0 || prop2 in state.copy_) || // special case: NaN
        Number.isNaN(value) && Number.isNaN(state.copy_[prop2]))
          return true;
        state.copy_[prop2] = value;
        state.assigned_[prop2] = true;
        return true;
      },
      deleteProperty(state, prop2) {
        if (peek(state.base_, prop2) !== void 0 || prop2 in state.base_) {
          state.assigned_[prop2] = false;
          prepareCopy(state);
          markChanged(state);
        } else {
          delete state.assigned_[prop2];
        }
        if (state.copy_) {
          delete state.copy_[prop2];
        }
        return true;
      },
      // Note: We never coerce `desc.value` into an Immer draft, because we can't make
      // the same guarantee in ES5 mode.
      getOwnPropertyDescriptor(state, prop2) {
        const owner = latest(state);
        const desc = Reflect.getOwnPropertyDescriptor(owner, prop2);
        if (!desc)
          return desc;
        return {
          writable: true,
          configurable: state.type_ !== 1 || prop2 !== "length",
          enumerable: desc.enumerable,
          value: owner[prop2]
        };
      },
      defineProperty() {
        die(11);
      },
      getPrototypeOf(state) {
        return getPrototypeOf(state.base_);
      },
      setPrototypeOf() {
        die(12);
      }
    };
    var arrayTraps = {};
    each(objectTraps, (key, fn) => {
      arrayTraps[key] = function() {
        arguments[0] = arguments[0][0];
        return fn.apply(this, arguments);
      };
    });
    arrayTraps.deleteProperty = function(state, prop2) {
      return arrayTraps.set.call(this, state, prop2, void 0);
    };
    arrayTraps.set = function(state, prop2, value) {
      return objectTraps.set.call(this, state[0], prop2, value, state[0]);
    };
    function peek(draft, prop2) {
      const state = draft[DRAFT_STATE];
      const source = state ? latest(state) : draft;
      return source[prop2];
    }
    function readPropFromProto(state, source, prop2) {
      var _a2;
      const desc = getDescriptorFromProto(source, prop2);
      return desc ? `value` in desc ? desc.value : (
        // This is a very special case, if the prop is a getter defined by the
        // prototype, we should invoke it with the draft as context!
        (_a2 = desc.get) == null ? void 0 : _a2.call(state.draft_)
      ) : void 0;
    }
    function getDescriptorFromProto(source, prop2) {
      if (!(prop2 in source))
        return void 0;
      let proto = getPrototypeOf(source);
      while (proto) {
        const desc = Object.getOwnPropertyDescriptor(proto, prop2);
        if (desc)
          return desc;
        proto = getPrototypeOf(proto);
      }
      return void 0;
    }
    function markChanged(state) {
      if (!state.modified_) {
        state.modified_ = true;
        if (state.parent_) {
          markChanged(state.parent_);
        }
      }
    }
    function prepareCopy(state) {
      if (!state.copy_) {
        state.copy_ = shallowCopy(
          state.base_,
          state.scope_.immer_.useStrictShallowCopy_
        );
      }
    }
    var Immer2 = class {
      constructor(config2) {
        this.autoFreeze_ = true;
        this.useStrictShallowCopy_ = false;
        this.produce = (base2, recipe, patchListener) => {
          if (typeof base2 === "function" && typeof recipe !== "function") {
            const defaultBase = recipe;
            recipe = base2;
            const self2 = this;
            return function curriedProduce(base22 = defaultBase, ...args) {
              return self2.produce(base22, (draft) => recipe.call(this, draft, ...args));
            };
          }
          if (typeof recipe !== "function")
            die(6);
          if (patchListener !== void 0 && typeof patchListener !== "function")
            die(7);
          let result;
          if (isDraftable(base2)) {
            const scope2 = enterScope(this);
            const proxy = createProxy(base2, void 0);
            let hasError = true;
            try {
              result = recipe(proxy);
              hasError = false;
            } finally {
              if (hasError)
                revokeScope(scope2);
              else
                leaveScope(scope2);
            }
            usePatchesInScope(scope2, patchListener);
            return processResult(result, scope2);
          } else if (!base2 || typeof base2 !== "object") {
            result = recipe(base2);
            if (result === void 0)
              result = base2;
            if (result === NOTHING)
              result = void 0;
            if (this.autoFreeze_)
              freeze(result, true);
            if (patchListener) {
              const p2 = [];
              const ip = [];
              getPlugin("Patches").generateReplacementPatches_(base2, result, p2, ip);
              patchListener(p2, ip);
            }
            return result;
          } else
            die(1, base2);
        };
        this.produceWithPatches = (base2, recipe) => {
          if (typeof base2 === "function") {
            return (state, ...args) => this.produceWithPatches(state, (draft) => base2(draft, ...args));
          }
          let patches, inversePatches;
          const result = this.produce(base2, recipe, (p2, ip) => {
            patches = p2;
            inversePatches = ip;
          });
          return [result, patches, inversePatches];
        };
        if (typeof (config2 == null ? void 0 : config2.autoFreeze) === "boolean")
          this.setAutoFreeze(config2.autoFreeze);
        if (typeof (config2 == null ? void 0 : config2.useStrictShallowCopy) === "boolean")
          this.setUseStrictShallowCopy(config2.useStrictShallowCopy);
      }
      createDraft(base2) {
        if (!isDraftable(base2))
          die(8);
        if (isDraft(base2))
          base2 = current(base2);
        const scope2 = enterScope(this);
        const proxy = createProxy(base2, void 0);
        proxy[DRAFT_STATE].isManual_ = true;
        leaveScope(scope2);
        return proxy;
      }
      finishDraft(draft, patchListener) {
        const state = draft && draft[DRAFT_STATE];
        if (!state || !state.isManual_)
          die(9);
        const { scope_: scope2 } = state;
        usePatchesInScope(scope2, patchListener);
        return processResult(void 0, scope2);
      }
      /**
       * Pass true to automatically freeze all copies created by Immer.
       *
       * By default, auto-freezing is enabled.
       */
      setAutoFreeze(value) {
        this.autoFreeze_ = value;
      }
      /**
       * Pass true to enable strict shallow copy.
       *
       * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
       */
      setUseStrictShallowCopy(value) {
        this.useStrictShallowCopy_ = value;
      }
      applyPatches(base2, patches) {
        let i2;
        for (i2 = patches.length - 1; i2 >= 0; i2--) {
          const patch = patches[i2];
          if (patch.path.length === 0 && patch.op === "replace") {
            base2 = patch.value;
            break;
          }
        }
        if (i2 > -1) {
          patches = patches.slice(i2 + 1);
        }
        const applyPatchesImpl = getPlugin("Patches").applyPatches_;
        if (isDraft(base2)) {
          return applyPatchesImpl(base2, patches);
        }
        return this.produce(
          base2,
          (draft) => applyPatchesImpl(draft, patches)
        );
      }
    };
    function createProxy(value, parent) {
      const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
      const scope2 = parent ? parent.scope_ : getCurrentScope();
      scope2.drafts_.push(draft);
      return draft;
    }
    function current(value) {
      if (!isDraft(value))
        die(10, value);
      return currentImpl(value);
    }
    function currentImpl(value) {
      if (!isDraftable(value) || isFrozen(value))
        return value;
      const state = value[DRAFT_STATE];
      let copy2;
      if (state) {
        if (!state.modified_)
          return state.base_;
        state.finalized_ = true;
        copy2 = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
      } else {
        copy2 = shallowCopy(value, true);
      }
      each(copy2, (key, childValue) => {
        set(copy2, key, currentImpl(childValue));
      });
      if (state) {
        state.finalized_ = false;
      }
      return copy2;
    }
    var immer = new Immer2();
    var produce = immer.produce;
    immer.produceWithPatches.bind(
      immer
    );
    immer.setAutoFreeze.bind(immer);
    immer.setUseStrictShallowCopy.bind(immer);
    immer.applyPatches.bind(immer);
    immer.createDraft.bind(immer);
    immer.finishDraft.bind(immer);
    const names = ["xs", "sm", "md", "lg", "xl", "xxl"];
    const thresholds = {
      xs: 0,
      sm: 600,
      md: 960,
      lg: 1280,
      xl: 1920,
      xxl: 2560
    };
    class Display {
      /**
       * @param {number} width
       */
      constructor(width) {
        /**
         * @readonly
         * @type {number}
         */
        __publicField(this, "width");
        this.width = width;
      }
      /** @returns {BreakPointName} */
      get name() {
        for (let i2 = 0; i2 < names.length; i2++) {
          if (names[i2 + 1] && this.width < thresholds[names[i2 + 1]])
            return names[i2];
        }
        return "xxl";
      }
      /** @returns {boolean} */
      get xs() {
        return this.width < thresholds.sm;
      }
      /** @returns {boolean} */
      get sm() {
        return this.width >= thresholds.sm && this.width < thresholds.md;
      }
      /** @returns {boolean} */
      get smAndDown() {
        return this.width < thresholds.md;
      }
      /** @returns {boolean} */
      get smAndUp() {
        return this.width >= thresholds.sm;
      }
      /** @returns {boolean} */
      get md() {
        return this.width >= thresholds.md && this.width < thresholds.lg;
      }
      /** @returns {boolean} */
      get mdAndDown() {
        return this.width < thresholds.lg;
      }
      /** @returns {boolean} */
      get mobile() {
        return this.mdAndDown;
      }
      /** @returns {boolean} */
      get mdAndUp() {
        return this.width >= thresholds.md;
      }
      /** @returns {boolean} */
      get lg() {
        return this.width >= thresholds.lg && this.width < thresholds.xl;
      }
      /** @returns {boolean} */
      get lgAndDown() {
        return this.width < thresholds.xl;
      }
      /** @returns {boolean} */
      get lgAndUp() {
        return this.width >= thresholds.lg;
      }
      /** @returns {boolean} */
      get xl() {
        return this.width >= thresholds.xl && this.width < thresholds.xxl;
      }
      /** @returns {boolean} */
      get xlAndDown() {
        return this.width < thresholds.xxl;
      }
      /** @returns {boolean} */
      get xlAndUp() {
        return this.width >= thresholds.xl;
      }
      /** @returns {boolean} */
      get xxl() {
        return this.width >= thresholds.xxl;
      }
    }
    function getChildDisplay(parentDisplay, colsObj) {
      if (!colsObj)
        return [parentDisplay, 12];
      let cols = colsObj.xs;
      if (parentDisplay.smAndUp && colsObj.sm !== void 0)
        cols = colsObj.sm;
      if (parentDisplay.mdAndUp && colsObj.md !== void 0)
        cols = colsObj.md;
      if (parentDisplay.lgAndUp && colsObj.lg !== void 0)
        cols = colsObj.lg;
      if (parentDisplay.xlAndUp && colsObj.xl !== void 0)
        cols = colsObj.xl;
      if (parentDisplay.xxl && colsObj.xxl !== void 0)
        cols = colsObj.xxl;
      const display = cols === 12 ? parentDisplay : new Display(Math.round(parentDisplay.width * (cols / 12)));
      return [display, cols];
    }
    function shallowProduceArray(previousArray = [], newArray = []) {
      if (!previousArray || !newArray || previousArray.length !== newArray.length)
        return newArray;
      for (let i2 = 0; i2 < previousArray.length; i2++) {
        if (previousArray[i2] !== newArray[i2])
          return newArray;
      }
      return previousArray;
    }
    function shallowProduceObject(previousObj = {}, newObj = {}) {
      if (!previousObj || !newObj)
        return newObj;
      const previousKeys = Object.keys(previousObj);
      const newKeys = Object.keys(newObj);
      if (previousKeys.length !== newKeys.length)
        return newObj;
      for (const key of previousKeys) {
        if (previousObj[key] !== newObj[key])
          return newObj;
      }
      return previousObj;
    }
    function shallowEqualArray(a1 = [], a2 = []) {
      if (a1.length !== a2.length)
        return false;
      for (let i2 = 0; i2 < a1.length; i2++) {
        if (a1[i2] !== a2[i2])
          return false;
      }
      return true;
    }
    const isDataEmpty = (data) => {
      if (data === "" || data === void 0)
        return true;
      if (Array.isArray(data) && !data.length)
        return true;
      if (typeof data === "object" && !Array.isArray(data) && !!data && Object.values(data).findIndex((prop2) => prop2 !== void 0) === -1)
        return true;
      return false;
    };
    const useDefaultData = (data, layout, options) => {
      if (options.defaultOn === "missing" && data === void 0)
        return true;
      if (options.defaultOn === "empty" && isDataEmpty(data))
        return true;
      return false;
    };
    const produceStateNode = produce((draft, key, fullKey, parentFullKey, dataPath, parentDataPath, skeleton, layout, width, cols, data, error2, validated, options, autofocus, props, children) => {
      draft.messages = layout.messages ? produceStateNodeMessages(draft.messages || {}, layout.messages, options) : options.messages;
      draft.key = key;
      draft.fullKey = fullKey;
      draft.parentFullKey = parentFullKey;
      draft.dataPath = dataPath;
      draft.parentDataPath = parentDataPath;
      draft.skeleton = skeleton;
      draft.layout = layout;
      draft.width = width;
      draft.options = options;
      draft.cols = cols;
      draft.data = data;
      draft.error = error2;
      draft.childError = children && children.findIndex((c) => c.error || c.childError) !== -1;
      draft.validated = validated;
      if (autofocus) {
        draft.autofocus = true;
        delete draft.autofocusChild;
      } else {
        delete draft.autofocus;
        const autofocusChild = children == null ? void 0 : children.find((c) => c.autofocus);
        if (autofocusChild)
          draft.autofocusChild = autofocusChild.key;
        else
          delete draft.autofocusChild;
      }
      draft.props = props;
      draft.children = children;
    });
    const produceStateNodeMessages = produce((draft, layoutMessages, options) => {
      Object.assign(draft, options.messages, layoutMessages);
    });
    const produceStateNodeData = produce((draft, parentDataPath, children, additionalPropertiesErrors, propertyKeys) => {
      if (propertyKeys) {
        for (const key of Object.keys(draft)) {
          if (!propertyKeys.includes(key))
            delete draft[key];
        }
      }
      if (children) {
        for (const child of children) {
          if (parentDataPath === child.dataPath) {
            if (child.data === void 0)
              continue;
            Object.assign(draft, child.data);
          } else {
            if (child.data === void 0)
              delete draft[child.key];
            else
              draft[child.key] = child.data;
            if (Array.isArray(draft)) {
              while (draft.length && draft[draft.length - 1] === void 0) {
                draft.pop();
              }
            }
          }
        }
      }
      if (additionalPropertiesErrors) {
        for (const error2 of additionalPropertiesErrors) {
          if (error2.instancePath !== parentDataPath)
            continue;
          if (error2.keyword === "additionalProperties") {
            delete draft[error2.params.additionalProperty];
          }
          if (error2.keyword === "unevaluatedProperties") {
            delete draft[error2.params.unevaluatedProperty];
          }
        }
      }
    });
    const produceNodeOptions = produce((draft, parentNodeOptions, nodeOptions = {}) => {
      for (const key in parentNodeOptions) {
        draft[key] = nodeOptions[key] ?? parentNodeOptions[key];
      }
      for (const key in nodeOptions) {
        draft[key] = nodeOptions[key];
      }
      for (const key in draft) {
        if (!(key in parentNodeOptions) && !(key in nodeOptions)) {
          delete draft[key];
        }
      }
    });
    const produceReadonlyArrayItemOptions = produce((draft) => {
      draft.readOnly = true;
      draft.summary = true;
    });
    const produceCompositeChildrenOptions = produce((draft, section) => {
      if (section.title && draft.titleDepth < 6)
        draft.titleDepth += 1;
    });
    const matchError = (error2, skeleton, dataPath, parentDataPath) => {
      var _a2, _b, _c;
      const originalError = ((_b = (_a2 = error2.params) == null ? void 0 : _a2.errors) == null ? void 0 : _b[0]) ?? error2;
      if (parentDataPath === originalError.instancePath && ((_c = originalError.params) == null ? void 0 : _c.missingProperty) === skeleton.key)
        return true;
      if (originalError.instancePath === dataPath && originalError.schemaPath === skeleton.pointer)
        return true;
      return false;
    };
    const matchChildError = (error2, skeleton, dataPath, parentDataPath) => {
      if (error2.instancePath.startsWith(dataPath) && !(typeof skeleton.key === "string" && skeleton.key.startsWith("$allOf")))
        return true;
      return false;
    };
    function evalExpression(expressions, expression, data, options, display, layout, rootData, parentData) {
      if (expression.ref === void 0)
        throw new Error("expression was not compiled : " + JSON.stringify(expression));
      const compiledExpression = expressions[expression.ref];
      return expression.pure ? compiledExpression(data, options, options.context, display, layout) : compiledExpression(data, options, options.context, display, layout, rootData, parentData);
    }
    const getCompObject = (normalizedLayout, options, compiledLayout, display, data, rootData, parentData) => {
      if (isSwitchStruct(normalizedLayout)) {
        for (const compObject of normalizedLayout.switch) {
          if (!compObject.if || !!evalExpression(compiledLayout.expressions, compObject.if, data, options, display, compObject, parentData, rootData)) {
            return compObject;
          }
        }
      } else {
        if (normalizedLayout.if) {
          if (evalExpression(compiledLayout.expressions, normalizedLayout.if, data, options, display, normalizedLayout, parentData, rootData)) {
            return normalizedLayout;
          }
        } else {
          return normalizedLayout;
        }
      }
      return { comp: "none" };
    };
    function createStateNode(context, parentOptions, compiledLayout, key, fullKey, parentFullKey, dataPath, parentDataPath, skeleton, childDefinition, parentDisplay, data, parentData, validationState, reusedNode) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j;
      let cacheKey = null;
      if (skeleton.pure && reusedNode) {
        cacheKey = [parentOptions, compiledLayout, fullKey, skeleton, childDefinition, parentDisplay.width, validationState, context.activeItems, context.initial, data];
        if (context.cacheKeys[fullKey] && shallowEqualArray(context.cacheKeys[fullKey], cacheKey))
          return reusedNode;
      }
      const normalizedLayout = childDefinition && childIsCompObject(childDefinition) ? childDefinition : compiledLayout.normalizedLayouts[skeleton.pointer];
      const layout = getCompObject(normalizedLayout, parentOptions, compiledLayout, parentDisplay, data, context.rootData, parentData);
      const [display, cols] = getChildDisplay(parentDisplay, (childDefinition == null ? void 0 : childDefinition.cols) ?? layout.cols);
      const options = layout.getOptions ? produceNodeOptions(
        (reusedNode == null ? void 0 : reusedNode.options) ?? /** @type {import('./types.js').StateNodeOptions} */
        {},
        parentOptions,
        evalExpression(compiledLayout.expressions, layout.getOptions, data, parentOptions, display, layout, context.rootData, parentData)
      ) : parentOptions;
      if (context.initial && parentOptions.autofocus && layout.autofocus && layout.comp !== "none") {
        context.autofocusTarget = fullKey;
      }
      let children;
      if (isCompositeLayout(layout)) {
        const objectData = (
          /** @type {Record<string, unknown>} */
          data ?? {}
        );
        const childrenOptions = produceCompositeChildrenOptions(options, layout);
        children = [];
        let focusChild2 = context.autofocusTarget === fullKey;
        for (let i2 = 0; i2 < layout.children.length; i2++) {
          const childLayout = layout.children[i2];
          const childSkeleton = ((_a2 = skeleton.children) == null ? void 0 : _a2.find((c) => c.key === childLayout.key)) ?? skeleton;
          const isSameData = typeof childLayout.key === "string" && childLayout.key.startsWith("$");
          const childFullKey = `${fullKey}/${childLayout.key}`;
          if (focusChild2)
            context.autofocusTarget = childFullKey;
          const child = createStateNode(
            context,
            childrenOptions,
            compiledLayout,
            childLayout.key,
            childFullKey,
            fullKey,
            isSameData ? dataPath : `${dataPath}/${childLayout.key}`,
            dataPath,
            childSkeleton,
            childLayout,
            display,
            isSameData ? objectData : objectData[childLayout.key],
            objectData,
            validationState,
            (_b = reusedNode == null ? void 0 : reusedNode.children) == null ? void 0 : _b[i2]
          );
          if (child.autofocus || child.autofocusChild !== void 0)
            focusChild2 = false;
          children.push(child);
        }
      }
      if (key === "$oneOf" && skeleton.childrenTrees) {
        const activeChildTreeIndex = fullKey in context.activeItems ? context.activeItems[fullKey] : (_c = skeleton.childrenTrees) == null ? void 0 : _c.findIndex((childTree) => compiledLayout.validates[childTree.root.pointer](data));
        if (activeChildTreeIndex !== -1) {
          context.activeItems = produce(context.activeItems, (draft) => {
            draft[fullKey] = activeChildTreeIndex;
          });
          const activeChildKey = `${fullKey}/${activeChildTreeIndex}`;
          if (context.autofocusTarget === fullKey)
            context.autofocusTarget = activeChildKey;
          const activeChildTree = skeleton.childrenTrees[activeChildTreeIndex];
          children = [
            createStateNode(
              context,
              options,
              compiledLayout,
              activeChildTreeIndex,
              activeChildKey,
              fullKey,
              dataPath,
              dataPath,
              activeChildTree.root,
              null,
              display,
              data,
              data,
              validationState,
              (_d = reusedNode == null ? void 0 : reusedNode.children) == null ? void 0 : _d[0]
            )
          ];
        }
      }
      if (layout.comp === "list") {
        const arrayData = (
          /** @type {unknown[]} */
          data ?? []
        );
        const childSkeleton = (
          /** @type {import('../index.js').SkeletonNode} */
          (_f = (_e = skeleton == null ? void 0 : skeleton.childrenTrees) == null ? void 0 : _e[0]) == null ? void 0 : _f.root
        );
        const listItemOptions = layout.listEditMode === "inline" ? options : produceReadonlyArrayItemOptions(options);
        children = [];
        let focusChild2 = context.autofocusTarget === fullKey;
        for (let i2 = 0; i2 < arrayData.length; i2++) {
          const itemData = arrayData[i2];
          const childFullKey = `${fullKey}/${i2}`;
          if (focusChild2)
            context.autofocusTarget = childFullKey;
          const child = createStateNode(
            context,
            layout.listEditMode === "inline-single" && context.activeItems[fullKey] === i2 ? options : listItemOptions,
            compiledLayout,
            i2,
            childFullKey,
            fullKey,
            `${dataPath}/${i2}`,
            dataPath,
            childSkeleton,
            null,
            display,
            itemData,
            arrayData,
            validationState,
            (_g = reusedNode == null ? void 0 : reusedNode.children) == null ? void 0 : _g[0]
          );
          if (child.autofocus || child.autofocusChild !== void 0)
            focusChild2 = false;
          children.push(child);
        }
      }
      const error2 = ((_h = context.errors) == null ? void 0 : _h.find((error3) => matchError(error3, skeleton, dataPath, parentDataPath))) ?? ((_i = context.errors) == null ? void 0 : _i.find((error3) => matchChildError(error3, skeleton, dataPath)));
      if (layout.comp !== "none") {
        if (error2)
          context.errors = (_j = context.errors) == null ? void 0 : _j.filter((error3) => !matchError(error3, skeleton, dataPath, parentDataPath) && !matchChildError(error3, skeleton, dataPath));
      }
      const validated = validationState.validatedForm || validationState.validatedChildren.includes(fullKey) || validationState.initialized === false && options.initialValidation === "always" || validationState.initialized === false && options.initialValidation === "withData" && !isDataEmpty(data);
      let nodeData = children ? produceStateNodeData(
        /** @type {Record<string, unknown>} */
        data ?? {},
        dataPath,
        children,
        context.additionalPropertiesErrors,
        [true, "unknown"].includes(options.removeAdditional) ? skeleton.propertyKeys : void 0
      ) : data;
      if (nodeData !== data) {
        if (Array.isArray(data) && Array.isArray(nodeData))
          nodeData = shallowProduceArray(data, nodeData);
        else if (typeof data === "object" && typeof nodeData === "object")
          nodeData = shallowProduceObject(data, nodeData);
      }
      if (layout.getConstData) {
        if (!context.rehydrate) {
          nodeData = evalExpression(compiledLayout.expressions, layout.getConstData, nodeData, options, display, layout, context.rootData, parentData);
        }
      } else {
        if (layout.getDefaultData && useDefaultData(nodeData, layout, options)) {
          if (!context.rehydrate) {
            nodeData = evalExpression(compiledLayout.expressions, layout.getDefaultData, nodeData, options, display, layout, context.rootData, parentData);
          }
        } else {
          if (isDataEmpty(nodeData)) {
            if (layout.nullable) {
              if (options.defaultOn !== "missing" || nodeData !== void 0) {
                nodeData = null;
              }
            } else if (options.defaultOn !== "missing") {
              nodeData = void 0;
            }
          }
        }
      }
      let props;
      if (layout.getProps) {
        props = evalExpression(compiledLayout.expressions, layout.getProps, nodeData, options, display, layout, context.rootData, parentData);
      }
      const autofocus = isFocusableLayout(layout) && !options.readOnly && !options.summary && context.autofocusTarget === fullKey;
      const node = produceStateNode(
        reusedNode ?? /** @type {import('./types.js').StateNode} */
        {},
        key,
        fullKey,
        parentFullKey,
        dataPath,
        parentDataPath,
        skeleton,
        layout,
        display.width,
        cols,
        nodeData,
        error2 == null ? void 0 : error2.message,
        validated,
        options,
        autofocus,
        props,
        children && shallowProduceArray(reusedNode == null ? void 0 : reusedNode.children, children)
      );
      if (cacheKey)
        context.cacheKeys[fullKey] = cacheKey;
      return node;
    }
    const producePatchedData = produce((draft, node, data) => {
      if (node.dataPath === node.parentDataPath) {
        Object.assign(draft, data);
      } else {
        draft[node.key] = data;
      }
    });
    const produceStateTree = produce(
      (draft, root, valid) => {
        draft.root = root;
        draft.valid = valid;
      }
    );
    function* traverseNodes(node) {
      yield node;
      if (node.children) {
        for (const child of node.children) {
          yield* traverseNodes(child);
        }
      }
    }
    function createStateTree(context, options, compiledLayout, skeleton, display, data, validationState, reusedStateTree) {
      const validate2 = compiledLayout.validates[skeleton.root.pointer];
      const valid = validate2(data);
      if (validate2.errors) {
        for (const error2 of validate2.errors) {
          if (error2.keyword !== "errorMessage")
            compiledLayout.localizeErrors([error2]);
        }
        context.errors = validate2.errors;
        if ([true, "error"].includes(options.removeAdditional)) {
          context.additionalPropertiesErrors = validate2.errors.filter((error2) => error2.keyword === "additionalProperties" || error2.keyword === "unevaluatedProperties");
        }
      }
      const root = createStateNode(
        context,
        options,
        compiledLayout,
        "",
        "",
        null,
        "",
        null,
        skeleton.root,
        null,
        display,
        data,
        null,
        validationState,
        reusedStateTree == null ? void 0 : reusedStateTree.root
      );
      context.nodes = [];
      context.files = [];
      for (const node of traverseNodes(root)) {
        context.nodes.push(node);
        if (node.data instanceof File) {
          context.files.push({ dataPath: node.dataPath, file: node.data });
        }
      }
      return produceStateTree(reusedStateTree ?? /** @type {import('./types.js').StateTree} */
      {}, root, valid);
    }
    const isSection = (node) => !!node && node.layout.comp === "section";
    const isItemsNode = (node) => !!node && isItemsLayout(node.layout);
    const logDataBinding = debug("jl:data-binding");
    const mitt = (
      /** @type {typeof mittModule.default} */
      mittModule
    );
    function fillOptions(partialOptions, compiledLayout) {
      const messages = { ...compiledLayout.messages };
      if (partialOptions.messages)
        Object.assign(messages, partialOptions.messages);
      return {
        context: {},
        width: 1e3,
        readOnly: false,
        summary: false,
        density: "default",
        titleDepth: 2,
        validateOn: "input",
        initialValidation: "withData",
        defaultOn: "empty",
        removeAdditional: "error",
        autofocus: false,
        ...partialOptions,
        messages
      };
    }
    class StatefulLayout {
      /**
       * @param {import("../index.js").CompiledLayout} compiledLayout
       * @param {import("../index.js").SkeletonTree} skeletonTree
       * @param {Partial<StatefulLayoutOptions>} options
       * @param {unknown} [data]
       */
      constructor(compiledLayout, skeletonTree, options, data) {
        /**
         * @readonly
         * @type {import('mitt').Emitter<StatefulLayoutEvents>}
         */
        __publicField(this, "events");
        /**
         * @private
         * @readonly
         * @type {import('../index.js').CompiledLayout}
         */
        __publicField(this, "_compiledLayout");
        /**
         * @private
         * @type {StateTree}
         */
        // @ts-ignore
        __publicField(this, "_stateTree");
        /**
         * @readonly
         * @type {import('../index.js').SkeletonTree}
         */
        __publicField(this, "skeletonTree");
        /**
         * @private
         * @type {Display}
         */
        // @ts-ignore
        __publicField(this, "_display");
        /**
         * @private
         * @type {import('./types.js').ValidationState}
         */
        // @ts-ignore
        __publicField(this, "_validationState");
        /**
         * @private
         * @type {StatefulLayoutOptions}
         */
        // @ts-ignore
        __publicField(this, "_options");
        /**
         * @private
         * @type {unknown}
         */
        __publicField(this, "_data");
        /**
         * @private
         * @type {CreateStateTreeContext}
         */
        // @ts-ignore
        __publicField(this, "_lastCreateStateTreeContext");
        /**
         * @private
         * @type {string | null}
         */
        __publicField(this, "_autofocusTarget");
        /**
         * @private
         * @type {string | null}
         */
        __publicField(this, "_previousAutofocusTarget");
        /**
         * @type {FileRef[]}
         */
        __publicField(this, "files", []);
        /**
         * @private
         * @param {StateNode} node
         * @param {import('@json-layout/vocabulary').Expression} expression
         * @param {any} data
         * @returns {any}
         */
        __publicField(this, "evalNodeExpression", (node, expression, data) => {
          const parentNode = this._lastCreateStateTreeContext.nodes.find((n) => n.fullKey === node.parentFullKey);
          const parentData = parentNode ? parentNode.data : null;
          return evalExpression(this.compiledLayout.expressions, expression, data, node.options, new Display(node.width), node.layout, parentData, this._data);
        });
        /**
         * @type {Record<string, number>}
         */
        __publicField(this, "activeItems");
        this._compiledLayout = compiledLayout;
        this.skeletonTree = skeletonTree;
        this.events = mitt();
        this.prepareOptions(options);
        this._autofocusTarget = this.options.autofocus ? "" : null;
        this._previousAutofocusTarget = null;
        this._data = data;
        this.initValidationState();
        this.activeItems = {};
        this.updateState();
        this.handleAutofocus();
      }
      get compiledLayout() {
        return this._compiledLayout;
      }
      get stateTree() {
        return this._stateTree;
      }
      get display() {
        return this._display;
      }
      /**
       * @returns {import('./types.js').ValidationState}
       */
      get validationState() {
        return this._validationState;
      }
      /**
       * @private
       * @param {Partial<import('./types.js').ValidationState>} validationState
       */
      set validationState(validationState) {
        this._validationState = {
          initialized: validationState.initialized ?? this._validationState.initialized ?? false,
          validatedForm: validationState.validatedForm ?? this._validationState.validatedForm ?? false,
          validatedChildren: validationState.validatedChildren ?? this._validationState.validatedChildren ?? []
        };
        this.updateState();
      }
      /**
       * @returns {StatefulLayoutOptions}
       */
      get options() {
        return this._options;
      }
      /**
       * @param {Partial<StatefulLayoutOptions>} options
       */
      set options(options) {
        this.prepareOptions(options);
        this.updateState();
      }
      get data() {
        return this._data;
      }
      set data(data) {
        logDataBinding("apply main data setter", data);
        this._data = data;
        this.updateState();
      }
      /**
       * @private
       * @param {Partial<StatefulLayoutOptions>} options
       */
      prepareOptions(options) {
        this._options = fillOptions(options, this.compiledLayout);
        this._display = this._display && this._display.width === this._options.width ? this._display : new Display(this._options.width);
      }
      /**
       * @private
       */
      initValidationState() {
        const initialValidation = this.options.initialValidation === "always";
        this._validationState = {
          initialized: initialValidation,
          validatedForm: initialValidation,
          validatedChildren: []
        };
      }
      /**
       * @private
       */
      updateState() {
        this.createStateTree();
        let nbIter = 0;
        while (this._data !== this._stateTree.root.data || this._autofocusTarget !== this._lastCreateStateTreeContext.autofocusTarget) {
          nbIter += 1;
          if (nbIter > 100) {
            console.error("too many iterations in updateState, the data is probably not stable", this._data, this._stateTree.root.data);
            throw new Error("too many iterations in updateState, the data is probably not stable");
          }
          logDataBinding("hydrating state tree changed the data, do it again", this._data, this._stateTree.root.data);
          this._data = this._stateTree.root.data;
          this._autofocusTarget = this._lastCreateStateTreeContext.autofocusTarget;
          this.createStateTree(true);
        }
        logDataBinding("emit update event", this._data, this._stateTree);
        this.events.emit("update", this);
      }
      /**
       * @private
       * @param {boolean} rehydrate
       */
      createStateTree(rehydrate = false) {
        var _a2;
        const createStateTreeContext = {
          activeItems: this.activeItems,
          autofocusTarget: this._autofocusTarget,
          initial: !this._lastCreateStateTreeContext,
          rehydrate,
          cacheKeys: ((_a2 = this._lastCreateStateTreeContext) == null ? void 0 : _a2.cacheKeys) ?? {},
          rootData: this._data,
          files: [],
          nodes: []
        };
        this._stateTree = createStateTree(
          createStateTreeContext,
          this._options,
          this._compiledLayout,
          this.skeletonTree,
          this._display,
          this._data,
          this._validationState,
          this._stateTree
        );
        this._lastCreateStateTreeContext = createStateTreeContext;
        if (!this.validationState.initialized) {
          this._validationState = {
            initialized: true,
            validatedForm: this._validationState.validatedForm,
            validatedChildren: createStateTreeContext.nodes.filter((n) => n.validated).map((n) => n.fullKey)
          };
        }
        this.activeItems = createStateTreeContext.activeItems;
        this.files = shallowProduceArray(this.files, createStateTreeContext.files);
      }
      validate() {
        this.validationState = { validatedForm: true };
      }
      resetValidation() {
        this.initValidationState();
        this.updateState();
      }
      /**
       * @returns {boolean}
       */
      get valid() {
        return this.stateTree.valid;
      }
      /**
       * @returns {string[]}
       */
      get errors() {
        return this._lastCreateStateTreeContext.nodes.filter((n) => !!n.error).map((n) => (
          /** @type {string} */
          n.error
        ));
      }
      /**
       * @returns {boolean}
       */
      get hasHiddenError() {
        return this._lastCreateStateTreeContext.nodes.findIndex((node) => node.error && !node.validated) !== -1;
      }
      /**
       * @param {StateNode} node
       * @param {unknown} data
       * @param {number} [activateKey]
       */
      input(node, data, activateKey) {
        logDataBinding("received input event from node", node, data);
        const transformedData = node.layout.transformData && this.evalNodeExpression(node, node.layout.transformData, data);
        if (isFileLayout(node.layout)) {
          if (transformedData) {
            data.toJSON = () => transformedData;
          } else if (data instanceof File) {
            const fileJSON = { name: data.name, size: data.size, type: data.type };
            data.toJSON = () => fileJSON;
          } else if (Array.isArray(data)) {
            for (const file of data) {
              const fileJSON = { name: file.name, size: file.size, type: file.type };
              file.toJSON = () => fileJSON;
            }
          }
        } else if (transformedData) {
          data = transformedData;
        }
        if (node.options.validateOn === "input" && !this.validationState.validatedChildren.includes(node.fullKey)) {
          this.validationState = { validatedChildren: this.validationState.validatedChildren.concat([node.fullKey]) };
        }
        if (activateKey !== void 0) {
          this.activeItems = produce(this.activeItems, (draft) => {
            draft[node.fullKey] = activateKey;
          });
          this._autofocusTarget = node.fullKey + "/" + activateKey;
        }
        if (node.parentFullKey === null) {
          this.data = data;
          this.events.emit("input", this.data);
          return;
        }
        const parentNode = this._lastCreateStateTreeContext.nodes.find((p2) => p2.fullKey === node.parentFullKey);
        if (!parentNode)
          throw new Error(`parent with key "${node.parentFullKey}" not found`);
        const newParentValue = producePatchedData(parentNode.data ?? (typeof node.key === "number" ? [] : {}), node, data);
        this.input(parentNode, newParentValue);
        if (activateKey !== void 0) {
          this.handleAutofocus();
        }
      }
      /**
       * @param {StateNode} node
       */
      blur(node) {
        logDataBinding("received blur event from node", node);
        if ((node.options.validateOn === "input" || node.options.validateOn === "blur") && !this.validationState.validatedChildren.includes(node.fullKey)) {
          this.validationState = { validatedChildren: this.validationState.validatedChildren.concat([node.fullKey]) };
        }
      }
      /**
       * @param {StateNode} node
       */
      validateNodeRecurse(node) {
        this.validationState = { validatedChildren: this.validationState.validatedChildren.concat([node.fullKey]) };
        if (node.children) {
          for (const child of node.children) {
            this.validateNodeRecurse(child);
          }
        }
      }
      /**
       * @private
       * @param {StateNode} node
       * @param {string} q
       * @returns {Promise<[import('@json-layout/vocabulary').SelectItems, boolean]>}
       */
      async getSourceItems(node, q = "") {
        var _a2;
        if (!isItemsNode(node))
          throw new Error("node is not a component with an items list");
        if (node.layout.items)
          return [node.layout.items, false];
        let rawItems;
        let appliedQ = false;
        if (node.layout.getItems && isGetItemsExpression(node.layout.getItems)) {
          rawItems = this.evalNodeExpression(node, node.layout.getItems, null);
        }
        if (node.layout.getItems && isGetItemsFetch(node.layout.getItems)) {
          const url = new URL(this.evalNodeExpression(node, node.layout.getItems.url, null));
          let qSearchParam = node.layout.getItems.qSearchParam;
          if (!qSearchParam) {
            for (const searchParam of url.searchParams.entries()) {
              if (searchParam[1] === "{q}")
                qSearchParam = searchParam[0];
            }
          }
          if (qSearchParam) {
            appliedQ = true;
            if (q)
              url.searchParams.set(qSearchParam, q);
            else
              url.searchParams.delete(qSearchParam);
          }
          rawItems = await (await fetch(url)).json();
        }
        if (rawItems) {
          if ((_a2 = node.layout.getItems) == null ? void 0 : _a2.itemsResults) {
            rawItems = this.evalNodeExpression(node, node.layout.getItems.itemsResults, rawItems);
          }
          if (!Array.isArray(rawItems))
            throw new Error(`getItems didn't return an array for node ${node.fullKey}, you can define itemsResults to extract the array`);
          const items2 = rawItems.map((rawItem) => {
            var _a3, _b, _c, _d, _e, _f, _g, _h, _i;
            const item = {};
            if (typeof rawItem === "object") {
              item.value = ((_a3 = node.layout.getItems) == null ? void 0 : _a3.itemValue) ? this.evalNodeExpression(node, node.layout.getItems.itemValue, rawItem) : ((_b = node.layout.getItems) == null ? void 0 : _b.returnObjects) ? rawItem : rawItem.value;
              item.key = ((_c = node.layout.getItems) == null ? void 0 : _c.itemKey) ? this.evalNodeExpression(node, node.layout.getItems.itemKey, rawItem) : rawItem.key;
              item.title = ((_d = node.layout.getItems) == null ? void 0 : _d.itemTitle) ? this.evalNodeExpression(node, node.layout.getItems.itemTitle, rawItem) : rawItem.title;
              item.value = item.value ?? item.key;
              item.key = item.key ?? item.value + "";
              item.title = item.title ?? item.key;
              if (!item.icon && rawItem.icon)
                item.icon = rawItem.icon;
            } else {
              item.value = ((_e = node.layout.getItems) == null ? void 0 : _e.itemValue) ? this.evalNodeExpression(node, node.layout.getItems.itemValue, rawItem) : rawItem;
              item.key = ((_f = node.layout.getItems) == null ? void 0 : _f.itemKey) ? this.evalNodeExpression(node, node.layout.getItems.itemKey, rawItem) : item.value;
              item.title = ((_g = node.layout.getItems) == null ? void 0 : _g.itemTitle) ? this.evalNodeExpression(node, node.layout.getItems.itemTitle, rawItem) : item.value;
            }
            if ((_h = node.layout.getItems) == null ? void 0 : _h.itemIcon)
              item.icon = this.evalNodeExpression(node, (_i = node.layout.getItems) == null ? void 0 : _i.itemIcon, rawItem);
            return (
              /** @type {import('@json-layout/vocabulary').SelectItem} */
              item
            );
          });
          return [items2, appliedQ];
        }
        throw new Error(`node ${node.fullKey} is missing items or getItems parameters`);
      }
      /**
       * @param {StateNode} node
       * @param {string} q
       * @returns {Promise<import('@json-layout/vocabulary').SelectItems>}
       */
      async getItems(node, q = "") {
        const [sourceItems, appliedQ] = await this.getSourceItems(node, q);
        if (q && !appliedQ)
          return sourceItems.filter((item) => item.title.toLowerCase().includes(q.toLowerCase()));
        return sourceItems;
      }
      /**
       * @param {StateNode} node
       * @param {number} key
       */
      activateItem(node, key) {
        this.activeItems = produce(this.activeItems, (draft) => {
          draft[node.fullKey] = key;
        });
        this._autofocusTarget = node.fullKey + "/" + key;
        if (node.key === "$oneOf") {
          this.input(node, void 0);
        } else {
          this.updateState();
        }
        this.handleAutofocus();
      }
      /**
       * @param {StateNode} node
       */
      deactivateItem(node) {
        this.activeItems = produce(this.activeItems, (draft) => {
          delete draft[node.fullKey];
        });
        this.updateState();
      }
      handleAutofocus() {
        const autofocusTarget = this._autofocusTarget;
        if (autofocusTarget !== null && this._autofocusTarget !== this._previousAutofocusTarget) {
          this._previousAutofocusTarget = autofocusTarget;
          setTimeout(() => {
            logDataBinding("emit autofocus event", autofocusTarget);
            this.events.emit("autofocus", autofocusTarget);
          });
        }
      }
    }
    const defaultFilter = (value, query, item) => {
      if (value == null || query == null)
        return -1;
      return value.toString().toLocaleLowerCase().indexOf(query.toString().toLocaleLowerCase());
    };
    const makeFilterProps = propsFactory({
      customFilter: Function,
      customKeyFilter: Object,
      filterKeys: [Array, String],
      filterMode: {
        type: String,
        default: "intersection"
      },
      noFilter: Boolean
    }, "filter");
    function filterItems(items2, query, options) {
      var _a2;
      const array = [];
      const filter = (options == null ? void 0 : options.default) ?? defaultFilter;
      const keys2 = (options == null ? void 0 : options.filterKeys) ? wrapInArray(options.filterKeys) : false;
      const customFiltersLength = Object.keys((options == null ? void 0 : options.customKeyFilter) ?? {}).length;
      if (!(items2 == null ? void 0 : items2.length))
        return array;
      loop:
        for (let i2 = 0; i2 < items2.length; i2++) {
          const [item, transformed = item] = wrapInArray(items2[i2]);
          const customMatches = {};
          const defaultMatches = {};
          let match = -1;
          if (query && !(options == null ? void 0 : options.noFilter)) {
            if (typeof item === "object") {
              const filterKeys = keys2 || Object.keys(transformed);
              for (const key of filterKeys) {
                const value = getPropertyFromItem(transformed, key, transformed);
                const keyFilter = (_a2 = options == null ? void 0 : options.customKeyFilter) == null ? void 0 : _a2[key];
                match = keyFilter ? keyFilter(value, query, item) : filter(value, query, item);
                if (match !== -1 && match !== false) {
                  if (keyFilter)
                    customMatches[key] = match;
                  else
                    defaultMatches[key] = match;
                } else if ((options == null ? void 0 : options.filterMode) === "every") {
                  continue loop;
                }
              }
            } else {
              match = filter(item, query, item);
              if (match !== -1 && match !== false) {
                defaultMatches.title = match;
              }
            }
            const defaultMatchesLength = Object.keys(defaultMatches).length;
            const customMatchesLength = Object.keys(customMatches).length;
            if (!defaultMatchesLength && !customMatchesLength)
              continue;
            if ((options == null ? void 0 : options.filterMode) === "union" && customMatchesLength !== customFiltersLength && !defaultMatchesLength)
              continue;
            if ((options == null ? void 0 : options.filterMode) === "intersection" && (customMatchesLength !== customFiltersLength || !defaultMatchesLength))
              continue;
          }
          array.push({
            index: i2,
            matches: {
              ...defaultMatches,
              ...customMatches
            }
          });
        }
      return array;
    }
    function useFilter(props, items2, query, options) {
      const filteredItems = ref$1([]);
      const filteredMatches = ref$1(/* @__PURE__ */ new Map());
      const transformedItems = computed(() => (options == null ? void 0 : options.transform) ? unref(items2).map((item) => [item, options.transform(item)]) : unref(items2));
      watchEffect(() => {
        const _query = typeof query === "function" ? query() : unref(query);
        const strQuery = typeof _query !== "string" && typeof _query !== "number" ? "" : String(_query);
        const results = filterItems(transformedItems.value, strQuery, {
          customKeyFilter: {
            ...props.customKeyFilter,
            ...unref(options == null ? void 0 : options.customKeyFilter)
          },
          default: props.customFilter,
          filterKeys: props.filterKeys,
          filterMode: props.filterMode,
          noFilter: props.noFilter
        });
        const originalItems = unref(items2);
        const _filteredItems = [];
        const _filteredMatches = /* @__PURE__ */ new Map();
        results.forEach((_ref) => {
          let {
            index,
            matches
          } = _ref;
          const item = originalItems[index];
          _filteredItems.push(item);
          _filteredMatches.set(item.value, matches);
        });
        filteredItems.value = _filteredItems;
        filteredMatches.value = _filteredMatches;
      });
      function getMatches(item) {
        return filteredMatches.value.get(item.value);
      }
      return {
        filteredItems,
        filteredMatches,
        getMatches
      };
    }
    function highlightResult$1(text2, matches, length) {
      if (matches == null)
        return text2;
      if (Array.isArray(matches))
        throw new Error("Multiple matches is not implemented");
      return typeof matches === "number" && ~matches ? createVNode(Fragment, null, [createVNode("span", {
        "class": "v-autocomplete__unmask"
      }, [text2.substr(0, matches)]), createVNode("span", {
        "class": "v-autocomplete__mask"
      }, [text2.substr(matches, length)]), createVNode("span", {
        "class": "v-autocomplete__unmask"
      }, [text2.substr(matches + length)])]) : text2;
    }
    const makeVAutocompleteProps = propsFactory({
      autoSelectFirst: {
        type: [Boolean, String]
      },
      clearOnSelect: Boolean,
      search: String,
      ...makeFilterProps({
        filterKeys: ["title"]
      }),
      ...makeSelectProps(),
      ...omit$1(makeVTextFieldProps({
        modelValue: null,
        role: "combobox"
      }), ["validationValue", "dirty", "appendInnerIcon"]),
      ...makeTransitionProps({
        transition: false
      })
    }, "VAutocomplete");
    const VAutocomplete = genericComponent()({
      name: "VAutocomplete",
      props: makeVAutocompleteProps(),
      emits: {
        "update:focused": (focused) => true,
        "update:search": (value) => true,
        "update:modelValue": (value) => true,
        "update:menu": (value) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          t
        } = useLocale();
        const vTextFieldRef = ref$1();
        const isFocused = shallowRef(false);
        const isPristine = shallowRef(true);
        const listHasFocus = shallowRef(false);
        const vMenuRef = ref$1();
        const vVirtualScrollRef = ref$1();
        const _menu = useProxiedModel(props, "menu");
        const menu = computed({
          get: () => _menu.value,
          set: (v) => {
            var _a2;
            if (_menu.value && !v && ((_a2 = vMenuRef.value) == null ? void 0 : _a2.openChildren))
              return;
            _menu.value = v;
          }
        });
        const selectionIndex = shallowRef(-1);
        const color = computed(() => {
          var _a2;
          return (_a2 = vTextFieldRef.value) == null ? void 0 : _a2.color;
        });
        const label = computed(() => menu.value ? props.closeText : props.openText);
        const {
          items: items2,
          transformIn,
          transformOut
        } = useItems(props);
        const {
          textColorClasses,
          textColorStyles
        } = useTextColor(color);
        const search = useProxiedModel(props, "search", "");
        const model = useProxiedModel(props, "modelValue", [], (v) => transformIn(v === null ? [null] : wrapInArray(v)), (v) => {
          const transformed = transformOut(v);
          return props.multiple ? transformed : transformed[0] ?? null;
        });
        const counterValue = computed(() => {
          return typeof props.counterValue === "function" ? props.counterValue(model.value) : typeof props.counterValue === "number" ? props.counterValue : model.value.length;
        });
        const form = useForm();
        const {
          filteredItems,
          getMatches
        } = useFilter(props, items2, () => isPristine.value ? "" : search.value);
        const displayItems = computed(() => {
          if (props.hideSelected) {
            return filteredItems.value.filter((filteredItem) => !model.value.some((s) => s.value === filteredItem.value));
          }
          return filteredItems.value;
        });
        const selectedValues = computed(() => model.value.map((selection) => selection.props.value));
        const highlightFirst = computed(() => {
          var _a2;
          const selectFirst = props.autoSelectFirst === true || props.autoSelectFirst === "exact" && search.value === ((_a2 = displayItems.value[0]) == null ? void 0 : _a2.title);
          return selectFirst && displayItems.value.length > 0 && !isPristine.value && !listHasFocus.value;
        });
        const menuDisabled = computed(() => props.hideNoData && !displayItems.value.length || props.readonly || (form == null ? void 0 : form.isReadonly.value));
        const listRef = ref$1();
        const {
          onListScroll,
          onListKeydown
        } = useScrolling(listRef, vTextFieldRef);
        function onClear(e) {
          if (props.openOnClear) {
            menu.value = true;
          }
          search.value = "";
        }
        function onMousedownControl() {
          if (menuDisabled.value)
            return;
          menu.value = true;
        }
        function onMousedownMenuIcon(e) {
          if (menuDisabled.value)
            return;
          if (isFocused.value) {
            e.preventDefault();
            e.stopPropagation();
          }
          menu.value = !menu.value;
        }
        function onKeydown(e) {
          var _a2, _b, _c;
          if (props.readonly || (form == null ? void 0 : form.isReadonly.value))
            return;
          const selectionStart = vTextFieldRef.value.selectionStart;
          const length = model.value.length;
          if (selectionIndex.value > -1 || ["Enter", "ArrowDown", "ArrowUp"].includes(e.key)) {
            e.preventDefault();
          }
          if (["Enter", "ArrowDown"].includes(e.key)) {
            menu.value = true;
          }
          if (["Escape"].includes(e.key)) {
            menu.value = false;
          }
          if (highlightFirst.value && ["Enter", "Tab"].includes(e.key)) {
            select(displayItems.value[0]);
          }
          if (e.key === "ArrowDown" && highlightFirst.value) {
            (_a2 = listRef.value) == null ? void 0 : _a2.focus("next");
          }
          if (!props.multiple)
            return;
          if (["Backspace", "Delete"].includes(e.key)) {
            if (selectionIndex.value < 0) {
              if (e.key === "Backspace" && !search.value) {
                selectionIndex.value = length - 1;
              }
              return;
            }
            const originalSelectionIndex = selectionIndex.value;
            const selectedItem = model.value[selectionIndex.value];
            if (selectedItem && !selectedItem.props.disabled)
              select(selectedItem);
            selectionIndex.value = originalSelectionIndex >= length - 1 ? length - 2 : originalSelectionIndex;
          }
          if (e.key === "ArrowLeft") {
            if (selectionIndex.value < 0 && selectionStart > 0)
              return;
            const prev = selectionIndex.value > -1 ? selectionIndex.value - 1 : length - 1;
            if (model.value[prev]) {
              selectionIndex.value = prev;
            } else {
              selectionIndex.value = -1;
              vTextFieldRef.value.setSelectionRange((_b = search.value) == null ? void 0 : _b.length, (_c = search.value) == null ? void 0 : _c.length);
            }
          }
          if (e.key === "ArrowRight") {
            if (selectionIndex.value < 0)
              return;
            const next2 = selectionIndex.value + 1;
            if (model.value[next2]) {
              selectionIndex.value = next2;
            } else {
              selectionIndex.value = -1;
              vTextFieldRef.value.setSelectionRange(0, 0);
            }
          }
        }
        function onChange(e) {
          if (matchesSelector(vTextFieldRef.value, ":autofill") || matchesSelector(vTextFieldRef.value, ":-webkit-autofill")) {
            const item = items2.value.find((item2) => item2.title === e.target.value);
            if (item) {
              select(item);
            }
          }
        }
        function onAfterLeave() {
          var _a2;
          if (isFocused.value) {
            isPristine.value = true;
            (_a2 = vTextFieldRef.value) == null ? void 0 : _a2.focus();
          }
        }
        function onFocusin(e) {
          isFocused.value = true;
          setTimeout(() => {
            listHasFocus.value = true;
          });
        }
        function onFocusout(e) {
          listHasFocus.value = false;
        }
        function onUpdateModelValue(v) {
          if (v == null || v === "" && !props.multiple)
            model.value = [];
        }
        const isSelecting = shallowRef(false);
        function select(item) {
          if (item.props.disabled)
            return;
          const index = model.value.findIndex((selection) => props.valueComparator(selection.value, item.value));
          const add2 = index === -1;
          if (props.multiple) {
            if (add2) {
              model.value = [...model.value, item];
            } else {
              const value = [...model.value];
              value.splice(index, 1);
              model.value = value;
            }
            if (props.clearOnSelect) {
              search.value = "";
            }
          } else {
            model.value = add2 ? [item] : [];
            isSelecting.value = true;
            search.value = add2 ? item.title : "";
            menu.value = false;
            isPristine.value = true;
            nextTick(() => isSelecting.value = false);
          }
        }
        watch(isFocused, (val, oldVal) => {
          var _a2;
          if (val === oldVal)
            return;
          if (val) {
            isSelecting.value = true;
            search.value = props.multiple ? "" : String(((_a2 = model.value.at(-1)) == null ? void 0 : _a2.props.title) ?? "");
            isPristine.value = true;
            nextTick(() => isSelecting.value = false);
          } else {
            if (!props.multiple && search.value == null)
              model.value = [];
            else if (highlightFirst.value && !listHasFocus.value && !model.value.some((_ref2) => {
              let {
                value
              } = _ref2;
              return value === displayItems.value[0].value;
            })) {
              select(displayItems.value[0]);
            }
            menu.value = false;
            search.value = "";
            selectionIndex.value = -1;
          }
        });
        watch(search, (val) => {
          if (!isFocused.value || isSelecting.value)
            return;
          if (val)
            menu.value = true;
          isPristine.value = !val;
        });
        watch(menu, () => {
          if (!props.hideSelected && menu.value && model.value.length) {
            const index = displayItems.value.findIndex((item) => model.value.some((s) => item.value === s.value));
            IN_BROWSER && window.requestAnimationFrame(() => {
              var _a2;
              index >= 0 && ((_a2 = vVirtualScrollRef.value) == null ? void 0 : _a2.scrollToIndex(index));
            });
          }
        });
        watch(displayItems, (val, oldVal) => {
          if (!isFocused.value)
            return;
          if (!val.length && props.hideNoData) {
            menu.value = false;
          }
          if (!oldVal.length && val.length) {
            menu.value = true;
          }
        });
        useRender(() => {
          const hasChips = !!(props.chips || slots.chip);
          const hasList = !!(!props.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
          const isDirty = model.value.length > 0;
          const textFieldProps = VTextField.filterProps(props);
          return createVNode(VTextField, mergeProps({
            "ref": vTextFieldRef
          }, textFieldProps, {
            "modelValue": search.value,
            "onUpdate:modelValue": [($event) => search.value = $event, onUpdateModelValue],
            "focused": isFocused.value,
            "onUpdate:focused": ($event) => isFocused.value = $event,
            "validationValue": model.externalValue,
            "counterValue": counterValue.value,
            "dirty": isDirty,
            "onChange": onChange,
            "class": ["v-autocomplete", `v-autocomplete--${props.multiple ? "multiple" : "single"}`, {
              "v-autocomplete--active-menu": menu.value,
              "v-autocomplete--chips": !!props.chips,
              "v-autocomplete--selection-slot": !!slots.selection,
              "v-autocomplete--selecting-index": selectionIndex.value > -1
            }, props.class],
            "style": props.style,
            "readonly": props.readonly,
            "placeholder": isDirty ? void 0 : props.placeholder,
            "onClick:clear": onClear,
            "onMousedown:control": onMousedownControl,
            "onKeydown": onKeydown
          }), {
            ...slots,
            default: () => createVNode(Fragment, null, [createVNode(VMenu, mergeProps({
              "ref": vMenuRef,
              "modelValue": menu.value,
              "onUpdate:modelValue": ($event) => menu.value = $event,
              "activator": "parent",
              "contentClass": "v-autocomplete__content",
              "disabled": menuDisabled.value,
              "eager": props.eager,
              "maxHeight": 310,
              "openOnClick": false,
              "closeOnContentClick": false,
              "transition": props.transition,
              "onAfterLeave": onAfterLeave
            }, props.menuProps), {
              default: () => [hasList && createVNode(VList, mergeProps({
                "ref": listRef,
                "selected": selectedValues.value,
                "selectStrategy": props.multiple ? "independent" : "single-independent",
                "onMousedown": (e) => e.preventDefault(),
                "onKeydown": onListKeydown,
                "onFocusin": onFocusin,
                "onFocusout": onFocusout,
                "onScrollPassive": onListScroll,
                "tabindex": "-1",
                "aria-live": "polite",
                "color": props.itemColor ?? props.color
              }, props.listProps), {
                default: () => {
                  var _a2, _b, _c;
                  return [(_a2 = slots["prepend-item"]) == null ? void 0 : _a2.call(slots), !displayItems.value.length && !props.hideNoData && (((_b = slots["no-data"]) == null ? void 0 : _b.call(slots)) ?? createVNode(VListItem, {
                    "title": t(props.noDataText)
                  }, null)), createVNode(VVirtualScroll, {
                    "ref": vVirtualScrollRef,
                    "renderless": true,
                    "items": displayItems.value
                  }, {
                    default: (_ref3) => {
                      var _a3;
                      let {
                        item,
                        index,
                        itemRef
                      } = _ref3;
                      const itemProps = mergeProps(item.props, {
                        ref: itemRef,
                        key: index,
                        active: highlightFirst.value && index === 0 ? true : void 0,
                        onClick: () => select(item)
                      });
                      return ((_a3 = slots.item) == null ? void 0 : _a3.call(slots, {
                        item,
                        index,
                        props: itemProps
                      })) ?? createVNode(VListItem, itemProps, {
                        prepend: (_ref4) => {
                          let {
                            isSelected
                          } = _ref4;
                          return createVNode(Fragment, null, [props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                            "key": item.value,
                            "modelValue": isSelected,
                            "ripple": false,
                            "tabindex": "-1"
                          }, null) : void 0, item.props.prependAvatar && createVNode(VAvatar, {
                            "image": item.props.prependAvatar
                          }, null), item.props.prependIcon && createVNode(VIcon, {
                            "icon": item.props.prependIcon
                          }, null)]);
                        },
                        title: () => {
                          var _a4, _b2;
                          return isPristine.value ? item.title : highlightResult$1(item.title, (_a4 = getMatches(item)) == null ? void 0 : _a4.title, ((_b2 = search.value) == null ? void 0 : _b2.length) ?? 0);
                        }
                      });
                    }
                  }), (_c = slots["append-item"]) == null ? void 0 : _c.call(slots)];
                }
              })]
            }), model.value.map((item, index) => {
              function onChipClose(e) {
                e.stopPropagation();
                e.preventDefault();
                select(item);
              }
              const slotProps = {
                "onClick:close": onChipClose,
                onMousedown(e) {
                  e.preventDefault();
                  e.stopPropagation();
                },
                modelValue: true,
                "onUpdate:modelValue": void 0
              };
              const hasSlot = hasChips ? !!slots.chip : !!slots.selection;
              const slotContent = hasSlot ? ensureValidVNode(hasChips ? slots.chip({
                item,
                index,
                props: slotProps
              }) : slots.selection({
                item,
                index
              })) : void 0;
              if (hasSlot && !slotContent)
                return void 0;
              return createVNode("div", {
                "key": item.value,
                "class": ["v-autocomplete__selection", index === selectionIndex.value && ["v-autocomplete__selection--selected", textColorClasses.value]],
                "style": index === selectionIndex.value ? textColorStyles.value : {}
              }, [hasChips ? !slots.chip ? createVNode(VChip, mergeProps({
                "key": "chip",
                "closable": props.closableChips,
                "size": "small",
                "text": item.title,
                "disabled": item.props.disabled
              }, slotProps), null) : createVNode(VDefaultsProvider, {
                "key": "chip-defaults",
                "defaults": {
                  VChip: {
                    closable: props.closableChips,
                    size: "small",
                    text: item.title
                  }
                }
              }, {
                default: () => [slotContent]
              }) : slotContent ?? createVNode("span", {
                "class": "v-autocomplete__selection-text"
              }, [item.title, props.multiple && index < model.value.length - 1 && createVNode("span", {
                "class": "v-autocomplete__selection-comma"
              }, [createTextVNode(",")])])]);
            })]),
            "append-inner": function() {
              var _a2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return createVNode(Fragment, null, [(_a2 = slots["append-inner"]) == null ? void 0 : _a2.call(slots, ...args), props.menuIcon ? createVNode(VIcon, {
                "class": "v-autocomplete__menu-icon",
                "icon": props.menuIcon,
                "onMousedown": onMousedownMenuIcon,
                "onClick": noop$1,
                "aria-label": t(label.value),
                "title": t(label.value)
              }, null) : void 0]);
            }
          });
        });
        return forwardRefs({
          isFocused,
          isPristine,
          menu,
          search,
          filteredItems,
          select
        }, vTextFieldRef);
      }
    });
    const handleGesture = (wrapper) => {
      const {
        touchstartX,
        touchendX,
        touchstartY,
        touchendY
      } = wrapper;
      const dirRatio = 0.5;
      const minDistance = 16;
      wrapper.offsetX = touchendX - touchstartX;
      wrapper.offsetY = touchendY - touchstartY;
      if (Math.abs(wrapper.offsetY) < dirRatio * Math.abs(wrapper.offsetX)) {
        wrapper.left && touchendX < touchstartX - minDistance && wrapper.left(wrapper);
        wrapper.right && touchendX > touchstartX + minDistance && wrapper.right(wrapper);
      }
      if (Math.abs(wrapper.offsetX) < dirRatio * Math.abs(wrapper.offsetY)) {
        wrapper.up && touchendY < touchstartY - minDistance && wrapper.up(wrapper);
        wrapper.down && touchendY > touchstartY + minDistance && wrapper.down(wrapper);
      }
    };
    function touchstart(event, wrapper) {
      var _a2;
      const touch = event.changedTouches[0];
      wrapper.touchstartX = touch.clientX;
      wrapper.touchstartY = touch.clientY;
      (_a2 = wrapper.start) == null ? void 0 : _a2.call(wrapper, {
        originalEvent: event,
        ...wrapper
      });
    }
    function touchend(event, wrapper) {
      var _a2;
      const touch = event.changedTouches[0];
      wrapper.touchendX = touch.clientX;
      wrapper.touchendY = touch.clientY;
      (_a2 = wrapper.end) == null ? void 0 : _a2.call(wrapper, {
        originalEvent: event,
        ...wrapper
      });
      handleGesture(wrapper);
    }
    function touchmove(event, wrapper) {
      var _a2;
      const touch = event.changedTouches[0];
      wrapper.touchmoveX = touch.clientX;
      wrapper.touchmoveY = touch.clientY;
      (_a2 = wrapper.move) == null ? void 0 : _a2.call(wrapper, {
        originalEvent: event,
        ...wrapper
      });
    }
    function createHandlers() {
      let value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const wrapper = {
        touchstartX: 0,
        touchstartY: 0,
        touchendX: 0,
        touchendY: 0,
        touchmoveX: 0,
        touchmoveY: 0,
        offsetX: 0,
        offsetY: 0,
        left: value.left,
        right: value.right,
        up: value.up,
        down: value.down,
        start: value.start,
        move: value.move,
        end: value.end
      };
      return {
        touchstart: (e) => touchstart(e, wrapper),
        touchend: (e) => touchend(e, wrapper),
        touchmove: (e) => touchmove(e, wrapper)
      };
    }
    function mounted(el2, binding) {
      var _a2;
      const value = binding.value;
      const target2 = (value == null ? void 0 : value.parent) ? el2.parentElement : el2;
      const options = (value == null ? void 0 : value.options) ?? {
        passive: true
      };
      const uid2 = (_a2 = binding.instance) == null ? void 0 : _a2.$.uid;
      if (!target2 || !uid2)
        return;
      const handlers2 = createHandlers(binding.value);
      target2._touchHandlers = target2._touchHandlers ?? /* @__PURE__ */ Object.create(null);
      target2._touchHandlers[uid2] = handlers2;
      keys(handlers2).forEach((eventName2) => {
        target2.addEventListener(eventName2, handlers2[eventName2], options);
      });
    }
    function unmounted(el2, binding) {
      var _a2, _b;
      const target2 = ((_a2 = binding.value) == null ? void 0 : _a2.parent) ? el2.parentElement : el2;
      const uid2 = (_b = binding.instance) == null ? void 0 : _b.$.uid;
      if (!(target2 == null ? void 0 : target2._touchHandlers) || !uid2)
        return;
      const handlers2 = target2._touchHandlers[uid2];
      keys(handlers2).forEach((eventName2) => {
        target2.removeEventListener(eventName2, handlers2[eventName2]);
      });
      delete target2._touchHandlers[uid2];
    }
    const Touch = {
      mounted,
      unmounted
    };
    const Touch$1 = Touch;
    const VWindowSymbol = Symbol.for("vuetify:v-window");
    const VWindowGroupSymbol = Symbol.for("vuetify:v-window-group");
    const makeVWindowProps = propsFactory({
      continuous: Boolean,
      nextIcon: {
        type: [Boolean, String, Function, Object],
        default: "$next"
      },
      prevIcon: {
        type: [Boolean, String, Function, Object],
        default: "$prev"
      },
      reverse: Boolean,
      showArrows: {
        type: [Boolean, String],
        validator: (v) => typeof v === "boolean" || v === "hover"
      },
      touch: {
        type: [Object, Boolean],
        default: void 0
      },
      direction: {
        type: String,
        default: "horizontal"
      },
      modelValue: null,
      disabled: Boolean,
      selectedClass: {
        type: String,
        default: "v-window-item--active"
      },
      // TODO: mandatory should probably not be exposed but do this for now
      mandatory: {
        type: [Boolean, String],
        default: "force"
      },
      ...makeComponentProps(),
      ...makeTagProps(),
      ...makeThemeProps()
    }, "VWindow");
    const VWindow = genericComponent()({
      name: "VWindow",
      directives: {
        Touch
      },
      props: makeVWindowProps(),
      emits: {
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          themeClasses
        } = provideTheme(props);
        const {
          isRtl
        } = useRtl();
        const {
          t
        } = useLocale();
        const group = useGroup(props, VWindowGroupSymbol);
        const rootRef = ref$1();
        const isRtlReverse = computed(() => isRtl.value ? !props.reverse : props.reverse);
        const isReversed = shallowRef(false);
        const transition = computed(() => {
          const axis = props.direction === "vertical" ? "y" : "x";
          const reverse = isRtlReverse.value ? !isReversed.value : isReversed.value;
          const direction = reverse ? "-reverse" : "";
          return `v-window-${axis}${direction}-transition`;
        });
        const transitionCount = shallowRef(0);
        const transitionHeight = ref$1(void 0);
        const activeIndex = computed(() => {
          return group.items.value.findIndex((item) => group.selected.value.includes(item.id));
        });
        watch(activeIndex, (newVal, oldVal) => {
          const itemsLength = group.items.value.length;
          const lastIndex = itemsLength - 1;
          if (itemsLength <= 2) {
            isReversed.value = newVal < oldVal;
          } else if (newVal === lastIndex && oldVal === 0) {
            isReversed.value = true;
          } else if (newVal === 0 && oldVal === lastIndex) {
            isReversed.value = false;
          } else {
            isReversed.value = newVal < oldVal;
          }
        });
        provide(VWindowSymbol, {
          transition,
          isReversed,
          transitionCount,
          transitionHeight,
          rootRef
        });
        const canMoveBack = computed(() => props.continuous || activeIndex.value !== 0);
        const canMoveForward = computed(() => props.continuous || activeIndex.value !== group.items.value.length - 1);
        function prev() {
          canMoveBack.value && group.prev();
        }
        function next2() {
          canMoveForward.value && group.next();
        }
        const arrows = computed(() => {
          const arrows2 = [];
          const prevProps = {
            icon: isRtl.value ? props.nextIcon : props.prevIcon,
            class: `v-window__${isRtlReverse.value ? "right" : "left"}`,
            onClick: group.prev,
            "aria-label": t("$vuetify.carousel.prev")
          };
          arrows2.push(canMoveBack.value ? slots.prev ? slots.prev({
            props: prevProps
          }) : createVNode(VBtn, prevProps, null) : createVNode("div", null, null));
          const nextProps = {
            icon: isRtl.value ? props.prevIcon : props.nextIcon,
            class: `v-window__${isRtlReverse.value ? "left" : "right"}`,
            onClick: group.next,
            "aria-label": t("$vuetify.carousel.next")
          };
          arrows2.push(canMoveForward.value ? slots.next ? slots.next({
            props: nextProps
          }) : createVNode(VBtn, nextProps, null) : createVNode("div", null, null));
          return arrows2;
        });
        const touchOptions = computed(() => {
          if (props.touch === false)
            return props.touch;
          const options = {
            left: () => {
              isRtlReverse.value ? prev() : next2();
            },
            right: () => {
              isRtlReverse.value ? next2() : prev();
            },
            start: (_ref2) => {
              let {
                originalEvent
              } = _ref2;
              originalEvent.stopPropagation();
            }
          };
          return {
            ...options,
            ...props.touch === true ? {} : props.touch
          };
        });
        useRender(() => withDirectives(createVNode(props.tag, {
          "ref": rootRef,
          "class": ["v-window", {
            "v-window--show-arrows-on-hover": props.showArrows === "hover"
          }, themeClasses.value, props.class],
          "style": props.style
        }, {
          default: () => {
            var _a2, _b;
            return [createVNode("div", {
              "class": "v-window__container",
              "style": {
                height: transitionHeight.value
              }
            }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
              group
            }), props.showArrows !== false && createVNode("div", {
              "class": "v-window__controls"
            }, [arrows.value])]), (_b = slots.additional) == null ? void 0 : _b.call(slots, {
              group
            })];
          }
        }), [[resolveDirective("touch"), touchOptions.value]]));
        return {
          group
        };
      }
    });
    const makeVWindowItemProps = propsFactory({
      reverseTransition: {
        type: [Boolean, String],
        default: void 0
      },
      transition: {
        type: [Boolean, String],
        default: void 0
      },
      ...makeComponentProps(),
      ...makeGroupItemProps(),
      ...makeLazyProps()
    }, "VWindowItem");
    const VWindowItem = genericComponent()({
      name: "VWindowItem",
      directives: {
        Touch: Touch$1
      },
      props: makeVWindowItemProps(),
      emits: {
        "group:selected": (val) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const window2 = inject$1(VWindowSymbol);
        const groupItem = useGroupItem(props, VWindowGroupSymbol);
        const {
          isBooted
        } = useSsrBoot();
        if (!window2 || !groupItem)
          throw new Error("[Vuetify] VWindowItem must be used inside VWindow");
        const isTransitioning = shallowRef(false);
        const hasTransition = computed(() => isBooted.value && (window2.isReversed.value ? props.reverseTransition !== false : props.transition !== false));
        function onAfterTransition() {
          if (!isTransitioning.value || !window2) {
            return;
          }
          isTransitioning.value = false;
          if (window2.transitionCount.value > 0) {
            window2.transitionCount.value -= 1;
            if (window2.transitionCount.value === 0) {
              window2.transitionHeight.value = void 0;
            }
          }
        }
        function onBeforeTransition() {
          var _a2;
          if (isTransitioning.value || !window2) {
            return;
          }
          isTransitioning.value = true;
          if (window2.transitionCount.value === 0) {
            window2.transitionHeight.value = convertToUnit((_a2 = window2.rootRef.value) == null ? void 0 : _a2.clientHeight);
          }
          window2.transitionCount.value += 1;
        }
        function onTransitionCancelled() {
          onAfterTransition();
        }
        function onEnterTransition(el2) {
          if (!isTransitioning.value) {
            return;
          }
          nextTick(() => {
            if (!hasTransition.value || !isTransitioning.value || !window2) {
              return;
            }
            window2.transitionHeight.value = convertToUnit(el2.clientHeight);
          });
        }
        const transition = computed(() => {
          const name = window2.isReversed.value ? props.reverseTransition : props.transition;
          return !hasTransition.value ? false : {
            name: typeof name !== "string" ? window2.transition.value : name,
            onBeforeEnter: onBeforeTransition,
            onAfterEnter: onAfterTransition,
            onEnterCancelled: onTransitionCancelled,
            onBeforeLeave: onBeforeTransition,
            onAfterLeave: onAfterTransition,
            onLeaveCancelled: onTransitionCancelled,
            onEnter: onEnterTransition
          };
        });
        const {
          hasContent
        } = useLazy(props, groupItem.isSelected);
        useRender(() => createVNode(MaybeTransition, {
          "transition": transition.value,
          "disabled": !isBooted.value
        }, {
          default: () => {
            var _a2;
            return [withDirectives(createVNode("div", {
              "class": ["v-window-item", groupItem.selectedClass.value, props.class],
              "style": props.style
            }, [hasContent.value && ((_a2 = slots.default) == null ? void 0 : _a2.call(slots))]), [[vShow, groupItem.isSelected.value]])];
          }
        }));
        return {
          groupItem
        };
      }
    });
    const makeVColorPickerCanvasProps = propsFactory({
      color: {
        type: Object
      },
      disabled: Boolean,
      dotSize: {
        type: [Number, String],
        default: 10
      },
      height: {
        type: [Number, String],
        default: 150
      },
      width: {
        type: [Number, String],
        default: 300
      },
      ...makeComponentProps()
    }, "VColorPickerCanvas");
    const VColorPickerCanvas = defineComponent({
      name: "VColorPickerCanvas",
      props: makeVColorPickerCanvasProps(),
      emits: {
        "update:color": (color) => true,
        "update:position": (hue) => true
      },
      setup(props, _ref) {
        let {
          emit: emit2
        } = _ref;
        const isInteracting = shallowRef(false);
        const canvasRef = ref$1();
        const canvasWidth = shallowRef(parseFloat(props.width));
        const canvasHeight = shallowRef(parseFloat(props.height));
        const _dotPosition = ref$1({
          x: 0,
          y: 0
        });
        const dotPosition = computed({
          get: () => _dotPosition.value,
          set(val) {
            var _a2, _b;
            if (!canvasRef.value)
              return;
            const {
              x,
              y
            } = val;
            _dotPosition.value = val;
            emit2("update:color", {
              h: ((_a2 = props.color) == null ? void 0 : _a2.h) ?? 0,
              s: clamp(x, 0, canvasWidth.value) / canvasWidth.value,
              v: 1 - clamp(y, 0, canvasHeight.value) / canvasHeight.value,
              a: ((_b = props.color) == null ? void 0 : _b.a) ?? 1
            });
          }
        });
        const dotStyles = computed(() => {
          const {
            x,
            y
          } = dotPosition.value;
          const radius = parseInt(props.dotSize, 10) / 2;
          return {
            width: convertToUnit(props.dotSize),
            height: convertToUnit(props.dotSize),
            transform: `translate(${convertToUnit(x - radius)}, ${convertToUnit(y - radius)})`
          };
        });
        const {
          resizeRef
        } = useResizeObserver$1((entries) => {
          var _a2;
          if (!((_a2 = resizeRef.value) == null ? void 0 : _a2.offsetParent))
            return;
          const {
            width,
            height
          } = entries[0].contentRect;
          canvasWidth.value = width;
          canvasHeight.value = height;
        });
        function updateDotPosition(x, y, rect2) {
          const {
            left,
            top: top2,
            width,
            height
          } = rect2;
          dotPosition.value = {
            x: clamp(x - left, 0, width),
            y: clamp(y - top2, 0, height)
          };
        }
        function handleMouseDown(e) {
          if (e.type === "mousedown") {
            e.preventDefault();
          }
          if (props.disabled)
            return;
          handleMouseMove(e);
          window.addEventListener("mousemove", handleMouseMove);
          window.addEventListener("mouseup", handleMouseUp);
          window.addEventListener("touchmove", handleMouseMove);
          window.addEventListener("touchend", handleMouseUp);
        }
        function handleMouseMove(e) {
          if (props.disabled || !canvasRef.value)
            return;
          isInteracting.value = true;
          const coords = getEventCoordinates(e);
          updateDotPosition(coords.clientX, coords.clientY, canvasRef.value.getBoundingClientRect());
        }
        function handleMouseUp() {
          window.removeEventListener("mousemove", handleMouseMove);
          window.removeEventListener("mouseup", handleMouseUp);
          window.removeEventListener("touchmove", handleMouseMove);
          window.removeEventListener("touchend", handleMouseUp);
        }
        function updateCanvas() {
          var _a2;
          if (!canvasRef.value)
            return;
          const canvas = canvasRef.value;
          const ctx = canvas.getContext("2d");
          if (!ctx)
            return;
          const saturationGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
          saturationGradient.addColorStop(0, "hsla(0, 0%, 100%, 1)");
          saturationGradient.addColorStop(1, `hsla(${((_a2 = props.color) == null ? void 0 : _a2.h) ?? 0}, 100%, 50%, 1)`);
          ctx.fillStyle = saturationGradient;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          const valueGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
          valueGradient.addColorStop(0, "hsla(0, 0%, 0%, 0)");
          valueGradient.addColorStop(1, "hsla(0, 0%, 0%, 1)");
          ctx.fillStyle = valueGradient;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        watch(() => {
          var _a2;
          return (_a2 = props.color) == null ? void 0 : _a2.h;
        }, updateCanvas, {
          immediate: true
        });
        watch(() => [canvasWidth.value, canvasHeight.value], (newVal, oldVal) => {
          updateCanvas();
          _dotPosition.value = {
            x: dotPosition.value.x * newVal[0] / oldVal[0],
            y: dotPosition.value.y * newVal[1] / oldVal[1]
          };
        }, {
          flush: "post"
        });
        watch(() => props.color, () => {
          if (isInteracting.value) {
            isInteracting.value = false;
            return;
          }
          _dotPosition.value = props.color ? {
            x: props.color.s * canvasWidth.value,
            y: (1 - props.color.v) * canvasHeight.value
          } : {
            x: 0,
            y: 0
          };
        }, {
          deep: true,
          immediate: true
        });
        onMounted(() => updateCanvas());
        useRender(() => createVNode("div", {
          "ref": resizeRef,
          "class": ["v-color-picker-canvas", props.class],
          "style": props.style,
          "onMousedown": handleMouseDown,
          "onTouchstartPassive": handleMouseDown
        }, [createVNode("canvas", {
          "ref": canvasRef,
          "width": canvasWidth.value,
          "height": canvasHeight.value
        }, null), props.color && createVNode("div", {
          "class": ["v-color-picker-canvas__dot", {
            "v-color-picker-canvas__dot--disabled": props.disabled
          }],
          "style": dotStyles.value
        }, null)]));
        return {};
      }
    });
    function stripAlpha(color, stripAlpha2) {
      if (stripAlpha2) {
        const {
          a,
          ...rest
        } = color;
        return rest;
      }
      return color;
    }
    function extractColor(color, input) {
      if (input == null || typeof input === "string") {
        const hex2 = HSVtoHex(color);
        if (color.a === 1)
          return hex2.slice(0, 7);
        else
          return hex2;
      }
      if (typeof input === "object") {
        let converted;
        if (has$2(input, ["r", "g", "b"]))
          converted = HSVtoRGB(color);
        else if (has$2(input, ["h", "s", "l"]))
          converted = HSVtoHSL(color);
        else if (has$2(input, ["h", "s", "v"]))
          converted = color;
        return stripAlpha(converted, !has$2(input, ["a"]) && color.a === 1);
      }
      return color;
    }
    const nullColor = {
      h: 0,
      s: 0,
      v: 0,
      a: 1
    };
    const rgba = {
      inputProps: {
        type: "number",
        min: 0
      },
      inputs: [{
        label: "R",
        max: 255,
        step: 1,
        getValue: (c) => Math.round(c.r),
        getColor: (c, v) => ({
          ...c,
          r: Number(v)
        })
      }, {
        label: "G",
        max: 255,
        step: 1,
        getValue: (c) => Math.round(c.g),
        getColor: (c, v) => ({
          ...c,
          g: Number(v)
        })
      }, {
        label: "B",
        max: 255,
        step: 1,
        getValue: (c) => Math.round(c.b),
        getColor: (c, v) => ({
          ...c,
          b: Number(v)
        })
      }, {
        label: "A",
        max: 1,
        step: 0.01,
        getValue: (_ref) => {
          let {
            a
          } = _ref;
          return a != null ? Math.round(a * 100) / 100 : 1;
        },
        getColor: (c, v) => ({
          ...c,
          a: Number(v)
        })
      }],
      to: HSVtoRGB,
      from: RGBtoHSV
    };
    const rgb = {
      ...rgba,
      inputs: (_a = rgba.inputs) == null ? void 0 : _a.slice(0, 3)
    };
    const hsla = {
      inputProps: {
        type: "number",
        min: 0
      },
      inputs: [{
        label: "H",
        max: 360,
        step: 1,
        getValue: (c) => Math.round(c.h),
        getColor: (c, v) => ({
          ...c,
          h: Number(v)
        })
      }, {
        label: "S",
        max: 1,
        step: 0.01,
        getValue: (c) => Math.round(c.s * 100) / 100,
        getColor: (c, v) => ({
          ...c,
          s: Number(v)
        })
      }, {
        label: "L",
        max: 1,
        step: 0.01,
        getValue: (c) => Math.round(c.l * 100) / 100,
        getColor: (c, v) => ({
          ...c,
          l: Number(v)
        })
      }, {
        label: "A",
        max: 1,
        step: 0.01,
        getValue: (_ref2) => {
          let {
            a
          } = _ref2;
          return a != null ? Math.round(a * 100) / 100 : 1;
        },
        getColor: (c, v) => ({
          ...c,
          a: Number(v)
        })
      }],
      to: HSVtoHSL,
      from: HSLtoHSV
    };
    const hsl = {
      ...hsla,
      inputs: hsla.inputs.slice(0, 3)
    };
    const hexa = {
      inputProps: {
        type: "text"
      },
      inputs: [{
        label: "HEXA",
        getValue: (c) => c,
        getColor: (c, v) => v
      }],
      to: HSVtoHex,
      from: HexToHSV
    };
    const hex = {
      ...hexa,
      inputs: [{
        label: "HEX",
        getValue: (c) => c.slice(0, 7),
        getColor: (c, v) => v
      }]
    };
    const modes = {
      rgb,
      rgba,
      hsl,
      hsla,
      hex,
      hexa
    };
    const VColorPickerInput = (_ref) => {
      let {
        label,
        ...rest
      } = _ref;
      return createVNode("div", {
        "class": "v-color-picker-edit__input"
      }, [createVNode("input", rest, null), createVNode("span", null, [label])]);
    };
    const makeVColorPickerEditProps = propsFactory({
      color: Object,
      disabled: Boolean,
      mode: {
        type: String,
        default: "rgba",
        validator: (v) => Object.keys(modes).includes(v)
      },
      modes: {
        type: Array,
        default: () => Object.keys(modes),
        validator: (v) => Array.isArray(v) && v.every((m) => Object.keys(modes).includes(m))
      },
      ...makeComponentProps()
    }, "VColorPickerEdit");
    const VColorPickerEdit = defineComponent({
      name: "VColorPickerEdit",
      props: makeVColorPickerEditProps(),
      emits: {
        "update:color": (color) => true,
        "update:mode": (mode) => true
      },
      setup(props, _ref2) {
        let {
          emit: emit2
        } = _ref2;
        const enabledModes = computed(() => {
          return props.modes.map((key) => ({
            ...modes[key],
            name: key
          }));
        });
        const inputs = computed(() => {
          var _a2;
          const mode = enabledModes.value.find((m) => m.name === props.mode);
          if (!mode)
            return [];
          const color = props.color ? mode.to(props.color) : null;
          return (_a2 = mode.inputs) == null ? void 0 : _a2.map((_ref3) => {
            let {
              getValue,
              getColor,
              ...inputProps
            } = _ref3;
            return {
              ...mode.inputProps,
              ...inputProps,
              disabled: props.disabled,
              value: color && getValue(color),
              onChange: (e) => {
                const target2 = e.target;
                if (!target2)
                  return;
                emit2("update:color", mode.from(getColor(color ?? mode.to(nullColor), target2.value)));
              }
            };
          });
        });
        useRender(() => {
          var _a2;
          return createVNode("div", {
            "class": ["v-color-picker-edit", props.class],
            "style": props.style
          }, [(_a2 = inputs.value) == null ? void 0 : _a2.map((props2) => createVNode(VColorPickerInput, props2, null)), enabledModes.value.length > 1 && createVNode(VBtn, {
            "icon": "$unfold",
            "size": "x-small",
            "variant": "plain",
            "onClick": () => {
              const mi = enabledModes.value.findIndex((m) => m.name === props.mode);
              emit2("update:mode", enabledModes.value[(mi + 1) % enabledModes.value.length].name);
            }
          }, null)]);
        });
        return {};
      }
    });
    const VSliderSymbol = Symbol.for("vuetify:v-slider");
    function getOffset(e, el2, direction) {
      const vertical = direction === "vertical";
      const rect2 = el2.getBoundingClientRect();
      const touch = "touches" in e ? e.touches[0] : e;
      return vertical ? touch.clientY - (rect2.top + rect2.height / 2) : touch.clientX - (rect2.left + rect2.width / 2);
    }
    function getPosition(e, position) {
      if ("touches" in e && e.touches.length)
        return e.touches[0][position];
      else if ("changedTouches" in e && e.changedTouches.length)
        return e.changedTouches[0][position];
      else
        return e[position];
    }
    const makeSliderProps = propsFactory({
      disabled: {
        type: Boolean,
        default: null
      },
      error: Boolean,
      readonly: {
        type: Boolean,
        default: null
      },
      max: {
        type: [Number, String],
        default: 100
      },
      min: {
        type: [Number, String],
        default: 0
      },
      step: {
        type: [Number, String],
        default: 0
      },
      thumbColor: String,
      thumbLabel: {
        type: [Boolean, String],
        default: void 0,
        validator: (v) => typeof v === "boolean" || v === "always"
      },
      thumbSize: {
        type: [Number, String],
        default: 20
      },
      showTicks: {
        type: [Boolean, String],
        default: false,
        validator: (v) => typeof v === "boolean" || v === "always"
      },
      ticks: {
        type: [Array, Object]
      },
      tickSize: {
        type: [Number, String],
        default: 2
      },
      color: String,
      trackColor: String,
      trackFillColor: String,
      trackSize: {
        type: [Number, String],
        default: 4
      },
      direction: {
        type: String,
        default: "horizontal",
        validator: (v) => ["vertical", "horizontal"].includes(v)
      },
      reverse: Boolean,
      ...makeRoundedProps(),
      ...makeElevationProps({
        elevation: 2
      }),
      ripple: {
        type: Boolean,
        default: true
      }
    }, "Slider");
    const useSteps = (props) => {
      const min = computed(() => parseFloat(props.min));
      const max = computed(() => parseFloat(props.max));
      const step = computed(() => +props.step > 0 ? parseFloat(props.step) : 0);
      const decimals = computed(() => Math.max(getDecimals(step.value), getDecimals(min.value)));
      function roundValue(value) {
        value = parseFloat(value);
        if (step.value <= 0)
          return value;
        const clamped = clamp(value, min.value, max.value);
        const offset = min.value % step.value;
        const newValue = Math.round((clamped - offset) / step.value) * step.value + offset;
        return parseFloat(Math.min(newValue, max.value).toFixed(decimals.value));
      }
      return {
        min,
        max,
        step,
        decimals,
        roundValue
      };
    };
    const useSlider = (_ref) => {
      let {
        props,
        steps,
        onSliderStart,
        onSliderMove,
        onSliderEnd,
        getActiveThumb
      } = _ref;
      const {
        isRtl
      } = useRtl();
      const isReversed = toRef(props, "reverse");
      const vertical = computed(() => props.direction === "vertical");
      const indexFromEnd = computed(() => vertical.value !== isReversed.value);
      const {
        min,
        max,
        step,
        decimals,
        roundValue
      } = steps;
      const thumbSize = computed(() => parseInt(props.thumbSize, 10));
      const tickSize = computed(() => parseInt(props.tickSize, 10));
      const trackSize = computed(() => parseInt(props.trackSize, 10));
      const numTicks = computed(() => (max.value - min.value) / step.value);
      const disabled = toRef(props, "disabled");
      const thumbColor = computed(() => props.error || props.disabled ? void 0 : props.thumbColor ?? props.color);
      const trackColor = computed(() => props.error || props.disabled ? void 0 : props.trackColor ?? props.color);
      const trackFillColor = computed(() => props.error || props.disabled ? void 0 : props.trackFillColor ?? props.color);
      const mousePressed = shallowRef(false);
      const startOffset = shallowRef(0);
      const trackContainerRef = ref$1();
      const activeThumbRef = ref$1();
      function parseMouseMove(e) {
        var _a2;
        const vertical2 = props.direction === "vertical";
        const start = vertical2 ? "top" : "left";
        const length = vertical2 ? "height" : "width";
        const position2 = vertical2 ? "clientY" : "clientX";
        const {
          [start]: trackStart,
          [length]: trackLength
        } = (_a2 = trackContainerRef.value) == null ? void 0 : _a2.$el.getBoundingClientRect();
        const clickOffset = getPosition(e, position2);
        let clickPos = Math.min(Math.max((clickOffset - trackStart - startOffset.value) / trackLength, 0), 1) || 0;
        if (vertical2 ? indexFromEnd.value : indexFromEnd.value !== isRtl.value)
          clickPos = 1 - clickPos;
        return roundValue(min.value + clickPos * (max.value - min.value));
      }
      const handleStop = (e) => {
        onSliderEnd({
          value: parseMouseMove(e)
        });
        mousePressed.value = false;
        startOffset.value = 0;
      };
      const handleStart = (e) => {
        activeThumbRef.value = getActiveThumb(e);
        if (!activeThumbRef.value)
          return;
        activeThumbRef.value.focus();
        mousePressed.value = true;
        if (activeThumbRef.value.contains(e.target)) {
          startOffset.value = getOffset(e, activeThumbRef.value, props.direction);
        } else {
          startOffset.value = 0;
          onSliderMove({
            value: parseMouseMove(e)
          });
        }
        onSliderStart({
          value: parseMouseMove(e)
        });
      };
      const moveListenerOptions = {
        passive: true,
        capture: true
      };
      function onMouseMove(e) {
        onSliderMove({
          value: parseMouseMove(e)
        });
      }
      function onSliderMouseUp(e) {
        e.stopPropagation();
        e.preventDefault();
        handleStop(e);
        window.removeEventListener("mousemove", onMouseMove, moveListenerOptions);
        window.removeEventListener("mouseup", onSliderMouseUp);
      }
      function onSliderTouchend(e) {
        var _a2;
        handleStop(e);
        window.removeEventListener("touchmove", onMouseMove, moveListenerOptions);
        (_a2 = e.target) == null ? void 0 : _a2.removeEventListener("touchend", onSliderTouchend);
      }
      function onSliderTouchstart(e) {
        var _a2;
        handleStart(e);
        window.addEventListener("touchmove", onMouseMove, moveListenerOptions);
        (_a2 = e.target) == null ? void 0 : _a2.addEventListener("touchend", onSliderTouchend, {
          passive: false
        });
      }
      function onSliderMousedown(e) {
        e.preventDefault();
        handleStart(e);
        window.addEventListener("mousemove", onMouseMove, moveListenerOptions);
        window.addEventListener("mouseup", onSliderMouseUp, {
          passive: false
        });
      }
      const position = (val) => {
        const percentage = (val - min.value) / (max.value - min.value) * 100;
        return clamp(isNaN(percentage) ? 0 : percentage, 0, 100);
      };
      const showTicks = toRef(props, "showTicks");
      const parsedTicks = computed(() => {
        if (!showTicks.value)
          return [];
        if (!props.ticks) {
          return numTicks.value !== Infinity ? createRange(numTicks.value + 1).map((t) => {
            const value = min.value + t * step.value;
            return {
              value,
              position: position(value)
            };
          }) : [];
        }
        if (Array.isArray(props.ticks))
          return props.ticks.map((t) => ({
            value: t,
            position: position(t),
            label: t.toString()
          }));
        return Object.keys(props.ticks).map((key) => ({
          value: parseFloat(key),
          position: position(parseFloat(key)),
          label: props.ticks[key]
        }));
      });
      const hasLabels = computed(() => parsedTicks.value.some((_ref2) => {
        let {
          label
        } = _ref2;
        return !!label;
      }));
      const data = {
        activeThumbRef,
        color: toRef(props, "color"),
        decimals,
        disabled,
        direction: toRef(props, "direction"),
        elevation: toRef(props, "elevation"),
        hasLabels,
        isReversed,
        indexFromEnd,
        min,
        max,
        mousePressed,
        numTicks,
        onSliderMousedown,
        onSliderTouchstart,
        parsedTicks,
        parseMouseMove,
        position,
        readonly: toRef(props, "readonly"),
        rounded: toRef(props, "rounded"),
        roundValue,
        showTicks,
        startOffset,
        step,
        thumbSize,
        thumbColor,
        thumbLabel: toRef(props, "thumbLabel"),
        ticks: toRef(props, "ticks"),
        tickSize,
        trackColor,
        trackContainerRef,
        trackFillColor,
        trackSize,
        vertical
      };
      provide(VSliderSymbol, data);
      return data;
    };
    const makeVSliderThumbProps = propsFactory({
      focused: Boolean,
      max: {
        type: Number,
        required: true
      },
      min: {
        type: Number,
        required: true
      },
      modelValue: {
        type: Number,
        required: true
      },
      position: {
        type: Number,
        required: true
      },
      ripple: {
        type: [Boolean, Object],
        default: true
      },
      ...makeComponentProps()
    }, "VSliderThumb");
    const VSliderThumb = genericComponent()({
      name: "VSliderThumb",
      directives: {
        Ripple
      },
      props: makeVSliderThumbProps(),
      emits: {
        "update:modelValue": (v) => true
      },
      setup(props, _ref) {
        let {
          slots,
          emit: emit2
        } = _ref;
        const slider = inject$1(VSliderSymbol);
        const {
          isRtl,
          rtlClasses
        } = useRtl();
        if (!slider)
          throw new Error("[Vuetify] v-slider-thumb must be used inside v-slider or v-range-slider");
        const {
          thumbColor,
          step,
          disabled,
          thumbSize,
          thumbLabel,
          direction,
          isReversed,
          vertical,
          readonly: readonly2,
          elevation,
          mousePressed,
          decimals,
          indexFromEnd
        } = slider;
        const elevationProps = computed(() => !disabled.value ? elevation.value : void 0);
        const {
          elevationClasses
        } = useElevation(elevationProps);
        const {
          textColorClasses,
          textColorStyles
        } = useTextColor(thumbColor);
        const {
          pageup,
          pagedown,
          end,
          home,
          left,
          right,
          down,
          up
        } = keyValues;
        const relevantKeys = [pageup, pagedown, end, home, left, right, down, up];
        const multipliers = computed(() => {
          if (step.value)
            return [1, 2, 3];
          else
            return [1, 5, 10];
        });
        function parseKeydown(e, value) {
          if (!relevantKeys.includes(e.key))
            return;
          e.preventDefault();
          const _step = step.value || 0.1;
          const steps = (props.max - props.min) / _step;
          if ([left, right, down, up].includes(e.key)) {
            const increase = vertical.value ? [isRtl.value ? left : right, isReversed.value ? down : up] : indexFromEnd.value !== isRtl.value ? [left, up] : [right, up];
            const direction2 = increase.includes(e.key) ? 1 : -1;
            const multiplier = e.shiftKey ? 2 : e.ctrlKey ? 1 : 0;
            value = value + direction2 * _step * multipliers.value[multiplier];
          } else if (e.key === home) {
            value = props.min;
          } else if (e.key === end) {
            value = props.max;
          } else {
            const direction2 = e.key === pagedown ? 1 : -1;
            value = value - direction2 * _step * (steps > 100 ? steps / 10 : 10);
          }
          return Math.max(props.min, Math.min(props.max, value));
        }
        function onKeydown(e) {
          const newValue = parseKeydown(e, props.modelValue);
          newValue != null && emit2("update:modelValue", newValue);
        }
        useRender(() => {
          const positionPercentage = convertToUnit(indexFromEnd.value ? 100 - props.position : props.position, "%");
          return createVNode("div", {
            "class": ["v-slider-thumb", {
              "v-slider-thumb--focused": props.focused,
              "v-slider-thumb--pressed": props.focused && mousePressed.value
            }, props.class, rtlClasses.value],
            "style": [{
              "--v-slider-thumb-position": positionPercentage,
              "--v-slider-thumb-size": convertToUnit(thumbSize.value)
            }, props.style],
            "role": "slider",
            "tabindex": disabled.value ? -1 : 0,
            "aria-valuemin": props.min,
            "aria-valuemax": props.max,
            "aria-valuenow": props.modelValue,
            "aria-readonly": !!readonly2.value,
            "aria-orientation": direction.value,
            "onKeydown": !readonly2.value ? onKeydown : void 0
          }, [createVNode("div", {
            "class": ["v-slider-thumb__surface", textColorClasses.value, elevationClasses.value],
            "style": {
              ...textColorStyles.value
            }
          }, null), withDirectives(createVNode("div", {
            "class": ["v-slider-thumb__ripple", textColorClasses.value],
            "style": textColorStyles.value
          }, null), [[resolveDirective("ripple"), props.ripple, null, {
            circle: true,
            center: true
          }]]), createVNode(VScaleTransition, {
            "origin": "bottom center"
          }, {
            default: () => {
              var _a2;
              return [withDirectives(createVNode("div", {
                "class": "v-slider-thumb__label-container"
              }, [createVNode("div", {
                "class": ["v-slider-thumb__label"]
              }, [createVNode("div", null, [((_a2 = slots["thumb-label"]) == null ? void 0 : _a2.call(slots, {
                modelValue: props.modelValue
              })) ?? props.modelValue.toFixed(step.value ? decimals.value : 1)])])]), [[vShow, thumbLabel.value && props.focused || thumbLabel.value === "always"]])];
            }
          })]);
        });
        return {};
      }
    });
    const makeVSliderTrackProps = propsFactory({
      start: {
        type: Number,
        required: true
      },
      stop: {
        type: Number,
        required: true
      },
      ...makeComponentProps()
    }, "VSliderTrack");
    const VSliderTrack = genericComponent()({
      name: "VSliderTrack",
      props: makeVSliderTrackProps(),
      emits: {},
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const slider = inject$1(VSliderSymbol);
        if (!slider)
          throw new Error("[Vuetify] v-slider-track must be inside v-slider or v-range-slider");
        const {
          color,
          parsedTicks,
          rounded,
          showTicks,
          tickSize,
          trackColor,
          trackFillColor,
          trackSize,
          vertical,
          min,
          max,
          indexFromEnd
        } = slider;
        const {
          roundedClasses
        } = useRounded(rounded);
        const {
          backgroundColorClasses: trackFillColorClasses,
          backgroundColorStyles: trackFillColorStyles
        } = useBackgroundColor(trackFillColor);
        const {
          backgroundColorClasses: trackColorClasses,
          backgroundColorStyles: trackColorStyles
        } = useBackgroundColor(trackColor);
        const startDir = computed(() => `inset-${vertical.value ? "block" : "inline"}-${indexFromEnd.value ? "end" : "start"}`);
        const endDir = computed(() => vertical.value ? "height" : "width");
        const backgroundStyles = computed(() => {
          return {
            [startDir.value]: "0%",
            [endDir.value]: "100%"
          };
        });
        const trackFillWidth = computed(() => props.stop - props.start);
        const trackFillStyles = computed(() => {
          return {
            [startDir.value]: convertToUnit(props.start, "%"),
            [endDir.value]: convertToUnit(trackFillWidth.value, "%")
          };
        });
        const computedTicks = computed(() => {
          if (!showTicks.value)
            return [];
          const ticks = vertical.value ? parsedTicks.value.slice().reverse() : parsedTicks.value;
          return ticks.map((tick, index) => {
            var _a2;
            const directionValue = tick.value !== min.value && tick.value !== max.value ? convertToUnit(tick.position, "%") : void 0;
            return createVNode("div", {
              "key": tick.value,
              "class": ["v-slider-track__tick", {
                "v-slider-track__tick--filled": tick.position >= props.start && tick.position <= props.stop,
                "v-slider-track__tick--first": tick.value === min.value,
                "v-slider-track__tick--last": tick.value === max.value
              }],
              "style": {
                [startDir.value]: directionValue
              }
            }, [(tick.label || slots["tick-label"]) && createVNode("div", {
              "class": "v-slider-track__tick-label"
            }, [((_a2 = slots["tick-label"]) == null ? void 0 : _a2.call(slots, {
              tick,
              index
            })) ?? tick.label])]);
          });
        });
        useRender(() => {
          return createVNode("div", {
            "class": ["v-slider-track", roundedClasses.value, props.class],
            "style": [{
              "--v-slider-track-size": convertToUnit(trackSize.value),
              "--v-slider-tick-size": convertToUnit(tickSize.value)
            }, props.style]
          }, [createVNode("div", {
            "class": ["v-slider-track__background", trackColorClasses.value, {
              "v-slider-track__background--opacity": !!color.value || !trackFillColor.value
            }],
            "style": {
              ...backgroundStyles.value,
              ...trackColorStyles.value
            }
          }, null), createVNode("div", {
            "class": ["v-slider-track__fill", trackFillColorClasses.value],
            "style": {
              ...trackFillStyles.value,
              ...trackFillColorStyles.value
            }
          }, null), showTicks.value && createVNode("div", {
            "class": ["v-slider-track__ticks", {
              "v-slider-track__ticks--always-show": showTicks.value === "always"
            }]
          }, [computedTicks.value])]);
        });
        return {};
      }
    });
    const makeVSliderProps = propsFactory({
      ...makeFocusProps(),
      ...makeSliderProps(),
      ...makeVInputProps(),
      modelValue: {
        type: [Number, String],
        default: 0
      }
    }, "VSlider");
    const VSlider = genericComponent()({
      name: "VSlider",
      props: makeVSliderProps(),
      emits: {
        "update:focused": (value) => true,
        "update:modelValue": (v) => true,
        start: (value) => true,
        end: (value) => true
      },
      setup(props, _ref) {
        let {
          slots,
          emit: emit2
        } = _ref;
        const thumbContainerRef = ref$1();
        const {
          rtlClasses
        } = useRtl();
        const steps = useSteps(props);
        const model = useProxiedModel(props, "modelValue", void 0, (value) => {
          return steps.roundValue(value == null ? steps.min.value : value);
        });
        const {
          min,
          max,
          mousePressed,
          roundValue,
          onSliderMousedown,
          onSliderTouchstart,
          trackContainerRef,
          position,
          hasLabels,
          readonly: readonly2
        } = useSlider({
          props,
          steps,
          onSliderStart: () => {
            emit2("start", model.value);
          },
          onSliderEnd: (_ref2) => {
            let {
              value
            } = _ref2;
            const roundedValue = roundValue(value);
            model.value = roundedValue;
            emit2("end", roundedValue);
          },
          onSliderMove: (_ref3) => {
            let {
              value
            } = _ref3;
            return model.value = roundValue(value);
          },
          getActiveThumb: () => {
            var _a2;
            return (_a2 = thumbContainerRef.value) == null ? void 0 : _a2.$el;
          }
        });
        const {
          isFocused,
          focus,
          blur
        } = useFocus(props);
        const trackStop = computed(() => position(model.value));
        useRender(() => {
          const inputProps = VInput.filterProps(props);
          const hasPrepend = !!(props.label || slots.label || slots.prepend);
          return createVNode(VInput, mergeProps({
            "class": ["v-slider", {
              "v-slider--has-labels": !!slots["tick-label"] || hasLabels.value,
              "v-slider--focused": isFocused.value,
              "v-slider--pressed": mousePressed.value,
              "v-slider--disabled": props.disabled
            }, rtlClasses.value, props.class],
            "style": props.style
          }, inputProps, {
            "focused": isFocused.value
          }), {
            ...slots,
            prepend: hasPrepend ? (slotProps) => {
              var _a2, _b;
              return createVNode(Fragment, null, [((_a2 = slots.label) == null ? void 0 : _a2.call(slots, slotProps)) ?? (props.label ? createVNode(VLabel, {
                "id": slotProps.id.value,
                "class": "v-slider__label",
                "text": props.label
              }, null) : void 0), (_b = slots.prepend) == null ? void 0 : _b.call(slots, slotProps)]);
            } : void 0,
            default: (_ref4) => {
              let {
                id: id2,
                messagesId
              } = _ref4;
              return createVNode("div", {
                "class": "v-slider__container",
                "onMousedown": !readonly2.value ? onSliderMousedown : void 0,
                "onTouchstartPassive": !readonly2.value ? onSliderTouchstart : void 0
              }, [createVNode("input", {
                "id": id2.value,
                "name": props.name || id2.value,
                "disabled": !!props.disabled,
                "readonly": !!props.readonly,
                "tabindex": "-1",
                "value": model.value
              }, null), createVNode(VSliderTrack, {
                "ref": trackContainerRef,
                "start": 0,
                "stop": trackStop.value
              }, {
                "tick-label": slots["tick-label"]
              }), createVNode(VSliderThumb, {
                "ref": thumbContainerRef,
                "aria-describedby": messagesId.value,
                "focused": isFocused.value,
                "min": min.value,
                "max": max.value,
                "modelValue": model.value,
                "onUpdate:modelValue": (v) => model.value = v,
                "position": trackStop.value,
                "elevation": props.elevation,
                "onFocus": focus,
                "onBlur": blur,
                "ripple": props.ripple
              }, {
                "thumb-label": slots["thumb-label"]
              })]);
            }
          });
        });
        return {};
      }
    });
    const makeVColorPickerPreviewProps = propsFactory({
      color: {
        type: Object
      },
      disabled: Boolean,
      hideAlpha: Boolean,
      ...makeComponentProps()
    }, "VColorPickerPreview");
    const VColorPickerPreview = defineComponent({
      name: "VColorPickerPreview",
      props: makeVColorPickerPreviewProps(),
      emits: {
        "update:color": (color) => true
      },
      setup(props, _ref) {
        let {
          emit: emit2
        } = _ref;
        const abortController = new AbortController();
        onUnmounted(() => abortController.abort());
        async function openEyeDropper() {
          if (!SUPPORTS_EYE_DROPPER)
            return;
          const eyeDropper = new window.EyeDropper();
          try {
            const result = await eyeDropper.open({
              signal: abortController.signal
            });
            const colorHexValue = HexToHSV(result.sRGBHex);
            emit2("update:color", {
              ...props.color ?? nullColor,
              ...colorHexValue
            });
          } catch (e) {
          }
        }
        useRender(() => {
          var _a2, _b;
          return createVNode("div", {
            "class": ["v-color-picker-preview", {
              "v-color-picker-preview--hide-alpha": props.hideAlpha
            }, props.class],
            "style": props.style
          }, [SUPPORTS_EYE_DROPPER && createVNode("div", {
            "class": "v-color-picker-preview__eye-dropper",
            "key": "eyeDropper"
          }, [createVNode(VBtn, {
            "onClick": openEyeDropper,
            "icon": "$eyeDropper",
            "variant": "plain",
            "density": "comfortable"
          }, null)]), createVNode("div", {
            "class": "v-color-picker-preview__dot"
          }, [createVNode("div", {
            "style": {
              background: HSVtoCSS(props.color ?? nullColor)
            }
          }, null)]), createVNode("div", {
            "class": "v-color-picker-preview__sliders"
          }, [createVNode(VSlider, {
            "class": "v-color-picker-preview__track v-color-picker-preview__hue",
            "modelValue": (_a2 = props.color) == null ? void 0 : _a2.h,
            "onUpdate:modelValue": (h2) => emit2("update:color", {
              ...props.color ?? nullColor,
              h: h2
            }),
            "step": 0,
            "min": 0,
            "max": 360,
            "disabled": props.disabled,
            "thumbSize": 14,
            "trackSize": 8,
            "trackFillColor": "white",
            "hideDetails": true
          }, null), !props.hideAlpha && createVNode(VSlider, {
            "class": "v-color-picker-preview__track v-color-picker-preview__alpha",
            "modelValue": ((_b = props.color) == null ? void 0 : _b.a) ?? 1,
            "onUpdate:modelValue": (a) => emit2("update:color", {
              ...props.color ?? nullColor,
              a
            }),
            "step": 1 / 256,
            "min": 0,
            "max": 1,
            "disabled": props.disabled,
            "thumbSize": 14,
            "trackSize": 8,
            "trackFillColor": "white",
            "hideDetails": true
          }, null)])]);
        });
        return {};
      }
    });
    const red = {
      base: "#f44336",
      lighten5: "#ffebee",
      lighten4: "#ffcdd2",
      lighten3: "#ef9a9a",
      lighten2: "#e57373",
      lighten1: "#ef5350",
      darken1: "#e53935",
      darken2: "#d32f2f",
      darken3: "#c62828",
      darken4: "#b71c1c",
      accent1: "#ff8a80",
      accent2: "#ff5252",
      accent3: "#ff1744",
      accent4: "#d50000"
    };
    const pink = {
      base: "#e91e63",
      lighten5: "#fce4ec",
      lighten4: "#f8bbd0",
      lighten3: "#f48fb1",
      lighten2: "#f06292",
      lighten1: "#ec407a",
      darken1: "#d81b60",
      darken2: "#c2185b",
      darken3: "#ad1457",
      darken4: "#880e4f",
      accent1: "#ff80ab",
      accent2: "#ff4081",
      accent3: "#f50057",
      accent4: "#c51162"
    };
    const purple = {
      base: "#9c27b0",
      lighten5: "#f3e5f5",
      lighten4: "#e1bee7",
      lighten3: "#ce93d8",
      lighten2: "#ba68c8",
      lighten1: "#ab47bc",
      darken1: "#8e24aa",
      darken2: "#7b1fa2",
      darken3: "#6a1b9a",
      darken4: "#4a148c",
      accent1: "#ea80fc",
      accent2: "#e040fb",
      accent3: "#d500f9",
      accent4: "#aa00ff"
    };
    const deepPurple = {
      base: "#673ab7",
      lighten5: "#ede7f6",
      lighten4: "#d1c4e9",
      lighten3: "#b39ddb",
      lighten2: "#9575cd",
      lighten1: "#7e57c2",
      darken1: "#5e35b1",
      darken2: "#512da8",
      darken3: "#4527a0",
      darken4: "#311b92",
      accent1: "#b388ff",
      accent2: "#7c4dff",
      accent3: "#651fff",
      accent4: "#6200ea"
    };
    const indigo = {
      base: "#3f51b5",
      lighten5: "#e8eaf6",
      lighten4: "#c5cae9",
      lighten3: "#9fa8da",
      lighten2: "#7986cb",
      lighten1: "#5c6bc0",
      darken1: "#3949ab",
      darken2: "#303f9f",
      darken3: "#283593",
      darken4: "#1a237e",
      accent1: "#8c9eff",
      accent2: "#536dfe",
      accent3: "#3d5afe",
      accent4: "#304ffe"
    };
    const blue = {
      base: "#2196f3",
      lighten5: "#e3f2fd",
      lighten4: "#bbdefb",
      lighten3: "#90caf9",
      lighten2: "#64b5f6",
      lighten1: "#42a5f5",
      darken1: "#1e88e5",
      darken2: "#1976d2",
      darken3: "#1565c0",
      darken4: "#0d47a1",
      accent1: "#82b1ff",
      accent2: "#448aff",
      accent3: "#2979ff",
      accent4: "#2962ff"
    };
    const lightBlue = {
      base: "#03a9f4",
      lighten5: "#e1f5fe",
      lighten4: "#b3e5fc",
      lighten3: "#81d4fa",
      lighten2: "#4fc3f7",
      lighten1: "#29b6f6",
      darken1: "#039be5",
      darken2: "#0288d1",
      darken3: "#0277bd",
      darken4: "#01579b",
      accent1: "#80d8ff",
      accent2: "#40c4ff",
      accent3: "#00b0ff",
      accent4: "#0091ea"
    };
    const cyan = {
      base: "#00bcd4",
      lighten5: "#e0f7fa",
      lighten4: "#b2ebf2",
      lighten3: "#80deea",
      lighten2: "#4dd0e1",
      lighten1: "#26c6da",
      darken1: "#00acc1",
      darken2: "#0097a7",
      darken3: "#00838f",
      darken4: "#006064",
      accent1: "#84ffff",
      accent2: "#18ffff",
      accent3: "#00e5ff",
      accent4: "#00b8d4"
    };
    const teal = {
      base: "#009688",
      lighten5: "#e0f2f1",
      lighten4: "#b2dfdb",
      lighten3: "#80cbc4",
      lighten2: "#4db6ac",
      lighten1: "#26a69a",
      darken1: "#00897b",
      darken2: "#00796b",
      darken3: "#00695c",
      darken4: "#004d40",
      accent1: "#a7ffeb",
      accent2: "#64ffda",
      accent3: "#1de9b6",
      accent4: "#00bfa5"
    };
    const green = {
      base: "#4caf50",
      lighten5: "#e8f5e9",
      lighten4: "#c8e6c9",
      lighten3: "#a5d6a7",
      lighten2: "#81c784",
      lighten1: "#66bb6a",
      darken1: "#43a047",
      darken2: "#388e3c",
      darken3: "#2e7d32",
      darken4: "#1b5e20",
      accent1: "#b9f6ca",
      accent2: "#69f0ae",
      accent3: "#00e676",
      accent4: "#00c853"
    };
    const lightGreen = {
      base: "#8bc34a",
      lighten5: "#f1f8e9",
      lighten4: "#dcedc8",
      lighten3: "#c5e1a5",
      lighten2: "#aed581",
      lighten1: "#9ccc65",
      darken1: "#7cb342",
      darken2: "#689f38",
      darken3: "#558b2f",
      darken4: "#33691e",
      accent1: "#ccff90",
      accent2: "#b2ff59",
      accent3: "#76ff03",
      accent4: "#64dd17"
    };
    const lime = {
      base: "#cddc39",
      lighten5: "#f9fbe7",
      lighten4: "#f0f4c3",
      lighten3: "#e6ee9c",
      lighten2: "#dce775",
      lighten1: "#d4e157",
      darken1: "#c0ca33",
      darken2: "#afb42b",
      darken3: "#9e9d24",
      darken4: "#827717",
      accent1: "#f4ff81",
      accent2: "#eeff41",
      accent3: "#c6ff00",
      accent4: "#aeea00"
    };
    const yellow = {
      base: "#ffeb3b",
      lighten5: "#fffde7",
      lighten4: "#fff9c4",
      lighten3: "#fff59d",
      lighten2: "#fff176",
      lighten1: "#ffee58",
      darken1: "#fdd835",
      darken2: "#fbc02d",
      darken3: "#f9a825",
      darken4: "#f57f17",
      accent1: "#ffff8d",
      accent2: "#ffff00",
      accent3: "#ffea00",
      accent4: "#ffd600"
    };
    const amber = {
      base: "#ffc107",
      lighten5: "#fff8e1",
      lighten4: "#ffecb3",
      lighten3: "#ffe082",
      lighten2: "#ffd54f",
      lighten1: "#ffca28",
      darken1: "#ffb300",
      darken2: "#ffa000",
      darken3: "#ff8f00",
      darken4: "#ff6f00",
      accent1: "#ffe57f",
      accent2: "#ffd740",
      accent3: "#ffc400",
      accent4: "#ffab00"
    };
    const orange = {
      base: "#ff9800",
      lighten5: "#fff3e0",
      lighten4: "#ffe0b2",
      lighten3: "#ffcc80",
      lighten2: "#ffb74d",
      lighten1: "#ffa726",
      darken1: "#fb8c00",
      darken2: "#f57c00",
      darken3: "#ef6c00",
      darken4: "#e65100",
      accent1: "#ffd180",
      accent2: "#ffab40",
      accent3: "#ff9100",
      accent4: "#ff6d00"
    };
    const deepOrange = {
      base: "#ff5722",
      lighten5: "#fbe9e7",
      lighten4: "#ffccbc",
      lighten3: "#ffab91",
      lighten2: "#ff8a65",
      lighten1: "#ff7043",
      darken1: "#f4511e",
      darken2: "#e64a19",
      darken3: "#d84315",
      darken4: "#bf360c",
      accent1: "#ff9e80",
      accent2: "#ff6e40",
      accent3: "#ff3d00",
      accent4: "#dd2c00"
    };
    const brown = {
      base: "#795548",
      lighten5: "#efebe9",
      lighten4: "#d7ccc8",
      lighten3: "#bcaaa4",
      lighten2: "#a1887f",
      lighten1: "#8d6e63",
      darken1: "#6d4c41",
      darken2: "#5d4037",
      darken3: "#4e342e",
      darken4: "#3e2723"
    };
    const blueGrey = {
      base: "#607d8b",
      lighten5: "#eceff1",
      lighten4: "#cfd8dc",
      lighten3: "#b0bec5",
      lighten2: "#90a4ae",
      lighten1: "#78909c",
      darken1: "#546e7a",
      darken2: "#455a64",
      darken3: "#37474f",
      darken4: "#263238"
    };
    const grey = {
      base: "#9e9e9e",
      lighten5: "#fafafa",
      lighten4: "#f5f5f5",
      lighten3: "#eeeeee",
      lighten2: "#e0e0e0",
      lighten1: "#bdbdbd",
      darken1: "#757575",
      darken2: "#616161",
      darken3: "#424242",
      darken4: "#212121"
    };
    const shades = {
      black: "#000000",
      white: "#ffffff",
      transparent: "#ffffff00"
    };
    const colors = {
      red,
      pink,
      purple,
      deepPurple,
      indigo,
      blue,
      lightBlue,
      cyan,
      teal,
      green,
      lightGreen,
      lime,
      yellow,
      amber,
      orange,
      deepOrange,
      brown,
      blueGrey,
      grey,
      shades
    };
    const makeVColorPickerSwatchesProps = propsFactory({
      swatches: {
        type: Array,
        default: () => parseDefaultColors(colors)
      },
      disabled: Boolean,
      color: Object,
      maxHeight: [Number, String],
      ...makeComponentProps()
    }, "VColorPickerSwatches");
    function parseDefaultColors(colors2) {
      return Object.keys(colors2).map((key) => {
        const color = colors2[key];
        return color.base ? [color.base, color.darken4, color.darken3, color.darken2, color.darken1, color.lighten1, color.lighten2, color.lighten3, color.lighten4, color.lighten5] : [color.black, color.white, color.transparent];
      });
    }
    const VColorPickerSwatches = defineComponent({
      name: "VColorPickerSwatches",
      props: makeVColorPickerSwatchesProps(),
      emits: {
        "update:color": (color) => true
      },
      setup(props, _ref) {
        let {
          emit: emit2
        } = _ref;
        useRender(() => createVNode("div", {
          "class": ["v-color-picker-swatches", props.class],
          "style": [{
            maxHeight: convertToUnit(props.maxHeight)
          }, props.style]
        }, [createVNode("div", null, [props.swatches.map((swatch) => createVNode("div", {
          "class": "v-color-picker-swatches__swatch"
        }, [swatch.map((color) => {
          const rgba2 = parseColor(color);
          const hsva = RGBtoHSV(rgba2);
          const background = RGBtoCSS(rgba2);
          return createVNode("div", {
            "class": "v-color-picker-swatches__color",
            "onClick": () => hsva && emit2("update:color", hsva)
          }, [createVNode("div", {
            "style": {
              background
            }
          }, [props.color && deepEqual(props.color, hsva) ? createVNode(VIcon, {
            "size": "x-small",
            "icon": "$success",
            "color": getContrast(color, "#FFFFFF") > 2 ? "white" : "black"
          }, null) : void 0])]);
        })]))])]));
        return {};
      }
    });
    const makeVColorPickerProps = propsFactory({
      canvasHeight: {
        type: [String, Number],
        default: 150
      },
      disabled: Boolean,
      dotSize: {
        type: [Number, String],
        default: 10
      },
      hideCanvas: Boolean,
      hideSliders: Boolean,
      hideInputs: Boolean,
      mode: {
        type: String,
        default: "rgba",
        validator: (v) => Object.keys(modes).includes(v)
      },
      modes: {
        type: Array,
        default: () => Object.keys(modes),
        validator: (v) => Array.isArray(v) && v.every((m) => Object.keys(modes).includes(m))
      },
      showSwatches: Boolean,
      swatches: Array,
      swatchesMaxHeight: {
        type: [Number, String],
        default: 150
      },
      modelValue: {
        type: [Object, String]
      },
      ...omit$1(makeVSheetProps({
        width: 300
      }), ["height", "location", "minHeight", "maxHeight", "minWidth", "maxWidth"])
    }, "VColorPicker");
    const VColorPicker = defineComponent({
      name: "VColorPicker",
      props: makeVColorPickerProps(),
      emits: {
        "update:modelValue": (color) => true,
        "update:mode": (mode) => true
      },
      setup(props) {
        const mode = useProxiedModel(props, "mode");
        const hue = ref$1(null);
        const model = useProxiedModel(props, "modelValue", void 0, (v) => {
          if (v == null || v === "")
            return null;
          let c;
          try {
            c = RGBtoHSV(parseColor(v));
          } catch (err) {
            return null;
          }
          return c;
        }, (v) => {
          if (!v)
            return null;
          return extractColor(v, props.modelValue);
        });
        const currentColor = computed(() => {
          return model.value ? {
            ...model.value,
            h: hue.value ?? model.value.h
          } : null;
        });
        const {
          rtlClasses
        } = useRtl();
        let externalChange = true;
        watch(model, (v) => {
          if (!externalChange) {
            externalChange = true;
            return;
          }
          if (!v)
            return;
          hue.value = v.h;
        }, {
          immediate: true
        });
        const updateColor = (hsva) => {
          externalChange = false;
          hue.value = hsva.h;
          model.value = hsva;
        };
        onMounted(() => {
          if (!props.modes.includes(mode.value))
            mode.value = props.modes[0];
        });
        provideDefaults({
          VSlider: {
            color: void 0,
            trackColor: void 0,
            trackFillColor: void 0
          }
        });
        useRender(() => {
          const sheetProps = VSheet.filterProps(props);
          return createVNode(VSheet, mergeProps({
            "rounded": props.rounded,
            "elevation": props.elevation,
            "theme": props.theme,
            "class": ["v-color-picker", rtlClasses.value, props.class],
            "style": [{
              "--v-color-picker-color-hsv": HSVtoCSS({
                ...currentColor.value ?? nullColor,
                a: 1
              })
            }, props.style]
          }, sheetProps, {
            "maxWidth": props.width
          }), {
            default: () => [!props.hideCanvas && createVNode(VColorPickerCanvas, {
              "key": "canvas",
              "color": currentColor.value,
              "onUpdate:color": updateColor,
              "disabled": props.disabled,
              "dotSize": props.dotSize,
              "width": props.width,
              "height": props.canvasHeight
            }, null), (!props.hideSliders || !props.hideInputs) && createVNode("div", {
              "key": "controls",
              "class": "v-color-picker__controls"
            }, [!props.hideSliders && createVNode(VColorPickerPreview, {
              "key": "preview",
              "color": currentColor.value,
              "onUpdate:color": updateColor,
              "hideAlpha": !mode.value.endsWith("a"),
              "disabled": props.disabled
            }, null), !props.hideInputs && createVNode(VColorPickerEdit, {
              "key": "edit",
              "modes": props.modes,
              "mode": mode.value,
              "onUpdate:mode": (m) => mode.value = m,
              "color": currentColor.value,
              "onUpdate:color": updateColor,
              "disabled": props.disabled
            }, null)]), props.showSwatches && createVNode(VColorPickerSwatches, {
              "key": "swatches",
              "color": currentColor.value,
              "onUpdate:color": updateColor,
              "maxHeight": props.swatchesMaxHeight,
              "swatches": props.swatches,
              "disabled": props.disabled
            }, null)]
          });
        });
        return {};
      }
    });
    function highlightResult(text2, matches, length) {
      if (matches == null)
        return text2;
      if (Array.isArray(matches))
        throw new Error("Multiple matches is not implemented");
      return typeof matches === "number" && ~matches ? createVNode(Fragment, null, [createVNode("span", {
        "class": "v-combobox__unmask"
      }, [text2.substr(0, matches)]), createVNode("span", {
        "class": "v-combobox__mask"
      }, [text2.substr(matches, length)]), createVNode("span", {
        "class": "v-combobox__unmask"
      }, [text2.substr(matches + length)])]) : text2;
    }
    const makeVComboboxProps = propsFactory({
      autoSelectFirst: {
        type: [Boolean, String]
      },
      clearOnSelect: {
        type: Boolean,
        default: true
      },
      delimiters: Array,
      ...makeFilterProps({
        filterKeys: ["title"]
      }),
      ...makeSelectProps({
        hideNoData: true,
        returnObject: true
      }),
      ...omit$1(makeVTextFieldProps({
        modelValue: null,
        role: "combobox"
      }), ["validationValue", "dirty", "appendInnerIcon"]),
      ...makeTransitionProps({
        transition: false
      })
    }, "VCombobox");
    const VCombobox = genericComponent()({
      name: "VCombobox",
      props: makeVComboboxProps(),
      emits: {
        "update:focused": (focused) => true,
        "update:modelValue": (value) => true,
        "update:search": (value) => true,
        "update:menu": (value) => true
      },
      setup(props, _ref) {
        var _a2;
        let {
          emit: emit2,
          slots
        } = _ref;
        const {
          t
        } = useLocale();
        const vTextFieldRef = ref$1();
        const isFocused = shallowRef(false);
        const isPristine = shallowRef(true);
        const listHasFocus = shallowRef(false);
        const vMenuRef = ref$1();
        const vVirtualScrollRef = ref$1();
        const _menu = useProxiedModel(props, "menu");
        const menu = computed({
          get: () => _menu.value,
          set: (v) => {
            var _a3;
            if (_menu.value && !v && ((_a3 = vMenuRef.value) == null ? void 0 : _a3.openChildren))
              return;
            _menu.value = v;
          }
        });
        const selectionIndex = shallowRef(-1);
        let cleared = false;
        const color = computed(() => {
          var _a3;
          return (_a3 = vTextFieldRef.value) == null ? void 0 : _a3.color;
        });
        const label = computed(() => menu.value ? props.closeText : props.openText);
        const {
          items: items2,
          transformIn,
          transformOut
        } = useItems(props);
        const {
          textColorClasses,
          textColorStyles
        } = useTextColor(color);
        const model = useProxiedModel(props, "modelValue", [], (v) => transformIn(wrapInArray(v)), (v) => {
          const transformed = transformOut(v);
          return props.multiple ? transformed : transformed[0] ?? null;
        });
        const form = useForm();
        const _search = shallowRef(!props.multiple ? ((_a2 = model.value[0]) == null ? void 0 : _a2.title) ?? "" : "");
        const search = computed({
          get: () => {
            return _search.value;
          },
          set: (val) => {
            var _a3;
            _search.value = val ?? "";
            if (!props.multiple) {
              model.value = [transformItem$1(props, val)];
            }
            if (val && props.multiple && ((_a3 = props.delimiters) == null ? void 0 : _a3.length)) {
              const values = val.split(new RegExp(`(?:${props.delimiters.join("|")})+`));
              if (values.length > 1) {
                values.forEach((v) => {
                  v = v.trim();
                  if (v)
                    select(transformItem$1(props, v));
                });
                _search.value = "";
              }
            }
            if (!val)
              selectionIndex.value = -1;
            isPristine.value = !val;
          }
        });
        const counterValue = computed(() => {
          return typeof props.counterValue === "function" ? props.counterValue(model.value) : typeof props.counterValue === "number" ? props.counterValue : props.multiple ? model.value.length : search.value.length;
        });
        watch(_search, (value) => {
          if (cleared) {
            nextTick(() => cleared = false);
          } else if (isFocused.value && !menu.value) {
            menu.value = true;
          }
          emit2("update:search", value);
        });
        watch(model, (value) => {
          var _a3;
          if (!props.multiple) {
            _search.value = ((_a3 = value[0]) == null ? void 0 : _a3.title) ?? "";
          }
        });
        const {
          filteredItems,
          getMatches
        } = useFilter(props, items2, () => isPristine.value ? "" : search.value);
        const displayItems = computed(() => {
          if (props.hideSelected) {
            return filteredItems.value.filter((filteredItem) => !model.value.some((s) => s.value === filteredItem.value));
          }
          return filteredItems.value;
        });
        const selectedValues = computed(() => model.value.map((selection) => selection.value));
        const highlightFirst = computed(() => {
          var _a3;
          const selectFirst = props.autoSelectFirst === true || props.autoSelectFirst === "exact" && search.value === ((_a3 = displayItems.value[0]) == null ? void 0 : _a3.title);
          return selectFirst && displayItems.value.length > 0 && !isPristine.value && !listHasFocus.value;
        });
        const menuDisabled = computed(() => props.hideNoData && !displayItems.value.length || props.readonly || (form == null ? void 0 : form.isReadonly.value));
        const listRef = ref$1();
        const {
          onListScroll,
          onListKeydown
        } = useScrolling(listRef, vTextFieldRef);
        function onClear(e) {
          cleared = true;
          if (props.openOnClear) {
            menu.value = true;
          }
        }
        function onMousedownControl() {
          if (menuDisabled.value)
            return;
          menu.value = true;
        }
        function onMousedownMenuIcon(e) {
          if (menuDisabled.value)
            return;
          if (isFocused.value) {
            e.preventDefault();
            e.stopPropagation();
          }
          menu.value = !menu.value;
        }
        function onKeydown(e) {
          var _a3;
          if (isComposingIgnoreKey(e) || props.readonly || (form == null ? void 0 : form.isReadonly.value))
            return;
          const selectionStart = vTextFieldRef.value.selectionStart;
          const length = model.value.length;
          if (selectionIndex.value > -1 || ["Enter", "ArrowDown", "ArrowUp"].includes(e.key)) {
            e.preventDefault();
          }
          if (["Enter", "ArrowDown"].includes(e.key)) {
            menu.value = true;
          }
          if (["Escape"].includes(e.key)) {
            menu.value = false;
          }
          if (["Enter", "Escape", "Tab"].includes(e.key)) {
            if (highlightFirst.value && ["Enter", "Tab"].includes(e.key)) {
              select(filteredItems.value[0]);
            }
            isPristine.value = true;
          }
          if (e.key === "ArrowDown" && highlightFirst.value) {
            (_a3 = listRef.value) == null ? void 0 : _a3.focus("next");
          }
          if (!props.multiple)
            return;
          if (["Backspace", "Delete"].includes(e.key)) {
            if (selectionIndex.value < 0) {
              if (e.key === "Backspace" && !search.value) {
                selectionIndex.value = length - 1;
              }
              return;
            }
            const originalSelectionIndex = selectionIndex.value;
            const selectedItem = model.value[selectionIndex.value];
            if (selectedItem && !selectedItem.props.disabled)
              select(selectedItem, false);
            selectionIndex.value = originalSelectionIndex >= length - 1 ? length - 2 : originalSelectionIndex;
          }
          if (e.key === "ArrowLeft") {
            if (selectionIndex.value < 0 && selectionStart > 0)
              return;
            const prev = selectionIndex.value > -1 ? selectionIndex.value - 1 : length - 1;
            if (model.value[prev]) {
              selectionIndex.value = prev;
            } else {
              selectionIndex.value = -1;
              vTextFieldRef.value.setSelectionRange(search.value.length, search.value.length);
            }
          }
          if (e.key === "ArrowRight") {
            if (selectionIndex.value < 0)
              return;
            const next2 = selectionIndex.value + 1;
            if (model.value[next2]) {
              selectionIndex.value = next2;
            } else {
              selectionIndex.value = -1;
              vTextFieldRef.value.setSelectionRange(0, 0);
            }
          }
          if (e.key === "Enter" && search.value) {
            select(transformItem$1(props, search.value));
            search.value = "";
          }
        }
        function onAfterLeave() {
          var _a3;
          if (isFocused.value) {
            isPristine.value = true;
            (_a3 = vTextFieldRef.value) == null ? void 0 : _a3.focus();
          }
        }
        function select(item) {
          let set2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          if (props.multiple) {
            const index = model.value.findIndex((selection) => props.valueComparator(selection.value, item.value));
            const add2 = set2 == null ? !~index : set2;
            if (~index) {
              const value = add2 ? [...model.value, item] : [...model.value];
              value.splice(index, 1);
              model.value = value;
            } else if (add2) {
              model.value = [...model.value, item];
            }
            if (props.clearOnSelect) {
              search.value = "";
            }
          } else {
            const add2 = set2 !== false;
            model.value = add2 ? [item] : [];
            _search.value = add2 ? item.title : "";
            nextTick(() => {
              menu.value = false;
              isPristine.value = true;
            });
          }
        }
        function onFocusin(e) {
          isFocused.value = true;
          setTimeout(() => {
            listHasFocus.value = true;
          });
        }
        function onFocusout(e) {
          listHasFocus.value = false;
        }
        function onUpdateModelValue(v) {
          if (v == null || v === "" && !props.multiple)
            model.value = [];
        }
        watch(isFocused, (val, oldVal) => {
          if (val || val === oldVal)
            return;
          selectionIndex.value = -1;
          menu.value = false;
          if (highlightFirst.value && !listHasFocus.value && !model.value.some((_ref2) => {
            let {
              value
            } = _ref2;
            return value === displayItems.value[0].value;
          })) {
            select(displayItems.value[0]);
          } else if (props.multiple && search.value) {
            select(transformItem$1(props, search.value));
          }
        });
        watch(menu, () => {
          if (!props.hideSelected && menu.value && model.value.length) {
            const index = displayItems.value.findIndex((item) => model.value.some((s) => props.valueComparator(s.value, item.value)));
            IN_BROWSER && window.requestAnimationFrame(() => {
              var _a3;
              index >= 0 && ((_a3 = vVirtualScrollRef.value) == null ? void 0 : _a3.scrollToIndex(index));
            });
          }
        });
        watch(displayItems, (val, oldVal) => {
          if (!isFocused.value)
            return;
          if (!val.length && props.hideNoData) {
            menu.value = false;
          }
          if (!oldVal.length && val.length) {
            menu.value = true;
          }
        });
        useRender(() => {
          const hasChips = !!(props.chips || slots.chip);
          const hasList = !!(!props.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
          const isDirty = model.value.length > 0;
          const textFieldProps = VTextField.filterProps(props);
          return createVNode(VTextField, mergeProps({
            "ref": vTextFieldRef
          }, textFieldProps, {
            "modelValue": search.value,
            "onUpdate:modelValue": [($event) => search.value = $event, onUpdateModelValue],
            "focused": isFocused.value,
            "onUpdate:focused": ($event) => isFocused.value = $event,
            "validationValue": model.externalValue,
            "counterValue": counterValue.value,
            "dirty": isDirty,
            "class": ["v-combobox", {
              "v-combobox--active-menu": menu.value,
              "v-combobox--chips": !!props.chips,
              "v-combobox--selection-slot": !!slots.selection,
              "v-combobox--selecting-index": selectionIndex.value > -1,
              [`v-combobox--${props.multiple ? "multiple" : "single"}`]: true
            }, props.class],
            "style": props.style,
            "readonly": props.readonly,
            "placeholder": isDirty ? void 0 : props.placeholder,
            "onClick:clear": onClear,
            "onMousedown:control": onMousedownControl,
            "onKeydown": onKeydown
          }), {
            ...slots,
            default: () => createVNode(Fragment, null, [createVNode(VMenu, mergeProps({
              "ref": vMenuRef,
              "modelValue": menu.value,
              "onUpdate:modelValue": ($event) => menu.value = $event,
              "activator": "parent",
              "contentClass": "v-combobox__content",
              "disabled": menuDisabled.value,
              "eager": props.eager,
              "maxHeight": 310,
              "openOnClick": false,
              "closeOnContentClick": false,
              "transition": props.transition,
              "onAfterLeave": onAfterLeave
            }, props.menuProps), {
              default: () => [hasList && createVNode(VList, mergeProps({
                "ref": listRef,
                "selected": selectedValues.value,
                "selectStrategy": props.multiple ? "independent" : "single-independent",
                "onMousedown": (e) => e.preventDefault(),
                "onKeydown": onListKeydown,
                "onFocusin": onFocusin,
                "onFocusout": onFocusout,
                "onScrollPassive": onListScroll,
                "tabindex": "-1",
                "aria-live": "polite",
                "color": props.itemColor ?? props.color
              }, props.listProps), {
                default: () => {
                  var _a3, _b, _c;
                  return [(_a3 = slots["prepend-item"]) == null ? void 0 : _a3.call(slots), !displayItems.value.length && !props.hideNoData && (((_b = slots["no-data"]) == null ? void 0 : _b.call(slots)) ?? createVNode(VListItem, {
                    "title": t(props.noDataText)
                  }, null)), createVNode(VVirtualScroll, {
                    "ref": vVirtualScrollRef,
                    "renderless": true,
                    "items": displayItems.value
                  }, {
                    default: (_ref3) => {
                      var _a4;
                      let {
                        item,
                        index,
                        itemRef
                      } = _ref3;
                      const itemProps = mergeProps(item.props, {
                        ref: itemRef,
                        key: index,
                        active: highlightFirst.value && index === 0 ? true : void 0,
                        onClick: () => select(item, null)
                      });
                      return ((_a4 = slots.item) == null ? void 0 : _a4.call(slots, {
                        item,
                        index,
                        props: itemProps
                      })) ?? createVNode(VListItem, itemProps, {
                        prepend: (_ref4) => {
                          let {
                            isSelected
                          } = _ref4;
                          return createVNode(Fragment, null, [props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                            "key": item.value,
                            "modelValue": isSelected,
                            "ripple": false,
                            "tabindex": "-1"
                          }, null) : void 0, item.props.prependAvatar && createVNode(VAvatar, {
                            "image": item.props.prependAvatar
                          }, null), item.props.prependIcon && createVNode(VIcon, {
                            "icon": item.props.prependIcon
                          }, null)]);
                        },
                        title: () => {
                          var _a5, _b2;
                          return isPristine.value ? item.title : highlightResult(item.title, (_a5 = getMatches(item)) == null ? void 0 : _a5.title, ((_b2 = search.value) == null ? void 0 : _b2.length) ?? 0);
                        }
                      });
                    }
                  }), (_c = slots["append-item"]) == null ? void 0 : _c.call(slots)];
                }
              })]
            }), model.value.map((item, index) => {
              function onChipClose(e) {
                e.stopPropagation();
                e.preventDefault();
                select(item, false);
              }
              const slotProps = {
                "onClick:close": onChipClose,
                onMousedown(e) {
                  e.preventDefault();
                  e.stopPropagation();
                },
                modelValue: true,
                "onUpdate:modelValue": void 0
              };
              const hasSlot = hasChips ? !!slots.chip : !!slots.selection;
              const slotContent = hasSlot ? ensureValidVNode(hasChips ? slots.chip({
                item,
                index,
                props: slotProps
              }) : slots.selection({
                item,
                index
              })) : void 0;
              if (hasSlot && !slotContent)
                return void 0;
              return createVNode("div", {
                "key": item.value,
                "class": ["v-combobox__selection", index === selectionIndex.value && ["v-combobox__selection--selected", textColorClasses.value]],
                "style": index === selectionIndex.value ? textColorStyles.value : {}
              }, [hasChips ? !slots.chip ? createVNode(VChip, mergeProps({
                "key": "chip",
                "closable": props.closableChips,
                "size": "small",
                "text": item.title,
                "disabled": item.props.disabled
              }, slotProps), null) : createVNode(VDefaultsProvider, {
                "key": "chip-defaults",
                "defaults": {
                  VChip: {
                    closable: props.closableChips,
                    size: "small",
                    text: item.title
                  }
                }
              }, {
                default: () => [slotContent]
              }) : slotContent ?? createVNode("span", {
                "class": "v-combobox__selection-text"
              }, [item.title, props.multiple && index < model.value.length - 1 && createVNode("span", {
                "class": "v-combobox__selection-comma"
              }, [createTextVNode(",")])])]);
            })]),
            "append-inner": function() {
              var _a3;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return createVNode(Fragment, null, [(_a3 = slots["append-inner"]) == null ? void 0 : _a3.call(slots, ...args), (!props.hideNoData || props.items.length) && props.menuIcon ? createVNode(VIcon, {
                "class": "v-combobox__menu-icon",
                "icon": props.menuIcon,
                "onMousedown": onMousedownMenuIcon,
                "onClick": noop$1,
                "aria-label": t(label.value),
                "title": t(label.value)
              }, null) : void 0]);
            }
          });
        });
        return forwardRefs({
          isFocused,
          isPristine,
          menu,
          search,
          selectionIndex,
          filteredItems,
          select
        }, vTextFieldRef);
      }
    });
    const makeVDatePickerControlsProps = propsFactory({
      active: {
        type: [String, Array],
        default: void 0
      },
      disabled: {
        type: [Boolean, String, Array],
        default: false
      },
      nextIcon: {
        type: [String],
        default: "$next"
      },
      prevIcon: {
        type: [String],
        default: "$prev"
      },
      modeIcon: {
        type: [String],
        default: "$subgroup"
      },
      text: String,
      viewMode: {
        type: String,
        default: "month"
      }
    }, "VDatePickerControls");
    const VDatePickerControls = genericComponent()({
      name: "VDatePickerControls",
      props: makeVDatePickerControlsProps(),
      emits: {
        "click:year": () => true,
        "click:month": () => true,
        "click:prev": () => true,
        "click:next": () => true,
        "click:text": () => true
      },
      setup(props, _ref) {
        let {
          emit: emit2
        } = _ref;
        const disableMonth = computed(() => {
          return Array.isArray(props.disabled) ? props.disabled.includes("text") : !!props.disabled;
        });
        const disableYear = computed(() => {
          return Array.isArray(props.disabled) ? props.disabled.includes("mode") : !!props.disabled;
        });
        const disablePrev = computed(() => {
          return Array.isArray(props.disabled) ? props.disabled.includes("prev") : !!props.disabled;
        });
        const disableNext = computed(() => {
          return Array.isArray(props.disabled) ? props.disabled.includes("next") : !!props.disabled;
        });
        function onClickPrev() {
          emit2("click:prev");
        }
        function onClickNext() {
          emit2("click:next");
        }
        function onClickYear() {
          emit2("click:year");
        }
        function onClickMonth() {
          emit2("click:month");
        }
        useRender(() => {
          return createVNode("div", {
            "class": ["v-date-picker-controls"]
          }, [createVNode(VBtn, {
            "class": "v-date-picker-controls__month-btn",
            "disabled": disableMonth.value,
            "text": props.text,
            "variant": "text",
            "rounded": true,
            "onClick": onClickMonth
          }, null), createVNode(VBtn, {
            "key": "mode-btn",
            "class": "v-date-picker-controls__mode-btn",
            "disabled": disableYear.value,
            "density": "comfortable",
            "icon": props.modeIcon,
            "variant": "text",
            "onClick": onClickYear
          }, null), createVNode(VSpacer, {
            "key": "mode-spacer"
          }, null), createVNode("div", {
            "key": "month-buttons",
            "class": "v-date-picker-controls__month"
          }, [createVNode(VBtn, {
            "disabled": disablePrev.value,
            "icon": props.prevIcon,
            "variant": "text",
            "onClick": onClickPrev
          }, null), createVNode(VBtn, {
            "disabled": disableNext.value,
            "icon": props.nextIcon,
            "variant": "text",
            "onClick": onClickNext
          }, null)])]);
        });
        return {};
      }
    });
    const makeVDatePickerHeaderProps = propsFactory({
      appendIcon: String,
      color: String,
      header: String,
      transition: String,
      onClick: EventProp()
    }, "VDatePickerHeader");
    const VDatePickerHeader = genericComponent()({
      name: "VDatePickerHeader",
      props: makeVDatePickerHeaderProps(),
      emits: {
        click: () => true,
        "click:append": () => true
      },
      setup(props, _ref) {
        let {
          emit: emit2,
          slots
        } = _ref;
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(props, "color");
        function onClick() {
          emit2("click");
        }
        function onClickAppend() {
          emit2("click:append");
        }
        useRender(() => {
          const hasContent = !!(slots.default || props.header);
          const hasAppend = !!(slots.append || props.appendIcon);
          return createVNode("div", {
            "class": ["v-date-picker-header", {
              "v-date-picker-header--clickable": !!props.onClick
            }, backgroundColorClasses.value],
            "style": backgroundColorStyles.value,
            "onClick": onClick
          }, [slots.prepend && createVNode("div", {
            "key": "prepend",
            "class": "v-date-picker-header__prepend"
          }, [slots.prepend()]), hasContent && createVNode(MaybeTransition, {
            "key": "content",
            "name": props.transition
          }, {
            default: () => {
              var _a2;
              return [createVNode("div", {
                "key": props.header,
                "class": "v-date-picker-header__content"
              }, [((_a2 = slots.default) == null ? void 0 : _a2.call(slots)) ?? props.header])];
            }
          }), hasAppend && createVNode("div", {
            "class": "v-date-picker-header__append"
          }, [!slots.append ? createVNode(VBtn, {
            "key": "append-btn",
            "icon": props.appendIcon,
            "variant": "text",
            "onClick": onClickAppend
          }, null) : createVNode(VDefaultsProvider, {
            "key": "append-defaults",
            "disabled": !props.appendIcon,
            "defaults": {
              VBtn: {
                icon: props.appendIcon,
                variant: "text"
              }
            }
          }, {
            default: () => {
              var _a2;
              return [(_a2 = slots.append) == null ? void 0 : _a2.call(slots)];
            }
          })])]);
        });
        return {};
      }
    });
    const makeCalendarProps = propsFactory({
      allowedDates: [Array, Function],
      disabled: Boolean,
      displayValue: null,
      modelValue: Array,
      month: [Number, String],
      max: null,
      min: null,
      showAdjacentMonths: Boolean,
      year: [Number, String],
      weekdays: {
        type: Array,
        default: () => [0, 1, 2, 3, 4, 5, 6]
      }
    }, "calendar");
    function useCalendar(props) {
      const adapter = useDate();
      const model = useProxiedModel(props, "modelValue", [], (v) => wrapInArray(v));
      const displayValue = computed(() => {
        if (props.displayValue)
          return adapter.date(props.displayValue);
        if (model.value.length > 0)
          return adapter.date(model.value[0]);
        if (props.min)
          return adapter.date(props.min);
        if (Array.isArray(props.allowedDates))
          return adapter.date(props.allowedDates[0]);
        return adapter.date();
      });
      const year = useProxiedModel(props, "year", void 0, (v) => {
        const value = v != null ? Number(v) : adapter.getYear(displayValue.value);
        return adapter.startOfYear(adapter.setYear(adapter.date(), value));
      }, (v) => adapter.getYear(v));
      const month = useProxiedModel(props, "month", void 0, (v) => {
        const value = v != null ? Number(v) : adapter.getMonth(displayValue.value);
        const date2 = adapter.setYear(adapter.startOfMonth(adapter.date()), adapter.getYear(year.value));
        return adapter.setMonth(date2, value);
      }, (v) => adapter.getMonth(v));
      const weeksInMonth = computed(() => {
        const weeks = adapter.getWeekArray(month.value);
        const days = weeks.flat();
        const daysInMonth2 = 6 * 7;
        if (days.length < daysInMonth2) {
          const lastDay = days[days.length - 1];
          let week = [];
          for (let day = 1; day <= daysInMonth2 - days.length; day++) {
            week.push(adapter.addDays(lastDay, day));
            if (day % 7 === 0) {
              weeks.push(week);
              week = [];
            }
          }
        }
        return weeks;
      });
      function genDays(days, today) {
        return days.filter((date2) => {
          return props.weekdays.includes(adapter.toJsDate(date2).getDay());
        }).map((date2, index) => {
          const isoDate = adapter.toISO(date2);
          const isAdjacent = !adapter.isSameMonth(date2, month.value);
          const isStart = adapter.isSameDay(date2, adapter.startOfMonth(month.value));
          const isEnd = adapter.isSameDay(date2, adapter.endOfMonth(month.value));
          const isSame = adapter.isSameDay(date2, month.value);
          return {
            date: date2,
            isoDate,
            formatted: adapter.format(date2, "keyboardDate"),
            year: adapter.getYear(date2),
            month: adapter.getMonth(date2),
            isDisabled: isDisabled(date2),
            isWeekStart: index % 7 === 0,
            isWeekEnd: index % 7 === 6,
            isToday: adapter.isSameDay(date2, today),
            isAdjacent,
            isHidden: isAdjacent && !props.showAdjacentMonths,
            isStart,
            isSelected: model.value.some((value) => adapter.isSameDay(date2, value)),
            isEnd,
            isSame,
            localized: adapter.format(date2, "dayOfMonth")
          };
        });
      }
      const daysInWeek = computed(() => {
        const lastDay = adapter.startOfWeek(model.value);
        const week = [];
        for (let day = 0; day <= 6; day++) {
          week.push(adapter.addDays(lastDay, day));
        }
        const days = week;
        const today = adapter.date();
        return genDays(days, today);
      });
      const daysInMonth = computed(() => {
        const days = weeksInMonth.value.flat();
        const today = adapter.date();
        return genDays(days, today);
      });
      const weekNumbers = computed(() => {
        return weeksInMonth.value.map((week) => {
          return week.length ? getWeek(adapter, week[0]) : null;
        });
      });
      function isDisabled(value) {
        if (props.disabled)
          return true;
        const date2 = adapter.date(value);
        if (props.min && adapter.isAfter(adapter.date(props.min), date2))
          return true;
        if (props.max && adapter.isAfter(date2, adapter.date(props.max)))
          return true;
        if (Array.isArray(props.allowedDates) && props.allowedDates.length > 0) {
          return !props.allowedDates.some((d) => adapter.isSameDay(adapter.date(d), date2));
        }
        if (typeof props.allowedDates === "function") {
          return !props.allowedDates(date2);
        }
        return false;
      }
      return {
        displayValue,
        daysInMonth,
        daysInWeek,
        genDays,
        model,
        weeksInMonth,
        weekNumbers
      };
    }
    const makeVDatePickerMonthProps = propsFactory({
      color: String,
      hideWeekdays: Boolean,
      multiple: [Boolean, Number, String],
      showWeek: Boolean,
      ...makeCalendarProps()
    }, "VDatePickerMonth");
    const VDatePickerMonth = genericComponent()({
      name: "VDatePickerMonth",
      props: makeVDatePickerMonthProps(),
      emits: {
        "update:modelValue": (date2) => true,
        "update:month": (date2) => true,
        "update:year": (date2) => true
      },
      setup(props, _ref) {
        let {
          emit: emit2,
          slots
        } = _ref;
        const daysRef = ref$1();
        const {
          daysInMonth,
          model,
          weekNumbers
        } = useCalendar(props);
        const adapter = useDate();
        const rangeStart = shallowRef();
        const rangeStop = shallowRef();
        const atMax = computed(() => {
          const max = ["number", "string"].includes(typeof props.multiple) ? Number(props.multiple) : Infinity;
          return model.value.length >= max;
        });
        function onRangeClick(value) {
          const _value = adapter.startOfDay(value);
          if (!rangeStart.value) {
            rangeStart.value = _value;
            model.value = [rangeStart.value];
          } else if (!rangeStop.value) {
            if (adapter.isSameDay(value, rangeStart.value)) {
              rangeStart.value = void 0;
              model.value = [];
              return;
            } else if (adapter.isBefore(value, rangeStart.value)) {
              rangeStop.value = rangeStart.value;
              rangeStart.value = _value;
            } else {
              rangeStop.value = _value;
            }
            const diff = adapter.getDiff(rangeStop.value, rangeStart.value);
            const datesInRange = [rangeStart.value];
            for (let i2 = 1; i2 < diff; i2++) {
              const nextDate = adapter.addDays(rangeStart.value, i2);
              datesInRange.push(nextDate);
            }
            datesInRange.push(rangeStop.value);
            model.value = datesInRange;
          } else {
            rangeStart.value = value;
            rangeStop.value = void 0;
            model.value = [rangeStart.value];
          }
        }
        function onMultipleClick(value) {
          const index = model.value.findIndex((selection) => adapter.isSameDay(selection, value));
          if (index === -1) {
            model.value = [...model.value, value];
          } else {
            const value2 = [...model.value];
            value2.splice(index, 1);
            model.value = value2;
          }
        }
        function onClick(value) {
          if (props.multiple === "range") {
            onRangeClick(value);
          } else if (props.multiple) {
            onMultipleClick(value);
          } else {
            model.value = [value];
          }
        }
        return () => createVNode("div", {
          "class": "v-date-picker-month"
        }, [props.showWeek && createVNode("div", {
          "key": "weeks",
          "class": "v-date-picker-month__weeks"
        }, [!props.hideWeekdays && createVNode("div", {
          "key": "hide-week-days",
          "class": "v-date-picker-month__day"
        }, [createTextVNode("")]), weekNumbers.value.map((week) => createVNode("div", {
          "class": ["v-date-picker-month__day", "v-date-picker-month__day--adjacent"]
        }, [week]))]), createVNode("div", {
          "ref": daysRef,
          "class": "v-date-picker-month__days"
        }, [!props.hideWeekdays && adapter.getWeekdays().map((weekDay) => createVNode("div", {
          "class": ["v-date-picker-month__day", "v-date-picker-month__weekday"]
        }, [weekDay])), daysInMonth.value.map((item, i2) => {
          const slotProps = {
            props: {
              onClick: () => onClick(item.date)
            },
            item,
            i: i2
          };
          if (atMax.value && !item.isSelected) {
            item.isDisabled = true;
          }
          return createVNode("div", {
            "class": ["v-date-picker-month__day", {
              "v-date-picker-month__day--adjacent": item.isAdjacent,
              "v-date-picker-month__day--hide-adjacent": item.isHidden,
              "v-date-picker-month__day--selected": item.isSelected,
              "v-date-picker-month__day--week-end": item.isWeekEnd,
              "v-date-picker-month__day--week-start": item.isWeekStart
            }],
            "data-v-date": !item.isDisabled ? item.isoDate : void 0
          }, [(props.showAdjacentMonths || !item.isAdjacent) && createVNode(VDefaultsProvider, {
            "defaults": {
              VBtn: {
                class: "v-date-picker-month__day-btn",
                color: (item.isSelected || item.isToday) && !item.isDisabled ? props.color : void 0,
                disabled: item.isDisabled,
                icon: true,
                ripple: false,
                text: item.localized,
                variant: item.isDisabled ? item.isToday ? "outlined" : "text" : item.isToday && !item.isSelected ? "outlined" : "flat",
                onClick: () => onClick(item.date)
              }
            }
          }, {
            default: () => {
              var _a2;
              return [((_a2 = slots.day) == null ? void 0 : _a2.call(slots, slotProps)) ?? createVNode(VBtn, slotProps.props, null)];
            }
          })]);
        })])]);
      }
    });
    const makeVDatePickerMonthsProps = propsFactory({
      color: String,
      height: [String, Number],
      modelValue: Number
    }, "VDatePickerMonths");
    const VDatePickerMonths = genericComponent()({
      name: "VDatePickerMonths",
      props: makeVDatePickerMonthsProps(),
      emits: {
        "update:modelValue": (date2) => true
      },
      setup(props, _ref) {
        let {
          emit: emit2,
          slots
        } = _ref;
        const adapter = useDate();
        const model = useProxiedModel(props, "modelValue");
        const months = computed(() => {
          let date2 = adapter.startOfYear(adapter.date());
          return createRange(12).map((i2) => {
            const text2 = adapter.format(date2, "monthShort");
            date2 = adapter.getNextMonth(date2);
            return {
              text: text2,
              value: i2
            };
          });
        });
        watchEffect(() => {
          model.value = model.value ?? adapter.getMonth(adapter.date());
        });
        useRender(() => createVNode("div", {
          "class": "v-date-picker-months",
          "style": {
            height: convertToUnit(props.height)
          }
        }, [createVNode("div", {
          "class": "v-date-picker-months__content"
        }, [months.value.map((month, i2) => {
          var _a2;
          const btnProps = {
            active: model.value === i2,
            color: model.value === i2 ? props.color : void 0,
            rounded: true,
            text: month.text,
            variant: model.value === month.value ? "flat" : "text",
            onClick: () => onClick(i2)
          };
          function onClick(i3) {
            if (model.value === i3) {
              emit2("update:modelValue", model.value);
              return;
            }
            model.value = i3;
          }
          return ((_a2 = slots.month) == null ? void 0 : _a2.call(slots, {
            month,
            i: i2,
            props: btnProps
          })) ?? createVNode(VBtn, mergeProps({
            "key": "month"
          }, btnProps), null);
        })])]));
        return {};
      }
    });
    const makeVDatePickerYearsProps = propsFactory({
      color: String,
      height: [String, Number],
      min: null,
      max: null,
      modelValue: Number
    }, "VDatePickerYears");
    const VDatePickerYears = genericComponent()({
      name: "VDatePickerYears",
      props: makeVDatePickerYearsProps(),
      emits: {
        "update:modelValue": (year) => true
      },
      setup(props, _ref) {
        let {
          emit: emit2,
          slots
        } = _ref;
        const adapter = useDate();
        const model = useProxiedModel(props, "modelValue");
        const years = computed(() => {
          const year = adapter.getYear(adapter.date());
          let min = year - 100;
          let max = year + 52;
          if (props.min) {
            min = adapter.getYear(adapter.date(props.min));
          }
          if (props.max) {
            max = adapter.getYear(adapter.date(props.max));
          }
          let date2 = adapter.startOfYear(adapter.date());
          date2 = adapter.setYear(date2, min);
          return createRange(max - min + 1, min).map((i2) => {
            const text2 = adapter.format(date2, "year");
            date2 = adapter.setYear(date2, adapter.getYear(date2) + 1);
            return {
              text: text2,
              value: i2
            };
          });
        });
        watchEffect(() => {
          model.value = model.value ?? adapter.getYear(adapter.date());
        });
        const yearRef = ref$1();
        onMounted(async () => {
          var _a2;
          await nextTick();
          (_a2 = yearRef.value) == null ? void 0 : _a2.$el.scrollIntoView({
            block: "center"
          });
        });
        useRender(() => createVNode("div", {
          "class": "v-date-picker-years",
          "style": {
            height: convertToUnit(props.height)
          }
        }, [createVNode("div", {
          "class": "v-date-picker-years__content"
        }, [years.value.map((year, i2) => {
          var _a2;
          const btnProps = {
            ref: model.value === year.value ? yearRef : void 0,
            active: model.value === year.value,
            color: model.value === year.value ? props.color : void 0,
            rounded: true,
            text: year.text,
            variant: model.value === year.value ? "flat" : "text",
            onClick: () => {
              if (model.value === year.value) {
                emit2("update:modelValue", model.value);
                return;
              }
              model.value = year.value;
            }
          };
          return ((_a2 = slots.year) == null ? void 0 : _a2.call(slots, {
            year,
            i: i2,
            props: btnProps
          })) ?? createVNode(VBtn, mergeProps({
            "key": "month"
          }, btnProps), null);
        })])]));
        return {};
      }
    });
    const VPickerTitle = createSimpleFunctional("v-picker-title");
    const makeVPickerProps = propsFactory({
      bgColor: String,
      landscape: Boolean,
      title: String,
      hideHeader: Boolean,
      ...makeVSheetProps()
    }, "VPicker");
    const VPicker = genericComponent()({
      name: "VPicker",
      props: makeVPickerProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(toRef(props, "color"));
        useRender(() => {
          const sheetProps = VSheet.filterProps(props);
          const hasTitle = !!(props.title || slots.title);
          return createVNode(VSheet, mergeProps(sheetProps, {
            "color": props.bgColor,
            "class": ["v-picker", {
              "v-picker--landscape": props.landscape,
              "v-picker--with-actions": !!slots.actions
            }, props.class],
            "style": props.style
          }), {
            default: () => {
              var _a2;
              return [!props.hideHeader && createVNode("div", {
                "key": "header",
                "class": [backgroundColorClasses.value],
                "style": [backgroundColorStyles.value]
              }, [hasTitle && createVNode(VPickerTitle, {
                "key": "picker-title"
              }, {
                default: () => {
                  var _a3;
                  return [((_a3 = slots.title) == null ? void 0 : _a3.call(slots)) ?? props.title];
                }
              }), slots.header && createVNode("div", {
                "class": "v-picker__header"
              }, [slots.header()])]), createVNode("div", {
                "class": "v-picker__body"
              }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), slots.actions && createVNode(VDefaultsProvider, {
                "defaults": {
                  VBtn: {
                    slim: true,
                    variant: "text"
                  }
                }
              }, {
                default: () => [createVNode("div", {
                  "class": "v-picker__actions"
                }, [slots.actions()])]
              })];
            }
          });
        });
        return {};
      }
    });
    const makeVDatePickerProps = propsFactory({
      // TODO: implement in v3.5
      // calendarIcon: {
      //   type: String,
      //   default: '$calendar',
      // },
      // keyboardIcon: {
      //   type: String,
      //   default: '$edit',
      // },
      // inputMode: {
      //   type: String as PropType<'calendar' | 'keyboard'>,
      //   default: 'calendar',
      // },
      // inputText: {
      //   type: String,
      //   default: '$vuetify.datePicker.input.placeholder',
      // },
      // inputPlaceholder: {
      //   type: String,
      //   default: 'dd/mm/yyyy',
      // },
      header: {
        type: String,
        default: "$vuetify.datePicker.header"
      },
      ...makeVDatePickerControlsProps(),
      ...makeVDatePickerMonthProps(),
      ...omit$1(makeVDatePickerMonthsProps(), ["modelValue"]),
      ...omit$1(makeVDatePickerYearsProps(), ["modelValue"]),
      ...makeVPickerProps({
        title: "$vuetify.datePicker.title"
      }),
      modelValue: null
    }, "VDatePicker");
    const VDatePicker = genericComponent()({
      name: "VDatePicker",
      props: makeVDatePickerProps(),
      emits: {
        "update:modelValue": (date2) => true,
        "update:month": (date2) => true,
        "update:year": (date2) => true,
        // 'update:inputMode': (date: any) => true,
        "update:viewMode": (date2) => true
      },
      setup(props, _ref) {
        let {
          emit: emit2,
          slots
        } = _ref;
        const adapter = useDate();
        const {
          t
        } = useLocale();
        const model = useProxiedModel(props, "modelValue", void 0, (v) => wrapInArray(v), (v) => props.multiple ? v : v[0]);
        const viewMode = useProxiedModel(props, "viewMode");
        const internal = computed(() => {
          var _a2;
          const value = adapter.date((_a2 = model.value) == null ? void 0 : _a2[0]);
          return value && adapter.isValid(value) ? value : adapter.date();
        });
        const month = ref$1(Number(props.month ?? adapter.getMonth(adapter.startOfMonth(internal.value))));
        const year = ref$1(Number(props.year ?? adapter.getYear(adapter.startOfYear(adapter.setMonth(internal.value, month.value)))));
        const isReversing = shallowRef(false);
        const header = computed(() => {
          return props.multiple && model.value.length > 1 ? t("$vuetify.datePicker.itemsSelected", model.value.length) : model.value[0] && adapter.isValid(model.value[0]) ? adapter.format(model.value[0], "normalDateWithWeekday") : t(props.header);
        });
        const text2 = computed(() => {
          return adapter.format(adapter.date(new Date(year.value, month.value, 1)), "monthAndYear");
        });
        const headerTransition = computed(() => `date-picker-header${isReversing.value ? "-reverse" : ""}-transition`);
        const minDate = computed(() => {
          const date2 = adapter.date(props.min);
          return props.min && adapter.isValid(date2) ? date2 : null;
        });
        const maxDate = computed(() => {
          const date2 = adapter.date(props.max);
          return props.max && adapter.isValid(date2) ? date2 : null;
        });
        const disabled = computed(() => {
          if (props.disabled)
            return true;
          const targets = [];
          if (viewMode.value !== "month") {
            targets.push(...["prev", "next"]);
          } else {
            let _date = adapter.date();
            _date = adapter.setYear(_date, year.value);
            _date = adapter.setMonth(_date, month.value);
            if (minDate.value) {
              const date2 = adapter.addDays(adapter.startOfMonth(_date), -1);
              adapter.isAfter(minDate.value, date2) && targets.push("prev");
            }
            if (maxDate.value) {
              const date2 = adapter.addDays(adapter.endOfMonth(_date), 1);
              adapter.isAfter(date2, maxDate.value) && targets.push("next");
            }
          }
          return targets;
        });
        function onClickNext() {
          if (month.value < 11) {
            month.value++;
          } else {
            year.value++;
            month.value = 0;
            onUpdateYear(year.value);
          }
          onUpdateMonth(month.value);
        }
        function onClickPrev() {
          if (month.value > 0) {
            month.value--;
          } else {
            year.value--;
            month.value = 11;
            onUpdateYear(year.value);
          }
          onUpdateMonth(month.value);
        }
        function onClickDate() {
          viewMode.value = "month";
        }
        function onClickMonth() {
          viewMode.value = viewMode.value === "months" ? "month" : "months";
        }
        function onClickYear() {
          viewMode.value = viewMode.value === "year" ? "month" : "year";
        }
        function onUpdateMonth(value) {
          if (viewMode.value === "months")
            onClickMonth();
          emit2("update:month", value);
        }
        function onUpdateYear(value) {
          if (viewMode.value === "year")
            onClickYear();
          emit2("update:year", value);
        }
        watch(model, (val, oldVal) => {
          const before = adapter.date(wrapInArray(val)[0]);
          const after = adapter.date(wrapInArray(oldVal)[0]);
          isReversing.value = adapter.isBefore(before, after);
        });
        useRender(() => {
          const pickerProps = VPicker.filterProps(props);
          const datePickerControlsProps = VDatePickerControls.filterProps(props);
          const datePickerHeaderProps = VDatePickerHeader.filterProps(props);
          const datePickerMonthProps = VDatePickerMonth.filterProps(props);
          const datePickerMonthsProps = omit$1(VDatePickerMonths.filterProps(props), ["modelValue"]);
          const datePickerYearsProps = omit$1(VDatePickerYears.filterProps(props), ["modelValue"]);
          const headerProps = {
            header: header.value,
            transition: headerTransition.value
          };
          return createVNode(VPicker, mergeProps(pickerProps, {
            "class": ["v-date-picker", `v-date-picker--${viewMode.value}`, {
              "v-date-picker--show-week": props.showWeek
            }, props.class],
            "style": props.style
          }), {
            title: () => {
              var _a2;
              return ((_a2 = slots.title) == null ? void 0 : _a2.call(slots)) ?? createVNode("div", {
                "class": "v-date-picker__title"
              }, [t(props.title)]);
            },
            header: () => slots.header ? createVNode(VDefaultsProvider, {
              "defaults": {
                VDatePickerHeader: {
                  ...headerProps
                }
              }
            }, {
              default: () => {
                var _a2;
                return [(_a2 = slots.header) == null ? void 0 : _a2.call(slots, headerProps)];
              }
            }) : createVNode(VDatePickerHeader, mergeProps({
              "key": "header"
            }, datePickerHeaderProps, headerProps, {
              "onClick": viewMode.value !== "month" ? onClickDate : void 0
            }), {
              ...slots,
              default: void 0
            }),
            default: () => createVNode(Fragment, null, [createVNode(VDatePickerControls, mergeProps(datePickerControlsProps, {
              "disabled": disabled.value,
              "text": text2.value,
              "onClick:next": onClickNext,
              "onClick:prev": onClickPrev,
              "onClick:month": onClickMonth,
              "onClick:year": onClickYear
            }), null), createVNode(VFadeTransition, {
              "hideOnLeave": true
            }, {
              default: () => [viewMode.value === "months" ? createVNode(VDatePickerMonths, mergeProps({
                "key": "date-picker-months"
              }, datePickerMonthsProps, {
                "modelValue": month.value,
                "onUpdate:modelValue": [($event) => month.value = $event, onUpdateMonth],
                "min": minDate.value,
                "max": maxDate.value
              }), null) : viewMode.value === "year" ? createVNode(VDatePickerYears, mergeProps({
                "key": "date-picker-years"
              }, datePickerYearsProps, {
                "modelValue": year.value,
                "onUpdate:modelValue": [($event) => year.value = $event, onUpdateYear],
                "min": minDate.value,
                "max": maxDate.value
              }), null) : createVNode(VDatePickerMonth, mergeProps({
                "key": "date-picker-month"
              }, datePickerMonthProps, {
                "modelValue": model.value,
                "onUpdate:modelValue": ($event) => model.value = $event,
                "month": month.value,
                "onUpdate:month": [($event) => month.value = $event, onUpdateMonth],
                "year": year.value,
                "onUpdate:year": [($event) => year.value = $event, onUpdateYear],
                "min": minDate.value,
                "max": maxDate.value
              }), null)]
            })]),
            actions: slots.actions
          });
        });
        return {};
      }
    });
    const makeVFileInputProps = propsFactory({
      chips: Boolean,
      counter: Boolean,
      counterSizeString: {
        type: String,
        default: "$vuetify.fileInput.counterSize"
      },
      counterString: {
        type: String,
        default: "$vuetify.fileInput.counter"
      },
      multiple: Boolean,
      showSize: {
        type: [Boolean, Number, String],
        default: false,
        validator: (v) => {
          return typeof v === "boolean" || [1e3, 1024].includes(Number(v));
        }
      },
      ...makeVInputProps({
        prependIcon: "$file"
      }),
      modelValue: {
        type: Array,
        default: () => [],
        validator: (val) => {
          return wrapInArray(val).every((v) => v != null && typeof v === "object");
        }
      },
      ...makeVFieldProps({
        clearable: true
      })
    }, "VFileInput");
    const VFileInput = genericComponent()({
      name: "VFileInput",
      inheritAttrs: false,
      props: makeVFileInputProps(),
      emits: {
        "click:control": (e) => true,
        "mousedown:control": (e) => true,
        "update:focused": (focused) => true,
        "update:modelValue": (files) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          emit: emit2,
          slots
        } = _ref;
        const {
          t
        } = useLocale();
        const model = useProxiedModel(props, "modelValue");
        const {
          isFocused,
          focus,
          blur
        } = useFocus(props);
        const base2 = computed(() => typeof props.showSize !== "boolean" ? props.showSize : void 0);
        const totalBytes = computed(() => (model.value ?? []).reduce((bytes, _ref2) => {
          let {
            size: size2 = 0
          } = _ref2;
          return bytes + size2;
        }, 0));
        const totalBytesReadable = computed(() => humanReadableFileSize(totalBytes.value, base2.value));
        const fileNames = computed(() => (model.value ?? []).map((file) => {
          const {
            name = "",
            size: size2 = 0
          } = file;
          return !props.showSize ? name : `${name} (${humanReadableFileSize(size2, base2.value)})`;
        }));
        const counterValue = computed(() => {
          var _a2;
          const fileCount = ((_a2 = model.value) == null ? void 0 : _a2.length) ?? 0;
          if (props.showSize)
            return t(props.counterSizeString, fileCount, totalBytesReadable.value);
          else
            return t(props.counterString, fileCount);
        });
        const vInputRef = ref$1();
        const vFieldRef = ref$1();
        const inputRef = ref$1();
        const isActive = computed(() => isFocused.value || props.active);
        const isPlainOrUnderlined = computed(() => ["plain", "underlined"].includes(props.variant));
        function onFocus() {
          var _a2;
          if (inputRef.value !== document.activeElement) {
            (_a2 = inputRef.value) == null ? void 0 : _a2.focus();
          }
          if (!isFocused.value)
            focus();
        }
        function onClickPrepend(e) {
          var _a2;
          (_a2 = inputRef.value) == null ? void 0 : _a2.click();
        }
        function onControlMousedown(e) {
          emit2("mousedown:control", e);
        }
        function onControlClick(e) {
          var _a2;
          (_a2 = inputRef.value) == null ? void 0 : _a2.click();
          emit2("click:control", e);
        }
        function onClear(e) {
          e.stopPropagation();
          onFocus();
          nextTick(() => {
            model.value = [];
            callEvent(props["onClick:clear"], e);
          });
        }
        watch(model, (newValue) => {
          const hasModelReset = !Array.isArray(newValue) || !newValue.length;
          if (hasModelReset && inputRef.value) {
            inputRef.value.value = "";
          }
        });
        useRender(() => {
          const hasCounter = !!(slots.counter || props.counter);
          const hasDetails = !!(hasCounter || slots.details);
          const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
          const {
            modelValue: _,
            ...inputProps
          } = VInput.filterProps(props);
          const fieldProps = filterFieldProps(props);
          return createVNode(VInput, mergeProps({
            "ref": vInputRef,
            "modelValue": model.value,
            "onUpdate:modelValue": ($event) => model.value = $event,
            "class": ["v-file-input", {
              "v-file-input--chips": !!props.chips,
              "v-input--plain-underlined": isPlainOrUnderlined.value
            }, props.class],
            "style": props.style,
            "onClick:prepend": onClickPrepend
          }, rootAttrs, inputProps, {
            "centerAffix": !isPlainOrUnderlined.value,
            "focused": isFocused.value
          }), {
            ...slots,
            default: (_ref3) => {
              let {
                id: id2,
                isDisabled,
                isDirty,
                isReadonly: isReadonly2,
                isValid: isValid2
              } = _ref3;
              return createVNode(VField, mergeProps({
                "ref": vFieldRef,
                "prepend-icon": props.prependIcon,
                "onMousedown": onControlMousedown,
                "onClick": onControlClick,
                "onClick:clear": onClear,
                "onClick:prependInner": props["onClick:prependInner"],
                "onClick:appendInner": props["onClick:appendInner"]
              }, fieldProps, {
                "id": id2.value,
                "active": isActive.value || isDirty.value,
                "dirty": isDirty.value,
                "disabled": isDisabled.value,
                "focused": isFocused.value,
                "error": isValid2.value === false
              }), {
                ...slots,
                default: (_ref4) => {
                  var _a2;
                  let {
                    props: {
                      class: fieldClass,
                      ...slotProps
                    }
                  } = _ref4;
                  return createVNode(Fragment, null, [createVNode("input", mergeProps({
                    "ref": inputRef,
                    "type": "file",
                    "readonly": isReadonly2.value,
                    "disabled": isDisabled.value,
                    "multiple": props.multiple,
                    "name": props.name,
                    "onClick": (e) => {
                      e.stopPropagation();
                      if (isReadonly2.value)
                        e.preventDefault();
                      onFocus();
                    },
                    "onChange": (e) => {
                      if (!e.target)
                        return;
                      const target2 = e.target;
                      model.value = [...target2.files ?? []];
                    },
                    "onFocus": onFocus,
                    "onBlur": blur
                  }, slotProps, inputAttrs), null), createVNode("div", {
                    "class": fieldClass
                  }, [!!((_a2 = model.value) == null ? void 0 : _a2.length) && (slots.selection ? slots.selection({
                    fileNames: fileNames.value,
                    totalBytes: totalBytes.value,
                    totalBytesReadable: totalBytesReadable.value
                  }) : props.chips ? fileNames.value.map((text2) => createVNode(VChip, {
                    "key": text2,
                    "size": "small",
                    "color": props.color
                  }, {
                    default: () => [text2]
                  })) : fileNames.value.join(", "))])]);
                }
              });
            },
            details: hasDetails ? (slotProps) => {
              var _a2, _b;
              return createVNode(Fragment, null, [(_a2 = slots.details) == null ? void 0 : _a2.call(slots, slotProps), hasCounter && createVNode(Fragment, null, [createVNode("span", null, null), createVNode(VCounter, {
                "active": !!((_b = model.value) == null ? void 0 : _b.length),
                "value": counterValue.value
              }, slots.counter)])]);
            } : void 0
          });
        });
        return forwardRefs({}, vInputRef, vFieldRef, inputRef);
      }
    });
    const makeVFormProps = propsFactory({
      ...makeComponentProps(),
      ...makeFormProps()
    }, "VForm");
    const VForm = genericComponent()({
      name: "VForm",
      props: makeVFormProps(),
      emits: {
        "update:modelValue": (val) => true,
        submit: (e) => true
      },
      setup(props, _ref) {
        let {
          slots,
          emit: emit2
        } = _ref;
        const form = createForm(props);
        const formRef = ref$1();
        function onReset(e) {
          e.preventDefault();
          form.reset();
        }
        function onSubmit(_e) {
          const e = _e;
          const ready = form.validate();
          e.then = ready.then.bind(ready);
          e.catch = ready.catch.bind(ready);
          e.finally = ready.finally.bind(ready);
          emit2("submit", e);
          if (!e.defaultPrevented) {
            ready.then((_ref2) => {
              var _a2;
              let {
                valid
              } = _ref2;
              if (valid) {
                (_a2 = formRef.value) == null ? void 0 : _a2.submit();
              }
            });
          }
          e.preventDefault();
        }
        useRender(() => {
          var _a2;
          return createVNode("form", {
            "ref": formRef,
            "class": ["v-form", props.class],
            "style": props.style,
            "novalidate": true,
            "onReset": onReset,
            "onSubmit": onSubmit
          }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, form)]);
        });
        return forwardRefs(form, formRef);
      }
    });
    const makeVStepperActionsProps = propsFactory({
      color: String,
      disabled: {
        type: [Boolean, String],
        default: false
      },
      prevText: {
        type: String,
        default: "$vuetify.stepper.prev"
      },
      nextText: {
        type: String,
        default: "$vuetify.stepper.next"
      }
    }, "VStepperActions");
    const VStepperActions = genericComponent()({
      name: "VStepperActions",
      props: makeVStepperActionsProps(),
      emits: {
        "click:prev": () => true,
        "click:next": () => true
      },
      setup(props, _ref) {
        let {
          emit: emit2,
          slots
        } = _ref;
        const {
          t
        } = useLocale();
        function onClickPrev() {
          emit2("click:prev");
        }
        function onClickNext() {
          emit2("click:next");
        }
        useRender(() => {
          const prevSlotProps = {
            onClick: onClickPrev
          };
          const nextSlotProps = {
            onClick: onClickNext
          };
          return createVNode("div", {
            "class": "v-stepper-actions"
          }, [createVNode(VDefaultsProvider, {
            "defaults": {
              VBtn: {
                disabled: ["prev", true].includes(props.disabled),
                text: t(props.prevText),
                variant: "text"
              }
            }
          }, {
            default: () => {
              var _a2;
              return [((_a2 = slots.prev) == null ? void 0 : _a2.call(slots, {
                props: prevSlotProps
              })) ?? createVNode(VBtn, prevSlotProps, null)];
            }
          }), createVNode(VDefaultsProvider, {
            "defaults": {
              VBtn: {
                color: props.color,
                disabled: ["next", true].includes(props.disabled),
                text: t(props.nextText),
                variant: "tonal"
              }
            }
          }, {
            default: () => {
              var _a2;
              return [((_a2 = slots.next) == null ? void 0 : _a2.call(slots, {
                props: nextSlotProps
              })) ?? createVNode(VBtn, nextSlotProps, null)];
            }
          })]);
        });
        return {};
      }
    });
    const VStepperHeader = createSimpleFunctional("v-stepper-header");
    const makeVStepperItemProps = propsFactory({
      color: String,
      title: String,
      subtitle: String,
      complete: Boolean,
      completeIcon: {
        type: String,
        default: "$complete"
      },
      editable: Boolean,
      editIcon: {
        type: String,
        default: "$edit"
      },
      error: Boolean,
      errorIcon: {
        type: String,
        default: "$error"
      },
      icon: String,
      ripple: {
        type: [Boolean, Object],
        default: true
      },
      rules: {
        type: Array,
        default: () => []
      },
      ...makeGroupItemProps()
    }, "VStepperItem");
    const VStepperItem = genericComponent()({
      name: "VStepperItem",
      directives: {
        Ripple
      },
      props: makeVStepperItemProps(),
      emits: {
        "group:selected": (val) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const group = useGroupItem(props, VStepperSymbol, true);
        const step = computed(() => (group == null ? void 0 : group.value.value) ?? props.value);
        const isValid2 = computed(() => props.rules.every((handler) => handler() === true));
        const canEdit = computed(() => !props.disabled && props.editable);
        const hasError = computed(() => props.error || !isValid2.value);
        const hasCompleted = computed(() => props.complete || props.rules.length > 0 && isValid2.value);
        const icon = computed(() => {
          if (hasError.value)
            return props.errorIcon;
          if (hasCompleted.value)
            return props.completeIcon;
          if (props.editable)
            return props.editIcon;
          return props.icon;
        });
        const slotProps = computed(() => ({
          canEdit: canEdit.value,
          hasError: hasError.value,
          hasCompleted: hasCompleted.value,
          title: props.title,
          subtitle: props.subtitle,
          step: step.value,
          value: props.value
        }));
        useRender(() => {
          var _a2, _b, _c;
          const hasColor = (!group || group.isSelected.value || hasCompleted.value || canEdit.value) && !hasError.value && !props.disabled;
          const hasTitle = !!(props.title != null || slots.title);
          const hasSubtitle = !!(props.subtitle != null || slots.subtitle);
          function onClick() {
            group == null ? void 0 : group.toggle();
          }
          return withDirectives(createVNode("button", {
            "class": ["v-stepper-item", {
              "v-stepper-item--complete": hasCompleted.value,
              "v-stepper-item--disabled": props.disabled,
              "v-stepper-item--error": hasError.value
            }, group == null ? void 0 : group.selectedClass.value],
            "disabled": !props.editable,
            "onClick": onClick
          }, [createVNode(VAvatar, {
            "key": "stepper-avatar",
            "class": "v-stepper-item__avatar",
            "color": hasColor ? props.color : void 0,
            "size": 24
          }, {
            default: () => {
              var _a3;
              return [((_a3 = slots.icon) == null ? void 0 : _a3.call(slots, slotProps.value)) ?? (icon.value ? createVNode(VIcon, {
                "icon": icon.value
              }, null) : step.value)];
            }
          }), createVNode("div", {
            "class": "v-stepper-item__content"
          }, [hasTitle && createVNode("div", {
            "key": "title",
            "class": "v-stepper-item__title"
          }, [((_a2 = slots.title) == null ? void 0 : _a2.call(slots, slotProps.value)) ?? props.title]), hasSubtitle && createVNode("div", {
            "key": "subtitle",
            "class": "v-stepper-item__subtitle"
          }, [((_b = slots.subtitle) == null ? void 0 : _b.call(slots, slotProps.value)) ?? props.subtitle]), (_c = slots.default) == null ? void 0 : _c.call(slots, slotProps.value)])]), [[resolveDirective("ripple"), props.ripple && props.editable, null]]);
        });
        return {};
      }
    });
    const VStepperSymbol$1 = Symbol.for("vuetify:v-stepper");
    const makeVStepperWindowProps = propsFactory({
      ...omit$1(makeVWindowProps(), ["continuous", "nextIcon", "prevIcon", "showArrows", "touch", "mandatory"])
    }, "VStepperWindow");
    const VStepperWindow = genericComponent()({
      name: "VStepperWindow",
      props: makeVStepperWindowProps(),
      emits: {
        "update:modelValue": (v) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const group = inject$1(VStepperSymbol$1, null);
        const _model = useProxiedModel(props, "modelValue");
        const model = computed({
          get() {
            var _a2;
            if (_model.value != null || !group)
              return _model.value;
            return (_a2 = group.items.value.find((item) => group.selected.value.includes(item.id))) == null ? void 0 : _a2.value;
          },
          set(val) {
            _model.value = val;
          }
        });
        useRender(() => {
          const windowProps = VWindow.filterProps(props);
          return createVNode(VWindow, mergeProps({
            "_as": "VStepperWindow"
          }, windowProps, {
            "modelValue": model.value,
            "onUpdate:modelValue": ($event) => model.value = $event,
            "class": "v-stepper-window",
            "mandatory": false,
            "touch": false
          }), slots);
        });
        return {};
      }
    });
    const makeVStepperWindowItemProps = propsFactory({
      ...makeVWindowItemProps()
    }, "VStepperWindowItem");
    const VStepperWindowItem = genericComponent()({
      name: "VStepperWindowItem",
      props: makeVStepperWindowItemProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        useRender(() => {
          const windowItemProps = VWindowItem.filterProps(props);
          return createVNode(VWindowItem, mergeProps({
            "_as": "VStepperWindowItem"
          }, windowItemProps, {
            "class": "v-stepper-window-item"
          }), slots);
        });
        return {};
      }
    });
    const VStepperSymbol = Symbol.for("vuetify:v-stepper");
    const makeVStepperProps = propsFactory({
      altLabels: Boolean,
      bgColor: String,
      editable: Boolean,
      hideActions: Boolean,
      items: {
        type: Array,
        default: () => []
      },
      itemTitle: {
        type: String,
        default: "title"
      },
      itemValue: {
        type: String,
        default: "value"
      },
      mobile: Boolean,
      nonLinear: Boolean,
      flat: Boolean,
      ...makeGroupProps({
        mandatory: "force",
        selectedClass: "v-stepper-item--selected"
      }),
      ...makeVSheetProps(),
      ...only(makeVStepperActionsProps(), ["prevText", "nextText"])
    }, "VStepper");
    const VStepper = genericComponent()({
      name: "VStepper",
      props: makeVStepperProps(),
      emits: {
        "update:modelValue": (v) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          items: _items,
          next: next2,
          prev,
          selected
        } = useGroup(props, VStepperSymbol);
        const {
          color,
          editable,
          prevText,
          nextText
        } = toRefs(props);
        const items2 = computed(() => props.items.map((item, index) => {
          const title2 = getPropertyFromItem(item, props.itemTitle, item);
          const value = getPropertyFromItem(item, props.itemValue, index + 1);
          return {
            title: title2,
            value,
            raw: item
          };
        }));
        const activeIndex = computed(() => {
          return _items.value.findIndex((item) => selected.value.includes(item.id));
        });
        const disabled = computed(() => {
          if (props.disabled)
            return props.disabled;
          if (activeIndex.value === 0)
            return "prev";
          if (activeIndex.value === _items.value.length - 1)
            return "next";
          return false;
        });
        provideDefaults({
          VStepperItem: {
            editable,
            prevText,
            nextText
          },
          VStepperActions: {
            color,
            disabled,
            prevText,
            nextText
          }
        });
        useRender(() => {
          const sheetProps = VSheet.filterProps(props);
          const hasHeader = !!(slots.header || props.items.length);
          const hasWindow = props.items.length > 0;
          const hasActions = !props.hideActions && !!(hasWindow || slots.actions);
          return createVNode(VSheet, mergeProps(sheetProps, {
            "color": props.bgColor,
            "class": ["v-stepper", {
              "v-stepper--alt-labels": props.altLabels,
              "v-stepper--flat": props.flat,
              "v-stepper--non-linear": props.nonLinear,
              "v-stepper--mobile": props.mobile
            }, props.class],
            "style": props.style
          }), {
            default: () => {
              var _a2, _b;
              return [hasHeader && createVNode(VStepperHeader, {
                "key": "stepper-header"
              }, {
                default: () => [items2.value.map((item, index) => createVNode(Fragment, null, [!!index && createVNode(VDivider, null, null), createVNode(VStepperItem, item, {
                  default: slots[`header-item.${item.value}`] ?? slots.header,
                  icon: slots.icon,
                  title: slots.title,
                  subtitle: slots.subtitle
                })]))]
              }), hasWindow && createVNode(VStepperWindow, {
                "key": "stepper-window"
              }, {
                default: () => [items2.value.map((item) => createVNode(VStepperWindowItem, {
                  "value": item.value
                }, {
                  default: () => {
                    var _a3, _b2;
                    return ((_a3 = slots[`item.${item.value}`]) == null ? void 0 : _a3.call(slots, item)) ?? ((_b2 = slots.item) == null ? void 0 : _b2.call(slots, item));
                  }
                }))]
              }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
                prev,
                next: next2
              }), hasActions && (((_b = slots.actions) == null ? void 0 : _b.call(slots, {
                next: next2,
                prev
              })) ?? createVNode(VStepperActions, {
                "key": "stepper-actions",
                "onClick:prev": prev,
                "onClick:next": next2
              }, slots))];
            }
          });
        });
        return {
          prev,
          next: next2
        };
      }
    });
    const makeVSwitchProps = propsFactory({
      indeterminate: Boolean,
      inset: Boolean,
      flat: Boolean,
      loading: {
        type: [Boolean, String],
        default: false
      },
      ...makeVInputProps(),
      ...makeVSelectionControlProps()
    }, "VSwitch");
    const VSwitch = genericComponent()({
      name: "VSwitch",
      inheritAttrs: false,
      props: makeVSwitchProps(),
      emits: {
        "update:focused": (focused) => true,
        "update:modelValue": (value) => true,
        "update:indeterminate": (value) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          slots
        } = _ref;
        const indeterminate = useProxiedModel(props, "indeterminate");
        const model = useProxiedModel(props, "modelValue");
        const {
          loaderClasses
        } = useLoader(props);
        const {
          isFocused,
          focus,
          blur
        } = useFocus(props);
        const control = ref$1();
        const loaderColor = computed(() => {
          return typeof props.loading === "string" && props.loading !== "" ? props.loading : props.color;
        });
        const uid2 = getUid();
        const id2 = computed(() => props.id || `switch-${uid2}`);
        function onChange() {
          if (indeterminate.value) {
            indeterminate.value = false;
          }
        }
        function onTrackClick(e) {
          var _a2, _b;
          e.stopPropagation();
          e.preventDefault();
          (_b = (_a2 = control.value) == null ? void 0 : _a2.input) == null ? void 0 : _b.click();
        }
        useRender(() => {
          const [rootAttrs, controlAttrs] = filterInputAttrs(attrs);
          const inputProps = VInput.filterProps(props);
          const controlProps = VSelectionControl.filterProps(props);
          return createVNode(VInput, mergeProps({
            "class": ["v-switch", {
              "v-switch--inset": props.inset
            }, {
              "v-switch--indeterminate": indeterminate.value
            }, loaderClasses.value, props.class]
          }, rootAttrs, inputProps, {
            "modelValue": model.value,
            "onUpdate:modelValue": ($event) => model.value = $event,
            "id": id2.value,
            "focused": isFocused.value,
            "style": props.style
          }), {
            ...slots,
            default: (_ref2) => {
              let {
                id: id3,
                messagesId,
                isDisabled,
                isReadonly: isReadonly2,
                isValid: isValid2
              } = _ref2;
              const slotProps = {
                model,
                isValid: isValid2
              };
              return createVNode(VSelectionControl, mergeProps({
                "ref": control
              }, controlProps, {
                "modelValue": model.value,
                "onUpdate:modelValue": [($event) => model.value = $event, onChange],
                "id": id3.value,
                "aria-describedby": messagesId.value,
                "type": "checkbox",
                "aria-checked": indeterminate.value ? "mixed" : void 0,
                "disabled": isDisabled.value,
                "readonly": isReadonly2.value,
                "onFocus": focus,
                "onBlur": blur
              }, controlAttrs), {
                ...slots,
                default: (_ref3) => {
                  let {
                    backgroundColorClasses,
                    backgroundColorStyles
                  } = _ref3;
                  return createVNode("div", {
                    "class": ["v-switch__track", ...backgroundColorClasses.value],
                    "style": backgroundColorStyles.value,
                    "onClick": onTrackClick
                  }, [slots["track-true"] && createVNode("div", {
                    "key": "prepend",
                    "class": "v-switch__track-true"
                  }, [slots["track-true"](slotProps)]), slots["track-false"] && createVNode("div", {
                    "key": "append",
                    "class": "v-switch__track-false"
                  }, [slots["track-false"](slotProps)])]);
                },
                input: (_ref4) => {
                  let {
                    inputNode,
                    icon,
                    backgroundColorClasses,
                    backgroundColorStyles
                  } = _ref4;
                  return createVNode(Fragment, null, [inputNode, createVNode("div", {
                    "class": ["v-switch__thumb", {
                      "v-switch__thumb--filled": icon || props.loading
                    }, props.inset ? void 0 : backgroundColorClasses.value],
                    "style": props.inset ? void 0 : backgroundColorStyles.value
                  }, [slots.thumb ? createVNode(VDefaultsProvider, {
                    "defaults": {
                      VIcon: {
                        icon,
                        size: "x-small"
                      }
                    }
                  }, {
                    default: () => [slots.thumb({
                      ...slotProps,
                      icon
                    })]
                  }) : createVNode(VScaleTransition, null, {
                    default: () => [!props.loading ? icon && createVNode(VIcon, {
                      "key": String(icon),
                      "icon": icon,
                      "size": "x-small"
                    }, null) : createVNode(LoaderSlot, {
                      "name": "v-switch",
                      "active": true,
                      "color": isValid2.value === false ? void 0 : loaderColor.value
                    }, {
                      default: (slotProps2) => slots.loader ? slots.loader(slotProps2) : createVNode(VProgressCircular, {
                        "active": slotProps2.isActive,
                        "color": slotProps2.color,
                        "indeterminate": true,
                        "size": "16",
                        "width": "2"
                      }, null)
                    })]
                  })])]);
                }
              });
            }
          });
        });
        return {};
      }
    });
    const VTabsSymbol = Symbol.for("vuetify:v-tabs");
    const makeVTabProps = propsFactory({
      fixed: Boolean,
      sliderColor: String,
      hideSlider: Boolean,
      direction: {
        type: String,
        default: "horizontal"
      },
      ...omit$1(makeVBtnProps({
        selectedClass: "v-tab--selected",
        variant: "text"
      }), ["active", "block", "flat", "location", "position", "symbol"])
    }, "VTab");
    const VTab = genericComponent()({
      name: "VTab",
      props: makeVTabProps(),
      setup(props, _ref) {
        let {
          slots,
          attrs
        } = _ref;
        const {
          textColorClasses: sliderColorClasses,
          textColorStyles: sliderColorStyles
        } = useTextColor(props, "sliderColor");
        const rootEl = ref$1();
        const sliderEl = ref$1();
        const isHorizontal = computed(() => props.direction === "horizontal");
        const isSelected = computed(() => {
          var _a2, _b;
          return ((_b = (_a2 = rootEl.value) == null ? void 0 : _a2.group) == null ? void 0 : _b.isSelected.value) ?? false;
        });
        function updateSlider(_ref2) {
          var _a2, _b;
          let {
            value
          } = _ref2;
          if (value) {
            const prevEl = (_b = (_a2 = rootEl.value) == null ? void 0 : _a2.$el.parentElement) == null ? void 0 : _b.querySelector(".v-tab--selected .v-tab__slider");
            const nextEl = sliderEl.value;
            if (!prevEl || !nextEl)
              return;
            const color = getComputedStyle(prevEl).color;
            const prevBox = prevEl.getBoundingClientRect();
            const nextBox = nextEl.getBoundingClientRect();
            const xy = isHorizontal.value ? "x" : "y";
            const XY = isHorizontal.value ? "X" : "Y";
            const rightBottom = isHorizontal.value ? "right" : "bottom";
            const widthHeight = isHorizontal.value ? "width" : "height";
            const prevPos = prevBox[xy];
            const nextPos = nextBox[xy];
            const delta2 = prevPos > nextPos ? prevBox[rightBottom] - nextBox[rightBottom] : prevBox[xy] - nextBox[xy];
            const origin = Math.sign(delta2) > 0 ? isHorizontal.value ? "right" : "bottom" : Math.sign(delta2) < 0 ? isHorizontal.value ? "left" : "top" : "center";
            const size2 = Math.abs(delta2) + (Math.sign(delta2) < 0 ? prevBox[widthHeight] : nextBox[widthHeight]);
            const scale = size2 / Math.max(prevBox[widthHeight], nextBox[widthHeight]) || 0;
            const initialScale = prevBox[widthHeight] / nextBox[widthHeight] || 0;
            const sigma2 = 1.5;
            animate(nextEl, {
              backgroundColor: [color, "currentcolor"],
              transform: [`translate${XY}(${delta2}px) scale${XY}(${initialScale})`, `translate${XY}(${delta2 / sigma2}px) scale${XY}(${(scale - 1) / sigma2 + 1})`, "none"],
              transformOrigin: Array(3).fill(origin)
            }, {
              duration: 225,
              easing: standardEasing
            });
          }
        }
        useRender(() => {
          const btnProps = VBtn.filterProps(props);
          return createVNode(VBtn, mergeProps({
            "symbol": VTabsSymbol,
            "ref": rootEl,
            "class": ["v-tab", props.class],
            "style": props.style,
            "tabindex": isSelected.value ? 0 : -1,
            "role": "tab",
            "aria-selected": String(isSelected.value),
            "active": false
          }, btnProps, attrs, {
            "block": props.fixed,
            "maxWidth": props.fixed ? 300 : void 0,
            "onGroup:selected": updateSlider
          }), {
            ...slots,
            default: () => {
              var _a2;
              return createVNode(Fragment, null, [((_a2 = slots.default) == null ? void 0 : _a2.call(slots)) ?? props.text, !props.hideSlider && createVNode("div", {
                "ref": sliderEl,
                "class": ["v-tab__slider", sliderColorClasses.value],
                "style": sliderColorStyles.value
              }, null)]);
            }
          });
        });
        return forwardRefs({}, rootEl);
      }
    });
    function parseItems(items2) {
      if (!items2)
        return [];
      return items2.map((item) => {
        if (!isObject$2(item))
          return {
            text: item,
            value: item
          };
        return item;
      });
    }
    const makeVTabsProps = propsFactory({
      alignTabs: {
        type: String,
        default: "start"
      },
      color: String,
      fixedTabs: Boolean,
      items: {
        type: Array,
        default: () => []
      },
      stacked: Boolean,
      bgColor: String,
      grow: Boolean,
      height: {
        type: [Number, String],
        default: void 0
      },
      hideSlider: Boolean,
      sliderColor: String,
      ...makeVSlideGroupProps({
        mandatory: "force"
      }),
      ...makeDensityProps(),
      ...makeTagProps()
    }, "VTabs");
    const VTabs = genericComponent()({
      name: "VTabs",
      props: makeVTabsProps(),
      emits: {
        "update:modelValue": (v) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const model = useProxiedModel(props, "modelValue");
        const parsedItems = computed(() => parseItems(props.items));
        const {
          densityClasses
        } = useDensity(props);
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(toRef(props, "bgColor"));
        provideDefaults({
          VTab: {
            color: toRef(props, "color"),
            direction: toRef(props, "direction"),
            stacked: toRef(props, "stacked"),
            fixed: toRef(props, "fixedTabs"),
            sliderColor: toRef(props, "sliderColor"),
            hideSlider: toRef(props, "hideSlider")
          }
        });
        useRender(() => {
          const slideGroupProps = VSlideGroup.filterProps(props);
          return createVNode(VSlideGroup, mergeProps(slideGroupProps, {
            "modelValue": model.value,
            "onUpdate:modelValue": ($event) => model.value = $event,
            "class": ["v-tabs", `v-tabs--${props.direction}`, `v-tabs--align-tabs-${props.alignTabs}`, {
              "v-tabs--fixed-tabs": props.fixedTabs,
              "v-tabs--grow": props.grow,
              "v-tabs--stacked": props.stacked
            }, densityClasses.value, backgroundColorClasses.value, props.class],
            "style": [{
              "--v-tabs-height": convertToUnit(props.height)
            }, backgroundColorStyles.value, props.style],
            "role": "tablist",
            "symbol": VTabsSymbol
          }), {
            default: () => [slots.default ? slots.default() : parsedItems.value.map((item) => createVNode(VTab, mergeProps(item, {
              "key": item.text
            }), null))]
          });
        });
        return {};
      }
    });
    const makeVTextareaProps = propsFactory({
      autoGrow: Boolean,
      autofocus: Boolean,
      counter: [Boolean, Number, String],
      counterValue: Function,
      prefix: String,
      placeholder: String,
      persistentPlaceholder: Boolean,
      persistentCounter: Boolean,
      noResize: Boolean,
      rows: {
        type: [Number, String],
        default: 5,
        validator: (v) => !isNaN(parseFloat(v))
      },
      maxRows: {
        type: [Number, String],
        validator: (v) => !isNaN(parseFloat(v))
      },
      suffix: String,
      modelModifiers: Object,
      ...makeVInputProps(),
      ...makeVFieldProps()
    }, "VTextarea");
    const VTextarea = genericComponent()({
      name: "VTextarea",
      directives: {
        Intersect: Intersect$1
      },
      inheritAttrs: false,
      props: makeVTextareaProps(),
      emits: {
        "click:control": (e) => true,
        "mousedown:control": (e) => true,
        "update:focused": (focused) => true,
        "update:modelValue": (val) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          emit: emit2,
          slots
        } = _ref;
        const model = useProxiedModel(props, "modelValue");
        const {
          isFocused,
          focus,
          blur
        } = useFocus(props);
        const counterValue = computed(() => {
          return typeof props.counterValue === "function" ? props.counterValue(model.value) : (model.value || "").toString().length;
        });
        const max = computed(() => {
          if (attrs.maxlength)
            return attrs.maxlength;
          if (!props.counter || typeof props.counter !== "number" && typeof props.counter !== "string")
            return void 0;
          return props.counter;
        });
        function onIntersect(isIntersecting, entries) {
          var _a2, _b;
          if (!props.autofocus || !isIntersecting)
            return;
          (_b = (_a2 = entries[0].target) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
        }
        const vInputRef = ref$1();
        const vFieldRef = ref$1();
        const controlHeight = shallowRef("");
        const textareaRef = ref$1();
        const isActive = computed(() => props.persistentPlaceholder || isFocused.value || props.active);
        function onFocus() {
          var _a2;
          if (textareaRef.value !== document.activeElement) {
            (_a2 = textareaRef.value) == null ? void 0 : _a2.focus();
          }
          if (!isFocused.value)
            focus();
        }
        function onControlClick(e) {
          onFocus();
          emit2("click:control", e);
        }
        function onControlMousedown(e) {
          emit2("mousedown:control", e);
        }
        function onClear(e) {
          e.stopPropagation();
          onFocus();
          nextTick(() => {
            model.value = "";
            callEvent(props["onClick:clear"], e);
          });
        }
        function onInput(e) {
          var _a2;
          const el2 = e.target;
          model.value = el2.value;
          if ((_a2 = props.modelModifiers) == null ? void 0 : _a2.trim) {
            const caretPosition = [el2.selectionStart, el2.selectionEnd];
            nextTick(() => {
              el2.selectionStart = caretPosition[0];
              el2.selectionEnd = caretPosition[1];
            });
          }
        }
        const sizerRef = ref$1();
        const rows = ref$1(+props.rows);
        const isPlainOrUnderlined = computed(() => ["plain", "underlined"].includes(props.variant));
        watchEffect(() => {
          if (!props.autoGrow)
            rows.value = +props.rows;
        });
        function calculateInputHeight() {
          if (!props.autoGrow)
            return;
          nextTick(() => {
            if (!sizerRef.value || !vFieldRef.value)
              return;
            const style = getComputedStyle(sizerRef.value);
            const fieldStyle = getComputedStyle(vFieldRef.value.$el);
            const padding = parseFloat(style.getPropertyValue("--v-field-padding-top")) + parseFloat(style.getPropertyValue("--v-input-padding-top")) + parseFloat(style.getPropertyValue("--v-field-padding-bottom"));
            const height = sizerRef.value.scrollHeight;
            const lineHeight = parseFloat(style.lineHeight);
            const minHeight = Math.max(parseFloat(props.rows) * lineHeight + padding, parseFloat(fieldStyle.getPropertyValue("--v-input-control-height")));
            const maxHeight = parseFloat(props.maxRows) * lineHeight + padding || Infinity;
            const newHeight = clamp(height ?? 0, minHeight, maxHeight);
            rows.value = Math.floor((newHeight - padding) / lineHeight);
            controlHeight.value = convertToUnit(newHeight);
          });
        }
        onMounted(calculateInputHeight);
        watch(model, calculateInputHeight);
        watch(() => props.rows, calculateInputHeight);
        watch(() => props.maxRows, calculateInputHeight);
        watch(() => props.density, calculateInputHeight);
        let observer;
        watch(sizerRef, (val) => {
          if (val) {
            observer = new ResizeObserver(calculateInputHeight);
            observer.observe(sizerRef.value);
          } else {
            observer == null ? void 0 : observer.disconnect();
          }
        });
        onBeforeUnmount(() => {
          observer == null ? void 0 : observer.disconnect();
        });
        useRender(() => {
          const hasCounter = !!(slots.counter || props.counter || props.counterValue);
          const hasDetails = !!(hasCounter || slots.details);
          const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
          const {
            modelValue: _,
            ...inputProps
          } = VInput.filterProps(props);
          const fieldProps = filterFieldProps(props);
          return createVNode(VInput, mergeProps({
            "ref": vInputRef,
            "modelValue": model.value,
            "onUpdate:modelValue": ($event) => model.value = $event,
            "class": ["v-textarea v-text-field", {
              "v-textarea--prefixed": props.prefix,
              "v-textarea--suffixed": props.suffix,
              "v-text-field--prefixed": props.prefix,
              "v-text-field--suffixed": props.suffix,
              "v-textarea--auto-grow": props.autoGrow,
              "v-textarea--no-resize": props.noResize || props.autoGrow,
              "v-input--plain-underlined": isPlainOrUnderlined.value
            }, props.class],
            "style": props.style
          }, rootAttrs, inputProps, {
            "centerAffix": rows.value === 1 && !isPlainOrUnderlined.value,
            "focused": isFocused.value
          }), {
            ...slots,
            default: (_ref2) => {
              let {
                id: id2,
                isDisabled,
                isDirty,
                isReadonly: isReadonly2,
                isValid: isValid2
              } = _ref2;
              return createVNode(VField, mergeProps({
                "ref": vFieldRef,
                "style": {
                  "--v-textarea-control-height": controlHeight.value
                },
                "onClick": onControlClick,
                "onMousedown": onControlMousedown,
                "onClick:clear": onClear,
                "onClick:prependInner": props["onClick:prependInner"],
                "onClick:appendInner": props["onClick:appendInner"]
              }, fieldProps, {
                "id": id2.value,
                "active": isActive.value || isDirty.value,
                "centerAffix": rows.value === 1 && !isPlainOrUnderlined.value,
                "dirty": isDirty.value || props.dirty,
                "disabled": isDisabled.value,
                "focused": isFocused.value,
                "error": isValid2.value === false
              }), {
                ...slots,
                default: (_ref3) => {
                  let {
                    props: {
                      class: fieldClass,
                      ...slotProps
                    }
                  } = _ref3;
                  return createVNode(Fragment, null, [props.prefix && createVNode("span", {
                    "class": "v-text-field__prefix"
                  }, [props.prefix]), withDirectives(createVNode("textarea", mergeProps({
                    "ref": textareaRef,
                    "class": fieldClass,
                    "value": model.value,
                    "onInput": onInput,
                    "autofocus": props.autofocus,
                    "readonly": isReadonly2.value,
                    "disabled": isDisabled.value,
                    "placeholder": props.placeholder,
                    "rows": props.rows,
                    "name": props.name,
                    "onFocus": onFocus,
                    "onBlur": blur
                  }, slotProps, inputAttrs), null), [[resolveDirective("intersect"), {
                    handler: onIntersect
                  }, null, {
                    once: true
                  }]]), props.autoGrow && withDirectives(createVNode("textarea", {
                    "class": [fieldClass, "v-textarea__sizer"],
                    "id": `${slotProps.id}-sizer`,
                    "onUpdate:modelValue": ($event) => model.value = $event,
                    "ref": sizerRef,
                    "readonly": true,
                    "aria-hidden": "true"
                  }, null), [[vModelText, model.value]]), props.suffix && createVNode("span", {
                    "class": "v-text-field__suffix"
                  }, [props.suffix])]);
                }
              });
            },
            details: hasDetails ? (slotProps) => {
              var _a2;
              return createVNode(Fragment, null, [(_a2 = slots.details) == null ? void 0 : _a2.call(slots, slotProps), hasCounter && createVNode(Fragment, null, [createVNode("span", null, null), createVNode(VCounter, {
                "active": props.persistentCounter || isFocused.value,
                "value": counterValue.value,
                "max": max.value
              }, slots.counter)])]);
            } : void 0
          });
        });
        return forwardRefs({}, vInputRef, vFieldRef, textareaRef);
      }
    });
    const _sfc_main$x = {
      props: {
        layoutSlot: {
          /** @type import('vue').PropType<import('@json-layout/vocabulary').Slot> */
          type: Object,
          required: true
        },
        node: {
          /** @type import('vue').PropType<import('../../types.js').VjsfNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        },
        tag: {
          /** @type import('vue').PropType<string> */
          type: String,
          default: null
        }
      },
      render() {
        const renderTag = this.tag ?? (isTextSlot(this.layoutSlot) ? "p" : "div");
        if (isTextSlot(this.layoutSlot)) {
          return h(renderTag, this.layoutSlot.text);
        }
        if (isMarkdownSlot(this.layoutSlot)) {
          return h(renderTag, { innerHTML: this.layoutSlot.markdown });
        }
        if (isNameSlot(this.layoutSlot)) {
          if (!this.statefulLayout.options.vjsfSlots[this.layoutSlot.name]) {
            console.error(`vjsf: layout references a code slot "${this.layoutSlot.name}" that was not provided.`);
          } else {
            return h(renderTag, this.statefulLayout.options.vjsfSlots[this.layoutSlot.name]({ node: this.node, statefulLayout: this.statefulLayout }));
          }
        }
        return null;
      }
    };
    const _hoisted_1$3 = { class: "vjsf-help-message" };
    const _hoisted_2$2 = ["innerHTML"];
    const _sfc_main$w = {
      __name: "help-message",
      props: {
        node: {
          /** @type import('vue').PropType<import('../../types.js').VjsfNode> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        const show = ref$1(false);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", _hoisted_1$3, [
            createVNode(unref(VSlideXReverseTransition), null, {
              default: withCtx(() => [
                withDirectives(createVNode(unref(VAlert), { color: "info" }, {
                  default: withCtx(() => [
                    createBaseVNode("div", {
                      innerHTML: __props.node.layout.help
                    }, null, 8, _hoisted_2$2)
                  ]),
                  _: 1
                }, 512), [
                  [vShow, show.value]
                ])
              ]),
              _: 1
            }),
            createVNode(unref(VBtn), {
              color: "info",
              class: "vjsf-help-message-toggle",
              icon: show.value ? "mdi-close-circle" : "mdi-information",
              density: "compact",
              title: show.value ? "" : __props.node.messages.showHelp,
              onClick: _cache[0] || (_cache[0] = ($event) => show.value = !show.value)
            }, null, 8, ["icon", "title"])
          ]);
        };
      }
    };
    const _sfc_main$v = {
      __name: "node",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../types.js').VjsfNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        const props = __props;
        const beforeAfterClasses = {
          compact: "my-1",
          comfortable: "my-2",
          default: "my-3"
        };
        const theme = useTheme();
        const nodeClasses = computed(() => {
          let classes = `vjsf-node vjsf-node-${props.modelValue.layout.comp} vjsf-density-${props.modelValue.options.density}`;
          if (props.modelValue.options.readOnly)
            classes += " vjsf-readonly";
          if (props.modelValue.options.summary)
            classes += " vjsf-summary";
          if (theme.current.value.dark)
            classes += " vjsf-dark";
          return classes;
        });
        if (!props.statefulLayout.options.nodeComponents[props.modelValue.layout.comp]) {
          console.error(`vjsf: missing component to render vjsf node "${props.modelValue.layout.comp}", maybe you forgot to register a component from a plugin ?`);
        }
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(VCol), {
            cols: __props.modelValue.cols,
            class: normalizeClass(nodeClasses.value)
          }, {
            default: withCtx(() => {
              var _a2, _b, _c, _d, _e, _f;
              return [
                ((_a2 = __props.modelValue.layout.slots) == null ? void 0 : _a2.before) ? (openBlock(), createBlock(_sfc_main$x, {
                  key: "before",
                  "layout-slot": (_b = __props.modelValue.layout.slots) == null ? void 0 : _b.before,
                  node: __props.modelValue,
                  "stateful-layout": __props.statefulLayout,
                  class: normalizeClass(beforeAfterClasses[__props.modelValue.options.density])
                }, null, 8, ["layout-slot", "node", "stateful-layout", "class"])) : createCommentVNode("", true),
                __props.modelValue.layout.help ? (openBlock(), createBlock(_sfc_main$w, {
                  key: 1,
                  node: __props.modelValue,
                  class: normalizeClass(beforeAfterClasses[__props.modelValue.options.density])
                }, null, 8, ["node", "class"])) : createCommentVNode("", true),
                ((_c = __props.modelValue.layout.slots) == null ? void 0 : _c.component) ? (openBlock(), createBlock(_sfc_main$x, {
                  key: "component",
                  "layout-slot": (_d = __props.modelValue.layout.slots) == null ? void 0 : _d.component,
                  node: __props.modelValue,
                  "stateful-layout": __props.statefulLayout
                }, null, 8, ["layout-slot", "node", "stateful-layout"])) : __props.modelValue.layout.comp !== "none" ? (openBlock(), createBlock(resolveDynamicComponent(props.statefulLayout.options.nodeComponents[__props.modelValue.layout.comp]), {
                  key: 3,
                  "model-value": __props.modelValue,
                  "stateful-layout": __props.statefulLayout
                }, null, 8, ["model-value", "stateful-layout"])) : createCommentVNode("", true),
                ((_e = __props.modelValue.layout.slots) == null ? void 0 : _e.after) ? (openBlock(), createBlock(_sfc_main$x, {
                  key: "after",
                  "layout-slot": (_f = __props.modelValue.layout.slots) == null ? void 0 : _f.after,
                  node: __props.modelValue,
                  "stateful-layout": __props.statefulLayout,
                  class: normalizeClass(beforeAfterClasses[__props.modelValue.options.density])
                }, null, 8, ["layout-slot", "node", "stateful-layout", "class"])) : createCommentVNode("", true)
              ];
            }),
            _: 1
          }, 8, ["cols", "class"]);
        };
      }
    };
    const _sfc_main$u = {
      __name: "tree",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('@json-layout/core').StateTree> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(VRow), { class: "vjsf-tree" }, {
            default: withCtx(() => [
              createVNode(_sfc_main$v, {
                "stateful-layout": __props.statefulLayout,
                "model-value": (
                  /** @type import('../types.js').VjsfNode */
                  __props.modelValue.root
                )
              }, null, 8, ["stateful-layout", "model-value"])
            ]),
            _: 1
          });
        };
      }
    };
    function tryOnScopeDispose(fn) {
      if (getCurrentScope$1()) {
        onScopeDispose(fn);
        return true;
      }
      return false;
    }
    function toValue(r) {
      return typeof r === "function" ? r() : unref(r);
    }
    const isClient = typeof window !== "undefined" && typeof document !== "undefined";
    typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
    function getLifeCycleTarget(target2) {
      return target2 || getCurrentInstance$1();
    }
    function tryOnMounted(fn, sync = true, target2) {
      const instance = getLifeCycleTarget();
      if (instance)
        onMounted(fn, target2);
      else if (sync)
        fn();
      else
        nextTick(fn);
    }
    function unrefElement(elRef) {
      var _a2;
      const plain = toValue(elRef);
      return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
    }
    const defaultWindow = isClient ? window : void 0;
    function useMounted() {
      const isMounted = ref$1(false);
      if (getCurrentInstance$1()) {
        onMounted(() => {
          isMounted.value = true;
        });
      }
      return isMounted;
    }
    function useSupported(callback) {
      const isMounted = useMounted();
      return computed(() => {
        isMounted.value;
        return Boolean(callback());
      });
    }
    function useResizeObserver(target2, callback, options = {}) {
      const { window: window2 = defaultWindow, ...observerOptions } = options;
      let observer;
      const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
      const cleanup = () => {
        if (observer) {
          observer.disconnect();
          observer = void 0;
        }
      };
      const targets = computed(() => Array.isArray(target2) ? target2.map((el2) => unrefElement(el2)) : [unrefElement(target2)]);
      const stopWatch = watch(
        targets,
        (els2) => {
          cleanup();
          if (isSupported.value && window2) {
            observer = new ResizeObserver(callback);
            for (const _el of els2)
              _el && observer.observe(_el, observerOptions);
          }
        },
        { immediate: true, flush: "post", deep: true }
      );
      const stop = () => {
        cleanup();
        stopWatch();
      };
      tryOnScopeDispose(stop);
      return {
        isSupported,
        stop
      };
    }
    function useElementSize(target2, initialSize = { width: 0, height: 0 }, options = {}) {
      const { window: window2 = defaultWindow, box = "content-box" } = options;
      const isSVG = computed(() => {
        var _a2, _b;
        return (_b = (_a2 = unrefElement(target2)) == null ? void 0 : _a2.namespaceURI) == null ? void 0 : _b.includes("svg");
      });
      const width = ref$1(initialSize.width);
      const height = ref$1(initialSize.height);
      const { stop: stop1 } = useResizeObserver(
        target2,
        ([entry]) => {
          const boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
          if (window2 && isSVG.value) {
            const $elem = unrefElement(target2);
            if ($elem) {
              const styles = window2.getComputedStyle($elem);
              width.value = Number.parseFloat(styles.width);
              height.value = Number.parseFloat(styles.height);
            }
          } else {
            if (boxSize) {
              const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];
              width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);
              height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);
            } else {
              width.value = entry.contentRect.width;
              height.value = entry.contentRect.height;
            }
          }
        },
        options
      );
      tryOnMounted(() => {
        const ele = unrefElement(target2);
        if (ele) {
          width.value = "offsetWidth" in ele ? ele.offsetWidth : initialSize.width;
          height.value = "offsetHeight" in ele ? ele.offsetHeight : initialSize.height;
        }
      });
      const stop2 = watch(
        () => unrefElement(target2),
        (ele) => {
          width.value = ele ? initialSize.width : 0;
          height.value = ele ? initialSize.height : 0;
        }
      );
      function stop() {
        stop1();
        stop2();
      }
      return {
        width,
        height,
        stop
      };
    }
    const defaultOptions = {
      errorAlertProps: { type: "error", variant: "tonal" },
      nodeComponents: {},
      plugins: {}
    };
    const getFullOptions = (options, form, width, slots, nodeComponents) => {
      const fullOptions = {
        ...defaultOptions,
        readOnly: !!(form && (form.isDisabled.value || form.isReadonly.value)),
        ...options,
        context: (options == null ? void 0 : options.context) ? JSON.parse(JSON.stringify(options.context)) : {},
        width: Math.round(width ?? 0),
        vjsfSlots: { ...slots },
        nodeComponents: { ...nodeComponents, ...options == null ? void 0 : options.nodeComponents }
      };
      return (
        /** @type import('../types.js').VjsfOptions */
        fullOptions
      );
    };
    function moveArrayItem(array, fromIndex, toIndex) {
      if (fromIndex === toIndex || fromIndex === -1 || toIndex === -1)
        return array;
      const newArray = [...array];
      const element = newArray[fromIndex];
      newArray.splice(fromIndex, 1);
      newArray.splice(toIndex, 0, element);
      return newArray;
    }
    const padTimeComponent = (val) => {
      const s = "" + val;
      return s.length === 1 ? "0" + s : s;
    };
    const getDateTimeParts = (date2) => {
      return [`${date2.getFullYear()}-${padTimeComponent(date2.getMonth() + 1)}-${padTimeComponent(date2.getDate())}`, `${padTimeComponent(date2.getHours())}:${padTimeComponent(date2.getMinutes())}`];
    };
    const defaultProps = {
      fieldProps: {},
      fieldPropsCompact: {
        density: "compact",
        hideDetails: "auto"
      },
      fieldPropsComfortable: {
        density: "comfortable"
      },
      fieldPropsReadOnly: { hideDetails: "auto", variant: "plain" },
      fieldPropsSummary: { hideDetails: true },
      textfieldProps: {},
      textfieldPropsReadOnly: {},
      textareaProps: {},
      textareaPropsReadOnly: {},
      // it is not very common to show an error below checkboxes and switches and without hide-details=auto they take a lot of space
      checkboxProps: { hideDetails: "auto" },
      checkboxPropsReadOnly: {},
      switchProps: { hideDetails: "auto" },
      switchPropsReadOnly: {}
    };
    function mergePropsLevels(propsLevels) {
      const fullProps = { class: [] };
      for (const propsLevel of propsLevels) {
        if (propsLevel) {
          for (const key of Object.keys(propsLevel)) {
            if (key === "class") {
              if (Array.isArray(propsLevel.class))
                fullProps.class = fullProps.class.concat(propsLevel.class);
              else
                fullProps.class = [propsLevel.class];
            } else {
              fullProps[camelize(key)] = propsLevel[key];
            }
          }
        }
      }
      return fullProps;
    }
    function getInputProps(node, statefulLayout, layoutPropsMap, isMainComp = true) {
      const options = node.options;
      const propsLevels = [defaultProps.fieldProps];
      if (options.density === "comfortable")
        propsLevels.push(defaultProps.fieldPropsComfortable);
      if (options.density === "compact")
        propsLevels.push(defaultProps.fieldPropsCompact);
      if (node.options.readOnly)
        propsLevels.push(defaultProps.fieldPropsReadOnly);
      if (isMainComp) {
        propsLevels.push(
          /** @type Record<string, any> | undefined */
          options[`${node.layout.comp}Props`]
        );
        if (node.options.readOnly)
          propsLevels.push(
            /** @type Record<string, any> | undefined */
            options[`${node.layout.comp}PropsReadOnly`]
          );
        if (node.props)
          propsLevels.push(node.props);
      }
      const fullProps = mergePropsLevels(propsLevels);
      fullProps.label = node.layout.label;
      if (node.error && node.validated) {
        fullProps.errorMessages = node.error;
      }
      fullProps.modelValue = node.data;
      if (node.options.readOnly) {
        fullProps.disabled = true;
        fullProps.class.push("vjsf-input--readonly");
      }
      if (node.autofocus) {
        fullProps.class.push("vjsf-input--autofocus");
      }
      if (layoutPropsMap) {
        for (const propMap2 of layoutPropsMap) {
          if (typeof propMap2 === "string")
            fullProps[propMap2] = node.layout[propMap2];
          else
            fullProps[propMap2[0]] = node.layout[propMap2[1]];
        }
      }
      if (isMainComp) {
        fullProps["onUpdate:modelValue"] = (value) => statefulLayout.input(node, value);
        fullProps.onBlur = () => statefulLayout.blur(node);
      }
      return fullProps;
    }
    function getCompProps(node, comp2, isMainComp = true) {
      const options = (
        /** @type import('../types.js').VjsfOptions */
        node.options
      );
      const propsLevels = [{ density: options.density }];
      propsLevels.push(
        /** @type Record<string, any> | undefined */
        options[`${comp2}Props`]
      );
      if (node.options.readOnly)
        propsLevels.push(
          /** @type Record<string, any> | undefined */
          options[`${comp2}PropsReadOnly`]
        );
      if (isMainComp)
        propsLevels.push(node.layout.props);
      const fullProps = mergePropsLevels(propsLevels);
      if (isMainComp)
        fullProps.modelValue = node.data;
      return fullProps;
    }
    function getCompSlots(node, statefulLayout) {
      if (!node.layout.slots)
        return {};
      const slots = {};
      for (const [key, layoutSlot] of Object.entries(node.layout.slots)) {
        slots[key] = () => h(_sfc_main$x, { layoutSlot, node, statefulLayout });
      }
      return slots;
    }
    const registeredNodeComponents = ref$1({});
    const emits = {
      /**
       * @arg {any} data
      */
      "update:modelValue": (data) => true,
      /**
       * @arg {import('../types.js').VjsfStatefulLayout} state
      */
      "update:state": (state) => true
    };
    const useVjsf = (schema, modelValue, options, nodeComponents, emit2, compile2, precompiledLayout) => {
      const el2 = ref$1(null);
      const { width } = useElementSize(el2);
      const statefulLayout = shallowRef(null);
      const stateTree = shallowRef(null);
      const form = inject$1(Symbol.for("vuetify:form"));
      if (form) {
        form.register({
          id: "vjsf",
          // TODO: a unique random id ?
          validate: () => {
            var _a2, _b;
            (_a2 = statefulLayout.value) == null ? void 0 : _a2.validate();
            return (_b = statefulLayout.value) == null ? void 0 : _b.errors;
          },
          reset: () => {
            var _a2;
            return (_a2 = statefulLayout.value) == null ? void 0 : _a2.resetValidation();
          },
          // TODO: also empty the data ?
          resetValidation: () => {
            var _a2;
            return (_a2 = statefulLayout.value) == null ? void 0 : _a2.resetValidation();
          }
        });
      }
      const slots = useSlots();
      const fullOptions = computed(() => getFullOptions(options.value, form, width.value, slots, { ...nodeComponents, ...toRaw(registeredNodeComponents.value) }));
      const compiledLayout = computed(() => {
        if (precompiledLayout == null ? void 0 : precompiledLayout.value)
          return precompiledLayout == null ? void 0 : precompiledLayout.value;
        if (!compile2)
          throw new Error("compile function is not available");
        const compiledLayout2 = compile2(schema.value, fullOptions.value);
        return compiledLayout2;
      });
      const onStatefulLayoutUpdate = () => {
        if (!statefulLayout.value)
          return;
        stateTree.value = statefulLayout.value.stateTree;
        emit2("update:modelValue", statefulLayout.value.data);
        emit2("update:state", statefulLayout.value);
        if (form) {
          if (statefulLayout.value.valid)
            form.update("vjsf", true, []);
          else if (statefulLayout.value.hasHiddenError)
            form.update("vjsf", null, []);
          else
            form.update("vjsf", false, []);
        }
      };
      const initStatefulLayout = () => {
        if (!width.value)
          return;
        const _statefulLayout = (
          /** @type {import('../types.js').VjsfStatefulLayout} */
          new StatefulLayout(
            toRaw(compiledLayout.value),
            toRaw(compiledLayout.value.skeletonTree),
            toRaw(fullOptions.value),
            toRaw(modelValue.value)
          )
        );
        statefulLayout.value = _statefulLayout;
        onStatefulLayoutUpdate();
        _statefulLayout.events.on("update", () => {
          onStatefulLayoutUpdate();
        });
        emit2("update:state", _statefulLayout);
        _statefulLayout.events.on("autofocus", () => {
          if (!el2.value)
            return;
          const autofocusNodeElement = el2.value.querySelector(".vjsf-input--autofocus");
          if (autofocusNodeElement) {
            const autofocusInputElement = autofocusNodeElement.querySelector("input") ?? autofocusNodeElement.querySelector('textarea:not([style*="display: none"]');
            if (autofocusInputElement)
              autofocusInputElement.focus();
          }
        });
      };
      watch(fullOptions, (newOptions) => {
        if (!(precompiledLayout == null ? void 0 : precompiledLayout.value))
          return;
        if (statefulLayout.value) {
          statefulLayout.value.options = newOptions;
        } else {
          initStatefulLayout();
        }
      });
      watch(modelValue, (newData) => {
        if (statefulLayout.value && statefulLayout.value.data !== newData)
          statefulLayout.value.data = toRaw(newData);
      });
      watch(compiledLayout, (newCompiledLayout) => {
        initStatefulLayout();
      });
      return { el: el2, statefulLayout, stateTree };
    };
    const _sfc_main$t = {
      __name: "section-header",
      props: {
        node: {
          /** @type import('vue').PropType<import('../../types.js').VjsfNode> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        const props = __props;
        const titleDepthBase = computed(() => {
          if (props.node.options.density === "compact")
            return 6;
          if (props.node.options.density === "comfortable")
            return 7;
          return 8;
        });
        const classes = ["text-h1", "text-h2", "text-h3", "text-h4", "text-h5", "text-h6", "text-subtitle-1", "text-subtitle-2"];
        const titleClass = computed(() => {
          const index = props.node.options.titleDepth;
          if (props.node.options.density === "compact")
            return classes[index + 2];
          if (props.node.options.density === "comfortable")
            return classes[index + 1];
          return classes[index];
        });
        return (_ctx, _cache) => {
          return __props.node.layout.title ?? __props.node.layout.subtitle ?? (__props.node.error && __props.node.validated) ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(`mb-${titleDepthBase.value - __props.node.options.titleDepth} mt-${titleDepthBase.value - __props.node.options.titleDepth}`)
          }, [
            __props.node.layout.title ? (openBlock(), createBlock(resolveDynamicComponent(`h${__props.node.options.titleDepth}`), {
              key: 0,
              class: normalizeClass(`${titleClass.value}`)
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(__props.node.layout.title), 1)
              ]),
              _: 1
            }, 8, ["class"])) : createCommentVNode("", true),
            __props.node.layout.subtitle ? (openBlock(), createElementBlock("p", {
              key: 1,
              class: normalizeClass(`text-subtitle mt-${titleDepthBase.value - __props.node.options.titleDepth}`)
            }, toDisplayString(__props.node.layout.subtitle), 3)) : createCommentVNode("", true),
            __props.node.error && __props.node.validated ? (openBlock(), createBlock(unref(VAlert), mergeProps({ key: 2 }, __props.node.options.errorAlertProps, {
              class: `mt-${titleDepthBase.value - __props.node.options.titleDepth}`,
              density: __props.node.options.density
            }), {
              default: withCtx(() => [
                createTextVNode(toDisplayString(__props.node.error), 1)
              ]),
              _: 1
            }, 16, ["class", "density"])) : createCommentVNode("", true)
          ], 2)) : createCommentVNode("", true);
        };
      }
    };
    const _sfc_main$s = {
      __name: "section",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfSectionNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        return (_ctx, _cache) => {
          var _a2, _b;
          return openBlock(), createElementBlock(Fragment, null, [
            createVNode(_sfc_main$t, { node: __props.modelValue }, null, 8, ["node"]),
            createVNode(unref(VRow), {
              dense: ((_a2 = __props.modelValue.options) == null ? void 0 : _a2.density) === "compact" || ((_b = __props.modelValue.options) == null ? void 0 : _b.density) === "comfortable"
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(__props.modelValue.children, (child) => {
                  return openBlock(), createBlock(_sfc_main$v, {
                    key: child.fullKey,
                    "model-value": (
                      /** @type import('../../types.js').VjsfNode */
                      child
                    ),
                    "stateful-layout": __props.statefulLayout
                  }, null, 8, ["model-value", "stateful-layout"]);
                }), 128))
              ]),
              _: 1
            }, 8, ["dense"])
          ], 64);
        };
      }
    };
    const _sfc_main$r = /* @__PURE__ */ defineComponent$1({
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfTextFieldNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(props) {
        const fieldProps = computed(() => getInputProps(props.modelValue, props.statefulLayout, ["placeholder"]));
        const fieldSlots = computed(() => getCompSlots(props.modelValue, props.statefulLayout));
        return () => h(VTextField, fieldProps.value, fieldSlots.value);
      }
    });
    const _sfc_main$q = /* @__PURE__ */ defineComponent$1({
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfTextareaNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(props) {
        const textarea = ref$1(null);
        const fieldProps = computed(() => {
          const inputProps = getInputProps(props.modelValue, props.statefulLayout, ["placeholder"]);
          inputProps.ref = textarea;
          if (props.modelValue.options.readOnly && props.modelValue.options.summary)
            inputProps.rows = 3;
          return inputProps;
        });
        const fieldSlots = computed(() => getCompSlots(props.modelValue, props.statefulLayout));
        watch(() => props.modelValue.options.readOnly, (readOnly) => {
          if (readOnly && textarea.value) {
            textarea.value.scrollTop = 0;
          }
        });
        return () => h(VTextarea, fieldProps.value, fieldSlots.value);
      }
    });
    const _sfc_main$p = {
      __name: "checkbox",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfCheckboxNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        const props = __props;
        const fieldProps = computed(() => getInputProps(props.modelValue, props.statefulLayout));
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(VCheckbox), mergeProps(fieldProps.value, {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = (value) => __props.statefulLayout.input(__props.modelValue, value))
          }), null, 16);
        };
      }
    };
    const _sfc_main$o = {
      __name: "switch",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfSwitchNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        const props = __props;
        const fieldProps = computed(
          () => getInputProps(props.modelValue, props.statefulLayout)
        );
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(VSwitch), mergeProps(fieldProps.value, {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = (value) => __props.statefulLayout.input(__props.modelValue, value))
          }), null, 16);
        };
      }
    };
    const _sfc_main$n = /* @__PURE__ */ defineComponent$1({
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfNumberFieldNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(props) {
        const fieldProps = computed(() => {
          const fieldProps2 = getInputProps(props.modelValue, props.statefulLayout, ["step", "min", "max", "placeholder"]);
          fieldProps2.type = "number";
          fieldProps2["onUpdate:modelValue"] = (value) => props.statefulLayout.input(props.modelValue, value && Number(value));
          return fieldProps2;
        });
        const fieldSlots = computed(() => getCompSlots(props.modelValue, props.statefulLayout));
        return () => h(VTextField, fieldProps.value, fieldSlots.value);
      }
    });
    const _sfc_main$m = {
      __name: "slider",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfSliderNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        const props = __props;
        const fieldProps = computed(() => {
          const fieldProps2 = getInputProps(props.modelValue, props.statefulLayout);
          if ("step" in props.modelValue.layout)
            fieldProps2.step = props.modelValue.layout.step;
          fieldProps2.min = props.modelValue.layout.min;
          fieldProps2.max = props.modelValue.layout.max;
          return fieldProps2;
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(VSlider), mergeProps({ type: "number" }, fieldProps.value, {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = (value) => __props.statefulLayout.input(__props.modelValue, value && Number(value)))
          }), null, 16);
        };
      }
    };
    const _sfc_main$l = {
      __name: "text-field-menu",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        },
        formattedValue: {
          /** @type import('vue').PropType<string | null> */
          type: String,
          default: null
        }
      },
      setup(__props) {
        const props = __props;
        const fieldProps = computed(() => {
          const fieldProps2 = getInputProps(props.modelValue, props.statefulLayout, [], false);
          fieldProps2.readonly = true;
          return fieldProps2;
        });
        const menuProps = computed(() => {
          const menuProps2 = getCompProps(props.modelValue, "menu", false);
          menuProps2.closeOnContentClick = false;
          menuProps2.disabled = true;
          return menuProps2;
        });
        const textField = ref$1(null);
        const menuOpened = ref$1(false);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock(Fragment, null, [
            createVNode(unref(VTextField), mergeProps({
              ref_key: "textField",
              ref: textField
            }, fieldProps.value, {
              "model-value": __props.formattedValue ?? __props.modelValue.data,
              "onClick:control": _cache[0] || (_cache[0] = (e) => {
                menuOpened.value = !menuOpened.value;
                e.stopPropagation();
              })
            }), {
              "prepend-inner": withCtx(() => [
                renderSlot(_ctx.$slots, "prepend-inner")
              ]),
              _: 3
            }, 16, ["model-value"]),
            textField.value ? (openBlock(), createBlock(unref(VMenu), mergeProps({ key: 0 }, menuProps.value, {
              modelValue: menuOpened.value,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => menuOpened.value = $event),
              class: "vjsf-text-field-menu",
              activator: textField.value
            }), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default", {
                  close: () => menuOpened.value = false
                })
              ]),
              _: 3
            }, 16, ["modelValue", "activator"])) : createCommentVNode("", true)
          ], 64);
        };
      }
    };
    const _sfc_main$k = {
      __name: "date-picker",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfDatePickerNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        const props = __props;
        const vDate = useDate();
        const datePickerProps = computed(() => {
          const datePickerProps2 = getCompProps(props.modelValue, "datePicker", true);
          datePickerProps2.hideActions = true;
          if (props.modelValue.data)
            datePickerProps2.modelValue = new Date(props.modelValue.data);
          return datePickerProps2;
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(_sfc_main$l, {
            "model-value": __props.modelValue,
            "stateful-layout": __props.statefulLayout,
            "formatted-value": __props.modelValue.data && unref(vDate).format(__props.modelValue.data, "fullDateWithWeekday")
          }, {
            default: withCtx(({ close }) => [
              createVNode(unref(VDatePicker), mergeProps(datePickerProps.value, {
                "onUpdate:modelValue": (value) => {
                  __props.statefulLayout.input(__props.modelValue, value && unref(getDateTimeParts)(
                    /** @type Date */
                    /** @type unknown */
                    value
                  )[0]);
                  close();
                }
              }), null, 16, ["onUpdate:modelValue"])
            ]),
            _: 1
          }, 8, ["model-value", "stateful-layout", "formatted-value"]);
        };
      }
    };
    const _sfc_main$j = {
      __name: "date-time-picker",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfDateTimePickerNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        return (_ctx, _cache) => {
          return " TODO date-time ";
        };
      }
    };
    const _sfc_main$i = {
      __name: "color-picker",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfColorPickerNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        const props = __props;
        const colorPickerProps = computed(() => {
          const colorPickerProps2 = getCompProps(props.modelValue, "colorPicker", true);
          return colorPickerProps2;
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(_sfc_main$l, {
            "model-value": __props.modelValue,
            "stateful-layout": __props.statefulLayout,
            "formatted-value": __props.modelValue.data
          }, createSlots({
            default: withCtx(() => [
              createVNode(unref(VColorPicker), mergeProps(colorPickerProps.value, {
                "onUpdate:modelValue": _cache[0] || (_cache[0] = (value) => __props.statefulLayout.input(__props.modelValue, value))
              }), null, 16)
            ]),
            _: 2
          }, [
            __props.modelValue.data ? {
              name: "prepend-inner",
              fn: withCtx(() => [
                createBaseVNode("div", {
                  style: normalizeStyle(`height:30px; width: 30px; border-radius: 40px; margin-right:6px; background: ${__props.modelValue.data};`)
                }, null, 4)
              ]),
              key: "0"
            } : void 0
          ]), 1032, ["model-value", "stateful-layout", "formatted-value"]);
        };
      }
    };
    const _sfc_main$h = /* @__PURE__ */ defineComponent$1({
      props: {
        icon: {
          type: String,
          required: true
        }
      },
      setup(props) {
        const isUrl = computed(() => props.icon.startsWith("http://") || props.icon.startsWith("https://"));
        const isSVG = computed(() => props.icon.startsWith("<?xml") || props.icon.startsWith("<svg"));
        return () => {
          if (isUrl.value) {
            return h("img", { src: props.icon, style: "height:100%;width:100%;" });
          } else if (isSVG.value) {
            return h("div", { innerHTML: props.icon.replace("<svg ", '<svg class="v-icon__svg" '), class: "v-icon" });
          } else {
            return h(VIcon, null, props.icon);
          }
        };
      }
    });
    const _sfc_main$g = {
      __name: "select-item",
      props: {
        multiple: {
          type: Boolean,
          default: false
        },
        itemProps: {
          type: Object,
          required: true
        },
        item: {
          /** @type import('vue').PropType<import('@json-layout/vocabulary').SelectItem> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(VListItem), normalizeProps(guardReactiveProps(__props.itemProps)), createSlots({ _: 2 }, [
            __props.item.icon || __props.multiple ? {
              name: "prepend",
              fn: withCtx(({ isSelected }) => [
                __props.multiple ? (openBlock(), createBlock(unref(VCheckboxBtn), {
                  key: __props.item.key,
                  ripple: false,
                  tabindex: "-1",
                  "model-value": isSelected
                }, null, 8, ["model-value"])) : createCommentVNode("", true),
                __props.item.icon ? (openBlock(), createBlock(_sfc_main$h, {
                  key: 1,
                  icon: __props.item.icon
                }, null, 8, ["icon"])) : createCommentVNode("", true)
              ]),
              key: "0"
            } : void 0
          ]), 1040);
        };
      }
    };
    const _hoisted_1$2 = { class: "v-select__selection-text" };
    const _hoisted_2$1 = {
      key: 1,
      class: "v-select__selection-comma"
    };
    const _sfc_main$f = {
      __name: "select-selection",
      props: {
        multiple: {
          type: Boolean,
          default: false
        },
        last: {
          type: Boolean,
          default: false
        },
        item: {
          /** @type import('vue').PropType<import('@json-layout/vocabulary').SelectItem> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("span", _hoisted_1$2, [
            __props.item.icon ? (openBlock(), createBlock(_sfc_main$h, {
              key: 0,
              icon: __props.item.icon
            }, null, 8, ["icon"])) : createCommentVNode("", true),
            createTextVNode(" " + toDisplayString(__props.item.title) + " ", 1),
            __props.multiple && !__props.last ? (openBlock(), createElementBlock("span", _hoisted_2$1, ",")) : createCommentVNode("", true)
          ]);
        };
      }
    };
    const _sfc_main$e = /* @__PURE__ */ defineComponent$1({
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfSelectNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(props) {
        const items2 = shallowRef([]);
        const loading = ref$1(false);
        const fieldProps = computed(() => {
          const fieldProps2 = getInputProps(props.modelValue, props.statefulLayout, ["multiple"]);
          if (props.modelValue.options.readOnly)
            fieldProps2.menuProps = { modelValue: false };
          fieldProps2.loading = loading.value;
          fieldProps2.items = items2.value;
          fieldProps2["onUpdate:menu"] = refresh;
          return fieldProps2;
        });
        let lastStateTree = null;
        let lastContext = null;
        const refresh = async () => {
          if (props.statefulLayout.stateTree === lastStateTree && props.statefulLayout.options.context === lastContext)
            return;
          lastStateTree = props.statefulLayout.stateTree;
          lastContext = props.statefulLayout.options.context ?? null;
          loading.value = true;
          items2.value = await props.statefulLayout.getItems(props.modelValue);
          loading.value = false;
        };
        if (!props.modelValue.layout.items) {
          refresh();
        }
        const fieldSlots = computed(() => {
          const slots = getCompSlots(props.modelValue, props.statefulLayout);
          if (!slots.item) {
            slots.item = (context) => h(_sfc_main$g, {
              multiple: props.modelValue.layout.multiple,
              itemProps: context.props,
              item: context.item.raw
            });
          }
          if (!slots.selection) {
            slots.selection = (context) => h(_sfc_main$f, {
              multiple: props.modelValue.layout.multiple,
              last: props.modelValue.layout.multiple && context.index === props.modelValue.data.length - 1,
              item: context.item.raw
            });
          }
          return slots;
        });
        return () => h(VSelect, fieldProps.value, fieldSlots.value);
      }
    });
    const _sfc_main$d = /* @__PURE__ */ defineComponent$1({
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfSelectNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(props) {
        const items2 = shallowRef([]);
        const loading = ref$1(false);
        const search = ref$1("");
        const fieldProps = computed(() => {
          const fieldProps2 = getInputProps(props.modelValue, props.statefulLayout, ["multiple"]);
          if (props.modelValue.options.readOnly)
            fieldProps2.menuProps = { modelValue: false };
          fieldProps2.noFilter = true;
          fieldProps2["onUpdate:search"] = (searchValue) => {
            search.value = searchValue;
            refresh();
          };
          fieldProps2["onUpdate:menu"] = refresh;
          fieldProps2.items = items2.value;
          fieldProps2.loading = loading.value;
          return fieldProps2;
        });
        let lastStateTree = null;
        let lastContext = null;
        let lastSearch = "";
        const refresh = async () => {
          if (props.statefulLayout.stateTree === lastStateTree && props.statefulLayout.options.context === lastContext && search.value === lastSearch)
            return;
          loading.value = true;
          items2.value = await props.statefulLayout.getItems(props.modelValue, search.value);
          lastStateTree = props.statefulLayout.stateTree;
          lastContext = props.statefulLayout.options.context ?? null;
          lastSearch = search.value;
          loading.value = false;
        };
        if (!props.modelValue.layout.items) {
          refresh();
        }
        const fieldSlots = computed(() => {
          const slots = getCompSlots(props.modelValue, props.statefulLayout);
          if (!slots.item) {
            slots.item = (context) => h(_sfc_main$g, {
              multiple: props.modelValue.layout.multiple,
              itemProps: context.props,
              item: context.item.raw
            });
          }
          if (!slots.selection) {
            slots.selection = (context) => h(_sfc_main$f, {
              multiple: props.modelValue.layout.multiple,
              last: props.modelValue.layout.multiple && context.index === props.modelValue.data.length - 1,
              item: context.item.raw
            });
          }
          return slots;
        });
        return () => h(VAutocomplete, fieldProps.value, fieldSlots.value);
      }
    });
    const _sfc_main$c = {
      __name: "one-of-select",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfOneOfSelectNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        const props = __props;
        const activeChildTree = shallowRef(void 0);
        watch(() => props.modelValue, () => {
          var _a2;
          if (props.modelValue.fullKey in props.statefulLayout.activeItems) {
            activeChildTree.value = (_a2 = props.modelValue.skeleton.childrenTrees) == null ? void 0 : _a2[props.statefulLayout.activeItems[props.modelValue.fullKey]];
          } else {
            activeChildTree.value = void 0;
          }
        }, { immediate: true });
        const onChange = (childTree) => {
          if (!props.modelValue.skeleton.childrenTrees)
            return;
          props.statefulLayout.activateItem(props.modelValue, props.modelValue.skeleton.childrenTrees.indexOf(childTree));
        };
        return (_ctx, _cache) => {
          var _a2;
          return openBlock(), createElementBlock(Fragment, null, [
            __props.modelValue.skeleton.childrenTrees ? (openBlock(), createBlock(unref(VSelect), {
              key: 0,
              modelValue: activeChildTree.value,
              "onUpdate:modelValue": [
                _cache[0] || (_cache[0] = ($event) => activeChildTree.value = $event),
                onChange
              ],
              items: __props.modelValue.skeleton.childrenTrees,
              "item-title": "title",
              "return-object": "",
              "error-messages": __props.modelValue.validated ? __props.modelValue.error : null
            }, null, 8, ["modelValue", "items", "error-messages"])) : createCommentVNode("", true),
            ((_a2 = __props.modelValue.children) == null ? void 0 : _a2[0]) ? (openBlock(), createBlock(unref(VRow), { key: 1 }, {
              default: withCtx(() => {
                var _a3, _b;
                return [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(isSection)((_a3 = __props.modelValue.children) == null ? void 0 : _a3[0]) ? (_b = __props.modelValue.children) == null ? void 0 : _b[0].children : __props.modelValue.children, (grandChild) => {
                    return openBlock(), createBlock(_sfc_main$v, {
                      key: grandChild.fullKey,
                      "model-value": (
                        /** @type import('../../types.js').VjsfNode */
                        grandChild
                      ),
                      "stateful-layout": __props.statefulLayout
                    }, null, 8, ["model-value", "stateful-layout"]);
                  }), 128))
                ];
              }),
              _: 1
            })) : createCommentVNode("", true)
          ], 64);
        };
      }
    };
    const _sfc_main$b = {
      __name: "tabs",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfTabsNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        const tab = ref$1(0);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock(Fragment, null, [
            createVNode(_sfc_main$t, { node: __props.modelValue }, null, 8, ["node"]),
            createVNode(unref(VSheet), { border: "" }, {
              default: withCtx(() => [
                createVNode(unref(VTabs), {
                  modelValue: tab.value,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => tab.value = $event)
                }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(__props.modelValue.children, (child, i2) => {
                      return openBlock(), createBlock(unref(VTab), {
                        key: child.key,
                        value: i2,
                        density: __props.modelValue.options.density,
                        color: child.validated && (child.error || child.childError) ? "error" : void 0
                      }, {
                        default: withCtx(() => [
                          child.validated && (child.error || child.childError) ? (openBlock(), createBlock(unref(VIcon), {
                            key: 0,
                            color: "error"
                          }, {
                            default: withCtx(() => [
                              createTextVNode(" mdi-alert ")
                            ]),
                            _: 1
                          })) : createCommentVNode("", true),
                          createTextVNode(" " + toDisplayString(child.layout.title ?? child.layout.label), 1)
                        ]),
                        _: 2
                      }, 1032, ["value", "density", "color"]);
                    }), 128))
                  ]),
                  _: 1
                }, 8, ["modelValue"]),
                createVNode(unref(VWindow), {
                  modelValue: tab.value,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => tab.value = $event)
                }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(__props.modelValue.children, (child, i2) => {
                      return openBlock(), createBlock(unref(VWindowItem), {
                        key: child.key,
                        value: i2
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(VContainer), { fluid: "" }, {
                            default: withCtx(() => [
                              createVNode(unref(VRow), null, {
                                default: withCtx(() => [
                                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(isSection)(child) ? child.children : [child], (grandChild) => {
                                    return openBlock(), createBlock(_sfc_main$v, {
                                      key: grandChild.fullKey,
                                      "model-value": (
                                        /** @type import('../../types.js').VjsfNode */
                                        grandChild
                                      ),
                                      "stateful-layout": __props.statefulLayout
                                    }, null, 8, ["model-value", "stateful-layout"]);
                                  }), 128))
                                ]),
                                _: 2
                              }, 1024)
                            ]),
                            _: 2
                          }, 1024)
                        ]),
                        _: 2
                      }, 1032, ["value"]);
                    }), 128))
                  ]),
                  _: 1
                }, 8, ["modelValue"])
              ]),
              _: 1
            })
          ], 64);
        };
      }
    };
    const _hoisted_1$1 = { class: "d-flex flex-row" };
    const _sfc_main$a = {
      __name: "vertical-tabs",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfVerticalTabsNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        const tab = ref$1(0);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock(Fragment, null, [
            createVNode(_sfc_main$t, { node: __props.modelValue }, null, 8, ["node"]),
            createVNode(unref(VSheet), { border: "" }, {
              default: withCtx(() => [
                createBaseVNode("div", _hoisted_1$1, [
                  createVNode(unref(VTabs), {
                    modelValue: tab.value,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => tab.value = $event),
                    direction: "vertical"
                  }, {
                    default: withCtx(() => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(__props.modelValue.children, (child, i2) => {
                        return openBlock(), createBlock(unref(VTab), {
                          key: child.key,
                          value: i2,
                          color: child.validated && (child.error || child.childError) ? "error" : void 0
                        }, {
                          default: withCtx(() => [
                            child.validated && (child.error || child.childError) ? (openBlock(), createBlock(unref(VIcon), {
                              key: 0,
                              color: "error"
                            }, {
                              default: withCtx(() => [
                                createTextVNode(" mdi-alert ")
                              ]),
                              _: 1
                            })) : createCommentVNode("", true),
                            createTextVNode(" " + toDisplayString(child.layout.title ?? child.layout.label), 1)
                          ]),
                          _: 2
                        }, 1032, ["value", "color"]);
                      }), 128))
                    ]),
                    _: 1
                  }, 8, ["modelValue"]),
                  createVNode(unref(VWindow), {
                    modelValue: tab.value,
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => tab.value = $event),
                    class: "flex-fill"
                  }, {
                    default: withCtx(() => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(__props.modelValue.children, (child, i2) => {
                        return openBlock(), createBlock(unref(VWindowItem), {
                          key: child.key,
                          value: i2
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(VContainer), { fluid: "" }, {
                              default: withCtx(() => [
                                createVNode(unref(VRow), null, {
                                  default: withCtx(() => [
                                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(isSection)(child) ? child.children : [child], (grandChild) => {
                                      return openBlock(), createBlock(_sfc_main$v, {
                                        key: grandChild.fullKey,
                                        "model-value": (
                                          /** @type import('../../types.js').VjsfNode */
                                          grandChild
                                        ),
                                        "stateful-layout": __props.statefulLayout
                                      }, null, 8, ["model-value", "stateful-layout"]);
                                    }), 128))
                                  ]),
                                  _: 2
                                }, 1024)
                              ]),
                              _: 2
                            }, 1024)
                          ]),
                          _: 2
                        }, 1032, ["value"]);
                      }), 128))
                    ]),
                    _: 1
                  }, 8, ["modelValue"])
                ])
              ]),
              _: 1
            })
          ], 64);
        };
      }
    };
    const _sfc_main$9 = /* @__PURE__ */ defineComponent$1({
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfComboboxNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(props) {
        const items2 = shallowRef(props.modelValue.layout.items ?? []);
        const loading = ref$1(false);
        let lastStateTree = null;
        let lastContext = null;
        const hasItems = computed(() => {
          return !!(props.modelValue.layout.items || props.modelValue.layout.getItems);
        });
        const refresh = async () => {
          if (props.modelValue.layout.items)
            return;
          if (props.statefulLayout.stateTree === lastStateTree && props.statefulLayout.options.context === lastContext)
            return;
          lastStateTree = props.statefulLayout.stateTree;
          lastContext = props.statefulLayout.options.context ?? null;
          if (hasItems.value) {
            loading.value = true;
            items2.value = await props.statefulLayout.getItems(props.modelValue);
            loading.value = false;
          }
        };
        if (!props.modelValue.layout.items) {
          refresh();
        }
        const fieldProps = computed(() => {
          const fieldProps2 = getInputProps(props.modelValue, props.statefulLayout);
          fieldProps2.loading = loading.value;
          fieldProps2.returnObject = false;
          if (hasItems.value)
            fieldProps2.items = items2.value;
          if (props.modelValue.options.readOnly)
            fieldProps2.menuProps = { modelValue: false };
          if (props.modelValue.layout.multiple) {
            fieldProps2.multiple = true;
            fieldProps2.chips = true;
            fieldProps2.closableChips = true;
          }
          fieldProps2["onUpdate:menu"] = () => refresh();
          return fieldProps2;
        });
        const fieldSlots = computed(() => getCompSlots(props.modelValue, props.statefulLayout));
        return () => h(VCombobox, fieldProps.value, fieldSlots.value);
      }
    });
    const _sfc_main$8 = /* @__PURE__ */ defineComponent$1({
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfComboboxNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(props) {
        const items2 = shallowRef(props.modelValue.layout.items ?? []);
        const loading = ref$1(false);
        let lastStateTree = null;
        let lastContext = null;
        const hasItems = computed(() => {
          return !!(props.modelValue.layout.items || props.modelValue.layout.getItems);
        });
        const refresh = async () => {
          if (props.modelValue.layout.items)
            return;
          if (props.statefulLayout.stateTree === lastStateTree && props.statefulLayout.options.context === lastContext)
            return;
          lastStateTree = props.statefulLayout.stateTree;
          lastContext = props.statefulLayout.options.context ?? null;
          if (hasItems.value) {
            loading.value = true;
            items2.value = await props.statefulLayout.getItems(props.modelValue);
            loading.value = false;
          }
        };
        if (!props.modelValue.layout.items) {
          refresh();
        }
        const fieldProps = computed(() => {
          const fieldProps2 = getInputProps(props.modelValue, props.statefulLayout, ["step", "min", "max"]);
          fieldProps2.type = "number";
          fieldProps2.loading = loading.value;
          if (hasItems.value)
            fieldProps2.items = items2.value;
          if (props.modelValue.options.readOnly)
            fieldProps2.menuProps = { modelValue: false };
          if (props.modelValue.layout.multiple) {
            fieldProps2.multiple = true;
            fieldProps2.chips = true;
            fieldProps2.closableChips = true;
          }
          fieldProps2["onUpdate:menu"] = () => refresh();
          fieldProps2["onUpdate:modelValue"] = (value) => props.statefulLayout.input(props.modelValue, value && value.map(Number));
          return fieldProps2;
        });
        const fieldSlots = computed(() => getCompSlots(props.modelValue, props.statefulLayout));
        return () => h(VCombobox, fieldProps.value, fieldSlots.value);
      }
    });
    const _sfc_main$7 = {
      __name: "expansion-panels",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfExpansionPanelsNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock(Fragment, null, [
            createVNode(_sfc_main$t, { node: __props.modelValue }, null, 8, ["node"]),
            createVNode(unref(VExpansionPanels), null, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(__props.modelValue.children, (child, i2) => {
                  return openBlock(), createBlock(unref(VExpansionPanel), {
                    key: child.key,
                    value: i2
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(VExpansionPanelTitle), null, {
                        default: withCtx(() => [
                          child.validated && (child.error || child.childError) ? (openBlock(), createBlock(unref(VIcon), {
                            key: 0,
                            color: "error",
                            class: "mr-2"
                          }, {
                            default: withCtx(() => [
                              createTextVNode(" mdi-alert ")
                            ]),
                            _: 1
                          })) : createCommentVNode("", true),
                          createTextVNode(" " + toDisplayString(child.layout.title ?? child.layout.label), 1)
                        ]),
                        _: 2
                      }, 1024),
                      createVNode(unref(VContainer), { fluid: "" }, {
                        default: withCtx(() => [
                          createVNode(unref(VRow), null, {
                            default: withCtx(() => [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(isSection)(child) ? child.children : [child], (grandChild) => {
                                return openBlock(), createBlock(_sfc_main$v, {
                                  key: grandChild.fullKey,
                                  "model-value": (
                                    /** @type import('../../types.js').VjsfNode */
                                    grandChild
                                  ),
                                  "stateful-layout": __props.statefulLayout
                                }, null, 8, ["model-value", "stateful-layout"]);
                              }), 128))
                            ]),
                            _: 2
                          }, 1024)
                        ]),
                        _: 2
                      }, 1024)
                    ]),
                    _: 2
                  }, 1032, ["value"]);
                }), 128))
              ]),
              _: 1
            })
          ], 64);
        };
      }
    };
    const _sfc_main$6 = {
      __name: "stepper",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStepperNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        const props = __props;
        const step = ref$1(0);
        const firstErrorIndex = computed(() => {
          const index = props.modelValue.children.findIndex((child) => child.validated && !!(child.error || child.childError));
          return index === -1 ? props.modelValue.children.length : index;
        });
        const goNext = () => {
          const child = props.modelValue.children[step.value];
          props.statefulLayout.validateNodeRecurse(child);
          if (!(child.error || child.childError))
            step.value++;
        };
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock(Fragment, null, [
            createVNode(_sfc_main$t, { node: __props.modelValue }, null, 8, ["node"]),
            createVNode(unref(VStepper), {
              modelValue: step.value,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => step.value = $event)
            }, {
              default: withCtx(() => [
                createVNode(unref(VStepperHeader), null, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(__props.modelValue.children, (child, i2) => {
                      return openBlock(), createElementBlock(Fragment, {
                        key: child.key
                      }, [
                        createVNode(unref(VStepperItem), {
                          value: i2,
                          title: (
                            /** @type {string | undefined} */
                            child.layout.title ?? child.layout.label
                          ),
                          error: child.validated && !!(child.error || child.childError),
                          complete: child.validated && !(child.error || child.childError),
                          editable: i2 <= firstErrorIndex.value
                        }, null, 8, ["value", "title", "error", "complete", "editable"]),
                        createVNode(unref(VDivider))
                      ], 64);
                    }), 128))
                  ]),
                  _: 1
                }),
                createVNode(unref(VStepperWindow), null, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(__props.modelValue.children, (child) => {
                      return openBlock(), createBlock(unref(VStepperWindowItem), {
                        key: child.key
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(VContainer), {
                            fluid: "",
                            class: "pa-0"
                          }, {
                            default: withCtx(() => [
                              createVNode(unref(VRow), null, {
                                default: withCtx(() => [
                                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(isSection)(child) ? child.children : [child], (grandChild) => {
                                    return openBlock(), createBlock(_sfc_main$v, {
                                      key: grandChild.fullKey,
                                      "model-value": (
                                        /** @type import('../../types.js').VjsfNode */
                                        grandChild
                                      ),
                                      "stateful-layout": __props.statefulLayout
                                    }, null, 8, ["model-value", "stateful-layout"]);
                                  }), 128))
                                ]),
                                _: 2
                              }, 1024)
                            ]),
                            _: 2
                          }, 1024)
                        ]),
                        _: 2
                      }, 1024);
                    }), 128))
                  ]),
                  _: 1
                }),
                createVNode(unref(VStepperActions), null, {
                  prev: withCtx(() => [
                    step.value > 0 ? (openBlock(), createBlock(unref(VBtn), {
                      key: 0,
                      variant: "text",
                      onClick: _cache[0] || (_cache[0] = ($event) => step.value--)
                    }, {
                      default: withCtx(() => [
                        createTextVNode(" Back ")
                      ]),
                      _: 1
                    })) : createCommentVNode("", true)
                  ]),
                  next: withCtx(() => [
                    createVNode(unref(VSpacer)),
                    step.value < __props.modelValue.children.length - 1 ? (openBlock(), createBlock(unref(VBtn), {
                      key: 0,
                      variant: "flat",
                      color: "primary",
                      onClick: goNext
                    }, {
                      default: withCtx(() => [
                        createTextVNode(" Next ")
                      ]),
                      _: 1
                    })) : createCommentVNode("", true)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["modelValue"])
          ], 64);
        };
      }
    };
    function useDnd(array, callback) {
      const activeDnd = computed(() => {
        if (!("draggable" in document.createElement("div")))
          return false;
        if (window.matchMedia("(pointer: coarse)").matches)
          return false;
        return true;
      });
      const sortableArray = shallowRef(array);
      const hovered = ref$1(-1);
      const draggable = ref$1(-1);
      const dragging = ref$1(-1);
      hovered.value = 1;
      const itemBind = (itemIndex) => ({
        // hover the item
        onMouseenter: () => {
          hovered.value = itemIndex;
        },
        onMouseleave: () => {
          hovered.value = -1;
        },
        // drag the item
        onDragstart: () => {
          dragging.value = itemIndex;
        },
        onDragover: () => {
          sortableArray.value = moveArrayItem(sortableArray.value, dragging.value, itemIndex);
          dragging.value = itemIndex;
        },
        onDragend: () => {
          dragging.value = -1;
          callback();
        }
      });
      const handleBind = (itemIndex) => ({
        // hover the handle
        onMouseover() {
          draggable.value = itemIndex;
        },
        onMouseout() {
          draggable.value = -1;
        }
      });
      return {
        activeDnd,
        sortableArray,
        hovered,
        draggable,
        dragging,
        itemBind,
        handleBind
      };
    }
    const _sfc_main$5 = {
      __name: "list",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfListNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        const props = __props;
        const { activeDnd, sortableArray, draggable, hovered, dragging, itemBind, handleBind } = useDnd(props.modelValue.children, () => {
          props.statefulLayout.input(props.modelValue, sortableArray.value.map((child) => child.data));
        });
        watch(() => props.modelValue.children, (array) => {
          sortableArray.value = array;
        });
        const editedItem = computed(() => {
          return props.statefulLayout.activeItems[props.modelValue.fullKey];
        });
        const menuOpened = ref$1(-1);
        const activeItem = computed(() => {
          if (props.modelValue.layout.listActions.includes("edit") && props.modelValue.layout.listEditMode === "inline-single" && editedItem.value !== void 0) {
            return editedItem.value;
          }
          if (dragging.value !== -1)
            return -1;
          if (menuOpened.value !== -1)
            return menuOpened.value;
          return hovered.value;
        });
        const buttonDensity = computed(() => {
          if (props.modelValue.options.density === "default")
            return "comfortable";
          return props.modelValue.options.density;
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(VSheet), { elevation: 1 }, {
            default: withCtx(() => [
              createVNode(unref(VList), {
                density: __props.modelValue.options.density
              }, {
                default: withCtx(() => [
                  __props.modelValue.layout.title ? (openBlock(), createBlock(unref(VListSubheader), { key: 0 }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(__props.modelValue.layout.title), 1)
                    ]),
                    _: 1
                  })) : createCommentVNode("", true),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(sortableArray), (child, childIndex) => {
                    return openBlock(), createElementBlock(Fragment, {
                      key: props.modelValue.children.findIndex((c) => c === child)
                    }, [
                      createVNode(unref(VListItem), mergeProps(unref(itemBind)(childIndex), {
                        density: __props.modelValue.options.density,
                        draggable: unref(draggable) === childIndex,
                        variant: editedItem.value === childIndex ? "outlined" : "flat",
                        class: "pa-1 vjsf-list-item"
                      }), createSlots({
                        default: withCtx(() => [
                          createVNode(unref(VRow), { class: "ma-0" }, {
                            default: withCtx(() => [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(isSection)(child) ? child.children : [child], (grandChild) => {
                                return openBlock(), createBlock(_sfc_main$v, {
                                  key: grandChild.fullKey,
                                  "model-value": (
                                    /** @type import('../../types.js').VjsfNode */
                                    grandChild
                                  ),
                                  "stateful-layout": __props.statefulLayout
                                }, null, 8, ["model-value", "stateful-layout"]);
                              }), 128))
                            ]),
                            _: 2
                          }, 1024)
                        ]),
                        _: 2
                      }, [
                        activeItem.value === childIndex ? {
                          name: "append",
                          fn: withCtx(() => [
                            createBaseVNode("div", null, [
                              __props.modelValue.layout.listActions.includes("edit") && __props.modelValue.layout.listEditMode === "inline-single" ? (openBlock(), createBlock(unref(VListItemAction), { key: 0 }, {
                                default: withCtx(() => [
                                  editedItem.value !== childIndex ? (openBlock(), createBlock(unref(VBtn), {
                                    key: 0,
                                    title: __props.modelValue.messages.edit,
                                    icon: "mdi-pencil",
                                    variant: "text",
                                    color: "primary",
                                    density: buttonDensity.value,
                                    onClick: ($event) => __props.statefulLayout.activateItem(__props.modelValue, childIndex)
                                  }, null, 8, ["title", "density", "onClick"])) : (openBlock(), createBlock(unref(VBtn), {
                                    key: 1,
                                    title: __props.modelValue.messages.edit,
                                    icon: "mdi-pencil",
                                    variant: "flat",
                                    color: "primary",
                                    density: buttonDensity.value,
                                    onClick: _cache[0] || (_cache[0] = ($event) => __props.statefulLayout.deactivateItem(__props.modelValue))
                                  }, null, 8, ["title", "density"]))
                                ]),
                                _: 2
                              }, 1024)) : createCommentVNode("", true),
                              editedItem.value === void 0 && __props.modelValue.layout.listActions.includes("sort") && unref(activeDnd) ? (openBlock(), createBlock(unref(VListItemAction), { key: 1 }, {
                                default: withCtx(() => [
                                  createVNode(unref(VBtn), mergeProps({
                                    title: __props.modelValue.messages.sort,
                                    icon: "mdi-arrow-up-down",
                                    variant: "plain",
                                    density: buttonDensity.value
                                  }, unref(handleBind)(childIndex)), null, 16, ["title", "density"])
                                ]),
                                _: 2
                              }, 1024)) : createCommentVNode("", true),
                              editedItem.value === void 0 && (__props.modelValue.layout.listActions.includes("delete") || __props.modelValue.layout.listActions.includes("duplicate") || __props.modelValue.layout.listActions.includes("sort")) ? (openBlock(), createBlock(unref(VListItemAction), { key: 2 }, {
                                default: withCtx(() => [
                                  createVNode(unref(VMenu), {
                                    location: "bottom end",
                                    "onUpdate:modelValue": (value) => {
                                      menuOpened.value = value ? childIndex : -1;
                                    }
                                  }, {
                                    activator: withCtx(({ props: activatorProps }) => [
                                      createVNode(unref(VBtn), mergeProps(activatorProps, {
                                        icon: "mdi-dots-vertical",
                                        variant: "plain",
                                        slim: "",
                                        density: buttonDensity.value
                                      }), null, 16, ["density"])
                                    ]),
                                    default: withCtx(() => [
                                      createVNode(unref(VList), {
                                        density: __props.modelValue.options.density
                                      }, {
                                        default: withCtx(() => [
                                          __props.modelValue.layout.listActions.includes("delete") ? (openBlock(), createBlock(unref(VListItem), {
                                            key: 0,
                                            "base-color": "warning",
                                            onClick: ($event) => __props.statefulLayout.input(__props.modelValue, [...__props.modelValue.data.slice(0, childIndex), ...__props.modelValue.data.slice(childIndex + 1)])
                                          }, {
                                            prepend: withCtx(() => [
                                              createVNode(unref(VIcon), { icon: "mdi-delete" })
                                            ]),
                                            default: withCtx(() => [
                                              createTextVNode(" " + toDisplayString(__props.modelValue.messages.delete), 1)
                                            ]),
                                            _: 2
                                          }, 1032, ["onClick"])) : createCommentVNode("", true),
                                          __props.modelValue.layout.listActions.includes("duplicate") ? (openBlock(), createBlock(unref(VListItem), {
                                            key: 1,
                                            onClick: ($event) => __props.statefulLayout.input(__props.modelValue, [...__props.modelValue.data.slice(0, childIndex), unref(clone$1)(child.data), ...__props.modelValue.data.slice(childIndex)])
                                          }, {
                                            prepend: withCtx(() => [
                                              createVNode(unref(VIcon), { icon: "mdi-content-duplicate" })
                                            ]),
                                            default: withCtx(() => [
                                              createTextVNode(" " + toDisplayString(__props.modelValue.messages.duplicate), 1)
                                            ]),
                                            _: 2
                                          }, 1032, ["onClick"])) : createCommentVNode("", true),
                                          __props.modelValue.layout.listActions.includes("sort") ? (openBlock(), createBlock(unref(VListItem), {
                                            key: 2,
                                            onClick: ($event) => __props.statefulLayout.input(__props.modelValue, unref(moveArrayItem)(__props.modelValue.data, childIndex, childIndex - 1))
                                          }, {
                                            prepend: withCtx(() => [
                                              createVNode(unref(VIcon), { icon: "mdi-arrow-up" })
                                            ]),
                                            default: withCtx(() => [
                                              createTextVNode(" " + toDisplayString(__props.modelValue.messages.up), 1)
                                            ]),
                                            _: 2
                                          }, 1032, ["onClick"])) : createCommentVNode("", true),
                                          __props.modelValue.layout.listActions.includes("sort") ? (openBlock(), createBlock(unref(VListItem), {
                                            key: 3,
                                            onClick: ($event) => __props.statefulLayout.input(__props.modelValue, unref(moveArrayItem)(__props.modelValue.data, childIndex, childIndex + 1))
                                          }, {
                                            prepend: withCtx(() => [
                                              createVNode(unref(VIcon), { icon: "mdi-arrow-down" })
                                            ]),
                                            default: withCtx(() => [
                                              createTextVNode(" " + toDisplayString(__props.modelValue.messages.down), 1)
                                            ]),
                                            _: 2
                                          }, 1032, ["onClick"])) : createCommentVNode("", true)
                                        ]),
                                        _: 2
                                      }, 1032, ["density"])
                                    ]),
                                    _: 2
                                  }, 1032, ["onUpdate:modelValue"])
                                ]),
                                _: 2
                              }, 1024)) : createCommentVNode("", true)
                            ])
                          ]),
                          key: "0"
                        } : void 0
                      ]), 1040, ["density", "draggable", "variant"]),
                      childIndex < __props.modelValue.children.length - 1 ? (openBlock(), createBlock(unref(VDivider), { key: 0 })) : createCommentVNode("", true)
                    ], 64);
                  }), 128)),
                  !__props.modelValue.options.readOnly && __props.modelValue.layout.listActions.includes("add") ? (openBlock(), createBlock(unref(VListItem), { key: 1 }, {
                    default: withCtx(() => [
                      createVNode(unref(VSpacer)),
                      createVNode(unref(VBtn), {
                        color: "primary",
                        density: __props.modelValue.options.density,
                        onClick: _cache[1] || (_cache[1] = ($event) => __props.statefulLayout.input(__props.modelValue, (__props.modelValue.data ?? []).concat([void 0])))
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(__props.modelValue.messages.addItem), 1)
                        ]),
                        _: 1
                      }, 8, ["density"]),
                      createVNode(unref(VSpacer))
                    ]),
                    _: 1
                  })) : createCommentVNode("", true)
                ]),
                _: 1
              }, 8, ["density"])
            ]),
            _: 1
          });
        };
      }
    };
    const _sfc_main$4 = /* @__PURE__ */ defineComponent$1({
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfFileInputNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(props) {
        const fieldProps = computed(() => {
          const fieldProps2 = getInputProps(props.modelValue, props.statefulLayout, ["placeholder", "accept"]);
          if (props.modelValue.layout.multiple) {
            fieldProps2.multiple = true;
          } else {
            fieldProps2.modelValue = props.modelValue.data ? [props.modelValue.data] : props.modelValue.data;
            fieldProps2["onUpdate:modelValue"] = (value) => props.statefulLayout.input(props.modelValue, Array.isArray(value) ? value[0] : value);
          }
          return fieldProps2;
        });
        const fieldSlots = computed(() => getCompSlots(props.modelValue, props.statefulLayout));
        return () => h(VFileInput, fieldProps.value, fieldSlots.value);
      }
    });
    const _sfc_main$3 = {
      __name: "vjsf",
      props: {
        schema: {
          type: Object,
          required: true
        },
        precompiledLayout: {
          /** @type import('vue').PropType<import('@json-layout/core').CompiledLayout> */
          type: Object,
          default: null
        },
        modelValue: {
          type: null,
          default: null
        },
        options: {
          /** @type import('vue').PropType<import('../types.js').PartialVjsfOptions | null> */
          type: Object,
          default: null
        }
      },
      emits,
      setup(__props, { emit: __emit }) {
        const nodeComponents = {
          section: _sfc_main$s,
          "text-field": _sfc_main$r,
          textarea: _sfc_main$q,
          checkbox: _sfc_main$p,
          switch: _sfc_main$o,
          "number-field": _sfc_main$n,
          slider: _sfc_main$m,
          "date-picker": _sfc_main$k,
          "date-time-picker": _sfc_main$j,
          "color-picker": _sfc_main$i,
          select: _sfc_main$e,
          autocomplete: _sfc_main$d,
          "one-of-select": _sfc_main$c,
          tabs: _sfc_main$b,
          "vertical-tabs": _sfc_main$a,
          "expansion-panels": _sfc_main$7,
          stepper: _sfc_main$6,
          list: _sfc_main$5,
          combobox: _sfc_main$9,
          "number-combobox": _sfc_main$8,
          "file-input": _sfc_main$4
        };
        const props = __props;
        const emit2 = __emit;
        const { el: el2, statefulLayout, stateTree } = useVjsf(
          computed(() => props.schema),
          computed(() => props.modelValue),
          computed(() => props.options),
          nodeComponents,
          emit2,
          compile,
          computed(() => props.precompiledLayout)
        );
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref_key: "el",
            ref: el2,
            class: "vjsf"
          }, [
            unref(statefulLayout) && unref(stateTree) ? (openBlock(), createBlock(_sfc_main$u, {
              key: 0,
              "model-value": unref(stateTree),
              "stateful-layout": unref(statefulLayout)
            }, null, 8, ["model-value", "stateful-layout"])) : createCommentVNode("", true)
          ], 512);
        };
      }
    };
    const _sfc_main$2 = /* @__PURE__ */ defineComponent$1({
      __name: "IconButtonWithTooltip",
      props: {
        title: {},
        icon: {},
        variant: {},
        density: {}
      },
      emits: ["click"],
      setup(__props, { emit: __emit }) {
        const props = __props;
        const emit2 = __emit;
        return (_ctx, _cache) => {
          return openBlock(), createBlock(VTooltip, { location: "bottom" }, {
            activator: withCtx(({ props: props2 }) => [
              createVNode(VBtn, mergeProps(props2, {
                icon: _ctx.icon,
                class: "icon-right",
                onClick: _cache[0] || (_cache[0] = ($event) => emit2("click")),
                variant: _ctx.variant,
                density: _ctx.density
              }), null, 16, ["icon", "variant", "density"])
            ]),
            default: withCtx(() => [
              createBaseVNode("span", null, toDisplayString(props.title), 1)
            ]),
            _: 1
          });
        };
      }
    });
    const IconButtonWithTooltip = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-40228a16"]]);
    let evbcStore;
    const _sfc_main$1 = /* @__PURE__ */ defineComponent$1({
      created() {
        evbcStore = useEvbcStore();
      },
      computed: {
        // FIXME (aw): this is not how it works!
        module_node() {
          const instance_id = evbcStore.get_selected_module_instance();
          if (instance_id === null) {
            return null;
          }
          const instance = this.config_model.get_module_instance(instance_id);
          return {
            instance_id,
            instance
          };
        },
        terminal() {
          return evbcStore.get_selected_terminal();
        },
        config_model: function() {
          return evbcStore.get_current_config();
        },
        connection: function() {
          const connection_id = evbcStore.get_selected_connection();
          if (connection_id === null) {
            return null;
          }
          const cxn = this.config_model.get_connection(connection_id);
          const requiring_module = this.config_model.get_module_instance(cxn.requiring_instance_id);
          const implementing_module = this.config_model.get_module_instance(cxn.providing_instance_id);
          return {
            from: {
              type: implementing_module.type,
              id: implementing_module.id,
              name: cxn.providing_impl_name
            },
            to: {
              type: requiring_module.type,
              id: requiring_module.id,
              name: cxn.requirement_name
            },
            id: connection_id
          };
        },
        context: function() {
          return evbcStore.config_context;
        },
        moduleIDRules: function() {
          return [
            (v) => {
              const instance_id = this.module_node.instance_id;
              const result = this.config_model.update_module_id(instance_id, v);
              return result || "This module id is not available";
            }
          ];
        }
      },
      methods: {
        delete_connection(id2) {
          this.config_model.delete_connection(id2);
        },
        delete_module_instance(id2) {
          this.config_model.delete_module_instance(id2);
        }
      },
      components: {
        Vjsf: _sfc_main$3,
        IconButtonWithTooltip
      }
    });
    const _hoisted_1 = { class: "font-weight-bold" };
    const _hoisted_2 = /* @__PURE__ */ createBaseVNode("p", { class: "font-weight-bold" }, "Module configuration", -1);
    const _hoisted_3 = /* @__PURE__ */ createBaseVNode("p", { class: "font-weight-bold" }, "Implementation configurations", -1);
    function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_icon_button_with_tooltip = resolveComponent("icon-button-with-tooltip");
      const _component_vjsf = resolveComponent("vjsf");
      return _ctx.module_node ? (openBlock(), createBlock(VCard, {
        key: 0,
        title: "Module instance information"
      }, {
        append: withCtx(() => [
          createVNode(_component_icon_button_with_tooltip, {
            icon: "mdi-close",
            title: "Discard selection",
            variant: "text",
            density: "compact",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.context.unselect())
          })
        ]),
        default: withCtx(() => [
          createVNode(VCardText, null, {
            default: withCtx(() => {
              var _a2, _b;
              return [
                createBaseVNode("p", _hoisted_1, "Module type: " + toDisplayString((_b = (_a2 = _ctx.module_node) == null ? void 0 : _a2.instance) == null ? void 0 : _b.type), 1),
                createVNode(VForm, null, {
                  default: withCtx(() => {
                    var _a3;
                    return [
                      createVNode(VTextField, {
                        "model-value": (_a3 = _ctx.module_node) == null ? void 0 : _a3.instance.id,
                        label: "Module ID",
                        rules: _ctx.moduleIDRules
                      }, null, 8, ["model-value", "rules"])
                    ];
                  }),
                  _: 1
                }),
                createVNode(VForm, null, {
                  default: withCtx(() => [
                    _ctx.module_node.instance.module_config ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      createVNode(VDivider),
                      _hoisted_2,
                      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.module_node.instance.module_config, (item, index) => {
                        return openBlock(), createBlock(_component_vjsf, {
                          key: index,
                          modelValue: item.model,
                          "onUpdate:modelValue": ($event) => item.model = $event,
                          schema: item.schema
                        }, null, 8, ["modelValue", "onUpdate:modelValue", "schema"]);
                      }), 128))
                    ], 64)) : createCommentVNode("", true),
                    _ctx.module_node.instance.implementation_config ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createVNode(VDivider),
                      _hoisted_3,
                      createVNode(VExpansionPanels, null, {
                        default: withCtx(() => [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.module_node.instance.implementation_config, (impl_config, id2) => {
                            return openBlock(), createBlock(VExpansionPanel, { key: id2 }, {
                              default: withCtx(() => [
                                createVNode(VExpansionPanelTitle, null, {
                                  default: withCtx(() => [
                                    createTextVNode(toDisplayString(id2), 1)
                                  ]),
                                  _: 2
                                }, 1024),
                                createVNode(VExpansionPanelText, null, {
                                  default: withCtx(() => [
                                    (openBlock(true), createElementBlock(Fragment, null, renderList(impl_config, (item, index) => {
                                      return openBlock(), createBlock(_component_vjsf, {
                                        key: index,
                                        modelValue: item.model,
                                        "onUpdate:modelValue": ($event) => item.model = $event,
                                        schema: item.schema
                                      }, null, 8, ["modelValue", "onUpdate:modelValue", "schema"]);
                                    }), 128))
                                  ]),
                                  _: 2
                                }, 1024)
                              ]),
                              _: 2
                            }, 1024);
                          }), 128))
                        ]),
                        _: 1
                      })
                    ], 64)) : createCommentVNode("", true)
                  ]),
                  _: 1
                })
              ];
            }),
            _: 1
          }),
          createVNode(VCardActions, null, {
            default: withCtx(() => [
              createVNode(_component_icon_button_with_tooltip, {
                icon: "mdi-delete",
                title: "Delete instance",
                onClick: _cache[1] || (_cache[1] = ($event) => _ctx.delete_module_instance(_ctx.module_node.instance_id))
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      })) : _ctx.connection ? (openBlock(), createBlock(VCard, { key: 1 }, {
        default: withCtx(() => [
          createVNode(VCardTitle, null, {
            default: withCtx(() => [
              createTextVNode(" Connection "),
              createVNode(_component_icon_button_with_tooltip, {
                icon: "mdi-close",
                title: "Discard selection",
                variant: "text",
                density: "compact",
                onClick: _cache[2] || (_cache[2] = ($event) => _ctx.context.unselect())
              })
            ]),
            _: 1
          }),
          createVNode(VCardText, null, {
            default: withCtx(() => [
              createTextVNode(" The requirement "),
              createBaseVNode("code", null, toDisplayString(_ctx.connection.to.name), 1),
              createTextVNode(" of "),
              createBaseVNode("code", null, toDisplayString(_ctx.connection.to.id), 1),
              createTextVNode(" is fulfilled by implementation "),
              createBaseVNode("code", null, toDisplayString(_ctx.connection.from.name), 1),
              createTextVNode(" of "),
              createBaseVNode("code", null, toDisplayString(_ctx.connection.from.id), 1)
            ]),
            _: 1
          }),
          createVNode(VCardActions, null, {
            default: withCtx(() => [
              createVNode(_component_icon_button_with_tooltip, {
                icon: "mdi-delete",
                title: "Delete connection",
                onClick: _cache[3] || (_cache[3] = ($event) => _ctx.delete_connection(_ctx.connection.id))
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      })) : _ctx.terminal ? (openBlock(), createBlock(VCard, { key: 2 }, {
        default: withCtx(() => [
          createVNode(VCardTitle, null, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.terminal.type === "provide" ? "Implementation" : "Requirement") + ": ", 1),
              createBaseVNode("code", null, toDisplayString(_ctx.terminal.id), 1),
              createVNode(_component_icon_button_with_tooltip, {
                icon: "mdi-close",
                title: "Discard selection",
                variant: "text",
                density: "compact",
                onClick: _cache[4] || (_cache[4] = ($event) => _ctx.context.unselect())
              })
            ]),
            _: 1
          }),
          createVNode(VCardText, null, {
            default: withCtx(() => [
              createTextVNode(" Interface type: "),
              createBaseVNode("code", null, toDisplayString(_ctx.terminal.interface), 1)
            ]),
            _: 1
          })
        ]),
        _: 1
      })) : createCommentVNode("", true);
    }
    const EvModuleInfo = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
    const _sfc_main = /* @__PURE__ */ defineComponent$1({
      components: {
        EvConfigCanvas,
        EvModuleList,
        EvModuleInfo
      }
    });
    function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ev_module_list = resolveComponent("ev-module-list");
      const _component_ev_config_canvas = resolveComponent("ev-config-canvas");
      const _component_ev_module_info = resolveComponent("ev-module-info");
      return openBlock(), createBlock(VContainer, {
        fluid: "",
        class: "fill-height"
      }, {
        default: withCtx(() => [
          createVNode(VRow, { class: "fill-height" }, {
            default: withCtx(() => [
              createVNode(VCol, {
                cols: "2",
                class: "overflow-y-auto pa-0",
                style: { "max-height": "calc(100vh - 96px)" }
              }, {
                default: withCtx(() => [
                  createVNode(_component_ev_module_list)
                ]),
                _: 1
              }),
              createVNode(VCol, {
                class: "pt-0",
                cols: "7"
              }, {
                default: withCtx(() => [
                  createVNode(_component_ev_config_canvas)
                ]),
                _: 1
              }),
              createVNode(VCol, {
                cols: "3",
                class: "overflow-y-auto pa-0 pr-2",
                style: { "max-height": "calc(100vh - 96px)" }
              }, {
                default: withCtx(() => [
                  createVNode(_component_ev_module_info)
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      });
    }
    const ConfigPage = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__scopeId", "data-v-dd1b2d1f"]]);
    const routes = [
      {
        path: "/login",
        name: "login",
        component: LoginPage
      },
      {
        path: "/",
        name: "main",
        component: MainPanel,
        children: [
          {
            path: "config",
            component: ConfigPage
          }
        ],
        meta: { requiresConnection: true }
      }
    ];
    const router = createRouter({
      history: createWebHashHistory("/everest-admin-panel/pr-86"),
      routes
    });
    router.beforeEach((to, from, next2) => {
      const evbc2 = inject$1("evbc");
      const userIsLoggedIn = evbc2 == null ? void 0 : evbc2.initialized;
      if (to.path === "/" && userIsLoggedIn) {
        next2("/config");
      } else if (to.matched.some((record) => record.meta.requiresConnection)) {
        if (userIsLoggedIn) {
          next2();
        } else {
          next2("/login");
        }
      } else {
        next2();
      }
    });
    function generate_interface_parents_map(interface_definitions) {
      const interface_parents = {};
      Object.keys(interface_definitions).forEach((interface_name) => {
        const parents = /* @__PURE__ */ new Set();
        function recurse2(name) {
          const parent = interface_definitions[name].parent;
          if (parent) {
            parents.add(parent);
            recurse2(parent);
          }
        }
        recurse2(interface_name);
        interface_parents[interface_name] = parents;
      });
      return interface_parents;
    }
    function default_terminals(module_definition) {
      const left_terminals = [];
      if (module_definition.requires) {
        Object.entries(module_definition.requires).forEach(
          ([key, value]) => left_terminals.push(
            Object.freeze({
              id: key,
              interface: value.interface,
              type: "requirement"
            })
          )
        );
      }
      const right_terminals = [];
      if (module_definition.provides) {
        Object.entries(module_definition.provides).forEach(
          ([key, value]) => right_terminals.push(
            Object.freeze({
              id: key,
              interface: value.interface,
              type: "provide"
            })
          )
        );
      }
      return {
        top: [],
        right: right_terminals,
        bottom: [],
        left: left_terminals
      };
    }
    var collectionClone = clone;
    function clone(obj) {
      let result = obj;
      var type2 = {}.toString.call(obj).slice(8, -1);
      if (type2 == "Set") {
        return new Set([...obj].map((value) => clone(value)));
      }
      if (type2 == "Map") {
        return new Map([...obj].map((kv) => [clone(kv[0]), clone(kv[1])]));
      }
      if (type2 == "Date") {
        return new Date(obj.getTime());
      }
      if (type2 == "RegExp") {
        return RegExp(obj.source, getRegExpFlags(obj));
      }
      if (type2 == "Array" || type2 == "Object") {
        result = Array.isArray(obj) ? [] : {};
        for (var key in obj) {
          result[key] = clone(obj[key]);
        }
      }
      return result;
    }
    function getRegExpFlags(regExp) {
      if (typeof regExp.source.flags == "string") {
        return regExp.source.flags;
      } else {
        var flags = [];
        regExp.global && flags.push("g");
        regExp.ignoreCase && flags.push("i");
        regExp.multiline && flags.push("m");
        regExp.sticky && flags.push("y");
        regExp.unicode && flags.push("u");
        return flags.join("");
      }
    }
    function get_next_available_name(prefix, name_list) {
      const valid_integral_endings = name_list.filter((item) => item.startsWith(prefix)).map((item) => Number(item.slice(prefix.length))).filter((item) => Number.isInteger(item) && item >= 0).sort((a, b) => a - b);
      const count = valid_integral_endings.length;
      const next_number = count === 0 ? 0 : valid_integral_endings[count - 1] + 1;
      return `${prefix}${next_number}`;
    }
    function config_set_with_schema_to_config_set(config_set) {
      const entries = config_set.filter((item) => item.model !== void 0).map((item) => [item.schema.title, item.model]);
      return Object.fromEntries(entries);
    }
    class EVConfigModel {
      constructor(definitions2, name, config2) {
        __publicField(this, "_module_definitions");
        __publicField(this, "_interface_parents");
        __publicField(this, "_next_instance_id", 0);
        __publicField(this, "_next_connection_id", 0);
        __publicField(this, "_name");
        __publicField(this, "_instances", {});
        __publicField(this, "_connections", {});
        // FIXME (aw): refactor this functionality like a mixin or something similar
        __publicField(this, "_event_handlers", []);
        this._module_definitions = definitions2.modules;
        this._interface_parents = generate_interface_parents_map(definitions2.interfaces);
        this._name = name;
        if (!config2) {
          return;
        }
        Object.entries(config2.active_modules).forEach(([module_id, module_config]) => {
          var _a2;
          this._add_module_instance(module_config.module, module_id, module_config, (_a2 = config2["x-module-layout"]) == null ? void 0 : _a2[module_id]);
        });
        Object.entries(this._instances).forEach(([_instance_id, module_instance]) => {
          const instance_connections = config2.active_modules[module_instance.id].connections;
          if (!instance_connections)
            return;
          Object.entries(instance_connections).forEach(([requirement_name, requirement_connections]) => {
            requirement_connections.forEach((provider) => {
              const providing_instance_id = this._module_instance_id_from_module_id(provider.module_id);
              this.add_connection({
                providing_impl_name: provider.implementation_id,
                providing_instance_id,
                requirement_name,
                requiring_instance_id: Number(_instance_id)
              });
            });
          });
        });
      }
      _module_instance_id_from_module_id(module_id) {
        const pair = Object.entries(this._instances).find(([, instance]) => instance.id === module_id);
        return pair ? Number(pair[0]) : null;
      }
      add_observer(handler) {
        this._event_handlers.push(handler);
      }
      _notify(event) {
        this._event_handlers.forEach((handler) => {
          handler(event);
        });
      }
      add_new_module_instance(module_type, module_id) {
        module_id = module_id || get_next_available_name(
          module_type,
          Object.values(this._instances).map((item) => item.id)
        );
        return this._add_module_instance(module_type, module_id);
      }
      delete_module_instance(id2) {
        if (!(id2 in this._instances)) {
          throw Error(`Module instance with instance id "${id2}" does not exist`);
        }
        const cxns = Object.entries(this._connections).filter(
          ([, cxn]) => cxn.providing_instance_id === id2 || cxn.requiring_instance_id === id2
        );
        cxns.forEach(([cxn_id]) => {
          this.delete_connection(parseInt(cxn_id));
        });
        delete this._instances[id2];
        this._notify({ type: "MODULE_INSTANCE_DELETED", id: id2 });
      }
      add_connection(conn) {
        this._validate_connection(conn);
        this._connection_exists(conn);
        const new_connection_id = this._next_connection_id;
        this._next_connection_id++;
        const new_connection = Object.assign({}, conn);
        this._connections[new_connection_id] = new_connection;
        this._add_connection_to_instance(conn.requiring_instance_id, new_connection_id);
        this._notify({ type: "CONNECTION_ADDED", id: new_connection_id });
        return new_connection_id;
      }
      // FIXME (aw): all these update module things need to factored out in a module instance model class
      update_module_id(module_instance_id, new_module_id) {
        const module_instance = this.get_module_instance(module_instance_id);
        if (module_instance.id == new_module_id) {
          return true;
        }
        if (Object.values(this._instances).filter((config2) => config2.id == new_module_id).length) {
          return false;
        }
        module_instance.id = new_module_id;
        this._notify({ type: "MODULE_INSTANCE_UPDATED", id: module_instance_id });
        return true;
      }
      update_module_view_position(module_instance_id, pos) {
        const module_instance = this.get_module_instance(module_instance_id);
        module_instance.view_config.position = collectionClone(pos);
      }
      update_module_view_terminals(module_instance_id, arrangement) {
        const module_instance = this.get_module_instance(module_instance_id);
        for (const _alignment in arrangement) {
          const alignment = _alignment;
          module_instance.view_config.terminals[alignment] = collectionClone(arrangement[alignment]);
        }
      }
      get_connection(connection_id) {
        return this._connections[connection_id];
      }
      delete_connection(connection_id) {
        if (!(connection_id in this._connections)) {
          throw Error(`Connection with id "${connection_id}" unknown`);
        }
        const conn = this._connections[connection_id];
        this._remove_connection_from_instance(conn.requiring_instance_id, connection_id);
        delete this._connections[connection_id];
        this._notify({ type: "CONNECTION_DELETED", id: connection_id });
      }
      get module_definitions() {
        return this._module_definitions;
      }
      get_module_instance(id2) {
        return this._instances[id2];
      }
      interfaces_match(provide2, requirement) {
        if (provide2 === requirement)
          return true;
        if (this._interface_parents[provide2].has(requirement))
          return true;
        return false;
      }
      serialize() {
        const config2 = { active_modules: {}, "x-module-layout": {} };
        Object.entries(this._instances).forEach(([, instance]) => {
          const modules_config = config2.active_modules;
          const connections = {};
          instance.connections.map((id2) => this._connections[id2]).forEach((cxn) => {
            const fullfilment = {
              module_id: this._instances[cxn.providing_instance_id].id,
              implementation_id: cxn.providing_impl_name
            };
            if (cxn.requirement_name in connections) {
              connections[cxn.requirement_name].push(fullfilment);
            } else {
              connections[cxn.requirement_name] = [fullfilment];
            }
          });
          modules_config[instance.id] = {
            module: instance.type,
            connections
          };
          config2["x-module-layout"][instance.id] = instance.view_config;
          if (instance.module_config && Object.keys(instance.module_config).length !== 0) {
            modules_config[instance.id].config_module = config_set_with_schema_to_config_set(instance.module_config);
          }
          if (instance.implementation_config) {
            const implementation_config = {};
            Object.entries(instance.implementation_config).forEach(([impl_name, config_set_with_schema]) => {
              const config_set = config_set_with_schema_to_config_set(config_set_with_schema);
              if (Object.keys(config_set).length != 0) {
                implementation_config[impl_name] = config_set;
              }
            });
            if (Object.keys(implementation_config).length !== 0) {
              modules_config[instance.id].config_implementation = implementation_config;
            }
          }
        });
        return config2;
      }
      _setup_config_set(schema, config2) {
        if (schema === void 0) {
          return void 0;
        }
        return Object.entries(schema).map(([key, value]) => {
          const config_value = config2 !== void 0 && key in config2 ? config2[key] : value.default;
          return { schema: { ...value, title: key }, model: config_value };
        });
      }
      _add_module_instance(type2, id2, config2, view_config) {
        if (!(type2 in this._module_definitions)) {
          throw Error(`Invalid module type: ${type2}`);
        }
        if (Object.values(this._instances).filter((value) => value.id === id2).length) {
          throw Error(`Module instance with id: ${module.id} already exists`);
        }
        const manifest = this._module_definitions[type2];
        const impl_configs = {};
        Object.entries(manifest.provides).forEach(([impl_name, impl_def]) => {
          const impl_config = (config2 == null ? void 0 : config2.config_implementation) !== void 0 && impl_name in config2.config_implementation ? config2.config_implementation[impl_name] : void 0;
          if (impl_def.config !== void 0) {
            impl_configs[impl_name] = this._setup_config_set(impl_def.config, impl_config);
          }
        });
        const instance_id = this._next_instance_id;
        this._next_instance_id++;
        this._instances[instance_id] = {
          id: id2,
          type: type2,
          module_config: this._setup_config_set(manifest.config, config2 == null ? void 0 : config2.config_module),
          implementation_config: Object.keys(impl_configs).length ? impl_configs : void 0,
          connections: [],
          view_config: view_config ? view_config : {
            position: null,
            terminals: default_terminals(manifest)
          }
        };
        this._notify({ type: "MODULE_INSTANCE_ADDED", id: instance_id });
        return instance_id;
      }
      _validate_connection(conn) {
        const prov_id = conn.providing_instance_id;
        if (!(prov_id in this._instances)) {
          throw Error(`Providing instance with instance id ${prov_id} does not exist`);
        }
        const req_id = conn.requiring_instance_id;
        if (!(req_id in this._instances)) {
          throw Error(`Requiring instance with instance id ${req_id} does not exist`);
        }
        const prov_module = this._instances[prov_id].type;
        const prov_manifest = this._module_definitions[prov_module];
        const req_module = this._instances[req_id].type;
        const req_manifest = this._module_definitions[req_module];
        if (!(conn.providing_impl_name in prov_manifest.provides)) {
          throw Error(
            `Providing module of type "${prov_module}" does not provide an implementation named "${conn.providing_impl_name}"`
          );
        }
        if (!(conn.requirement_name in req_manifest.requires)) {
          throw Error(
            `Requiring module of type "${req_module}" does not have an requirement called "${conn.requirement_name}"`
          );
        }
        const prov_interface = prov_manifest.provides[conn.providing_impl_name].interface;
        const req_interface = req_manifest.requires[conn.requirement_name].interface;
        if (!this.interfaces_match(prov_interface, req_interface)) {
          throw Error(
            `The interface for the provide (${prov_interface}) and the requirement (${req_interface}) do not match`
          );
        }
      }
      _connection_exists(conn) {
        for (const [, other_conn] of Object.entries(this._connections)) {
          if (conn.providing_impl_name === other_conn.providing_impl_name && conn.providing_instance_id === other_conn.providing_instance_id && conn.requirement_name === other_conn.requirement_name && conn.requiring_instance_id === other_conn.requiring_instance_id) {
            throw Error(`The connection "${JSON.stringify(conn, null, 2)}" already exists`);
          }
        }
      }
      _add_connection_to_instance(instance_id, connection_id) {
        this._instances[instance_id].connections.push(connection_id);
      }
      _remove_connection_from_instance(instance_id, connection_id) {
        const connection_list = this._instances[instance_id].connections;
        const index = connection_list.indexOf(connection_id);
        if (index > -1) {
          connection_list.splice(index, 1);
        }
      }
    }
    const SampleManifestList = {
      EnergyManager: {
        description: "This module is the global Energy Manager for all EVSE/Charging stations in this building",
        enable_external_mqtt: false,
        metadata: {
          authors: ["Cornelius Claussen"],
          license: "https://opensource.org/licenses/Apache-2.0"
        },
        provides: {
          main: {
            description: "Main interface of the energy manager",
            interface: "energy_manager"
          }
        },
        requires: {
          energy_trunk: {
            interface: "energy"
          }
        }
      },
      EnergyNode: {
        config: {
          fuse_limit_A: {
            description: "Fuse limit in ampere for all phases",
            minimum: 0,
            type: "number"
          },
          phase_count: {
            description: "phase count limit. Omit if not limited in this fuse.",
            maximum: 3,
            minimum: 0,
            type: "integer"
          }
        },
        description: "This module is part of the Energy Tree and represents a simple current fuse.",
        enable_external_mqtt: false,
        metadata: {
          authors: ["Cornelius Claussen"],
          license: "https://opensource.org/licenses/Apache-2.0"
        },
        provides: {
          energy_grid: {
            description: "This is the chain interface to build the energy supply tree",
            interface: "energy"
          }
        },
        requires: {
          energy_consumer: {
            interface: "energy",
            max_connections: 128,
            min_connections: 1
          },
          powermeter: {
            interface: "powermeter",
            max_connections: 128,
            min_connections: 0
          },
          price_information: {
            interface: "energy_price_information",
            max_connections: 128,
            min_connections: 0
          }
        }
      },
      EvseManager: {
        config: {
          country_code: {
            default: "DE",
            description: "Country Code",
            type: "string"
          },
          has_ventilation: {
            default: true,
            description: "Allow ventilated charging or not",
            type: "boolean"
          },
          max_current: {
            default: 32,
            description: "User configurable current limit for this EVSE",
            type: "number"
          },
          rcd_enabled: {
            default: true,
            description: "Enable or disable RCD",
            type: "boolean"
          },
          three_phases: {
            default: true,
            description: "Limit to three phases (true) or one phase (false)",
            type: "boolean"
          }
        },
        description: "EVSE Manager",
        enable_external_mqtt: true,
        metadata: {
          authors: ["Cornelius Claussen", "Anton Woellert"],
          license: "https://spdx.org/licenses/Apache-2.0.html"
        },
        provides: {
          energy_grid: {
            description: "This is the tree leaf interface to build the energy supply tree",
            interface: "energy"
          },
          evse: {
            description: "This is the main evsemanager interface",
            interface: "evse_manager"
          }
        },
        requires: {
          auth: {
            interface: "auth"
          },
          bsp: {
            interface: "board_support_AC"
          },
          powermeter: {
            interface: "powermeter"
          }
        }
      },
      EvseSlac: {
        description: "Implementation of SLAC data link negotiation according to ISO15118-3.",
        metadata: {
          authors: ["aw@pionix.de", "Cornelius Claussen (Pionix GmbH)"],
          base_license: "https://directory.fsf.org/wiki/License:BSD-3-Clause-Clear",
          license: "https://opensource.org/licenses/Apache-2.0"
        },
        provides: {
          main: {
            config: {
              device: {
                default: "eth1",
                description: "Ethernet device used for PLC.",
                type: "string"
              },
              evse_id: {
                default: "PIONIX_SAYS_HELLO",
                description: "EVSE id - 17 octets.",
                type: "string"
              },
              nid: {
                default: "pionix!",
                description: "NID (Network Identification Key) - 7 octets.",
                type: "string"
              },
              number_of_sounds: {
                default: 10,
                description: "SLAC number of sounds.",
                type: "integer"
              }
            },
            description: "SLAC interface implementation.",
            interface: "slac"
          }
        }
      },
      Example: {
        description: "Simple example module written in C++",
        enable_external_mqtt: true,
        metadata: {
          authors: ["Kai-Uwe Hermann"],
          license: "https://opensource.org/licenses/Apache-2.0"
        },
        provides: {
          example: {
            config: {
              current: {
                description: "The current the physical connector can supply",
                maximum: 60,
                minimum: 1,
                type: "number"
              },
              enum_test: {
                description: "A config value that tests the enum type",
                enum: ["one", "two", "three"],
                type: "string"
              },
              enum_test2: {
                description: "Another config value that tests the enum type",
                enum: [1, 2, 3],
                type: "integer"
              }
            },
            description: "This implements an example interface that uses multiple framework features",
            interface: "example_child"
          },
          store: {
            description: "This implements the kvs interface, mostly for testing multiple interfaces in one manifest",
            interface: "kvs"
          }
        },
        requires: {
          kvs: {
            interface: "kvs"
          }
        }
      },
      ExampleUser: {
        description: "Simple example module written in C++ and using the other example module",
        metadata: {
          authors: ["Kai-Uwe Hermann"],
          license: "https://opensource.org/licenses/Apache-2.0"
        },
        provides: {
          example_user: {
            description: "This implements the example_user interface",
            interface: "example_user"
          }
        },
        requires: {
          example: {
            interface: "example"
          }
        }
      },
      JsAuth: {
        description: "This module implements the authentication API for the everest system.",
        metadata: {
          authors: ["Thilo Molitor"],
          license: "https://opensource.org/licenses/Apache-2.0"
        },
        provides: {
          main: {
            description: "This implements the authentication interface for the everest system.",
            interface: "auth"
          }
        },
        requires: {
          tokenProvider: {
            interface: "auth_token_provider",
            max_connections: 128,
            min_connections: 1
          },
          tokenValidator: {
            interface: "auth_token_validator",
            max_connections: 128,
            min_connections: 1
          }
        }
      },
      JsCarSimulator: {
        description: "This module implements a Car simulator that can execute charging sessions using the yeti-simulation-control interface",
        enable_external_mqtt: true,
        metadata: {
          authors: ["Cornelius Claussen"],
          license: "https://opensource.org/licenses/Apache-2.0"
        },
        provides: {
          main: {
            description: "This implements the car simulator",
            interface: "car_simulator"
          }
        },
        requires: {
          simulation_control: {
            interface: "yeti_simulation_control"
          }
        }
      },
      JsDummy: {
        description: "This module is only for testing",
        metadata: {
          authors: ["aw"],
          license: "https://opensource.org/licenses/MIT"
        },
        provides: {
          main: {
            config: {
              test: {
                description: "test parm",
                type: "boolean"
              },
              type: {
                description: "test type",
                type: "number"
              }
            },
            description: "This implements the dummy API for the everest system.",
            interface: "dummy"
          }
        }
      },
      JsDummyTokenProvider: {
        description: "Dummy token provider that listens to AuthRequired event from evse_manager and then publishes one token",
        metadata: {
          authors: ["Thilo Molitor", "Cornelius Claussen"],
          license: "https://opensource.org/licenses/Apache-2.0"
        },
        provides: {
          main: {
            config: {
              timeout: {
                default: 10,
                description: "Time our dummy token is valid (in s)",
                maximum: 120,
                minimum: 0,
                type: "number"
              },
              token: {
                default: "DEADBEEF",
                description: "Dummy token string to return",
                maxLength: 20,
                minLength: 1,
                type: "string"
              },
              type: {
                default: "dummy",
                description: "Type to report for our dummy token",
                maxLength: 32,
                minLength: 2,
                type: "string"
              }
            },
            description: "Main implementation of dummy token provider always returning one configured token",
            interface: "auth_token_provider"
          }
        },
        requires: {
          evse: {
            interface: "evse_manager"
          }
        }
      },
      JsDummyTokenValidator: {
        description: "Dummy token validator always returning the same configured token validation result for every token",
        metadata: {
          authors: ["Thilo Molitor"],
          license: "https://opensource.org/licenses/Apache-2.0"
        },
        provides: {
          main: {
            config: {
              sleep: {
                default: 0.5,
                description: "Time to wait before returning the dumy validation result (in s)",
                maximum: 120,
                minimum: 0,
                type: "number"
              },
              validation_reason: {
                default: "Token valid",
                description: "Dummy validation reason to return",
                minLength: 5,
                type: "string"
              },
              validation_result: {
                default: "Accepted",
                description: "Dummy validation result to return",
                enum: ["Accepted", "Blocked", "Expired", "Invalid"],
                type: "string"
              }
            },
            description: "Main implementation of dummy token validator always returning the same configured token validation result for every token",
            interface: "auth_token_validator"
          }
        }
      },
      JsEmulator: {
        description: "Emulation modul, provides different emulation units",
        metadata: {
          authors: ["aw@pionix.de"],
          license: "https://opensource.org/licenses/MIT"
        },
        provides: {
          iso15118_evcc: {
            config: {
              conf1: {
                description: "conf1 setting",
                type: "string"
              }
            },
            description: "Unit for emulating an ISO15118 EVCC",
            interface: "iso15118_evcc_emu"
          }
        }
      },
      JsForecastDotSolar: {
        description: "This modules fetches data from the ForecastDotSolar API and publishes it.",
        enable_external_mqtt: true,
        metadata: {
          authors: ["Andreas Heinrich", "Leonardo Oliveira"],
          license: "https://opensource.org/licenses/Apache-2.0"
        },
        provides: {
          main: {
            config: {
              all_panels_max_power: {
                description: "Maximum power peak production of ALL combined solar panels",
                minimum: 0,
                type: "number"
              },
              api_key: {
                description: "API key for forecast.solar",
                type: "string"
              },
              azimuth: {
                description: "Plane azimuth angle",
                maximum: 360,
                minimum: 0,
                type: "number"
              },
              latitude: {
                description: "Location latitude",
                maximum: 90,
                minimum: -90,
                type: "number"
              },
              longitude: {
                description: "Location longitude",
                maximum: 180,
                minimum: -180,
                type: "number"
              },
              update_interval: {
                description: "Update interval in minutes",
                type: "integer"
              }
            },
            description: "This interface is responsible for providing the solar forecast data",
            interface: "solar_forecast"
          }
        }
      },
      JsPN532TokenProvider: {
        description: "PN532 RFID/NFC token provider returning the token as soon as the tag can be read by the reader",
        metadata: {
          authors: ["Thilo Molitor"],
          license: "https://opensource.org/licenses/Apache-2.0"
        },
        provides: {
          main: {
            config: {
              baud_rate: {
                default: 115200,
                description: "Serial baud rate to use when communicating with PN532 hardware",
                maximum: 230400,
                minimum: 9600,
                type: "integer"
              },
              serial_port: {
                default: "/dev/ttyS0",
                description: "Serial port the PN532 hardware is connected to",
                type: "string"
              },
              timeout: {
                default: 30,
                description: "Time a new token is valid (in s)",
                maximum: 120,
                minimum: 0,
                type: "number"
              }
            },
            description: "Implementation of PN532 RFID/NFC token provider",
            interface: "auth_token_provider"
          }
        }
      },
      JsRiseV2G: {
        description: "This module implements ISO15118 ac and dc charging by proxying everything into a modified RISE-V2G implementation",
        enable_external_mqtt: true,
        metadata: {
          authors: ["Thilo Molitor"],
          license: "https://opensource.org/licenses/Apache-2.0"
        },
        provides: {
          ac_charger: {
            description: "This module implements the ISO15118-2 implementation of an AC charger",
            interface: "ISO15118_ac_charger"
          },
          dc_charger: {
            description: "This module implements the ISO15118-2 implementation of a DC charger",
            interface: "ISO15118_dc_charger"
          },
          main: {
            config: {
              mqtt_base_path: {
                default: "everest_external/iso15118/java",
                description: "Base path for the mqtt communication used by the java process",
                type: "string"
              }
            },
            description: "This module implements a proxy to the RISE-V2G ISO15118-2 implementation in java",
            interface: "empty"
          }
        },
        requires: {
          slac: {
            interface: "ISO15118_3_SLAC",
            min_connections: 0
          }
        }
      },
      JsTibber: {
        description: "This modules fetches data from the Tibber Price Energy Forecast API and publishes it.",
        enable_external_mqtt: false,
        metadata: {
          authors: ["Andreas Heinrich", "Leonardo Oliveira", "Cornelius Claussen"],
          license: "https://opensource.org/licenses/Apache-2.0"
        },
        provides: {
          main: {
            config: {
              additional_cost_per_kwh: {
                description: "Constant to add to the reported price. Usually 0.",
                type: "number"
              },
              api_key: {
                description: "API key from Tibber developer account",
                type: "string"
              },
              update_interval: {
                description: "Update interval in minutes. Typically 60 or so.",
                type: "integer"
              }
            },
            description: "This interface is responsible for providing the price forecast data from Tibber",
            interface: "energy_price_information"
          }
        }
      },
      JsYetiSimulator: {
        description: "SIL simulator for YETI hardware v1.0",
        enable_external_mqtt: true,
        metadata: {
          authors: ["Cornelius Claussen"],
          license: "https://opensource.org/licenses/Apache-2.0"
        },
        provides: {
          board_support: {
            description: "provides the board support Interface to low level control control pilot, relais, rcd, motor lock",
            interface: "board_support_AC"
          },
          debug_keepalive: {
            description: "Provides the keepalive as a json object",
            interface: "debug_json"
          },
          debug_powermeter: {
            description: "Provides the powermeter as a json object",
            interface: "debug_json"
          },
          debug_state: {
            description: "Provides the state as a json object",
            interface: "debug_json"
          },
          debug_yeti: {
            description: "provides the debug information of the charging driver",
            interface: "debug_json"
          },
          powermeter: {
            description: "provides the Yeti Internal Power Meter",
            interface: "powermeter"
          },
          yeti_extras: {
            description: "extra functionality special for Yeti",
            interface: "yeti_extras"
          },
          yeti_simulation_control: {
            description: "Interface for the Yeti HIL simulator",
            interface: "yeti_simulation_control"
          }
        }
      },
      ModbusMeter: {
        description: "Module that collects power and energy measurements from a MODBUS device",
        enable_external_mqtt: true,
        metadata: {
          authors: ["Andreas Heinrich", "Leonardo Fernandes"],
          license: "https://opensource.org/licenses/Apache-2.0"
        },
        provides: {
          main: {
            config: {
              energy_in_length: {
                description: "Amount of modbus registers uint16 = 1, uint32 = 2, uint64 = 4",
                enum: [2],
                type: "integer"
              },
              energy_in_register: {
                description: "Modbus register for energy in Watthours imported",
                minimum: 0,
                type: "integer"
              },
              energy_out_length: {
                description: "Amount of modbus registers uint16 = 1, uint32 = 2, uint64 = 4",
                enum: [2],
                type: "integer"
              },
              energy_out_register: {
                description: "Modbus register for energy in Watthours imported",
                minimum: 0,
                type: "integer"
              },
              energy_unit_id: {
                description: "Modbus unit_id, mostly 1",
                maximum: 255,
                minimum: 1,
                type: "integer"
              },
              modbus_ip_address: {
                description: "The ip address which should be used to get the modbus values",
                pattern: "^(?:[0-9]{1,3}.){3}[0-9]{1,3}$",
                type: "string"
              },
              modbus_port: {
                description: "The port which should be used to get the modbus values",
                minimum: 0,
                type: "integer"
              },
              power_in_length: {
                description: "Amount of modbus registers uint16 = 1, uint32 = 2, uint64 = 4",
                enum: [2],
                type: "integer"
              },
              power_in_register: {
                description: "Modbus register for power in Watts imported",
                minimum: 0,
                type: "integer"
              },
              power_out_length: {
                description: "Amount of modbus registers uint16 = 1, uint32 = 2, uint64 = 4",
                enum: [2],
                type: "integer"
              },
              power_out_register: {
                description: "Modbus register for power in Watts exported",
                minimum: 0,
                type: "integer"
              },
              power_unit_id: {
                description: "Modbus unit_id, mostly 1",
                maximum: 255,
                minimum: 1,
                type: "integer"
              },
              update_interval: {
                description: "Update interval in milliseconds.",
                minimum: 0,
                type: "integer"
              }
            },
            description: "This is the main unit of the module",
            interface: "powermeter"
          }
        }
      },
      OCPP: {
        config: {
          ChargePointConfigPath: {
            default: "charge_point_config.json",
            description: "Path to the configuration file",
            type: "string"
          },
          DatabasePath: {
            default: "/tmp/ocpp_1_6_charge_point",
            description: "Path to the persistent SQLite database folder",
            type: "string"
          },
          SchemasPath: {
            default: "/tmp/ocpp_1_6_charge_point",
            description: "Path to the schemas folder in which the OCPP 1.6 schemas reside",
            type: "string"
          }
        },
        description: "A OCPP charge point / charging station module, currently targeting OCPP-J 1.6",
        enable_external_mqtt: true,
        metadata: {
          authors: ["Kai-Uwe Hermann"],
          license: "https://opensource.org/licenses/Apache-2.0"
        },
        provides: {
          auth_validator: {
            description: "Validates the provided auth token with OCPP",
            interface: "auth_token_validator"
          },
          main: {
            description: "This is a OCPP 1.6 charge point",
            interface: "ocpp_1_6_charge_point"
          }
        },
        requires: {
          evse_manager: {
            interface: "evse_manager",
            max_connections: 128,
            min_connections: 1
          }
        }
      },
      PersistentStore: {
        config: {
          sqlite_db_file_path: {
            default: "everest_persistent_store.db",
            description: "Path to the SQLite db file.",
            type: "string"
          }
        },
        description: "Simple implementation of a SQLite backed persistent key-value store",
        metadata: {
          authors: ["Kai-Uwe Hermann"],
          license: "https://opensource.org/licenses/Apache-2.0"
        },
        provides: {
          main: {
            description: "This implements a persistent key-value store",
            interface: "kvs"
          }
        }
      },
      Store: {
        description: "Simple implementation of a memory-backed key-value store",
        metadata: {
          authors: ["Kai-Uwe Hermann", "Thilo Molitor"],
          license: "https://opensource.org/licenses/Apache-2.0"
        },
        provides: {
          main: {
            description: "This implements a key-value store",
            interface: "kvs"
          }
        }
      },
      SunspecReader: {
        description: "Module that collects measurements from a Sunspec-conformant device, given a string formatted input query.",
        enable_external_mqtt: true,
        metadata: {
          authors: ["Andreas Heinrich", "Leonardo Fernandes"],
          license: "https://opensource.org/licenses/Apache-2.0"
        },
        provides: {
          main: {
            config: {
              ip_address: {
                description: "IP address of device to be read.",
                pattern: "^\\b(?:(?:2(?:[0-4][0-9]|5[0-5])|[0-1]?[0-9]?[0-9])\\.){3}(?:(?:2([0-4][0-9]|5[0-5])|[0-1]?[0-9]?[0-9]))\\b$",
                type: "string"
              },
              port: {
                description: "TCP port number.",
                minimum: 0,
                type: "integer"
              },
              query: {
                description: "Query string in the predefined format.",
                pattern: "^<[0-9]+>::<[a-zA-Z]+>::<[a-zA-Z]+>$",
                type: "string"
              },
              read_interval: {
                description: "Polling interval for read (in milliseconds).",
                type: "integer"
              },
              unit: {
                description: "MODBUS unit ID.",
                minimum: 0,
                type: "integer"
              }
            },
            description: "This is the main unit of the module",
            interface: "sunspec_reader"
          }
        }
      },
      SunspecScanner: {
        description: "Module to implement a scan for Sunspec compliant devices",
        enable_external_mqtt: true,
        metadata: {
          authors: ["Andreas Heinrich", "Leonardo Fernandes"],
          license: "https://opensource.org/licenses/Apache-2.0"
        },
        provides: {
          main: {
            description: "This is the main unit of the module",
            interface: "sunspec_scanner"
          }
        }
      },
      TestUser: {
        description: "This implements a simple power regulator module publishing the max_current for the charger being the minimum of the incomng max_current values received from power_in and (optionally solar modules)",
        metadata: {
          authors: ["Nobody"],
          license: "https://opensource.org/licenses/Apache-2.0"
        },
        provides: {
          fool: {
            description: "nothing",
            interface: "empty"
          }
        },
        requires: {
          test_intf: {
            interface: "TestIntf"
          }
        }
      },
      TestX: {
        description: "This implements a simple power regulator module publishing the max_current for the charger being the minimum of the incomng max_current values received from power_in and (optionally solar modules)",
        metadata: {
          authors: ["Nobody"],
          license: "https://opensource.org/licenses/Apache-2.0"
        },
        provides: {
          main: {
            description: "This implements the main logic of the module Power",
            interface: "TestIntf"
          }
        }
      },
      YetiDriver: {
        config: {
          baud_rate: {
            default: 115200,
            description: "Serial baud rate to use when communicating with Yeti hardware",
            maximum: 230400,
            minimum: 9600,
            type: "integer"
          },
          control_mode: {
            default: "low",
            description: "none, high or low",
            enum: ["none", "high", "low"],
            type: "string"
          },
          serial_port: {
            default: "/dev/ttyUSB0",
            description: "Serial port the Yeti hardware is connected to",
            type: "string"
          }
        },
        description: "Driver module for the YETI hardware v1.0",
        enable_external_mqtt: true,
        metadata: {
          authors: ["Cornelius Claussen", "Kai-Uwe Hermann", "Thilo Molitor", "Anton Woellert"],
          license: "https://opensource.org/licenses/Apache-2.0"
        },
        provides: {
          board_support: {
            description: "provides the board support Interface to low level control control pilot, relais, rcd, motor lock",
            interface: "board_support_AC"
          },
          debug_keepalive: {
            description: "Provides the keepalive as a json object",
            interface: "debug_json"
          },
          debug_powermeter: {
            description: "Provides the powermeter as a json object",
            interface: "debug_json"
          },
          debug_state: {
            description: "Provides the state as a json object",
            interface: "debug_json"
          },
          debug_yeti: {
            description: "provides the debug information of the charging driver",
            interface: "debug_json"
          },
          powermeter: {
            description: "provides the Yeti Internal Power Meter",
            interface: "powermeter"
          },
          yeti_extras: {
            description: "extra functionality special for Yeti",
            interface: "yeti_extras"
          },
          yeti_simulation_control: {
            description: "Interface for the Yeti HIL simulator",
            interface: "yeti_simulation_control"
          }
        }
      }
    };
    const SampleInterfaceList = {
      ISO15118_ac_charger: {
        cmds: {
          set_max_current: {
            arguments: {
              max_current: {
                description: "EVSE maximum current in ampere",
                maximum: 4e3,
                minimum: 0,
                type: "number"
              }
            },
            description: "Sets the maximum current of EVSE"
          },
          set_nominal_voltage: {
            arguments: {
              voltage: {
                description: "Nominal voltage in volt",
                maximum: 1e4,
                minimum: 0,
                type: "number"
              }
            },
            description: "Sets nominal voltage of the EVSE"
          },
          set_rcd: {
            arguments: {
              rcd_err: {
                description: "True if the RCD has detected an error.",
                type: "boolean"
              }
            },
            description: "Sets the status of the Residual Current Device (RCD). If rcd_err is equal to true, the RCD has detected an error."
          }
        },
        description: "This interface defines an ISO15118 AC Charger",
        parent: "ISO15118_charger",
        vars: {
          e_amount: {
            description: "Amount of energy (unit: Wh) reflecting the EV's estimate how much energy is needed to fulfill the user configured charging goal for the current charging session. This might include energy for other purposes than solely charging the HV battery of an EV.",
            maximum: 2e5,
            minimum: 0,
            type: "number"
          },
          ev_max_current: {
            description: "Maximum current (unit: A) supported by the EV per phase.",
            maximum: 4e3,
            minimum: 0,
            type: "number"
          },
          ev_max_voltage: {
            description: "The RMS of the maximal nominal voltage (unit: V) the vehicle can accept, measured between one phase and neutral.",
            maximum: 1e4,
            minimum: 0,
            type: "number"
          },
          ev_min_current: {
            description: "EVMinCurrent (unit: A) is used to indicate to the SECC that charging below this minimum is not energy/cost efficient for the EV. It is recommended that the SECC considers this value during the target setting process (e.g. sale tariff table should account for this value).",
            maximum: 4e3,
            minimum: 0,
            type: "number"
          }
        }
      },
      ISO15118_charger: {
        cmds: {
          set_evse_notification: {
            arguments: {
              max_delay: {
                description: "Indicates the time in seconds until it expects the EVCC to react on the action request indicated in the coresponding EVSENotification",
                type: "integer"
              },
              notification: {
                description: "EVSE notification",
                enum: ["None", "StopCharging", "ReNegotiation"],
                type: "string"
              }
            },
            description: "Sets a notification value used by the SECC to influence the behaviour of the EVCC. The EVSENotification contains an action that the SECC wants the EVCC to perform"
          },
          set_evseid: {
            arguments: {
              id: {
                description: "EVSE ID",
                pattern: "^[A-Z]{2}\\*[A-Z0-9]{3}\\*E[A-Z0-9][A-Z0-9\\*]{30}$",
                type: "string"
              }
            },
            description: "Sets the ID that uniquely identifies the EVSE. The EVSEID shall match the following structure: <EVSEID> = <Country Code> <S> <EVSE Operator ID> <S> <ID Type> <Power Outlet ID>"
          },
          set_meter_reading: {
            arguments: {
              id: {
                description: "Meter ID",
                pattern: "/^[A-Za-z0-9]{1,32}$/",
                type: "string"
              },
              timestamp: {
                description: "Timestamp (unix epoch time)",
                type: "integer"
              },
              value: {
                description: "Current meter reading",
                type: "number"
              }
            },
            description: "Sets the current meter reading in Watthours from the EVSE."
          },
          set_receipt_required: {
            arguments: {
              receipt_required: {
                description: "Receipt required",
                type: "boolean"
              }
            },
            description: "Optional: Indicate that the EVCC is required to send a MeteringReceiptReq message for the purpose of signing the meter info record. If ReceiptRequired is equal to True, the EVCC is required to send a MeteringReceiptReq message including the signature."
          }
        },
        description: "This base interface defines an abstract ISO15118 Charger",
        vars: {
          MISSING_charge_progress: {
            description: "This message element is used to request the EVSE to fulfill all conditions that the energy transfer can start as soon as the EV onboard system begins to retrieve energy. If ChargeProgress is equal to Start the EVSE is requested to prepare the energy flow for an immediate start, if ChargeProgress is equal to Stop the EVSE is requested to stop the energy flow, if ChargeProgress is equal to Renegotiate the energy flow is neither stopped nor started, instead the renegotiation mechanisms defined in this standard apply.",
            enum: ["Start", "Stop", "Renegotiate"],
            type: "string"
          },
          MISSING_emaid: {
            description: "The e-Mobility Account Identifier (EMAID) identifies the charging contract.",
            pattern: "^[A-Za-z]{2}\\*[A-Za-z0-9]{3}\\*[A-Za-z0-9]{9}\\*[A-Za-z0-9]{0,1}$",
            type: "string"
          },
          MISSING_evccid: {
            description: "Contains the MAC adress of the EVCC in a human readable format (six hexadecimal encoded bytes)",
            pattern: "^[A-Fa-f0-9]{2}(:[A-Fa-f0-9]{2}){5}$",
            type: "string"
          },
          MISSING_selected_service: {
            description: "Used for indicating a service selected by the EVCC",
            type: "object"
          },
          departure_time: {
            description: "Optional: Is used to indicate when the vehicle intends to finish the charging process. Format: hh:mm:ss",
            type: "integer"
          },
          requested_energy_tranfer_mode: {
            description: "Energy transfer mode requested by the EVCC.",
            enum: ["AC_single_phase_core", "AC_three_phase_core", "DC_core", "DC_extended", "DC_combo_core", "DC_unique"],
            type: "string"
          },
          selected_payment_option: {
            description: "Used for indicating the selected payment type for services invoked by the EVCC",
            enum: ["Contract", "ExternalPayment"],
            type: "string"
          }
        }
      },
      ISO15118_dc_charger: {
        cmds: {
          MISSING_set_evse_current_regulation_tolerance: {
            arguments: {
              current: {
                description: "Current in Ampere",
                maximum: 400,
                minimum: 0,
                type: "number"
              }
            },
            description: "Optional: Sets the absolute magnitude of the current regulation tolerance of the EVSE"
          },
          MISSING_set_evse_energy_to_be_delivered: {
            arguments: {
              energy: {
                description: "Energy in Watthours",
                maximum: 2e5,
                minimum: 0,
                type: "number"
              }
            },
            description: "Optional: Amount of energy to be delivered by the EVSE."
          },
          set_evse_current_limit_achieved: {
            arguments: {
              current_limit_achieved: {
                description: "True, if the EVSE has reached its current limit, false otherwise",
                type: "boolean"
              }
            },
            description: "Sets the EVSECurrentLimitAchieved flag that indicates whether the EVSE has reached its current limit."
          },
          set_evse_maximum_current_limit: {
            arguments: {
              max_current: {
                description: "Maximum current in Ampere",
                maximum: 400,
                minimum: 0,
                type: "number"
              }
            },
            description: "Optional: Sets the maximum current the EVSE can deliver."
          },
          set_evse_maximum_power_limit: {
            arguments: {
              max_power: {
                description: "Maximum power in Watt",
                maximum: 2e5,
                minimum: 0,
                type: "number"
              }
            },
            description: "Optional: Sets the maximum power the EVSE can deliver."
          },
          set_evse_maximum_voltage_limit: {
            arguments: {
              max_voltage: {
                description: "Maximum voltage in Volt",
                maximum: 1e3,
                minimum: 0,
                type: "number"
              }
            },
            description: "Optional: Sets the maximum voltage the EVSE can deliver."
          },
          set_evse_minimum_current_limit: {
            arguments: {
              min_current: {
                description: "Minimum current in Ampere",
                maximum: 400,
                minimum: 0,
                type: "number"
              }
            },
            description: "Sets the minimum current the EVSE can deliver with the expected accuracy."
          },
          set_evse_minimum_voltage_limit: {
            arguments: {
              min_voltage: {
                description: "Minimum voltage in Volt",
                maximum: 1e3,
                minimum: 0,
                type: "number"
              }
            },
            description: "Sets the minimum voltage the EVSE can deliver with the expected accuracy"
          },
          set_evse_peak_current_ripple: {
            arguments: {
              current: {
                description: "Current in Ampere",
                maximum: 400,
                minimum: 0,
                type: "number"
              }
            },
            description: "Peak-to-peak magnitude of the current ripple of the EVSE"
          },
          set_evse_power_limit_achieved: {
            arguments: {
              power_limit_achieved: {
                description: "True, if the EVSE has reached its power limit, false otherwise",
                type: "boolean"
              }
            },
            description: "Sets the EVSEPowerLimitAchieved flag that indicates whether the EVSE has reached its power limit."
          },
          set_evse_present_current: {
            arguments: {
              current: {
                description: "Output current in Ampere",
                maximum: 400,
                minimum: 0,
                type: "number"
              }
            },
            description: "Sets the output current of the EVSE"
          },
          set_evse_present_voltage: {
            arguments: {
              voltage: {
                description: "Output voltage in Volt",
                maximum: 1e3,
                minimum: 0,
                type: "number"
              }
            },
            description: "Sets the output voltage of the EVSE."
          },
          set_evse_voltage_limit_achieved: {
            arguments: {
              voltage_limit_achieved: {
                description: "True, if the EVSE has reached its voltage limit, false otherwise",
                type: "boolean"
              }
            },
            description: "Sets the EVSEVoltageLimitAchieved flag that indicates whether the EVSE has reached its voltage limit."
          }
        },
        description: "This interface defines an ISO15118 DC Charger",
        parent: "ISO15118_charger",
        vars: {
          MISSING_bulk_charging_complete: {
            description: "If set to true, the EV indicates that bulk charge (approx. 80% SOC) is complete.",
            type: "boolean"
          },
          MISSING_charging_complete: {
            description: "If set to true, the EV indicates that full charge (100% SOC)is complete.",
            type: "boolean"
          },
          MISSING_ev_dc_error_code: {
            description: "Indicates the EV internal status.",
            enum: [
              "NO_ERROR",
              "FAILED_RESSTemperatureInhibit",
              "FAILED_EV_ShiftPosition",
              "FAILED_ChargerConnerctorLockFault",
              "FAILED_EVRESSMalfunction",
              "FAILED_ChargingCurrentdifferential",
              "FAILED_ChargingVoltageOutOfRange",
              "Reserved A-C",
              "FAILED_ChargingSystemIncompatibility",
              "NoData"
            ],
            type: "string"
          },
          MISSING_ev_ready_for_charging: {
            description: "If set to TRUE, the EV is ready to charge.",
            type: "boolean"
          },
          MISSING_ev_soc: {
            description: "State of charge (soc) of the EV's battery.",
            maximum: 100,
            minimum: 0,
            type: "integer"
          },
          dc_evse_status: {
            description: "Current status of the EVSE",
            type: "object"
          },
          ev_energy_capacity: {
            description: "Optional: Energy capacity (unit: Wh) of the EV",
            maximum: 2e5,
            minimum: 0,
            type: "number"
          },
          ev_energy_request: {
            description: "Optional: Amount of energy (unit: Wh) the EV requests from the EVSE",
            maximum: 2e5,
            minimum: 0,
            type: "number"
          },
          ev_maximum_current_limit: {
            description: "Maximum EV current (unit: A) limit",
            maximum: 400,
            minimum: 0,
            type: "number"
          },
          ev_maximum_power_limit: {
            description: "Maximum EV power (unit: W) limit",
            maximum: 2e5,
            minimum: 0,
            type: "number"
          },
          ev_maximum_voltage_limit: {
            description: "Maximum EV voltage (unit: V) limit",
            maximum: 1e3,
            minimum: 0,
            type: "number"
          },
          ev_target_current: {
            description: "Instantaneous current (unit: A) requested by the EV",
            maximum: 400,
            minimum: 0,
            type: "number"
          },
          ev_target_voltage: {
            description: "Target voltage (unit: V) requested by the EV",
            maximum: 1e3,
            minimum: 0,
            type: "number"
          },
          remaining_time_to_bulk_soc: {
            description: "Optional: Estimated or calculated time (unit: s) until bulk charge (80% SOC) is complete.",
            maximum: 172800,
            minimum: 0,
            type: "integer"
          },
          remaining_time_to_full_soc: {
            description: "Optional: Estimated or calculated time (unit: s) until full charge (100% SOC) is complete.",
            maximum: 172800,
            minimum: 0,
            type: "integer"
          }
        }
      },
      auth: {
        cmds: {
          get_authorization: {
            description: "This returns a validated auth token or null if none could be validated. If a validated token is returned, ownership is transferred to the caller and it is removed from this module.",
            result: {
              description: "The auth token that can be used for signing etc. This will return null if no token could be validated.",
              maxLength: 20,
              minLength: 1,
              type: ["null", "string"]
            }
          }
        },
        description: "Interface of authentication framework",
        vars: {
          authorization_available: {
            description: "True: Validated auth token available, use get_authorization to consume it. False: no token available.",
            type: "boolean"
          }
        }
      },
      auth_token_provider: {
        description: "Provide some authentication token",
        vars: {
          token: {
            additionalProperties: false,
            description: "Arbitrary auth token string and type of token provider (string provided in UI)",
            properties: {
              timeout: {
                description: "Time (in s) the token can be considered valid by the auth framework",
                maximum: 120,
                minimum: 1,
                type: "number"
              },
              token: {
                description: "Arbitrary token string: this has to be printable case insensitive ascii: !!!FIXME!!! write a regex to allow only printable ascii",
                maxLength: 20,
                minLength: 1,
                type: "string"
              },
              type: {
                description: "Type of token provider",
                maxLength: 32,
                minLength: 2,
                type: "string"
              }
            },
            required: ["token", "type"],
            type: "object"
          }
        }
      },
      auth_token_validator: {
        cmds: {
          validate_token: {
            arguments: {
              token: {
                description: "Arbitrary token string: this has to be printable case insensitive ascii: !!!FIXME!!! write a regex to allow only printable ascii",
                maxLength: 20,
                minLength: 1,
                type: "string"
              }
            },
            description: "Validate auth token and return result (with optional reason string)",
            result: {
              additionalProperties: false,
              description: "Result object containing validation result enum value (key: result) and optional reason string (key: reason)",
              properties: {
                reason: {
                  minLength: 5,
                  type: "string"
                },
                result: {
                  enum: ["Accepted", "Blocked", "Expired", "Invalid"],
                  type: "string"
                }
              },
              required: ["result"],
              type: "object"
            }
          }
        },
        description: "Checks provided tokens for validity"
      },
      board_support_AC: {
        cmds: {
          allow_power_on: {
            arguments: {
              value: {
                description: "True: allow power on, false: do not allow power on.",
                type: "boolean"
              }
            },
            description: "Sets allow_power_on flag. If false, Relais must never be switched on."
          },
          enable: {
            arguments: {
              value: {
                description: "True: enabled, false: disabled.",
                type: "boolean"
              }
            },
            description: "Enables or disables the EVSE. Typically disabled results in control pilot state F. It must not accept cars for new charging sessions if disabled."
          },
          force_unlock: {
            description: "Force unlock motor lock",
            result: {
              description: "Returns true if unlocking sequence was successfully executed",
              type: "boolean"
            }
          },
          get_hw_capabilities: {
            description: "Get Hardware capability/limits",
            result: {
              description: "Hardware capability/limits",
              max_current_A: {
                description: "Maximum current (ampere) the hardware can handle",
                type: "number"
              },
              max_phase_count: {
                description: "Max nr of phases the hardware can use",
                maximum: 3,
                minimum: 1,
                type: "integer"
              },
              min_current_A: {
                description: "Minimum current (ampere) the hardware can use to charge. Values below may be set but may result in pause instead.",
                type: "number"
              },
              min_phase_count: {
                description: "Minimum nr of phases the hardware can use",
                maximum: 3,
                minimum: 1,
                type: "integer"
              },
              supports_changing_phases_during_charging: {
                description: "Indicates whether changing number of phases is supported during charging (true) or not (false)",
                type: "boolean"
              },
              type: "object"
            }
          },
          pwm_F: {
            description: "Turns PWM off with Error F (constant negative voltage)"
          },
          pwm_off: {
            description: "Turns PWM off (constant high voltage)"
          },
          pwm_on: {
            arguments: {
              value: {
                description: "PWM duty cycle (>0, <1)",
                maximum: 1,
                minimum: 0,
                type: "number"
              }
            },
            description: "Turns PWM on with duty cycle"
          },
          setup: {
            arguments: {
              country_code: {
                description: "A two-letter country code in ISO 3166-1 alpha-2 format",
                type: "string"
              },
              has_ventilation: {
                description: "true: Allow mode D charging, false: do not allow mode D charging",
                type: "boolean"
              },
              rcd_enabled: {
                description: "true: enable RCD, false: disable RCD",
                type: "boolean"
              },
              three_phases: {
                description: "true: Three phases enabled, false: only single phase",
                type: "boolean"
              }
            },
            description: "Setup config options"
          },
          switch_three_phases_while_charging: {
            arguments: {
              value: {
                description: "True: switch to 3ph, False: switch to 1ph",
                type: "boolean"
              }
            },
            description: "Special command to force switching between one and three phases while charging is active. HW must go through some special sequence to ensure safe operation."
          }
        },
        description: "This interface defines the board support driver for AC power path: ControlPilot, Relais, RCD and motor lock",
        vars: {
          event: {
            description: "Event from ControlPilot signal/Relais/RCD",
            enum: [
              "CarPluggedIn",
              "CarRequestedPower",
              "PowerOn",
              "PowerOff",
              "CarRequestedStopPower",
              "CarUnplugged",
              "ErrorE",
              "ErrorDF",
              "ErrorRelais",
              "ErrorRCD",
              "ErrorVentilationNotAvailable",
              "ErrorOverCurrent",
              "RestartMatching",
              "PermanentFault"
            ],
            type: "string"
          },
          nr_of_phases_available: {
            description: "Instantaneous phase count available to car",
            maximum: 3,
            minimum: 1,
            type: "integer"
          },
          telemetry: {
            additionalProperties: false,
            description: "Other telemetry",
            properties: {
              fan_rpm: {
                description: "RPM of the fan. 0 if off or no fan available.",
                type: "number"
              },
              rcd_current: {
                description: "Residual current in mA",
                type: "number"
              },
              relais_on: {
                description: "true if power to the car is currently on, false if off",
                type: "boolean"
              },
              supply_voltage_12V: {
                description: "Internal 12V supply voltage",
                type: "number"
              },
              supply_voltage_minus_12V: {
                description: "Internal -12V supply voltage",
                type: "number"
              },
              temperature: {
                description: "Current temperature of the EVSE in degree celsius",
                type: "number"
              }
            },
            type: "object"
          }
        }
      },
      board_support_AC_debug: {
        description: "This interface defines the board support debug information that is not used for actual control",
        vars: {
          cp_hi_voltage: {
            description: "Voltage of high part of PWM",
            type: "number"
          },
          cp_lo_voltage: {
            description: "Voltage of low part of PWM",
            type: "number"
          },
          has_ventilation: {
            description: "True if ventilated charging is allowed",
            type: "boolean"
          },
          is_power_on: {
            description: "True if Relais are currently closed (power on)",
            type: "boolean"
          },
          pwm_running: {
            description: "True if ventilated charging is allowed",
            type: "boolean"
          },
          rcd_current: {
            description: "Residual current measurement",
            type: "number"
          },
          rcd_reclosing_allowed: {
            description: "True if RCD may reclose after fault according to local regulations",
            type: "boolean"
          },
          simplified_mode: {
            description: "True if car uses simplified mode of IEC61851",
            type: "boolean"
          },
          supply_12V_voltage: {
            description: "Voltage of +12V supply",
            type: "number"
          },
          supply_N12V_voltage: {
            description: "Voltage of -12V supply",
            type: "number"
          },
          three_phases: {
            description: "config option for three phase/single phase operation",
            type: "boolean"
          },
          three_phases_active: {
            description: "True if three phases is enabled for current charging session",
            type: "boolean"
          }
        }
      },
      car_simulator: {
        cmds: {
          enable: {
            arguments: {
              value: {
                description: "Enable/Disable simulation mode",
                type: "boolean"
              }
            },
            description: "Sets the ID that uniquely identifies the EVSE. The EVSEID shall match the following structure: <EVSEID> = <Country Code> <S> <EVSE Operator ID> <S> <ID Type> <Power Outlet ID>"
          },
          executeChargingSession: {
            arguments: {
              value: {
                description: "Charging simulation string",
                type: "string"
              }
            },
            description: "Executes a charging simulation string"
          }
        },
        description: "This defines a car simulator that can execute a full charging session, from plugging in to plugging out. It uses HIL or SIL simulation controllers from e.g. the Yeti HIL simulator.",
        vars: {
          enabled: {
            description: "Indicates whether simulation is currently enabled or not",
            type: "boolean"
          }
        }
      },
      debug_json: {
        description: "This interface defines a generic JSON object debug variable publisher for use in any module. Can be used to display debug variables e.g. in web interface.",
        vars: {
          debug_json: {
            description: "Provides the debug object as a json object",
            type: "object"
          },
          title: {
            description: "Title of the Debug object",
            type: "string"
          }
        }
      },
      dummy: {
        description: "Dummy interface for testing",
        vars: {
          token: {
            additionalProperties: false,
            description: "Arbitrary auth token string and type of token provider (string provided in UI)",
            properties: {
              heart: {
                description: "Type of token provider",
                maxLength: 32,
                minLength: 2,
                type: "string"
              },
              token: {
                description: "Arbitrary token string: this has to be printable case insensitive ascii: !!!FIXME!!! write a regex to allow only printable ascii",
                maxLength: 20,
                minLength: 1,
                type: "string"
              }
            },
            required: ["token", "heart"],
            type: "object"
          }
        }
      },
      empty: {
        description: "This interface is empty and can be used for a config-only (main) implementation"
      },
      energy: {
        cmds: {
          enforce_limits: {
            arguments: {
              limits_export: {
                additionalProperties: false,
                description: "Enforced limits that must be respected.",
                properties: {
                  limit: {
                    ac_current_A: {
                      additionalProperties: false,
                      description: "AC current limit object",
                      properties: {
                        current_A: {
                          description: "AC current limit per phase in Ampere",
                          maximum: 0,
                          type: "number"
                        },
                        phase_count: {
                          description: "Limit to number of phases. Omit if number of phases are not limited.",
                          maximum: 3,
                          minimum: 1,
                          type: "integer"
                        }
                      },
                      required: ["current_A"],
                      type: "object"
                    },
                    description: "Enforced limits",
                    total_power_W: {
                      description: "Total power limit in Watt. Can be used for DC or as additional limit for AC.",
                      maximum: 0,
                      type: "number"
                    },
                    type: "object"
                  },
                  valid_until: {
                    description: "Limits are valid until this timepoint in RFC3339 UTC. If no new update is received, power consumption must be stopped afer that timepoint.",
                    format: "date-time",
                    type: "string"
                  }
                },
                type: "object"
              },
              limits_import: {
                additionalProperties: false,
                description: "Enforced limits that must be respected.",
                properties: {
                  limit: {
                    ac_current_A: {
                      additionalProperties: false,
                      description: "AC current limit object",
                      properties: {
                        current_A: {
                          description: "AC current limit per phase in Ampere",
                          minimum: 0,
                          type: "number"
                        },
                        phase_count: {
                          description: "Limit to number of phases. Omit if number of phases are not limited.",
                          maximum: 3,
                          minimum: 1,
                          type: "integer"
                        }
                      },
                      required: ["current_A"],
                      type: "object"
                    },
                    description: "Enforced limits",
                    total_power_W: {
                      description: "Total power limit in Watt. Can be used for DC or as additional limit for AC.",
                      minimum: 0,
                      type: "number"
                    },
                    type: "object"
                  },
                  valid_until: {
                    description: "Limits are valid until this timepoint in RFC3339 UTC. If no new update is received, power consumption must be stopped afer that timepoint.",
                    format: "date-time",
                    type: "string"
                  }
                },
                type: "object"
              },
              schedule_export: {
                description: "Informative only. Do not use for actual limiting. Energy export/limits time series. The first entry is special as it will be active already now even if the timestamp is in the future, so it is good practice to set the first entry to current time. The time series can have arbitrary time difference between entries and all timestamps are absolute UTC time.",
                items: {
                  additionalProperties: false,
                  description: "One entry for the time series",
                  properties: {
                    limit: {
                      ac_current_A: {
                        additionalProperties: false,
                        description: "AC current limit object",
                        properties: {
                          current_A: {
                            description: "AC current limit per phase in Ampere",
                            maximum: 0,
                            type: "number"
                          },
                          phase_count: {
                            description: "Limit to number of phases. Omit if number of phases are not limited.",
                            maximum: 3,
                            minimum: 1,
                            type: "integer"
                          }
                        },
                        required: ["current_A"],
                        type: "object"
                      },
                      description: "Limit for this timestamp",
                      required: ["limit_type"],
                      total_power_W: {
                        description: "Total power limit in Watt. Can be used for DC or as additional limit for AC.",
                        maximum: 0,
                        type: "number"
                      },
                      type: "object"
                    },
                    timestamp: {
                      description: "Absolute timestamp for this sample in RFC3339 UTC format https://datatracker.ietf.org/doc/html/rfc3339#section-5.6",
                      format: "date-time",
                      type: "string"
                    }
                  },
                  required: ["timestamp", "limit"],
                  type: "object"
                },
                type: "array"
              },
              schedule_import: {
                description: "Informative only. Do not use for actual limiting. Energy import/limits time series. The first entry is special as it will be active already now even if the timestamp is in the future, so it is good practice to set the first entry to current time. The time series can have arbitrary time difference between entries and all timestamps are absolute UTC time.",
                items: {
                  additionalProperties: false,
                  description: "One entry for the time series",
                  properties: {
                    limit: {
                      ac_current_A: {
                        additionalProperties: false,
                        description: "AC current limit object",
                        properties: {
                          current_A: {
                            description: "AC current limit per phase in Ampere",
                            minimum: 0,
                            type: "number"
                          },
                          phase_count: {
                            description: "Limit to number of phases. Omit if number of phases are not limited.",
                            maximum: 3,
                            minimum: 1,
                            type: "integer"
                          }
                        },
                        required: ["current_A"],
                        type: "object"
                      },
                      description: "Limit for this timestamp",
                      required: ["limit_type"],
                      total_power_W: {
                        description: "Total power limit in Watt. Can be used for DC or as additional limit for AC.",
                        minimum: 0,
                        type: "number"
                      },
                      type: "object"
                    },
                    timestamp: {
                      description: "Absolute timestamp for this sample in RFC3339 UTC format https://datatracker.ietf.org/doc/html/rfc3339#section-5.6",
                      format: "date-time",
                      type: "string"
                    }
                  },
                  required: ["timestamp", "limit"],
                  type: "object"
                },
                type: "array"
              },
              uuid: {
                description: "UUID of node that this limit applies to",
                type: "string"
              }
            },
            description: "The EnergyManager enforces a limit using this command."
          }
        },
        description: "This interface defines a forecast schedule of energy import/export capability/limits, pricing and current energy usage.",
        vars: {
          energy: {
            description: "Energy object to supply/limit energy import (direction from grid to car) and/or consume/limit energy export (car to grid).",
            properties: {
              children: {
                description: "Array of child nodes (in the direction to consumer/car",
                type: "array"
              },
              energy_usage: {
                description: "Energy usage of this node (powermeter struct)",
                type: "object"
              },
              node_type: {
                description: "Type of energy source/sink. Use Limit if this purely enforces limits but is not a physical energy source/sink.",
                enum: ["Grid", "GridConnection", "Solar", "Battery", "Fuse", "Evse"],
                type: "string"
              },
              optimizer_target: {
                additionalProperties: false,
                description: "User defined optimizer targets for this evse",
                properties: {
                  car_battery_soc: {
                    description: "Car battery State Of Charge in percent",
                    type: "number"
                  },
                  charge_to_max_percent: {
                    description: "Charge car battery to max NN percent",
                    type: "number"
                  },
                  energy_amount_needed: {
                    description: "Amount of kwh the car needs to fulfill its charging target",
                    type: "number"
                  },
                  full_autonomy: {
                    description: "Only charge from locally generated energy. Do not draw power from grid for charging.",
                    type: "boolean"
                  },
                  leave_time: {
                    description: "RFC3339 UTC format time when the car needs to drive away with charging targets fullfilled. Will charge cheapest within this timeframe.",
                    type: "string"
                  },
                  price_limit: {
                    description: "Always charge if price below this limit. This includes solar charging and price for solar energy if price levels set correctly.",
                    type: "number"
                  }
                },
                type: "object"
              },
              schedule_export: {
                description: "Energy export/limits time series. The first entry is special as it will be active already now even if the timestamp is in the future, so it is good practice to set the first entry to current time. The time series can have arbitrary time difference between entries and all timestamps are absolute UTC time.",
                items: {
                  additionalProperties: false,
                  description: "One entry for the time series",
                  properties: {
                    limit: {
                      ac_current_A: {
                        additionalProperties: false,
                        description: "AC current limit object",
                        properties: {
                          max_current_A: {
                            description: "Max AC current limit per phase in Ampere",
                            minimum: 0,
                            type: "number"
                          },
                          max_phase_count: {
                            description: "Max Limit of number of phases. Omit if number of phases are not limited.",
                            maximum: 3,
                            minimum: 1,
                            type: "integer"
                          },
                          min_current_A: {
                            description: "Minimal AC current limit per phase in Ampere to be able to discharge",
                            minimum: 0,
                            type: "number"
                          },
                          min_phase_count: {
                            description: "Minimum number of phases that can be used for proper operation.",
                            maximum: 3,
                            minimum: 1,
                            type: "integer"
                          },
                          supports_changing_phases_during_charging: {
                            description: "Indicate whether phase switching is allowed during charging or not",
                            type: "boolean"
                          }
                        },
                        required: ["max_current_A"],
                        type: "object"
                      },
                      description: "Limit for this timestamp",
                      limit_type: {
                        description: "Hard limits need to be enforced by EnergyManager, Soft limits may be ignored.",
                        enum: ["Hard", "Soft"],
                        type: "string"
                      },
                      required: ["limit_type"],
                      total_power_W: {
                        description: "Total power limit in Watt. Can be used for DC or as additional limit for AC.",
                        maximum: 0,
                        type: "number"
                      },
                      type: "object"
                    },
                    price_per_kwh: {
                      additionalProperties: false,
                      description: "Price information for this timepoint",
                      properties: {
                        currency: {
                          description: "Currency in 3 digit ISO 4217",
                          maxLength: 3,
                          minLength: 3,
                          type: "string"
                        },
                        value: {
                          description: "Price per kWh (earning)",
                          type: "number"
                        }
                      },
                      required: ["value", "currency"],
                      type: "object"
                    },
                    timestamp: {
                      description: "Absolute timestamp for this sample in RFC3339 UTC format https://datatracker.ietf.org/doc/html/rfc3339#section-5.6",
                      format: "date-time",
                      type: "string"
                    }
                  },
                  required: ["timestamp", "limit"],
                  type: "object"
                },
                type: "array"
              },
              schedule_import: {
                description: "Energy import/limits time series. The first entry is special as it will be active already now even if the timestamp is in the future, so it is good practice to set the first entry to current time. The time series can have arbitrary time difference between entries and all timestamps are absolute UTC time.",
                items: {
                  additionalProperties: false,
                  description: "One entry for the time series",
                  properties: {
                    capabilities: {
                      ac_current_A: {
                        additionalProperties: false,
                        description: "AC current limit object",
                        properties: {
                          max_current_A: {
                            description: "Max AC current limit per phase in Ampere",
                            minimum: 0,
                            type: "number"
                          },
                          max_phase_count: {
                            description: "Max Limit of number of phases. Omit if number of phases are not limited.",
                            maximum: 3,
                            minimum: 1,
                            type: "integer"
                          },
                          min_current_A: {
                            description: "Minimal AC current limit per phase in Ampere to be able to charge",
                            minimum: 0,
                            type: "number"
                          },
                          min_phase_count: {
                            description: "Minimum number of phases that can be used for proper operation.",
                            maximum: 3,
                            minimum: 1,
                            type: "integer"
                          },
                          supports_changing_phases_during_charging: {
                            description: "Indicate whether phase switching is allowed during charging or not",
                            type: "boolean"
                          }
                        },
                        required: ["max_current_A"],
                        type: "object"
                      },
                      description: "Limit for this timestamp",
                      limit_type: {
                        description: "Hard limits need to be enforced by EnergyManager, Soft limits may be ignored.",
                        enum: ["Hard", "Soft"],
                        type: "string"
                      },
                      required: ["limit_type"],
                      total_power_W: {
                        description: "Total power limit in Watt. Can be used for DC or as additional limit for AC.",
                        minimum: 0,
                        type: "number"
                      },
                      type: "object"
                    },
                    price_per_kwh: {
                      additionalProperties: false,
                      description: "Price information for this timepoint",
                      properties: {
                        currency: {
                          description: "Currency in 3 digit ISO 4217",
                          maxLength: 3,
                          minLength: 3,
                          type: "string"
                        },
                        value: {
                          description: "Price per kWh (cost)",
                          type: "number"
                        }
                      },
                      required: ["value", "currency"],
                      type: "object"
                    },
                    timestamp: {
                      description: "Absolute timestamp for this sample in RFC3339 UTC format https://datatracker.ietf.org/doc/html/rfc3339#section-5.6",
                      format: "date-time",
                      type: "string"
                    }
                  },
                  required: ["timestamp", "capabilities"],
                  type: "object"
                },
                type: "array"
              },
              uuid: {
                description: "UUID for this node. This UUID will be used again when enforce_limits() command propagates through the tree.",
                type: "string"
              }
            },
            required: ["node_type", "uuid"],
            type: "object"
          }
        }
      },
      energy_manager: {
        description: "This interface defines the global EnergyManager",
        vars: {}
      },
      energy_price_information: {
        description: "This interface defines the interface for an energy price forecast",
        vars: {
          energy_price_schedule: {
            additionalProperties: false,
            description: "Forecast JSON Object containing timestamps and the price forecast for both import and export.",
            properties: {
              schedule_export: {
                description: "Pricing time series. The first entry is special as it will be active already now even if the timestamp is in the future, so it is good practice to set the first entry to current time. The time series can have arbitrary time difference between entries and all timestamps are absolute UTC time.",
                items: {
                  additionalProperties: false,
                  description: "One entry for the time series",
                  properties: {
                    price_per_kwh: {
                      additionalProperties: false,
                      description: "Price information for this timepoint",
                      properties: {
                        currency: {
                          description: "Currency in 3 digit ISO 4217",
                          maxLength: 3,
                          minLength: 3,
                          type: "string"
                        },
                        value: {
                          description: "Price per kWh (earning)",
                          type: "number"
                        }
                      },
                      required: ["value", "currency"],
                      type: "object"
                    },
                    timestamp: {
                      description: "Absolute timestamp for this sample in RFC3339 UTC format https://datatracker.ietf.org/doc/html/rfc3339#section-5.6",
                      format: "date-time",
                      type: "string"
                    }
                  },
                  required: ["timestamp", "price_per_kwh"],
                  type: "object"
                },
                type: "array"
              },
              schedule_import: {
                description: "Pricing time series. The first entry is special as it will be active already now even if the timestamp is in the future, so it is good practice to set the first entry to current time. The time series can have arbitrary time difference between entries and all timestamps are absolute UTC time.",
                items: {
                  additionalProperties: false,
                  description: "One entry for the time series",
                  properties: {
                    price_per_kwh: {
                      additionalProperties: false,
                      description: "Price information for this timepoint",
                      properties: {
                        currency: {
                          description: "Currency in 3 digit ISO 4217",
                          maxLength: 3,
                          minLength: 3,
                          type: "string"
                        },
                        value: {
                          description: "Price per kWh (cost)",
                          type: "number"
                        }
                      },
                      required: ["value", "currency"],
                      type: "object"
                    },
                    timestamp: {
                      description: "Absolute timestamp for this sample in RFC3339 UTC format https://datatracker.ietf.org/doc/html/rfc3339#section-5.6",
                      format: "date-time",
                      type: "string"
                    }
                  },
                  required: ["timestamp", "price_per_kwh"],
                  type: "object"
                },
                type: "array"
              }
            },
            type: "object"
          }
        }
      },
      evse_manager: {
        cmds: {
          accept_new_session: {
            description: "Call when cleanup is done and new cars are allowed to plugin. Do not use multiple cleanup handlers, call from only one module!",
            result: {
              description: "Returns true if successful",
              type: "boolean"
            }
          },
          cancel_charging: {
            description: "Cancels charging, can only be resumed by replugging car",
            result: {
              description: "Returns true if successful",
              type: "boolean"
            }
          },
          cancel_reservation: {
            description: "Cancels current reservation",
            result: {
              description: "Indicates if cancelling reservation was successful or not",
              type: "boolean"
            }
          },
          disable: {
            description: "Disables the evse",
            result: {
              description: "Returns true if evse was disabled (or was disabled before), returns false if it could not be disabled (i.e. due to communication error with hardware)",
              type: "boolean"
            }
          },
          enable: {
            description: "Enables the evse",
            result: {
              description: "Returns true if evse was enabled (or was enabled before), returns false if enable failed e.g. due to permanent fault.",
              type: "boolean"
            }
          },
          force_unlock: {
            description: "Force unlock connector now. During normal operation, connector will be locked/unlocked in the correct sequence. Do not use this function except if explicitly requested by e.g. management cloud.",
            result: {
              description: "Returns true if unlocking sequence was successfully executed",
              type: "boolean"
            }
          },
          get_signed_meter_value: {
            description: "Returns a signed meter value. Includes current auth token if session is running.",
            result: {
              description: "Signed meter value",
              type: "string"
            }
          },
          pause_charging: {
            description: "Pauses charging",
            result: {
              description: "Returns true if successfully paused or was already in paused_by_evse mode",
              type: "boolean"
            }
          },
          reserve_now: {
            arguments: {
              auth_token: {
                description: "The authentication token that this evse is reserved for",
                type: "string"
              },
              timeout: {
                description: "timeout [s] until this reservation expires",
                type: "number"
              }
            },
            description: "Reserves this evse for a given auth token",
            result: {
              description: "Indicates if reservation was successful or not",
              type: "boolean"
            }
          },
          resume_charging: {
            description: "Resumes charging",
            result: {
              description: "Returns true if resume was successful, false otherwise (e.g. resuming a car pause won't work)",
              type: "boolean"
            }
          },
          set_local_max_current: {
            arguments: {
              max_current: {
                description: "maximum current",
                type: "number"
              }
            },
            description: "Sets the local maximum current limit for any phase.",
            result: {
              description: "Returns success or error code",
              enum: ["Success", "Error_OutOfRange", "Error_Hardware"],
              type: "string"
            }
          },
          switch_three_phases_while_charging: {
            arguments: {
              three_phases: {
                description: "True if switching three phases whilst charging, false if not",
                type: "boolean"
              }
            },
            description: "Switch three phases while charging",
            result: {
              description: "Returns success or error code",
              enum: ["Success", "Error_NotSupported", "Error_NotCharging", "Error_Hardware"],
              type: "string"
            }
          }
        },
        description: "This interface defines the main evse manager",
        vars: {
          limits: {
            additionalProperties: false,
            description: "Limits of this evse, published on change",
            properties: {
              max_current: {
                description: "Instantaneous maximum current available to car",
                type: "number"
              },
              nr_of_phases_available: {
                description: "Instantaneous phase count available to car",
                maximum: 3,
                minimum: 1,
                type: "integer"
              }
            },
            required: ["max_current", "nr_of_phases_available"],
            type: "object"
          },
          powermeter: {
            description: "FIXME: use powermeter type here",
            type: "object"
          },
          reservation: {
            additionalProperties: false,
            description: "Current reservation status, published on change",
            properties: {
              auth_token: {
                description: "token for which evse is reserved for",
                maxLength: 20,
                minLength: 1,
                type: "string"
              },
              reserved: {
                description: "true if currently reserved",
                type: "boolean"
              },
              valid_until: {
                description: "timestamp (abs time) when reservation expires",
                type: "number"
              }
            },
            required: ["reserved", "auth_token", "valid_until"],
            type: "object"
          },
          session_events: {
            additionalProperties: false,
            description: "Emits all events related to sessions",
            properties: {
              error: {
                description: "Details on error type",
                enum: ["Car", "CarDiodeFault", "Relais", "RCD", "VentilationNotAvailable", "OverCurrent"],
                type: "string"
              },
              event: {
                description: "Event enum. For some events an additional object is set, see below.",
                enum: [
                  "Enabled",
                  "Disabled",
                  "SessionStarted",
                  "AuthRequired",
                  "ChargingStarted",
                  "ChargingPausedEV",
                  "ChargingPausedEVSE",
                  "ChargingResumed",
                  "SessionFinished",
                  "Error",
                  "PermanentFault"
                ],
                type: "string"
              },
              session_finished: {
                additionalProperties: false,
                description: "data for SessionFinished event",
                properties: {
                  energy_Wh_export: {
                    description: "Session end Wh",
                    type: "number"
                  },
                  energy_Wh_import: {
                    description: "Session end Wh",
                    type: "number"
                  },
                  signed_meter_value: {
                    description: "Signed meter value",
                    type: "string"
                  },
                  timestamp: {
                    description: "Session end timestamp",
                    type: "number"
                  }
                },
                required: ["timestamp", "energy_Wh_import"],
                type: "object"
              },
              session_started: {
                additionalProperties: false,
                description: "data for SessionStarted event",
                properties: {
                  energy_Wh_export: {
                    description: "Session start Wh",
                    type: "number"
                  },
                  energy_Wh_import: {
                    description: "Session start Wh",
                    type: "number"
                  },
                  signed_meter_value: {
                    description: "Signed meter value",
                    type: "string"
                  },
                  timestamp: {
                    description: "Session start timestamp",
                    type: "number"
                  }
                },
                required: ["timestamp", "energy_Wh_import"],
                type: "object"
              },
              uuid: {
                description: "An EVSE generated UUID for this session, can be used e.g. for database storage.",
                type: "string"
              }
            },
            required: ["uuid", "event"],
            type: "object"
          },
          telemetry: {
            additionalProperties: false,
            description: "Other telemetry",
            properties: {
              fan_rpm: {
                description: "RPM of the fan. 0 if off or no fan available.",
                type: "number"
              },
              rcd_current: {
                description: "Residual current in mA",
                type: "number"
              },
              relais_on: {
                description: "true if power to the car is currently on, false if off",
                type: "boolean"
              },
              supply_voltage_12V: {
                description: "Internal 12V supply voltage",
                type: "number"
              },
              supply_voltage_minus_12V: {
                description: "Internal -12V supply voltage",
                type: "number"
              },
              temperature: {
                description: "Current temperature of the EVSE in degree celsius",
                type: "number"
              }
            },
            type: "object"
          }
        }
      },
      example: {
        cmds: {
          uses_something: {
            arguments: {
              key: {
                description: "Key to check the existence for",
                pattern: "^[A-Za-z0-9_.]+$",
                type: "string"
              }
            },
            description: "This command checks if something is stored under a given key",
            result: {
              description: "Returns 'True' if something was stored for this key",
              type: "boolean"
            }
          }
        },
        description: "This interface defines an example interface that uses multiple framework features",
        vars: {
          max_current: {
            description: "Provides maximum current of this supply in ampere",
            type: "number"
          }
        }
      },
      example_child: {
        description: "This interface defines an inherited example interface that uses multiple framework features (all inherited from base interface)",
        parent: "example"
      },
      example_user: {
        description: "This interface defines an example_user interface that uses the example interface"
      },
      iso15118_evcc_emu: {
        cmds: {
          start: {
            arguments: {
              arg1: {
                additionalProperties: false,
                description: "Arg1 desc",
                properties: {
                  bar: {
                    type: "number"
                  },
                  foo: {
                    type: "string"
                  }
                },
                required: ["foo", "bar"],
                type: "object"
              }
            },
            description: "Start a charging session"
          },
          stop: {
            description: "Stop current charging session"
          }
        },
        description: "This unit type should emulate an ISO15118 EVCC"
      },
      kvs: {
        cmds: {
          delete: {
            arguments: {
              key: {
                description: "Key to delete the value for",
                pattern: "^[A-Za-z0-9_.]+$",
                type: "string"
              }
            },
            description: "This command removes the value stored under a given key"
          },
          exists: {
            arguments: {
              key: {
                description: "Key to check the existence for",
                pattern: "^[A-Za-z0-9_.]+$",
                type: "string"
              }
            },
            description: "This command checks if something is stored under a given key",
            result: {
              description: "Returns 'True' if something was stored for this key",
              type: "boolean"
            }
          },
          load: {
            arguments: {
              key: {
                description: "Key to load the value for",
                pattern: "^[A-Za-z0-9_.]+$",
                type: "string"
              }
            },
            description: "This command loads the previously stored value for a given key (it will return null if the key does not exist)",
            result: {
              description: "The previously stored value",
              type: ["null", "string", "number", "integer", "boolean", "array", "object"]
            }
          },
          store: {
            arguments: {
              key: {
                description: "Key to store the value for",
                pattern: "^[A-Za-z0-9_.]*$",
                type: "string"
              },
              value: {
                description: "Value to store",
                type: ["null", "string", "number", "integer", "boolean", "array", "object"]
              }
            },
            description: "This command stores a value under a given key"
          }
        },
        description: "This interface defines a simple key-value-store interface"
      },
      ocpp_1_6_charge_point: {
        description: "This interface defines a OCPP 1.6 charge point"
      },
      power: {
        description: "This interface defines the interface of a power supply",
        vars: {
          max_current: {
            description: "This is the maximum current of the power supply",
            maximum: 60,
            minimum: 1,
            type: "number"
          }
        }
      },
      power_in: {
        description: "This interface defines the interface of a physical power supply",
        parent: "power",
        vars: {
          phase_count: {
            description: "This is the phase count of the physical power supply",
            maximum: 3,
            minimum: 1,
            type: "integer"
          }
        }
      },
      power_result: {
        description: "This interface defines the interface of an augmented power supply (currently solely conforming to the power_in interface)",
        parent: "power_in"
      },
      powermeter: {
        cmds: {
          get_signed_meter_value: {
            arguments: {
              auth_token: {
                description: "Auth token",
                maxLength: 20,
                minLength: 1,
                type: "string"
              }
            },
            description: "Returns a signed meter value with the given auth token",
            result: {
              description: "Signed meter value",
              type: "string"
            }
          }
        },
        description: "This interface defines a generic powermeter for 5 wire TN networks.",
        vars: {
          powermeter: {
            additionalProperties: false,
            description: "Measured dataset",
            properties: {
              current_A: {
                additionalProperties: false,
                description: "Current in ampere",
                properties: {
                  L1: {
                    description: "L1 value only",
                    type: "number"
                  },
                  L2: {
                    description: "L2 value only",
                    type: "number"
                  },
                  L3: {
                    description: "L3 value only",
                    type: "number"
                  },
                  N: {
                    description: "Neutral value only",
                    type: "number"
                  }
                },
                required: ["L1"],
                type: "object"
              },
              energy_Wh_export: {
                additionalProperties: false,
                description: "Exported energy in Wh (to grid)",
                properties: {
                  L1: {
                    description: "L1 value only",
                    type: "number"
                  },
                  L2: {
                    description: "L2 value only",
                    type: "number"
                  },
                  L3: {
                    description: "L3 value only",
                    type: "number"
                  },
                  total: {
                    description: "Sum value (which is relevant for billing)",
                    type: "number"
                  }
                },
                required: ["total"],
                type: "object"
              },
              energy_Wh_import: {
                additionalProperties: false,
                description: "Imported energy in Wh (from grid)",
                properties: {
                  L1: {
                    description: "L1 value only",
                    type: "number"
                  },
                  L2: {
                    description: "L2 value only",
                    type: "number"
                  },
                  L3: {
                    description: "L3 value only",
                    type: "number"
                  },
                  total: {
                    description: "Sum value (which is relevant for billing)",
                    type: "number"
                  }
                },
                required: ["total"],
                type: "object"
              },
              frequency_Hz: {
                additionalProperties: false,
                description: "Grid frequency in Hertz",
                properties: {
                  L1: {
                    description: "L1 value",
                    type: "number"
                  },
                  L2: {
                    description: "L2 value",
                    type: "number"
                  },
                  L3: {
                    description: "L3 value",
                    type: "number"
                  }
                },
                required: ["L1"],
                type: "object"
              },
              meter_id: {
                description: "A (user defined) meter if (e.g. id printed on the case)",
                type: "string"
              },
              phase_seq_error: {
                description: "true for 3 phase rotation error (ccw)",
                type: "boolean"
              },
              power_W: {
                additionalProperties: false,
                description: "Instantaneous power in Watt. Negative values are exported, positive values imported Energy.",
                properties: {
                  L1: {
                    description: "L1 value only",
                    type: "number"
                  },
                  L2: {
                    description: "L2 value only",
                    type: "number"
                  },
                  L3: {
                    description: "L3 value only",
                    type: "number"
                  },
                  total: {
                    description: "Sum value",
                    type: "number"
                  }
                },
                required: ["total"],
                type: "object"
              },
              timestamp: {
                description: "Timestamp of measurement",
                type: "number"
              },
              voltage_V: {
                additionalProperties: false,
                description: "Voltage in Volts",
                properties: {
                  L1: {
                    description: "L1 value only",
                    type: "number"
                  },
                  L2: {
                    description: "L2 value only",
                    type: "number"
                  },
                  L3: {
                    description: "L3 value only",
                    type: "number"
                  }
                },
                required: ["L1"],
                type: "object"
              }
            },
            required: ["timestamp"],
            type: "object"
          }
        }
      },
      slac: {
        cmds: {
          dlink_error: {
            description: "Terminate the data link and restart the matching process.",
            result: {
              description: "True on success.",
              type: "boolean"
            }
          },
          dlink_pause: {
            description: "Request power saving mode, while staying MATCHED.",
            result: {
              description: "True on success.",
              type: "boolean"
            }
          },
          dlink_terminate: {
            description: "Terminate the data link and become UNMATCHED.",
            result: {
              description: "True on success.",
              type: "boolean"
            }
          },
          enter_bcd: {
            description: "Signal pilot state change to B/C/D from A/E/F.",
            result: {
              description: "True on success.",
              type: "boolean"
            }
          },
          error_sequence_reset: {
            arguments: {
              successful: {
                description: "Whether the error sequence could be done and was successful",
                type: "boolean"
              }
            },
            description: "Signal that the error sequence has finished.",
            result: {
              description: "True on success.",
              type: "boolean"
            }
          },
          leave_bcd: {
            description: "Signal pilot state change to A/E/F from B/C/D.",
            result: {
              description: "True on success.",
              type: "boolean"
            }
          },
          reset: {
            description: "Reset SLAC. Not implemented yet."
          }
        },
        description: "ISO15118-3 SLAC interface",
        vars: {
          dlink_ready: {
            description: "Inform higher layers about a change in data link status. Emits true if link was set up and false when the link is shut down.",
            type: "boolean"
          },
          request_error_routine: {
            description: "Inform the higher layer to execute the error routine for a SLAC connection retry",
            type: "null"
          },
          state: {
            description: "Provides the state enum.",
            enum: ["UNMATCHED", "MATCHING", "MATCHED"],
            type: "string"
          }
        }
      },
      solar: {
        description: "This interface defines the interface of a solar module",
        parent: "power"
      },
      solar_forecast: {
        description: "This interface defines the interface for an solar energy production forecast",
        vars: {
          forecast: {
            description: "Forecast JSON Object containing a timestamp and the energy forecast in watthours.",
            type: "object"
          }
        }
      },
      sunspec_reader: {
        description: "This interface defines a generic Sunspec reader, which can be used to fetch values from Sunspec devices when an implementation is given.",
        vars: {
          measurement: {
            additionalProperties: true,
            description: "Measured dataset",
            properties: {
              timestamp: {
                description: "Timestamp of measurement",
                type: "number"
              },
              value: {
                description: "Measurement value",
                type: "number"
              }
            },
            required: ["timestamp"],
            type: "object"
          }
        }
      },
      sunspec_scanner: {
        cmds: {
          scan_device: {
            arguments: {
              ip_address: {
                description: "local IP-address of the Sunspec device",
                pattern: "^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$",
                type: "string"
              }
            },
            description: "Scans complete device",
            result: {
              description: "Returns a json overview of the scan",
              type: "object"
            }
          },
          scan_network: {
            description: "Scans local network",
            result: {
              description: "Returns a json overview of the scan",
              type: "object"
            }
          },
          scan_port: {
            arguments: {
              ip_address: {
                description: "local IP-address of the Sunspec device",
                pattern: "^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$",
                type: "string"
              },
              port: {
                description: "Modbus port",
                minimum: 0,
                type: "integer"
              }
            },
            description: "Scans all units at a device's port",
            result: {
              description: "Returns a json overview of the scan",
              type: "object"
            }
          },
          scan_unit: {
            arguments: {
              ip_address: {
                description: "local IP-address of the Sunspec device",
                pattern: "^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$",
                type: "string"
              },
              port: {
                description: "Modbus port",
                minimum: 0,
                type: "integer"
              },
              unit: {
                description: "Modbus unit id",
                minimum: 0,
                type: "integer"
              }
            },
            description: "Scans specific unit at a device's port",
            result: {
              description: "Returns a json overview of the scan",
              type: "object"
            }
          }
        },
        description: "This class defines the global Sunspec scanner"
      },
      tibber_price_forecast: {
        description: "This interface defines the interface for an energy price forecast",
        vars: {
          forecast: {
            description: "Forecast JSON Object containing a timestamp and the price forecast",
            type: "object"
          }
        }
      },
      yeti_extras: {
        cmds: {
          firmware_update: {
            arguments: {
              firmware_binary: {
                description: "Path to firmware binary file that should be sent to Yeti Controller",
                type: "string"
              }
            },
            description: "This command reboots Yeti in firmware upgrade mode"
          }
        },
        description: "This interface defines Yeti extra funtionality not found in the generic interfaces",
        vars: {
          hw_revision: {
            description: "Provides the hw_revision",
            type: "integer"
          },
          hw_type: {
            description: "Provides the hw_type",
            type: "integer"
          },
          protocol_version_major: {
            description: "Provides the protocol_version_major",
            type: "integer"
          },
          protocol_version_minor: {
            description: "Provides the protocol_version_minor",
            type: "integer"
          },
          sw_version_string: {
            description: "Provides the sw_version_string",
            type: "string"
          },
          time_stamp: {
            description: "Provides the current time stamp",
            type: "integer"
          }
        }
      },
      yeti_simulation_control: {
        cmds: {
          enable: {
            arguments: {
              value: {
                description: "true to enable, false to disable",
                type: "boolean"
              }
            },
            description: "Enable/disable the simulation"
          },
          setSimulationData: {
            arguments: {
              value: {
                additionalProperties: false,
                description: "simulation data",
                minProperties: 8,
                properties: {
                  cp_voltage: {
                    description: "CP Voltage level [V]",
                    type: "number"
                  },
                  currents: {
                    additionalProperties: false,
                    description: "Currents in Ampere",
                    minProperties: 4,
                    properties: {
                      L1: {
                        type: "number"
                      },
                      L2: {
                        type: "number"
                      },
                      L3: {
                        type: "number"
                      },
                      N: {
                        type: "number"
                      }
                    },
                    type: "object"
                  },
                  diode_fail: {
                    description: "Set to true to simulate a diode failure",
                    type: "boolean"
                  },
                  error_e: {
                    description: "Set to true to simulate Error E (CP-PE short)",
                    type: "boolean"
                  },
                  frequencies: {
                    additionalProperties: false,
                    description: "Frequencies in Hertz",
                    minProperties: 3,
                    properties: {
                      L1: {
                        type: "number"
                      },
                      L2: {
                        type: "number"
                      },
                      L3: {
                        type: "number"
                      }
                    },
                    type: "object"
                  },
                  pp_resistor: {
                    description: "PP resistor value [Ohm]",
                    type: "number"
                  },
                  rcd_current: {
                    description: "RCD current in mA",
                    type: "number"
                  },
                  voltages: {
                    additionalProperties: false,
                    description: "Voltages in Volt",
                    minProperties: 3,
                    properties: {
                      L1: {
                        type: "number"
                      },
                      L2: {
                        type: "number"
                      },
                      L3: {
                        type: "number"
                      }
                    },
                    type: "object"
                  }
                },
                type: "object"
              }
            },
            description: "Sends a new simulation data object"
          }
        },
        description: "This defines a HIL simulation interface",
        vars: {
          enabled: {
            description: "Indicates whether simulation interface is currently active or not",
            type: "boolean"
          },
          simulation_feedback: {
            description: "Feedback from simulation (everything that a car can measure on the CP signal plus the indication whether relais are on or off)",
            type: "object"
          }
        }
      }
    };
    const SampleConfigList = {
      "sample-config-sil": {
        active_modules: {
          auth: {
            connections: {
              tokenProvider: [
                {
                  implementation_id: "main",
                  module_id: "token_provider_1"
                }
              ],
              tokenValidator: [
                {
                  implementation_id: "main",
                  module_id: "token_validator"
                }
              ]
            },
            module: "JsAuth",
            "x-view-model": {
              position: {
                x: 6,
                y: 1
              },
              terminals: {
                bottom: [
                  {
                    id: "tokenProvider",
                    interface: "auth_token_provider",
                    type: "requirement"
                  }
                ],
                left: [
                  {
                    id: "main",
                    interface: "auth",
                    type: "provide"
                  }
                ],
                right: [
                  {
                    id: "tokenValidator",
                    interface: "auth_token_validator",
                    type: "requirement"
                  }
                ],
                top: []
              }
            }
          },
          car_simulator: {
            connections: {
              simulation_control: [
                {
                  implementation_id: "yeti_simulation_control",
                  module_id: "yeti_driver"
                }
              ]
            },
            module: "JsCarSimulator",
            "x-view-model": {
              position: {
                x: -28,
                y: 35
              },
              terminals: {
                bottom: [],
                left: [],
                right: [
                  {
                    id: "main",
                    interface: "car_simulator",
                    type: "provide"
                  }
                ],
                top: [
                  {
                    id: "simulation_control",
                    interface: "yeti_simulation_control",
                    type: "requirement"
                  }
                ]
              }
            }
          },
          energy_manager: {
            connections: {
              energy_trunk: [
                {
                  implementation_id: "energy_grid",
                  module_id: "grid_connection_point"
                }
              ]
            },
            module: "EnergyManager",
            "x-view-model": {
              position: {
                x: 2,
                y: 38
              },
              terminals: {
                bottom: [],
                left: [],
                right: [
                  {
                    id: "main",
                    interface: "energy_manager",
                    type: "provide"
                  }
                ],
                top: [
                  {
                    id: "energy_trunk",
                    interface: "energy",
                    type: "requirement"
                  }
                ]
              }
            }
          },
          evse_manager: {
            connections: {
              auth: [
                {
                  implementation_id: "main",
                  module_id: "auth"
                }
              ],
              bsp: [
                {
                  implementation_id: "board_support",
                  module_id: "yeti_driver"
                }
              ],
              powermeter: [
                {
                  implementation_id: "powermeter",
                  module_id: "yeti_driver"
                }
              ]
            },
            module: "EvseManager",
            "x-view-model": {
              position: {
                x: -11,
                y: 13
              },
              terminals: {
                bottom: [
                  {
                    id: "energy_grid",
                    interface: "energy",
                    type: "provide"
                  }
                ],
                left: [
                  {
                    id: "bsp",
                    interface: "board_support_AC",
                    type: "requirement"
                  },
                  {
                    id: "powermeter",
                    interface: "powermeter",
                    type: "requirement"
                  }
                ],
                right: [
                  {
                    id: "evse",
                    interface: "evse_manager",
                    type: "provide"
                  }
                ],
                top: [
                  {
                    id: "auth",
                    interface: "auth",
                    type: "requirement"
                  }
                ]
              }
            }
          },
          grid_connection_point: {
            connections: {
              energy_consumer: [
                {
                  implementation_id: "energy_grid",
                  module_id: "evse_manager"
                }
              ],
              powermeter: [
                {
                  implementation_id: "powermeter",
                  module_id: "yeti_driver"
                }
              ]
            },
            module: "EnergyNode",
            "x-view-model": {
              position: {
                x: 2,
                y: 26
              },
              terminals: {
                bottom: [
                  {
                    id: "energy_grid",
                    interface: "energy",
                    type: "provide"
                  }
                ],
                left: [
                  {
                    id: "energy_consumer",
                    interface: "energy",
                    type: "requirement"
                  },
                  {
                    id: "powermeter",
                    interface: "powermeter",
                    type: "requirement"
                  },
                  {
                    id: "price_information",
                    interface: "energy_price_information",
                    type: "requirement"
                  }
                ],
                right: [],
                top: []
              }
            }
          },
          iso15118_charger: {
            connections: {},
            module: "JsRiseV2G",
            "x-view-model": {
              position: {
                x: -29,
                y: 4
              },
              terminals: {
                bottom: [],
                left: [
                  {
                    id: "slac",
                    interface: "ISO15118_3_SLAC",
                    type: "requirement"
                  }
                ],
                right: [
                  {
                    id: "ac_charger",
                    interface: "ISO15118_ac_charger",
                    type: "provide"
                  },
                  {
                    id: "dc_charger",
                    interface: "ISO15118_dc_charger",
                    type: "provide"
                  },
                  {
                    id: "main",
                    interface: "empty",
                    type: "provide"
                  }
                ],
                top: []
              }
            }
          },
          token_provider_1: {
            connections: {
              evse: [
                {
                  implementation_id: "evse",
                  module_id: "evse_manager"
                }
              ]
            },
            module: "JsDummyTokenProvider",
            "x-view-model": {
              position: {
                x: 6,
                y: 13
              },
              terminals: {
                bottom: [],
                left: [
                  {
                    id: "evse",
                    interface: "evse_manager",
                    type: "requirement"
                  }
                ],
                right: [],
                top: [
                  {
                    id: "main",
                    interface: "auth_token_provider",
                    type: "provide"
                  }
                ]
              }
            }
          },
          token_validator: {
            connections: {},
            module: "JsDummyTokenValidator",
            "x-view-model": {
              position: {
                x: 22,
                y: 1
              },
              terminals: {
                bottom: [],
                left: [
                  {
                    id: "main",
                    interface: "auth_token_validator",
                    type: "provide"
                  }
                ],
                right: [],
                top: []
              }
            }
          },
          yeti_driver: {
            connections: {},
            module: "JsYetiSimulator",
            "x-view-model": {
              position: {
                x: -28,
                y: 24
              },
              terminals: {
                bottom: [
                  {
                    id: "yeti_simulation_control",
                    interface: "yeti_simulation_control",
                    type: "provide"
                  }
                ],
                left: [
                  {
                    id: "yeti_extras",
                    interface: "yeti_extras",
                    type: "provide"
                  },
                  {
                    id: "debug_state",
                    interface: "debug_json",
                    type: "provide"
                  },
                  {
                    id: "debug_yeti",
                    interface: "debug_json",
                    type: "provide"
                  }
                ],
                right: [
                  {
                    id: "debug_keepalive",
                    interface: "debug_json",
                    type: "provide"
                  },
                  {
                    id: "debug_powermeter",
                    interface: "debug_json",
                    type: "provide"
                  },
                  {
                    id: "powermeter",
                    interface: "powermeter",
                    type: "provide"
                  }
                ],
                top: [
                  {
                    id: "board_support",
                    interface: "board_support_AC",
                    type: "provide"
                  }
                ]
              }
            }
          }
        },
        "x-module-layout": {
          auth: {
            position: {
              x: 6,
              y: 1
            },
            terminals: {
              bottom: [
                {
                  id: "tokenProvider",
                  interface: "auth_token_provider",
                  type: "requirement"
                }
              ],
              left: [
                {
                  id: "main",
                  interface: "auth",
                  type: "provide"
                }
              ],
              right: [
                {
                  id: "tokenValidator",
                  interface: "auth_token_validator",
                  type: "requirement"
                }
              ],
              top: []
            }
          },
          car_simulator: {
            position: {
              x: -28,
              y: 35
            },
            terminals: {
              bottom: [],
              left: [],
              right: [
                {
                  id: "main",
                  interface: "car_simulator",
                  type: "provide"
                }
              ],
              top: [
                {
                  id: "simulation_control",
                  interface: "yeti_simulation_control",
                  type: "requirement"
                }
              ]
            }
          },
          energy_manager: {
            position: {
              x: 2,
              y: 38
            },
            terminals: {
              bottom: [],
              left: [],
              right: [
                {
                  id: "main",
                  interface: "energy_manager",
                  type: "provide"
                }
              ],
              top: [
                {
                  id: "energy_trunk",
                  interface: "energy",
                  type: "requirement"
                }
              ]
            }
          },
          evse_manager: {
            position: {
              x: -11,
              y: 13
            },
            terminals: {
              bottom: [
                {
                  id: "energy_grid",
                  interface: "energy",
                  type: "provide"
                }
              ],
              left: [
                {
                  id: "bsp",
                  interface: "board_support_AC",
                  type: "requirement"
                },
                {
                  id: "powermeter",
                  interface: "powermeter",
                  type: "requirement"
                }
              ],
              right: [
                {
                  id: "evse",
                  interface: "evse_manager",
                  type: "provide"
                }
              ],
              top: [
                {
                  id: "auth",
                  interface: "auth",
                  type: "requirement"
                }
              ]
            }
          },
          grid_connection_point: {
            position: {
              x: 2,
              y: 26
            },
            terminals: {
              bottom: [
                {
                  id: "energy_grid",
                  interface: "energy",
                  type: "provide"
                }
              ],
              left: [
                {
                  id: "energy_consumer",
                  interface: "energy",
                  type: "requirement"
                },
                {
                  id: "powermeter",
                  interface: "powermeter",
                  type: "requirement"
                },
                {
                  id: "price_information",
                  interface: "energy_price_information",
                  type: "requirement"
                }
              ],
              right: [],
              top: []
            }
          },
          iso15118_charger: {
            position: {
              x: -29,
              y: 4
            },
            terminals: {
              bottom: [],
              left: [
                {
                  id: "slac",
                  interface: "ISO15118_3_SLAC",
                  type: "requirement"
                }
              ],
              right: [
                {
                  id: "ac_charger",
                  interface: "ISO15118_ac_charger",
                  type: "provide"
                },
                {
                  id: "dc_charger",
                  interface: "ISO15118_dc_charger",
                  type: "provide"
                },
                {
                  id: "main",
                  interface: "empty",
                  type: "provide"
                }
              ],
              top: []
            }
          },
          token_provider_1: {
            position: {
              x: 6,
              y: 13
            },
            terminals: {
              bottom: [],
              left: [
                {
                  id: "evse",
                  interface: "evse_manager",
                  type: "requirement"
                }
              ],
              right: [],
              top: [
                {
                  id: "main",
                  interface: "auth_token_provider",
                  type: "provide"
                }
              ]
            }
          },
          token_validator: {
            position: {
              x: 22,
              y: 1
            },
            terminals: {
              bottom: [],
              left: [
                {
                  id: "main",
                  interface: "auth_token_validator",
                  type: "provide"
                }
              ],
              right: [],
              top: []
            }
          },
          yeti_driver: {
            position: {
              x: -28,
              y: 24
            },
            terminals: {
              bottom: [
                {
                  id: "yeti_simulation_control",
                  interface: "yeti_simulation_control",
                  type: "provide"
                }
              ],
              left: [
                {
                  id: "yeti_extras",
                  interface: "yeti_extras",
                  type: "provide"
                },
                {
                  id: "debug_state",
                  interface: "debug_json",
                  type: "provide"
                },
                {
                  id: "debug_yeti",
                  interface: "debug_json",
                  type: "provide"
                }
              ],
              right: [
                {
                  id: "debug_keepalive",
                  interface: "debug_json",
                  type: "provide"
                },
                {
                  id: "debug_powermeter",
                  interface: "debug_json",
                  type: "provide"
                },
                {
                  id: "powermeter",
                  interface: "powermeter",
                  type: "provide"
                }
              ],
              top: [
                {
                  id: "board_support",
                  interface: "board_support_AC",
                  type: "provide"
                }
              ]
            }
          }
        }
      }
    };
    class RpcIssuer {
      async get_modules() {
        return this.issue_rpc("get_modules", null, false);
      }
      async get_interfaces() {
        return this.issue_rpc("get_interfaces", null, false);
      }
      async get_configs() {
        return this.issue_rpc("get_configs", null, false);
      }
      async save_config(params, notification) {
        return this.issue_rpc("save_config", params, notification);
      }
      async restart_modules() {
        return this.issue_rpc("restart_modules", null, false);
      }
      async get_rpc_timeout() {
        return this.issue_rpc("get_rpc_timeout", null, false);
      }
    }
    class LoopbackRpcIssuer extends RpcIssuer {
      random_wait_resolve(returnValue) {
        if (returnValue) {
          return new Promise((resolve2) => {
            setTimeout(() => resolve2(returnValue), Math.random() * 4 * LOOPBACK_WAIT_MS);
          });
        } else {
          return new Promise((resolve2) => {
            setTimeout(() => resolve2(), Math.random() * 4 * LOOPBACK_WAIT_MS);
          });
        }
      }
      async get_modules() {
        return this.random_wait_resolve(SampleManifestList);
      }
      async get_interfaces() {
        return this.random_wait_resolve(SampleInterfaceList);
      }
      async get_configs() {
        return this.random_wait_resolve(SampleConfigList);
      }
      async save_config() {
        return this.random_wait_resolve();
      }
      async restart_modules() {
        return this.random_wait_resolve();
      }
      async get_rpc_timeout() {
        return this.random_wait_resolve(5e3);
      }
      async issue_rpc() {
        throw new Error("Method not implemented in LoopbackRpcIssuer.");
      }
      async disconnect() {
        return this.random_wait_resolve();
      }
    }
    class WebsocketRpcIssuer extends RpcIssuer {
      constructor(_url, publish_connection_state) {
        super();
        __publicField(this, "_pending_commands", /* @__PURE__ */ new Map());
        __publicField(this, "_socket");
        __publicField(this, "_rpc_timeout_ms", INITIAL_RPC_TIMEOUT_VALUE);
        this._url = _url;
        this.publish_connection_state = publish_connection_state;
        this._socket = new WebSocket(this._url);
        this._socket.onopen = this._handle_socket_opened.bind(this);
        this._socket.onmessage = this.handle_backend_message.bind(this);
        this._socket.onerror = this._handle_socket_error.bind(this);
        this._socket.onclose = this._handle_socket_close.bind(this);
      }
      _handle_socket_opened() {
        this.publish_connection_state({ type: "OPENED" });
        this.get_rpc_timeout().then((timeout) => {
          this._rpc_timeout_ms = timeout;
        });
      }
      _handle_socket_error() {
        this.publish_connection_state({
          type: "ERROR",
          error: `Could not connect to ${this._socket.url}.`
        });
      }
      _handle_socket_close() {
        this.publish_connection_state({
          type: "CLOSED"
        });
      }
      async disconnect() {
        this._socket.close();
      }
      async issue_rpc(method, params, notification) {
        console.log("Issuing RPC request", method, params, notification);
        const id2 = notification ? void 0 : Math.floor(Math.random() * 1024 * 1024);
        const rpc_request = {
          method,
          ...params !== void 0 && { params },
          ...!notification && { id: id2 }
        };
        this._socket.send(JSON.stringify(rpc_request));
        if (notification) {
          return null;
        }
        return new Promise((resolve2, reject) => {
          const timeout_id = setTimeout(() => {
            this._pending_commands.delete(id2);
            reject(`RPC communication timeout to everest controller process after '${this._rpc_timeout_ms}'ms`);
          }, this._rpc_timeout_ms);
          this._pending_commands.set(id2, { resolve: resolve2, reject, timeout_id });
          console.log(JSON.stringify(this._pending_commands.size));
        });
      }
      handle_backend_message(ev) {
        console.log("second", this._pending_commands.size);
        const payload = JSON.parse(ev.data);
        if (payload.id !== void 0) {
          const id2 = payload.id;
          const pending_command = this._pending_commands.get(id2);
          if (pending_command === void 0) {
            console.log("Received an unknown JSON RPC command id");
            return;
          }
          this._pending_commands.delete(id2);
          clearTimeout(pending_command.timeout_id);
          if (payload.result !== void 0) {
            pending_command.resolve(payload.result);
          } else if (payload.error !== void 0) {
            pending_command.reject(payload.error.message);
          } else {
            console.log("Received an invalid JSON RPC response from backend");
          }
        }
      }
    }
    const LOOPBACK_WAIT_MS = 500;
    class EVBackendConnection {
      constructor(_url, _listener) {
        __publicField(this, "_socket");
        __publicField(this, "_last_message");
        __publicField(this, "_loopback", false);
        __publicField(this, "rpc_issuer");
        this._url = _url;
        this._listener = _listener;
        this._publish_connection_state({ type: "OPEN", url: this._url });
        if (this._url === "ws://loopback:8849") {
          this._connect_loopback_mode();
        } else {
          this._connect_websocket_mode();
        }
      }
      _connect_websocket_mode() {
        this.rpc_issuer = new WebsocketRpcIssuer(this._url, this._publish_connection_state.bind(this));
      }
      _connect_loopback_mode() {
        this.rpc_issuer = new LoopbackRpcIssuer();
        this._loopback = true;
        setTimeout(() => {
          this._publish_connection_state({ type: "OPENED" });
        }, LOOPBACK_WAIT_MS);
      }
      async _disconnect() {
        await this.rpc_issuer.disconnect();
        this._publish_connection_state({ type: "DISCONNECTED" });
        this._listener = () => {
        };
      }
      _publish_connection_state(status) {
        this._listener(status);
      }
    }
    class EVBackendClient {
      constructor() {
        __publicField(this, "initialized", false);
        __publicField(this, "_cxn", null);
        __publicField(this, "_event_handler_map", {});
        __publicField(this, "_last_event_map", {});
        __publicField(this, "_configs");
        __publicField(this, "everest_definitions", {
          modules: null,
          interfaces: null
        });
      }
      async connect(url) {
        if (this._cxn) {
          await this._cxn._disconnect();
        }
        this._cxn = new EVBackendConnection(url, (msg) => this._connection_state_listener(msg));
      }
      async disconnect() {
        this.initialized = false;
        await this._cxn._disconnect();
        this._cxn = null;
      }
      on(event_name, handler) {
        if (!(event_name in this._event_handler_map)) {
          this._event_handler_map[event_name] = [];
        }
        this._event_handler_map[event_name].push(handler);
        if (event_name in this._last_event_map) {
          handler(this._last_event_map[event_name]);
        }
        return () => {
          this._event_handler_map[event_name] = this._event_handler_map[event_name].filter((o) => o !== handler);
        };
      }
      // FIXME (aw):
      // - these shouldn't be callable, until we're successfully connected
      // - it would be nice, if we got an object after successful connection, that contains that
      load_config(name) {
        if (!(name in this._configs)) {
          throw Error(`Configuration "${name}" not found`);
        }
        const config2 = this._configs[name];
        return new EVConfigModel(this.everest_definitions, name, config2);
      }
      create_empty_config(name) {
        return new EVConfigModel(this.everest_definitions, name);
      }
      async save_config(config2) {
        await this._cxn.rpc_issuer.save_config({
          name: `${config2._name}`,
          config: config2.serialize()
        }, false);
        await this._reload_configs();
      }
      _connection_state_listener(status) {
        let event = null;
        if (status.type === "OPEN") {
          event = { type: "INFO", text: `Opening WebSocket connection to ${status.url}` };
        } else if (status.type === "OPENED") {
          if (!this.initialized) {
            event = { type: "INFO", text: `Successfully opened WebSocket connection` };
            this._on_connected();
          } else {
            event = { type: "INITIALIZED", text: "Successfully reconnected" };
          }
        } else if (status.type === "ERROR") {
          event = { type: "FAILED", text: `Connection failed. Trying to reconnect.` };
        } else if (status.type === "CLOSED") {
          event = { type: "RECONNECT", text: "Trying to reconnect" };
        } else if (status.type === "DISCONNECTED") {
          event = { type: "IDLE", text: "Disconnected" };
        }
        if (event) {
          this._publish("connection_state", event);
        }
      }
      _on_connected() {
        this._reload_instance_data().then(() => {
          this.initialized = true;
          this._publish("connection_state", { type: "INITIALIZED", text: "Done initializing" });
        });
      }
      async _reload_modules() {
        this.everest_definitions.modules = await this._cxn.rpc_issuer.get_modules();
        this._publish("connection_state", { type: "INFO", text: `Received ${Object.keys(this.everest_definitions.modules).length} module files` });
      }
      async _reload_interfaces() {
        this.everest_definitions.interfaces = await this._cxn.rpc_issuer.get_interfaces();
        this._publish("connection_state", {
          type: "INFO",
          text: `Received ${Object.keys(this.everest_definitions.interfaces).length} interfaces definitions`
        });
      }
      async _reload_configs() {
        this._configs = await this._cxn.rpc_issuer.get_configs();
        this._publish("connection_state", { type: "INFO", text: `Received ${Object.keys(this._configs).length} config files` });
      }
      _reload_instance_data() {
        return Promise.all([this._reload_interfaces(), this._reload_configs(), this._reload_modules()]);
      }
      _publish(event_name, message) {
        this._last_event_map[event_name] = message;
        if (!(event_name in this._event_handler_map)) {
          return;
        }
        this._event_handler_map[event_name].forEach((handler) => {
          handler(message);
        });
      }
    }
    const evbc = new EVBackendClient();
    const evbcPlugin = {
      install(app2) {
        app2.provide("evbc", evbc);
      }
    };
    const pinia = createPinia();
    function registerPlugins(app2) {
      app2.use(pinia).use(evbcPlugin).use(vuetify).use(router);
    }
    const app = createApp(App);
    registerPlugins(app);
    app.provide("notyf", new Notyf({
      duration: 3e3,
      // default duration for notifications
      ripple: true,
      // adds a material design ripple effect to the notifications
      position: {
        x: "right",
        y: "top"
      },
      types: [
        {
          type: "info",
          background: currentTheme.colors.info
        },
        {
          type: "success",
          background: currentTheme.colors.success
        },
        {
          type: "warning",
          background: currentTheme.colors.warning
        },
        {
          type: "error",
          background: currentTheme.colors.error
        }
      ]
    }));
    app.mount("#app");
  }
});
export default require_index_001();
