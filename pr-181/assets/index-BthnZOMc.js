var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var require_index_001 = __commonJS({
  "assets/index-BthnZOMc.js"(exports, module) {
    var _a;
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link2 of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link2);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node of mutation.addedNodes) {
            if (node.tagName === "LINK" && node.rel === "modulepreload")
              processPreload(node);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link2) {
        const fetchOpts = {};
        if (link2.integrity)
          fetchOpts.integrity = link2.integrity;
        if (link2.referrerPolicy)
          fetchOpts.referrerPolicy = link2.referrerPolicy;
        if (link2.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link2.crossOrigin === "anonymous")
          fetchOpts.credentials = "omit";
        else
          fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link2) {
        if (link2.ep)
          return;
        link2.ep = true;
        const fetchOpts = getFetchOpts(link2);
        fetch(link2.href, fetchOpts);
      }
    })();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
    
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
    
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    var __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
          s = arguments[i2];
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2))
              t[p2] = s[p2];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var NotyfNotification = (
      /** @class */
      function() {
        function NotyfNotification2(options) {
          this.options = options;
          this.listeners = {};
        }
        NotyfNotification2.prototype.on = function(eventType, cb) {
          var callbacks = this.listeners[eventType] || [];
          this.listeners[eventType] = callbacks.concat([cb]);
        };
        NotyfNotification2.prototype.triggerEvent = function(eventType, event) {
          var _this = this;
          var callbacks = this.listeners[eventType] || [];
          callbacks.forEach(function(cb) {
            return cb({ target: _this, event });
          });
        };
        return NotyfNotification2;
      }()
    );
    var NotyfArrayEvent;
    (function(NotyfArrayEvent2) {
      NotyfArrayEvent2[NotyfArrayEvent2["Add"] = 0] = "Add";
      NotyfArrayEvent2[NotyfArrayEvent2["Remove"] = 1] = "Remove";
    })(NotyfArrayEvent || (NotyfArrayEvent = {}));
    var NotyfArray = (
      /** @class */
      function() {
        function NotyfArray2() {
          this.notifications = [];
        }
        NotyfArray2.prototype.push = function(elem) {
          this.notifications.push(elem);
          this.updateFn(elem, NotyfArrayEvent.Add, this.notifications);
        };
        NotyfArray2.prototype.splice = function(index, num2) {
          var elem = this.notifications.splice(index, num2)[0];
          this.updateFn(elem, NotyfArrayEvent.Remove, this.notifications);
          return elem;
        };
        NotyfArray2.prototype.indexOf = function(elem) {
          return this.notifications.indexOf(elem);
        };
        NotyfArray2.prototype.onUpdate = function(fn) {
          this.updateFn = fn;
        };
        return NotyfArray2;
      }()
    );
    var NotyfEvent;
    (function(NotyfEvent2) {
      NotyfEvent2["Dismiss"] = "dismiss";
      NotyfEvent2["Click"] = "click";
    })(NotyfEvent || (NotyfEvent = {}));
    var DEFAULT_OPTIONS = {
      types: [
        {
          type: "success",
          className: "notyf__toast--success",
          backgroundColor: "#3dc763",
          icon: {
            className: "notyf__icon--success",
            tagName: "i"
          }
        },
        {
          type: "error",
          className: "notyf__toast--error",
          backgroundColor: "#ed3d3d",
          icon: {
            className: "notyf__icon--error",
            tagName: "i"
          }
        }
      ],
      duration: 2e3,
      ripple: true,
      position: {
        x: "right",
        y: "bottom"
      },
      dismissible: false
    };
    var NotyfView = (
      /** @class */
      function() {
        function NotyfView2() {
          this.notifications = [];
          this.events = {};
          this.X_POSITION_FLEX_MAP = {
            left: "flex-start",
            center: "center",
            right: "flex-end"
          };
          this.Y_POSITION_FLEX_MAP = {
            top: "flex-start",
            center: "center",
            bottom: "flex-end"
          };
          var docFrag = document.createDocumentFragment();
          var notyfContainer = this._createHTMLElement({ tagName: "div", className: "notyf" });
          docFrag.appendChild(notyfContainer);
          document.body.appendChild(docFrag);
          this.container = notyfContainer;
          this.animationEndEventName = this._getAnimationEndEventName();
          this._createA11yContainer();
        }
        NotyfView2.prototype.on = function(event, cb) {
          var _a2;
          this.events = __assign(__assign({}, this.events), (_a2 = {}, _a2[event] = cb, _a2));
        };
        NotyfView2.prototype.update = function(notification, type2) {
          if (type2 === NotyfArrayEvent.Add) {
            this.addNotification(notification);
          } else if (type2 === NotyfArrayEvent.Remove) {
            this.removeNotification(notification);
          }
        };
        NotyfView2.prototype.removeNotification = function(notification) {
          var _this = this;
          var renderedNotification = this._popRenderedNotification(notification);
          var node;
          if (!renderedNotification) {
            return;
          }
          node = renderedNotification.node;
          node.classList.add("notyf__toast--disappear");
          var handleEvent;
          node.addEventListener(this.animationEndEventName, handleEvent = function(event) {
            if (event.target === node) {
              node.removeEventListener(_this.animationEndEventName, handleEvent);
              _this.container.removeChild(node);
            }
          });
        };
        NotyfView2.prototype.addNotification = function(notification) {
          var node = this._renderNotification(notification);
          this.notifications.push({ notification, node });
          this._announce(notification.options.message || "Notification");
        };
        NotyfView2.prototype._renderNotification = function(notification) {
          var _a2;
          var card = this._buildNotificationCard(notification);
          var className = notification.options.className;
          if (className) {
            (_a2 = card.classList).add.apply(_a2, className.split(" "));
          }
          this.container.appendChild(card);
          return card;
        };
        NotyfView2.prototype._popRenderedNotification = function(notification) {
          var idx = -1;
          for (var i2 = 0; i2 < this.notifications.length && idx < 0; i2++) {
            if (this.notifications[i2].notification === notification) {
              idx = i2;
            }
          }
          if (idx !== -1) {
            return this.notifications.splice(idx, 1)[0];
          }
          return;
        };
        NotyfView2.prototype.getXPosition = function(options) {
          var _a2;
          return ((_a2 = options === null || options === void 0 ? void 0 : options.position) === null || _a2 === void 0 ? void 0 : _a2.x) || "right";
        };
        NotyfView2.prototype.getYPosition = function(options) {
          var _a2;
          return ((_a2 = options === null || options === void 0 ? void 0 : options.position) === null || _a2 === void 0 ? void 0 : _a2.y) || "bottom";
        };
        NotyfView2.prototype.adjustContainerAlignment = function(options) {
          var align = this.X_POSITION_FLEX_MAP[this.getXPosition(options)];
          var justify = this.Y_POSITION_FLEX_MAP[this.getYPosition(options)];
          var style = this.container.style;
          style.setProperty("justify-content", justify);
          style.setProperty("align-items", align);
        };
        NotyfView2.prototype._buildNotificationCard = function(notification) {
          var _this = this;
          var options = notification.options;
          var iconOpts = options.icon;
          this.adjustContainerAlignment(options);
          var notificationElem = this._createHTMLElement({ tagName: "div", className: "notyf__toast" });
          var ripple = this._createHTMLElement({ tagName: "div", className: "notyf__ripple" });
          var wrapper = this._createHTMLElement({ tagName: "div", className: "notyf__wrapper" });
          var message = this._createHTMLElement({ tagName: "div", className: "notyf__message" });
          message.innerHTML = options.message || "";
          var mainColor = options.background || options.backgroundColor;
          if (iconOpts) {
            var iconContainer = this._createHTMLElement({ tagName: "div", className: "notyf__icon" });
            if (typeof iconOpts === "string" || iconOpts instanceof String)
              iconContainer.innerHTML = new String(iconOpts).valueOf();
            if (typeof iconOpts === "object") {
              var _a2 = iconOpts.tagName, tagName = _a2 === void 0 ? "i" : _a2, className_1 = iconOpts.className, text2 = iconOpts.text, _b = iconOpts.color, color = _b === void 0 ? mainColor : _b;
              var iconElement = this._createHTMLElement({ tagName, className: className_1, text: text2 });
              if (color)
                iconElement.style.color = color;
              iconContainer.appendChild(iconElement);
            }
            wrapper.appendChild(iconContainer);
          }
          wrapper.appendChild(message);
          notificationElem.appendChild(wrapper);
          if (mainColor) {
            if (options.ripple) {
              ripple.style.background = mainColor;
              notificationElem.appendChild(ripple);
            } else {
              notificationElem.style.background = mainColor;
            }
          }
          if (options.dismissible) {
            var dismissWrapper = this._createHTMLElement({ tagName: "div", className: "notyf__dismiss" });
            var dismissButton = this._createHTMLElement({
              tagName: "button",
              className: "notyf__dismiss-btn"
            });
            dismissWrapper.appendChild(dismissButton);
            wrapper.appendChild(dismissWrapper);
            notificationElem.classList.add("notyf__toast--dismissible");
            dismissButton.addEventListener("click", function(event) {
              var _a3, _b2;
              (_b2 = (_a3 = _this.events)[NotyfEvent.Dismiss]) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, { target: notification, event });
              event.stopPropagation();
            });
          }
          notificationElem.addEventListener("click", function(event) {
            var _a3, _b2;
            return (_b2 = (_a3 = _this.events)[NotyfEvent.Click]) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, { target: notification, event });
          });
          var className = this.getYPosition(options) === "top" ? "upper" : "lower";
          notificationElem.classList.add("notyf__toast--" + className);
          return notificationElem;
        };
        NotyfView2.prototype._createHTMLElement = function(_a2) {
          var tagName = _a2.tagName, className = _a2.className, text2 = _a2.text;
          var elem = document.createElement(tagName);
          if (className) {
            elem.className = className;
          }
          elem.textContent = text2 || null;
          return elem;
        };
        NotyfView2.prototype._createA11yContainer = function() {
          var a11yContainer = this._createHTMLElement({ tagName: "div", className: "notyf-announcer" });
          a11yContainer.setAttribute("aria-atomic", "true");
          a11yContainer.setAttribute("aria-live", "polite");
          a11yContainer.style.border = "0";
          a11yContainer.style.clip = "rect(0 0 0 0)";
          a11yContainer.style.height = "1px";
          a11yContainer.style.margin = "-1px";
          a11yContainer.style.overflow = "hidden";
          a11yContainer.style.padding = "0";
          a11yContainer.style.position = "absolute";
          a11yContainer.style.width = "1px";
          a11yContainer.style.outline = "0";
          document.body.appendChild(a11yContainer);
          this.a11yContainer = a11yContainer;
        };
        NotyfView2.prototype._announce = function(message) {
          var _this = this;
          this.a11yContainer.textContent = "";
          setTimeout(function() {
            _this.a11yContainer.textContent = message;
          }, 100);
        };
        NotyfView2.prototype._getAnimationEndEventName = function() {
          var el2 = document.createElement("_fake");
          var transitions = {
            MozTransition: "animationend",
            OTransition: "oAnimationEnd",
            WebkitTransition: "webkitAnimationEnd",
            transition: "animationend"
          };
          var t;
          for (t in transitions) {
            if (el2.style[t] !== void 0) {
              return transitions[t];
            }
          }
          return "animationend";
        };
        return NotyfView2;
      }()
    );
    var Notyf = (
      /** @class */
      function() {
        function Notyf2(opts) {
          var _this = this;
          this.dismiss = this._removeNotification;
          this.notifications = new NotyfArray();
          this.view = new NotyfView();
          var types2 = this.registerTypes(opts);
          this.options = __assign(__assign({}, DEFAULT_OPTIONS), opts);
          this.options.types = types2;
          this.notifications.onUpdate(function(elem, type2) {
            return _this.view.update(elem, type2);
          });
          this.view.on(NotyfEvent.Dismiss, function(_a2) {
            var target2 = _a2.target, event = _a2.event;
            _this._removeNotification(target2);
            target2["triggerEvent"](NotyfEvent.Dismiss, event);
          });
          this.view.on(NotyfEvent.Click, function(_a2) {
            var target2 = _a2.target, event = _a2.event;
            return target2["triggerEvent"](NotyfEvent.Click, event);
          });
        }
        Notyf2.prototype.error = function(payload) {
          var options = this.normalizeOptions("error", payload);
          return this.open(options);
        };
        Notyf2.prototype.success = function(payload) {
          var options = this.normalizeOptions("success", payload);
          return this.open(options);
        };
        Notyf2.prototype.open = function(options) {
          var defaultOpts = this.options.types.find(function(_a2) {
            var type2 = _a2.type;
            return type2 === options.type;
          }) || {};
          var config2 = __assign(__assign({}, defaultOpts), options);
          this.assignProps(["ripple", "position", "dismissible"], config2);
          var notification = new NotyfNotification(config2);
          this._pushNotification(notification);
          return notification;
        };
        Notyf2.prototype.dismissAll = function() {
          while (this.notifications.splice(0, 1))
            ;
        };
        Notyf2.prototype.assignProps = function(props, config2) {
          var _this = this;
          props.forEach(function(prop2) {
            config2[prop2] = config2[prop2] == null ? _this.options[prop2] : config2[prop2];
          });
        };
        Notyf2.prototype._pushNotification = function(notification) {
          var _this = this;
          this.notifications.push(notification);
          var duration = notification.options.duration !== void 0 ? notification.options.duration : this.options.duration;
          if (duration) {
            setTimeout(function() {
              return _this._removeNotification(notification);
            }, duration);
          }
        };
        Notyf2.prototype._removeNotification = function(notification) {
          var index = this.notifications.indexOf(notification);
          if (index !== -1) {
            this.notifications.splice(index, 1);
          }
        };
        Notyf2.prototype.normalizeOptions = function(type2, payload) {
          var options = { type: type2 };
          if (typeof payload === "string") {
            options.message = payload;
          } else if (typeof payload === "object") {
            options = __assign(__assign({}, options), payload);
          }
          return options;
        };
        Notyf2.prototype.registerTypes = function(opts) {
          var incomingTypes = (opts && opts.types || []).slice();
          var finalDefaultTypes = DEFAULT_OPTIONS.types.map(function(defaultType) {
            var userTypeIdx = -1;
            incomingTypes.forEach(function(t, idx) {
              if (t.type === defaultType.type)
                userTypeIdx = idx;
            });
            var userType = userTypeIdx !== -1 ? incomingTypes.splice(userTypeIdx, 1)[0] : {};
            return __assign(__assign({}, defaultType), userType);
          });
          return finalDefaultTypes.concat(incomingTypes);
        };
        return Notyf2;
      }()
    );
    /**
    * @vue/shared v3.4.36
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function makeMap(str2, expectsLowerCase) {
      const set2 = new Set(str2.split(","));
      return expectsLowerCase ? (val) => set2.has(val.toLowerCase()) : (val) => set2.has(val);
    }
    const EMPTY_OBJ = {};
    const EMPTY_ARR = [];
    const NOOP = () => {
    };
    const NO = () => false;
    const isOn$1 = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
    (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
    const isModelListener = (key) => key.startsWith("onUpdate:");
    const extend$1 = Object.assign;
    const remove = (arr, el2) => {
      const i2 = arr.indexOf(el2);
      if (i2 > -1) {
        arr.splice(i2, 1);
      }
    };
    const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
    const isArray$1 = Array.isArray;
    const isMap$1 = (val) => toTypeString(val) === "[object Map]";
    const isSet$1 = (val) => toTypeString(val) === "[object Set]";
    const isFunction$1 = (val) => typeof val === "function";
    const isString$1 = (val) => typeof val === "string";
    const isSymbol = (val) => typeof val === "symbol";
    const isObject$4 = (val) => val !== null && typeof val === "object";
    const isPromise = (val) => {
      return (isObject$4(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
    };
    const objectToString = Object.prototype.toString;
    const toTypeString = (value) => objectToString.call(value);
    const toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    const isPlainObject$3 = (val) => toTypeString(val) === "[object Object]";
    const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
    const isReservedProp = /* @__PURE__ */ makeMap(
      // the leading comma is intentional so empty string "" is also included
      ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    );
    const cacheStringFunction = (fn) => {
      const cache2 = /* @__PURE__ */ Object.create(null);
      return (str2) => {
        const hit = cache2[str2];
        return hit || (cache2[str2] = fn(str2));
      };
    };
    const camelizeRE = /-(\w)/g;
    const camelize = cacheStringFunction((str2) => {
      return str2.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
    });
    const hyphenateRE = /\B([A-Z])/g;
    const hyphenate = cacheStringFunction(
      (str2) => str2.replace(hyphenateRE, "-$1").toLowerCase()
    );
    const capitalize = cacheStringFunction((str2) => {
      return str2.charAt(0).toUpperCase() + str2.slice(1);
    });
    const toHandlerKey = cacheStringFunction((str2) => {
      const s = str2 ? `on${capitalize(str2)}` : ``;
      return s;
    });
    const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    const invokeArrayFns = (fns, ...arg) => {
      for (let i2 = 0; i2 < fns.length; i2++) {
        fns[i2](...arg);
      }
    };
    const def$C = (obj, key, value, writable = false) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        writable,
        value
      });
    };
    const looseToNumber = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    };
    const toNumber$1 = (val) => {
      const n = isString$1(val) ? Number(val) : NaN;
      return isNaN(n) ? val : n;
    };
    let _globalThis;
    const getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    function normalizeStyle(value) {
      if (isArray$1(value)) {
        const res = {};
        for (let i2 = 0; i2 < value.length; i2++) {
          const item = value[i2];
          const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isString$1(value) || isObject$4(value)) {
        return value;
      }
    }
    const listDelimiterRE = /;(?![^(]*\))/g;
    const propertyDelimiterRE = /:([^]+)/;
    const styleCommentRE = /\/\*[^]*?\*\//g;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString$1(value)) {
        res = value;
      } else if (isArray$1(value)) {
        for (let i2 = 0; i2 < value.length; i2++) {
          const normalized = normalizeClass(value[i2]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject$4(value)) {
        for (const name in value) {
          if (value[name]) {
            res += name + " ";
          }
        }
      }
      return res.trim();
    }
    function normalizeProps(props) {
      if (!props)
        return null;
      let { class: klass, style } = props;
      if (klass && !isString$1(klass)) {
        props.class = normalizeClass(klass);
      }
      if (style) {
        props.style = normalizeStyle(style);
      }
      return props;
    }
    const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    const isRef$1 = (val) => {
      return !!(val && val.__v_isRef === true);
    };
    const toDisplayString = (val) => {
      return isString$1(val) ? val : val == null ? "" : isArray$1(val) || isObject$4(val) && (val.toString === objectToString || !isFunction$1(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
    };
    const replacer = (_key, val) => {
      if (isRef$1(val)) {
        return replacer(_key, val.value);
      } else if (isMap$1(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce(
            (entries, [key, val2], i2) => {
              entries[stringifySymbol(key, i2) + " =>"] = val2;
              return entries;
            },
            {}
          )
        };
      } else if (isSet$1(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
        };
      } else if (isSymbol(val)) {
        return stringifySymbol(val);
      } else if (isObject$4(val) && !isArray$1(val) && !isPlainObject$3(val)) {
        return String(val);
      }
      return val;
    };
    const stringifySymbol = (v, i2 = "") => {
      var _a2;
      return (
        // Symbol.description in es2019+ so we need to cast here to pass
        // the lib: es2016 check
        isSymbol(v) ? `Symbol(${(_a2 = v.description) != null ? _a2 : i2})` : v
      );
    };
    /**
    * @vue/reactivity v3.4.36
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    let activeEffectScope;
    class EffectScope {
      constructor(detached = false) {
        this.detached = detached;
        this._active = true;
        this.effects = [];
        this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
          this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
            this
          ) - 1;
        }
      }
      get active() {
        return this._active;
      }
      run(fn) {
        if (this._active) {
          const currentEffectScope = activeEffectScope;
          try {
            activeEffectScope = this;
            return fn();
          } finally {
            activeEffectScope = currentEffectScope;
          }
        }
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      on() {
        activeEffectScope = this;
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      off() {
        activeEffectScope = this.parent;
      }
      stop(fromParent) {
        if (this._active) {
          let i2, l;
          for (i2 = 0, l = this.effects.length; i2 < l; i2++) {
            this.effects[i2].stop();
          }
          for (i2 = 0, l = this.cleanups.length; i2 < l; i2++) {
            this.cleanups[i2]();
          }
          if (this.scopes) {
            for (i2 = 0, l = this.scopes.length; i2 < l; i2++) {
              this.scopes[i2].stop(true);
            }
          }
          if (!this.detached && this.parent && !fromParent) {
            const last = this.parent.scopes.pop();
            if (last && last !== this) {
              this.parent.scopes[this.index] = last;
              last.index = this.index;
            }
          }
          this.parent = void 0;
          this._active = false;
        }
      }
    }
    function effectScope(detached) {
      return new EffectScope(detached);
    }
    function recordEffectScope(effect2, scope2 = activeEffectScope) {
      if (scope2 && scope2.active) {
        scope2.effects.push(effect2);
      }
    }
    function getCurrentScope$1() {
      return activeEffectScope;
    }
    function onScopeDispose(fn) {
      if (activeEffectScope) {
        activeEffectScope.cleanups.push(fn);
      }
    }
    let activeEffect;
    class ReactiveEffect {
      constructor(fn, trigger2, scheduler, scope2) {
        this.fn = fn;
        this.trigger = trigger2;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        this._dirtyLevel = 4;
        this._trackId = 0;
        this._runnings = 0;
        this._shouldSchedule = false;
        this._depsLength = 0;
        recordEffectScope(this, scope2);
      }
      get dirty() {
        if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
          this._dirtyLevel = 1;
          pauseTracking();
          for (let i2 = 0; i2 < this._depsLength; i2++) {
            const dep = this.deps[i2];
            if (dep.computed) {
              triggerComputed(dep.computed);
              if (this._dirtyLevel >= 4) {
                break;
              }
            }
          }
          if (this._dirtyLevel === 1) {
            this._dirtyLevel = 0;
          }
          resetTracking();
        }
        return this._dirtyLevel >= 4;
      }
      set dirty(v) {
        this._dirtyLevel = v ? 4 : 0;
      }
      run() {
        this._dirtyLevel = 0;
        if (!this.active) {
          return this.fn();
        }
        let lastShouldTrack = shouldTrack;
        let lastEffect = activeEffect;
        try {
          shouldTrack = true;
          activeEffect = this;
          this._runnings++;
          preCleanupEffect(this);
          return this.fn();
        } finally {
          postCleanupEffect(this);
          this._runnings--;
          activeEffect = lastEffect;
          shouldTrack = lastShouldTrack;
        }
      }
      stop() {
        if (this.active) {
          preCleanupEffect(this);
          postCleanupEffect(this);
          this.onStop && this.onStop();
          this.active = false;
        }
      }
    }
    function triggerComputed(computed2) {
      return computed2.value;
    }
    function preCleanupEffect(effect2) {
      effect2._trackId++;
      effect2._depsLength = 0;
    }
    function postCleanupEffect(effect2) {
      if (effect2.deps.length > effect2._depsLength) {
        for (let i2 = effect2._depsLength; i2 < effect2.deps.length; i2++) {
          cleanupDepEffect(effect2.deps[i2], effect2);
        }
        effect2.deps.length = effect2._depsLength;
      }
    }
    function cleanupDepEffect(dep, effect2) {
      const trackId = dep.get(effect2);
      if (trackId !== void 0 && effect2._trackId !== trackId) {
        dep.delete(effect2);
        if (dep.size === 0) {
          dep.cleanup();
        }
      }
    }
    let shouldTrack = true;
    let pauseScheduleStack = 0;
    const trackStack = [];
    function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
    }
    function resetTracking() {
      const last = trackStack.pop();
      shouldTrack = last === void 0 ? true : last;
    }
    function pauseScheduling() {
      pauseScheduleStack++;
    }
    function resetScheduling() {
      pauseScheduleStack--;
      while (!pauseScheduleStack && queueEffectSchedulers.length) {
        queueEffectSchedulers.shift()();
      }
    }
    function trackEffect(effect2, dep, debuggerEventExtraInfo) {
      if (dep.get(effect2) !== effect2._trackId) {
        dep.set(effect2, effect2._trackId);
        const oldDep = effect2.deps[effect2._depsLength];
        if (oldDep !== dep) {
          if (oldDep) {
            cleanupDepEffect(oldDep, effect2);
          }
          effect2.deps[effect2._depsLength++] = dep;
        } else {
          effect2._depsLength++;
        }
      }
    }
    const queueEffectSchedulers = [];
    function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
      pauseScheduling();
      for (const effect2 of dep.keys()) {
        let tracking;
        if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
          effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
          effect2._dirtyLevel = dirtyLevel;
        }
        if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
          effect2.trigger();
          if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
            effect2._shouldSchedule = false;
            if (effect2.scheduler) {
              queueEffectSchedulers.push(effect2.scheduler);
            }
          }
        }
      }
      resetScheduling();
    }
    const createDep = (cleanup, computed2) => {
      const dep = /* @__PURE__ */ new Map();
      dep.cleanup = cleanup;
      dep.computed = computed2;
      return dep;
    };
    const targetMap = /* @__PURE__ */ new WeakMap();
    const ITERATE_KEY = Symbol("");
    const MAP_KEY_ITERATE_KEY = Symbol("");
    function track(target2, type2, key) {
      if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target2);
        if (!depsMap) {
          targetMap.set(target2, depsMap = /* @__PURE__ */ new Map());
        }
        let dep = depsMap.get(key);
        if (!dep) {
          depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
        }
        trackEffect(
          activeEffect,
          dep
        );
      }
    }
    function trigger(target2, type2, key, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target2);
      if (!depsMap) {
        return;
      }
      let deps = [];
      if (type2 === "clear") {
        deps = [...depsMap.values()];
      } else if (key === "length" && isArray$1(target2)) {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || !isSymbol(key2) && key2 >= newLength) {
            deps.push(dep);
          }
        });
      } else {
        if (key !== void 0) {
          deps.push(depsMap.get(key));
        }
        switch (type2) {
          case "add":
            if (!isArray$1(target2)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap$1(target2)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isIntegerKey(key)) {
              deps.push(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!isArray$1(target2)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap$1(target2)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap$1(target2)) {
              deps.push(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
      pauseScheduling();
      for (const dep of deps) {
        if (dep) {
          triggerEffects(
            dep,
            4
          );
        }
      }
      resetScheduling();
    }
    function getDepFromReactive(object, key) {
      const depsMap = targetMap.get(object);
      return depsMap && depsMap.get(key);
    }
    const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
    const builtInSymbols = new Set(
      /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
    );
    const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
    function createArrayInstrumentations() {
      const instrumentations = {};
      ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
        instrumentations[key] = function(...args) {
          const arr = toRaw(this);
          for (let i2 = 0, l = this.length; i2 < l; i2++) {
            track(arr, "get", i2 + "");
          }
          const res = arr[key](...args);
          if (res === -1 || res === false) {
            return arr[key](...args.map(toRaw));
          } else {
            return res;
          }
        };
      });
      ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
        instrumentations[key] = function(...args) {
          pauseTracking();
          pauseScheduling();
          const res = toRaw(this)[key].apply(this, args);
          resetScheduling();
          resetTracking();
          return res;
        };
      });
      return instrumentations;
    }
    function hasOwnProperty(key) {
      if (!isSymbol(key))
        key = String(key);
      const obj = toRaw(this);
      track(obj, "has", key);
      return obj.hasOwnProperty(key);
    }
    class BaseReactiveHandler {
      constructor(_isReadonly = false, _isShallow = false) {
        this._isReadonly = _isReadonly;
        this._isShallow = _isShallow;
      }
      get(target2, key, receiver) {
        const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_isShallow") {
          return isShallow2;
        } else if (key === "__v_raw") {
          if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target2) || // receiver is not the reactive proxy, but has the same prototype
          // this means the reciever is a user proxy of the reactive proxy
          Object.getPrototypeOf(target2) === Object.getPrototypeOf(receiver)) {
            return target2;
          }
          return;
        }
        const targetIsArray = isArray$1(target2);
        if (!isReadonly2) {
          if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
            return Reflect.get(arrayInstrumentations, key, receiver);
          }
          if (key === "hasOwnProperty") {
            return hasOwnProperty;
          }
        }
        const res = Reflect.get(target2, key, receiver);
        if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
          return res;
        }
        if (!isReadonly2) {
          track(target2, "get", key);
        }
        if (isShallow2) {
          return res;
        }
        if (isRef(res)) {
          return targetIsArray && isIntegerKey(key) ? res : res.value;
        }
        if (isObject$4(res)) {
          return isReadonly2 ? readonly(res) : reactive(res);
        }
        return res;
      }
    }
    class MutableReactiveHandler extends BaseReactiveHandler {
      constructor(isShallow2 = false) {
        super(false, isShallow2);
      }
      set(target2, key, value, receiver) {
        let oldValue = target2[key];
        if (!this._isShallow) {
          const isOldValueReadonly = isReadonly(oldValue);
          if (!isShallow(value) && !isReadonly(value)) {
            oldValue = toRaw(oldValue);
            value = toRaw(value);
          }
          if (!isArray$1(target2) && isRef(oldValue) && !isRef(value)) {
            if (isOldValueReadonly) {
              return false;
            } else {
              oldValue.value = value;
              return true;
            }
          }
        }
        const hadKey = isArray$1(target2) && isIntegerKey(key) ? Number(key) < target2.length : hasOwn(target2, key);
        const result = Reflect.set(target2, key, value, receiver);
        if (target2 === toRaw(receiver)) {
          if (!hadKey) {
            trigger(target2, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger(target2, "set", key, value);
          }
        }
        return result;
      }
      deleteProperty(target2, key) {
        const hadKey = hasOwn(target2, key);
        target2[key];
        const result = Reflect.deleteProperty(target2, key);
        if (result && hadKey) {
          trigger(target2, "delete", key, void 0);
        }
        return result;
      }
      has(target2, key) {
        const result = Reflect.has(target2, key);
        if (!isSymbol(key) || !builtInSymbols.has(key)) {
          track(target2, "has", key);
        }
        return result;
      }
      ownKeys(target2) {
        track(
          target2,
          "iterate",
          isArray$1(target2) ? "length" : ITERATE_KEY
        );
        return Reflect.ownKeys(target2);
      }
    }
    class ReadonlyReactiveHandler extends BaseReactiveHandler {
      constructor(isShallow2 = false) {
        super(true, isShallow2);
      }
      set(target2, key) {
        return true;
      }
      deleteProperty(target2, key) {
        return true;
      }
    }
    const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
    const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
    const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
      true
    );
    const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
    const toShallow = (value) => value;
    const getProto = (v) => Reflect.getPrototypeOf(v);
    function get(target2, key, isReadonly2 = false, isShallow2 = false) {
      target2 = target2["__v_raw"];
      const rawTarget = toRaw(target2);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has: has2 } = getProto(rawTarget);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      if (has2.call(rawTarget, key)) {
        return wrap(target2.get(key));
      } else if (has2.call(rawTarget, rawKey)) {
        return wrap(target2.get(rawKey));
      } else if (target2 !== rawTarget) {
        target2.get(key);
      }
    }
    function has$3(key, isReadonly2 = false) {
      const target2 = this["__v_raw"];
      const rawTarget = toRaw(target2);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target2.has(key) : target2.has(key) || target2.has(rawKey);
    }
    function size(target2, isReadonly2 = false) {
      target2 = target2["__v_raw"];
      !isReadonly2 && track(toRaw(target2), "iterate", ITERATE_KEY);
      return Reflect.get(target2, "size", target2);
    }
    function add(value, _isShallow = false) {
      if (!_isShallow && !isShallow(value) && !isReadonly(value)) {
        value = toRaw(value);
      }
      const target2 = toRaw(this);
      const proto = getProto(target2);
      const hadKey = proto.has.call(target2, value);
      if (!hadKey) {
        target2.add(value);
        trigger(target2, "add", value, value);
      }
      return this;
    }
    function set$3(key, value, _isShallow = false) {
      if (!_isShallow && !isShallow(value) && !isReadonly(value)) {
        value = toRaw(value);
      }
      const target2 = toRaw(this);
      const { has: has2, get: get2 } = getProto(target2);
      let hadKey = has2.call(target2, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target2, key);
      }
      const oldValue = get2.call(target2, key);
      target2.set(key, value);
      if (!hadKey) {
        trigger(target2, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target2, "set", key, value);
      }
      return this;
    }
    function deleteEntry(key) {
      const target2 = toRaw(this);
      const { has: has2, get: get2 } = getProto(target2);
      let hadKey = has2.call(target2, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target2, key);
      }
      get2 ? get2.call(target2, key) : void 0;
      const result = target2.delete(key);
      if (hadKey) {
        trigger(target2, "delete", key, void 0);
      }
      return result;
    }
    function clear() {
      const target2 = toRaw(this);
      const hadItems = target2.size !== 0;
      const result = target2.clear();
      if (hadItems) {
        trigger(target2, "clear", void 0, void 0);
      }
      return result;
    }
    function createForEach(isReadonly2, isShallow2) {
      return function forEach(callback, thisArg) {
        const observed = this;
        const target2 = observed["__v_raw"];
        const rawTarget = toRaw(target2);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target2.forEach((value, key) => {
          return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
      };
    }
    function createIterableMethod(method, isReadonly2, isShallow2) {
      return function(...args) {
        const target2 = this["__v_raw"];
        const rawTarget = toRaw(target2);
        const targetIsMap = isMap$1(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target2[method](...args);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(
          rawTarget,
          "iterate",
          isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
        );
        return {
          // iterator protocol
          next() {
            const { value, done } = innerIterator.next();
            return done ? { value, done } : {
              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
              done
            };
          },
          // iterable protocol
          [Symbol.iterator]() {
            return this;
          }
        };
      };
    }
    function createReadonlyMethod(type2) {
      return function(...args) {
        return type2 === "delete" ? false : type2 === "clear" ? void 0 : this;
      };
    }
    function createInstrumentations() {
      const mutableInstrumentations2 = {
        get(key) {
          return get(this, key);
        },
        get size() {
          return size(this);
        },
        has: has$3,
        add,
        set: set$3,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
      };
      const shallowInstrumentations2 = {
        get(key) {
          return get(this, key, false, true);
        },
        get size() {
          return size(this);
        },
        has: has$3,
        add(value) {
          return add.call(this, value, true);
        },
        set(key, value) {
          return set$3.call(this, key, value, true);
        },
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
      };
      const readonlyInstrumentations2 = {
        get(key) {
          return get(this, key, true);
        },
        get size() {
          return size(this, true);
        },
        has(key) {
          return has$3.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, false)
      };
      const shallowReadonlyInstrumentations2 = {
        get(key) {
          return get(this, key, true, true);
        },
        get size() {
          return size(this, true);
        },
        has(key) {
          return has$3.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, true)
      };
      const iteratorMethods = [
        "keys",
        "values",
        "entries",
        Symbol.iterator
      ];
      iteratorMethods.forEach((method) => {
        mutableInstrumentations2[method] = createIterableMethod(method, false, false);
        readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
        shallowInstrumentations2[method] = createIterableMethod(method, false, true);
        shallowReadonlyInstrumentations2[method] = createIterableMethod(
          method,
          true,
          true
        );
      });
      return [
        mutableInstrumentations2,
        readonlyInstrumentations2,
        shallowInstrumentations2,
        shallowReadonlyInstrumentations2
      ];
    }
    const [
      mutableInstrumentations,
      readonlyInstrumentations,
      shallowInstrumentations,
      shallowReadonlyInstrumentations
    ] = /* @__PURE__ */ createInstrumentations();
    function createInstrumentationGetter(isReadonly2, shallow) {
      const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
      return (target2, key, receiver) => {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_raw") {
          return target2;
        }
        return Reflect.get(
          hasOwn(instrumentations, key) && key in target2 ? instrumentations : target2,
          key,
          receiver
        );
      };
    }
    const mutableCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, false)
    };
    const shallowCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, true)
    };
    const readonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, false)
    };
    const shallowReadonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, true)
    };
    const reactiveMap = /* @__PURE__ */ new WeakMap();
    const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
    const readonlyMap = /* @__PURE__ */ new WeakMap();
    const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
    function targetTypeMap(rawType) {
      switch (rawType) {
        case "Object":
        case "Array":
          return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
          return 2;
        default:
          return 0;
      }
    }
    function getTargetType(value) {
      return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
    }
    function reactive(target2) {
      if (isReadonly(target2)) {
        return target2;
      }
      return createReactiveObject(
        target2,
        false,
        mutableHandlers,
        mutableCollectionHandlers,
        reactiveMap
      );
    }
    function shallowReactive(target2) {
      return createReactiveObject(
        target2,
        false,
        shallowReactiveHandlers,
        shallowCollectionHandlers,
        shallowReactiveMap
      );
    }
    function readonly(target2) {
      return createReactiveObject(
        target2,
        true,
        readonlyHandlers,
        readonlyCollectionHandlers,
        readonlyMap
      );
    }
    function shallowReadonly(target2) {
      return createReactiveObject(
        target2,
        true,
        shallowReadonlyHandlers,
        shallowReadonlyCollectionHandlers,
        shallowReadonlyMap
      );
    }
    function createReactiveObject(target2, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
      if (!isObject$4(target2)) {
        return target2;
      }
      if (target2["__v_raw"] && !(isReadonly2 && target2["__v_isReactive"])) {
        return target2;
      }
      const existingProxy = proxyMap.get(target2);
      if (existingProxy) {
        return existingProxy;
      }
      const targetType = getTargetType(target2);
      if (targetType === 0) {
        return target2;
      }
      const proxy = new Proxy(
        target2,
        targetType === 2 ? collectionHandlers : baseHandlers
      );
      proxyMap.set(target2, proxy);
      return proxy;
    }
    function isReactive(value) {
      if (isReadonly(value)) {
        return isReactive(value["__v_raw"]);
      }
      return !!(value && value["__v_isReactive"]);
    }
    function isReadonly(value) {
      return !!(value && value["__v_isReadonly"]);
    }
    function isShallow(value) {
      return !!(value && value["__v_isShallow"]);
    }
    function isProxy(value) {
      return value ? !!value["__v_raw"] : false;
    }
    function toRaw(observed) {
      const raw = observed && observed["__v_raw"];
      return raw ? toRaw(raw) : observed;
    }
    function markRaw(value) {
      if (Object.isExtensible(value)) {
        def$C(value, "__v_skip", true);
      }
      return value;
    }
    const toReactive = (value) => isObject$4(value) ? reactive(value) : value;
    const toReadonly = (value) => isObject$4(value) ? readonly(value) : value;
    class ComputedRefImpl {
      constructor(getter, _setter, isReadonly2, isSSR) {
        this.getter = getter;
        this._setter = _setter;
        this.dep = void 0;
        this.__v_isRef = true;
        this["__v_isReadonly"] = false;
        this.effect = new ReactiveEffect(
          () => getter(this._value),
          () => triggerRefValue(
            this,
            this.effect._dirtyLevel === 2 ? 2 : 3
          )
        );
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly"] = isReadonly2;
      }
      get value() {
        const self2 = toRaw(this);
        if ((!self2._cacheable || self2.effect.dirty) && hasChanged(self2._value, self2._value = self2.effect.run())) {
          triggerRefValue(self2, 4);
        }
        trackRefValue(self2);
        if (self2.effect._dirtyLevel >= 2) {
          triggerRefValue(self2, 2);
        }
        return self2._value;
      }
      set value(newValue) {
        this._setter(newValue);
      }
      // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
      get _dirty() {
        return this.effect.dirty;
      }
      set _dirty(v) {
        this.effect.dirty = v;
      }
      // #endregion
    }
    function computed$1(getterOrOptions, debugOptions, isSSR = false) {
      let getter;
      let setter;
      const onlyGetter = isFunction$1(getterOrOptions);
      if (onlyGetter) {
        getter = getterOrOptions;
        setter = NOOP;
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
      return cRef;
    }
    function trackRefValue(ref2) {
      var _a2;
      if (shouldTrack && activeEffect) {
        ref2 = toRaw(ref2);
        trackEffect(
          activeEffect,
          (_a2 = ref2.dep) != null ? _a2 : ref2.dep = createDep(
            () => ref2.dep = void 0,
            ref2 instanceof ComputedRefImpl ? ref2 : void 0
          )
        );
      }
    }
    function triggerRefValue(ref2, dirtyLevel = 4, newVal, oldVal) {
      ref2 = toRaw(ref2);
      const dep = ref2.dep;
      if (dep) {
        triggerEffects(
          dep,
          dirtyLevel
        );
      }
    }
    function isRef(r2) {
      return !!(r2 && r2.__v_isRef === true);
    }
    function ref$1(value) {
      return createRef(value, false);
    }
    function shallowRef(value) {
      return createRef(value, true);
    }
    function createRef(rawValue, shallow) {
      if (isRef(rawValue)) {
        return rawValue;
      }
      return new RefImpl(rawValue, shallow);
    }
    class RefImpl {
      constructor(value, __v_isShallow) {
        this.__v_isShallow = __v_isShallow;
        this.dep = void 0;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
      }
      get value() {
        trackRefValue(this);
        return this._value;
      }
      set value(newVal) {
        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
        newVal = useDirectValue ? newVal : toRaw(newVal);
        if (hasChanged(newVal, this._rawValue)) {
          this._rawValue;
          this._rawValue = newVal;
          this._value = useDirectValue ? newVal : toReactive(newVal);
          triggerRefValue(this, 4);
        }
      }
    }
    function unref(ref2) {
      return isRef(ref2) ? ref2.value : ref2;
    }
    function toValue$1(source2) {
      return isFunction$1(source2) ? source2() : unref(source2);
    }
    const shallowUnwrapHandlers = {
      get: (target2, key, receiver) => unref(Reflect.get(target2, key, receiver)),
      set: (target2, key, value, receiver) => {
        const oldValue = target2[key];
        if (isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target2, key, value, receiver);
        }
      }
    };
    function proxyRefs(objectWithRefs) {
      return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
    }
    class CustomRefImpl {
      constructor(factory) {
        this.dep = void 0;
        this.__v_isRef = true;
        const { get: get2, set: set2 } = factory(
          () => trackRefValue(this),
          () => triggerRefValue(this)
        );
        this._get = get2;
        this._set = set2;
      }
      get value() {
        return this._get();
      }
      set value(newVal) {
        this._set(newVal);
      }
    }
    function customRef(factory) {
      return new CustomRefImpl(factory);
    }
    function toRefs(object) {
      const ret = isArray$1(object) ? new Array(object.length) : {};
      for (const key in object) {
        ret[key] = propertyToRef(object, key);
      }
      return ret;
    }
    class ObjectRefImpl {
      constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
      }
      get value() {
        const val = this._object[this._key];
        return val === void 0 ? this._defaultValue : val;
      }
      set value(newVal) {
        this._object[this._key] = newVal;
      }
      get dep() {
        return getDepFromReactive(toRaw(this._object), this._key);
      }
    }
    class GetterRefImpl {
      constructor(_getter) {
        this._getter = _getter;
        this.__v_isRef = true;
        this.__v_isReadonly = true;
      }
      get value() {
        return this._getter();
      }
    }
    function toRef(source2, key, defaultValue) {
      if (isRef(source2)) {
        return source2;
      } else if (isFunction$1(source2)) {
        return new GetterRefImpl(source2);
      } else if (isObject$4(source2) && arguments.length > 1) {
        return propertyToRef(source2, key, defaultValue);
      } else {
        return ref$1(source2);
      }
    }
    function propertyToRef(source2, key, defaultValue) {
      const val = source2[key];
      return isRef(val) ? val : new ObjectRefImpl(source2, key, defaultValue);
    }
    /**
    * @vue/runtime-core v3.4.36
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    const stack = [];
    let isWarning = false;
    function warn$1(msg, ...args) {
      if (isWarning)
        return;
      isWarning = true;
      pauseTracking();
      const instance = stack.length ? stack[stack.length - 1].component : null;
      const appWarnHandler = instance && instance.appContext.config.warnHandler;
      const trace = getComponentTrace();
      if (appWarnHandler) {
        callWithErrorHandling(
          appWarnHandler,
          instance,
          11,
          [
            // eslint-disable-next-line no-restricted-syntax
            msg + args.map((a) => {
              var _a2, _b;
              return (_b = (_a2 = a.toString) == null ? void 0 : _a2.call(a)) != null ? _b : JSON.stringify(a);
            }).join(""),
            instance && instance.proxy,
            trace.map(
              ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
            ).join("\n"),
            trace
          ]
        );
      } else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        if (trace.length && // avoid spamming console during tests
        true) {
          warnArgs.push(`
`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
      }
      resetTracking();
      isWarning = false;
    }
    function getComponentTrace() {
      let currentVNode = stack[stack.length - 1];
      if (!currentVNode) {
        return [];
      }
      const normalizedStack = [];
      while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
          last.recurseCount++;
        } else {
          normalizedStack.push({
            vnode: currentVNode,
            recurseCount: 0
          });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
      }
      return normalizedStack;
    }
    function formatTrace(trace) {
      const logs = [];
      trace.forEach((entry, i2) => {
        logs.push(...i2 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
      });
      return logs;
    }
    function formatTraceEntry({ vnode, recurseCount }) {
      const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
      const isRoot = vnode.component ? vnode.component.parent == null : false;
      const open = ` at <${formatComponentName(
        vnode.component,
        vnode.type,
        isRoot
      )}`;
      const close = `>` + postfix;
      return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
    }
    function formatProps(props) {
      const res = [];
      const keys2 = Object.keys(props);
      keys2.slice(0, 3).forEach((key) => {
        res.push(...formatProp(key, props[key]));
      });
      if (keys2.length > 3) {
        res.push(` ...`);
      }
      return res;
    }
    function formatProp(key, value, raw) {
      if (isString$1(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
      } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
        return raw ? value : [`${key}=${value}`];
      } else if (isRef(value)) {
        value = formatProp(key, toRaw(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
      } else if (isFunction$1(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
      } else {
        value = toRaw(value);
        return raw ? value : [`${key}=`, value];
      }
    }
    function callWithErrorHandling(fn, instance, type2, args) {
      try {
        return args ? fn(...args) : fn();
      } catch (err) {
        handleError(err, instance, type2);
      }
    }
    function callWithAsyncErrorHandling(fn, instance, type2, args) {
      if (isFunction$1(fn)) {
        const res = callWithErrorHandling(fn, instance, type2, args);
        if (res && isPromise(res)) {
          res.catch((err) => {
            handleError(err, instance, type2);
          });
        }
        return res;
      }
      if (isArray$1(fn)) {
        const values = [];
        for (let i2 = 0; i2 < fn.length; i2++) {
          values.push(callWithAsyncErrorHandling(fn[i2], instance, type2, args));
        }
        return values;
      }
    }
    function handleError(err, instance, type2, throwInDev = true) {
      const contextVNode = instance ? instance.vnode : null;
      if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = `https://vuejs.org/error-reference/#runtime-${type2}`;
        while (cur) {
          const errorCapturedHooks = cur.ec;
          if (errorCapturedHooks) {
            for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
              if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
                return;
              }
            }
          }
          cur = cur.parent;
        }
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
          pauseTracking();
          callWithErrorHandling(
            appErrorHandler,
            null,
            10,
            [err, exposedInstance, errorInfo]
          );
          resetTracking();
          return;
        }
      }
      logError(err, type2, contextVNode, throwInDev);
    }
    function logError(err, type2, contextVNode, throwInDev = true) {
      {
        console.error(err);
      }
    }
    let isFlushing = false;
    let isFlushPending = false;
    const queue = [];
    let flushIndex = 0;
    const pendingPostFlushCbs = [];
    let activePostFlushCbs = null;
    let postFlushIndex = 0;
    const resolvedPromise = /* @__PURE__ */ Promise.resolve();
    let currentFlushPromise = null;
    function nextTick(fn) {
      const p2 = currentFlushPromise || resolvedPromise;
      return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
    }
    function findInsertionIndex$1(id2) {
      let start = flushIndex + 1;
      let end = queue.length;
      while (start < end) {
        const middle = start + end >>> 1;
        const middleJob = queue[middle];
        const middleJobId = getId(middleJob);
        if (middleJobId < id2 || middleJobId === id2 && middleJob.pre) {
          start = middle + 1;
        } else {
          end = middle;
        }
      }
      return start;
    }
    function queueJob(job) {
      if (!queue.length || !queue.includes(
        job,
        isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
      )) {
        if (job.id == null) {
          queue.push(job);
        } else {
          queue.splice(findInsertionIndex$1(job.id), 0, job);
        }
        queueFlush();
      }
    }
    function queueFlush() {
      if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
      }
    }
    function invalidateJob(job) {
      const i2 = queue.indexOf(job);
      if (i2 > flushIndex) {
        queue.splice(i2, 1);
      }
    }
    function queuePostFlushCb(cb) {
      if (!isArray$1(cb)) {
        if (!activePostFlushCbs || !activePostFlushCbs.includes(
          cb,
          cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
        )) {
          pendingPostFlushCbs.push(cb);
        }
      } else {
        pendingPostFlushCbs.push(...cb);
      }
      queueFlush();
    }
    function flushPreFlushCbs(instance, seen, i2 = isFlushing ? flushIndex + 1 : 0) {
      for (; i2 < queue.length; i2++) {
        const cb = queue[i2];
        if (cb && cb.pre) {
          if (instance && cb.id !== instance.uid) {
            continue;
          }
          queue.splice(i2, 1);
          i2--;
          cb();
        }
      }
    }
    function flushPostFlushCbs(seen) {
      if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)].sort(
          (a, b) => getId(a) - getId(b)
        );
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
          activePostFlushCbs.push(...deduped);
          return;
        }
        activePostFlushCbs = deduped;
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
          const cb = activePostFlushCbs[postFlushIndex];
          if (cb.active !== false)
            cb();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
      }
    }
    const getId = (job) => job.id == null ? Infinity : job.id;
    const comparator = (a, b) => {
      const diff = getId(a) - getId(b);
      if (diff === 0) {
        if (a.pre && !b.pre)
          return -1;
        if (b.pre && !a.pre)
          return 1;
      }
      return diff;
    };
    function flushJobs(seen) {
      isFlushPending = false;
      isFlushing = true;
      queue.sort(comparator);
      try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job && job.active !== false) {
            if (false)
              ;
            callWithErrorHandling(
              job,
              job.i,
              job.i ? 15 : 14
            );
          }
        }
      } finally {
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs();
        isFlushing = false;
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) {
          flushJobs();
        }
      }
    }
    let currentRenderingInstance = null;
    let currentScopeId = null;
    function setCurrentRenderingInstance(instance) {
      const prev = currentRenderingInstance;
      currentRenderingInstance = instance;
      currentScopeId = instance && instance.type.__scopeId || null;
      return prev;
    }
    function pushScopeId(id2) {
      currentScopeId = id2;
    }
    function popScopeId() {
      currentScopeId = null;
    }
    function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
      if (!ctx)
        return fn;
      if (fn._n) {
        return fn;
      }
      const renderFnWithContext = (...args) => {
        if (renderFnWithContext._d) {
          setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx);
        let res;
        try {
          res = fn(...args);
        } finally {
          setCurrentRenderingInstance(prevInstance);
          if (renderFnWithContext._d) {
            setBlockTracking(1);
          }
        }
        return res;
      };
      renderFnWithContext._n = true;
      renderFnWithContext._c = true;
      renderFnWithContext._d = true;
      return renderFnWithContext;
    }
    function withDirectives(vnode, directives) {
      if (currentRenderingInstance === null) {
        return vnode;
      }
      const instance = getComponentPublicInstance(currentRenderingInstance);
      const bindings = vnode.dirs || (vnode.dirs = []);
      for (let i2 = 0; i2 < directives.length; i2++) {
        let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i2];
        if (dir) {
          if (isFunction$1(dir)) {
            dir = {
              mounted: dir,
              updated: dir
            };
          }
          if (dir.deep) {
            traverse$2(value);
          }
          bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
          });
        }
      }
      return vnode;
    }
    function invokeDirectiveHook(vnode, prevVNode, instance, name) {
      const bindings = vnode.dirs;
      const oldBindings = prevVNode && prevVNode.dirs;
      for (let i2 = 0; i2 < bindings.length; i2++) {
        const binding = bindings[i2];
        if (oldBindings) {
          binding.oldValue = oldBindings[i2].value;
        }
        let hook = binding.dir[name];
        if (hook) {
          pauseTracking();
          callWithAsyncErrorHandling(hook, instance, 8, [
            vnode.el,
            binding,
            vnode,
            prevVNode
          ]);
          resetTracking();
        }
      }
    }
    const leaveCbKey = Symbol("_leaveCb");
    const enterCbKey$1 = Symbol("_enterCb");
    function useTransitionState() {
      const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
      };
      onMounted(() => {
        state.isMounted = true;
      });
      onBeforeUnmount(() => {
        state.isUnmounting = true;
      });
      return state;
    }
    const TransitionHookValidator = [Function, Array];
    const BaseTransitionPropsValidators = {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      // enter
      onBeforeEnter: TransitionHookValidator,
      onEnter: TransitionHookValidator,
      onAfterEnter: TransitionHookValidator,
      onEnterCancelled: TransitionHookValidator,
      // leave
      onBeforeLeave: TransitionHookValidator,
      onLeave: TransitionHookValidator,
      onAfterLeave: TransitionHookValidator,
      onLeaveCancelled: TransitionHookValidator,
      // appear
      onBeforeAppear: TransitionHookValidator,
      onAppear: TransitionHookValidator,
      onAfterAppear: TransitionHookValidator,
      onAppearCancelled: TransitionHookValidator
    };
    const recursiveGetSubtree = (instance) => {
      const subTree = instance.subTree;
      return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
    };
    const BaseTransitionImpl = {
      name: `BaseTransition`,
      props: BaseTransitionPropsValidators,
      setup(props, { slots }) {
        const instance = getCurrentInstance$1();
        const state = useTransitionState();
        return () => {
          const children = slots.default && getTransitionRawChildren(slots.default(), true);
          if (!children || !children.length) {
            return;
          }
          let child = children[0];
          if (children.length > 1) {
            for (const c of children) {
              if (c.type !== Comment) {
                child = c;
                break;
              }
            }
          }
          const rawProps = toRaw(props);
          const { mode } = rawProps;
          if (state.isLeaving) {
            return emptyPlaceholder(child);
          }
          const innerChild = getKeepAliveChild(child);
          if (!innerChild) {
            return emptyPlaceholder(child);
          }
          let enterHooks = resolveTransitionHooks(
            innerChild,
            rawProps,
            state,
            instance,
            // #11061, ensure enterHooks is fresh after clone
            (hooks) => enterHooks = hooks
          );
          setTransitionHooks(innerChild, enterHooks);
          const oldChild = instance.subTree;
          const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
          if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
            const leavingHooks = resolveTransitionHooks(
              oldInnerChild,
              rawProps,
              state,
              instance
            );
            setTransitionHooks(oldInnerChild, leavingHooks);
            if (mode === "out-in" && innerChild.type !== Comment) {
              state.isLeaving = true;
              leavingHooks.afterLeave = () => {
                state.isLeaving = false;
                if (instance.update.active !== false) {
                  instance.effect.dirty = true;
                  instance.update();
                }
              };
              return emptyPlaceholder(child);
            } else if (mode === "in-out" && innerChild.type !== Comment) {
              leavingHooks.delayLeave = (el2, earlyRemove, delayedLeave) => {
                const leavingVNodesCache = getLeavingNodesForType(
                  state,
                  oldInnerChild
                );
                leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                el2[leaveCbKey] = () => {
                  earlyRemove();
                  el2[leaveCbKey] = void 0;
                  delete enterHooks.delayedLeave;
                };
                enterHooks.delayedLeave = delayedLeave;
              };
            }
          }
          return child;
        };
      }
    };
    const BaseTransition = BaseTransitionImpl;
    function getLeavingNodesForType(state, vnode) {
      const { leavingVNodes } = state;
      let leavingVNodesCache = leavingVNodes.get(vnode.type);
      if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
      }
      return leavingVNodesCache;
    }
    function resolveTransitionHooks(vnode, props, state, instance, postClone) {
      const {
        appear,
        mode,
        persisted = false,
        onBeforeEnter,
        onEnter,
        onAfterEnter,
        onEnterCancelled,
        onBeforeLeave,
        onLeave,
        onAfterLeave,
        onLeaveCancelled,
        onBeforeAppear,
        onAppear,
        onAfterAppear,
        onAppearCancelled
      } = props;
      const key = String(vnode.key);
      const leavingVNodesCache = getLeavingNodesForType(state, vnode);
      const callHook2 = (hook, args) => {
        hook && callWithAsyncErrorHandling(
          hook,
          instance,
          9,
          args
        );
      };
      const callAsyncHook = (hook, args) => {
        const done = args[1];
        callHook2(hook, args);
        if (isArray$1(hook)) {
          if (hook.every((hook2) => hook2.length <= 1))
            done();
        } else if (hook.length <= 1) {
          done();
        }
      };
      const hooks = {
        mode,
        persisted,
        beforeEnter(el2) {
          let hook = onBeforeEnter;
          if (!state.isMounted) {
            if (appear) {
              hook = onBeforeAppear || onBeforeEnter;
            } else {
              return;
            }
          }
          if (el2[leaveCbKey]) {
            el2[leaveCbKey](
              true
              /* cancelled */
            );
          }
          const leavingVNode = leavingVNodesCache[key];
          if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
            leavingVNode.el[leaveCbKey]();
          }
          callHook2(hook, [el2]);
        },
        enter(el2) {
          let hook = onEnter;
          let afterHook = onAfterEnter;
          let cancelHook = onEnterCancelled;
          if (!state.isMounted) {
            if (appear) {
              hook = onAppear || onEnter;
              afterHook = onAfterAppear || onAfterEnter;
              cancelHook = onAppearCancelled || onEnterCancelled;
            } else {
              return;
            }
          }
          let called = false;
          const done = el2[enterCbKey$1] = (cancelled) => {
            if (called)
              return;
            called = true;
            if (cancelled) {
              callHook2(cancelHook, [el2]);
            } else {
              callHook2(afterHook, [el2]);
            }
            if (hooks.delayedLeave) {
              hooks.delayedLeave();
            }
            el2[enterCbKey$1] = void 0;
          };
          if (hook) {
            callAsyncHook(hook, [el2, done]);
          } else {
            done();
          }
        },
        leave(el2, remove2) {
          const key2 = String(vnode.key);
          if (el2[enterCbKey$1]) {
            el2[enterCbKey$1](
              true
              /* cancelled */
            );
          }
          if (state.isUnmounting) {
            return remove2();
          }
          callHook2(onBeforeLeave, [el2]);
          let called = false;
          const done = el2[leaveCbKey] = (cancelled) => {
            if (called)
              return;
            called = true;
            remove2();
            if (cancelled) {
              callHook2(onLeaveCancelled, [el2]);
            } else {
              callHook2(onAfterLeave, [el2]);
            }
            el2[leaveCbKey] = void 0;
            if (leavingVNodesCache[key2] === vnode) {
              delete leavingVNodesCache[key2];
            }
          };
          leavingVNodesCache[key2] = vnode;
          if (onLeave) {
            callAsyncHook(onLeave, [el2, done]);
          } else {
            done();
          }
        },
        clone(vnode2) {
          const hooks2 = resolveTransitionHooks(
            vnode2,
            props,
            state,
            instance,
            postClone
          );
          if (postClone)
            postClone(hooks2);
          return hooks2;
        }
      };
      return hooks;
    }
    function emptyPlaceholder(vnode) {
      if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
      }
    }
    function getKeepAliveChild(vnode) {
      if (!isKeepAlive(vnode)) {
        return vnode;
      }
      const { shapeFlag, children } = vnode;
      if (children) {
        if (shapeFlag & 16) {
          return children[0];
        }
        if (shapeFlag & 32 && isFunction$1(children.default)) {
          return children.default();
        }
      }
    }
    function setTransitionHooks(vnode, hooks) {
      if (vnode.shapeFlag & 6 && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks);
      } else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
      } else {
        vnode.transition = hooks;
      }
    }
    function getTransitionRawChildren(children, keepComment = false, parentKey) {
      let ret = [];
      let keyedFragmentCount = 0;
      for (let i2 = 0; i2 < children.length; i2++) {
        let child = children[i2];
        const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
        if (child.type === Fragment) {
          if (child.patchFlag & 128)
            keyedFragmentCount++;
          ret = ret.concat(
            getTransitionRawChildren(child.children, keepComment, key)
          );
        } else if (keepComment || child.type !== Comment) {
          ret.push(key != null ? cloneVNode(child, { key }) : child);
        }
      }
      if (keyedFragmentCount > 1) {
        for (let i2 = 0; i2 < ret.length; i2++) {
          ret[i2].patchFlag = -2;
        }
      }
      return ret;
    }
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function defineComponent$1(options, extraOptions) {
      return isFunction$1(options) ? (
        // #8326: extend call and options.name access are considered side-effects
        // by Rollup, so we have to wrap it in a pure-annotated IIFE.
        /* @__PURE__ */ (() => extend$1({ name: options.name }, extraOptions, { setup: options }))()
      ) : options;
    }
    const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
    const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
    function onActivated(hook, target2) {
      registerKeepAliveHook(hook, "a", target2);
    }
    function onDeactivated(hook, target2) {
      registerKeepAliveHook(hook, "da", target2);
    }
    function registerKeepAliveHook(hook, type2, target2 = currentInstance) {
      const wrappedHook = hook.__wdc || (hook.__wdc = () => {
        let current2 = target2;
        while (current2) {
          if (current2.isDeactivated) {
            return;
          }
          current2 = current2.parent;
        }
        return hook();
      });
      injectHook(type2, wrappedHook, target2);
      if (target2) {
        let current2 = target2.parent;
        while (current2 && current2.parent) {
          if (isKeepAlive(current2.parent.vnode)) {
            injectToKeepAliveRoot(wrappedHook, type2, target2, current2);
          }
          current2 = current2.parent;
        }
      }
    }
    function injectToKeepAliveRoot(hook, type2, target2, keepAliveRoot) {
      const injected = injectHook(
        type2,
        hook,
        keepAliveRoot,
        true
        /* prepend */
      );
      onUnmounted(() => {
        remove(keepAliveRoot[type2], injected);
      }, target2);
    }
    function injectHook(type2, hook, target2 = currentInstance, prepend = false) {
      if (target2) {
        const hooks = target2[type2] || (target2[type2] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
          pauseTracking();
          const reset = setCurrentInstance(target2);
          const res = callWithAsyncErrorHandling(hook, target2, type2, args);
          reset();
          resetTracking();
          return res;
        });
        if (prepend) {
          hooks.unshift(wrappedHook);
        } else {
          hooks.push(wrappedHook);
        }
        return wrappedHook;
      }
    }
    const createHook = (lifecycle) => (hook, target2 = currentInstance) => {
      if (!isInSSRComponentSetup || lifecycle === "sp") {
        injectHook(lifecycle, (...args) => hook(...args), target2);
      }
    };
    const onBeforeMount = createHook("bm");
    const onMounted = createHook("m");
    const onBeforeUpdate = createHook("bu");
    const onUpdated = createHook("u");
    const onBeforeUnmount = createHook("bum");
    const onUnmounted = createHook("um");
    const onServerPrefetch = createHook("sp");
    const onRenderTriggered = createHook(
      "rtg"
    );
    const onRenderTracked = createHook(
      "rtc"
    );
    function onErrorCaptured(hook, target2 = currentInstance) {
      injectHook("ec", hook, target2);
    }
    const COMPONENTS = "components";
    const DIRECTIVES = "directives";
    function resolveComponent(name, maybeSelfReference) {
      return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
    }
    const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
    function resolveDynamicComponent(component) {
      if (isString$1(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
      } else {
        return component || NULL_DYNAMIC_COMPONENT;
      }
    }
    function resolveDirective(name) {
      return resolveAsset(DIRECTIVES, name);
    }
    function resolveAsset(type2, name, warnMissing = true, maybeSelfReference = false) {
      const instance = currentRenderingInstance || currentInstance;
      if (instance) {
        const Component = instance.type;
        if (type2 === COMPONENTS) {
          const selfName = getComponentName(
            Component,
            false
          );
          if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
            return Component;
          }
        }
        const res = (
          // local registration
          // check instance[type] first which is resolved for options API
          resolve$3(instance[type2] || Component[type2], name) || // global registration
          resolve$3(instance.appContext[type2], name)
        );
        if (!res && maybeSelfReference) {
          return Component;
        }
        return res;
      }
    }
    function resolve$3(registry, name) {
      return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
    }
    function renderList(source2, renderItem, cache2, index) {
      let ret;
      const cached = cache2 && cache2[index];
      if (isArray$1(source2) || isString$1(source2)) {
        ret = new Array(source2.length);
        for (let i2 = 0, l = source2.length; i2 < l; i2++) {
          ret[i2] = renderItem(source2[i2], i2, void 0, cached && cached[i2]);
        }
      } else if (typeof source2 === "number") {
        ret = new Array(source2);
        for (let i2 = 0; i2 < source2; i2++) {
          ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
        }
      } else if (isObject$4(source2)) {
        if (source2[Symbol.iterator]) {
          ret = Array.from(
            source2,
            (item, i2) => renderItem(item, i2, void 0, cached && cached[i2])
          );
        } else {
          const keys2 = Object.keys(source2);
          ret = new Array(keys2.length);
          for (let i2 = 0, l = keys2.length; i2 < l; i2++) {
            const key = keys2[i2];
            ret[i2] = renderItem(source2[key], key, i2, cached && cached[i2]);
          }
        }
      } else {
        ret = [];
      }
      if (cache2) {
        cache2[index] = ret;
      }
      return ret;
    }
    function createSlots(slots, dynamicSlots) {
      for (let i2 = 0; i2 < dynamicSlots.length; i2++) {
        const slot = dynamicSlots[i2];
        if (isArray$1(slot)) {
          for (let j = 0; j < slot.length; j++) {
            slots[slot[j].name] = slot[j].fn;
          }
        } else if (slot) {
          slots[slot.name] = slot.key ? (...args) => {
            const res = slot.fn(...args);
            if (res)
              res.key = slot.key;
            return res;
          } : slot.fn;
        }
      }
      return slots;
    }
    function renderSlot(slots, name, props = {}, fallback, noSlotted) {
      if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
        if (name !== "default")
          props.name = name;
        return createVNode("slot", props, fallback && fallback());
      }
      let slot = slots[name];
      if (slot && slot._c) {
        slot._d = false;
      }
      openBlock();
      const validSlotContent = slot && ensureValidVNode$1(slot(props));
      const rendered = createBlock(
        Fragment,
        {
          key: (props.key || // slot content array of a dynamic conditional slot may have a branch
          // key attached in the `createSlots` helper, respect that
          validSlotContent && validSlotContent.key || `_${name}`) + // #7256 force differentiate fallback content from actual content
          (!validSlotContent && fallback ? "_fb" : "")
        },
        validSlotContent || (fallback ? fallback() : []),
        validSlotContent && slots._ === 1 ? 64 : -2
      );
      if (!noSlotted && rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + "-s"];
      }
      if (slot && slot._c) {
        slot._d = true;
      }
      return rendered;
    }
    function ensureValidVNode$1(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child))
          return true;
        if (child.type === Comment)
          return false;
        if (child.type === Fragment && !ensureValidVNode$1(child.children))
          return false;
        return true;
      }) ? vnodes : null;
    }
    const getPublicInstance = (i2) => {
      if (!i2)
        return null;
      if (isStatefulComponent(i2))
        return getComponentPublicInstance(i2);
      return getPublicInstance(i2.parent);
    };
    const publicPropertiesMap = (
      // Move PURE marker to new line to workaround compiler discarding it
      // due to type annotation
      /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
        $: (i2) => i2,
        $el: (i2) => i2.vnode.el,
        $data: (i2) => i2.data,
        $props: (i2) => i2.props,
        $attrs: (i2) => i2.attrs,
        $slots: (i2) => i2.slots,
        $refs: (i2) => i2.refs,
        $parent: (i2) => getPublicInstance(i2.parent),
        $root: (i2) => getPublicInstance(i2.root),
        $emit: (i2) => i2.emit,
        $options: (i2) => resolveMergedOptions(i2),
        $forceUpdate: (i2) => i2.f || (i2.f = () => {
          i2.effect.dirty = true;
          queueJob(i2.update);
        }),
        $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
        $watch: (i2) => instanceWatch.bind(i2)
      })
    );
    const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
    const PublicInstanceProxyHandlers = {
      get({ _: instance }, key) {
        if (key === "__v_skip") {
          return true;
        }
        const { ctx, setupState, data, props, accessCache, type: type2, appContext } = instance;
        let normalizedProps;
        if (key[0] !== "$") {
          const n = accessCache[key];
          if (n !== void 0) {
            switch (n) {
              case 1:
                return setupState[key];
              case 2:
                return data[key];
              case 4:
                return ctx[key];
              case 3:
                return props[key];
            }
          } else if (hasSetupBinding(setupState, key)) {
            accessCache[key] = 1;
            return setupState[key];
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            accessCache[key] = 2;
            return data[key];
          } else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
          ) {
            accessCache[key] = 3;
            return props[key];
          } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (shouldCacheAccess) {
            accessCache[key] = 0;
          }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
          if (key === "$attrs") {
            track(instance.attrs, "get", "");
          }
          return publicGetter(instance);
        } else if (
          // css module (injected by vue-loader)
          (cssModule = type2.__cssModules) && (cssModule = cssModule[key])
        ) {
          return cssModule;
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (
          // global properties
          globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
        ) {
          {
            return globalProperties[key];
          }
        } else
          ;
      },
      set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (hasSetupBinding(setupState, key)) {
          setupState[key] = value;
          return true;
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          data[key] = value;
          return true;
        } else if (hasOwn(instance.props, key)) {
          return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
          return false;
        } else {
          {
            ctx[key] = value;
          }
        }
        return true;
      },
      has({
        _: { data, setupState, accessCache, ctx, appContext, propsOptions }
      }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
      },
      defineProperty(target2, key, descriptor) {
        if (descriptor.get != null) {
          target2._.accessCache[key] = 0;
        } else if (hasOwn(descriptor, "value")) {
          this.set(target2, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target2, key, descriptor);
      }
    };
    function useSlots() {
      return getContext().slots;
    }
    function getContext() {
      const i2 = getCurrentInstance$1();
      return i2.setupContext || (i2.setupContext = createSetupContext(i2));
    }
    function normalizePropsOrEmits(props) {
      return isArray$1(props) ? props.reduce(
        (normalized, p2) => (normalized[p2] = null, normalized),
        {}
      ) : props;
    }
    function mergeModels(a, b) {
      if (!a || !b)
        return a || b;
      if (isArray$1(a) && isArray$1(b))
        return a.concat(b);
      return extend$1({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
    }
    let shouldCacheAccess = true;
    function applyOptions(instance) {
      const options = resolveMergedOptions(instance);
      const publicThis = instance.proxy;
      const ctx = instance.ctx;
      shouldCacheAccess = false;
      if (options.beforeCreate) {
        callHook$1(options.beforeCreate, instance, "bc");
      }
      const {
        // state
        data: dataOptions,
        computed: computedOptions,
        methods,
        watch: watchOptions,
        provide: provideOptions,
        inject: injectOptions,
        // lifecycle
        created,
        beforeMount,
        mounted: mounted2,
        beforeUpdate,
        updated: updated2,
        activated,
        deactivated,
        beforeDestroy,
        beforeUnmount,
        destroyed,
        unmounted: unmounted2,
        render,
        renderTracked,
        renderTriggered,
        errorCaptured,
        serverPrefetch,
        // public API
        expose,
        inheritAttrs,
        // assets
        components,
        directives,
        filters
      } = options;
      const checkDuplicateProperties = null;
      if (injectOptions) {
        resolveInjections(injectOptions, ctx, checkDuplicateProperties);
      }
      if (methods) {
        for (const key in methods) {
          const methodHandler = methods[key];
          if (isFunction$1(methodHandler)) {
            {
              ctx[key] = methodHandler.bind(publicThis);
            }
          }
        }
      }
      if (dataOptions) {
        const data = dataOptions.call(publicThis, publicThis);
        if (!isObject$4(data))
          ;
        else {
          instance.data = reactive(data);
        }
      }
      shouldCacheAccess = true;
      if (computedOptions) {
        for (const key in computedOptions) {
          const opt = computedOptions[key];
          const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
          const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
          const c = computed({
            get: get2,
            set: set2
          });
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => c.value,
            set: (v) => c.value = v
          });
        }
      }
      if (watchOptions) {
        for (const key in watchOptions) {
          createWatcher(watchOptions[key], ctx, publicThis, key);
        }
      }
      if (provideOptions) {
        const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key) => {
          provide(key, provides[key]);
        });
      }
      if (created) {
        callHook$1(created, instance, "c");
      }
      function registerLifecycleHook(register, hook) {
        if (isArray$1(hook)) {
          hook.forEach((_hook) => register(_hook.bind(publicThis)));
        } else if (hook) {
          register(hook.bind(publicThis));
        }
      }
      registerLifecycleHook(onBeforeMount, beforeMount);
      registerLifecycleHook(onMounted, mounted2);
      registerLifecycleHook(onBeforeUpdate, beforeUpdate);
      registerLifecycleHook(onUpdated, updated2);
      registerLifecycleHook(onActivated, activated);
      registerLifecycleHook(onDeactivated, deactivated);
      registerLifecycleHook(onErrorCaptured, errorCaptured);
      registerLifecycleHook(onRenderTracked, renderTracked);
      registerLifecycleHook(onRenderTriggered, renderTriggered);
      registerLifecycleHook(onBeforeUnmount, beforeUnmount);
      registerLifecycleHook(onUnmounted, unmounted2);
      registerLifecycleHook(onServerPrefetch, serverPrefetch);
      if (isArray$1(expose)) {
        if (expose.length) {
          const exposed = instance.exposed || (instance.exposed = {});
          expose.forEach((key) => {
            Object.defineProperty(exposed, key, {
              get: () => publicThis[key],
              set: (val) => publicThis[key] = val
            });
          });
        } else if (!instance.exposed) {
          instance.exposed = {};
        }
      }
      if (render && instance.render === NOOP) {
        instance.render = render;
      }
      if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
      }
      if (components)
        instance.components = components;
      if (directives)
        instance.directives = directives;
    }
    function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
      if (isArray$1(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
      }
      for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if (isObject$4(opt)) {
          if ("default" in opt) {
            injected = inject$1(
              opt.from || key,
              opt.default,
              true
            );
          } else {
            injected = inject$1(opt.from || key);
          }
        } else {
          injected = inject$1(opt);
        }
        if (isRef(injected)) {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => injected.value,
            set: (v) => injected.value = v
          });
        } else {
          ctx[key] = injected;
        }
      }
    }
    function callHook$1(hook, instance, type2) {
      callWithAsyncErrorHandling(
        isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
        instance,
        type2
      );
    }
    function createWatcher(raw, ctx, publicThis, key) {
      const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
      if (isString$1(raw)) {
        const handler = ctx[raw];
        if (isFunction$1(handler)) {
          watch(getter, handler);
        }
      } else if (isFunction$1(raw)) {
        watch(getter, raw.bind(publicThis));
      } else if (isObject$4(raw)) {
        if (isArray$1(raw)) {
          raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
        } else {
          const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
          if (isFunction$1(handler)) {
            watch(getter, handler, raw);
          }
        }
      } else
        ;
    }
    function resolveMergedOptions(instance) {
      const base2 = instance.type;
      const { mixins, extends: extendsOptions } = base2;
      const {
        mixins: globalMixins,
        optionsCache: cache2,
        config: { optionMergeStrategies }
      } = instance.appContext;
      const cached = cache2.get(base2);
      let resolved;
      if (cached) {
        resolved = cached;
      } else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
          resolved = base2;
        }
      } else {
        resolved = {};
        if (globalMixins.length) {
          globalMixins.forEach(
            (m) => mergeOptions$1(resolved, m, optionMergeStrategies, true)
          );
        }
        mergeOptions$1(resolved, base2, optionMergeStrategies);
      }
      if (isObject$4(base2)) {
        cache2.set(base2, resolved);
      }
      return resolved;
    }
    function mergeOptions$1(to, from, strats, asMixin = false) {
      const { mixins, extends: extendsOptions } = from;
      if (extendsOptions) {
        mergeOptions$1(to, extendsOptions, strats, true);
      }
      if (mixins) {
        mixins.forEach(
          (m) => mergeOptions$1(to, m, strats, true)
        );
      }
      for (const key in from) {
        if (asMixin && key === "expose")
          ;
        else {
          const strat = internalOptionMergeStrats[key] || strats && strats[key];
          to[key] = strat ? strat(to[key], from[key]) : from[key];
        }
      }
      return to;
    }
    const internalOptionMergeStrats = {
      data: mergeDataFn,
      props: mergeEmitsOrPropsOptions,
      emits: mergeEmitsOrPropsOptions,
      // objects
      methods: mergeObjectOptions,
      computed: mergeObjectOptions,
      // lifecycle
      beforeCreate: mergeAsArray,
      created: mergeAsArray,
      beforeMount: mergeAsArray,
      mounted: mergeAsArray,
      beforeUpdate: mergeAsArray,
      updated: mergeAsArray,
      beforeDestroy: mergeAsArray,
      beforeUnmount: mergeAsArray,
      destroyed: mergeAsArray,
      unmounted: mergeAsArray,
      activated: mergeAsArray,
      deactivated: mergeAsArray,
      errorCaptured: mergeAsArray,
      serverPrefetch: mergeAsArray,
      // assets
      components: mergeObjectOptions,
      directives: mergeObjectOptions,
      // watch
      watch: mergeWatchOptions,
      // provide / inject
      provide: mergeDataFn,
      inject: mergeInject
    };
    function mergeDataFn(to, from) {
      if (!from) {
        return to;
      }
      if (!to) {
        return from;
      }
      return function mergedDataFn() {
        return extend$1(
          isFunction$1(to) ? to.call(this, this) : to,
          isFunction$1(from) ? from.call(this, this) : from
        );
      };
    }
    function mergeInject(to, from) {
      return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
    }
    function normalizeInject(raw) {
      if (isArray$1(raw)) {
        const res = {};
        for (let i2 = 0; i2 < raw.length; i2++) {
          res[raw[i2]] = raw[i2];
        }
        return res;
      }
      return raw;
    }
    function mergeAsArray(to, from) {
      return to ? [...new Set([].concat(to, from))] : from;
    }
    function mergeObjectOptions(to, from) {
      return to ? extend$1(/* @__PURE__ */ Object.create(null), to, from) : from;
    }
    function mergeEmitsOrPropsOptions(to, from) {
      if (to) {
        if (isArray$1(to) && isArray$1(from)) {
          return [.../* @__PURE__ */ new Set([...to, ...from])];
        }
        return extend$1(
          /* @__PURE__ */ Object.create(null),
          normalizePropsOrEmits(to),
          normalizePropsOrEmits(from != null ? from : {})
        );
      } else {
        return from;
      }
    }
    function mergeWatchOptions(to, from) {
      if (!to)
        return from;
      if (!from)
        return to;
      const merged = extend$1(/* @__PURE__ */ Object.create(null), to);
      for (const key in from) {
        merged[key] = mergeAsArray(to[key], from[key]);
      }
      return merged;
    }
    function createAppContext() {
      return {
        app: null,
        config: {
          isNativeTag: NO,
          performance: false,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
      };
    }
    let uid$1 = 0;
    function createAppAPI(render, hydrate) {
      return function createApp2(rootComponent, rootProps = null) {
        if (!isFunction$1(rootComponent)) {
          rootComponent = extend$1({}, rootComponent);
        }
        if (rootProps != null && !isObject$4(rootProps)) {
          rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = /* @__PURE__ */ new WeakSet();
        let isMounted = false;
        const app2 = context.app = {
          _uid: uid$1++,
          _component: rootComponent,
          _props: rootProps,
          _container: null,
          _context: context,
          _instance: null,
          version: version$2,
          get config() {
            return context.config;
          },
          set config(v) {
          },
          use(plugin, ...options) {
            if (installedPlugins.has(plugin))
              ;
            else if (plugin && isFunction$1(plugin.install)) {
              installedPlugins.add(plugin);
              plugin.install(app2, ...options);
            } else if (isFunction$1(plugin)) {
              installedPlugins.add(plugin);
              plugin(app2, ...options);
            } else
              ;
            return app2;
          },
          mixin(mixin) {
            {
              if (!context.mixins.includes(mixin)) {
                context.mixins.push(mixin);
              }
            }
            return app2;
          },
          component(name, component) {
            if (!component) {
              return context.components[name];
            }
            context.components[name] = component;
            return app2;
          },
          directive(name, directive2) {
            if (!directive2) {
              return context.directives[name];
            }
            context.directives[name] = directive2;
            return app2;
          },
          mount(rootContainer, isHydrate, namespace) {
            if (!isMounted) {
              const vnode = createVNode(rootComponent, rootProps);
              vnode.appContext = context;
              if (namespace === true) {
                namespace = "svg";
              } else if (namespace === false) {
                namespace = void 0;
              }
              if (isHydrate && hydrate) {
                hydrate(vnode, rootContainer);
              } else {
                render(vnode, rootContainer, namespace);
              }
              isMounted = true;
              app2._container = rootContainer;
              rootContainer.__vue_app__ = app2;
              return getComponentPublicInstance(vnode.component);
            }
          },
          unmount() {
            if (isMounted) {
              render(null, app2._container);
              delete app2._container.__vue_app__;
            }
          },
          provide(key, value) {
            context.provides[key] = value;
            return app2;
          },
          runWithContext(fn) {
            const lastApp = currentApp;
            currentApp = app2;
            try {
              return fn();
            } finally {
              currentApp = lastApp;
            }
          }
        };
        return app2;
      };
    }
    let currentApp = null;
    function provide(key, value) {
      if (!currentInstance)
        ;
      else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
          provides = currentInstance.provides = Object.create(parentProvides);
        }
        provides[key] = value;
      }
    }
    function inject$1(key, defaultValue, treatDefaultAsFactory = false) {
      const instance = currentInstance || currentRenderingInstance;
      if (instance || currentApp) {
        const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
        if (provides && key in provides) {
          return provides[key];
        } else if (arguments.length > 1) {
          return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        } else
          ;
      }
    }
    function hasInjectionContext() {
      return !!(currentInstance || currentRenderingInstance || currentApp);
    }
    const internalObjectProto = {};
    const createInternalObject = () => Object.create(internalObjectProto);
    const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
    function initProps(instance, rawProps, isStateful, isSSR = false) {
      const props = {};
      const attrs = createInternalObject();
      instance.propsDefaults = /* @__PURE__ */ Object.create(null);
      setFullProps(instance, rawProps, props, attrs);
      for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
          props[key] = void 0;
        }
      }
      if (isStateful) {
        instance.props = isSSR ? props : shallowReactive(props);
      } else {
        if (!instance.type.props) {
          instance.props = attrs;
        } else {
          instance.props = props;
        }
      }
      instance.attrs = attrs;
    }
    function updateProps(instance, rawProps, rawPrevProps, optimized) {
      const {
        props,
        attrs,
        vnode: { patchFlag }
      } = instance;
      const rawCurrentProps = toRaw(props);
      const [options] = instance.propsOptions;
      let hasAttrsChanged = false;
      if (
        // always force full diff in dev
        // - #1942 if hmr is enabled with sfc component
        // - vite#872 non-sfc component used by sfc component
        (optimized || patchFlag > 0) && !(patchFlag & 16)
      ) {
        if (patchFlag & 8) {
          const propsToUpdate = instance.vnode.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            let key = propsToUpdate[i2];
            if (isEmitListener(instance.emitsOptions, key)) {
              continue;
            }
            const value = rawProps[key];
            if (options) {
              if (hasOwn(attrs, key)) {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              } else {
                const camelizedKey = camelize(key);
                props[camelizedKey] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  camelizedKey,
                  value,
                  instance,
                  false
                );
              }
            } else {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
      } else {
        if (setFullProps(instance, rawProps, props, attrs)) {
          hasAttrsChanged = true;
        }
        let kebabKey;
        for (const key in rawCurrentProps) {
          if (!rawProps || // for camelCase
          !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
          // and converted to camelCase (#955)
          ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
            if (options) {
              if (rawPrevProps && // for camelCase
              (rawPrevProps[key] !== void 0 || // for kebab-case
              rawPrevProps[kebabKey] !== void 0)) {
                props[key] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  key,
                  void 0,
                  instance,
                  true
                );
              }
            } else {
              delete props[key];
            }
          }
        }
        if (attrs !== rawCurrentProps) {
          for (const key in attrs) {
            if (!rawProps || !hasOwn(rawProps, key) && true) {
              delete attrs[key];
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (hasAttrsChanged) {
        trigger(instance.attrs, "set", "");
      }
    }
    function setFullProps(instance, rawProps, props, attrs) {
      const [options, needCastKeys] = instance.propsOptions;
      let hasAttrsChanged = false;
      let rawCastValues;
      if (rawProps) {
        for (let key in rawProps) {
          if (isReservedProp(key)) {
            continue;
          }
          const value = rawProps[key];
          let camelKey;
          if (options && hasOwn(options, camelKey = camelize(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) {
              props[camelKey] = value;
            } else {
              (rawCastValues || (rawCastValues = {}))[camelKey] = value;
            }
          } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (needCastKeys) {
        const rawCurrentProps = toRaw(props);
        const castValues = rawCastValues || EMPTY_OBJ;
        for (let i2 = 0; i2 < needCastKeys.length; i2++) {
          const key = needCastKeys[i2];
          props[key] = resolvePropValue(
            options,
            rawCurrentProps,
            key,
            castValues[key],
            instance,
            !hasOwn(castValues, key)
          );
        }
      }
      return hasAttrsChanged;
    }
    function resolvePropValue(options, props, key, value, instance, isAbsent) {
      const opt = options[key];
      if (opt != null) {
        const hasDefault = hasOwn(opt, "default");
        if (hasDefault && value === void 0) {
          const defaultValue = opt.default;
          if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
            const { propsDefaults } = instance;
            if (key in propsDefaults) {
              value = propsDefaults[key];
            } else {
              const reset = setCurrentInstance(instance);
              value = propsDefaults[key] = defaultValue.call(
                null,
                props
              );
              reset();
            }
          } else {
            value = defaultValue;
          }
        }
        if (opt[
          0
          /* shouldCast */
        ]) {
          if (isAbsent && !hasDefault) {
            value = false;
          } else if (opt[
            1
            /* shouldCastTrue */
          ] && (value === "" || value === hyphenate(key))) {
            value = true;
          }
        }
      }
      return value;
    }
    const mixinPropsCache = /* @__PURE__ */ new WeakMap();
    function normalizePropsOptions(comp2, appContext, asMixin = false) {
      const cache2 = asMixin ? mixinPropsCache : appContext.propsCache;
      const cached = cache2.get(comp2);
      if (cached) {
        return cached;
      }
      const raw = comp2.props;
      const normalized = {};
      const needCastKeys = [];
      let hasExtends = false;
      if (!isFunction$1(comp2)) {
        const extendProps = (raw2) => {
          hasExtends = true;
          const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
          extend$1(normalized, props);
          if (keys2)
            needCastKeys.push(...keys2);
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendProps);
        }
        if (comp2.extends) {
          extendProps(comp2.extends);
        }
        if (comp2.mixins) {
          comp2.mixins.forEach(extendProps);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$4(comp2)) {
          cache2.set(comp2, EMPTY_ARR);
        }
        return EMPTY_ARR;
      }
      if (isArray$1(raw)) {
        for (let i2 = 0; i2 < raw.length; i2++) {
          const normalizedKey = camelize(raw[i2]);
          if (validatePropName(normalizedKey)) {
            normalized[normalizedKey] = EMPTY_OBJ;
          }
        }
      } else if (raw) {
        for (const key in raw) {
          const normalizedKey = camelize(key);
          if (validatePropName(normalizedKey)) {
            const opt = raw[key];
            const prop2 = normalized[normalizedKey] = isArray$1(opt) || isFunction$1(opt) ? { type: opt } : extend$1({}, opt);
            const propType = prop2.type;
            let shouldCast = false;
            let shouldCastTrue = true;
            if (isArray$1(propType)) {
              for (let index = 0; index < propType.length; ++index) {
                const type2 = propType[index];
                const typeName = isFunction$1(type2) && type2.name;
                if (typeName === "Boolean") {
                  shouldCast = true;
                  break;
                } else if (typeName === "String") {
                  shouldCastTrue = false;
                }
              }
            } else {
              shouldCast = isFunction$1(propType) && propType.name === "Boolean";
            }
            prop2[
              0
              /* shouldCast */
            ] = shouldCast;
            prop2[
              1
              /* shouldCastTrue */
            ] = shouldCastTrue;
            if (shouldCast || hasOwn(prop2, "default")) {
              needCastKeys.push(normalizedKey);
            }
          }
        }
      }
      const res = [normalized, needCastKeys];
      if (isObject$4(comp2)) {
        cache2.set(comp2, res);
      }
      return res;
    }
    function validatePropName(key) {
      if (key[0] !== "$" && !isReservedProp(key)) {
        return true;
      }
      return false;
    }
    const isInternalKey = (key) => key[0] === "_" || key === "$stable";
    const normalizeSlotValue = (value) => isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
    const normalizeSlot$1 = (key, rawSlot, ctx) => {
      if (rawSlot._n) {
        return rawSlot;
      }
      const normalized = withCtx((...args) => {
        if (false)
          ;
        return normalizeSlotValue(rawSlot(...args));
      }, ctx);
      normalized._c = false;
      return normalized;
    };
    const normalizeObjectSlots = (rawSlots, slots, instance) => {
      const ctx = rawSlots._ctx;
      for (const key in rawSlots) {
        if (isInternalKey(key))
          continue;
        const value = rawSlots[key];
        if (isFunction$1(value)) {
          slots[key] = normalizeSlot$1(key, value, ctx);
        } else if (value != null) {
          const normalized = normalizeSlotValue(value);
          slots[key] = () => normalized;
        }
      }
    };
    const normalizeVNodeSlots = (instance, children) => {
      const normalized = normalizeSlotValue(children);
      instance.slots.default = () => normalized;
    };
    const assignSlots = (slots, children, optimized) => {
      for (const key in children) {
        if (optimized || key !== "_") {
          slots[key] = children[key];
        }
      }
    };
    const initSlots = (instance, children, optimized) => {
      const slots = instance.slots = createInternalObject();
      if (instance.vnode.shapeFlag & 32) {
        const type2 = children._;
        if (type2) {
          assignSlots(slots, children, optimized);
          if (optimized) {
            def$C(slots, "_", type2, true);
          }
        } else {
          normalizeObjectSlots(children, slots);
        }
      } else if (children) {
        normalizeVNodeSlots(instance, children);
      }
    };
    const updateSlots = (instance, children, optimized) => {
      const { vnode, slots } = instance;
      let needDeletionCheck = true;
      let deletionComparisonTarget = EMPTY_OBJ;
      if (vnode.shapeFlag & 32) {
        const type2 = children._;
        if (type2) {
          if (optimized && type2 === 1) {
            needDeletionCheck = false;
          } else {
            assignSlots(slots, children, optimized);
          }
        } else {
          needDeletionCheck = !children.$stable;
          normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
      } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
      }
      if (needDeletionCheck) {
        for (const key in slots) {
          if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
            delete slots[key];
          }
        }
      }
    };
    function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
      if (isArray$1(rawRef)) {
        rawRef.forEach(
          (r2, i2) => setRef(
            r2,
            oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i2] : oldRawRef),
            parentSuspense,
            vnode,
            isUnmount
          )
        );
        return;
      }
      if (isAsyncWrapper(vnode) && !isUnmount) {
        return;
      }
      const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
      const value = isUnmount ? null : refValue;
      const { i: owner, r: ref3 } = rawRef;
      const oldRef = oldRawRef && oldRawRef.r;
      const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
      const setupState = owner.setupState;
      if (oldRef != null && oldRef !== ref3) {
        if (isString$1(oldRef)) {
          refs[oldRef] = null;
          if (hasOwn(setupState, oldRef)) {
            setupState[oldRef] = null;
          }
        } else if (isRef(oldRef)) {
          oldRef.value = null;
        }
      }
      if (isFunction$1(ref3)) {
        callWithErrorHandling(ref3, owner, 12, [value, refs]);
      } else {
        const _isString = isString$1(ref3);
        const _isRef = isRef(ref3);
        if (_isString || _isRef) {
          const doSet = () => {
            if (rawRef.f) {
              const existing = _isString ? hasOwn(setupState, ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
              if (isUnmount) {
                isArray$1(existing) && remove(existing, refValue);
              } else {
                if (!isArray$1(existing)) {
                  if (_isString) {
                    refs[ref3] = [refValue];
                    if (hasOwn(setupState, ref3)) {
                      setupState[ref3] = refs[ref3];
                    }
                  } else {
                    ref3.value = [refValue];
                    if (rawRef.k)
                      refs[rawRef.k] = ref3.value;
                  }
                } else if (!existing.includes(refValue)) {
                  existing.push(refValue);
                }
              }
            } else if (_isString) {
              refs[ref3] = value;
              if (hasOwn(setupState, ref3)) {
                setupState[ref3] = value;
              }
            } else if (_isRef) {
              ref3.value = value;
              if (rawRef.k)
                refs[rawRef.k] = value;
            } else
              ;
          };
          if (value) {
            doSet.id = -1;
            queuePostRenderEffect(doSet, parentSuspense);
          } else {
            doSet();
          }
        }
      }
    }
    const TeleportEndKey = Symbol("_vte");
    const isTeleport = (type2) => type2.__isTeleport;
    const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
    const isTargetSVG = (target2) => typeof SVGElement !== "undefined" && target2 instanceof SVGElement;
    const isTargetMathML = (target2) => typeof MathMLElement === "function" && target2 instanceof MathMLElement;
    const resolveTarget = (props, select) => {
      const targetSelector = props && props.to;
      if (isString$1(targetSelector)) {
        if (!select) {
          return null;
        } else {
          const target2 = select(targetSelector);
          return target2;
        }
      } else {
        return targetSelector;
      }
    };
    const TeleportImpl = {
      name: "Teleport",
      __isTeleport: true,
      process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
        const {
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          o: { insert, querySelector, createText, createComment }
        } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        if (n1 == null) {
          const placeholder = n2.el = createText("");
          const mainAnchor = n2.anchor = createText("");
          insert(placeholder, container, anchor);
          insert(mainAnchor, container, anchor);
          const target2 = n2.target = resolveTarget(n2.props, querySelector);
          const targetAnchor = prepareAnchor(target2, n2, createText, insert);
          if (target2) {
            if (namespace === "svg" || isTargetSVG(target2)) {
              namespace = "svg";
            } else if (namespace === "mathml" || isTargetMathML(target2)) {
              namespace = "mathml";
            }
          }
          const mount = (container2, anchor2) => {
            if (shapeFlag & 16) {
              mountChildren(
                children,
                container2,
                anchor2,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            }
          };
          if (disabled) {
            mount(container, mainAnchor);
          } else if (target2) {
            mount(target2, targetAnchor);
          }
        } else {
          n2.el = n1.el;
          n2.targetStart = n1.targetStart;
          const mainAnchor = n2.anchor = n1.anchor;
          const target2 = n2.target = n1.target;
          const targetAnchor = n2.targetAnchor = n1.targetAnchor;
          const wasDisabled = isTeleportDisabled(n1.props);
          const currentContainer = wasDisabled ? container : target2;
          const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
          if (namespace === "svg" || isTargetSVG(target2)) {
            namespace = "svg";
          } else if (namespace === "mathml" || isTargetMathML(target2)) {
            namespace = "mathml";
          }
          if (dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              currentContainer,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds
            );
            traverseStaticChildren(n1, n2, true);
          } else if (!optimized) {
            patchChildren(
              n1,
              n2,
              currentContainer,
              currentAnchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              false
            );
          }
          if (disabled) {
            if (!wasDisabled) {
              moveTeleport(
                n2,
                container,
                mainAnchor,
                internals,
                1
              );
            } else {
              if (n2.props && n1.props && n2.props.to !== n1.props.to) {
                n2.props.to = n1.props.to;
              }
            }
          } else {
            if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
              const nextTarget = n2.target = resolveTarget(
                n2.props,
                querySelector
              );
              if (nextTarget) {
                moveTeleport(
                  n2,
                  nextTarget,
                  null,
                  internals,
                  0
                );
              }
            } else if (wasDisabled) {
              moveTeleport(
                n2,
                target2,
                targetAnchor,
                internals,
                1
              );
            }
          }
        }
        updateCssVars(n2);
      },
      remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const {
          shapeFlag,
          children,
          anchor,
          targetStart,
          targetAnchor,
          target: target2,
          props
        } = vnode;
        if (target2) {
          hostRemove(targetStart);
          hostRemove(targetAnchor);
        }
        doRemove && hostRemove(anchor);
        if (shapeFlag & 16) {
          const shouldRemove = doRemove || !isTeleportDisabled(props);
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            unmount(
              child,
              parentComponent,
              parentSuspense,
              shouldRemove,
              !!child.dynamicChildren
            );
          }
        }
      },
      move: moveTeleport,
      hydrate: hydrateTeleport
    };
    function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
      if (moveType === 0) {
        insert(vnode.targetAnchor, container, parentAnchor);
      }
      const { el: el2, anchor, shapeFlag, children, props } = vnode;
      const isReorder = moveType === 2;
      if (isReorder) {
        insert(el2, container, parentAnchor);
      }
      if (!isReorder || isTeleportDisabled(props)) {
        if (shapeFlag & 16) {
          for (let i2 = 0; i2 < children.length; i2++) {
            move(
              children[i2],
              container,
              parentAnchor,
              2
            );
          }
        }
      }
      if (isReorder) {
        insert(anchor, container, parentAnchor);
      }
    }
    function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
      o: { nextSibling, parentNode, querySelector, insert, createText }
    }, hydrateChildren) {
      const target2 = vnode.target = resolveTarget(
        vnode.props,
        querySelector
      );
      if (target2) {
        const targetNode = target2._lpa || target2.firstChild;
        if (vnode.shapeFlag & 16) {
          if (isTeleportDisabled(vnode.props)) {
            vnode.anchor = hydrateChildren(
              nextSibling(node),
              vnode,
              parentNode(node),
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
            vnode.targetStart = targetNode;
            vnode.targetAnchor = targetNode && nextSibling(targetNode);
          } else {
            vnode.anchor = nextSibling(node);
            let targetAnchor = targetNode;
            while (targetAnchor) {
              if (targetAnchor && targetAnchor.nodeType === 8) {
                if (targetAnchor.data === "teleport start anchor") {
                  vnode.targetStart = targetAnchor;
                } else if (targetAnchor.data === "teleport anchor") {
                  vnode.targetAnchor = targetAnchor;
                  target2._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                  break;
                }
              }
              targetAnchor = nextSibling(targetAnchor);
            }
            if (!vnode.targetAnchor) {
              prepareAnchor(target2, vnode, createText, insert);
            }
            hydrateChildren(
              targetNode && nextSibling(targetNode),
              vnode,
              target2,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        }
        updateCssVars(vnode);
      }
      return vnode.anchor && nextSibling(vnode.anchor);
    }
    const Teleport = TeleportImpl;
    function updateCssVars(vnode) {
      const ctx = vnode.ctx;
      if (ctx && ctx.ut) {
        let node = vnode.children[0].el;
        while (node && node !== vnode.targetAnchor) {
          if (node.nodeType === 1)
            node.setAttribute("data-v-owner", ctx.uid);
          node = node.nextSibling;
        }
        ctx.ut();
      }
    }
    function prepareAnchor(target2, vnode, createText, insert) {
      const targetStart = vnode.targetStart = createText("");
      const targetAnchor = vnode.targetAnchor = createText("");
      targetStart[TeleportEndKey] = targetAnchor;
      if (target2) {
        insert(targetStart, target2);
        insert(targetAnchor, target2);
      }
      return targetAnchor;
    }
    const queuePostRenderEffect = queueEffectWithSuspense;
    function createRenderer(options) {
      return baseCreateRenderer(options);
    }
    function baseCreateRenderer(options, createHydrationFns) {
      const target2 = getGlobalThis();
      target2.__VUE__ = true;
      const {
        insert: hostInsert,
        remove: hostRemove,
        patchProp: hostPatchProp,
        createElement: hostCreateElement,
        createText: hostCreateText,
        createComment: hostCreateComment,
        setText: hostSetText,
        setElementText: hostSetElementText,
        parentNode: hostParentNode,
        nextSibling: hostNextSibling,
        setScopeId: hostSetScopeId = NOOP,
        insertStaticContent: hostInsertStaticContent
      } = options;
      const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
        if (n1 === n2) {
          return;
        }
        if (n1 && !isSameVNodeType(n1, n2)) {
          anchor = getNextHostNode(n1);
          unmount(n1, parentComponent, parentSuspense, true);
          n1 = null;
        }
        if (n2.patchFlag === -2) {
          optimized = false;
          n2.dynamicChildren = null;
        }
        const { type: type2, ref: ref3, shapeFlag } = n2;
        switch (type2) {
          case Text$2:
            processText(n1, n2, container, anchor);
            break;
          case Comment:
            processCommentNode(n1, n2, container, anchor);
            break;
          case Static:
            if (n1 == null) {
              mountStaticNode(n2, container, anchor, namespace);
            }
            break;
          case Fragment:
            processFragment(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            break;
          default:
            if (shapeFlag & 1) {
              processElement(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 6) {
              processComponent(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 64) {
              type2.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                internals
              );
            } else if (shapeFlag & 128) {
              type2.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                internals
              );
            } else
              ;
        }
        if (ref3 != null && parentComponent) {
          setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
        }
      };
      const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateText(n2.children),
            container,
            anchor
          );
        } else {
          const el2 = n2.el = n1.el;
          if (n2.children !== n1.children) {
            hostSetText(el2, n2.children);
          }
        }
      };
      const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateComment(n2.children || ""),
            container,
            anchor
          );
        } else {
          n2.el = n1.el;
        }
      };
      const mountStaticNode = (n2, container, anchor, namespace) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          namespace,
          n2.el,
          n2.anchor
        );
      };
      const moveStaticNode = ({ el: el2, anchor }, container, nextSibling) => {
        let next2;
        while (el2 && el2 !== anchor) {
          next2 = hostNextSibling(el2);
          hostInsert(el2, container, nextSibling);
          el2 = next2;
        }
        hostInsert(anchor, container, nextSibling);
      };
      const removeStaticNode = ({ el: el2, anchor }) => {
        let next2;
        while (el2 && el2 !== anchor) {
          next2 = hostNextSibling(el2);
          hostRemove(el2);
          el2 = next2;
        }
        hostRemove(anchor);
      };
      const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        if (n2.type === "svg") {
          namespace = "svg";
        } else if (n2.type === "math") {
          namespace = "mathml";
        }
        if (n1 == null) {
          mountElement(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          patchElement(
            n1,
            n2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        let el2;
        let vnodeHook;
        const { props, shapeFlag, transition, dirs } = vnode;
        el2 = vnode.el = hostCreateElement(
          vnode.type,
          namespace,
          props && props.is,
          props
        );
        if (shapeFlag & 8) {
          hostSetElementText(el2, vnode.children);
        } else if (shapeFlag & 16) {
          mountChildren(
            vnode.children,
            el2,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(vnode, namespace),
            slotScopeIds,
            optimized
          );
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        setScopeId(el2, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
          for (const key in props) {
            if (key !== "value" && !isReservedProp(key)) {
              hostPatchProp(el2, key, null, props[key], namespace, parentComponent);
            }
          }
          if ("value" in props) {
            hostPatchProp(el2, "value", null, props.value, namespace);
          }
          if (vnodeHook = props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        const needCallTransitionHooks = needTransition(parentSuspense, transition);
        if (needCallTransitionHooks) {
          transition.beforeEnter(el2);
        }
        hostInsert(el2, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el2);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
      };
      const setScopeId = (el2, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
          hostSetScopeId(el2, scopeId);
        }
        if (slotScopeIds) {
          for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
            hostSetScopeId(el2, slotScopeIds[i2]);
          }
        }
        if (parentComponent) {
          let subTree = parentComponent.subTree;
          if (vnode === subTree) {
            const parentVNode = parentComponent.vnode;
            setScopeId(
              el2,
              parentVNode,
              parentVNode.scopeId,
              parentVNode.slotScopeIds,
              parentComponent.parent
            );
          }
        }
      };
      const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
        for (let i2 = start; i2 < children.length; i2++) {
          const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
          patch(
            null,
            child,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        const el2 = n2.el = n1.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n1.patchFlag & 16;
        const oldProps = n1.props || EMPTY_OBJ;
        const newProps = n2.props || EMPTY_OBJ;
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
          invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
        }
        parentComponent && toggleRecurse(parentComponent, true);
        if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
          hostSetElementText(el2, "");
        }
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            el2,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace),
            slotScopeIds
          );
        } else if (!optimized) {
          patchChildren(
            n1,
            n2,
            el2,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace),
            slotScopeIds,
            false
          );
        }
        if (patchFlag > 0) {
          if (patchFlag & 16) {
            patchProps(el2, oldProps, newProps, parentComponent, namespace);
          } else {
            if (patchFlag & 2) {
              if (oldProps.class !== newProps.class) {
                hostPatchProp(el2, "class", null, newProps.class, namespace);
              }
            }
            if (patchFlag & 4) {
              hostPatchProp(el2, "style", oldProps.style, newProps.style, namespace);
            }
            if (patchFlag & 8) {
              const propsToUpdate = n2.dynamicProps;
              for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
                const key = propsToUpdate[i2];
                const prev = oldProps[key];
                const next2 = newProps[key];
                if (next2 !== prev || key === "value") {
                  hostPatchProp(el2, key, prev, next2, namespace, parentComponent);
                }
              }
            }
          }
          if (patchFlag & 1) {
            if (n1.children !== n2.children) {
              hostSetElementText(el2, n2.children);
            }
          }
        } else if (!optimized && dynamicChildren == null) {
          patchProps(el2, oldProps, newProps, parentComponent, namespace);
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
          }, parentSuspense);
        }
      };
      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
        for (let i2 = 0; i2 < newChildren.length; i2++) {
          const oldVNode = oldChildren[i2];
          const newVNode = newChildren[i2];
          const container = (
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
              // In other cases, the parent container is not actually used so we
              // just pass the block element here to avoid a DOM parentNode call.
              fallbackContainer
            )
          );
          patch(
            oldVNode,
            newVNode,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            true
          );
        }
      };
      const patchProps = (el2, oldProps, newProps, parentComponent, namespace) => {
        if (oldProps !== newProps) {
          if (oldProps !== EMPTY_OBJ) {
            for (const key in oldProps) {
              if (!isReservedProp(key) && !(key in newProps)) {
                hostPatchProp(
                  el2,
                  key,
                  oldProps[key],
                  null,
                  namespace,
                  parentComponent
                );
              }
            }
          }
          for (const key in newProps) {
            if (isReservedProp(key))
              continue;
            const next2 = newProps[key];
            const prev = oldProps[key];
            if (next2 !== prev && key !== "value") {
              hostPatchProp(el2, key, prev, next2, namespace, parentComponent);
            }
          }
          if ("value" in newProps) {
            hostPatchProp(el2, "value", oldProps.value, newProps.value, namespace);
          }
        }
      };
      const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        if (n1 == null) {
          hostInsert(fragmentStartAnchor, container, anchor);
          hostInsert(fragmentEndAnchor, container, anchor);
          mountChildren(
            // #10007
            // such fragment like `<></>` will be compiled into
            // a fragment which doesn't have a children.
            // In this case fallback to an empty array
            n2.children || [],
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
          // of renderSlot() with no valid children
          n1.dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              container,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds
            );
            if (
              // #2080 if the stable fragment has a key, it's a <template v-for> that may
              //  get moved around. Make sure all root level vnodes inherit el.
              // #2134 or if it's a component root, it may also get moved around
              // as the component is being moved.
              n2.key != null || parentComponent && n2 === parentComponent.subTree
            ) {
              traverseStaticChildren(
                n1,
                n2,
                true
                /* shallow */
              );
            }
          } else {
            patchChildren(
              n1,
              n2,
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      };
      const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
          if (n2.shapeFlag & 512) {
            parentComponent.ctx.activate(
              n2,
              container,
              anchor,
              namespace,
              optimized
            );
          } else {
            mountComponent(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              optimized
            );
          }
        } else {
          updateComponent(n1, n2, optimized);
        }
      };
      const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
        const instance = initialVNode.component = createComponentInstance(
          initialVNode,
          parentComponent,
          parentSuspense
        );
        if (isKeepAlive(initialVNode)) {
          instance.ctx.renderer = internals;
        }
        {
          setupComponent(instance, false, optimized);
        }
        if (instance.asyncDep) {
          parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
          if (!initialVNode.el) {
            const placeholder = instance.subTree = createVNode(Comment);
            processCommentNode(null, placeholder, container, anchor);
          }
        } else {
          setupRenderEffect(
            instance,
            initialVNode,
            container,
            anchor,
            parentSuspense,
            namespace,
            optimized
          );
        }
      };
      const updateComponent = (n1, n2, optimized) => {
        const instance = n2.component = n1.component;
        if (shouldUpdateComponent(n1, n2, optimized)) {
          if (instance.asyncDep && !instance.asyncResolved) {
            updateComponentPreRender(instance, n2, optimized);
            return;
          } else {
            instance.next = n2;
            invalidateJob(instance.update);
            instance.effect.dirty = true;
            instance.update();
          }
        } else {
          n2.el = n1.el;
          instance.vnode = n2;
        }
      };
      const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
        const componentUpdateFn = () => {
          if (!instance.isMounted) {
            let vnodeHook;
            const { el: el2, props } = initialVNode;
            const { bm, m, parent } = instance;
            const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
            toggleRecurse(instance, false);
            if (bm) {
              invokeArrayFns(bm);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
              invokeVNodeHook(vnodeHook, parent, initialVNode);
            }
            toggleRecurse(instance, true);
            if (el2 && hydrateNode) {
              const hydrateSubTree = () => {
                instance.subTree = renderComponentRoot(instance);
                hydrateNode(
                  el2,
                  instance.subTree,
                  instance,
                  parentSuspense,
                  null
                );
              };
              if (isAsyncWrapperVNode) {
                initialVNode.type.__asyncLoader().then(
                  // note: we are moving the render call into an async callback,
                  // which means it won't track dependencies - but it's ok because
                  // a server-rendered async wrapper is already in resolved state
                  // and it will never need to change.
                  () => !instance.isUnmounted && hydrateSubTree()
                );
              } else {
                hydrateSubTree();
              }
            } else {
              const subTree = instance.subTree = renderComponentRoot(instance);
              patch(
                null,
                subTree,
                container,
                anchor,
                instance,
                parentSuspense,
                namespace
              );
              initialVNode.el = subTree.el;
            }
            if (m) {
              queuePostRenderEffect(m, parentSuspense);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
              const scopedInitialVNode = initialVNode;
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                parentSuspense
              );
            }
            if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
              instance.a && queuePostRenderEffect(instance.a, parentSuspense);
            }
            instance.isMounted = true;
            initialVNode = container = anchor = null;
          } else {
            let { next: next2, bu, u, parent, vnode } = instance;
            {
              const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
              if (nonHydratedAsyncRoot) {
                if (next2) {
                  next2.el = vnode.el;
                  updateComponentPreRender(instance, next2, optimized);
                }
                nonHydratedAsyncRoot.asyncDep.then(() => {
                  if (!instance.isUnmounted) {
                    componentUpdateFn();
                  }
                });
                return;
              }
            }
            let originNext = next2;
            let vnodeHook;
            toggleRecurse(instance, false);
            if (next2) {
              next2.el = vnode.el;
              updateComponentPreRender(instance, next2, optimized);
            } else {
              next2 = vnode;
            }
            if (bu) {
              invokeArrayFns(bu);
            }
            if (vnodeHook = next2.props && next2.props.onVnodeBeforeUpdate) {
              invokeVNodeHook(vnodeHook, parent, next2, vnode);
            }
            toggleRecurse(instance, true);
            const nextTree = renderComponentRoot(instance);
            const prevTree = instance.subTree;
            instance.subTree = nextTree;
            patch(
              prevTree,
              nextTree,
              // parent may have changed if it's in a teleport
              hostParentNode(prevTree.el),
              // anchor may have changed if it's in a fragment
              getNextHostNode(prevTree),
              instance,
              parentSuspense,
              namespace
            );
            next2.el = nextTree.el;
            if (originNext === null) {
              updateHOCHostEl(instance, nextTree.el);
            }
            if (u) {
              queuePostRenderEffect(u, parentSuspense);
            }
            if (vnodeHook = next2.props && next2.props.onVnodeUpdated) {
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, next2, vnode),
                parentSuspense
              );
            }
          }
        };
        const effect2 = instance.effect = new ReactiveEffect(
          componentUpdateFn,
          NOOP,
          () => queueJob(update),
          instance.scope
          // track it in component's effect scope
        );
        const update = instance.update = () => {
          if (effect2.dirty) {
            effect2.run();
          }
        };
        update.i = instance;
        update.id = instance.uid;
        toggleRecurse(instance, true);
        update();
      };
      const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        pauseTracking();
        flushPreFlushCbs(instance);
        resetTracking();
      };
      const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
          if (patchFlag & 128) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            return;
          } else if (patchFlag & 256) {
            patchUnkeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            return;
          }
        }
        if (shapeFlag & 8) {
          if (prevShapeFlag & 16) {
            unmountChildren(c1, parentComponent, parentSuspense);
          }
          if (c2 !== c1) {
            hostSetElementText(container, c2);
          }
        } else {
          if (prevShapeFlag & 16) {
            if (shapeFlag & 16) {
              patchKeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else {
              unmountChildren(c1, parentComponent, parentSuspense, true);
            }
          } else {
            if (prevShapeFlag & 8) {
              hostSetElementText(container, "");
            }
            if (shapeFlag & 16) {
              mountChildren(
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            }
          }
        }
      };
      const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        c1 = c1 || EMPTY_ARR;
        c2 = c2 || EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i2;
        for (i2 = 0; i2 < commonLength; i2++) {
          const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
          patch(
            c1[i2],
            nextChild,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
        if (oldLength > newLength) {
          unmountChildren(
            c1,
            parentComponent,
            parentSuspense,
            true,
            false,
            commonLength
          );
        } else {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            commonLength
          );
        }
      };
      const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        let i2 = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1;
        let e2 = l2 - 1;
        while (i2 <= e1 && i2 <= e2) {
          const n1 = c1[i2];
          const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          i2++;
        }
        while (i2 <= e1 && i2 <= e2) {
          const n1 = c1[e1];
          const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          e1--;
          e2--;
        }
        if (i2 > e1) {
          if (i2 <= e2) {
            const nextPos = e2 + 1;
            const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
            while (i2 <= e2) {
              patch(
                null,
                c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]),
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              i2++;
            }
          }
        } else if (i2 > e2) {
          while (i2 <= e1) {
            unmount(c1[i2], parentComponent, parentSuspense, true);
            i2++;
          }
        } else {
          const s1 = i2;
          const s2 = i2;
          const keyToNewIndexMap = /* @__PURE__ */ new Map();
          for (i2 = s2; i2 <= e2; i2++) {
            const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
            if (nextChild.key != null) {
              keyToNewIndexMap.set(nextChild.key, i2);
            }
          }
          let j;
          let patched = 0;
          const toBePatched = e2 - s2 + 1;
          let moved = false;
          let maxNewIndexSoFar = 0;
          const newIndexToOldIndexMap = new Array(toBePatched);
          for (i2 = 0; i2 < toBePatched; i2++)
            newIndexToOldIndexMap[i2] = 0;
          for (i2 = s1; i2 <= e1; i2++) {
            const prevChild = c1[i2];
            if (patched >= toBePatched) {
              unmount(prevChild, parentComponent, parentSuspense, true);
              continue;
            }
            let newIndex;
            if (prevChild.key != null) {
              newIndex = keyToNewIndexMap.get(prevChild.key);
            } else {
              for (j = s2; j <= e2; j++) {
                if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                  newIndex = j;
                  break;
                }
              }
            }
            if (newIndex === void 0) {
              unmount(prevChild, parentComponent, parentSuspense, true);
            } else {
              newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
              if (newIndex >= maxNewIndexSoFar) {
                maxNewIndexSoFar = newIndex;
              } else {
                moved = true;
              }
              patch(
                prevChild,
                c2[newIndex],
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              patched++;
            }
          }
          const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
          j = increasingNewIndexSequence.length - 1;
          for (i2 = toBePatched - 1; i2 >= 0; i2--) {
            const nextIndex = s2 + i2;
            const nextChild = c2[nextIndex];
            const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
            if (newIndexToOldIndexMap[i2] === 0) {
              patch(
                null,
                nextChild,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (moved) {
              if (j < 0 || i2 !== increasingNewIndexSequence[j]) {
                move(nextChild, container, anchor, 2);
              } else {
                j--;
              }
            }
          }
        }
      };
      const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el: el2, type: type2, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
          move(vnode.component.subTree, container, anchor, moveType);
          return;
        }
        if (shapeFlag & 128) {
          vnode.suspense.move(container, anchor, moveType);
          return;
        }
        if (shapeFlag & 64) {
          type2.move(vnode, container, anchor, internals);
          return;
        }
        if (type2 === Fragment) {
          hostInsert(el2, container, anchor);
          for (let i2 = 0; i2 < children.length; i2++) {
            move(children[i2], container, anchor, moveType);
          }
          hostInsert(vnode.anchor, container, anchor);
          return;
        }
        if (type2 === Static) {
          moveStaticNode(vnode, container, anchor);
          return;
        }
        const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition2) {
          if (moveType === 0) {
            transition.beforeEnter(el2);
            hostInsert(el2, container, anchor);
            queuePostRenderEffect(() => transition.enter(el2), parentSuspense);
          } else {
            const { leave, delayLeave, afterLeave } = transition;
            const remove22 = () => hostInsert(el2, container, anchor);
            const performLeave = () => {
              leave(el2, () => {
                remove22();
                afterLeave && afterLeave();
              });
            };
            if (delayLeave) {
              delayLeave(el2, remove22, performLeave);
            } else {
              performLeave();
            }
          }
        } else {
          hostInsert(el2, container, anchor);
        }
      };
      const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const {
          type: type2,
          props,
          ref: ref3,
          children,
          dynamicChildren,
          shapeFlag,
          patchFlag,
          dirs,
          cacheIndex
        } = vnode;
        if (patchFlag === -2) {
          optimized = false;
        }
        if (ref3 != null) {
          setRef(ref3, null, parentSuspense, vnode, true);
        }
        if (cacheIndex != null) {
          parentComponent.renderCache[cacheIndex] = void 0;
        }
        if (shapeFlag & 256) {
          parentComponent.ctx.deactivate(vnode);
          return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6) {
          unmountComponent(vnode.component, parentSuspense, doRemove);
        } else {
          if (shapeFlag & 128) {
            vnode.suspense.unmount(parentSuspense, doRemove);
            return;
          }
          if (shouldInvokeDirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
          }
          if (shapeFlag & 64) {
            vnode.type.remove(
              vnode,
              parentComponent,
              parentSuspense,
              internals,
              doRemove
            );
          } else if (dynamicChildren && // #5154
          // when v-once is used inside a block, setBlockTracking(-1) marks the
          // parent block with hasOnce: true
          // so that it doesn't take the fast path during unmount - otherwise
          // components nested in v-once are never unmounted.
          !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
          (type2 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
            unmountChildren(
              dynamicChildren,
              parentComponent,
              parentSuspense,
              false,
              true
            );
          } else if (type2 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
            unmountChildren(children, parentComponent, parentSuspense);
          }
          if (doRemove) {
            remove2(vnode);
          }
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
          }, parentSuspense);
        }
      };
      const remove2 = (vnode) => {
        const { type: type2, el: el2, anchor, transition } = vnode;
        if (type2 === Fragment) {
          {
            removeFragment(el2, anchor);
          }
          return;
        }
        if (type2 === Static) {
          removeStaticNode(vnode);
          return;
        }
        const performRemove = () => {
          hostRemove(el2);
          if (transition && !transition.persisted && transition.afterLeave) {
            transition.afterLeave();
          }
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
          const { leave, delayLeave } = transition;
          const performLeave = () => leave(el2, performRemove);
          if (delayLeave) {
            delayLeave(vnode.el, performRemove, performLeave);
          } else {
            performLeave();
          }
        } else {
          performRemove();
        }
      };
      const removeFragment = (cur, end) => {
        let next2;
        while (cur !== end) {
          next2 = hostNextSibling(cur);
          hostRemove(cur);
          cur = next2;
        }
        hostRemove(end);
      };
      const unmountComponent = (instance, parentSuspense, doRemove) => {
        const { bum, scope: scope2, update, subTree, um, m, a } = instance;
        invalidateMount(m);
        invalidateMount(a);
        if (bum) {
          invokeArrayFns(bum);
        }
        scope2.stop();
        if (update) {
          update.active = false;
          unmount(subTree, instance, parentSuspense, doRemove);
        }
        if (um) {
          queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
          instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0) {
            parentSuspense.resolve();
          }
        }
      };
      const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
        for (let i2 = start; i2 < children.length; i2++) {
          unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
        }
      };
      const getNextHostNode = (vnode) => {
        if (vnode.shapeFlag & 6) {
          return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128) {
          return vnode.suspense.next();
        }
        const el2 = hostNextSibling(vnode.anchor || vnode.el);
        const teleportEnd = el2 && el2[TeleportEndKey];
        return teleportEnd ? hostNextSibling(teleportEnd) : el2;
      };
      let isFlushing2 = false;
      const render = (vnode, container, namespace) => {
        if (vnode == null) {
          if (container._vnode) {
            unmount(container._vnode, null, null, true);
          }
        } else {
          patch(
            container._vnode || null,
            vnode,
            container,
            null,
            null,
            null,
            namespace
          );
        }
        if (!isFlushing2) {
          isFlushing2 = true;
          flushPreFlushCbs();
          flushPostFlushCbs();
          isFlushing2 = false;
        }
        container._vnode = vnode;
      };
      const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove2,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
      };
      let hydrate;
      let hydrateNode;
      if (createHydrationFns) {
        [hydrate, hydrateNode] = createHydrationFns(
          internals
        );
      }
      return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
      };
    }
    function resolveChildrenNamespace({ type: type2, props }, currentNamespace) {
      return currentNamespace === "svg" && type2 === "foreignObject" || currentNamespace === "mathml" && type2 === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
    }
    function toggleRecurse({ effect: effect2, update }, allowed) {
      effect2.allowRecurse = update.allowRecurse = allowed;
    }
    function needTransition(parentSuspense, transition) {
      return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    }
    function traverseStaticChildren(n1, n2, shallow = false) {
      const ch1 = n1.children;
      const ch2 = n2.children;
      if (isArray$1(ch1) && isArray$1(ch2)) {
        for (let i2 = 0; i2 < ch1.length; i2++) {
          const c1 = ch1[i2];
          let c2 = ch2[i2];
          if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
              c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
              c2.el = c1.el;
            }
            if (!shallow && c2.patchFlag !== -2)
              traverseStaticChildren(c1, c2);
          }
          if (c2.type === Text$2) {
            c2.el = c1.el;
          }
        }
      }
    }
    function getSequence(arr) {
      const p2 = arr.slice();
      const result = [0];
      let i2, j, u, v, c;
      const len = arr.length;
      for (i2 = 0; i2 < len; i2++) {
        const arrI = arr[i2];
        if (arrI !== 0) {
          j = result[result.length - 1];
          if (arr[j] < arrI) {
            p2[i2] = j;
            result.push(i2);
            continue;
          }
          u = 0;
          v = result.length - 1;
          while (u < v) {
            c = u + v >> 1;
            if (arr[result[c]] < arrI) {
              u = c + 1;
            } else {
              v = c;
            }
          }
          if (arrI < arr[result[u]]) {
            if (u > 0) {
              p2[i2] = result[u - 1];
            }
            result[u] = i2;
          }
        }
      }
      u = result.length;
      v = result[u - 1];
      while (u-- > 0) {
        result[u] = v;
        v = p2[v];
      }
      return result;
    }
    function locateNonHydratedAsyncRoot(instance) {
      const subComponent = instance.subTree.component;
      if (subComponent) {
        if (subComponent.asyncDep && !subComponent.asyncResolved) {
          return subComponent;
        } else {
          return locateNonHydratedAsyncRoot(subComponent);
        }
      }
    }
    function invalidateMount(hooks) {
      if (hooks) {
        for (let i2 = 0; i2 < hooks.length; i2++)
          hooks[i2].active = false;
      }
    }
    const ssrContextKey = Symbol.for("v-scx");
    const useSSRContext = () => {
      {
        const ctx = inject$1(ssrContextKey);
        return ctx;
      }
    };
    function watchEffect(effect2, options) {
      return doWatch(effect2, null, options);
    }
    function watchSyncEffect(effect2, options) {
      return doWatch(
        effect2,
        null,
        { flush: "sync" }
      );
    }
    const INITIAL_WATCHER_VALUE = {};
    function watch(source2, cb, options) {
      return doWatch(source2, cb, options);
    }
    function doWatch(source2, cb, {
      immediate,
      deep,
      flush,
      once,
      onTrack,
      onTrigger
    } = EMPTY_OBJ) {
      if (cb && once) {
        const _cb = cb;
        cb = (...args) => {
          _cb(...args);
          unwatch();
        };
      }
      const instance = currentInstance;
      const reactiveGetter = (source22) => deep === true ? source22 : (
        // for deep: false, only traverse root-level properties
        traverse$2(source22, deep === false ? 1 : void 0)
      );
      let getter;
      let forceTrigger = false;
      let isMultiSource = false;
      if (isRef(source2)) {
        getter = () => source2.value;
        forceTrigger = isShallow(source2);
      } else if (isReactive(source2)) {
        getter = () => reactiveGetter(source2);
        forceTrigger = true;
      } else if (isArray$1(source2)) {
        isMultiSource = true;
        forceTrigger = source2.some((s) => isReactive(s) || isShallow(s));
        getter = () => source2.map((s) => {
          if (isRef(s)) {
            return s.value;
          } else if (isReactive(s)) {
            return reactiveGetter(s);
          } else if (isFunction$1(s)) {
            return callWithErrorHandling(s, instance, 2);
          } else
            ;
        });
      } else if (isFunction$1(source2)) {
        if (cb) {
          getter = () => callWithErrorHandling(source2, instance, 2);
        } else {
          getter = () => {
            if (cleanup) {
              cleanup();
            }
            return callWithAsyncErrorHandling(
              source2,
              instance,
              3,
              [onCleanup]
            );
          };
        }
      } else {
        getter = NOOP;
      }
      if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse$2(baseGetter());
      }
      let cleanup;
      let onCleanup = (fn) => {
        cleanup = effect2.onStop = () => {
          callWithErrorHandling(fn, instance, 4);
          cleanup = effect2.onStop = void 0;
        };
      };
      let ssrCleanup;
      if (isInSSRComponentSetup) {
        onCleanup = NOOP;
        if (!cb) {
          getter();
        } else if (immediate) {
          callWithAsyncErrorHandling(cb, instance, 3, [
            getter(),
            isMultiSource ? [] : void 0,
            onCleanup
          ]);
        }
        if (flush === "sync") {
          const ctx = useSSRContext();
          ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
        } else {
          return NOOP;
        }
      }
      let oldValue = isMultiSource ? new Array(source2.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
      const job = () => {
        if (!effect2.active || !effect2.dirty) {
          return;
        }
        if (cb) {
          const newValue = effect2.run();
          if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i2) => hasChanged(v, oldValue[i2])) : hasChanged(newValue, oldValue)) || false) {
            if (cleanup) {
              cleanup();
            }
            callWithAsyncErrorHandling(cb, instance, 3, [
              newValue,
              // pass undefined as the old value when it's changed for the first time
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              onCleanup
            ]);
            oldValue = newValue;
          }
        } else {
          effect2.run();
        }
      };
      job.allowRecurse = !!cb;
      let scheduler;
      if (flush === "sync") {
        scheduler = job;
      } else if (flush === "post") {
        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
      } else {
        job.pre = true;
        if (instance)
          job.id = instance.uid;
        scheduler = () => queueJob(job);
      }
      const effect2 = new ReactiveEffect(getter, NOOP, scheduler);
      const scope2 = getCurrentScope$1();
      const unwatch = () => {
        effect2.stop();
        if (scope2) {
          remove(scope2.effects, effect2);
        }
      };
      if (cb) {
        if (immediate) {
          job();
        } else {
          oldValue = effect2.run();
        }
      } else if (flush === "post") {
        queuePostRenderEffect(
          effect2.run.bind(effect2),
          instance && instance.suspense
        );
      } else {
        effect2.run();
      }
      if (ssrCleanup)
        ssrCleanup.push(unwatch);
      return unwatch;
    }
    function instanceWatch(source2, value, options) {
      const publicThis = this.proxy;
      const getter = isString$1(source2) ? source2.includes(".") ? createPathGetter(publicThis, source2) : () => publicThis[source2] : source2.bind(publicThis, publicThis);
      let cb;
      if (isFunction$1(value)) {
        cb = value;
      } else {
        cb = value.handler;
        options = value;
      }
      const reset = setCurrentInstance(this);
      const res = doWatch(getter, cb.bind(publicThis), options);
      reset();
      return res;
    }
    function createPathGetter(ctx, path) {
      const segments = path.split(".");
      return () => {
        let cur = ctx;
        for (let i2 = 0; i2 < segments.length && cur; i2++) {
          cur = cur[segments[i2]];
        }
        return cur;
      };
    }
    function traverse$2(value, depth = Infinity, seen) {
      if (depth <= 0 || !isObject$4(value) || value["__v_skip"]) {
        return value;
      }
      seen = seen || /* @__PURE__ */ new Set();
      if (seen.has(value)) {
        return value;
      }
      seen.add(value);
      depth--;
      if (isRef(value)) {
        traverse$2(value.value, depth, seen);
      } else if (isArray$1(value)) {
        for (let i2 = 0; i2 < value.length; i2++) {
          traverse$2(value[i2], depth, seen);
        }
      } else if (isSet$1(value) || isMap$1(value)) {
        value.forEach((v) => {
          traverse$2(v, depth, seen);
        });
      } else if (isPlainObject$3(value)) {
        for (const key in value) {
          traverse$2(value[key], depth, seen);
        }
        for (const key of Object.getOwnPropertySymbols(value)) {
          if (Object.prototype.propertyIsEnumerable.call(value, key)) {
            traverse$2(value[key], depth, seen);
          }
        }
      }
      return value;
    }
    function useModel(props, name, options = EMPTY_OBJ) {
      const i2 = getCurrentInstance$1();
      const camelizedName = camelize(name);
      const hyphenatedName = hyphenate(name);
      const modifiers = getModelModifiers(props, name);
      const res = customRef((track2, trigger2) => {
        let localValue;
        let prevSetValue = EMPTY_OBJ;
        let prevEmittedValue;
        watchSyncEffect(() => {
          const propValue = props[name];
          if (hasChanged(localValue, propValue)) {
            localValue = propValue;
            trigger2();
          }
        });
        return {
          get() {
            track2();
            return options.get ? options.get(localValue) : localValue;
          },
          set(value) {
            if (!hasChanged(value, localValue) && !(prevSetValue !== EMPTY_OBJ && hasChanged(value, prevSetValue))) {
              return;
            }
            const rawProps = i2.vnode.props;
            if (!(rawProps && // check if parent has passed v-model
            (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps))) {
              localValue = value;
              trigger2();
            }
            const emittedValue = options.set ? options.set(value) : value;
            i2.emit(`update:${name}`, emittedValue);
            if (hasChanged(value, emittedValue) && hasChanged(value, prevSetValue) && !hasChanged(emittedValue, prevEmittedValue)) {
              trigger2();
            }
            prevSetValue = value;
            prevEmittedValue = emittedValue;
          }
        };
      });
      res[Symbol.iterator] = () => {
        let i22 = 0;
        return {
          next() {
            if (i22 < 2) {
              return { value: i22++ ? modifiers || EMPTY_OBJ : res, done: false };
            } else {
              return { done: true };
            }
          }
        };
      };
      return res;
    }
    const getModelModifiers = (props, modelName) => {
      return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
    };
    function emit(instance, event, ...rawArgs) {
      if (instance.isUnmounted)
        return;
      const props = instance.vnode.props || EMPTY_OBJ;
      let args = rawArgs;
      const isModelListener2 = event.startsWith("update:");
      const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
      if (modifiers) {
        if (modifiers.trim) {
          args = rawArgs.map((a) => isString$1(a) ? a.trim() : a);
        }
        if (modifiers.number) {
          args = rawArgs.map(looseToNumber);
        }
      }
      let handlerName;
      let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
      props[handlerName = toHandlerKey(camelize(event))];
      if (!handler && isModelListener2) {
        handler = props[handlerName = toHandlerKey(hyphenate(event))];
      }
      if (handler) {
        callWithAsyncErrorHandling(
          handler,
          instance,
          6,
          args
        );
      }
      const onceHandler = props[handlerName + `Once`];
      if (onceHandler) {
        if (!instance.emitted) {
          instance.emitted = {};
        } else if (instance.emitted[handlerName]) {
          return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(
          onceHandler,
          instance,
          6,
          args
        );
      }
    }
    function normalizeEmitsOptions(comp2, appContext, asMixin = false) {
      const cache2 = appContext.emitsCache;
      const cached = cache2.get(comp2);
      if (cached !== void 0) {
        return cached;
      }
      const raw = comp2.emits;
      let normalized = {};
      let hasExtends = false;
      if (!isFunction$1(comp2)) {
        const extendEmits = (raw2) => {
          const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
          if (normalizedFromExtend) {
            hasExtends = true;
            extend$1(normalized, normalizedFromExtend);
          }
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendEmits);
        }
        if (comp2.extends) {
          extendEmits(comp2.extends);
        }
        if (comp2.mixins) {
          comp2.mixins.forEach(extendEmits);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$4(comp2)) {
          cache2.set(comp2, null);
        }
        return null;
      }
      if (isArray$1(raw)) {
        raw.forEach((key) => normalized[key] = null);
      } else {
        extend$1(normalized, raw);
      }
      if (isObject$4(comp2)) {
        cache2.set(comp2, normalized);
      }
      return normalized;
    }
    function isEmitListener(options, key) {
      if (!options || !isOn$1(key)) {
        return false;
      }
      key = key.slice(2).replace(/Once$/, "");
      return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
    }
    function markAttrsAccessed() {
    }
    function renderComponentRoot(instance) {
      const {
        type: Component,
        vnode,
        proxy,
        withProxy,
        propsOptions: [propsOptions],
        slots,
        attrs,
        emit: emit2,
        render,
        renderCache,
        props,
        data,
        setupState,
        ctx,
        inheritAttrs
      } = instance;
      const prev = setCurrentRenderingInstance(instance);
      let result;
      let fallthroughAttrs;
      try {
        if (vnode.shapeFlag & 4) {
          const proxyToUse = withProxy || proxy;
          const thisProxy = false ? new Proxy(proxyToUse, {
            get(target2, key, receiver) {
              warn$1(
                `Property '${String(
                  key
                )}' was accessed via 'this'. Avoid using 'this' in templates.`
              );
              return Reflect.get(target2, key, receiver);
            }
          }) : proxyToUse;
          result = normalizeVNode(
            render.call(
              thisProxy,
              proxyToUse,
              renderCache,
              false ? shallowReadonly(props) : props,
              setupState,
              data,
              ctx
            )
          );
          fallthroughAttrs = attrs;
        } else {
          const render2 = Component;
          if (false)
            ;
          result = normalizeVNode(
            render2.length > 1 ? render2(
              false ? shallowReadonly(props) : props,
              false ? {
                get attrs() {
                  markAttrsAccessed();
                  return shallowReadonly(attrs);
                },
                slots,
                emit: emit2
              } : { attrs, slots, emit: emit2 }
            ) : render2(
              false ? shallowReadonly(props) : props,
              null
            )
          );
          fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
      } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
      }
      let root = result;
      if (fallthroughAttrs && inheritAttrs !== false) {
        const keys2 = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root;
        if (keys2.length) {
          if (shapeFlag & (1 | 6)) {
            if (propsOptions && keys2.some(isModelListener)) {
              fallthroughAttrs = filterModelListeners(
                fallthroughAttrs,
                propsOptions
              );
            }
            root = cloneVNode(root, fallthroughAttrs, false, true);
          }
        }
      }
      if (vnode.dirs) {
        root = cloneVNode(root, null, false, true);
        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
      }
      if (vnode.transition) {
        root.transition = vnode.transition;
      }
      {
        result = root;
      }
      setCurrentRenderingInstance(prev);
      return result;
    }
    function filterSingleRoot(children, recurse = true) {
      let singleRoot;
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        if (isVNode(child)) {
          if (child.type !== Comment || child.children === "v-if") {
            if (singleRoot) {
              return;
            } else {
              singleRoot = child;
            }
          }
        } else {
          return;
        }
      }
      return singleRoot;
    }
    const getFunctionalFallthrough = (attrs) => {
      let res;
      for (const key in attrs) {
        if (key === "class" || key === "style" || isOn$1(key)) {
          (res || (res = {}))[key] = attrs[key];
        }
      }
      return res;
    };
    const filterModelListeners = (attrs, props) => {
      const res = {};
      for (const key in attrs) {
        if (!isModelListener(key) || !(key.slice(9) in props)) {
          res[key] = attrs[key];
        }
      }
      return res;
    };
    function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
      const { props: prevProps, children: prevChildren, component } = prevVNode;
      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
      const emits2 = component.emitsOptions;
      if (nextVNode.dirs || nextVNode.transition) {
        return true;
      }
      if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) {
          return true;
        }
        if (patchFlag & 16) {
          if (!prevProps) {
            return !!nextProps;
          }
          return hasPropsChanged(prevProps, nextProps, emits2);
        } else if (patchFlag & 8) {
          const dynamicProps = nextVNode.dynamicProps;
          for (let i2 = 0; i2 < dynamicProps.length; i2++) {
            const key = dynamicProps[i2];
            if (nextProps[key] !== prevProps[key] && !isEmitListener(emits2, key)) {
              return true;
            }
          }
        }
      } else {
        if (prevChildren || nextChildren) {
          if (!nextChildren || !nextChildren.$stable) {
            return true;
          }
        }
        if (prevProps === nextProps) {
          return false;
        }
        if (!prevProps) {
          return !!nextProps;
        }
        if (!nextProps) {
          return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits2);
      }
      return false;
    }
    function hasPropsChanged(prevProps, nextProps, emitsOptions) {
      const nextKeys = Object.keys(nextProps);
      if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
      }
      for (let i2 = 0; i2 < nextKeys.length; i2++) {
        const key = nextKeys[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
          return true;
        }
      }
      return false;
    }
    function updateHOCHostEl({ vnode, parent }, el2) {
      while (parent) {
        const root = parent.subTree;
        if (root.suspense && root.suspense.activeBranch === vnode) {
          root.el = vnode.el;
        }
        if (root === vnode) {
          (vnode = parent.vnode).el = el2;
          parent = parent.parent;
        } else {
          break;
        }
      }
    }
    const isSuspense = (type2) => type2.__isSuspense;
    let suspenseId = 0;
    const SuspenseImpl = {
      name: "Suspense",
      // In order to make Suspense tree-shakable, we need to avoid importing it
      // directly in the renderer. The renderer checks for the __isSuspense flag
      // on a vnode's type and calls the `process` method, passing in renderer
      // internals.
      __isSuspense: true,
      process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
        if (n1 == null) {
          mountSuspense(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            rendererInternals
          );
        } else {
          if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
            n2.suspense = n1.suspense;
            n2.suspense.vnode = n2;
            n2.el = n1.el;
            return;
          }
          patchSuspense(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            namespace,
            slotScopeIds,
            optimized,
            rendererInternals
          );
        }
      },
      hydrate: hydrateSuspense,
      normalize: normalizeSuspenseChildren
    };
    const Suspense = SuspenseImpl;
    function triggerEvent(vnode, name) {
      const eventListener = vnode.props && vnode.props[name];
      if (isFunction$1(eventListener)) {
        eventListener();
      }
    }
    function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
      const {
        p: patch,
        o: { createElement }
      } = rendererInternals;
      const hiddenContainer = createElement("div");
      const suspense = vnode.suspense = createSuspenseBoundary(
        vnode,
        parentSuspense,
        parentComponent,
        container,
        hiddenContainer,
        anchor,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
      patch(
        null,
        suspense.pendingBranch = vnode.ssContent,
        hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds
      );
      if (suspense.deps > 0) {
        triggerEvent(vnode, "onPending");
        triggerEvent(vnode, "onFallback");
        patch(
          null,
          vnode.ssFallback,
          container,
          anchor,
          parentComponent,
          null,
          // fallback tree will not have suspense context
          namespace,
          slotScopeIds
        );
        setActiveBranch(suspense, vnode.ssFallback);
      } else {
        suspense.resolve(false, true);
      }
    }
    function patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
      const suspense = n2.suspense = n1.suspense;
      suspense.vnode = n2;
      n2.el = n1.el;
      const newBranch = n2.ssContent;
      const newFallback = n2.ssFallback;
      const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
      if (pendingBranch) {
        suspense.pendingBranch = newBranch;
        if (isSameVNodeType(newBranch, pendingBranch)) {
          patch(
            pendingBranch,
            newBranch,
            suspense.hiddenContainer,
            null,
            parentComponent,
            suspense,
            namespace,
            slotScopeIds,
            optimized
          );
          if (suspense.deps <= 0) {
            suspense.resolve();
          } else if (isInFallback) {
            if (!isHydrating) {
              patch(
                activeBranch,
                newFallback,
                container,
                anchor,
                parentComponent,
                null,
                // fallback tree will not have suspense context
                namespace,
                slotScopeIds,
                optimized
              );
              setActiveBranch(suspense, newFallback);
            }
          }
        } else {
          suspense.pendingId = suspenseId++;
          if (isHydrating) {
            suspense.isHydrating = false;
            suspense.activeBranch = pendingBranch;
          } else {
            unmount(pendingBranch, parentComponent, suspense);
          }
          suspense.deps = 0;
          suspense.effects.length = 0;
          suspense.hiddenContainer = createElement("div");
          if (isInFallback) {
            patch(
              null,
              newBranch,
              suspense.hiddenContainer,
              null,
              parentComponent,
              suspense,
              namespace,
              slotScopeIds,
              optimized
            );
            if (suspense.deps <= 0) {
              suspense.resolve();
            } else {
              patch(
                activeBranch,
                newFallback,
                container,
                anchor,
                parentComponent,
                null,
                // fallback tree will not have suspense context
                namespace,
                slotScopeIds,
                optimized
              );
              setActiveBranch(suspense, newFallback);
            }
          } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
            patch(
              activeBranch,
              newBranch,
              container,
              anchor,
              parentComponent,
              suspense,
              namespace,
              slotScopeIds,
              optimized
            );
            suspense.resolve(true);
          } else {
            patch(
              null,
              newBranch,
              suspense.hiddenContainer,
              null,
              parentComponent,
              suspense,
              namespace,
              slotScopeIds,
              optimized
            );
            if (suspense.deps <= 0) {
              suspense.resolve();
            }
          }
        }
      } else {
        if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
          patch(
            activeBranch,
            newBranch,
            container,
            anchor,
            parentComponent,
            suspense,
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newBranch);
        } else {
          triggerEvent(n2, "onPending");
          suspense.pendingBranch = newBranch;
          if (newBranch.shapeFlag & 512) {
            suspense.pendingId = newBranch.component.suspenseId;
          } else {
            suspense.pendingId = suspenseId++;
          }
          patch(
            null,
            newBranch,
            suspense.hiddenContainer,
            null,
            parentComponent,
            suspense,
            namespace,
            slotScopeIds,
            optimized
          );
          if (suspense.deps <= 0) {
            suspense.resolve();
          } else {
            const { timeout, pendingId } = suspense;
            if (timeout > 0) {
              setTimeout(() => {
                if (suspense.pendingId === pendingId) {
                  suspense.fallback(newFallback);
                }
              }, timeout);
            } else if (timeout === 0) {
              suspense.fallback(newFallback);
            }
          }
        }
      }
    }
    function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
      const {
        p: patch,
        m: move,
        um: unmount,
        n: next2,
        o: { parentNode, remove: remove2 }
      } = rendererInternals;
      let parentSuspenseId;
      const isSuspensible = isVNodeSuspensible(vnode);
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch) {
          parentSuspenseId = parentSuspense.pendingId;
          parentSuspense.deps++;
        }
      }
      const timeout = vnode.props ? toNumber$1(vnode.props.timeout) : void 0;
      const initialAnchor = anchor;
      const suspense = {
        vnode,
        parent: parentSuspense,
        parentComponent,
        namespace,
        container,
        hiddenContainer,
        deps: 0,
        pendingId: suspenseId++,
        timeout: typeof timeout === "number" ? timeout : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: !isHydrating,
        isHydrating,
        isUnmounted: false,
        effects: [],
        resolve(resume = false, sync = false) {
          const {
            vnode: vnode2,
            activeBranch,
            pendingBranch,
            pendingId,
            effects,
            parentComponent: parentComponent2,
            container: container2
          } = suspense;
          let delayEnter = false;
          if (suspense.isHydrating) {
            suspense.isHydrating = false;
          } else if (!resume) {
            delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
            if (delayEnter) {
              activeBranch.transition.afterLeave = () => {
                if (pendingId === suspense.pendingId) {
                  move(
                    pendingBranch,
                    container2,
                    anchor === initialAnchor ? next2(activeBranch) : anchor,
                    0
                  );
                  queuePostFlushCb(effects);
                }
              };
            }
            if (activeBranch) {
              if (parentNode(activeBranch.el) !== suspense.hiddenContainer) {
                anchor = next2(activeBranch);
              }
              unmount(activeBranch, parentComponent2, suspense, true);
            }
            if (!delayEnter) {
              move(pendingBranch, container2, anchor, 0);
            }
          }
          setActiveBranch(suspense, pendingBranch);
          suspense.pendingBranch = null;
          suspense.isInFallback = false;
          let parent = suspense.parent;
          let hasUnresolvedAncestor = false;
          while (parent) {
            if (parent.pendingBranch) {
              parent.effects.push(...effects);
              hasUnresolvedAncestor = true;
              break;
            }
            parent = parent.parent;
          }
          if (!hasUnresolvedAncestor && !delayEnter) {
            queuePostFlushCb(effects);
          }
          suspense.effects = [];
          if (isSuspensible) {
            if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
              parentSuspense.deps--;
              if (parentSuspense.deps === 0 && !sync) {
                parentSuspense.resolve();
              }
            }
          }
          triggerEvent(vnode2, "onResolve");
        },
        fallback(fallbackVNode) {
          if (!suspense.pendingBranch) {
            return;
          }
          const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace2 } = suspense;
          triggerEvent(vnode2, "onFallback");
          const anchor2 = next2(activeBranch);
          const mountFallback = () => {
            if (!suspense.isInFallback) {
              return;
            }
            patch(
              null,
              fallbackVNode,
              container2,
              anchor2,
              parentComponent2,
              null,
              // fallback tree will not have suspense context
              namespace2,
              slotScopeIds,
              optimized
            );
            setActiveBranch(suspense, fallbackVNode);
          };
          const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
          if (delayEnter) {
            activeBranch.transition.afterLeave = mountFallback;
          }
          suspense.isInFallback = true;
          unmount(
            activeBranch,
            parentComponent2,
            null,
            // no suspense so unmount hooks fire now
            true
            // shouldRemove
          );
          if (!delayEnter) {
            mountFallback();
          }
        },
        move(container2, anchor2, type2) {
          suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type2);
          suspense.container = container2;
        },
        next() {
          return suspense.activeBranch && next2(suspense.activeBranch);
        },
        registerDep(instance, setupRenderEffect, optimized2) {
          const isInPendingSuspense = !!suspense.pendingBranch;
          if (isInPendingSuspense) {
            suspense.deps++;
          }
          const hydratedEl = instance.vnode.el;
          instance.asyncDep.catch((err) => {
            handleError(err, instance, 0);
          }).then((asyncSetupResult) => {
            if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
              return;
            }
            instance.asyncResolved = true;
            const { vnode: vnode2 } = instance;
            handleSetupResult(instance, asyncSetupResult, false);
            if (hydratedEl) {
              vnode2.el = hydratedEl;
            }
            const placeholder = !hydratedEl && instance.subTree.el;
            setupRenderEffect(
              instance,
              vnode2,
              // component may have been moved before resolve.
              // if this is not a hydration, instance.subTree will be the comment
              // placeholder.
              parentNode(hydratedEl || instance.subTree.el),
              // anchor will not be used if this is hydration, so only need to
              // consider the comment placeholder case.
              hydratedEl ? null : next2(instance.subTree),
              suspense,
              namespace,
              optimized2
            );
            if (placeholder) {
              remove2(placeholder);
            }
            updateHOCHostEl(instance, vnode2.el);
            if (isInPendingSuspense && --suspense.deps === 0) {
              suspense.resolve();
            }
          });
        },
        unmount(parentSuspense2, doRemove) {
          suspense.isUnmounted = true;
          if (suspense.activeBranch) {
            unmount(
              suspense.activeBranch,
              parentComponent,
              parentSuspense2,
              doRemove
            );
          }
          if (suspense.pendingBranch) {
            unmount(
              suspense.pendingBranch,
              parentComponent,
              parentSuspense2,
              doRemove
            );
          }
        }
      };
      return suspense;
    }
    function hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {
      const suspense = vnode.suspense = createSuspenseBoundary(
        vnode,
        parentSuspense,
        parentComponent,
        node.parentNode,
        // eslint-disable-next-line no-restricted-globals
        document.createElement("div"),
        null,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals,
        true
      );
      const result = hydrateNode(
        node,
        suspense.pendingBranch = vnode.ssContent,
        parentComponent,
        suspense,
        slotScopeIds,
        optimized
      );
      if (suspense.deps === 0) {
        suspense.resolve(false, true);
      }
      return result;
    }
    function normalizeSuspenseChildren(vnode) {
      const { shapeFlag, children } = vnode;
      const isSlotChildren = shapeFlag & 32;
      vnode.ssContent = normalizeSuspenseSlot(
        isSlotChildren ? children.default : children
      );
      vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
    }
    function normalizeSuspenseSlot(s) {
      let block2;
      if (isFunction$1(s)) {
        const trackBlock = isBlockTreeEnabled && s._c;
        if (trackBlock) {
          s._d = false;
          openBlock();
        }
        s = s();
        if (trackBlock) {
          s._d = true;
          block2 = currentBlock;
          closeBlock();
        }
      }
      if (isArray$1(s)) {
        const singleChild = filterSingleRoot(s);
        s = singleChild;
      }
      s = normalizeVNode(s);
      if (block2 && !s.dynamicChildren) {
        s.dynamicChildren = block2.filter((c) => c !== s);
      }
      return s;
    }
    function queueEffectWithSuspense(fn, suspense) {
      if (suspense && suspense.pendingBranch) {
        if (isArray$1(fn)) {
          suspense.effects.push(...fn);
        } else {
          suspense.effects.push(fn);
        }
      } else {
        queuePostFlushCb(fn);
      }
    }
    function setActiveBranch(suspense, branch) {
      suspense.activeBranch = branch;
      const { vnode, parentComponent } = suspense;
      let el2 = branch.el;
      while (!el2 && branch.component) {
        branch = branch.component.subTree;
        el2 = branch.el;
      }
      vnode.el = el2;
      if (parentComponent && parentComponent.subTree === vnode) {
        parentComponent.vnode.el = el2;
        updateHOCHostEl(parentComponent, el2);
      }
    }
    function isVNodeSuspensible(vnode) {
      const suspensible = vnode.props && vnode.props.suspensible;
      return suspensible != null && suspensible !== false;
    }
    const Fragment = Symbol.for("v-fgt");
    const Text$2 = Symbol.for("v-txt");
    const Comment = Symbol.for("v-cmt");
    const Static = Symbol.for("v-stc");
    const blockStack = [];
    let currentBlock = null;
    function openBlock(disableTracking = false) {
      blockStack.push(currentBlock = disableTracking ? null : []);
    }
    function closeBlock() {
      blockStack.pop();
      currentBlock = blockStack[blockStack.length - 1] || null;
    }
    let isBlockTreeEnabled = 1;
    function setBlockTracking(value) {
      isBlockTreeEnabled += value;
      if (value < 0 && currentBlock) {
        currentBlock.hasOnce = true;
      }
    }
    function setupBlock(vnode) {
      vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
      closeBlock();
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    function createElementBlock(type2, props, children, patchFlag, dynamicProps, shapeFlag) {
      return setupBlock(
        createBaseVNode(
          type2,
          props,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag,
          true
        )
      );
    }
    function createBlock(type2, props, children, patchFlag, dynamicProps) {
      return setupBlock(
        createVNode(
          type2,
          props,
          children,
          patchFlag,
          dynamicProps,
          true
        )
      );
    }
    function isVNode(value) {
      return value ? value.__v_isVNode === true : false;
    }
    function isSameVNodeType(n1, n2) {
      return n1.type === n2.type && n1.key === n2.key;
    }
    const normalizeKey = ({ key }) => key != null ? key : null;
    const normalizeRef = ({
      ref: ref3,
      ref_key,
      ref_for
    }) => {
      if (typeof ref3 === "number") {
        ref3 = "" + ref3;
      }
      return ref3 != null ? isString$1(ref3) || isRef(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
    };
    function createBaseVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type2 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
      const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type: type2,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetStart: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
      };
      if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) {
          type2.normalize(vnode);
        }
      } else if (children) {
        vnode.shapeFlag |= isString$1(children) ? 8 : 16;
      }
      if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
      !isBlockNode && // has current parent block
      currentBlock && // presence of a patch flag indicates this node needs patching on updates.
      // component nodes also should always be patched, because even if the
      // component doesn't need to update, it needs to persist the instance on to
      // the next vnode so that it can be properly unmounted later.
      (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
      // vnode should not be considered dynamic due to handler caching.
      vnode.patchFlag !== 32) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    const createVNode = _createVNode;
    function _createVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
      if (!type2 || type2 === NULL_DYNAMIC_COMPONENT) {
        type2 = Comment;
      }
      if (isVNode(type2)) {
        const cloned = cloneVNode(
          type2,
          props,
          true
          /* mergeRef: true */
        );
        if (children) {
          normalizeChildren(cloned, children);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
          if (cloned.shapeFlag & 6) {
            currentBlock[currentBlock.indexOf(type2)] = cloned;
          } else {
            currentBlock.push(cloned);
          }
        }
        cloned.patchFlag = -2;
        return cloned;
      }
      if (isClassComponent(type2)) {
        type2 = type2.__vccOpts;
      }
      if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !isString$1(klass)) {
          props.class = normalizeClass(klass);
        }
        if (isObject$4(style)) {
          if (isProxy(style) && !isArray$1(style)) {
            style = extend$1({}, style);
          }
          props.style = normalizeStyle(style);
        }
      }
      const shapeFlag = isString$1(type2) ? 1 : isSuspense(type2) ? 128 : isTeleport(type2) ? 64 : isObject$4(type2) ? 4 : isFunction$1(type2) ? 2 : 0;
      return createBaseVNode(
        type2,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        isBlockNode,
        true
      );
    }
    function guardReactiveProps(props) {
      if (!props)
        return null;
      return isProxy(props) || isInternalObject(props) ? extend$1({}, props) : props;
    }
    function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
      const { props, ref: ref3, patchFlag, children, transition } = vnode;
      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
      const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? (
          // #2078 in the case of <component :is="vnode" ref="extra"/>
          // if the vnode itself already has a ref, cloneVNode will need to merge
          // the refs so the single vnode can be set on multiple refs
          mergeRef && ref3 ? isArray$1(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
        ) : ref3,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children,
        target: vnode.target,
        targetStart: vnode.targetStart,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
      };
      if (transition && cloneTransition) {
        setTransitionHooks(
          cloned,
          transition.clone(cloned)
        );
      }
      return cloned;
    }
    function createTextVNode(text2 = " ", flag = 0) {
      return createVNode(Text$2, null, text2, flag);
    }
    function createCommentVNode(text2 = "", asBlock = false) {
      return asBlock ? (openBlock(), createBlock(Comment, null, text2)) : createVNode(Comment, null, text2);
    }
    function normalizeVNode(child) {
      if (child == null || typeof child === "boolean") {
        return createVNode(Comment);
      } else if (isArray$1(child)) {
        return createVNode(
          Fragment,
          null,
          // #3666, avoid reference pollution when reusing vnode
          child.slice()
        );
      } else if (typeof child === "object") {
        return cloneIfMounted(child);
      } else {
        return createVNode(Text$2, null, String(child));
      }
    }
    function cloneIfMounted(child) {
      return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
    }
    function normalizeChildren(vnode, children) {
      let type2 = 0;
      const { shapeFlag } = vnode;
      if (children == null) {
        children = null;
      } else if (isArray$1(children)) {
        type2 = 16;
      } else if (typeof children === "object") {
        if (shapeFlag & (1 | 64)) {
          const slot = children.default;
          if (slot) {
            slot._c && (slot._d = false);
            normalizeChildren(vnode, slot());
            slot._c && (slot._d = true);
          }
          return;
        } else {
          type2 = 32;
          const slotFlag = children._;
          if (!slotFlag && !isInternalObject(children)) {
            children._ctx = currentRenderingInstance;
          } else if (slotFlag === 3 && currentRenderingInstance) {
            if (currentRenderingInstance.slots._ === 1) {
              children._ = 1;
            } else {
              children._ = 2;
              vnode.patchFlag |= 1024;
            }
          }
        }
      } else if (isFunction$1(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type2 = 32;
      } else {
        children = String(children);
        if (shapeFlag & 64) {
          type2 = 16;
          children = [createTextVNode(children)];
        } else {
          type2 = 8;
        }
      }
      vnode.children = children;
      vnode.shapeFlag |= type2;
    }
    function mergeProps(...args) {
      const ret = {};
      for (let i2 = 0; i2 < args.length; i2++) {
        const toMerge = args[i2];
        for (const key in toMerge) {
          if (key === "class") {
            if (ret.class !== toMerge.class) {
              ret.class = normalizeClass([ret.class, toMerge.class]);
            }
          } else if (key === "style") {
            ret.style = normalizeStyle([ret.style, toMerge.style]);
          } else if (isOn$1(key)) {
            const existing = ret[key];
            const incoming = toMerge[key];
            if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
              ret[key] = existing ? [].concat(existing, incoming) : incoming;
            }
          } else if (key !== "") {
            ret[key] = toMerge[key];
          }
        }
      }
      return ret;
    }
    function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
      callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
      ]);
    }
    const emptyAppContext = createAppContext();
    let uid = 0;
    function createComponentInstance(vnode, parent, suspense) {
      const type2 = vnode.type;
      const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
      const instance = {
        uid: uid++,
        vnode,
        type: type2,
        parent,
        appContext,
        root: null,
        // to be immediately set
        next: null,
        subTree: null,
        // will be set synchronously right after creation
        effect: null,
        update: null,
        // will be set synchronously right after creation
        scope: new EffectScope(
          true
          /* detached */
        ),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type2, appContext),
        emitsOptions: normalizeEmitsOptions(type2, appContext),
        // emit
        emit: null,
        // to be set immediately
        emitted: null,
        // props default value
        propsDefaults: EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type2.inheritAttrs,
        // state
        ctx: EMPTY_OBJ,
        data: EMPTY_OBJ,
        props: EMPTY_OBJ,
        attrs: EMPTY_OBJ,
        slots: EMPTY_OBJ,
        refs: EMPTY_OBJ,
        setupState: EMPTY_OBJ,
        setupContext: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
      };
      {
        instance.ctx = { _: instance };
      }
      instance.root = parent ? parent.root : instance;
      instance.emit = emit.bind(null, instance);
      if (vnode.ce) {
        vnode.ce(instance);
      }
      return instance;
    }
    let currentInstance = null;
    const getCurrentInstance$1 = () => currentInstance || currentRenderingInstance;
    let internalSetCurrentInstance;
    let setInSSRSetupState;
    {
      const g2 = getGlobalThis();
      const registerGlobalSetter = (key, setter) => {
        let setters;
        if (!(setters = g2[key]))
          setters = g2[key] = [];
        setters.push(setter);
        return (v) => {
          if (setters.length > 1)
            setters.forEach((set2) => set2(v));
          else
            setters[0](v);
        };
      };
      internalSetCurrentInstance = registerGlobalSetter(
        `__VUE_INSTANCE_SETTERS__`,
        (v) => currentInstance = v
      );
      setInSSRSetupState = registerGlobalSetter(
        `__VUE_SSR_SETTERS__`,
        (v) => isInSSRComponentSetup = v
      );
    }
    const setCurrentInstance = (instance) => {
      const prev = currentInstance;
      internalSetCurrentInstance(instance);
      instance.scope.on();
      return () => {
        instance.scope.off();
        internalSetCurrentInstance(prev);
      };
    };
    const unsetCurrentInstance = () => {
      currentInstance && currentInstance.scope.off();
      internalSetCurrentInstance(null);
    };
    function isStatefulComponent(instance) {
      return instance.vnode.shapeFlag & 4;
    }
    let isInSSRComponentSetup = false;
    function setupComponent(instance, isSSR = false, optimized = false) {
      isSSR && setInSSRSetupState(isSSR);
      const { props, children } = instance.vnode;
      const isStateful = isStatefulComponent(instance);
      initProps(instance, props, isStateful, isSSR);
      initSlots(instance, children, optimized);
      const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
      isSSR && setInSSRSetupState(false);
      return setupResult;
    }
    function setupStatefulComponent(instance, isSSR) {
      const Component = instance.type;
      instance.accessCache = /* @__PURE__ */ Object.create(null);
      instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
      const { setup: setup2 } = Component;
      if (setup2) {
        const setupContext = instance.setupContext = setup2.length > 1 ? createSetupContext(instance) : null;
        const reset = setCurrentInstance(instance);
        pauseTracking();
        const setupResult = callWithErrorHandling(
          setup2,
          instance,
          0,
          [
            instance.props,
            setupContext
          ]
        );
        resetTracking();
        reset();
        if (isPromise(setupResult)) {
          setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
          if (isSSR) {
            return setupResult.then((resolvedResult) => {
              handleSetupResult(instance, resolvedResult, isSSR);
            }).catch((e) => {
              handleError(e, instance, 0);
            });
          } else {
            instance.asyncDep = setupResult;
          }
        } else {
          handleSetupResult(instance, setupResult, isSSR);
        }
      } else {
        finishComponentSetup(instance, isSSR);
      }
    }
    function handleSetupResult(instance, setupResult, isSSR) {
      if (isFunction$1(setupResult)) {
        if (instance.type.__ssrInlineRender) {
          instance.ssrRender = setupResult;
        } else {
          instance.render = setupResult;
        }
      } else if (isObject$4(setupResult)) {
        instance.setupState = proxyRefs(setupResult);
      } else
        ;
      finishComponentSetup(instance, isSSR);
    }
    let compile$3;
    function finishComponentSetup(instance, isSSR, skipOptions) {
      const Component = instance.type;
      if (!instance.render) {
        if (!isSSR && compile$3 && !Component.render) {
          const template = Component.template || resolveMergedOptions(instance).template;
          if (template) {
            const { isCustomElement, compilerOptions } = instance.appContext.config;
            const { delimiters, compilerOptions: componentCompilerOptions } = Component;
            const finalCompilerOptions = extend$1(
              extend$1(
                {
                  isCustomElement,
                  delimiters
                },
                compilerOptions
              ),
              componentCompilerOptions
            );
            Component.render = compile$3(template, finalCompilerOptions);
          }
        }
        instance.render = Component.render || NOOP;
      }
      {
        const reset = setCurrentInstance(instance);
        pauseTracking();
        try {
          applyOptions(instance);
        } finally {
          resetTracking();
          reset();
        }
      }
    }
    const attrsProxyHandlers = {
      get(target2, key) {
        track(target2, "get", "");
        return target2[key];
      }
    };
    function createSetupContext(instance) {
      const expose = (exposed) => {
        instance.exposed = exposed || {};
      };
      {
        return {
          attrs: new Proxy(instance.attrs, attrsProxyHandlers),
          slots: instance.slots,
          emit: instance.emit,
          expose
        };
      }
    }
    function getComponentPublicInstance(instance) {
      if (instance.exposed) {
        return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
          get(target2, key) {
            if (key in target2) {
              return target2[key];
            } else if (key in publicPropertiesMap) {
              return publicPropertiesMap[key](instance);
            }
          },
          has(target2, key) {
            return key in target2 || key in publicPropertiesMap;
          }
        }));
      } else {
        return instance.proxy;
      }
    }
    const classifyRE = /(?:^|[-_])(\w)/g;
    const classify = (str2) => str2.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
    function getComponentName(Component, includeInferred = true) {
      return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
    }
    function formatComponentName(instance, Component, isRoot = false) {
      let name = getComponentName(Component);
      if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
          name = match[1];
        }
      }
      if (!name && instance && instance.parent) {
        const inferFromRegistry = (registry) => {
          for (const key in registry) {
            if (registry[key] === Component) {
              return key;
            }
          }
        };
        name = inferFromRegistry(
          instance.components || instance.parent.type.components
        ) || inferFromRegistry(instance.appContext.components);
      }
      return name ? classify(name) : isRoot ? `App` : `Anonymous`;
    }
    function isClassComponent(value) {
      return isFunction$1(value) && "__vccOpts" in value;
    }
    const computed = (getterOrOptions, debugOptions) => {
      const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
      return c;
    };
    function h(type2, propsOrChildren, children) {
      const l = arguments.length;
      if (l === 2) {
        if (isObject$4(propsOrChildren) && !isArray$1(propsOrChildren)) {
          if (isVNode(propsOrChildren)) {
            return createVNode(type2, null, [propsOrChildren]);
          }
          return createVNode(type2, propsOrChildren);
        } else {
          return createVNode(type2, null, propsOrChildren);
        }
      } else {
        if (l > 3) {
          children = Array.prototype.slice.call(arguments, 2);
        } else if (l === 3 && isVNode(children)) {
          children = [children];
        }
        return createVNode(type2, propsOrChildren, children);
      }
    }
    const version$2 = "3.4.36";
    /**
    * @vue/runtime-dom v3.4.36
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    const svgNS = "http://www.w3.org/2000/svg";
    const mathmlNS = "http://www.w3.org/1998/Math/MathML";
    const doc = typeof document !== "undefined" ? document : null;
    const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
    const nodeOps = {
      insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
      },
      remove: (child) => {
        const parent = child.parentNode;
        if (parent) {
          parent.removeChild(child);
        }
      },
      createElement: (tag, namespace, is2, props) => {
        const el2 = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is2 ? doc.createElement(tag, { is: is2 }) : doc.createElement(tag);
        if (tag === "select" && props && props.multiple != null) {
          el2.setAttribute("multiple", props.multiple);
        }
        return el2;
      },
      createText: (text2) => doc.createTextNode(text2),
      createComment: (text2) => doc.createComment(text2),
      setText: (node, text2) => {
        node.nodeValue = text2;
      },
      setElementText: (el2, text2) => {
        el2.textContent = text2;
      },
      parentNode: (node) => node.parentNode,
      nextSibling: (node) => node.nextSibling,
      querySelector: (selector) => doc.querySelector(selector),
      setScopeId(el2, id2) {
        el2.setAttribute(id2, "");
      },
      // __UNSAFE__
      // Reason: innerHTML.
      // Static content here can only come from compiled templates.
      // As long as the user only uses trusted templates, this is safe.
      insertStaticContent(content2, parent, anchor, namespace, start, end) {
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        if (start && (start === end || start.nextSibling)) {
          while (true) {
            parent.insertBefore(start.cloneNode(true), anchor);
            if (start === end || !(start = start.nextSibling))
              break;
          }
        } else {
          templateContainer.innerHTML = namespace === "svg" ? `<svg>${content2}</svg>` : namespace === "mathml" ? `<math>${content2}</math>` : content2;
          const template = templateContainer.content;
          if (namespace === "svg" || namespace === "mathml") {
            const wrapper = template.firstChild;
            while (wrapper.firstChild) {
              template.appendChild(wrapper.firstChild);
            }
            template.removeChild(wrapper);
          }
          parent.insertBefore(template, anchor);
        }
        return [
          // first
          before ? before.nextSibling : parent.firstChild,
          // last
          anchor ? anchor.previousSibling : parent.lastChild
        ];
      }
    };
    const TRANSITION = "transition";
    const ANIMATION = "animation";
    const vtcKey = Symbol("_vtc");
    const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
    Transition.displayName = "Transition";
    const DOMTransitionPropsValidators = {
      name: String,
      type: String,
      css: {
        type: Boolean,
        default: true
      },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String
    };
    const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend$1(
      {},
      BaseTransitionPropsValidators,
      DOMTransitionPropsValidators
    );
    const callHook = (hook, args = []) => {
      if (isArray$1(hook)) {
        hook.forEach((h2) => h2(...args));
      } else if (hook) {
        hook(...args);
      }
    };
    const hasExplicitCallback = (hook) => {
      return hook ? isArray$1(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
    };
    function resolveTransitionProps(rawProps) {
      const baseProps = {};
      for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
          baseProps[key] = rawProps[key];
        }
      }
      if (rawProps.css === false) {
        return baseProps;
      }
      const {
        name = "v",
        type: type2,
        duration,
        enterFromClass = `${name}-enter-from`,
        enterActiveClass = `${name}-enter-active`,
        enterToClass = `${name}-enter-to`,
        appearFromClass = enterFromClass,
        appearActiveClass = enterActiveClass,
        appearToClass = enterToClass,
        leaveFromClass = `${name}-leave-from`,
        leaveActiveClass = `${name}-leave-active`,
        leaveToClass = `${name}-leave-to`
      } = rawProps;
      const durations = normalizeDuration(duration);
      const enterDuration = durations && durations[0];
      const leaveDuration = durations && durations[1];
      const {
        onBeforeEnter,
        onEnter,
        onEnterCancelled,
        onLeave,
        onLeaveCancelled,
        onBeforeAppear = onBeforeEnter,
        onAppear = onEnter,
        onAppearCancelled = onEnterCancelled
      } = baseProps;
      const finishEnter = (el2, isAppear, done) => {
        removeTransitionClass(el2, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el2, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
      };
      const finishLeave = (el2, done) => {
        el2._isLeaving = false;
        removeTransitionClass(el2, leaveFromClass);
        removeTransitionClass(el2, leaveToClass);
        removeTransitionClass(el2, leaveActiveClass);
        done && done();
      };
      const makeEnterHook = (isAppear) => {
        return (el2, done) => {
          const hook = isAppear ? onAppear : onEnter;
          const resolve2 = () => finishEnter(el2, isAppear, done);
          callHook(hook, [el2, resolve2]);
          nextFrame(() => {
            removeTransitionClass(el2, isAppear ? appearFromClass : enterFromClass);
            addTransitionClass(el2, isAppear ? appearToClass : enterToClass);
            if (!hasExplicitCallback(hook)) {
              whenTransitionEnds(el2, type2, enterDuration, resolve2);
            }
          });
        };
      };
      return extend$1(baseProps, {
        onBeforeEnter(el2) {
          callHook(onBeforeEnter, [el2]);
          addTransitionClass(el2, enterFromClass);
          addTransitionClass(el2, enterActiveClass);
        },
        onBeforeAppear(el2) {
          callHook(onBeforeAppear, [el2]);
          addTransitionClass(el2, appearFromClass);
          addTransitionClass(el2, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el2, done) {
          el2._isLeaving = true;
          const resolve2 = () => finishLeave(el2, done);
          addTransitionClass(el2, leaveFromClass);
          addTransitionClass(el2, leaveActiveClass);
          forceReflow();
          nextFrame(() => {
            if (!el2._isLeaving) {
              return;
            }
            removeTransitionClass(el2, leaveFromClass);
            addTransitionClass(el2, leaveToClass);
            if (!hasExplicitCallback(onLeave)) {
              whenTransitionEnds(el2, type2, leaveDuration, resolve2);
            }
          });
          callHook(onLeave, [el2, resolve2]);
        },
        onEnterCancelled(el2) {
          finishEnter(el2, false);
          callHook(onEnterCancelled, [el2]);
        },
        onAppearCancelled(el2) {
          finishEnter(el2, true);
          callHook(onAppearCancelled, [el2]);
        },
        onLeaveCancelled(el2) {
          finishLeave(el2);
          callHook(onLeaveCancelled, [el2]);
        }
      });
    }
    function normalizeDuration(duration) {
      if (duration == null) {
        return null;
      } else if (isObject$4(duration)) {
        return [NumberOf(duration.enter), NumberOf(duration.leave)];
      } else {
        const n = NumberOf(duration);
        return [n, n];
      }
    }
    function NumberOf(val) {
      const res = toNumber$1(val);
      return res;
    }
    function addTransitionClass(el2, cls) {
      cls.split(/\s+/).forEach((c) => c && el2.classList.add(c));
      (el2[vtcKey] || (el2[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
    }
    function removeTransitionClass(el2, cls) {
      cls.split(/\s+/).forEach((c) => c && el2.classList.remove(c));
      const _vtc = el2[vtcKey];
      if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
          el2[vtcKey] = void 0;
        }
      }
    }
    function nextFrame(cb) {
      requestAnimationFrame(() => {
        requestAnimationFrame(cb);
      });
    }
    let endId = 0;
    function whenTransitionEnds(el2, expectedType, explicitTimeout, resolve2) {
      const id2 = el2._endId = ++endId;
      const resolveIfNotStale = () => {
        if (id2 === el2._endId) {
          resolve2();
        }
      };
      if (explicitTimeout) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
      }
      const { type: type2, timeout, propCount } = getTransitionInfo(el2, expectedType);
      if (!type2) {
        return resolve2();
      }
      const endEvent = type2 + "end";
      let ended = 0;
      const end = () => {
        el2.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
      };
      const onEnd = (e) => {
        if (e.target === el2 && ++ended >= propCount) {
          end();
        }
      };
      setTimeout(() => {
        if (ended < propCount) {
          end();
        }
      }, timeout + 1);
      el2.addEventListener(endEvent, onEnd);
    }
    function getTransitionInfo(el2, expectedType) {
      const styles = window.getComputedStyle(el2);
      const getStyleProperties = (key) => (styles[key] || "").split(", ");
      const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
      const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
      const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
      const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
      const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
      const animationTimeout = getTimeout(animationDelays, animationDurations);
      let type2 = null;
      let timeout = 0;
      let propCount = 0;
      if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
          type2 = TRANSITION;
          timeout = transitionTimeout;
          propCount = transitionDurations.length;
        }
      } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
          type2 = ANIMATION;
          timeout = animationTimeout;
          propCount = animationDurations.length;
        }
      } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type2 = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type2 ? type2 === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
      }
      const hasTransform = type2 === TRANSITION && /\b(transform|all)(,|$)/.test(
        getStyleProperties(`${TRANSITION}Property`).toString()
      );
      return {
        type: type2,
        timeout,
        propCount,
        hasTransform
      };
    }
    function getTimeout(delays, durations) {
      while (delays.length < durations.length) {
        delays = delays.concat(delays);
      }
      return Math.max(...durations.map((d, i2) => toMs(d) + toMs(delays[i2])));
    }
    function toMs(s) {
      if (s === "auto")
        return 0;
      return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
    }
    function forceReflow() {
      return document.body.offsetHeight;
    }
    function patchClass(el2, value, isSVG) {
      const transitionClasses = el2[vtcKey];
      if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
      }
      if (value == null) {
        el2.removeAttribute("class");
      } else if (isSVG) {
        el2.setAttribute("class", value);
      } else {
        el2.className = value;
      }
    }
    const vShowOriginalDisplay = Symbol("_vod");
    const vShowHidden = Symbol("_vsh");
    const vShow = {
      beforeMount(el2, { value }, { transition }) {
        el2[vShowOriginalDisplay] = el2.style.display === "none" ? "" : el2.style.display;
        if (transition && value) {
          transition.beforeEnter(el2);
        } else {
          setDisplay(el2, value);
        }
      },
      mounted(el2, { value }, { transition }) {
        if (transition && value) {
          transition.enter(el2);
        }
      },
      updated(el2, { value, oldValue }, { transition }) {
        if (!value === !oldValue)
          return;
        if (transition) {
          if (value) {
            transition.beforeEnter(el2);
            setDisplay(el2, true);
            transition.enter(el2);
          } else {
            transition.leave(el2, () => {
              setDisplay(el2, false);
            });
          }
        } else {
          setDisplay(el2, value);
        }
      },
      beforeUnmount(el2, { value }) {
        setDisplay(el2, value);
      }
    };
    function setDisplay(el2, value) {
      el2.style.display = value ? el2[vShowOriginalDisplay] : "none";
      el2[vShowHidden] = !value;
    }
    const CSS_VAR_TEXT = Symbol("");
    const displayRE = /(^|;)\s*display\s*:/;
    function patchStyle(el2, prev, next2) {
      const style = el2.style;
      const isCssString = isString$1(next2);
      let hasControlledDisplay = false;
      if (next2 && !isCssString) {
        if (prev) {
          if (!isString$1(prev)) {
            for (const key in prev) {
              if (next2[key] == null) {
                setStyle(style, key, "");
              }
            }
          } else {
            for (const prevStyle of prev.split(";")) {
              const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
              if (next2[key] == null) {
                setStyle(style, key, "");
              }
            }
          }
        }
        for (const key in next2) {
          if (key === "display") {
            hasControlledDisplay = true;
          }
          setStyle(style, key, next2[key]);
        }
      } else {
        if (isCssString) {
          if (prev !== next2) {
            const cssVarText = style[CSS_VAR_TEXT];
            if (cssVarText) {
              next2 += ";" + cssVarText;
            }
            style.cssText = next2;
            hasControlledDisplay = displayRE.test(next2);
          }
        } else if (prev) {
          el2.removeAttribute("style");
        }
      }
      if (vShowOriginalDisplay in el2) {
        el2[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
        if (el2[vShowHidden]) {
          style.display = "none";
        }
      }
    }
    const importantRE = /\s*!important$/;
    function setStyle(style, name, val) {
      if (isArray$1(val)) {
        val.forEach((v) => setStyle(style, name, v));
      } else {
        if (val == null)
          val = "";
        if (name.startsWith("--")) {
          style.setProperty(name, val);
        } else {
          const prefixed = autoPrefix(style, name);
          if (importantRE.test(val)) {
            style.setProperty(
              hyphenate(prefixed),
              val.replace(importantRE, ""),
              "important"
            );
          } else {
            style[prefixed] = val;
          }
        }
      }
    }
    const prefixes = ["Webkit", "Moz", "ms"];
    const prefixCache = {};
    function autoPrefix(style, rawName) {
      const cached = prefixCache[rawName];
      if (cached) {
        return cached;
      }
      let name = camelize(rawName);
      if (name !== "filter" && name in style) {
        return prefixCache[rawName] = name;
      }
      name = capitalize(name);
      for (let i2 = 0; i2 < prefixes.length; i2++) {
        const prefixed = prefixes[i2] + name;
        if (prefixed in style) {
          return prefixCache[rawName] = prefixed;
        }
      }
      return rawName;
    }
    const xlinkNS = "http://www.w3.org/1999/xlink";
    function patchAttr(el2, key, value, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
      if (isSVG && key.startsWith("xlink:")) {
        if (value == null) {
          el2.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        } else {
          el2.setAttributeNS(xlinkNS, key, value);
        }
      } else {
        if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
          el2.removeAttribute(key);
        } else {
          el2.setAttribute(
            key,
            isBoolean2 ? "" : isSymbol(value) ? String(value) : value
          );
        }
      }
    }
    function patchDOMProp(el2, key, value, parentComponent) {
      if (key === "innerHTML" || key === "textContent") {
        if (value == null)
          return;
        el2[key] = value;
        return;
      }
      const tag = el2.tagName;
      if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
      !tag.includes("-")) {
        const oldValue = tag === "OPTION" ? el2.getAttribute("value") || "" : el2.value;
        const newValue = value == null ? "" : String(value);
        if (oldValue !== newValue || !("_value" in el2)) {
          el2.value = newValue;
        }
        if (value == null) {
          el2.removeAttribute(key);
        }
        el2._value = value;
        return;
      }
      let needRemove = false;
      if (value === "" || value == null) {
        const type2 = typeof el2[key];
        if (type2 === "boolean") {
          value = includeBooleanAttr(value);
        } else if (value == null && type2 === "string") {
          value = "";
          needRemove = true;
        } else if (type2 === "number") {
          value = 0;
          needRemove = true;
        }
      }
      try {
        el2[key] = value;
      } catch (e) {
      }
      needRemove && el2.removeAttribute(key);
    }
    function addEventListener(el2, event, handler, options) {
      el2.addEventListener(event, handler, options);
    }
    function removeEventListener(el2, event, handler, options) {
      el2.removeEventListener(event, handler, options);
    }
    const veiKey = Symbol("_vei");
    function patchEvent(el2, rawName, prevValue, nextValue, instance = null) {
      const invokers = el2[veiKey] || (el2[veiKey] = {});
      const existingInvoker = invokers[rawName];
      if (nextValue && existingInvoker) {
        existingInvoker.value = nextValue;
      } else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
          const invoker = invokers[rawName] = createInvoker(
            nextValue,
            instance
          );
          addEventListener(el2, name, invoker, options);
        } else if (existingInvoker) {
          removeEventListener(el2, name, existingInvoker, options);
          invokers[rawName] = void 0;
        }
      }
    }
    const optionsModifierRE = /(?:Once|Passive|Capture)$/;
    function parseName(name) {
      let options;
      if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while (m = name.match(optionsModifierRE)) {
          name = name.slice(0, name.length - m[0].length);
          options[m[0].toLowerCase()] = true;
        }
      }
      const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
      return [event, options];
    }
    let cachedNow = 0;
    const p = /* @__PURE__ */ Promise.resolve();
    const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
    function createInvoker(initialValue, instance) {
      const invoker = (e) => {
        if (!e._vts) {
          e._vts = Date.now();
        } else if (e._vts <= invoker.attached) {
          return;
        }
        callWithAsyncErrorHandling(
          patchStopImmediatePropagation(e, invoker.value),
          instance,
          5,
          [e]
        );
      };
      invoker.value = initialValue;
      invoker.attached = getNow();
      return invoker;
    }
    function patchStopImmediatePropagation(e, value) {
      if (isArray$1(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
          originalStop.call(e);
          e._stopped = true;
        };
        return value.map(
          (fn) => (e2) => !e2._stopped && fn && fn(e2)
        );
      } else {
        return value;
      }
    }
    const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
    key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
    const patchProp = (el2, key, prevValue, nextValue, namespace, parentComponent) => {
      const isSVG = namespace === "svg";
      if (key === "class") {
        patchClass(el2, nextValue, isSVG);
      } else if (key === "style") {
        patchStyle(el2, prevValue, nextValue);
      } else if (isOn$1(key)) {
        if (!isModelListener(key)) {
          patchEvent(el2, key, prevValue, nextValue, parentComponent);
        }
      } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el2, key, nextValue, isSVG)) {
        patchDOMProp(el2, key, nextValue);
        if (!el2.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
          patchAttr(el2, key, nextValue, isSVG, parentComponent, key !== "value");
        }
      } else {
        if (key === "true-value") {
          el2._trueValue = nextValue;
        } else if (key === "false-value") {
          el2._falseValue = nextValue;
        }
        patchAttr(el2, key, nextValue, isSVG);
      }
    };
    function shouldSetAsProp(el2, key, value, isSVG) {
      if (isSVG) {
        if (key === "innerHTML" || key === "textContent") {
          return true;
        }
        if (key in el2 && isNativeOn(key) && isFunction$1(value)) {
          return true;
        }
        return false;
      }
      if (key === "spellcheck" || key === "draggable" || key === "translate") {
        return false;
      }
      if (key === "form") {
        return false;
      }
      if (key === "list" && el2.tagName === "INPUT") {
        return false;
      }
      if (key === "type" && el2.tagName === "TEXTAREA") {
        return false;
      }
      if (key === "width" || key === "height") {
        const tag = el2.tagName;
        if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
          return false;
        }
      }
      if (isNativeOn(key) && isString$1(value)) {
        return false;
      }
      return key in el2;
    }
    const positionMap = /* @__PURE__ */ new WeakMap();
    const newPositionMap = /* @__PURE__ */ new WeakMap();
    const moveCbKey = Symbol("_moveCb");
    const enterCbKey = Symbol("_enterCb");
    const TransitionGroupImpl = {
      name: "TransitionGroup",
      props: /* @__PURE__ */ extend$1({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
      }),
      setup(props, { slots }) {
        const instance = getCurrentInstance$1();
        const state = useTransitionState();
        let prevChildren;
        let children;
        onUpdated(() => {
          if (!prevChildren.length) {
            return;
          }
          const moveClass = props.moveClass || `${props.name || "v"}-move`;
          if (!hasCSSTransform(
            prevChildren[0].el,
            instance.vnode.el,
            moveClass
          )) {
            return;
          }
          prevChildren.forEach(callPendingCbs);
          prevChildren.forEach(recordPosition);
          const movedChildren = prevChildren.filter(applyTranslation);
          forceReflow();
          movedChildren.forEach((c) => {
            const el2 = c.el;
            const style = el2.style;
            addTransitionClass(el2, moveClass);
            style.transform = style.webkitTransform = style.transitionDuration = "";
            const cb = el2[moveCbKey] = (e) => {
              if (e && e.target !== el2) {
                return;
              }
              if (!e || /transform$/.test(e.propertyName)) {
                el2.removeEventListener("transitionend", cb);
                el2[moveCbKey] = null;
                removeTransitionClass(el2, moveClass);
              }
            };
            el2.addEventListener("transitionend", cb);
          });
        });
        return () => {
          const rawProps = toRaw(props);
          const cssTransitionProps = resolveTransitionProps(rawProps);
          let tag = rawProps.tag || Fragment;
          prevChildren = [];
          if (children) {
            for (let i2 = 0; i2 < children.length; i2++) {
              const child = children[i2];
              if (child.el && child.el instanceof Element) {
                prevChildren.push(child);
                setTransitionHooks(
                  child,
                  resolveTransitionHooks(
                    child,
                    cssTransitionProps,
                    state,
                    instance
                  )
                );
                positionMap.set(
                  child,
                  child.el.getBoundingClientRect()
                );
              }
            }
          }
          children = slots.default ? getTransitionRawChildren(slots.default()) : [];
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            if (child.key != null) {
              setTransitionHooks(
                child,
                resolveTransitionHooks(child, cssTransitionProps, state, instance)
              );
            }
          }
          return createVNode(tag, null, children);
        };
      }
    };
    const removeMode = (props) => delete props.mode;
    /* @__PURE__ */ removeMode(TransitionGroupImpl.props);
    const TransitionGroup = TransitionGroupImpl;
    function callPendingCbs(c) {
      const el2 = c.el;
      if (el2[moveCbKey]) {
        el2[moveCbKey]();
      }
      if (el2[enterCbKey]) {
        el2[enterCbKey]();
      }
    }
    function recordPosition(c) {
      newPositionMap.set(c, c.el.getBoundingClientRect());
    }
    function applyTranslation(c) {
      const oldPos = positionMap.get(c);
      const newPos = newPositionMap.get(c);
      const dx = oldPos.left - newPos.left;
      const dy = oldPos.top - newPos.top;
      if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = "0s";
        return c;
      }
    }
    function hasCSSTransform(el2, root, moveClass) {
      const clone2 = el2.cloneNode();
      const _vtc = el2[vtcKey];
      if (_vtc) {
        _vtc.forEach((cls) => {
          cls.split(/\s+/).forEach((c) => c && clone2.classList.remove(c));
        });
      }
      moveClass.split(/\s+/).forEach((c) => c && clone2.classList.add(c));
      clone2.style.display = "none";
      const container = root.nodeType === 1 ? root : root.parentNode;
      container.appendChild(clone2);
      const { hasTransform } = getTransitionInfo(clone2);
      container.removeChild(clone2);
      return hasTransform;
    }
    const getModelAssigner = (vnode) => {
      const fn = vnode.props["onUpdate:modelValue"] || false;
      return isArray$1(fn) ? (value) => invokeArrayFns(fn, value) : fn;
    };
    function onCompositionStart(e) {
      e.target.composing = true;
    }
    function onCompositionEnd(e) {
      const target2 = e.target;
      if (target2.composing) {
        target2.composing = false;
        target2.dispatchEvent(new Event("input"));
      }
    }
    const assignKey = Symbol("_assign");
    const vModelText = {
      created(el2, { modifiers: { lazy, trim, number } }, vnode) {
        el2[assignKey] = getModelAssigner(vnode);
        const castToNumber = number || vnode.props && vnode.props.type === "number";
        addEventListener(el2, lazy ? "change" : "input", (e) => {
          if (e.target.composing)
            return;
          let domValue = el2.value;
          if (trim) {
            domValue = domValue.trim();
          }
          if (castToNumber) {
            domValue = looseToNumber(domValue);
          }
          el2[assignKey](domValue);
        });
        if (trim) {
          addEventListener(el2, "change", () => {
            el2.value = el2.value.trim();
          });
        }
        if (!lazy) {
          addEventListener(el2, "compositionstart", onCompositionStart);
          addEventListener(el2, "compositionend", onCompositionEnd);
          addEventListener(el2, "change", onCompositionEnd);
        }
      },
      // set value on mounted so it's after min/max for type="range"
      mounted(el2, { value }) {
        el2.value = value == null ? "" : value;
      },
      beforeUpdate(el2, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
        el2[assignKey] = getModelAssigner(vnode);
        if (el2.composing)
          return;
        const elValue = (number || el2.type === "number") && !/^0\d/.test(el2.value) ? looseToNumber(el2.value) : el2.value;
        const newValue = value == null ? "" : value;
        if (elValue === newValue) {
          return;
        }
        if (document.activeElement === el2 && el2.type !== "range") {
          if (lazy && value === oldValue) {
            return;
          }
          if (trim && el2.value.trim() === newValue) {
            return;
          }
        }
        el2.value = newValue;
      }
    };
    const systemModifiers = ["ctrl", "shift", "alt", "meta"];
    const modifierGuards = {
      stop: (e) => e.stopPropagation(),
      prevent: (e) => e.preventDefault(),
      self: (e) => e.target !== e.currentTarget,
      ctrl: (e) => !e.ctrlKey,
      shift: (e) => !e.shiftKey,
      alt: (e) => !e.altKey,
      meta: (e) => !e.metaKey,
      left: (e) => "button" in e && e.button !== 0,
      middle: (e) => "button" in e && e.button !== 1,
      right: (e) => "button" in e && e.button !== 2,
      exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
    };
    const withModifiers = (fn, modifiers) => {
      const cache2 = fn._withMods || (fn._withMods = {});
      const cacheKey = modifiers.join(".");
      return cache2[cacheKey] || (cache2[cacheKey] = (event, ...args) => {
        for (let i2 = 0; i2 < modifiers.length; i2++) {
          const guard = modifierGuards[modifiers[i2]];
          if (guard && guard(event, modifiers))
            return;
        }
        return fn(event, ...args);
      });
    };
    const keyNames = {
      esc: "escape",
      space: " ",
      up: "arrow-up",
      left: "arrow-left",
      right: "arrow-right",
      down: "arrow-down",
      delete: "backspace"
    };
    const withKeys = (fn, modifiers) => {
      const cache2 = fn._withKeys || (fn._withKeys = {});
      const cacheKey = modifiers.join(".");
      return cache2[cacheKey] || (cache2[cacheKey] = (event) => {
        if (!("key" in event)) {
          return;
        }
        const eventKey = hyphenate(event.key);
        if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
          return fn(event);
        }
      });
    };
    const rendererOptions = /* @__PURE__ */ extend$1({ patchProp }, nodeOps);
    let renderer$1;
    function ensureRenderer() {
      return renderer$1 || (renderer$1 = createRenderer(rendererOptions));
    }
    const createApp = (...args) => {
      const app2 = ensureRenderer().createApp(...args);
      const { mount } = app2;
      app2.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container)
          return;
        const component = app2._component;
        if (!isFunction$1(component) && !component.render && !component.template) {
          component.template = container.innerHTML;
        }
        container.innerHTML = "";
        const proxy = mount(container, false, resolveRootNamespace(container));
        if (container instanceof Element) {
          container.removeAttribute("v-cloak");
          container.setAttribute("data-v-app", "");
        }
        return proxy;
      };
      return app2;
    };
    function resolveRootNamespace(container) {
      if (container instanceof SVGElement) {
        return "svg";
      }
      if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
        return "mathml";
      }
    }
    function normalizeContainer(container) {
      if (isString$1(container)) {
        const res = document.querySelector(container);
        return res;
      }
      return container;
    }
    const _sfc_main$M = {
      name: "App"
    };
    const _export_sfc = (sfc, props) => {
      const target2 = sfc.__vccOpts || sfc;
      for (const [key, val] of props) {
        target2[key] = val;
      }
      return target2;
    };
    function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_router_view = resolveComponent("router-view");
      return openBlock(), createBlock(_component_router_view);
    }
    const App = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["render", _sfc_render$7]]);
    /*!
      * vue-router v4.4.3
      * (c) 2024 Eduardo San Martin Morote
      * @license MIT
      */
    const isBrowser = typeof document !== "undefined";
    function isESModule(obj) {
      return obj.__esModule || obj[Symbol.toStringTag] === "Module";
    }
    const assign$3 = Object.assign;
    function applyToParams(fn, params) {
      const newParams = {};
      for (const key in params) {
        const value = params[key];
        newParams[key] = isArray(value) ? value.map(fn) : fn(value);
      }
      return newParams;
    }
    const noop$2 = () => {
    };
    const isArray = Array.isArray;
    const HASH_RE = /#/g;
    const AMPERSAND_RE = /&/g;
    const SLASH_RE = /\//g;
    const EQUAL_RE = /=/g;
    const IM_RE = /\?/g;
    const PLUS_RE = /\+/g;
    const ENC_BRACKET_OPEN_RE = /%5B/g;
    const ENC_BRACKET_CLOSE_RE = /%5D/g;
    const ENC_CARET_RE = /%5E/g;
    const ENC_BACKTICK_RE = /%60/g;
    const ENC_CURLY_OPEN_RE = /%7B/g;
    const ENC_PIPE_RE = /%7C/g;
    const ENC_CURLY_CLOSE_RE = /%7D/g;
    const ENC_SPACE_RE = /%20/g;
    function commonEncode(text2) {
      return encodeURI("" + text2).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
    }
    function encodeHash(text2) {
      return commonEncode(text2).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
    }
    function encodeQueryValue(text2) {
      return commonEncode(text2).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
    }
    function encodeQueryKey(text2) {
      return encodeQueryValue(text2).replace(EQUAL_RE, "%3D");
    }
    function encodePath(text2) {
      return commonEncode(text2).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
    }
    function encodeParam(text2) {
      return text2 == null ? "" : encodePath(text2).replace(SLASH_RE, "%2F");
    }
    function decode$2(text2) {
      try {
        return decodeURIComponent("" + text2);
      } catch (err) {
      }
      return "" + text2;
    }
    const TRAILING_SLASH_RE = /\/$/;
    const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
    function parseURL(parseQuery2, location2, currentLocation = "/") {
      let path, query = {}, searchString = "", hash = "";
      const hashPos = location2.indexOf("#");
      let searchPos = location2.indexOf("?");
      if (hashPos < searchPos && hashPos >= 0) {
        searchPos = -1;
      }
      if (searchPos > -1) {
        path = location2.slice(0, searchPos);
        searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
        query = parseQuery2(searchString);
      }
      if (hashPos > -1) {
        path = path || location2.slice(0, hashPos);
        hash = location2.slice(hashPos, location2.length);
      }
      path = resolveRelativePath(path != null ? path : location2, currentLocation);
      return {
        fullPath: path + (searchString && "?") + searchString + hash,
        path,
        query,
        hash: decode$2(hash)
      };
    }
    function stringifyURL(stringifyQuery2, location2) {
      const query = location2.query ? stringifyQuery2(location2.query) : "";
      return location2.path + (query && "?") + query + (location2.hash || "");
    }
    function stripBase(pathname, base2) {
      if (!base2 || !pathname.toLowerCase().startsWith(base2.toLowerCase()))
        return pathname;
      return pathname.slice(base2.length) || "/";
    }
    function isSameRouteLocation(stringifyQuery2, a, b) {
      const aLastIndex = a.matched.length - 1;
      const bLastIndex = b.matched.length - 1;
      return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery2(a.query) === stringifyQuery2(b.query) && a.hash === b.hash;
    }
    function isSameRouteRecord(a, b) {
      return (a.aliasOf || a) === (b.aliasOf || b);
    }
    function isSameRouteLocationParams(a, b) {
      if (Object.keys(a).length !== Object.keys(b).length)
        return false;
      for (const key in a) {
        if (!isSameRouteLocationParamsValue(a[key], b[key]))
          return false;
      }
      return true;
    }
    function isSameRouteLocationParamsValue(a, b) {
      return isArray(a) ? isEquivalentArray(a, b) : isArray(b) ? isEquivalentArray(b, a) : a === b;
    }
    function isEquivalentArray(a, b) {
      return isArray(b) ? a.length === b.length && a.every((value, i2) => value === b[i2]) : a.length === 1 && a[0] === b;
    }
    function resolveRelativePath(to, from) {
      if (to.startsWith("/"))
        return to;
      if (!to)
        return from;
      const fromSegments = from.split("/");
      const toSegments = to.split("/");
      const lastToSegment = toSegments[toSegments.length - 1];
      if (lastToSegment === ".." || lastToSegment === ".") {
        toSegments.push("");
      }
      let position = fromSegments.length - 1;
      let toPosition;
      let segment;
      for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
        segment = toSegments[toPosition];
        if (segment === ".")
          continue;
        if (segment === "..") {
          if (position > 1)
            position--;
        } else
          break;
      }
      return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition).join("/");
    }
    const START_LOCATION_NORMALIZED = {
      path: "/",
      // TODO: could we use a symbol in the future?
      name: void 0,
      params: {},
      query: {},
      hash: "",
      fullPath: "/",
      matched: [],
      meta: {},
      redirectedFrom: void 0
    };
    var NavigationType;
    (function(NavigationType2) {
      NavigationType2["pop"] = "pop";
      NavigationType2["push"] = "push";
    })(NavigationType || (NavigationType = {}));
    var NavigationDirection;
    (function(NavigationDirection2) {
      NavigationDirection2["back"] = "back";
      NavigationDirection2["forward"] = "forward";
      NavigationDirection2["unknown"] = "";
    })(NavigationDirection || (NavigationDirection = {}));
    function normalizeBase(base2) {
      if (!base2) {
        if (isBrowser) {
          const baseEl = document.querySelector("base");
          base2 = baseEl && baseEl.getAttribute("href") || "/";
          base2 = base2.replace(/^\w+:\/\/[^\/]+/, "");
        } else {
          base2 = "/";
        }
      }
      if (base2[0] !== "/" && base2[0] !== "#")
        base2 = "/" + base2;
      return removeTrailingSlash(base2);
    }
    const BEFORE_HASH_RE = /^[^#]+#/;
    function createHref(base2, location2) {
      return base2.replace(BEFORE_HASH_RE, "#") + location2;
    }
    function getElementPosition(el2, offset) {
      const docRect = document.documentElement.getBoundingClientRect();
      const elRect = el2.getBoundingClientRect();
      return {
        behavior: offset.behavior,
        left: elRect.left - docRect.left - (offset.left || 0),
        top: elRect.top - docRect.top - (offset.top || 0)
      };
    }
    const computeScrollPosition = () => ({
      left: window.scrollX,
      top: window.scrollY
    });
    function scrollToPosition(position) {
      let scrollToOptions;
      if ("el" in position) {
        const positionEl = position.el;
        const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
        const el2 = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
        if (!el2) {
          return;
        }
        scrollToOptions = getElementPosition(el2, position);
      } else {
        scrollToOptions = position;
      }
      if ("scrollBehavior" in document.documentElement.style)
        window.scrollTo(scrollToOptions);
      else {
        window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.scrollX, scrollToOptions.top != null ? scrollToOptions.top : window.scrollY);
      }
    }
    function getScrollKey(path, delta2) {
      const position = history.state ? history.state.position - delta2 : -1;
      return position + path;
    }
    const scrollPositions = /* @__PURE__ */ new Map();
    function saveScrollPosition(key, scrollPosition) {
      scrollPositions.set(key, scrollPosition);
    }
    function getSavedScrollPosition(key) {
      const scroll = scrollPositions.get(key);
      scrollPositions.delete(key);
      return scroll;
    }
    let createBaseLocation = () => location.protocol + "//" + location.host;
    function createCurrentLocation(base2, location2) {
      const { pathname, search, hash } = location2;
      const hashPos = base2.indexOf("#");
      if (hashPos > -1) {
        let slicePos = hash.includes(base2.slice(hashPos)) ? base2.slice(hashPos).length : 1;
        let pathFromHash = hash.slice(slicePos);
        if (pathFromHash[0] !== "/")
          pathFromHash = "/" + pathFromHash;
        return stripBase(pathFromHash, "");
      }
      const path = stripBase(pathname, base2);
      return path + search + hash;
    }
    function useHistoryListeners(base2, historyState, currentLocation, replace2) {
      let listeners = [];
      let teardowns = [];
      let pauseState = null;
      const popStateHandler = ({ state }) => {
        const to = createCurrentLocation(base2, location);
        const from = currentLocation.value;
        const fromState = historyState.value;
        let delta2 = 0;
        if (state) {
          currentLocation.value = to;
          historyState.value = state;
          if (pauseState && pauseState === from) {
            pauseState = null;
            return;
          }
          delta2 = fromState ? state.position - fromState.position : 0;
        } else {
          replace2(to);
        }
        listeners.forEach((listener) => {
          listener(currentLocation.value, from, {
            delta: delta2,
            type: NavigationType.pop,
            direction: delta2 ? delta2 > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
          });
        });
      };
      function pauseListeners() {
        pauseState = currentLocation.value;
      }
      function listen(callback) {
        listeners.push(callback);
        const teardown = () => {
          const index = listeners.indexOf(callback);
          if (index > -1)
            listeners.splice(index, 1);
        };
        teardowns.push(teardown);
        return teardown;
      }
      function beforeUnloadListener() {
        const { history: history2 } = window;
        if (!history2.state)
          return;
        history2.replaceState(assign$3({}, history2.state, { scroll: computeScrollPosition() }), "");
      }
      function destroy() {
        for (const teardown of teardowns)
          teardown();
        teardowns = [];
        window.removeEventListener("popstate", popStateHandler);
        window.removeEventListener("beforeunload", beforeUnloadListener);
      }
      window.addEventListener("popstate", popStateHandler);
      window.addEventListener("beforeunload", beforeUnloadListener, {
        passive: true
      });
      return {
        pauseListeners,
        listen,
        destroy
      };
    }
    function buildState(back, current2, forward, replaced = false, computeScroll = false) {
      return {
        back,
        current: current2,
        forward,
        replaced,
        position: window.history.length,
        scroll: computeScroll ? computeScrollPosition() : null
      };
    }
    function useHistoryStateNavigation(base2) {
      const { history: history2, location: location2 } = window;
      const currentLocation = {
        value: createCurrentLocation(base2, location2)
      };
      const historyState = { value: history2.state };
      if (!historyState.value) {
        changeLocation(currentLocation.value, {
          back: null,
          current: currentLocation.value,
          forward: null,
          // the length is off by one, we need to decrease it
          position: history2.length - 1,
          replaced: true,
          // don't add a scroll as the user may have an anchor, and we want
          // scrollBehavior to be triggered without a saved position
          scroll: null
        }, true);
      }
      function changeLocation(to, state, replace22) {
        const hashIndex = base2.indexOf("#");
        const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base2 : base2.slice(hashIndex)) + to : createBaseLocation() + base2 + to;
        try {
          history2[replace22 ? "replaceState" : "pushState"](state, "", url);
          historyState.value = state;
        } catch (err) {
          {
            console.error(err);
          }
          location2[replace22 ? "replace" : "assign"](url);
        }
      }
      function replace2(to, data) {
        const state = assign$3({}, history2.state, buildState(
          historyState.value.back,
          // keep back and forward entries but override current position
          to,
          historyState.value.forward,
          true
        ), data, { position: historyState.value.position });
        changeLocation(to, state, true);
        currentLocation.value = to;
      }
      function push(to, data) {
        const currentState = assign$3(
          {},
          // use current history state to gracefully handle a wrong call to
          // history.replaceState
          // https://github.com/vuejs/router/issues/366
          historyState.value,
          history2.state,
          {
            forward: to,
            scroll: computeScrollPosition()
          }
        );
        changeLocation(currentState.current, currentState, true);
        const state = assign$3({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);
        changeLocation(to, state, false);
        currentLocation.value = to;
      }
      return {
        location: currentLocation,
        state: historyState,
        push,
        replace: replace2
      };
    }
    function createWebHistory(base2) {
      base2 = normalizeBase(base2);
      const historyNavigation = useHistoryStateNavigation(base2);
      const historyListeners = useHistoryListeners(base2, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
      function go(delta2, triggerListeners = true) {
        if (!triggerListeners)
          historyListeners.pauseListeners();
        history.go(delta2);
      }
      const routerHistory = assign$3({
        // it's overridden right after
        location: "",
        base: base2,
        go,
        createHref: createHref.bind(null, base2)
      }, historyNavigation, historyListeners);
      Object.defineProperty(routerHistory, "location", {
        enumerable: true,
        get: () => historyNavigation.location.value
      });
      Object.defineProperty(routerHistory, "state", {
        enumerable: true,
        get: () => historyNavigation.state.value
      });
      return routerHistory;
    }
    function createWebHashHistory(base2) {
      base2 = location.host ? base2 || location.pathname + location.search : "";
      if (!base2.includes("#"))
        base2 += "#";
      return createWebHistory(base2);
    }
    function isRouteLocation(route) {
      return typeof route === "string" || route && typeof route === "object";
    }
    function isRouteName(name) {
      return typeof name === "string" || typeof name === "symbol";
    }
    const NavigationFailureSymbol = Symbol("");
    var NavigationFailureType;
    (function(NavigationFailureType2) {
      NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
      NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
      NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
    })(NavigationFailureType || (NavigationFailureType = {}));
    function createRouterError(type2, params) {
      {
        return assign$3(new Error(), {
          type: type2,
          [NavigationFailureSymbol]: true
        }, params);
      }
    }
    function isNavigationFailure(error2, type2) {
      return error2 instanceof Error && NavigationFailureSymbol in error2 && (type2 == null || !!(error2.type & type2));
    }
    const BASE_PARAM_PATTERN = "[^/]+?";
    const BASE_PATH_PARSER_OPTIONS = {
      sensitive: false,
      strict: false,
      start: true,
      end: true
    };
    const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
    function tokensToParser(segments, extraOptions) {
      const options = assign$3({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
      const score = [];
      let pattern2 = options.start ? "^" : "";
      const keys2 = [];
      for (const segment of segments) {
        const segmentScores = segment.length ? [] : [
          90
          /* PathScore.Root */
        ];
        if (options.strict && !segment.length)
          pattern2 += "/";
        for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
          const token2 = segment[tokenIndex];
          let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
          if (token2.type === 0) {
            if (!tokenIndex)
              pattern2 += "/";
            pattern2 += token2.value.replace(REGEX_CHARS_RE, "\\$&");
            subSegmentScore += 40;
          } else if (token2.type === 1) {
            const { value, repeatable, optional: optional2, regexp } = token2;
            keys2.push({
              name: value,
              repeatable,
              optional: optional2
            });
            const re22 = regexp ? regexp : BASE_PARAM_PATTERN;
            if (re22 !== BASE_PARAM_PATTERN) {
              subSegmentScore += 10;
              try {
                new RegExp(`(${re22})`);
              } catch (err) {
                throw new Error(`Invalid custom RegExp for param "${value}" (${re22}): ` + err.message);
              }
            }
            let subPattern = repeatable ? `((?:${re22})(?:/(?:${re22}))*)` : `(${re22})`;
            if (!tokenIndex)
              subPattern = // avoid an optional / if there are more segments e.g. /:p?-static
              // or /:p?-:p2
              optional2 && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
            if (optional2)
              subPattern += "?";
            pattern2 += subPattern;
            subSegmentScore += 20;
            if (optional2)
              subSegmentScore += -8;
            if (repeatable)
              subSegmentScore += -20;
            if (re22 === ".*")
              subSegmentScore += -50;
          }
          segmentScores.push(subSegmentScore);
        }
        score.push(segmentScores);
      }
      if (options.strict && options.end) {
        const i2 = score.length - 1;
        score[i2][score[i2].length - 1] += 0.7000000000000001;
      }
      if (!options.strict)
        pattern2 += "/?";
      if (options.end)
        pattern2 += "$";
      else if (options.strict)
        pattern2 += "(?:/|$)";
      const re2 = new RegExp(pattern2, options.sensitive ? "" : "i");
      function parse2(path) {
        const match = path.match(re2);
        const params = {};
        if (!match)
          return null;
        for (let i2 = 1; i2 < match.length; i2++) {
          const value = match[i2] || "";
          const key = keys2[i2 - 1];
          params[key.name] = value && key.repeatable ? value.split("/") : value;
        }
        return params;
      }
      function stringify(params) {
        let path = "";
        let avoidDuplicatedSlash = false;
        for (const segment of segments) {
          if (!avoidDuplicatedSlash || !path.endsWith("/"))
            path += "/";
          avoidDuplicatedSlash = false;
          for (const token2 of segment) {
            if (token2.type === 0) {
              path += token2.value;
            } else if (token2.type === 1) {
              const { value, repeatable, optional: optional2 } = token2;
              const param = value in params ? params[value] : "";
              if (isArray(param) && !repeatable) {
                throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
              }
              const text2 = isArray(param) ? param.join("/") : param;
              if (!text2) {
                if (optional2) {
                  if (segment.length < 2) {
                    if (path.endsWith("/"))
                      path = path.slice(0, -1);
                    else
                      avoidDuplicatedSlash = true;
                  }
                } else
                  throw new Error(`Missing required param "${value}"`);
              }
              path += text2;
            }
          }
        }
        return path || "/";
      }
      return {
        re: re2,
        score,
        keys: keys2,
        parse: parse2,
        stringify
      };
    }
    function compareScoreArray(a, b) {
      let i2 = 0;
      while (i2 < a.length && i2 < b.length) {
        const diff = b[i2] - a[i2];
        if (diff)
          return diff;
        i2++;
      }
      if (a.length < b.length) {
        return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;
      } else if (a.length > b.length) {
        return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;
      }
      return 0;
    }
    function comparePathParserScore(a, b) {
      let i2 = 0;
      const aScore = a.score;
      const bScore = b.score;
      while (i2 < aScore.length && i2 < bScore.length) {
        const comp2 = compareScoreArray(aScore[i2], bScore[i2]);
        if (comp2)
          return comp2;
        i2++;
      }
      if (Math.abs(bScore.length - aScore.length) === 1) {
        if (isLastScoreNegative(aScore))
          return 1;
        if (isLastScoreNegative(bScore))
          return -1;
      }
      return bScore.length - aScore.length;
    }
    function isLastScoreNegative(score) {
      const last = score[score.length - 1];
      return score.length > 0 && last[last.length - 1] < 0;
    }
    const ROOT_TOKEN = {
      type: 0,
      value: ""
    };
    const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
    function tokenizePath(path) {
      if (!path)
        return [[]];
      if (path === "/")
        return [[ROOT_TOKEN]];
      if (!path.startsWith("/")) {
        throw new Error(`Invalid path "${path}"`);
      }
      function crash(message) {
        throw new Error(`ERR (${state})/"${buffer}": ${message}`);
      }
      let state = 0;
      let previousState = state;
      const tokens = [];
      let segment;
      function finalizeSegment() {
        if (segment)
          tokens.push(segment);
        segment = [];
      }
      let i2 = 0;
      let char;
      let buffer = "";
      let customRe = "";
      function consumeBuffer() {
        if (!buffer)
          return;
        if (state === 0) {
          segment.push({
            type: 0,
            value: buffer
          });
        } else if (state === 1 || state === 2 || state === 3) {
          if (segment.length > 1 && (char === "*" || char === "+"))
            crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
          segment.push({
            type: 1,
            value: buffer,
            regexp: customRe,
            repeatable: char === "*" || char === "+",
            optional: char === "*" || char === "?"
          });
        } else {
          crash("Invalid state to consume buffer");
        }
        buffer = "";
      }
      function addCharToBuffer() {
        buffer += char;
      }
      while (i2 < path.length) {
        char = path[i2++];
        if (char === "\\" && state !== 2) {
          previousState = state;
          state = 4;
          continue;
        }
        switch (state) {
          case 0:
            if (char === "/") {
              if (buffer) {
                consumeBuffer();
              }
              finalizeSegment();
            } else if (char === ":") {
              consumeBuffer();
              state = 1;
            } else {
              addCharToBuffer();
            }
            break;
          case 4:
            addCharToBuffer();
            state = previousState;
            break;
          case 1:
            if (char === "(") {
              state = 2;
            } else if (VALID_PARAM_RE.test(char)) {
              addCharToBuffer();
            } else {
              consumeBuffer();
              state = 0;
              if (char !== "*" && char !== "?" && char !== "+")
                i2--;
            }
            break;
          case 2:
            if (char === ")") {
              if (customRe[customRe.length - 1] == "\\")
                customRe = customRe.slice(0, -1) + char;
              else
                state = 3;
            } else {
              customRe += char;
            }
            break;
          case 3:
            consumeBuffer();
            state = 0;
            if (char !== "*" && char !== "?" && char !== "+")
              i2--;
            customRe = "";
            break;
          default:
            crash("Unknown state");
            break;
        }
      }
      if (state === 2)
        crash(`Unfinished custom RegExp for param "${buffer}"`);
      consumeBuffer();
      finalizeSegment();
      return tokens;
    }
    function createRouteRecordMatcher(record, parent, options) {
      const parser = tokensToParser(tokenizePath(record.path), options);
      const matcher = assign$3(parser, {
        record,
        parent,
        // these needs to be populated by the parent
        children: [],
        alias: []
      });
      if (parent) {
        if (!matcher.record.aliasOf === !parent.record.aliasOf)
          parent.children.push(matcher);
      }
      return matcher;
    }
    function createRouterMatcher(routes2, globalOptions) {
      const matchers = [];
      const matcherMap = /* @__PURE__ */ new Map();
      globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
      function getRecordMatcher(name) {
        return matcherMap.get(name);
      }
      function addRoute(record, parent, originalRecord) {
        const isRootAdd = !originalRecord;
        const mainNormalizedRecord = normalizeRouteRecord(record);
        mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
        const options = mergeOptions(globalOptions, record);
        const normalizedRecords = [
          mainNormalizedRecord
        ];
        if ("alias" in record) {
          const aliases2 = typeof record.alias === "string" ? [record.alias] : record.alias;
          for (const alias of aliases2) {
            normalizedRecords.push(assign$3({}, mainNormalizedRecord, {
              // this allows us to hold a copy of the `components` option
              // so that async components cache is hold on the original record
              components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
              path: alias,
              // we might be the child of an alias
              aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
              // the aliases are always of the same kind as the original since they
              // are defined on the same record
            }));
          }
        }
        let matcher;
        let originalMatcher;
        for (const normalizedRecord of normalizedRecords) {
          const { path } = normalizedRecord;
          if (parent && path[0] !== "/") {
            const parentPath = parent.record.path;
            const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
            normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
          }
          matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
          if (originalRecord) {
            originalRecord.alias.push(matcher);
          } else {
            originalMatcher = originalMatcher || matcher;
            if (originalMatcher !== matcher)
              originalMatcher.alias.push(matcher);
            if (isRootAdd && record.name && !isAliasRecord(matcher))
              removeRoute(record.name);
          }
          if (isMatchable(matcher)) {
            insertMatcher(matcher);
          }
          if (mainNormalizedRecord.children) {
            const children = mainNormalizedRecord.children;
            for (let i2 = 0; i2 < children.length; i2++) {
              addRoute(children[i2], matcher, originalRecord && originalRecord.children[i2]);
            }
          }
          originalRecord = originalRecord || matcher;
        }
        return originalMatcher ? () => {
          removeRoute(originalMatcher);
        } : noop$2;
      }
      function removeRoute(matcherRef) {
        if (isRouteName(matcherRef)) {
          const matcher = matcherMap.get(matcherRef);
          if (matcher) {
            matcherMap.delete(matcherRef);
            matchers.splice(matchers.indexOf(matcher), 1);
            matcher.children.forEach(removeRoute);
            matcher.alias.forEach(removeRoute);
          }
        } else {
          const index = matchers.indexOf(matcherRef);
          if (index > -1) {
            matchers.splice(index, 1);
            if (matcherRef.record.name)
              matcherMap.delete(matcherRef.record.name);
            matcherRef.children.forEach(removeRoute);
            matcherRef.alias.forEach(removeRoute);
          }
        }
      }
      function getRoutes() {
        return matchers;
      }
      function insertMatcher(matcher) {
        const index = findInsertionIndex(matcher, matchers);
        matchers.splice(index, 0, matcher);
        if (matcher.record.name && !isAliasRecord(matcher))
          matcherMap.set(matcher.record.name, matcher);
      }
      function resolve2(location2, currentLocation) {
        let matcher;
        let params = {};
        let path;
        let name;
        if ("name" in location2 && location2.name) {
          matcher = matcherMap.get(location2.name);
          if (!matcher)
            throw createRouterError(1, {
              location: location2
            });
          name = matcher.record.name;
          params = assign$3(
            // paramsFromLocation is a new object
            paramsFromLocation(
              currentLocation.params,
              // only keep params that exist in the resolved location
              // only keep optional params coming from a parent record
              matcher.keys.filter((k) => !k.optional).concat(matcher.parent ? matcher.parent.keys.filter((k) => k.optional) : []).map((k) => k.name)
            ),
            // discard any existing params in the current location that do not exist here
            // #1497 this ensures better active/exact matching
            location2.params && paramsFromLocation(location2.params, matcher.keys.map((k) => k.name))
          );
          path = matcher.stringify(params);
        } else if (location2.path != null) {
          path = location2.path;
          matcher = matchers.find((m) => m.re.test(path));
          if (matcher) {
            params = matcher.parse(path);
            name = matcher.record.name;
          }
        } else {
          matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m) => m.re.test(currentLocation.path));
          if (!matcher)
            throw createRouterError(1, {
              location: location2,
              currentLocation
            });
          name = matcher.record.name;
          params = assign$3({}, currentLocation.params, location2.params);
          path = matcher.stringify(params);
        }
        const matched = [];
        let parentMatcher = matcher;
        while (parentMatcher) {
          matched.unshift(parentMatcher.record);
          parentMatcher = parentMatcher.parent;
        }
        return {
          name,
          path,
          params,
          matched,
          meta: mergeMetaFields(matched)
        };
      }
      routes2.forEach((route) => addRoute(route));
      function clearRoutes() {
        matchers.length = 0;
        matcherMap.clear();
      }
      return {
        addRoute,
        resolve: resolve2,
        removeRoute,
        clearRoutes,
        getRoutes,
        getRecordMatcher
      };
    }
    function paramsFromLocation(params, keys2) {
      const newParams = {};
      for (const key of keys2) {
        if (key in params)
          newParams[key] = params[key];
      }
      return newParams;
    }
    function normalizeRouteRecord(record) {
      return {
        path: record.path,
        redirect: record.redirect,
        name: record.name,
        meta: record.meta || {},
        aliasOf: void 0,
        beforeEnter: record.beforeEnter,
        props: normalizeRecordProps(record),
        children: record.children || [],
        instances: {},
        leaveGuards: /* @__PURE__ */ new Set(),
        updateGuards: /* @__PURE__ */ new Set(),
        enterCallbacks: {},
        components: "components" in record ? record.components || null : record.component && { default: record.component }
      };
    }
    function normalizeRecordProps(record) {
      const propsObject = {};
      const props = record.props || false;
      if ("component" in record) {
        propsObject.default = props;
      } else {
        for (const name in record.components)
          propsObject[name] = typeof props === "object" ? props[name] : props;
      }
      return propsObject;
    }
    function isAliasRecord(record) {
      while (record) {
        if (record.record.aliasOf)
          return true;
        record = record.parent;
      }
      return false;
    }
    function mergeMetaFields(matched) {
      return matched.reduce((meta, record) => assign$3(meta, record.meta), {});
    }
    function mergeOptions(defaults2, partialOptions) {
      const options = {};
      for (const key in defaults2) {
        options[key] = key in partialOptions ? partialOptions[key] : defaults2[key];
      }
      return options;
    }
    function findInsertionIndex(matcher, matchers) {
      let lower = 0;
      let upper = matchers.length;
      while (lower !== upper) {
        const mid2 = lower + upper >> 1;
        const sortOrder = comparePathParserScore(matcher, matchers[mid2]);
        if (sortOrder < 0) {
          upper = mid2;
        } else {
          lower = mid2 + 1;
        }
      }
      const insertionAncestor = getInsertionAncestor(matcher);
      if (insertionAncestor) {
        upper = matchers.lastIndexOf(insertionAncestor, upper - 1);
      }
      return upper;
    }
    function getInsertionAncestor(matcher) {
      let ancestor = matcher;
      while (ancestor = ancestor.parent) {
        if (isMatchable(ancestor) && comparePathParserScore(matcher, ancestor) === 0) {
          return ancestor;
        }
      }
      return;
    }
    function isMatchable({ record }) {
      return !!(record.name || record.components && Object.keys(record.components).length || record.redirect);
    }
    function parseQuery(search) {
      const query = {};
      if (search === "" || search === "?")
        return query;
      const hasLeadingIM = search[0] === "?";
      const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
      for (let i2 = 0; i2 < searchParams.length; ++i2) {
        const searchParam = searchParams[i2].replace(PLUS_RE, " ");
        const eqPos = searchParam.indexOf("=");
        const key = decode$2(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
        const value = eqPos < 0 ? null : decode$2(searchParam.slice(eqPos + 1));
        if (key in query) {
          let currentValue = query[key];
          if (!isArray(currentValue)) {
            currentValue = query[key] = [currentValue];
          }
          currentValue.push(value);
        } else {
          query[key] = value;
        }
      }
      return query;
    }
    function stringifyQuery(query) {
      let search = "";
      for (let key in query) {
        const value = query[key];
        key = encodeQueryKey(key);
        if (value == null) {
          if (value !== void 0) {
            search += (search.length ? "&" : "") + key;
          }
          continue;
        }
        const values = isArray(value) ? value.map((v) => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)];
        values.forEach((value2) => {
          if (value2 !== void 0) {
            search += (search.length ? "&" : "") + key;
            if (value2 != null)
              search += "=" + value2;
          }
        });
      }
      return search;
    }
    function normalizeQuery(query) {
      const normalizedQuery = {};
      for (const key in query) {
        const value = query[key];
        if (value !== void 0) {
          normalizedQuery[key] = isArray(value) ? value.map((v) => v == null ? null : "" + v) : value == null ? value : "" + value;
        }
      }
      return normalizedQuery;
    }
    const matchedRouteKey = Symbol("");
    const viewDepthKey = Symbol("");
    const routerKey = Symbol("");
    const routeLocationKey = Symbol("");
    const routerViewLocationKey = Symbol("");
    function useCallbacks() {
      let handlers2 = [];
      function add2(handler) {
        handlers2.push(handler);
        return () => {
          const i2 = handlers2.indexOf(handler);
          if (i2 > -1)
            handlers2.splice(i2, 1);
        };
      }
      function reset() {
        handlers2 = [];
      }
      return {
        add: add2,
        list: () => handlers2.slice(),
        reset
      };
    }
    function guardToPromiseFn(guard, to, from, record, name, runWithContext = (fn) => fn()) {
      const enterCallbackArray = record && // name is defined if record is because of the function overload
      (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
      return () => new Promise((resolve2, reject) => {
        const next2 = (valid) => {
          if (valid === false) {
            reject(createRouterError(4, {
              from,
              to
            }));
          } else if (valid instanceof Error) {
            reject(valid);
          } else if (isRouteLocation(valid)) {
            reject(createRouterError(2, {
              from: to,
              to: valid
            }));
          } else {
            if (enterCallbackArray && // since enterCallbackArray is truthy, both record and name also are
            record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function") {
              enterCallbackArray.push(valid);
            }
            resolve2();
          }
        };
        const guardReturn = runWithContext(() => guard.call(record && record.instances[name], to, from, next2));
        let guardCall = Promise.resolve(guardReturn);
        if (guard.length < 3)
          guardCall = guardCall.then(next2);
        guardCall.catch((err) => reject(err));
      });
    }
    function extractComponentsGuards(matched, guardType, to, from, runWithContext = (fn) => fn()) {
      const guards = [];
      for (const record of matched) {
        for (const name in record.components) {
          let rawComponent = record.components[name];
          if (guardType !== "beforeRouteEnter" && !record.instances[name])
            continue;
          if (isRouteComponent(rawComponent)) {
            const options = rawComponent.__vccOpts || rawComponent;
            const guard = options[guardType];
            guard && guards.push(guardToPromiseFn(guard, to, from, record, name, runWithContext));
          } else {
            let componentPromise = rawComponent();
            guards.push(() => componentPromise.then((resolved) => {
              if (!resolved)
                return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
              const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
              record.components[name] = resolvedComponent;
              const options = resolvedComponent.__vccOpts || resolvedComponent;
              const guard = options[guardType];
              return guard && guardToPromiseFn(guard, to, from, record, name, runWithContext)();
            }));
          }
        }
      }
      return guards;
    }
    function isRouteComponent(component) {
      return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
    }
    function useLink$1(props) {
      const router2 = inject$1(routerKey);
      const currentRoute = inject$1(routeLocationKey);
      const route = computed(() => {
        const to = unref(props.to);
        return router2.resolve(to);
      });
      const activeRecordIndex = computed(() => {
        const { matched } = route.value;
        const { length } = matched;
        const routeMatched = matched[length - 1];
        const currentMatched = currentRoute.matched;
        if (!routeMatched || !currentMatched.length)
          return -1;
        const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
        if (index > -1)
          return index;
        const parentRecordPath = getOriginalPath(matched[length - 2]);
        return (
          // we are dealing with nested routes
          length > 1 && // if the parent and matched route have the same path, this link is
          // referring to the empty child. Or we currently are on a different
          // child of the same parent
          getOriginalPath(routeMatched) === parentRecordPath && // avoid comparing the child with its parent
          currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index
        );
      });
      const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
      const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
      function navigate(e = {}) {
        if (guardEvent(e)) {
          return router2[unref(props.replace) ? "replace" : "push"](
            unref(props.to)
            // avoid uncaught errors are they are logged anyway
          ).catch(noop$2);
        }
        return Promise.resolve();
      }
      return {
        route,
        href: computed(() => route.value.href),
        isActive,
        isExactActive,
        navigate
      };
    }
    const RouterLinkImpl = /* @__PURE__ */ defineComponent$1({
      name: "RouterLink",
      compatConfig: { MODE: 3 },
      props: {
        to: {
          type: [String, Object],
          required: true
        },
        replace: Boolean,
        activeClass: String,
        // inactiveClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
          type: String,
          default: "page"
        }
      },
      useLink: useLink$1,
      setup(props, { slots }) {
        const link2 = reactive(useLink$1(props));
        const { options } = inject$1(routerKey);
        const elClass = computed(() => ({
          [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link2.isActive,
          // [getLinkClass(
          //   props.inactiveClass,
          //   options.linkInactiveClass,
          //   'router-link-inactive'
          // )]: !link.isExactActive,
          [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link2.isExactActive
        }));
        return () => {
          const children = slots.default && slots.default(link2);
          return props.custom ? children : h("a", {
            "aria-current": link2.isExactActive ? props.ariaCurrentValue : null,
            href: link2.href,
            // this would override user added attrs but Vue will still add
            // the listener, so we end up triggering both
            onClick: link2.navigate,
            class: elClass.value
          }, children);
        };
      }
    });
    const RouterLink = RouterLinkImpl;
    function guardEvent(e) {
      if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
        return;
      if (e.defaultPrevented)
        return;
      if (e.button !== void 0 && e.button !== 0)
        return;
      if (e.currentTarget && e.currentTarget.getAttribute) {
        const target2 = e.currentTarget.getAttribute("target");
        if (/\b_blank\b/i.test(target2))
          return;
      }
      if (e.preventDefault)
        e.preventDefault();
      return true;
    }
    function includesParams(outer, inner) {
      for (const key in inner) {
        const innerValue = inner[key];
        const outerValue = outer[key];
        if (typeof innerValue === "string") {
          if (innerValue !== outerValue)
            return false;
        } else {
          if (!isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i2) => value !== outerValue[i2]))
            return false;
        }
      }
      return true;
    }
    function getOriginalPath(record) {
      return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
    }
    const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
    const RouterViewImpl = /* @__PURE__ */ defineComponent$1({
      name: "RouterView",
      // #674 we manually inherit them
      inheritAttrs: false,
      props: {
        name: {
          type: String,
          default: "default"
        },
        route: Object
      },
      // Better compat for @vue/compat users
      // https://github.com/vuejs/router/issues/1315
      compatConfig: { MODE: 3 },
      setup(props, { attrs, slots }) {
        const injectedRoute = inject$1(routerViewLocationKey);
        const routeToDisplay = computed(() => props.route || injectedRoute.value);
        const injectedDepth = inject$1(viewDepthKey, 0);
        const depth = computed(() => {
          let initialDepth = unref(injectedDepth);
          const { matched } = routeToDisplay.value;
          let matchedRoute;
          while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
            initialDepth++;
          }
          return initialDepth;
        });
        const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);
        provide(viewDepthKey, computed(() => depth.value + 1));
        provide(matchedRouteKey, matchedRouteRef);
        provide(routerViewLocationKey, routeToDisplay);
        const viewRef = ref$1();
        watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {
          if (to) {
            to.instances[name] = instance;
            if (from && from !== to && instance && instance === oldInstance) {
              if (!to.leaveGuards.size) {
                to.leaveGuards = from.leaveGuards;
              }
              if (!to.updateGuards.size) {
                to.updateGuards = from.updateGuards;
              }
            }
          }
          if (instance && to && // if there is no instance but to and from are the same this might be
          // the first visit
          (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
            (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));
          }
        }, { flush: "post" });
        return () => {
          const route = routeToDisplay.value;
          const currentName = props.name;
          const matchedRoute = matchedRouteRef.value;
          const ViewComponent = matchedRoute && matchedRoute.components[currentName];
          if (!ViewComponent) {
            return normalizeSlot(slots.default, { Component: ViewComponent, route });
          }
          const routePropsOption = matchedRoute.props[currentName];
          const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
          const onVnodeUnmounted = (vnode) => {
            if (vnode.component.isUnmounted) {
              matchedRoute.instances[currentName] = null;
            }
          };
          const component = h(ViewComponent, assign$3({}, routeProps, attrs, {
            onVnodeUnmounted,
            ref: viewRef
          }));
          return (
            // pass the vnode to the slot as a prop.
            // h and <component :is="..."> both accept vnodes
            normalizeSlot(slots.default, { Component: component, route }) || component
          );
        };
      }
    });
    function normalizeSlot(slot, data) {
      if (!slot)
        return null;
      const slotContent = slot(data);
      return slotContent.length === 1 ? slotContent[0] : slotContent;
    }
    const RouterView = RouterViewImpl;
    function createRouter(options) {
      const matcher = createRouterMatcher(options.routes, options);
      const parseQuery$1 = options.parseQuery || parseQuery;
      const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
      const routerHistory = options.history;
      const beforeGuards = useCallbacks();
      const beforeResolveGuards = useCallbacks();
      const afterGuards = useCallbacks();
      const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
      let pendingLocation = START_LOCATION_NORMALIZED;
      if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
        history.scrollRestoration = "manual";
      }
      const normalizeParams2 = applyToParams.bind(null, (paramValue) => "" + paramValue);
      const encodeParams = applyToParams.bind(null, encodeParam);
      const decodeParams = (
        // @ts-expect-error: intentionally avoid the type check
        applyToParams.bind(null, decode$2)
      );
      function addRoute(parentOrRoute, route) {
        let parent;
        let record;
        if (isRouteName(parentOrRoute)) {
          parent = matcher.getRecordMatcher(parentOrRoute);
          record = route;
        } else {
          record = parentOrRoute;
        }
        return matcher.addRoute(record, parent);
      }
      function removeRoute(name) {
        const recordMatcher = matcher.getRecordMatcher(name);
        if (recordMatcher) {
          matcher.removeRoute(recordMatcher);
        }
      }
      function getRoutes() {
        return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
      }
      function hasRoute(name) {
        return !!matcher.getRecordMatcher(name);
      }
      function resolve2(rawLocation, currentLocation) {
        currentLocation = assign$3({}, currentLocation || currentRoute.value);
        if (typeof rawLocation === "string") {
          const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
          const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
          const href2 = routerHistory.createHref(locationNormalized.fullPath);
          return assign$3(locationNormalized, matchedRoute2, {
            params: decodeParams(matchedRoute2.params),
            hash: decode$2(locationNormalized.hash),
            redirectedFrom: void 0,
            href: href2
          });
        }
        let matcherLocation;
        if (rawLocation.path != null) {
          matcherLocation = assign$3({}, rawLocation, {
            path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
          });
        } else {
          const targetParams = assign$3({}, rawLocation.params);
          for (const key in targetParams) {
            if (targetParams[key] == null) {
              delete targetParams[key];
            }
          }
          matcherLocation = assign$3({}, rawLocation, {
            params: encodeParams(targetParams)
          });
          currentLocation.params = encodeParams(currentLocation.params);
        }
        const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
        const hash = rawLocation.hash || "";
        matchedRoute.params = normalizeParams2(decodeParams(matchedRoute.params));
        const fullPath = stringifyURL(stringifyQuery$1, assign$3({}, rawLocation, {
          hash: encodeHash(hash),
          path: matchedRoute.path
        }));
        const href = routerHistory.createHref(fullPath);
        return assign$3({
          fullPath,
          // keep the hash encoded so fullPath is effectively path + encodedQuery +
          // hash
          hash,
          query: (
            // if the user is using a custom query lib like qs, we might have
            // nested objects, so we keep the query as is, meaning it can contain
            // numbers at `$route.query`, but at the point, the user will have to
            // use their own type anyway.
            // https://github.com/vuejs/router/issues/328#issuecomment-649481567
            stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
          )
        }, matchedRoute, {
          redirectedFrom: void 0,
          href
        });
      }
      function locationAsObject(to) {
        return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign$3({}, to);
      }
      function checkCanceledNavigation(to, from) {
        if (pendingLocation !== to) {
          return createRouterError(8, {
            from,
            to
          });
        }
      }
      function push(to) {
        return pushWithRedirect(to);
      }
      function replace2(to) {
        return push(assign$3(locationAsObject(to), { replace: true }));
      }
      function handleRedirectRecord(to) {
        const lastMatched = to.matched[to.matched.length - 1];
        if (lastMatched && lastMatched.redirect) {
          const { redirect } = lastMatched;
          let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
          if (typeof newTargetLocation === "string") {
            newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : (
              // force empty params
              { path: newTargetLocation }
            );
            newTargetLocation.params = {};
          }
          return assign$3({
            query: to.query,
            hash: to.hash,
            // avoid transferring params if the redirect has a path
            params: newTargetLocation.path != null ? {} : to.params
          }, newTargetLocation);
        }
      }
      function pushWithRedirect(to, redirectedFrom) {
        const targetLocation = pendingLocation = resolve2(to);
        const from = currentRoute.value;
        const data = to.state;
        const force = to.force;
        const replace22 = to.replace === true;
        const shouldRedirect = handleRedirectRecord(targetLocation);
        if (shouldRedirect)
          return pushWithRedirect(
            assign$3(locationAsObject(shouldRedirect), {
              state: typeof shouldRedirect === "object" ? assign$3({}, data, shouldRedirect.state) : data,
              force,
              replace: replace22
            }),
            // keep original redirectedFrom if it exists
            redirectedFrom || targetLocation
          );
        const toLocation = targetLocation;
        toLocation.redirectedFrom = redirectedFrom;
        let failure;
        if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
          failure = createRouterError(16, { to: toLocation, from });
          handleScroll(
            from,
            from,
            // this is a push, the only way for it to be triggered from a
            // history.listen is with a redirect, which makes it become a push
            true,
            // This cannot be the first navigation because the initial location
            // cannot be manually navigated to
            false
          );
        }
        return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error2) => isNavigationFailure(error2) ? (
          // navigation redirects still mark the router as ready
          isNavigationFailure(
            error2,
            2
            /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
          ) ? error2 : markAsReady(error2)
        ) : (
          // reject any unknown error
          triggerError(error2, toLocation, from)
        )).then((failure2) => {
          if (failure2) {
            if (isNavigationFailure(
              failure2,
              2
              /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
            )) {
              return pushWithRedirect(
                // keep options
                assign$3({
                  // preserve an existing replacement but allow the redirect to override it
                  replace: replace22
                }, locationAsObject(failure2.to), {
                  state: typeof failure2.to === "object" ? assign$3({}, data, failure2.to.state) : data,
                  force
                }),
                // preserve the original redirectedFrom if any
                redirectedFrom || toLocation
              );
            }
          } else {
            failure2 = finalizeNavigation(toLocation, from, true, replace22, data);
          }
          triggerAfterEach(toLocation, from, failure2);
          return failure2;
        });
      }
      function checkCanceledNavigationAndReject(to, from) {
        const error2 = checkCanceledNavigation(to, from);
        return error2 ? Promise.reject(error2) : Promise.resolve();
      }
      function runWithContext(fn) {
        const app2 = installedApps.values().next().value;
        return app2 && typeof app2.runWithContext === "function" ? app2.runWithContext(fn) : fn();
      }
      function navigate(to, from) {
        let guards;
        const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
        guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from);
        for (const record of leavingRecords) {
          record.leaveGuards.forEach((guard) => {
            guards.push(guardToPromiseFn(guard, to, from));
          });
        }
        const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards).then(() => {
          guards = [];
          for (const guard of beforeGuards.list()) {
            guards.push(guardToPromiseFn(guard, to, from));
          }
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).then(() => {
          guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from);
          for (const record of updatingRecords) {
            record.updateGuards.forEach((guard) => {
              guards.push(guardToPromiseFn(guard, to, from));
            });
          }
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).then(() => {
          guards = [];
          for (const record of enteringRecords) {
            if (record.beforeEnter) {
              if (isArray(record.beforeEnter)) {
                for (const beforeEnter of record.beforeEnter)
                  guards.push(guardToPromiseFn(beforeEnter, to, from));
              } else {
                guards.push(guardToPromiseFn(record.beforeEnter, to, from));
              }
            }
          }
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).then(() => {
          to.matched.forEach((record) => record.enterCallbacks = {});
          guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from, runWithContext);
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).then(() => {
          guards = [];
          for (const guard of beforeResolveGuards.list()) {
            guards.push(guardToPromiseFn(guard, to, from));
          }
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).catch((err) => isNavigationFailure(
          err,
          8
          /* ErrorTypes.NAVIGATION_CANCELLED */
        ) ? err : Promise.reject(err));
      }
      function triggerAfterEach(to, from, failure) {
        afterGuards.list().forEach((guard) => runWithContext(() => guard(to, from, failure)));
      }
      function finalizeNavigation(toLocation, from, isPush, replace22, data) {
        const error2 = checkCanceledNavigation(toLocation, from);
        if (error2)
          return error2;
        const isFirstNavigation = from === START_LOCATION_NORMALIZED;
        const state = !isBrowser ? {} : history.state;
        if (isPush) {
          if (replace22 || isFirstNavigation)
            routerHistory.replace(toLocation.fullPath, assign$3({
              scroll: isFirstNavigation && state && state.scroll
            }, data));
          else
            routerHistory.push(toLocation.fullPath, data);
        }
        currentRoute.value = toLocation;
        handleScroll(toLocation, from, isPush, isFirstNavigation);
        markAsReady();
      }
      let removeHistoryListener;
      function setupListeners() {
        if (removeHistoryListener)
          return;
        removeHistoryListener = routerHistory.listen((to, _from, info) => {
          if (!router2.listening)
            return;
          const toLocation = resolve2(to);
          const shouldRedirect = handleRedirectRecord(toLocation);
          if (shouldRedirect) {
            pushWithRedirect(assign$3(shouldRedirect, { replace: true }), toLocation).catch(noop$2);
            return;
          }
          pendingLocation = toLocation;
          const from = currentRoute.value;
          if (isBrowser) {
            saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
          }
          navigate(toLocation, from).catch((error2) => {
            if (isNavigationFailure(
              error2,
              4 | 8
              /* ErrorTypes.NAVIGATION_CANCELLED */
            )) {
              return error2;
            }
            if (isNavigationFailure(
              error2,
              2
              /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
            )) {
              pushWithRedirect(
                error2.to,
                toLocation
                // avoid an uncaught rejection, let push call triggerError
              ).then((failure) => {
                if (isNavigationFailure(
                  failure,
                  4 | 16
                  /* ErrorTypes.NAVIGATION_DUPLICATED */
                ) && !info.delta && info.type === NavigationType.pop) {
                  routerHistory.go(-1, false);
                }
              }).catch(noop$2);
              return Promise.reject();
            }
            if (info.delta) {
              routerHistory.go(-info.delta, false);
            }
            return triggerError(error2, toLocation, from);
          }).then((failure) => {
            failure = failure || finalizeNavigation(
              // after navigation, all matched components are resolved
              toLocation,
              from,
              false
            );
            if (failure) {
              if (info.delta && // a new navigation has been triggered, so we do not want to revert, that will change the current history
              // entry while a different route is displayed
              !isNavigationFailure(
                failure,
                8
                /* ErrorTypes.NAVIGATION_CANCELLED */
              )) {
                routerHistory.go(-info.delta, false);
              } else if (info.type === NavigationType.pop && isNavigationFailure(
                failure,
                4 | 16
                /* ErrorTypes.NAVIGATION_DUPLICATED */
              )) {
                routerHistory.go(-1, false);
              }
            }
            triggerAfterEach(toLocation, from, failure);
          }).catch(noop$2);
        });
      }
      let readyHandlers = useCallbacks();
      let errorListeners = useCallbacks();
      let ready;
      function triggerError(error2, to, from) {
        markAsReady(error2);
        const list2 = errorListeners.list();
        if (list2.length) {
          list2.forEach((handler) => handler(error2, to, from));
        } else {
          console.error(error2);
        }
        return Promise.reject(error2);
      }
      function isReady() {
        if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
          return Promise.resolve();
        return new Promise((resolve22, reject) => {
          readyHandlers.add([resolve22, reject]);
        });
      }
      function markAsReady(err) {
        if (!ready) {
          ready = !err;
          setupListeners();
          readyHandlers.list().forEach(([resolve22, reject]) => err ? reject(err) : resolve22());
          readyHandlers.reset();
        }
        return err;
      }
      function handleScroll(to, from, isPush, isFirstNavigation) {
        const { scrollBehavior } = options;
        if (!isBrowser || !scrollBehavior)
          return Promise.resolve();
        const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
        return nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to, from));
      }
      const go = (delta2) => routerHistory.go(delta2);
      let started;
      const installedApps = /* @__PURE__ */ new Set();
      const router2 = {
        currentRoute,
        listening: true,
        addRoute,
        removeRoute,
        clearRoutes: matcher.clearRoutes,
        hasRoute,
        getRoutes,
        resolve: resolve2,
        options,
        push,
        replace: replace2,
        go,
        back: () => go(-1),
        forward: () => go(1),
        beforeEach: beforeGuards.add,
        beforeResolve: beforeResolveGuards.add,
        afterEach: afterGuards.add,
        onError: errorListeners.add,
        isReady,
        install(app2) {
          const router22 = this;
          app2.component("RouterLink", RouterLink);
          app2.component("RouterView", RouterView);
          app2.config.globalProperties.$router = router22;
          Object.defineProperty(app2.config.globalProperties, "$route", {
            enumerable: true,
            get: () => unref(currentRoute)
          });
          if (isBrowser && // used for the initial navigation client side to avoid pushing
          // multiple times when the router is used in multiple apps
          !started && currentRoute.value === START_LOCATION_NORMALIZED) {
            started = true;
            push(routerHistory.location).catch((err) => {
            });
          }
          const reactiveRoute = {};
          for (const key in START_LOCATION_NORMALIZED) {
            Object.defineProperty(reactiveRoute, key, {
              get: () => currentRoute.value[key],
              enumerable: true
            });
          }
          app2.provide(routerKey, router22);
          app2.provide(routeLocationKey, shallowReactive(reactiveRoute));
          app2.provide(routerViewLocationKey, currentRoute);
          const unmountApp = app2.unmount;
          installedApps.add(app2);
          app2.unmount = function() {
            installedApps.delete(app2);
            if (installedApps.size < 1) {
              pendingLocation = START_LOCATION_NORMALIZED;
              removeHistoryListener && removeHistoryListener();
              removeHistoryListener = null;
              currentRoute.value = START_LOCATION_NORMALIZED;
              started = false;
              ready = false;
            }
            unmountApp();
          };
        }
      };
      function runGuardQueue(guards) {
        return guards.reduce((promise, guard) => promise.then(() => runWithContext(guard)), Promise.resolve());
      }
      return router2;
    }
    function extractChangingRecords(to, from) {
      const leavingRecords = [];
      const updatingRecords = [];
      const enteringRecords = [];
      const len = Math.max(from.matched.length, to.matched.length);
      for (let i2 = 0; i2 < len; i2++) {
        const recordFrom = from.matched[i2];
        if (recordFrom) {
          if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))
            updatingRecords.push(recordFrom);
          else
            leavingRecords.push(recordFrom);
        }
        const recordTo = to.matched[i2];
        if (recordTo) {
          if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) {
            enteringRecords.push(recordTo);
          }
        }
      }
      return [leavingRecords, updatingRecords, enteringRecords];
    }
    function useRouter$1() {
      return inject$1(routerKey);
    }
    let evbc$1;
    let router$1;
    let notyf$1;
    const _sfc_main$L = /* @__PURE__ */ defineComponent$1({
      data: () => ({
        drawer: false,
        evbc_disconnected: false,
        evbc_status: "",
        version: "0.3.0"
      }),
      computed: {
        connectionUrl() {
          var _a2;
          return ((_a2 = evbc$1 == null ? void 0 : evbc$1._cxn) == null ? void 0 : _a2._url) ?? "nothing";
        }
      },
      methods: {
        async changeInstance() {
          let notification;
          const timeout = setTimeout(() => {
            notification = notyf$1.open({ type: "warning", message: "Disconnecting from EVerest backend ...", ripple: false });
          }, 250);
          await evbc$1.disconnect();
          clearTimeout(timeout);
          if (notification) {
            notyf$1.dismiss(notification);
          }
          await router$1.push({ path: "/connect", query: { auto_connect: "false" } });
        }
      },
      created() {
        evbc$1 = inject$1("evbc");
        router$1 = useRouter$1();
        notyf$1 = inject$1("notyf");
        evbc$1.on("connection_state", (ev) => {
          this.evbc_status = ev.text;
          if (ev.type === "RECONNECT" || ev.type === "IDLE") {
            this.evbc_disconnected = true;
          } else if (ev.type === "INITIALIZED") {
            this.evbc_disconnected = false;
          }
        });
      }
    });
    const _imports_0 = "/everest-admin-panel/pr-181/img/icons/everest_lf_logo_white.svg";
    function propsFactory(props, source2) {
      return (defaults2) => {
        return Object.keys(props).reduce((obj, prop2) => {
          const isObjectDefinition = typeof props[prop2] === "object" && props[prop2] != null && !Array.isArray(props[prop2]);
          const definition = isObjectDefinition ? props[prop2] : {
            type: props[prop2]
          };
          if (defaults2 && prop2 in defaults2) {
            obj[prop2] = {
              ...definition,
              default: defaults2[prop2]
            };
          } else {
            obj[prop2] = definition;
          }
          if (source2 && !obj[prop2].source) {
            obj[prop2].source = source2;
          }
          return obj;
        }, {});
      };
    }
    const makeComponentProps = propsFactory({
      class: [String, Array, Object],
      style: {
        type: [String, Array, Object],
        default: null
      }
    }, "component");
    const IN_BROWSER = typeof window !== "undefined";
    const SUPPORTS_INTERSECTION = IN_BROWSER && "IntersectionObserver" in window;
    const SUPPORTS_TOUCH = IN_BROWSER && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0);
    const SUPPORTS_EYE_DROPPER = IN_BROWSER && "EyeDropper" in window;
    function _classPrivateFieldInitSpec(obj, privateMap, value) {
      _checkPrivateRedeclaration(obj, privateMap);
      privateMap.set(obj, value);
    }
    function _checkPrivateRedeclaration(obj, privateCollection) {
      if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
      }
    }
    function _classPrivateFieldSet(s, a, r2) {
      return s.set(_assertClassBrand(s, a), r2), r2;
    }
    function _classPrivateFieldGet(s, a) {
      return s.get(_assertClassBrand(s, a));
    }
    function _assertClassBrand(e, t, n) {
      if ("function" == typeof e ? e === t : e.has(t))
        return arguments.length < 3 ? t : n;
      throw new TypeError("Private element is not present on this object");
    }
    function getNestedValue(obj, path, fallback) {
      const last = path.length - 1;
      if (last < 0)
        return obj === void 0 ? fallback : obj;
      for (let i2 = 0; i2 < last; i2++) {
        if (obj == null) {
          return fallback;
        }
        obj = obj[path[i2]];
      }
      if (obj == null)
        return fallback;
      return obj[path[last]] === void 0 ? fallback : obj[path[last]];
    }
    function deepEqual(a, b) {
      if (a === b)
        return true;
      if (a instanceof Date && b instanceof Date && a.getTime() !== b.getTime()) {
        return false;
      }
      if (a !== Object(a) || b !== Object(b)) {
        return false;
      }
      const props = Object.keys(a);
      if (props.length !== Object.keys(b).length) {
        return false;
      }
      return props.every((p2) => deepEqual(a[p2], b[p2]));
    }
    function getObjectValueByPath(obj, path, fallback) {
      if (obj == null || !path || typeof path !== "string")
        return fallback;
      if (obj[path] !== void 0)
        return obj[path];
      path = path.replace(/\[(\w+)\]/g, ".$1");
      path = path.replace(/^\./, "");
      return getNestedValue(obj, path.split("."), fallback);
    }
    function getPropertyFromItem(item, property, fallback) {
      if (property === true)
        return item === void 0 ? fallback : item;
      if (property == null || typeof property === "boolean")
        return fallback;
      if (item !== Object(item)) {
        if (typeof property !== "function")
          return fallback;
        const value2 = property(item, fallback);
        return typeof value2 === "undefined" ? fallback : value2;
      }
      if (typeof property === "string")
        return getObjectValueByPath(item, property, fallback);
      if (Array.isArray(property))
        return getNestedValue(item, property, fallback);
      if (typeof property !== "function")
        return fallback;
      const value = property(item, fallback);
      return typeof value === "undefined" ? fallback : value;
    }
    function createRange(length) {
      let start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      return Array.from({
        length
      }, (v, k) => start + k);
    }
    function convertToUnit(str2) {
      let unit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "px";
      if (str2 == null || str2 === "") {
        return void 0;
      } else if (isNaN(+str2)) {
        return String(str2);
      } else if (!isFinite(+str2)) {
        return void 0;
      } else {
        return `${Number(str2)}${unit}`;
      }
    }
    function isObject$3(obj) {
      return obj !== null && typeof obj === "object" && !Array.isArray(obj);
    }
    function refElement(obj) {
      if (obj && "$el" in obj) {
        const el2 = obj.$el;
        if ((el2 == null ? void 0 : el2.nodeType) === Node.TEXT_NODE) {
          return el2.nextElementSibling;
        }
        return el2;
      }
      return obj;
    }
    const keyCodes = Object.freeze({
      enter: 13,
      tab: 9,
      delete: 46,
      esc: 27,
      space: 32,
      up: 38,
      down: 40,
      left: 37,
      right: 39,
      end: 35,
      home: 36,
      del: 46,
      backspace: 8,
      insert: 45,
      pageup: 33,
      pagedown: 34,
      shift: 16
    });
    const keyValues = Object.freeze({
      enter: "Enter",
      tab: "Tab",
      delete: "Delete",
      esc: "Escape",
      space: "Space",
      up: "ArrowUp",
      down: "ArrowDown",
      left: "ArrowLeft",
      right: "ArrowRight",
      end: "End",
      home: "Home",
      del: "Delete",
      backspace: "Backspace",
      insert: "Insert",
      pageup: "PageUp",
      pagedown: "PageDown",
      shift: "Shift"
    });
    function keys(o2) {
      return Object.keys(o2);
    }
    function has$2(obj, key) {
      return key.every((k) => obj.hasOwnProperty(k));
    }
    function pick(obj, paths) {
      const found = {};
      const keys2 = new Set(Object.keys(obj));
      for (const path of paths) {
        if (keys2.has(path)) {
          found[path] = obj[path];
        }
      }
      return found;
    }
    function pickWithRest(obj, paths, exclude) {
      const found = /* @__PURE__ */ Object.create(null);
      const rest = /* @__PURE__ */ Object.create(null);
      for (const key in obj) {
        if (paths.some((path) => path instanceof RegExp ? path.test(key) : path === key) && !(exclude == null ? void 0 : exclude.some((path) => path === key))) {
          found[key] = obj[key];
        } else {
          rest[key] = obj[key];
        }
      }
      return [found, rest];
    }
    function omit$1(obj, exclude) {
      const clone2 = {
        ...obj
      };
      exclude.forEach((prop2) => delete clone2[prop2]);
      return clone2;
    }
    function only(obj, include) {
      const clone2 = {};
      include.forEach((prop2) => clone2[prop2] = obj[prop2]);
      return clone2;
    }
    const onRE = /^on[^a-z]/;
    const isOn = (key) => onRE.test(key);
    const bubblingEvents = ["onAfterscriptexecute", "onAnimationcancel", "onAnimationend", "onAnimationiteration", "onAnimationstart", "onAuxclick", "onBeforeinput", "onBeforescriptexecute", "onChange", "onClick", "onCompositionend", "onCompositionstart", "onCompositionupdate", "onContextmenu", "onCopy", "onCut", "onDblclick", "onFocusin", "onFocusout", "onFullscreenchange", "onFullscreenerror", "onGesturechange", "onGestureend", "onGesturestart", "onGotpointercapture", "onInput", "onKeydown", "onKeypress", "onKeyup", "onLostpointercapture", "onMousedown", "onMousemove", "onMouseout", "onMouseover", "onMouseup", "onMousewheel", "onPaste", "onPointercancel", "onPointerdown", "onPointerenter", "onPointerleave", "onPointermove", "onPointerout", "onPointerover", "onPointerup", "onReset", "onSelect", "onSubmit", "onTouchcancel", "onTouchend", "onTouchmove", "onTouchstart", "onTransitioncancel", "onTransitionend", "onTransitionrun", "onTransitionstart", "onWheel"];
    const compositionIgnoreKeys = ["ArrowUp", "ArrowDown", "ArrowRight", "ArrowLeft", "Enter", "Escape", "Tab", " "];
    function isComposingIgnoreKey(e) {
      return e.isComposing && compositionIgnoreKeys.includes(e.key);
    }
    function filterInputAttrs(attrs) {
      const [events, props] = pickWithRest(attrs, [onRE]);
      const inputEvents = omit$1(events, bubblingEvents);
      const [rootAttrs, inputAttrs] = pickWithRest(props, ["class", "style", "id", /^data-/]);
      Object.assign(rootAttrs, events);
      Object.assign(inputAttrs, inputEvents);
      return [rootAttrs, inputAttrs];
    }
    function wrapInArray(v) {
      return v == null ? [] : Array.isArray(v) ? v : [v];
    }
    function debounce(fn, delay) {
      let timeoutId = 0;
      const wrap = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => fn(...args), unref(delay));
      };
      wrap.clear = () => {
        clearTimeout(timeoutId);
      };
      wrap.immediate = fn;
      return wrap;
    }
    function clamp(value) {
      let min = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      let max = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      return Math.max(min, Math.min(max, value));
    }
    function getDecimals(value) {
      const trimmedStr = value.toString().trim();
      return trimmedStr.includes(".") ? trimmedStr.length - trimmedStr.indexOf(".") - 1 : 0;
    }
    function padEnd(str2, length) {
      let char = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
      return str2 + char.repeat(Math.max(0, length - str2.length));
    }
    function padStart$2(str2, length) {
      let char = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
      return char.repeat(Math.max(0, length - str2.length)) + str2;
    }
    function chunk(str2) {
      let size2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      const chunked = [];
      let index = 0;
      while (index < str2.length) {
        chunked.push(str2.substr(index, size2));
        index += size2;
      }
      return chunked;
    }
    function humanReadableFileSize(bytes) {
      let base2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
      if (bytes < base2) {
        return `${bytes} B`;
      }
      const prefix = base2 === 1024 ? ["Ki", "Mi", "Gi"] : ["k", "M", "G"];
      let unit = -1;
      while (Math.abs(bytes) >= base2 && unit < prefix.length - 1) {
        bytes /= base2;
        ++unit;
      }
      return `${bytes.toFixed(1)} ${prefix[unit]}B`;
    }
    function mergeDeep() {
      let source2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let target2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let arrayFn = arguments.length > 2 ? arguments[2] : void 0;
      const out = {};
      for (const key in source2) {
        out[key] = source2[key];
      }
      for (const key in target2) {
        const sourceProperty = source2[key];
        const targetProperty = target2[key];
        if (isObject$3(sourceProperty) && isObject$3(targetProperty)) {
          out[key] = mergeDeep(sourceProperty, targetProperty, arrayFn);
          continue;
        }
        if (Array.isArray(sourceProperty) && Array.isArray(targetProperty) && arrayFn) {
          out[key] = arrayFn(sourceProperty, targetProperty);
          continue;
        }
        out[key] = targetProperty;
      }
      return out;
    }
    function flattenFragments(nodes) {
      return nodes.map((node) => {
        if (node.type === Fragment) {
          return flattenFragments(node.children);
        } else {
          return node;
        }
      }).flat();
    }
    function toKebabCase() {
      let str2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      if (toKebabCase.cache.has(str2))
        return toKebabCase.cache.get(str2);
      const kebab = str2.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
      toKebabCase.cache.set(str2, kebab);
      return kebab;
    }
    toKebabCase.cache = /* @__PURE__ */ new Map();
    function findChildrenWithProvide(key, vnode) {
      if (!vnode || typeof vnode !== "object")
        return [];
      if (Array.isArray(vnode)) {
        return vnode.map((child) => findChildrenWithProvide(key, child)).flat(1);
      } else if (vnode.suspense) {
        return findChildrenWithProvide(key, vnode.ssContent);
      } else if (Array.isArray(vnode.children)) {
        return vnode.children.map((child) => findChildrenWithProvide(key, child)).flat(1);
      } else if (vnode.component) {
        if (Object.getOwnPropertySymbols(vnode.component.provides).includes(key)) {
          return [vnode.component];
        } else if (vnode.component.subTree) {
          return findChildrenWithProvide(key, vnode.component.subTree).flat(1);
        }
      }
      return [];
    }
    var _arr = /* @__PURE__ */ new WeakMap();
    var _pointer = /* @__PURE__ */ new WeakMap();
    class CircularBuffer {
      constructor(size2) {
        _classPrivateFieldInitSpec(this, _arr, []);
        _classPrivateFieldInitSpec(this, _pointer, 0);
        this.size = size2;
      }
      push(val) {
        _classPrivateFieldGet(_arr, this)[_classPrivateFieldGet(_pointer, this)] = val;
        _classPrivateFieldSet(_pointer, this, (_classPrivateFieldGet(_pointer, this) + 1) % this.size);
      }
      values() {
        return _classPrivateFieldGet(_arr, this).slice(_classPrivateFieldGet(_pointer, this)).concat(_classPrivateFieldGet(_arr, this).slice(0, _classPrivateFieldGet(_pointer, this)));
      }
    }
    function getEventCoordinates(e) {
      if ("touches" in e) {
        return {
          clientX: e.touches[0].clientX,
          clientY: e.touches[0].clientY
        };
      }
      return {
        clientX: e.clientX,
        clientY: e.clientY
      };
    }
    function destructComputed(getter) {
      const refs = reactive({});
      const base2 = computed(getter);
      watchEffect(() => {
        for (const key in base2.value) {
          refs[key] = base2.value[key];
        }
      }, {
        flush: "sync"
      });
      return toRefs(refs);
    }
    function includes(arr, val) {
      return arr.includes(val);
    }
    function eventName(propName) {
      return propName[2].toLowerCase() + propName.slice(3);
    }
    const EventProp = () => [Function, Array];
    function hasEvent(props, name) {
      name = "on" + capitalize(name);
      return !!(props[name] || props[`${name}Once`] || props[`${name}Capture`] || props[`${name}OnceCapture`] || props[`${name}CaptureOnce`]);
    }
    function callEvent(handler) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      if (Array.isArray(handler)) {
        for (const h2 of handler) {
          h2(...args);
        }
      } else if (typeof handler === "function") {
        handler(...args);
      }
    }
    function focusableChildren(el2) {
      let filterByTabIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      const targets = ["button", "[href]", 'input:not([type="hidden"])', "select", "textarea", "[tabindex]"].map((s) => `${s}${filterByTabIndex ? ':not([tabindex="-1"])' : ""}:not([disabled])`).join(", ");
      return [...el2.querySelectorAll(targets)];
    }
    function getNextElement(elements, location2, condition) {
      let _el;
      let idx = elements.indexOf(document.activeElement);
      const inc = location2 === "next" ? 1 : -1;
      do {
        idx += inc;
        _el = elements[idx];
      } while ((!_el || _el.offsetParent == null || !((condition == null ? void 0 : condition(_el)) ?? true)) && idx < elements.length && idx >= 0);
      return _el;
    }
    function focusChild(el2, location2) {
      var _a2, _b, _c, _d;
      const focusable = focusableChildren(el2);
      if (!location2) {
        if (el2 === document.activeElement || !el2.contains(document.activeElement)) {
          (_a2 = focusable[0]) == null ? void 0 : _a2.focus();
        }
      } else if (location2 === "first") {
        (_b = focusable[0]) == null ? void 0 : _b.focus();
      } else if (location2 === "last") {
        (_c = focusable.at(-1)) == null ? void 0 : _c.focus();
      } else if (typeof location2 === "number") {
        (_d = focusable[location2]) == null ? void 0 : _d.focus();
      } else {
        const _el = getNextElement(focusable, location2);
        if (_el)
          _el.focus();
        else
          focusChild(el2, location2 === "next" ? "first" : "last");
      }
    }
    function noop$1() {
    }
    function matchesSelector(el2, selector) {
      const supportsSelector = IN_BROWSER && typeof CSS !== "undefined" && typeof CSS.supports !== "undefined" && CSS.supports(`selector(${selector})`);
      if (!supportsSelector)
        return null;
      try {
        return !!el2 && el2.matches(selector);
      } catch (err) {
        return null;
      }
    }
    function ensureValidVNode(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child))
          return true;
        if (child.type === Comment)
          return false;
        return child.type !== Fragment || ensureValidVNode(child.children);
      }) ? vnodes : null;
    }
    function defer(timeout, cb) {
      if (!IN_BROWSER || timeout === 0) {
        cb();
        return () => {
        };
      }
      const timeoutId = window.setTimeout(cb, timeout);
      return () => window.clearTimeout(timeoutId);
    }
    function eagerComputed(fn, options) {
      const result = shallowRef();
      watchEffect(() => {
        result.value = fn();
      }, {
        flush: "sync",
        ...options
      });
      return readonly(result);
    }
    function isClickInsideElement(event, targetDiv) {
      const mouseX = event.clientX;
      const mouseY = event.clientY;
      const divRect = targetDiv.getBoundingClientRect();
      const divLeft = divRect.left;
      const divTop = divRect.top;
      const divRight = divRect.right;
      const divBottom = divRect.bottom;
      return mouseX >= divLeft && mouseX <= divRight && mouseY >= divTop && mouseY <= divBottom;
    }
    function templateRef() {
      const el2 = shallowRef();
      const fn = (target2) => {
        el2.value = target2;
      };
      Object.defineProperty(fn, "value", {
        enumerable: true,
        get: () => el2.value,
        set: (val) => el2.value = val
      });
      Object.defineProperty(fn, "el", {
        enumerable: true,
        get: () => refElement(el2.value)
      });
      return fn;
    }
    const block$2 = ["top", "bottom"];
    const inline$1 = ["start", "end", "left", "right"];
    function parseAnchor(anchor, isRtl) {
      let [side, align] = anchor.split(" ");
      if (!align) {
        align = includes(block$2, side) ? "start" : includes(inline$1, side) ? "top" : "center";
      }
      return {
        side: toPhysical(side, isRtl),
        align: toPhysical(align, isRtl)
      };
    }
    function toPhysical(str2, isRtl) {
      if (str2 === "start")
        return isRtl ? "right" : "left";
      if (str2 === "end")
        return isRtl ? "left" : "right";
      return str2;
    }
    function flipSide(anchor) {
      return {
        side: {
          center: "center",
          top: "bottom",
          bottom: "top",
          left: "right",
          right: "left"
        }[anchor.side],
        align: anchor.align
      };
    }
    function flipAlign(anchor) {
      return {
        side: anchor.side,
        align: {
          center: "center",
          top: "bottom",
          bottom: "top",
          left: "right",
          right: "left"
        }[anchor.align]
      };
    }
    function flipCorner(anchor) {
      return {
        side: anchor.align,
        align: anchor.side
      };
    }
    function getAxis(anchor) {
      return includes(block$2, anchor.side) ? "y" : "x";
    }
    class Box {
      constructor(_ref) {
        let {
          x: x2,
          y,
          width,
          height
        } = _ref;
        this.x = x2;
        this.y = y;
        this.width = width;
        this.height = height;
      }
      get top() {
        return this.y;
      }
      get bottom() {
        return this.y + this.height;
      }
      get left() {
        return this.x;
      }
      get right() {
        return this.x + this.width;
      }
    }
    function getOverflow(a, b) {
      return {
        x: {
          before: Math.max(0, b.left - a.left),
          after: Math.max(0, a.right - b.right)
        },
        y: {
          before: Math.max(0, b.top - a.top),
          after: Math.max(0, a.bottom - b.bottom)
        }
      };
    }
    function getTargetBox(target2) {
      if (Array.isArray(target2)) {
        return new Box({
          x: target2[0],
          y: target2[1],
          width: 0,
          height: 0
        });
      } else {
        return target2.getBoundingClientRect();
      }
    }
    function nullifyTransforms(el2) {
      const rect2 = el2.getBoundingClientRect();
      const style = getComputedStyle(el2);
      const tx = style.transform;
      if (tx) {
        let ta, sx, sy, dx, dy;
        if (tx.startsWith("matrix3d(")) {
          ta = tx.slice(9, -1).split(/, /);
          sx = +ta[0];
          sy = +ta[5];
          dx = +ta[12];
          dy = +ta[13];
        } else if (tx.startsWith("matrix(")) {
          ta = tx.slice(7, -1).split(/, /);
          sx = +ta[0];
          sy = +ta[3];
          dx = +ta[4];
          dy = +ta[5];
        } else {
          return new Box(rect2);
        }
        const to = style.transformOrigin;
        const x2 = rect2.x - dx - (1 - sx) * parseFloat(to);
        const y = rect2.y - dy - (1 - sy) * parseFloat(to.slice(to.indexOf(" ") + 1));
        const w = sx ? rect2.width / sx : el2.offsetWidth + 1;
        const h2 = sy ? rect2.height / sy : el2.offsetHeight + 1;
        return new Box({
          x: x2,
          y,
          width: w,
          height: h2
        });
      } else {
        return new Box(rect2);
      }
    }
    function animate(el2, keyframes, options) {
      if (typeof el2.animate === "undefined")
        return {
          finished: Promise.resolve()
        };
      let animation;
      try {
        animation = el2.animate(keyframes, options);
      } catch (err) {
        return {
          finished: Promise.resolve()
        };
      }
      if (typeof animation.finished === "undefined") {
        animation.finished = new Promise((resolve2) => {
          animation.onfinish = () => {
            resolve2(animation);
          };
        });
      }
      return animation;
    }
    const handlers = /* @__PURE__ */ new WeakMap();
    function bindProps(el2, props) {
      Object.keys(props).forEach((k) => {
        var _a2;
        if (isOn(k)) {
          const name = eventName(k);
          const handler = handlers.get(el2);
          if (props[k] == null) {
            handler == null ? void 0 : handler.forEach((v) => {
              const [n, fn] = v;
              if (n === name) {
                el2.removeEventListener(name, fn);
                handler.delete(v);
              }
            });
          } else if (!handler || !((_a2 = [...handler]) == null ? void 0 : _a2.some((v) => v[0] === name && v[1] === props[k]))) {
            el2.addEventListener(name, props[k]);
            const _handler = handler || /* @__PURE__ */ new Set();
            _handler.add([name, props[k]]);
            if (!handlers.has(el2))
              handlers.set(el2, _handler);
          }
        } else {
          if (props[k] == null) {
            el2.removeAttribute(k);
          } else {
            el2.setAttribute(k, props[k]);
          }
        }
      });
    }
    function unbindProps(el2, props) {
      Object.keys(props).forEach((k) => {
        if (isOn(k)) {
          const name = eventName(k);
          const handler = handlers.get(el2);
          handler == null ? void 0 : handler.forEach((v) => {
            const [n, fn] = v;
            if (n === name) {
              el2.removeEventListener(name, fn);
              handler.delete(v);
            }
          });
        } else {
          el2.removeAttribute(k);
        }
      });
    }
    const mainTRC = 2.4;
    const Rco = 0.2126729;
    const Gco = 0.7151522;
    const Bco = 0.072175;
    const normBG = 0.55;
    const normTXT = 0.58;
    const revTXT = 0.57;
    const revBG = 0.62;
    const blkThrs = 0.03;
    const blkClmp = 1.45;
    const deltaYmin = 5e-4;
    const scaleBoW = 1.25;
    const scaleWoB = 1.25;
    const loConThresh = 0.078;
    const loConFactor = 12.82051282051282;
    const loConOffset = 0.06;
    const loClip = 1e-3;
    function APCAcontrast(text2, background) {
      const Rtxt = (text2.r / 255) ** mainTRC;
      const Gtxt = (text2.g / 255) ** mainTRC;
      const Btxt = (text2.b / 255) ** mainTRC;
      const Rbg = (background.r / 255) ** mainTRC;
      const Gbg = (background.g / 255) ** mainTRC;
      const Bbg = (background.b / 255) ** mainTRC;
      let Ytxt = Rtxt * Rco + Gtxt * Gco + Btxt * Bco;
      let Ybg = Rbg * Rco + Gbg * Gco + Bbg * Bco;
      if (Ytxt <= blkThrs)
        Ytxt += (blkThrs - Ytxt) ** blkClmp;
      if (Ybg <= blkThrs)
        Ybg += (blkThrs - Ybg) ** blkClmp;
      if (Math.abs(Ybg - Ytxt) < deltaYmin)
        return 0;
      let outputContrast;
      if (Ybg > Ytxt) {
        const SAPC = (Ybg ** normBG - Ytxt ** normTXT) * scaleBoW;
        outputContrast = SAPC < loClip ? 0 : SAPC < loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC - loConOffset;
      } else {
        const SAPC = (Ybg ** revBG - Ytxt ** revTXT) * scaleWoB;
        outputContrast = SAPC > -loClip ? 0 : SAPC > -loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC + loConOffset;
      }
      return outputContrast * 100;
    }
    function consoleWarn(message) {
    }
    function deprecate(original, replacement) {
      replacement = Array.isArray(replacement) ? replacement.slice(0, -1).map((s) => `'${s}'`).join(", ") + ` or '${replacement.at(-1)}'` : `'${replacement}'`;
    }
    const delta$1 = 0.20689655172413793;
    const cielabForwardTransform = (t) => t > delta$1 ** 3 ? Math.cbrt(t) : t / (3 * delta$1 ** 2) + 4 / 29;
    const cielabReverseTransform = (t) => t > delta$1 ? t ** 3 : 3 * delta$1 ** 2 * (t - 4 / 29);
    function fromXYZ$1(xyz) {
      const transform2 = cielabForwardTransform;
      const transformedY = transform2(xyz[1]);
      return [116 * transformedY - 16, 500 * (transform2(xyz[0] / 0.95047) - transformedY), 200 * (transformedY - transform2(xyz[2] / 1.08883))];
    }
    function toXYZ$1(lab) {
      const transform2 = cielabReverseTransform;
      const Ln = (lab[0] + 16) / 116;
      return [transform2(Ln + lab[1] / 500) * 0.95047, transform2(Ln), transform2(Ln - lab[2] / 200) * 1.08883];
    }
    const srgbForwardMatrix = [[3.2406, -1.5372, -0.4986], [-0.9689, 1.8758, 0.0415], [0.0557, -0.204, 1.057]];
    const srgbForwardTransform = (C) => C <= 31308e-7 ? C * 12.92 : 1.055 * C ** (1 / 2.4) - 0.055;
    const srgbReverseMatrix = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, 0.1192, 0.9505]];
    const srgbReverseTransform = (C) => C <= 0.04045 ? C / 12.92 : ((C + 0.055) / 1.055) ** 2.4;
    function fromXYZ(xyz) {
      const rgb2 = Array(3);
      const transform2 = srgbForwardTransform;
      const matrix = srgbForwardMatrix;
      for (let i2 = 0; i2 < 3; ++i2) {
        rgb2[i2] = Math.round(clamp(transform2(matrix[i2][0] * xyz[0] + matrix[i2][1] * xyz[1] + matrix[i2][2] * xyz[2])) * 255);
      }
      return {
        r: rgb2[0],
        g: rgb2[1],
        b: rgb2[2]
      };
    }
    function toXYZ(_ref) {
      let {
        r: r2,
        g: g2,
        b
      } = _ref;
      const xyz = [0, 0, 0];
      const transform2 = srgbReverseTransform;
      const matrix = srgbReverseMatrix;
      r2 = transform2(r2 / 255);
      g2 = transform2(g2 / 255);
      b = transform2(b / 255);
      for (let i2 = 0; i2 < 3; ++i2) {
        xyz[i2] = matrix[i2][0] * r2 + matrix[i2][1] * g2 + matrix[i2][2] * b;
      }
      return xyz;
    }
    function isCssColor(color) {
      return !!color && /^(#|var\(--|(rgb|hsl)a?\()/.test(color);
    }
    function isParsableColor(color) {
      return isCssColor(color) && !/^((rgb|hsl)a?\()?var\(--/.test(color);
    }
    const cssColorRe = /^(?<fn>(?:rgb|hsl)a?)\((?<values>.+)\)/;
    const mappers = {
      rgb: (r2, g2, b, a) => ({
        r: r2,
        g: g2,
        b,
        a
      }),
      rgba: (r2, g2, b, a) => ({
        r: r2,
        g: g2,
        b,
        a
      }),
      hsl: (h2, s, l, a) => HSLtoRGB({
        h: h2,
        s,
        l,
        a
      }),
      hsla: (h2, s, l, a) => HSLtoRGB({
        h: h2,
        s,
        l,
        a
      }),
      hsv: (h2, s, v, a) => HSVtoRGB({
        h: h2,
        s,
        v,
        a
      }),
      hsva: (h2, s, v, a) => HSVtoRGB({
        h: h2,
        s,
        v,
        a
      })
    };
    function parseColor(color) {
      if (typeof color === "number") {
        return {
          r: (color & 16711680) >> 16,
          g: (color & 65280) >> 8,
          b: color & 255
        };
      } else if (typeof color === "string" && cssColorRe.test(color)) {
        const {
          groups
        } = color.match(cssColorRe);
        const {
          fn,
          values
        } = groups;
        const realValues = values.split(/,\s*/).map((v) => {
          if (v.endsWith("%") && ["hsl", "hsla", "hsv", "hsva"].includes(fn)) {
            return parseFloat(v) / 100;
          } else {
            return parseFloat(v);
          }
        });
        return mappers[fn](...realValues);
      } else if (typeof color === "string") {
        let hex2 = color.startsWith("#") ? color.slice(1) : color;
        if ([3, 4].includes(hex2.length)) {
          hex2 = hex2.split("").map((char) => char + char).join("");
        } else if (![6, 8].includes(hex2.length))
          ;
        return HexToRGB(hex2);
      } else if (typeof color === "object") {
        if (has$2(color, ["r", "g", "b"])) {
          return color;
        } else if (has$2(color, ["h", "s", "l"])) {
          return HSVtoRGB(HSLtoHSV(color));
        } else if (has$2(color, ["h", "s", "v"])) {
          return HSVtoRGB(color);
        }
      }
      throw new TypeError(`Invalid color: ${color == null ? color : String(color) || color.constructor.name}
Expected #hex, #hexa, rgb(), rgba(), hsl(), hsla(), object or number`);
    }
    function HSVtoRGB(hsva) {
      const {
        h: h2,
        s,
        v,
        a
      } = hsva;
      const f = (n) => {
        const k = (n + h2 / 60) % 6;
        return v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
      };
      const rgb2 = [f(5), f(3), f(1)].map((v2) => Math.round(v2 * 255));
      return {
        r: rgb2[0],
        g: rgb2[1],
        b: rgb2[2],
        a
      };
    }
    function HSLtoRGB(hsla2) {
      return HSVtoRGB(HSLtoHSV(hsla2));
    }
    function RGBtoHSV(rgba2) {
      if (!rgba2)
        return {
          h: 0,
          s: 1,
          v: 1,
          a: 1
        };
      const r2 = rgba2.r / 255;
      const g2 = rgba2.g / 255;
      const b = rgba2.b / 255;
      const max = Math.max(r2, g2, b);
      const min = Math.min(r2, g2, b);
      let h2 = 0;
      if (max !== min) {
        if (max === r2) {
          h2 = 60 * (0 + (g2 - b) / (max - min));
        } else if (max === g2) {
          h2 = 60 * (2 + (b - r2) / (max - min));
        } else if (max === b) {
          h2 = 60 * (4 + (r2 - g2) / (max - min));
        }
      }
      if (h2 < 0)
        h2 = h2 + 360;
      const s = max === 0 ? 0 : (max - min) / max;
      const hsv = [h2, s, max];
      return {
        h: hsv[0],
        s: hsv[1],
        v: hsv[2],
        a: rgba2.a
      };
    }
    function HSVtoHSL(hsva) {
      const {
        h: h2,
        s,
        v,
        a
      } = hsva;
      const l = v - v * s / 2;
      const sprime = l === 1 || l === 0 ? 0 : (v - l) / Math.min(l, 1 - l);
      return {
        h: h2,
        s: sprime,
        l,
        a
      };
    }
    function HSLtoHSV(hsl2) {
      const {
        h: h2,
        s,
        l,
        a
      } = hsl2;
      const v = l + s * Math.min(l, 1 - l);
      const sprime = v === 0 ? 0 : 2 - 2 * l / v;
      return {
        h: h2,
        s: sprime,
        v,
        a
      };
    }
    function RGBtoCSS(_ref) {
      let {
        r: r2,
        g: g2,
        b,
        a
      } = _ref;
      return a === void 0 ? `rgb(${r2}, ${g2}, ${b})` : `rgba(${r2}, ${g2}, ${b}, ${a})`;
    }
    function HSVtoCSS(hsva) {
      return RGBtoCSS(HSVtoRGB(hsva));
    }
    function toHex(v) {
      const h2 = Math.round(v).toString(16);
      return ("00".substr(0, 2 - h2.length) + h2).toUpperCase();
    }
    function RGBtoHex(_ref2) {
      let {
        r: r2,
        g: g2,
        b,
        a
      } = _ref2;
      return `#${[toHex(r2), toHex(g2), toHex(b), a !== void 0 ? toHex(Math.round(a * 255)) : ""].join("")}`;
    }
    function HexToRGB(hex2) {
      hex2 = parseHex(hex2);
      let [r2, g2, b, a] = chunk(hex2, 2).map((c) => parseInt(c, 16));
      a = a === void 0 ? a : a / 255;
      return {
        r: r2,
        g: g2,
        b,
        a
      };
    }
    function HexToHSV(hex2) {
      const rgb2 = HexToRGB(hex2);
      return RGBtoHSV(rgb2);
    }
    function HSVtoHex(hsva) {
      return RGBtoHex(HSVtoRGB(hsva));
    }
    function parseHex(hex2) {
      if (hex2.startsWith("#")) {
        hex2 = hex2.slice(1);
      }
      hex2 = hex2.replace(/([^0-9a-f])/gi, "F");
      if (hex2.length === 3 || hex2.length === 4) {
        hex2 = hex2.split("").map((x2) => x2 + x2).join("");
      }
      if (hex2.length !== 6) {
        hex2 = padEnd(padEnd(hex2, 6), 8, "F");
      }
      return hex2;
    }
    function lighten(value, amount) {
      const lab = fromXYZ$1(toXYZ(value));
      lab[0] = lab[0] + amount * 10;
      return fromXYZ(toXYZ$1(lab));
    }
    function darken(value, amount) {
      const lab = fromXYZ$1(toXYZ(value));
      lab[0] = lab[0] - amount * 10;
      return fromXYZ(toXYZ$1(lab));
    }
    function getLuma(color) {
      const rgb2 = parseColor(color);
      return toXYZ(rgb2)[1];
    }
    function getContrast(first, second) {
      const l1 = getLuma(first);
      const l2 = getLuma(second);
      const light = Math.max(l1, l2);
      const dark = Math.min(l1, l2);
      return (light + 0.05) / (dark + 0.05);
    }
    function getForeground(color) {
      const blackContrast = Math.abs(APCAcontrast(parseColor(0), parseColor(color)));
      const whiteContrast = Math.abs(APCAcontrast(parseColor(16777215), parseColor(color)));
      return whiteContrast > Math.min(blackContrast, 50) ? "#fff" : "#000";
    }
    function getCurrentInstance(name, message) {
      const vm = getCurrentInstance$1();
      if (!vm) {
        throw new Error(`[Vuetify] ${name} ${message || "must be called from inside a setup function"}`);
      }
      return vm;
    }
    function getCurrentInstanceName() {
      let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "composables";
      const vm = getCurrentInstance(name).type;
      return toKebabCase((vm == null ? void 0 : vm.aliasName) || (vm == null ? void 0 : vm.name));
    }
    let _uid = 0;
    let _map = /* @__PURE__ */ new WeakMap();
    function getUid() {
      const vm = getCurrentInstance("getUid");
      if (_map.has(vm))
        return _map.get(vm);
      else {
        const uid2 = _uid++;
        _map.set(vm, uid2);
        return uid2;
      }
    }
    getUid.reset = () => {
      _uid = 0;
      _map = /* @__PURE__ */ new WeakMap();
    };
    function injectSelf(key) {
      let vm = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstance("injectSelf");
      const {
        provides
      } = vm;
      if (provides && key in provides) {
        return provides[key];
      }
      return void 0;
    }
    const DefaultsSymbol = Symbol.for("vuetify:defaults");
    function createDefaults(options) {
      return ref$1(options);
    }
    function injectDefaults() {
      const defaults2 = inject$1(DefaultsSymbol);
      if (!defaults2)
        throw new Error("[Vuetify] Could not find defaults instance");
      return defaults2;
    }
    function provideDefaults(defaults2, options) {
      const injectedDefaults = injectDefaults();
      const providedDefaults = ref$1(defaults2);
      const newDefaults = computed(() => {
        const disabled = unref(options == null ? void 0 : options.disabled);
        if (disabled)
          return injectedDefaults.value;
        const scoped = unref(options == null ? void 0 : options.scoped);
        const reset = unref(options == null ? void 0 : options.reset);
        const root = unref(options == null ? void 0 : options.root);
        if (providedDefaults.value == null && !(scoped || reset || root))
          return injectedDefaults.value;
        let properties2 = mergeDeep(providedDefaults.value, {
          prev: injectedDefaults.value
        });
        if (scoped)
          return properties2;
        if (reset || root) {
          const len = Number(reset || Infinity);
          for (let i2 = 0; i2 <= len; i2++) {
            if (!properties2 || !("prev" in properties2)) {
              break;
            }
            properties2 = properties2.prev;
          }
          if (properties2 && typeof root === "string" && root in properties2) {
            properties2 = mergeDeep(mergeDeep(properties2, {
              prev: properties2
            }), properties2[root]);
          }
          return properties2;
        }
        return properties2.prev ? mergeDeep(properties2.prev, properties2) : properties2;
      });
      provide(DefaultsSymbol, newDefaults);
      return newDefaults;
    }
    function propIsDefined(vnode, prop2) {
      var _a2, _b;
      return typeof ((_a2 = vnode.props) == null ? void 0 : _a2[prop2]) !== "undefined" || typeof ((_b = vnode.props) == null ? void 0 : _b[toKebabCase(prop2)]) !== "undefined";
    }
    function internalUseDefaults() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let name = arguments.length > 1 ? arguments[1] : void 0;
      let defaults2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : injectDefaults();
      const vm = getCurrentInstance("useDefaults");
      name = name ?? vm.type.name ?? vm.type.__name;
      if (!name) {
        throw new Error("[Vuetify] Could not determine component name");
      }
      const componentDefaults = computed(() => {
        var _a2;
        return (_a2 = defaults2.value) == null ? void 0 : _a2[props._as ?? name];
      });
      const _props = new Proxy(props, {
        get(target2, prop2) {
          var _a2, _b, _c, _d, _e, _f, _g;
          const propValue = Reflect.get(target2, prop2);
          if (prop2 === "class" || prop2 === "style") {
            return [(_a2 = componentDefaults.value) == null ? void 0 : _a2[prop2], propValue].filter((v) => v != null);
          } else if (typeof prop2 === "string" && !propIsDefined(vm.vnode, prop2)) {
            return ((_b = componentDefaults.value) == null ? void 0 : _b[prop2]) !== void 0 ? (_c = componentDefaults.value) == null ? void 0 : _c[prop2] : ((_e = (_d = defaults2.value) == null ? void 0 : _d.global) == null ? void 0 : _e[prop2]) !== void 0 ? (_g = (_f = defaults2.value) == null ? void 0 : _f.global) == null ? void 0 : _g[prop2] : propValue;
          }
          return propValue;
        }
      });
      const _subcomponentDefaults = shallowRef();
      watchEffect(() => {
        if (componentDefaults.value) {
          const subComponents = Object.entries(componentDefaults.value).filter((_ref) => {
            let [key] = _ref;
            return key.startsWith(key[0].toUpperCase());
          });
          _subcomponentDefaults.value = subComponents.length ? Object.fromEntries(subComponents) : void 0;
        } else {
          _subcomponentDefaults.value = void 0;
        }
      });
      function provideSubDefaults() {
        const injected = injectSelf(DefaultsSymbol, vm);
        provide(DefaultsSymbol, computed(() => {
          return _subcomponentDefaults.value ? mergeDeep((injected == null ? void 0 : injected.value) ?? {}, _subcomponentDefaults.value) : injected == null ? void 0 : injected.value;
        }));
      }
      return {
        props: _props,
        provideSubDefaults
      };
    }
    function useDefaults() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let name = arguments.length > 1 ? arguments[1] : void 0;
      const {
        props: _props,
        provideSubDefaults
      } = internalUseDefaults(props, name);
      provideSubDefaults();
      return _props;
    }
    function defineComponent(options) {
      options._setup = options._setup ?? options.setup;
      if (!options.name) {
        return options;
      }
      if (options._setup) {
        options.props = propsFactory(options.props ?? {}, options.name)();
        const propKeys = Object.keys(options.props).filter((key) => key !== "class" && key !== "style");
        options.filterProps = function filterProps(props) {
          return pick(props, propKeys);
        };
        options.props._as = String;
        options.setup = function setup2(props, ctx) {
          const defaults2 = injectDefaults();
          if (!defaults2.value)
            return options._setup(props, ctx);
          const {
            props: _props,
            provideSubDefaults
          } = internalUseDefaults(props, props._as ?? options.name, defaults2);
          const setupBindings = options._setup(_props, ctx);
          provideSubDefaults();
          return setupBindings;
        };
      }
      return options;
    }
    function genericComponent() {
      let exposeDefaults = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      return (options) => (exposeDefaults ? defineComponent : defineComponent$1)(options);
    }
    function createSimpleFunctional(klass) {
      let tag = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "div";
      let name = arguments.length > 2 ? arguments[2] : void 0;
      return genericComponent()({
        name: name ?? capitalize(camelize(klass.replace(/__/g, "-"))),
        props: {
          tag: {
            type: String,
            default: tag
          },
          ...makeComponentProps()
        },
        setup(props, _ref) {
          let {
            slots
          } = _ref;
          return () => {
            var _a2;
            return h(props.tag, {
              class: [klass, props.class],
              style: props.style
            }, (_a2 = slots.default) == null ? void 0 : _a2.call(slots));
          };
        }
      });
    }
    function attachedRoot(node) {
      if (typeof node.getRootNode !== "function") {
        while (node.parentNode)
          node = node.parentNode;
        if (node !== document)
          return null;
        return document;
      }
      const root = node.getRootNode();
      if (root !== document && root.getRootNode({
        composed: true
      }) !== document)
        return null;
      return root;
    }
    const standardEasing = "cubic-bezier(0.4, 0, 0.2, 1)";
    const deceleratedEasing = "cubic-bezier(0.0, 0, 0.2, 1)";
    const acceleratedEasing = "cubic-bezier(0.4, 0, 1, 1)";
    function getScrollParent(el2) {
      let includeHidden = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      while (el2) {
        if (includeHidden ? isPotentiallyScrollable(el2) : hasScrollbar(el2))
          return el2;
        el2 = el2.parentElement;
      }
      return document.scrollingElement;
    }
    function getScrollParents(el2, stopAt) {
      const elements = [];
      if (stopAt && el2 && !stopAt.contains(el2))
        return elements;
      while (el2) {
        if (hasScrollbar(el2))
          elements.push(el2);
        if (el2 === stopAt)
          break;
        el2 = el2.parentElement;
      }
      return elements;
    }
    function hasScrollbar(el2) {
      if (!el2 || el2.nodeType !== Node.ELEMENT_NODE)
        return false;
      const style = window.getComputedStyle(el2);
      return style.overflowY === "scroll" || style.overflowY === "auto" && el2.scrollHeight > el2.clientHeight;
    }
    function isPotentiallyScrollable(el2) {
      if (!el2 || el2.nodeType !== Node.ELEMENT_NODE)
        return false;
      const style = window.getComputedStyle(el2);
      return ["scroll", "auto"].includes(style.overflowY);
    }
    function isFixedPosition(el2) {
      while (el2) {
        if (window.getComputedStyle(el2).position === "fixed") {
          return true;
        }
        el2 = el2.offsetParent;
      }
      return false;
    }
    function useRender(render) {
      const vm = getCurrentInstance("useRender");
      vm.render = render;
    }
    function useResizeObserver$1(callback) {
      let box = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "content";
      const resizeRef = templateRef();
      const contentRect = ref$1();
      if (IN_BROWSER) {
        const observer = new ResizeObserver((entries) => {
          callback == null ? void 0 : callback(entries, observer);
          if (!entries.length)
            return;
          if (box === "content") {
            contentRect.value = entries[0].contentRect;
          } else {
            contentRect.value = entries[0].target.getBoundingClientRect();
          }
        });
        onBeforeUnmount(() => {
          observer.disconnect();
        });
        watch(() => resizeRef.el, (newValue, oldValue) => {
          if (oldValue) {
            observer.unobserve(oldValue);
            contentRect.value = void 0;
          }
          if (newValue)
            observer.observe(newValue);
        }, {
          flush: "post"
        });
      }
      return {
        resizeRef,
        contentRect: readonly(contentRect)
      };
    }
    const VuetifyLayoutKey = Symbol.for("vuetify:layout");
    const VuetifyLayoutItemKey = Symbol.for("vuetify:layout-item");
    const ROOT_ZINDEX = 1e3;
    const makeLayoutProps = propsFactory({
      overlaps: {
        type: Array,
        default: () => []
      },
      fullHeight: Boolean
    }, "layout");
    const makeLayoutItemProps = propsFactory({
      name: {
        type: String
      },
      order: {
        type: [Number, String],
        default: 0
      },
      absolute: Boolean
    }, "layout-item");
    function useLayout() {
      const layout = inject$1(VuetifyLayoutKey);
      if (!layout)
        throw new Error("[Vuetify] Could not find injected layout");
      const layoutIsReady = nextTick();
      return {
        layoutIsReady,
        getLayoutItem: layout.getLayoutItem,
        mainRect: layout.mainRect,
        mainStyles: layout.mainStyles
      };
    }
    function useLayoutItem(options) {
      const layout = inject$1(VuetifyLayoutKey);
      if (!layout)
        throw new Error("[Vuetify] Could not find injected layout");
      const id2 = options.id ?? `layout-item-${getUid()}`;
      const vm = getCurrentInstance("useLayoutItem");
      provide(VuetifyLayoutItemKey, {
        id: id2
      });
      const isKeptAlive = shallowRef(false);
      onDeactivated(() => isKeptAlive.value = true);
      onActivated(() => isKeptAlive.value = false);
      const layoutIsReady = nextTick();
      const {
        layoutItemStyles,
        layoutItemScrimStyles
      } = layout.register(vm, {
        ...options,
        active: computed(() => isKeptAlive.value ? false : options.active.value),
        id: id2
      });
      onBeforeUnmount(() => layout.unregister(id2));
      return {
        layoutItemStyles,
        layoutRect: layout.layoutRect,
        layoutItemScrimStyles,
        layoutIsReady
      };
    }
    const generateLayers = (layout, positions, layoutSizes, activeItems) => {
      let previousLayer = {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      };
      const layers = [{
        id: "",
        layer: {
          ...previousLayer
        }
      }];
      for (const id2 of layout) {
        const position = positions.get(id2);
        const amount = layoutSizes.get(id2);
        const active = activeItems.get(id2);
        if (!position || !amount || !active)
          continue;
        const layer = {
          ...previousLayer,
          [position.value]: parseInt(previousLayer[position.value], 10) + (active.value ? parseInt(amount.value, 10) : 0)
        };
        layers.push({
          id: id2,
          layer
        });
        previousLayer = layer;
      }
      return layers;
    };
    function createLayout(props) {
      const parentLayout = inject$1(VuetifyLayoutKey, null);
      const rootZIndex = computed(() => parentLayout ? parentLayout.rootZIndex.value - 100 : ROOT_ZINDEX);
      const registered = ref$1([]);
      const positions = reactive(/* @__PURE__ */ new Map());
      const layoutSizes = reactive(/* @__PURE__ */ new Map());
      const priorities = reactive(/* @__PURE__ */ new Map());
      const activeItems = reactive(/* @__PURE__ */ new Map());
      const disabledTransitions = reactive(/* @__PURE__ */ new Map());
      const {
        resizeRef,
        contentRect: layoutRect
      } = useResizeObserver$1();
      const layers = eagerComputed(() => {
        const uniquePriorities = [...new Set([...priorities.values()].map((p2) => p2.value))].sort((a, b) => a - b);
        const layout = [];
        for (const p2 of uniquePriorities) {
          const items3 = registered.value.filter((id2) => {
            var _a2;
            return ((_a2 = priorities.get(id2)) == null ? void 0 : _a2.value) === p2;
          });
          layout.push(...items3);
        }
        return generateLayers(layout, positions, layoutSizes, activeItems);
      });
      const transitionsEnabled = computed(() => {
        return !Array.from(disabledTransitions.values()).some((ref2) => ref2.value);
      });
      const mainRect = computed(() => {
        return layers.value[layers.value.length - 1].layer;
      });
      const mainStyles = computed(() => {
        return {
          "--v-layout-left": convertToUnit(mainRect.value.left),
          "--v-layout-right": convertToUnit(mainRect.value.right),
          "--v-layout-top": convertToUnit(mainRect.value.top),
          "--v-layout-bottom": convertToUnit(mainRect.value.bottom),
          ...transitionsEnabled.value ? void 0 : {
            transition: "none"
          }
        };
      });
      const items2 = eagerComputed(() => {
        return layers.value.slice(1).map((_ref, index) => {
          let {
            id: id2
          } = _ref;
          const {
            layer
          } = layers.value[index];
          const size2 = layoutSizes.get(id2);
          const position = positions.get(id2);
          return {
            id: id2,
            ...layer,
            size: Number(size2.value),
            position: position.value
          };
        });
      });
      const getLayoutItem = (id2) => {
        return items2.value.find((item) => item.id === id2);
      };
      const rootVm = getCurrentInstance("createLayout");
      const layoutIsReady = nextTick();
      provide(VuetifyLayoutKey, {
        register: (vm, _ref2) => {
          let {
            id: id2,
            order: order2,
            position,
            layoutSize,
            elementSize,
            active,
            disableTransitions,
            absolute
          } = _ref2;
          priorities.set(id2, order2);
          positions.set(id2, position);
          layoutSizes.set(id2, layoutSize);
          activeItems.set(id2, active);
          disableTransitions && disabledTransitions.set(id2, disableTransitions);
          const instances = findChildrenWithProvide(VuetifyLayoutItemKey, rootVm == null ? void 0 : rootVm.vnode);
          const instanceIndex = instances.indexOf(vm);
          if (instanceIndex > -1)
            registered.value.splice(instanceIndex, 0, id2);
          else
            registered.value.push(id2);
          const index = computed(() => items2.value.findIndex((i2) => i2.id === id2));
          const zIndex = computed(() => rootZIndex.value + layers.value.length * 2 - index.value * 2);
          const layoutItemStyles = computed(() => {
            const isHorizontal = position.value === "left" || position.value === "right";
            const isOppositeHorizontal = position.value === "right";
            const isOppositeVertical = position.value === "bottom";
            const size2 = elementSize.value ?? layoutSize.value;
            const unit = size2 === 0 ? "%" : "px";
            const styles = {
              [position.value]: 0,
              zIndex: zIndex.value,
              transform: `translate${isHorizontal ? "X" : "Y"}(${(active.value ? 0 : -(size2 === 0 ? 100 : size2)) * (isOppositeHorizontal || isOppositeVertical ? -1 : 1)}${unit})`,
              position: absolute.value || rootZIndex.value !== ROOT_ZINDEX ? "absolute" : "fixed",
              ...transitionsEnabled.value ? void 0 : {
                transition: "none"
              }
            };
            if (index.value < 0)
              throw new Error(`Layout item "${id2}" is missing`);
            const item = items2.value[index.value];
            if (!item)
              throw new Error(`[Vuetify] Could not find layout item "${id2}"`);
            return {
              ...styles,
              height: isHorizontal ? `calc(100% - ${item.top}px - ${item.bottom}px)` : elementSize.value ? `${elementSize.value}px` : void 0,
              left: isOppositeHorizontal ? void 0 : `${item.left}px`,
              right: isOppositeHorizontal ? `${item.right}px` : void 0,
              top: position.value !== "bottom" ? `${item.top}px` : void 0,
              bottom: position.value !== "top" ? `${item.bottom}px` : void 0,
              width: !isHorizontal ? `calc(100% - ${item.left}px - ${item.right}px)` : elementSize.value ? `${elementSize.value}px` : void 0
            };
          });
          const layoutItemScrimStyles = computed(() => ({
            zIndex: zIndex.value - 1
          }));
          return {
            layoutItemStyles,
            layoutItemScrimStyles,
            zIndex
          };
        },
        unregister: (id2) => {
          priorities.delete(id2);
          positions.delete(id2);
          layoutSizes.delete(id2);
          activeItems.delete(id2);
          disabledTransitions.delete(id2);
          registered.value = registered.value.filter((v) => v !== id2);
        },
        mainRect,
        mainStyles,
        getLayoutItem,
        items: items2,
        layoutRect,
        rootZIndex,
        layoutIsReady
      });
      const layoutClasses = computed(() => ["v-layout", {
        "v-layout--full-height": props.fullHeight
      }]);
      const layoutStyles = computed(() => ({
        zIndex: parentLayout ? rootZIndex.value : void 0,
        position: parentLayout ? "relative" : void 0,
        overflow: parentLayout ? "hidden" : void 0
      }));
      return {
        layoutClasses,
        layoutStyles,
        getLayoutItem,
        items: items2,
        layoutRect,
        layoutIsReady,
        layoutRef: resizeRef
      };
    }
    function useToggleScope(source2, fn) {
      let scope2;
      function start() {
        scope2 = effectScope();
        scope2.run(() => fn.length ? fn(() => {
          scope2 == null ? void 0 : scope2.stop();
          start();
        }) : fn());
      }
      watch(source2, (active) => {
        if (active && !scope2) {
          start();
        } else if (!active) {
          scope2 == null ? void 0 : scope2.stop();
          scope2 = void 0;
        }
      }, {
        immediate: true
      });
      onScopeDispose(() => {
        scope2 == null ? void 0 : scope2.stop();
      });
    }
    function useProxiedModel(props, prop2, defaultValue) {
      let transformIn = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : (v) => v;
      let transformOut = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : (v) => v;
      const vm = getCurrentInstance("useProxiedModel");
      const internal = ref$1(props[prop2] !== void 0 ? props[prop2] : defaultValue);
      const kebabProp = toKebabCase(prop2);
      const checkKebab = kebabProp !== prop2;
      const isControlled = checkKebab ? computed(() => {
        var _a2, _b, _c, _d;
        void props[prop2];
        return !!((((_a2 = vm.vnode.props) == null ? void 0 : _a2.hasOwnProperty(prop2)) || ((_b = vm.vnode.props) == null ? void 0 : _b.hasOwnProperty(kebabProp))) && (((_c = vm.vnode.props) == null ? void 0 : _c.hasOwnProperty(`onUpdate:${prop2}`)) || ((_d = vm.vnode.props) == null ? void 0 : _d.hasOwnProperty(`onUpdate:${kebabProp}`))));
      }) : computed(() => {
        var _a2, _b;
        void props[prop2];
        return !!(((_a2 = vm.vnode.props) == null ? void 0 : _a2.hasOwnProperty(prop2)) && ((_b = vm.vnode.props) == null ? void 0 : _b.hasOwnProperty(`onUpdate:${prop2}`)));
      });
      useToggleScope(() => !isControlled.value, () => {
        watch(() => props[prop2], (val) => {
          internal.value = val;
        });
      });
      const model = computed({
        get() {
          const externalValue = props[prop2];
          return transformIn(isControlled.value ? externalValue : internal.value);
        },
        set(internalValue) {
          const newValue = transformOut(internalValue);
          const value = toRaw(isControlled.value ? props[prop2] : internal.value);
          if (value === newValue || transformIn(value) === internalValue) {
            return;
          }
          internal.value = newValue;
          vm == null ? void 0 : vm.emit(`update:${prop2}`, newValue);
        }
      });
      Object.defineProperty(model, "externalValue", {
        get: () => isControlled.value ? props[prop2] : internal.value
      });
      return model;
    }
    const en$2 = {
      badge: "Badge",
      open: "Open",
      close: "Close",
      dismiss: "Dismiss",
      confirmEdit: {
        ok: "OK",
        cancel: "Cancel"
      },
      dataIterator: {
        noResultsText: "No matching records found",
        loadingText: "Loading items..."
      },
      dataTable: {
        itemsPerPageText: "Rows per page:",
        ariaLabel: {
          sortDescending: "Sorted descending.",
          sortAscending: "Sorted ascending.",
          sortNone: "Not sorted.",
          activateNone: "Activate to remove sorting.",
          activateDescending: "Activate to sort descending.",
          activateAscending: "Activate to sort ascending."
        },
        sortBy: "Sort by"
      },
      dataFooter: {
        itemsPerPageText: "Items per page:",
        itemsPerPageAll: "All",
        nextPage: "Next page",
        prevPage: "Previous page",
        firstPage: "First page",
        lastPage: "Last page",
        pageText: "{0}-{1} of {2}"
      },
      dateRangeInput: {
        divider: "to"
      },
      datePicker: {
        itemsSelected: "{0} selected",
        range: {
          title: "Select dates",
          header: "Enter dates"
        },
        title: "Select date",
        header: "Enter date",
        input: {
          placeholder: "Enter date"
        }
      },
      noDataText: "No data available",
      carousel: {
        prev: "Previous visual",
        next: "Next visual",
        ariaLabel: {
          delimiter: "Carousel slide {0} of {1}"
        }
      },
      calendar: {
        moreEvents: "{0} more",
        today: "Today"
      },
      input: {
        clear: "Clear {0}",
        prependAction: "{0} prepended action",
        appendAction: "{0} appended action",
        otp: "Please enter OTP character {0}"
      },
      fileInput: {
        counter: "{0} files",
        counterSize: "{0} files ({1} in total)"
      },
      timePicker: {
        am: "AM",
        pm: "PM",
        title: "Select Time"
      },
      pagination: {
        ariaLabel: {
          root: "Pagination Navigation",
          next: "Next page",
          previous: "Previous page",
          page: "Go to page {0}",
          currentPage: "Page {0}, Current page",
          first: "First page",
          last: "Last page"
        }
      },
      stepper: {
        next: "Next",
        prev: "Previous"
      },
      rating: {
        ariaLabel: {
          item: "Rating {0} of {1}"
        }
      },
      loading: "Loading...",
      infiniteScroll: {
        loadMore: "Load more",
        empty: "No more"
      }
    };
    const LANG_PREFIX = "$vuetify.";
    const replace = (str2, params) => {
      return str2.replace(/\{(\d+)\}/g, (match, index) => {
        return String(params[+index]);
      });
    };
    const createTranslateFunction = (current2, fallback, messages) => {
      return function(key) {
        for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          params[_key - 1] = arguments[_key];
        }
        if (!key.startsWith(LANG_PREFIX)) {
          return replace(key, params);
        }
        const shortKey = key.replace(LANG_PREFIX, "");
        const currentLocale = current2.value && messages.value[current2.value];
        const fallbackLocale = fallback.value && messages.value[fallback.value];
        let str2 = getObjectValueByPath(currentLocale, shortKey, null);
        if (!str2) {
          consoleWarn(`Translation key "${key}" not found in "${current2.value}", trying fallback locale`);
          str2 = getObjectValueByPath(fallbackLocale, shortKey, null);
        }
        if (!str2) {
          str2 = key;
        }
        if (typeof str2 !== "string") {
          str2 = key;
        }
        return replace(str2, params);
      };
    };
    function createNumberFunction(current2, fallback) {
      return (value, options) => {
        const numberFormat = new Intl.NumberFormat([current2.value, fallback.value], options);
        return numberFormat.format(value);
      };
    }
    function useProvided(props, prop2, provided) {
      const internal = useProxiedModel(props, prop2, props[prop2] ?? provided.value);
      internal.value = props[prop2] ?? provided.value;
      watch(provided, (v) => {
        if (props[prop2] == null) {
          internal.value = provided.value;
        }
      });
      return internal;
    }
    function createProvideFunction(state) {
      return (props) => {
        const current2 = useProvided(props, "locale", state.current);
        const fallback = useProvided(props, "fallback", state.fallback);
        const messages = useProvided(props, "messages", state.messages);
        return {
          name: "vuetify",
          current: current2,
          fallback,
          messages,
          t: createTranslateFunction(current2, fallback, messages),
          n: createNumberFunction(current2, fallback),
          provide: createProvideFunction({
            current: current2,
            fallback,
            messages
          })
        };
      };
    }
    function createVuetifyAdapter(options) {
      const current2 = shallowRef((options == null ? void 0 : options.locale) ?? "en");
      const fallback = shallowRef((options == null ? void 0 : options.fallback) ?? "en");
      const messages = ref$1({
        en: en$2,
        ...options == null ? void 0 : options.messages
      });
      return {
        name: "vuetify",
        current: current2,
        fallback,
        messages,
        t: createTranslateFunction(current2, fallback, messages),
        n: createNumberFunction(current2, fallback),
        provide: createProvideFunction({
          current: current2,
          fallback,
          messages
        })
      };
    }
    const LocaleSymbol = Symbol.for("vuetify:locale");
    function isLocaleInstance(obj) {
      return obj.name != null;
    }
    function createLocale(options) {
      const i18n2 = (options == null ? void 0 : options.adapter) && isLocaleInstance(options == null ? void 0 : options.adapter) ? options == null ? void 0 : options.adapter : createVuetifyAdapter(options);
      const rtl = createRtl(i18n2, options);
      return {
        ...i18n2,
        ...rtl
      };
    }
    function useLocale() {
      const locale = inject$1(LocaleSymbol);
      if (!locale)
        throw new Error("[Vuetify] Could not find injected locale instance");
      return locale;
    }
    function genDefaults$3() {
      return {
        af: false,
        ar: true,
        bg: false,
        ca: false,
        ckb: false,
        cs: false,
        de: false,
        el: false,
        en: false,
        es: false,
        et: false,
        fa: true,
        fi: false,
        fr: false,
        hr: false,
        hu: false,
        he: true,
        id: false,
        it: false,
        ja: false,
        km: false,
        ko: false,
        lv: false,
        lt: false,
        nl: false,
        no: false,
        pl: false,
        pt: false,
        ro: false,
        ru: false,
        sk: false,
        sl: false,
        srCyrl: false,
        srLatn: false,
        sv: false,
        th: false,
        tr: false,
        az: false,
        uk: false,
        vi: false,
        zhHans: false,
        zhHant: false
      };
    }
    function createRtl(i18n2, options) {
      const rtl = ref$1((options == null ? void 0 : options.rtl) ?? genDefaults$3());
      const isRtl = computed(() => rtl.value[i18n2.current.value] ?? false);
      return {
        isRtl,
        rtl,
        rtlClasses: computed(() => `v-locale--is-${isRtl.value ? "rtl" : "ltr"}`)
      };
    }
    function useRtl() {
      const locale = inject$1(LocaleSymbol);
      if (!locale)
        throw new Error("[Vuetify] Could not find injected rtl instance");
      return {
        isRtl: locale.isRtl,
        rtlClasses: locale.rtlClasses
      };
    }
    const ThemeSymbol = Symbol.for("vuetify:theme");
    const makeThemeProps = propsFactory({
      theme: String
    }, "theme");
    function genDefaults$2() {
      return {
        defaultTheme: "light",
        variations: {
          colors: [],
          lighten: 0,
          darken: 0
        },
        themes: {
          light: {
            dark: false,
            colors: {
              background: "#FFFFFF",
              surface: "#FFFFFF",
              "surface-bright": "#FFFFFF",
              "surface-light": "#EEEEEE",
              "surface-variant": "#424242",
              "on-surface-variant": "#EEEEEE",
              primary: "#1867C0",
              "primary-darken-1": "#1F5592",
              secondary: "#48A9A6",
              "secondary-darken-1": "#018786",
              error: "#B00020",
              info: "#2196F3",
              success: "#4CAF50",
              warning: "#FB8C00"
            },
            variables: {
              "border-color": "#000000",
              "border-opacity": 0.12,
              "high-emphasis-opacity": 0.87,
              "medium-emphasis-opacity": 0.6,
              "disabled-opacity": 0.38,
              "idle-opacity": 0.04,
              "hover-opacity": 0.04,
              "focus-opacity": 0.12,
              "selected-opacity": 0.08,
              "activated-opacity": 0.12,
              "pressed-opacity": 0.12,
              "dragged-opacity": 0.08,
              "theme-kbd": "#212529",
              "theme-on-kbd": "#FFFFFF",
              "theme-code": "#F5F5F5",
              "theme-on-code": "#000000"
            }
          },
          dark: {
            dark: true,
            colors: {
              background: "#121212",
              surface: "#212121",
              "surface-bright": "#ccbfd6",
              "surface-light": "#424242",
              "surface-variant": "#a3a3a3",
              "on-surface-variant": "#424242",
              primary: "#2196F3",
              "primary-darken-1": "#277CC1",
              secondary: "#54B6B2",
              "secondary-darken-1": "#48A9A6",
              error: "#CF6679",
              info: "#2196F3",
              success: "#4CAF50",
              warning: "#FB8C00"
            },
            variables: {
              "border-color": "#FFFFFF",
              "border-opacity": 0.12,
              "high-emphasis-opacity": 1,
              "medium-emphasis-opacity": 0.7,
              "disabled-opacity": 0.5,
              "idle-opacity": 0.1,
              "hover-opacity": 0.04,
              "focus-opacity": 0.12,
              "selected-opacity": 0.08,
              "activated-opacity": 0.12,
              "pressed-opacity": 0.16,
              "dragged-opacity": 0.08,
              "theme-kbd": "#212529",
              "theme-on-kbd": "#FFFFFF",
              "theme-code": "#343434",
              "theme-on-code": "#CCCCCC"
            }
          }
        }
      };
    }
    function parseThemeOptions() {
      var _a2, _b;
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : genDefaults$2();
      const defaults2 = genDefaults$2();
      if (!options)
        return {
          ...defaults2,
          isDisabled: true
        };
      const themes = {};
      for (const [key, theme] of Object.entries(options.themes ?? {})) {
        const defaultTheme = theme.dark || key === "dark" ? (_a2 = defaults2.themes) == null ? void 0 : _a2.dark : (_b = defaults2.themes) == null ? void 0 : _b.light;
        themes[key] = mergeDeep(defaultTheme, theme);
      }
      return mergeDeep(defaults2, {
        ...options,
        themes
      });
    }
    function createTheme(options) {
      const parsedOptions = parseThemeOptions(options);
      const name = ref$1(parsedOptions.defaultTheme);
      const themes = ref$1(parsedOptions.themes);
      const computedThemes = computed(() => {
        const acc = {};
        for (const [name2, original] of Object.entries(themes.value)) {
          const theme = acc[name2] = {
            ...original,
            colors: {
              ...original.colors
            }
          };
          if (parsedOptions.variations) {
            for (const name3 of parsedOptions.variations.colors) {
              const color = theme.colors[name3];
              if (!color)
                continue;
              for (const variation of ["lighten", "darken"]) {
                const fn = variation === "lighten" ? lighten : darken;
                for (const amount of createRange(parsedOptions.variations[variation], 1)) {
                  theme.colors[`${name3}-${variation}-${amount}`] = RGBtoHex(fn(parseColor(color), amount));
                }
              }
            }
          }
          for (const color of Object.keys(theme.colors)) {
            if (/^on-[a-z]/.test(color) || theme.colors[`on-${color}`])
              continue;
            const onColor = `on-${color}`;
            const colorVal = parseColor(theme.colors[color]);
            theme.colors[onColor] = getForeground(colorVal);
          }
        }
        return acc;
      });
      const current2 = computed(() => computedThemes.value[name.value]);
      const styles = computed(() => {
        var _a2;
        const lines = [];
        if ((_a2 = current2.value) == null ? void 0 : _a2.dark) {
          createCssClass(lines, ":root", ["color-scheme: dark"]);
        }
        createCssClass(lines, ":root", genCssVariables(current2.value));
        for (const [themeName, theme] of Object.entries(computedThemes.value)) {
          createCssClass(lines, `.v-theme--${themeName}`, [`color-scheme: ${theme.dark ? "dark" : "normal"}`, ...genCssVariables(theme)]);
        }
        const bgLines = [];
        const fgLines = [];
        const colors2 = new Set(Object.values(computedThemes.value).flatMap((theme) => Object.keys(theme.colors)));
        for (const key of colors2) {
          if (/^on-[a-z]/.test(key)) {
            createCssClass(fgLines, `.${key}`, [`color: rgb(var(--v-theme-${key})) !important`]);
          } else {
            createCssClass(bgLines, `.bg-${key}`, [`--v-theme-overlay-multiplier: var(--v-theme-${key}-overlay-multiplier)`, `background-color: rgb(var(--v-theme-${key})) !important`, `color: rgb(var(--v-theme-on-${key})) !important`]);
            createCssClass(fgLines, `.text-${key}`, [`color: rgb(var(--v-theme-${key})) !important`]);
            createCssClass(fgLines, `.border-${key}`, [`--v-border-color: var(--v-theme-${key})`]);
          }
        }
        lines.push(...bgLines, ...fgLines);
        return lines.map((str2, i2) => i2 === 0 ? str2 : `    ${str2}`).join("");
      });
      function getHead() {
        return {
          style: [{
            children: styles.value,
            id: "vuetify-theme-stylesheet",
            nonce: parsedOptions.cspNonce || false
          }]
        };
      }
      function install(app2) {
        if (parsedOptions.isDisabled)
          return;
        const head = app2._context.provides.usehead;
        if (head) {
          if (head.push) {
            const entry = head.push(getHead);
            if (IN_BROWSER) {
              watch(styles, () => {
                entry.patch(getHead);
              });
            }
          } else {
            if (IN_BROWSER) {
              head.addHeadObjs(computed(getHead));
              watchEffect(() => head.updateDOM());
            } else {
              head.addHeadObjs(getHead());
            }
          }
        } else {
          let updateStyles2 = function() {
            if (typeof document !== "undefined" && !styleEl) {
              const el2 = document.createElement("style");
              el2.type = "text/css";
              el2.id = "vuetify-theme-stylesheet";
              if (parsedOptions.cspNonce)
                el2.setAttribute("nonce", parsedOptions.cspNonce);
              styleEl = el2;
              document.head.appendChild(styleEl);
            }
            if (styleEl)
              styleEl.innerHTML = styles.value;
          };
          var updateStyles = updateStyles2;
          let styleEl = IN_BROWSER ? document.getElementById("vuetify-theme-stylesheet") : null;
          if (IN_BROWSER) {
            watch(styles, updateStyles2, {
              immediate: true
            });
          } else {
            updateStyles2();
          }
        }
      }
      const themeClasses = computed(() => parsedOptions.isDisabled ? void 0 : `v-theme--${name.value}`);
      return {
        install,
        isDisabled: parsedOptions.isDisabled,
        name,
        themes,
        current: current2,
        computedThemes,
        themeClasses,
        styles,
        global: {
          name,
          current: current2
        }
      };
    }
    function provideTheme(props) {
      getCurrentInstance("provideTheme");
      const theme = inject$1(ThemeSymbol, null);
      if (!theme)
        throw new Error("Could not find Vuetify theme injection");
      const name = computed(() => {
        return props.theme ?? theme.name.value;
      });
      const current2 = computed(() => theme.themes.value[name.value]);
      const themeClasses = computed(() => theme.isDisabled ? void 0 : `v-theme--${name.value}`);
      const newTheme = {
        ...theme,
        name,
        current: current2,
        themeClasses
      };
      provide(ThemeSymbol, newTheme);
      return newTheme;
    }
    function useTheme() {
      getCurrentInstance("useTheme");
      const theme = inject$1(ThemeSymbol, null);
      if (!theme)
        throw new Error("Could not find Vuetify theme injection");
      return theme;
    }
    function createCssClass(lines, selector, content2) {
      lines.push(`${selector} {
`, ...content2.map((line) => `  ${line};
`), "}\n");
    }
    function genCssVariables(theme) {
      const lightOverlay = theme.dark ? 2 : 1;
      const darkOverlay = theme.dark ? 1 : 2;
      const variables = [];
      for (const [key, value] of Object.entries(theme.colors)) {
        const rgb2 = parseColor(value);
        variables.push(`--v-theme-${key}: ${rgb2.r},${rgb2.g},${rgb2.b}`);
        if (!key.startsWith("on-")) {
          variables.push(`--v-theme-${key}-overlay-multiplier: ${getLuma(value) > 0.18 ? lightOverlay : darkOverlay}`);
        }
      }
      for (const [key, value] of Object.entries(theme.variables)) {
        const color = typeof value === "string" && value.startsWith("#") ? parseColor(value) : void 0;
        const rgb2 = color ? `${color.r}, ${color.g}, ${color.b}` : void 0;
        variables.push(`--v-${key}: ${rgb2 ?? value}`);
      }
      return variables;
    }
    const makeVAppProps = propsFactory({
      ...makeComponentProps(),
      ...makeLayoutProps({
        fullHeight: true
      }),
      ...makeThemeProps()
    }, "VApp");
    const VApp = genericComponent()({
      name: "VApp",
      props: makeVAppProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const theme = provideTheme(props);
        const {
          layoutClasses,
          getLayoutItem,
          items: items2,
          layoutRef
        } = createLayout(props);
        const {
          rtlClasses
        } = useRtl();
        useRender(() => createVNode("div", {
          "ref": layoutRef,
          "class": ["v-application", theme.themeClasses.value, layoutClasses.value, rtlClasses.value, props.class],
          "style": [props.style]
        }, [createVNode("div", {
          "class": "v-application__wrap"
        }, [createVNode(Suspense, null, {
          default: () => {
            var _a2;
            return [createVNode(Fragment, null, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)])];
          }
        })])]));
        return {
          getLayoutItem,
          items: items2,
          theme
        };
      }
    });
    const makeTagProps = propsFactory({
      tag: {
        type: String,
        default: "div"
      }
    }, "tag");
    const makeVToolbarTitleProps = propsFactory({
      text: String,
      ...makeComponentProps(),
      ...makeTagProps()
    }, "VToolbarTitle");
    const VToolbarTitle = genericComponent()({
      name: "VToolbarTitle",
      props: makeVToolbarTitleProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        useRender(() => {
          const hasText = !!(slots.default || slots.text || props.text);
          return createVNode(props.tag, {
            "class": ["v-toolbar-title", props.class],
            "style": props.style
          }, {
            default: () => {
              var _a2;
              return [hasText && createVNode("div", {
                "class": "v-toolbar-title__placeholder"
              }, [slots.text ? slots.text() : props.text, (_a2 = slots.default) == null ? void 0 : _a2.call(slots)])];
            }
          });
        });
        return {};
      }
    });
    const makeTransitionProps$1 = propsFactory({
      disabled: Boolean,
      group: Boolean,
      hideOnLeave: Boolean,
      leaveAbsolute: Boolean,
      mode: String,
      origin: String
    }, "transition");
    function createCssTransition(name, origin, mode) {
      return genericComponent()({
        name,
        props: makeTransitionProps$1({
          mode,
          origin
        }),
        setup(props, _ref) {
          let {
            slots
          } = _ref;
          const functions = {
            onBeforeEnter(el2) {
              if (props.origin) {
                el2.style.transformOrigin = props.origin;
              }
            },
            onLeave(el2) {
              if (props.leaveAbsolute) {
                const {
                  offsetTop,
                  offsetLeft,
                  offsetWidth,
                  offsetHeight
                } = el2;
                el2._transitionInitialStyles = {
                  position: el2.style.position,
                  top: el2.style.top,
                  left: el2.style.left,
                  width: el2.style.width,
                  height: el2.style.height
                };
                el2.style.position = "absolute";
                el2.style.top = `${offsetTop}px`;
                el2.style.left = `${offsetLeft}px`;
                el2.style.width = `${offsetWidth}px`;
                el2.style.height = `${offsetHeight}px`;
              }
              if (props.hideOnLeave) {
                el2.style.setProperty("display", "none", "important");
              }
            },
            onAfterLeave(el2) {
              if (props.leaveAbsolute && (el2 == null ? void 0 : el2._transitionInitialStyles)) {
                const {
                  position,
                  top: top2,
                  left,
                  width,
                  height
                } = el2._transitionInitialStyles;
                delete el2._transitionInitialStyles;
                el2.style.position = position || "";
                el2.style.top = top2 || "";
                el2.style.left = left || "";
                el2.style.width = width || "";
                el2.style.height = height || "";
              }
            }
          };
          return () => {
            const tag = props.group ? TransitionGroup : Transition;
            return h(tag, {
              name: props.disabled ? "" : name,
              css: !props.disabled,
              ...props.group ? void 0 : {
                mode: props.mode
              },
              ...props.disabled ? {} : functions
            }, slots.default);
          };
        }
      });
    }
    function createJavascriptTransition(name, functions) {
      let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "in-out";
      return genericComponent()({
        name,
        props: {
          mode: {
            type: String,
            default: mode
          },
          disabled: Boolean,
          group: Boolean
        },
        setup(props, _ref2) {
          let {
            slots
          } = _ref2;
          const tag = props.group ? TransitionGroup : Transition;
          return () => {
            return h(tag, {
              name: props.disabled ? "" : name,
              css: !props.disabled,
              // mode: props.mode, // TODO: vuejs/vue-next#3104
              ...props.disabled ? {} : functions
            }, slots.default);
          };
        }
      });
    }
    function ExpandTransitionGenerator() {
      let expandedParentClass = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      let x2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      const sizeProperty = x2 ? "width" : "height";
      const offsetProperty = camelize(`offset-${sizeProperty}`);
      return {
        onBeforeEnter(el2) {
          el2._parent = el2.parentNode;
          el2._initialStyle = {
            transition: el2.style.transition,
            overflow: el2.style.overflow,
            [sizeProperty]: el2.style[sizeProperty]
          };
        },
        onEnter(el2) {
          const initialStyle = el2._initialStyle;
          el2.style.setProperty("transition", "none", "important");
          el2.style.overflow = "hidden";
          const offset = `${el2[offsetProperty]}px`;
          el2.style[sizeProperty] = "0";
          void el2.offsetHeight;
          el2.style.transition = initialStyle.transition;
          if (expandedParentClass && el2._parent) {
            el2._parent.classList.add(expandedParentClass);
          }
          requestAnimationFrame(() => {
            el2.style[sizeProperty] = offset;
          });
        },
        onAfterEnter: resetStyles,
        onEnterCancelled: resetStyles,
        onLeave(el2) {
          el2._initialStyle = {
            transition: "",
            overflow: el2.style.overflow,
            [sizeProperty]: el2.style[sizeProperty]
          };
          el2.style.overflow = "hidden";
          el2.style[sizeProperty] = `${el2[offsetProperty]}px`;
          void el2.offsetHeight;
          requestAnimationFrame(() => el2.style[sizeProperty] = "0");
        },
        onAfterLeave,
        onLeaveCancelled: onAfterLeave
      };
      function onAfterLeave(el2) {
        if (expandedParentClass && el2._parent) {
          el2._parent.classList.remove(expandedParentClass);
        }
        resetStyles(el2);
      }
      function resetStyles(el2) {
        const size2 = el2._initialStyle[sizeProperty];
        el2.style.overflow = el2._initialStyle.overflow;
        if (size2 != null)
          el2.style[sizeProperty] = size2;
        delete el2._initialStyle;
      }
    }
    const makeVDialogTransitionProps = propsFactory({
      target: [Object, Array]
    }, "v-dialog-transition");
    const VDialogTransition = genericComponent()({
      name: "VDialogTransition",
      props: makeVDialogTransitionProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const functions = {
          onBeforeEnter(el2) {
            el2.style.pointerEvents = "none";
            el2.style.visibility = "hidden";
          },
          async onEnter(el2, done) {
            var _a2;
            await new Promise((resolve2) => requestAnimationFrame(resolve2));
            await new Promise((resolve2) => requestAnimationFrame(resolve2));
            el2.style.visibility = "";
            const {
              x: x2,
              y,
              sx,
              sy,
              speed
            } = getDimensions(props.target, el2);
            const animation = animate(el2, [{
              transform: `translate(${x2}px, ${y}px) scale(${sx}, ${sy})`,
              opacity: 0
            }, {}], {
              duration: 225 * speed,
              easing: deceleratedEasing
            });
            (_a2 = getChildren$1(el2)) == null ? void 0 : _a2.forEach((el3) => {
              animate(el3, [{
                opacity: 0
              }, {
                opacity: 0,
                offset: 0.33
              }, {}], {
                duration: 225 * 2 * speed,
                easing: standardEasing
              });
            });
            animation.finished.then(() => done());
          },
          onAfterEnter(el2) {
            el2.style.removeProperty("pointer-events");
          },
          onBeforeLeave(el2) {
            el2.style.pointerEvents = "none";
          },
          async onLeave(el2, done) {
            var _a2;
            await new Promise((resolve2) => requestAnimationFrame(resolve2));
            const {
              x: x2,
              y,
              sx,
              sy,
              speed
            } = getDimensions(props.target, el2);
            const animation = animate(el2, [{}, {
              transform: `translate(${x2}px, ${y}px) scale(${sx}, ${sy})`,
              opacity: 0
            }], {
              duration: 125 * speed,
              easing: acceleratedEasing
            });
            animation.finished.then(() => done());
            (_a2 = getChildren$1(el2)) == null ? void 0 : _a2.forEach((el3) => {
              animate(el3, [{}, {
                opacity: 0,
                offset: 0.2
              }, {
                opacity: 0
              }], {
                duration: 125 * 2 * speed,
                easing: standardEasing
              });
            });
          },
          onAfterLeave(el2) {
            el2.style.removeProperty("pointer-events");
          }
        };
        return () => {
          return props.target ? createVNode(Transition, mergeProps({
            "name": "dialog-transition"
          }, functions, {
            "css": false
          }), slots) : createVNode(Transition, {
            "name": "dialog-transition"
          }, slots);
        };
      }
    });
    function getChildren$1(el2) {
      var _a2;
      const els2 = (_a2 = el2.querySelector(":scope > .v-card, :scope > .v-sheet, :scope > .v-list")) == null ? void 0 : _a2.children;
      return els2 && [...els2];
    }
    function getDimensions(target2, el2) {
      const targetBox = getTargetBox(target2);
      const elBox = nullifyTransforms(el2);
      const [originX, originY] = getComputedStyle(el2).transformOrigin.split(" ").map((v) => parseFloat(v));
      const [anchorSide, anchorOffset] = getComputedStyle(el2).getPropertyValue("--v-overlay-anchor-origin").split(" ");
      let offsetX = targetBox.left + targetBox.width / 2;
      if (anchorSide === "left" || anchorOffset === "left") {
        offsetX -= targetBox.width / 2;
      } else if (anchorSide === "right" || anchorOffset === "right") {
        offsetX += targetBox.width / 2;
      }
      let offsetY = targetBox.top + targetBox.height / 2;
      if (anchorSide === "top" || anchorOffset === "top") {
        offsetY -= targetBox.height / 2;
      } else if (anchorSide === "bottom" || anchorOffset === "bottom") {
        offsetY += targetBox.height / 2;
      }
      const tsx = targetBox.width / elBox.width;
      const tsy = targetBox.height / elBox.height;
      const maxs = Math.max(1, tsx, tsy);
      const sx = tsx / maxs || 0;
      const sy = tsy / maxs || 0;
      const asa = elBox.width * elBox.height / (window.innerWidth * window.innerHeight);
      const speed = asa > 0.12 ? Math.min(1.5, (asa - 0.12) * 10 + 1) : 1;
      return {
        x: offsetX - (originX + elBox.left),
        y: offsetY - (originY + elBox.top),
        sx,
        sy,
        speed
      };
    }
    createCssTransition("fab-transition", "center center", "out-in");
    createCssTransition("dialog-bottom-transition");
    createCssTransition("dialog-top-transition");
    const VFadeTransition = createCssTransition("fade-transition");
    const VScaleTransition = createCssTransition("scale-transition");
    createCssTransition("scroll-x-transition");
    createCssTransition("scroll-x-reverse-transition");
    createCssTransition("scroll-y-transition");
    createCssTransition("scroll-y-reverse-transition");
    createCssTransition("slide-x-transition");
    const VSlideXReverseTransition = createCssTransition("slide-x-reverse-transition");
    const VSlideYTransition = createCssTransition("slide-y-transition");
    createCssTransition("slide-y-reverse-transition");
    const VExpandTransition = createJavascriptTransition("expand-transition", ExpandTransitionGenerator());
    const VExpandXTransition = createJavascriptTransition("expand-x-transition", ExpandTransitionGenerator("", true));
    const makeVDefaultsProviderProps = propsFactory({
      defaults: Object,
      disabled: Boolean,
      reset: [Number, String],
      root: [Boolean, String],
      scoped: Boolean
    }, "VDefaultsProvider");
    const VDefaultsProvider = genericComponent(false)({
      name: "VDefaultsProvider",
      props: makeVDefaultsProviderProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          defaults: defaults2,
          disabled,
          reset,
          root,
          scoped
        } = toRefs(props);
        provideDefaults(defaults2, {
          reset,
          root,
          scoped,
          disabled
        });
        return () => {
          var _a2;
          return (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
        };
      }
    });
    const makeDimensionProps = propsFactory({
      height: [Number, String],
      maxHeight: [Number, String],
      maxWidth: [Number, String],
      minHeight: [Number, String],
      minWidth: [Number, String],
      width: [Number, String]
    }, "dimension");
    function useDimension(props) {
      const dimensionStyles = computed(() => {
        const styles = {};
        const height = convertToUnit(props.height);
        const maxHeight = convertToUnit(props.maxHeight);
        const maxWidth = convertToUnit(props.maxWidth);
        const minHeight = convertToUnit(props.minHeight);
        const minWidth = convertToUnit(props.minWidth);
        const width = convertToUnit(props.width);
        if (height != null)
          styles.height = height;
        if (maxHeight != null)
          styles.maxHeight = maxHeight;
        if (maxWidth != null)
          styles.maxWidth = maxWidth;
        if (minHeight != null)
          styles.minHeight = minHeight;
        if (minWidth != null)
          styles.minWidth = minWidth;
        if (width != null)
          styles.width = width;
        return styles;
      });
      return {
        dimensionStyles
      };
    }
    function useAspectStyles(props) {
      return {
        aspectStyles: computed(() => {
          const ratio2 = Number(props.aspectRatio);
          return ratio2 ? {
            paddingBottom: String(1 / ratio2 * 100) + "%"
          } : void 0;
        })
      };
    }
    const makeVResponsiveProps = propsFactory({
      aspectRatio: [String, Number],
      contentClass: null,
      inline: Boolean,
      ...makeComponentProps(),
      ...makeDimensionProps()
    }, "VResponsive");
    const VResponsive = genericComponent()({
      name: "VResponsive",
      props: makeVResponsiveProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          aspectStyles
        } = useAspectStyles(props);
        const {
          dimensionStyles
        } = useDimension(props);
        useRender(() => {
          var _a2;
          return createVNode("div", {
            "class": ["v-responsive", {
              "v-responsive--inline": props.inline
            }, props.class],
            "style": [dimensionStyles.value, props.style]
          }, [createVNode("div", {
            "class": "v-responsive__sizer",
            "style": aspectStyles.value
          }, null), (_a2 = slots.additional) == null ? void 0 : _a2.call(slots), slots.default && createVNode("div", {
            "class": ["v-responsive__content", props.contentClass]
          }, [slots.default()])]);
        });
        return {};
      }
    });
    function useColor(colors2) {
      return destructComputed(() => {
        const classes = [];
        const styles = {};
        if (colors2.value.background) {
          if (isCssColor(colors2.value.background)) {
            styles.backgroundColor = colors2.value.background;
            if (!colors2.value.text && isParsableColor(colors2.value.background)) {
              const backgroundColor = parseColor(colors2.value.background);
              if (backgroundColor.a == null || backgroundColor.a === 1) {
                const textColor = getForeground(backgroundColor);
                styles.color = textColor;
                styles.caretColor = textColor;
              }
            }
          } else {
            classes.push(`bg-${colors2.value.background}`);
          }
        }
        if (colors2.value.text) {
          if (isCssColor(colors2.value.text)) {
            styles.color = colors2.value.text;
            styles.caretColor = colors2.value.text;
          } else {
            classes.push(`text-${colors2.value.text}`);
          }
        }
        return {
          colorClasses: classes,
          colorStyles: styles
        };
      });
    }
    function useTextColor(props, name) {
      const colors2 = computed(() => ({
        text: isRef(props) ? props.value : name ? props[name] : null
      }));
      const {
        colorClasses: textColorClasses,
        colorStyles: textColorStyles
      } = useColor(colors2);
      return {
        textColorClasses,
        textColorStyles
      };
    }
    function useBackgroundColor(props, name) {
      const colors2 = computed(() => ({
        background: isRef(props) ? props.value : name ? props[name] : null
      }));
      const {
        colorClasses: backgroundColorClasses,
        colorStyles: backgroundColorStyles
      } = useColor(colors2);
      return {
        backgroundColorClasses,
        backgroundColorStyles
      };
    }
    const makeRoundedProps = propsFactory({
      rounded: {
        type: [Boolean, Number, String],
        default: void 0
      },
      tile: Boolean
    }, "rounded");
    function useRounded(props) {
      let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
      const roundedClasses = computed(() => {
        const rounded = isRef(props) ? props.value : props.rounded;
        const tile = isRef(props) ? props.value : props.tile;
        const classes = [];
        if (rounded === true || rounded === "") {
          classes.push(`${name}--rounded`);
        } else if (typeof rounded === "string" || rounded === 0) {
          for (const value of String(rounded).split(" ")) {
            classes.push(`rounded-${value}`);
          }
        } else if (tile || rounded === false) {
          classes.push("rounded-0");
        }
        return classes;
      });
      return {
        roundedClasses
      };
    }
    const makeTransitionProps = propsFactory({
      transition: {
        type: [Boolean, String, Object],
        default: "fade-transition",
        validator: (val) => val !== true
      }
    }, "transition");
    const MaybeTransition = (props, _ref) => {
      let {
        slots
      } = _ref;
      const {
        transition,
        disabled,
        group,
        ...rest
      } = props;
      const {
        component = group ? TransitionGroup : Transition,
        ...customProps
      } = typeof transition === "object" ? transition : {};
      return h(component, mergeProps(typeof transition === "string" ? {
        name: disabled ? "" : transition
      } : customProps, typeof transition === "string" ? {} : Object.fromEntries(Object.entries({
        disabled,
        group
      }).filter((_ref2) => {
        let [_, v] = _ref2;
        return v !== void 0;
      })), rest), slots);
    };
    function mounted$2(el2, binding) {
      if (!SUPPORTS_INTERSECTION)
        return;
      const modifiers = binding.modifiers || {};
      const value = binding.value;
      const {
        handler,
        options
      } = typeof value === "object" ? value : {
        handler: value,
        options: {}
      };
      const observer = new IntersectionObserver(function() {
        var _a2;
        let entries = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        let observer2 = arguments.length > 1 ? arguments[1] : void 0;
        const _observe = (_a2 = el2._observe) == null ? void 0 : _a2[binding.instance.$.uid];
        if (!_observe)
          return;
        const isIntersecting = entries.some((entry) => entry.isIntersecting);
        if (handler && (!modifiers.quiet || _observe.init) && (!modifiers.once || isIntersecting || _observe.init)) {
          handler(isIntersecting, entries, observer2);
        }
        if (isIntersecting && modifiers.once)
          unmounted$2(el2, binding);
        else
          _observe.init = true;
      }, options);
      el2._observe = Object(el2._observe);
      el2._observe[binding.instance.$.uid] = {
        init: false,
        observer
      };
      observer.observe(el2);
    }
    function unmounted$2(el2, binding) {
      var _a2;
      const observe = (_a2 = el2._observe) == null ? void 0 : _a2[binding.instance.$.uid];
      if (!observe)
        return;
      observe.observer.unobserve(el2);
      delete el2._observe[binding.instance.$.uid];
    }
    const Intersect = {
      mounted: mounted$2,
      unmounted: unmounted$2
    };
    const Intersect$1 = Intersect;
    const makeVImgProps = propsFactory({
      alt: String,
      cover: Boolean,
      color: String,
      draggable: {
        type: [Boolean, String],
        default: void 0
      },
      eager: Boolean,
      gradient: String,
      lazySrc: String,
      options: {
        type: Object,
        // For more information on types, navigate to:
        // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
        default: () => ({
          root: void 0,
          rootMargin: void 0,
          threshold: void 0
        })
      },
      sizes: String,
      src: {
        type: [String, Object],
        default: ""
      },
      crossorigin: String,
      referrerpolicy: String,
      srcset: String,
      position: String,
      ...makeVResponsiveProps(),
      ...makeComponentProps(),
      ...makeRoundedProps(),
      ...makeTransitionProps()
    }, "VImg");
    const VImg = genericComponent()({
      name: "VImg",
      directives: {
        intersect: Intersect$1
      },
      props: makeVImgProps(),
      emits: {
        loadstart: (value) => true,
        load: (value) => true,
        error: (value) => true
      },
      setup(props, _ref) {
        let {
          emit: emit2,
          slots
        } = _ref;
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(toRef(props, "color"));
        const {
          roundedClasses
        } = useRounded(props);
        const vm = getCurrentInstance("VImg");
        const currentSrc = shallowRef("");
        const image2 = ref$1();
        const state = shallowRef(props.eager ? "loading" : "idle");
        const naturalWidth = shallowRef();
        const naturalHeight = shallowRef();
        const normalisedSrc = computed(() => {
          return props.src && typeof props.src === "object" ? {
            src: props.src.src,
            srcset: props.srcset || props.src.srcset,
            lazySrc: props.lazySrc || props.src.lazySrc,
            aspect: Number(props.aspectRatio || props.src.aspect || 0)
          } : {
            src: props.src,
            srcset: props.srcset,
            lazySrc: props.lazySrc,
            aspect: Number(props.aspectRatio || 0)
          };
        });
        const aspectRatio = computed(() => {
          return normalisedSrc.value.aspect || naturalWidth.value / naturalHeight.value || 0;
        });
        watch(() => props.src, () => {
          init(state.value !== "idle");
        });
        watch(aspectRatio, (val, oldVal) => {
          if (!val && oldVal && image2.value) {
            pollForSize(image2.value);
          }
        });
        onBeforeMount(() => init());
        function init(isIntersecting) {
          if (props.eager && isIntersecting)
            return;
          if (SUPPORTS_INTERSECTION && !isIntersecting && !props.eager)
            return;
          state.value = "loading";
          if (normalisedSrc.value.lazySrc) {
            const lazyImg = new Image();
            lazyImg.src = normalisedSrc.value.lazySrc;
            pollForSize(lazyImg, null);
          }
          if (!normalisedSrc.value.src)
            return;
          nextTick(() => {
            var _a2;
            emit2("loadstart", ((_a2 = image2.value) == null ? void 0 : _a2.currentSrc) || normalisedSrc.value.src);
            setTimeout(() => {
              var _a3;
              if (vm.isUnmounted)
                return;
              if ((_a3 = image2.value) == null ? void 0 : _a3.complete) {
                if (!image2.value.naturalWidth) {
                  onError();
                }
                if (state.value === "error")
                  return;
                if (!aspectRatio.value)
                  pollForSize(image2.value, null);
                if (state.value === "loading")
                  onLoad();
              } else {
                if (!aspectRatio.value)
                  pollForSize(image2.value);
                getSrc();
              }
            });
          });
        }
        function onLoad() {
          var _a2;
          if (vm.isUnmounted)
            return;
          getSrc();
          pollForSize(image2.value);
          state.value = "loaded";
          emit2("load", ((_a2 = image2.value) == null ? void 0 : _a2.currentSrc) || normalisedSrc.value.src);
        }
        function onError() {
          var _a2;
          if (vm.isUnmounted)
            return;
          state.value = "error";
          emit2("error", ((_a2 = image2.value) == null ? void 0 : _a2.currentSrc) || normalisedSrc.value.src);
        }
        function getSrc() {
          const img = image2.value;
          if (img)
            currentSrc.value = img.currentSrc || img.src;
        }
        let timer = -1;
        onBeforeUnmount(() => {
          clearTimeout(timer);
        });
        function pollForSize(img) {
          let timeout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
          const poll = () => {
            clearTimeout(timer);
            if (vm.isUnmounted)
              return;
            const {
              naturalHeight: imgHeight,
              naturalWidth: imgWidth
            } = img;
            if (imgHeight || imgWidth) {
              naturalWidth.value = imgWidth;
              naturalHeight.value = imgHeight;
            } else if (!img.complete && state.value === "loading" && timeout != null) {
              timer = window.setTimeout(poll, timeout);
            } else if (img.currentSrc.endsWith(".svg") || img.currentSrc.startsWith("data:image/svg+xml")) {
              naturalWidth.value = 1;
              naturalHeight.value = 1;
            }
          };
          poll();
        }
        const containClasses = computed(() => ({
          "v-img__img--cover": props.cover,
          "v-img__img--contain": !props.cover
        }));
        const __image = () => {
          var _a2;
          if (!normalisedSrc.value.src || state.value === "idle")
            return null;
          const img = createVNode("img", {
            "class": ["v-img__img", containClasses.value],
            "style": {
              objectPosition: props.position
            },
            "src": normalisedSrc.value.src,
            "srcset": normalisedSrc.value.srcset,
            "alt": props.alt,
            "crossorigin": props.crossorigin,
            "referrerpolicy": props.referrerpolicy,
            "draggable": props.draggable,
            "sizes": props.sizes,
            "ref": image2,
            "onLoad": onLoad,
            "onError": onError
          }, null);
          const sources = (_a2 = slots.sources) == null ? void 0 : _a2.call(slots);
          return createVNode(MaybeTransition, {
            "transition": props.transition,
            "appear": true
          }, {
            default: () => [withDirectives(sources ? createVNode("picture", {
              "class": "v-img__picture"
            }, [sources, img]) : img, [[vShow, state.value === "loaded"]])]
          });
        };
        const __preloadImage = () => createVNode(MaybeTransition, {
          "transition": props.transition
        }, {
          default: () => [normalisedSrc.value.lazySrc && state.value !== "loaded" && createVNode("img", {
            "class": ["v-img__img", "v-img__img--preload", containClasses.value],
            "style": {
              objectPosition: props.position
            },
            "src": normalisedSrc.value.lazySrc,
            "alt": props.alt,
            "crossorigin": props.crossorigin,
            "referrerpolicy": props.referrerpolicy,
            "draggable": props.draggable
          }, null)]
        });
        const __placeholder = () => {
          if (!slots.placeholder)
            return null;
          return createVNode(MaybeTransition, {
            "transition": props.transition,
            "appear": true
          }, {
            default: () => [(state.value === "loading" || state.value === "error" && !slots.error) && createVNode("div", {
              "class": "v-img__placeholder"
            }, [slots.placeholder()])]
          });
        };
        const __error = () => {
          if (!slots.error)
            return null;
          return createVNode(MaybeTransition, {
            "transition": props.transition,
            "appear": true
          }, {
            default: () => [state.value === "error" && createVNode("div", {
              "class": "v-img__error"
            }, [slots.error()])]
          });
        };
        const __gradient = () => {
          if (!props.gradient)
            return null;
          return createVNode("div", {
            "class": "v-img__gradient",
            "style": {
              backgroundImage: `linear-gradient(${props.gradient})`
            }
          }, null);
        };
        const isBooted = shallowRef(false);
        {
          const stop = watch(aspectRatio, (val) => {
            if (val) {
              requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                  isBooted.value = true;
                });
              });
              stop();
            }
          });
        }
        useRender(() => {
          const responsiveProps = VResponsive.filterProps(props);
          return withDirectives(createVNode(VResponsive, mergeProps({
            "class": ["v-img", {
              "v-img--booting": !isBooted.value
            }, backgroundColorClasses.value, roundedClasses.value, props.class],
            "style": [{
              width: convertToUnit(props.width === "auto" ? naturalWidth.value : props.width)
            }, backgroundColorStyles.value, props.style]
          }, responsiveProps, {
            "aspectRatio": aspectRatio.value,
            "aria-label": props.alt,
            "role": props.alt ? "img" : void 0
          }), {
            additional: () => createVNode(Fragment, null, [createVNode(__image, null, null), createVNode(__preloadImage, null, null), createVNode(__gradient, null, null), createVNode(__placeholder, null, null), createVNode(__error, null, null)]),
            default: slots.default
          }), [[resolveDirective("intersect"), {
            handler: init,
            options: props.options
          }, null, {
            once: true
          }]]);
        });
        return {
          currentSrc,
          image: image2,
          state,
          naturalWidth,
          naturalHeight
        };
      }
    });
    const makeBorderProps = propsFactory({
      border: [Boolean, Number, String]
    }, "border");
    function useBorder(props) {
      let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
      const borderClasses = computed(() => {
        const border = isRef(props) ? props.value : props.border;
        const classes = [];
        if (border === true || border === "") {
          classes.push(`${name}--border`);
        } else if (typeof border === "string" || border === 0) {
          for (const value of String(border).split(" ")) {
            classes.push(`border-${value}`);
          }
        }
        return classes;
      });
      return {
        borderClasses
      };
    }
    const makeElevationProps = propsFactory({
      elevation: {
        type: [Number, String],
        validator(v) {
          const value = parseInt(v);
          return !isNaN(value) && value >= 0 && // Material Design has a maximum elevation of 24
          // https://material.io/design/environment/elevation.html#default-elevations
          value <= 24;
        }
      }
    }, "elevation");
    function useElevation(props) {
      const elevationClasses = computed(() => {
        const elevation = isRef(props) ? props.value : props.elevation;
        const classes = [];
        if (elevation == null)
          return classes;
        classes.push(`elevation-${elevation}`);
        return classes;
      });
      return {
        elevationClasses
      };
    }
    const allowedDensities$1 = [null, "prominent", "default", "comfortable", "compact"];
    const makeVToolbarProps = propsFactory({
      absolute: Boolean,
      collapse: Boolean,
      color: String,
      density: {
        type: String,
        default: "default",
        validator: (v) => allowedDensities$1.includes(v)
      },
      extended: Boolean,
      extensionHeight: {
        type: [Number, String],
        default: 48
      },
      flat: Boolean,
      floating: Boolean,
      height: {
        type: [Number, String],
        default: 64
      },
      image: String,
      title: String,
      ...makeBorderProps(),
      ...makeComponentProps(),
      ...makeElevationProps(),
      ...makeRoundedProps(),
      ...makeTagProps({
        tag: "header"
      }),
      ...makeThemeProps()
    }, "VToolbar");
    const VToolbar = genericComponent()({
      name: "VToolbar",
      props: makeVToolbarProps(),
      setup(props, _ref) {
        var _a2;
        let {
          slots
        } = _ref;
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(toRef(props, "color"));
        const {
          borderClasses
        } = useBorder(props);
        const {
          elevationClasses
        } = useElevation(props);
        const {
          roundedClasses
        } = useRounded(props);
        const {
          themeClasses
        } = provideTheme(props);
        const {
          rtlClasses
        } = useRtl();
        const isExtended = shallowRef(!!(props.extended || ((_a2 = slots.extension) == null ? void 0 : _a2.call(slots))));
        const contentHeight = computed(() => parseInt(Number(props.height) + (props.density === "prominent" ? Number(props.height) : 0) - (props.density === "comfortable" ? 8 : 0) - (props.density === "compact" ? 16 : 0), 10));
        const extensionHeight = computed(() => isExtended.value ? parseInt(Number(props.extensionHeight) + (props.density === "prominent" ? Number(props.extensionHeight) : 0) - (props.density === "comfortable" ? 4 : 0) - (props.density === "compact" ? 8 : 0), 10) : 0);
        provideDefaults({
          VBtn: {
            variant: "text"
          }
        });
        useRender(() => {
          var _a3;
          const hasTitle = !!(props.title || slots.title);
          const hasImage = !!(slots.image || props.image);
          const extension = (_a3 = slots.extension) == null ? void 0 : _a3.call(slots);
          isExtended.value = !!(props.extended || extension);
          return createVNode(props.tag, {
            "class": ["v-toolbar", {
              "v-toolbar--absolute": props.absolute,
              "v-toolbar--collapse": props.collapse,
              "v-toolbar--flat": props.flat,
              "v-toolbar--floating": props.floating,
              [`v-toolbar--density-${props.density}`]: true
            }, backgroundColorClasses.value, borderClasses.value, elevationClasses.value, roundedClasses.value, themeClasses.value, rtlClasses.value, props.class],
            "style": [backgroundColorStyles.value, props.style]
          }, {
            default: () => [hasImage && createVNode("div", {
              "key": "image",
              "class": "v-toolbar__image"
            }, [!slots.image ? createVNode(VImg, {
              "key": "image-img",
              "cover": true,
              "src": props.image
            }, null) : createVNode(VDefaultsProvider, {
              "key": "image-defaults",
              "disabled": !props.image,
              "defaults": {
                VImg: {
                  cover: true,
                  src: props.image
                }
              }
            }, slots.image)]), createVNode(VDefaultsProvider, {
              "defaults": {
                VTabs: {
                  height: convertToUnit(contentHeight.value)
                }
              }
            }, {
              default: () => {
                var _a4, _b, _c;
                return [createVNode("div", {
                  "class": "v-toolbar__content",
                  "style": {
                    height: convertToUnit(contentHeight.value)
                  }
                }, [slots.prepend && createVNode("div", {
                  "class": "v-toolbar__prepend"
                }, [(_a4 = slots.prepend) == null ? void 0 : _a4.call(slots)]), hasTitle && createVNode(VToolbarTitle, {
                  "key": "title",
                  "text": props.title
                }, {
                  text: slots.title
                }), (_b = slots.default) == null ? void 0 : _b.call(slots), slots.append && createVNode("div", {
                  "class": "v-toolbar__append"
                }, [(_c = slots.append) == null ? void 0 : _c.call(slots)])])];
              }
            }), createVNode(VDefaultsProvider, {
              "defaults": {
                VTabs: {
                  height: convertToUnit(extensionHeight.value)
                }
              }
            }, {
              default: () => [createVNode(VExpandTransition, null, {
                default: () => [isExtended.value && createVNode("div", {
                  "class": "v-toolbar__extension",
                  "style": {
                    height: convertToUnit(extensionHeight.value)
                  }
                }, [extension])]
              })]
            })]
          });
        });
        return {
          contentHeight,
          extensionHeight
        };
      }
    });
    const makeScrollProps = propsFactory({
      scrollTarget: {
        type: String
      },
      scrollThreshold: {
        type: [String, Number],
        default: 300
      }
    }, "scroll");
    function useScroll(props) {
      let args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const {
        canScroll
      } = args;
      let previousScroll = 0;
      let previousScrollHeight = 0;
      const target2 = ref$1(null);
      const currentScroll = shallowRef(0);
      const savedScroll = shallowRef(0);
      const currentThreshold = shallowRef(0);
      const isScrollActive = shallowRef(false);
      const isScrollingUp = shallowRef(false);
      const scrollThreshold = computed(() => {
        return Number(props.scrollThreshold);
      });
      const scrollRatio = computed(() => {
        return clamp((scrollThreshold.value - currentScroll.value) / scrollThreshold.value || 0);
      });
      const onScroll = () => {
        const targetEl = target2.value;
        if (!targetEl || canScroll && !canScroll.value)
          return;
        previousScroll = currentScroll.value;
        currentScroll.value = "window" in targetEl ? targetEl.pageYOffset : targetEl.scrollTop;
        const currentScrollHeight = targetEl instanceof Window ? document.documentElement.scrollHeight : targetEl.scrollHeight;
        if (previousScrollHeight !== currentScrollHeight) {
          previousScrollHeight = currentScrollHeight;
          return;
        }
        isScrollingUp.value = currentScroll.value < previousScroll;
        currentThreshold.value = Math.abs(currentScroll.value - scrollThreshold.value);
      };
      watch(isScrollingUp, () => {
        savedScroll.value = savedScroll.value || currentScroll.value;
      });
      watch(isScrollActive, () => {
        savedScroll.value = 0;
      });
      onMounted(() => {
        watch(() => props.scrollTarget, (scrollTarget) => {
          var _a2;
          const newTarget = scrollTarget ? document.querySelector(scrollTarget) : window;
          if (!newTarget) {
            return;
          }
          if (newTarget === target2.value)
            return;
          (_a2 = target2.value) == null ? void 0 : _a2.removeEventListener("scroll", onScroll);
          target2.value = newTarget;
          target2.value.addEventListener("scroll", onScroll, {
            passive: true
          });
        }, {
          immediate: true
        });
      });
      onBeforeUnmount(() => {
        var _a2;
        (_a2 = target2.value) == null ? void 0 : _a2.removeEventListener("scroll", onScroll);
      });
      canScroll && watch(canScroll, onScroll, {
        immediate: true
      });
      return {
        scrollThreshold,
        currentScroll,
        currentThreshold,
        isScrollActive,
        scrollRatio,
        // required only for testing
        // probably can be removed
        // later (2 chars chlng)
        isScrollingUp,
        savedScroll
      };
    }
    function useSsrBoot() {
      const isBooted = shallowRef(false);
      onMounted(() => {
        window.requestAnimationFrame(() => {
          isBooted.value = true;
        });
      });
      const ssrBootStyles = computed(() => !isBooted.value ? {
        transition: "none !important"
      } : void 0);
      return {
        ssrBootStyles,
        isBooted: readonly(isBooted)
      };
    }
    const makeVAppBarProps = propsFactory({
      scrollBehavior: String,
      modelValue: {
        type: Boolean,
        default: true
      },
      location: {
        type: String,
        default: "top",
        validator: (value) => ["top", "bottom"].includes(value)
      },
      ...makeVToolbarProps(),
      ...makeLayoutItemProps(),
      ...makeScrollProps(),
      height: {
        type: [Number, String],
        default: 64
      }
    }, "VAppBar");
    const VAppBar = genericComponent()({
      name: "VAppBar",
      props: makeVAppBarProps(),
      emits: {
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const vToolbarRef = ref$1();
        const isActive = useProxiedModel(props, "modelValue");
        const scrollBehavior = computed(() => {
          var _a2;
          const behavior = new Set(((_a2 = props.scrollBehavior) == null ? void 0 : _a2.split(" ")) ?? []);
          return {
            hide: behavior.has("hide"),
            fullyHide: behavior.has("fully-hide"),
            inverted: behavior.has("inverted"),
            collapse: behavior.has("collapse"),
            elevate: behavior.has("elevate"),
            fadeImage: behavior.has("fade-image")
            // shrink: behavior.has('shrink'),
          };
        });
        const canScroll = computed(() => {
          const behavior = scrollBehavior.value;
          return behavior.hide || behavior.fullyHide || behavior.inverted || behavior.collapse || behavior.elevate || behavior.fadeImage || // behavior.shrink ||
          !isActive.value;
        });
        const {
          currentScroll,
          scrollThreshold,
          isScrollingUp,
          scrollRatio
        } = useScroll(props, {
          canScroll
        });
        const canHide = computed(() => scrollBehavior.value.hide || scrollBehavior.value.fullyHide);
        const isCollapsed = computed(() => props.collapse || scrollBehavior.value.collapse && (scrollBehavior.value.inverted ? scrollRatio.value > 0 : scrollRatio.value === 0));
        const isFlat = computed(() => props.flat || scrollBehavior.value.fullyHide && !isActive.value || scrollBehavior.value.elevate && (scrollBehavior.value.inverted ? currentScroll.value > 0 : currentScroll.value === 0));
        const opacity = computed(() => scrollBehavior.value.fadeImage ? scrollBehavior.value.inverted ? 1 - scrollRatio.value : scrollRatio.value : void 0);
        const height = computed(() => {
          var _a2, _b;
          const height2 = Number(((_a2 = vToolbarRef.value) == null ? void 0 : _a2.contentHeight) ?? props.height);
          const extensionHeight = Number(((_b = vToolbarRef.value) == null ? void 0 : _b.extensionHeight) ?? 0);
          if (!canHide.value)
            return height2 + extensionHeight;
          return currentScroll.value < scrollThreshold.value || scrollBehavior.value.fullyHide ? height2 + extensionHeight : height2;
        });
        useToggleScope(computed(() => !!props.scrollBehavior), () => {
          watchEffect(() => {
            if (canHide.value) {
              if (scrollBehavior.value.inverted) {
                isActive.value = currentScroll.value > scrollThreshold.value;
              } else {
                isActive.value = isScrollingUp.value || currentScroll.value < scrollThreshold.value;
              }
            } else {
              isActive.value = true;
            }
          });
        });
        const {
          ssrBootStyles
        } = useSsrBoot();
        const {
          layoutItemStyles,
          layoutIsReady
        } = useLayoutItem({
          id: props.name,
          order: computed(() => parseInt(props.order, 10)),
          position: toRef(props, "location"),
          layoutSize: height,
          elementSize: shallowRef(void 0),
          active: isActive,
          absolute: toRef(props, "absolute")
        });
        useRender(() => {
          const toolbarProps = VToolbar.filterProps(props);
          return createVNode(VToolbar, mergeProps({
            "ref": vToolbarRef,
            "class": ["v-app-bar", {
              "v-app-bar--bottom": props.location === "bottom"
            }, props.class],
            "style": [{
              ...layoutItemStyles.value,
              "--v-toolbar-image-opacity": opacity.value,
              height: void 0,
              ...ssrBootStyles.value
            }, props.style]
          }, toolbarProps, {
            "collapse": isCollapsed.value,
            "flat": isFlat.value
          }), slots);
        });
        return layoutIsReady;
      }
    });
    const allowedDensities = [null, "default", "comfortable", "compact"];
    const makeDensityProps = propsFactory({
      density: {
        type: String,
        default: "default",
        validator: (v) => allowedDensities.includes(v)
      }
    }, "density");
    function useDensity(props) {
      let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
      const densityClasses = computed(() => {
        return `${name}--density-${props.density}`;
      });
      return {
        densityClasses
      };
    }
    const allowedVariants$2 = ["elevated", "flat", "tonal", "outlined", "text", "plain"];
    function genOverlays(isClickable, name) {
      return createVNode(Fragment, null, [isClickable && createVNode("span", {
        "key": "overlay",
        "class": `${name}__overlay`
      }, null), createVNode("span", {
        "key": "underlay",
        "class": `${name}__underlay`
      }, null)]);
    }
    const makeVariantProps = propsFactory({
      color: String,
      variant: {
        type: String,
        default: "elevated",
        validator: (v) => allowedVariants$2.includes(v)
      }
    }, "variant");
    function useVariant(props) {
      let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
      const variantClasses = computed(() => {
        const {
          variant
        } = unref(props);
        return `${name}--variant-${variant}`;
      });
      const {
        colorClasses,
        colorStyles
      } = useColor(computed(() => {
        const {
          variant,
          color
        } = unref(props);
        return {
          [["elevated", "flat"].includes(variant) ? "background" : "text"]: color
        };
      }));
      return {
        colorClasses,
        colorStyles,
        variantClasses
      };
    }
    const makeVBtnGroupProps = propsFactory({
      baseColor: String,
      divided: Boolean,
      ...makeBorderProps(),
      ...makeComponentProps(),
      ...makeDensityProps(),
      ...makeElevationProps(),
      ...makeRoundedProps(),
      ...makeTagProps(),
      ...makeThemeProps(),
      ...makeVariantProps()
    }, "VBtnGroup");
    const VBtnGroup = genericComponent()({
      name: "VBtnGroup",
      props: makeVBtnGroupProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          themeClasses
        } = provideTheme(props);
        const {
          densityClasses
        } = useDensity(props);
        const {
          borderClasses
        } = useBorder(props);
        const {
          elevationClasses
        } = useElevation(props);
        const {
          roundedClasses
        } = useRounded(props);
        provideDefaults({
          VBtn: {
            height: "auto",
            baseColor: toRef(props, "baseColor"),
            color: toRef(props, "color"),
            density: toRef(props, "density"),
            flat: true,
            variant: toRef(props, "variant")
          }
        });
        useRender(() => {
          return createVNode(props.tag, {
            "class": ["v-btn-group", {
              "v-btn-group--divided": props.divided
            }, themeClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value, props.class],
            "style": props.style
          }, slots);
        });
      }
    });
    const makeGroupProps = propsFactory({
      modelValue: {
        type: null,
        default: void 0
      },
      multiple: Boolean,
      mandatory: [Boolean, String],
      max: Number,
      selectedClass: String,
      disabled: Boolean
    }, "group");
    const makeGroupItemProps = propsFactory({
      value: null,
      disabled: Boolean,
      selectedClass: String
    }, "group-item");
    function useGroupItem(props, injectKey) {
      let required2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      const vm = getCurrentInstance("useGroupItem");
      if (!vm) {
        throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");
      }
      const id2 = getUid();
      provide(Symbol.for(`${injectKey.description}:id`), id2);
      const group = inject$1(injectKey, null);
      if (!group) {
        if (!required2)
          return group;
        throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${injectKey.description}`);
      }
      const value = toRef(props, "value");
      const disabled = computed(() => !!(group.disabled.value || props.disabled));
      group.register({
        id: id2,
        value,
        disabled
      }, vm);
      onBeforeUnmount(() => {
        group.unregister(id2);
      });
      const isSelected = computed(() => {
        return group.isSelected(id2);
      });
      const isFirst = computed(() => {
        return group.items.value[0].id === id2;
      });
      const isLast = computed(() => {
        return group.items.value[group.items.value.length - 1].id === id2;
      });
      const selectedClass = computed(() => isSelected.value && [group.selectedClass.value, props.selectedClass]);
      watch(isSelected, (value2) => {
        vm.emit("group:selected", {
          value: value2
        });
      }, {
        flush: "sync"
      });
      return {
        id: id2,
        isSelected,
        isFirst,
        isLast,
        toggle: () => group.select(id2, !isSelected.value),
        select: (value2) => group.select(id2, value2),
        selectedClass,
        value,
        disabled,
        group
      };
    }
    function useGroup(props, injectKey) {
      let isUnmounted = false;
      const items2 = reactive([]);
      const selected = useProxiedModel(props, "modelValue", [], (v) => {
        if (v == null)
          return [];
        return getIds(items2, wrapInArray(v));
      }, (v) => {
        const arr = getValues(items2, v);
        return props.multiple ? arr : arr[0];
      });
      const groupVm = getCurrentInstance("useGroup");
      function register(item, vm) {
        const unwrapped = item;
        const key = Symbol.for(`${injectKey.description}:id`);
        const children = findChildrenWithProvide(key, groupVm == null ? void 0 : groupVm.vnode);
        const index = children.indexOf(vm);
        if (unref(unwrapped.value) == null) {
          unwrapped.value = index;
          unwrapped.useIndexAsValue = true;
        }
        if (index > -1) {
          items2.splice(index, 0, unwrapped);
        } else {
          items2.push(unwrapped);
        }
      }
      function unregister(id2) {
        if (isUnmounted)
          return;
        forceMandatoryValue();
        const index = items2.findIndex((item) => item.id === id2);
        items2.splice(index, 1);
      }
      function forceMandatoryValue() {
        const item = items2.find((item2) => !item2.disabled);
        if (item && props.mandatory === "force" && !selected.value.length) {
          selected.value = [item.id];
        }
      }
      onMounted(() => {
        forceMandatoryValue();
      });
      onBeforeUnmount(() => {
        isUnmounted = true;
      });
      onUpdated(() => {
        for (let i2 = 0; i2 < items2.length; i2++) {
          if (items2[i2].useIndexAsValue) {
            items2[i2].value = i2;
          }
        }
      });
      function select(id2, value) {
        const item = items2.find((item2) => item2.id === id2);
        if (value && (item == null ? void 0 : item.disabled))
          return;
        if (props.multiple) {
          const internalValue = selected.value.slice();
          const index = internalValue.findIndex((v) => v === id2);
          const isSelected = ~index;
          value = value ?? !isSelected;
          if (isSelected && props.mandatory && internalValue.length <= 1)
            return;
          if (!isSelected && props.max != null && internalValue.length + 1 > props.max)
            return;
          if (index < 0 && value)
            internalValue.push(id2);
          else if (index >= 0 && !value)
            internalValue.splice(index, 1);
          selected.value = internalValue;
        } else {
          const isSelected = selected.value.includes(id2);
          if (props.mandatory && isSelected)
            return;
          selected.value = value ?? !isSelected ? [id2] : [];
        }
      }
      function step(offset) {
        if (props.multiple)
          ;
        if (!selected.value.length) {
          const item = items2.find((item2) => !item2.disabled);
          item && (selected.value = [item.id]);
        } else {
          const currentId = selected.value[0];
          const currentIndex = items2.findIndex((i2) => i2.id === currentId);
          let newIndex = (currentIndex + offset) % items2.length;
          let newItem = items2[newIndex];
          while (newItem.disabled && newIndex !== currentIndex) {
            newIndex = (newIndex + offset) % items2.length;
            newItem = items2[newIndex];
          }
          if (newItem.disabled)
            return;
          selected.value = [items2[newIndex].id];
        }
      }
      const state = {
        register,
        unregister,
        selected,
        select,
        disabled: toRef(props, "disabled"),
        prev: () => step(items2.length - 1),
        next: () => step(1),
        isSelected: (id2) => selected.value.includes(id2),
        selectedClass: computed(() => props.selectedClass),
        items: computed(() => items2),
        getItemIndex: (value) => getItemIndex(items2, value)
      };
      provide(injectKey, state);
      return state;
    }
    function getItemIndex(items2, value) {
      const ids = getIds(items2, [value]);
      if (!ids.length)
        return -1;
      return items2.findIndex((item) => item.id === ids[0]);
    }
    function getIds(items2, modelValue) {
      const ids = [];
      modelValue.forEach((value) => {
        const item = items2.find((item2) => deepEqual(value, item2.value));
        const itemByIndex = items2[value];
        if ((item == null ? void 0 : item.value) != null) {
          ids.push(item.id);
        } else if (itemByIndex != null) {
          ids.push(itemByIndex.id);
        }
      });
      return ids;
    }
    function getValues(items2, ids) {
      const values = [];
      ids.forEach((id2) => {
        const itemIndex = items2.findIndex((item) => item.id === id2);
        if (~itemIndex) {
          const item = items2[itemIndex];
          values.push(item.value != null ? item.value : itemIndex);
        }
      });
      return values;
    }
    const VBtnToggleSymbol = Symbol.for("vuetify:v-btn-toggle");
    const makeVBtnToggleProps = propsFactory({
      ...makeVBtnGroupProps(),
      ...makeGroupProps()
    }, "VBtnToggle");
    genericComponent()({
      name: "VBtnToggle",
      props: makeVBtnToggleProps(),
      emits: {
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          isSelected,
          next: next2,
          prev,
          select,
          selected
        } = useGroup(props, VBtnToggleSymbol);
        useRender(() => {
          const btnGroupProps = VBtnGroup.filterProps(props);
          return createVNode(VBtnGroup, mergeProps({
            "class": ["v-btn-toggle", props.class]
          }, btnGroupProps, {
            "style": props.style
          }), {
            default: () => {
              var _a2;
              return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
                isSelected,
                next: next2,
                prev,
                select,
                selected
              })];
            }
          });
        });
        return {
          next: next2,
          prev,
          select
        };
      }
    });
    const aliases = {
      collapse: "mdi-chevron-up",
      complete: "mdi-check",
      cancel: "mdi-close-circle",
      close: "mdi-close",
      delete: "mdi-close-circle",
      // delete (e.g. v-chip close)
      clear: "mdi-close-circle",
      success: "mdi-check-circle",
      info: "mdi-information",
      warning: "mdi-alert-circle",
      error: "mdi-close-circle",
      prev: "mdi-chevron-left",
      next: "mdi-chevron-right",
      checkboxOn: "mdi-checkbox-marked",
      checkboxOff: "mdi-checkbox-blank-outline",
      checkboxIndeterminate: "mdi-minus-box",
      delimiter: "mdi-circle",
      // for carousel
      sortAsc: "mdi-arrow-up",
      sortDesc: "mdi-arrow-down",
      expand: "mdi-chevron-down",
      menu: "mdi-menu",
      subgroup: "mdi-menu-down",
      dropdown: "mdi-menu-down",
      radioOn: "mdi-radiobox-marked",
      radioOff: "mdi-radiobox-blank",
      edit: "mdi-pencil",
      ratingEmpty: "mdi-star-outline",
      ratingFull: "mdi-star",
      ratingHalf: "mdi-star-half-full",
      loading: "mdi-cached",
      first: "mdi-page-first",
      last: "mdi-page-last",
      unfold: "mdi-unfold-more-horizontal",
      file: "mdi-paperclip",
      plus: "mdi-plus",
      minus: "mdi-minus",
      calendar: "mdi-calendar",
      treeviewCollapse: "mdi-menu-down",
      treeviewExpand: "mdi-menu-right",
      eyeDropper: "mdi-eyedropper"
    };
    const mdi = {
      // Not using mergeProps here, functional components merge props by default (?)
      component: (props) => h(VClassIcon, {
        ...props,
        class: "mdi"
      })
    };
    const IconValue = [String, Function, Object, Array];
    const IconSymbol = Symbol.for("vuetify:icons");
    const makeIconProps = propsFactory({
      icon: {
        type: IconValue
      },
      // Could not remove this and use makeTagProps, types complained because it is not required
      tag: {
        type: String,
        required: true
      }
    }, "icon");
    const VComponentIcon = genericComponent()({
      name: "VComponentIcon",
      props: makeIconProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        return () => {
          const Icon = props.icon;
          return createVNode(props.tag, null, {
            default: () => {
              var _a2;
              return [props.icon ? createVNode(Icon, null, null) : (_a2 = slots.default) == null ? void 0 : _a2.call(slots)];
            }
          });
        };
      }
    });
    const VSvgIcon = defineComponent({
      name: "VSvgIcon",
      inheritAttrs: false,
      props: makeIconProps(),
      setup(props, _ref2) {
        let {
          attrs
        } = _ref2;
        return () => {
          return createVNode(props.tag, mergeProps(attrs, {
            "style": null
          }), {
            default: () => [createVNode("svg", {
              "class": "v-icon__svg",
              "xmlns": "http://www.w3.org/2000/svg",
              "viewBox": "0 0 24 24",
              "role": "img",
              "aria-hidden": "true"
            }, [Array.isArray(props.icon) ? props.icon.map((path) => Array.isArray(path) ? createVNode("path", {
              "d": path[0],
              "fill-opacity": path[1]
            }, null) : createVNode("path", {
              "d": path
            }, null)) : createVNode("path", {
              "d": props.icon
            }, null)])]
          });
        };
      }
    });
    defineComponent({
      name: "VLigatureIcon",
      props: makeIconProps(),
      setup(props) {
        return () => {
          return createVNode(props.tag, null, {
            default: () => [props.icon]
          });
        };
      }
    });
    const VClassIcon = defineComponent({
      name: "VClassIcon",
      props: makeIconProps(),
      setup(props) {
        return () => {
          return createVNode(props.tag, {
            "class": props.icon
          }, null);
        };
      }
    });
    function genDefaults$1() {
      return {
        svg: {
          component: VSvgIcon
        },
        class: {
          component: VClassIcon
        }
      };
    }
    function createIcons(options) {
      const sets = genDefaults$1();
      const defaultSet = (options == null ? void 0 : options.defaultSet) ?? "mdi";
      if (defaultSet === "mdi" && !sets.mdi) {
        sets.mdi = mdi;
      }
      return mergeDeep({
        defaultSet,
        sets,
        aliases: {
          ...aliases,
          /* eslint-disable max-len */
          vuetify: ["M8.2241 14.2009L12 21L22 3H14.4459L8.2241 14.2009Z", ["M7.26303 12.4733L7.00113 12L2 3H12.5261C12.5261 3 12.5261 3 12.5261 3L7.26303 12.4733Z", 0.6]],
          "vuetify-outline": "svg:M7.26 12.47 12.53 3H2L7.26 12.47ZM14.45 3 8.22 14.2 12 21 22 3H14.45ZM18.6 5 12 16.88 10.51 14.2 15.62 5ZM7.26 8.35 5.4 5H9.13L7.26 8.35Z",
          "vuetify-play": ["m6.376 13.184-4.11-7.192C1.505 4.66 2.467 3 4.003 3h8.532l-.953 1.576-.006.01-.396.677c-.429.732-.214 1.507.194 2.015.404.503 1.092.878 1.869.806a3.72 3.72 0 0 1 1.005.022c.276.053.434.143.523.237.138.146.38.635-.25 2.09-.893 1.63-1.553 1.722-1.847 1.677-.213-.033-.468-.158-.756-.406a4.95 4.95 0 0 1-.8-.927c-.39-.564-1.04-.84-1.66-.846-.625-.006-1.316.27-1.693.921l-.478.826-.911 1.506Z", ["M9.093 11.552c.046-.079.144-.15.32-.148a.53.53 0 0 1 .43.207c.285.414.636.847 1.046 1.2.405.35.914.662 1.516.754 1.334.205 2.502-.698 3.48-2.495l.014-.028.013-.03c.687-1.574.774-2.852-.005-3.675-.37-.391-.861-.586-1.333-.676a5.243 5.243 0 0 0-1.447-.044c-.173.016-.393-.073-.54-.257-.145-.18-.127-.316-.082-.392l.393-.672L14.287 3h5.71c1.536 0 2.499 1.659 1.737 2.992l-7.997 13.996c-.768 1.344-2.706 1.344-3.473 0l-3.037-5.314 1.377-2.278.004-.006.004-.007.481-.831Z", 0.6]]
          /* eslint-enable max-len */
        }
      }, options);
    }
    const useIcon = (props) => {
      const icons = inject$1(IconSymbol);
      if (!icons)
        throw new Error("Missing Vuetify Icons provide!");
      const iconData = computed(() => {
        var _a2;
        const iconAlias = unref(props);
        if (!iconAlias)
          return {
            component: VComponentIcon
          };
        let icon = iconAlias;
        if (typeof icon === "string") {
          icon = icon.trim();
          if (icon.startsWith("$")) {
            icon = (_a2 = icons.aliases) == null ? void 0 : _a2[icon.slice(1)];
          }
        }
        if (Array.isArray(icon)) {
          return {
            component: VSvgIcon,
            icon
          };
        } else if (typeof icon !== "string") {
          return {
            component: VComponentIcon,
            icon
          };
        }
        const iconSetName = Object.keys(icons.sets).find((setName) => typeof icon === "string" && icon.startsWith(`${setName}:`));
        const iconName = iconSetName ? icon.slice(iconSetName.length + 1) : icon;
        const iconSet = icons.sets[iconSetName ?? icons.defaultSet];
        return {
          component: iconSet.component,
          icon: iconName
        };
      });
      return {
        iconData
      };
    };
    const predefinedSizes = ["x-small", "small", "default", "large", "x-large"];
    const makeSizeProps = propsFactory({
      size: {
        type: [String, Number],
        default: "default"
      }
    }, "size");
    function useSize(props) {
      let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
      return destructComputed(() => {
        let sizeClasses;
        let sizeStyles;
        if (includes(predefinedSizes, props.size)) {
          sizeClasses = `${name}--size-${props.size}`;
        } else if (props.size) {
          sizeStyles = {
            width: convertToUnit(props.size),
            height: convertToUnit(props.size)
          };
        }
        return {
          sizeClasses,
          sizeStyles
        };
      });
    }
    const makeVIconProps = propsFactory({
      color: String,
      disabled: Boolean,
      start: Boolean,
      end: Boolean,
      icon: IconValue,
      ...makeComponentProps(),
      ...makeSizeProps(),
      ...makeTagProps({
        tag: "i"
      }),
      ...makeThemeProps()
    }, "VIcon");
    const VIcon = genericComponent()({
      name: "VIcon",
      props: makeVIconProps(),
      setup(props, _ref) {
        let {
          attrs,
          slots
        } = _ref;
        const slotIcon = ref$1();
        const {
          themeClasses
        } = provideTheme(props);
        const {
          iconData
        } = useIcon(computed(() => slotIcon.value || props.icon));
        const {
          sizeClasses
        } = useSize(props);
        const {
          textColorClasses,
          textColorStyles
        } = useTextColor(toRef(props, "color"));
        useRender(() => {
          var _a2, _b;
          const slotValue = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
          if (slotValue) {
            slotIcon.value = (_b = flattenFragments(slotValue).filter((node) => node.type === Text$2 && node.children && typeof node.children === "string")[0]) == null ? void 0 : _b.children;
          }
          const hasClick = !!(attrs.onClick || attrs.onClickOnce);
          return createVNode(iconData.value.component, {
            "tag": props.tag,
            "icon": iconData.value.icon,
            "class": ["v-icon", "notranslate", themeClasses.value, sizeClasses.value, textColorClasses.value, {
              "v-icon--clickable": hasClick,
              "v-icon--disabled": props.disabled,
              "v-icon--start": props.start,
              "v-icon--end": props.end
            }, props.class],
            "style": [!sizeClasses.value ? {
              fontSize: convertToUnit(props.size),
              height: convertToUnit(props.size),
              width: convertToUnit(props.size)
            } : void 0, textColorStyles.value, props.style],
            "role": hasClick ? "button" : void 0,
            "aria-hidden": !hasClick,
            "tabindex": hasClick ? props.disabled ? -1 : 0 : void 0
          }, {
            default: () => [slotValue]
          });
        });
        return {};
      }
    });
    function useIntersectionObserver(callback, options) {
      const intersectionRef = ref$1();
      const isIntersecting = shallowRef(false);
      if (SUPPORTS_INTERSECTION) {
        const observer = new IntersectionObserver((entries) => {
          callback == null ? void 0 : callback(entries, observer);
          isIntersecting.value = !!entries.find((entry) => entry.isIntersecting);
        }, options);
        onBeforeUnmount(() => {
          observer.disconnect();
        });
        watch(intersectionRef, (newValue, oldValue) => {
          if (oldValue) {
            observer.unobserve(oldValue);
            isIntersecting.value = false;
          }
          if (newValue)
            observer.observe(newValue);
        }, {
          flush: "post"
        });
      }
      return {
        intersectionRef,
        isIntersecting
      };
    }
    const makeVProgressCircularProps = propsFactory({
      bgColor: String,
      color: String,
      indeterminate: [Boolean, String],
      modelValue: {
        type: [Number, String],
        default: 0
      },
      rotate: {
        type: [Number, String],
        default: 0
      },
      width: {
        type: [Number, String],
        default: 4
      },
      ...makeComponentProps(),
      ...makeSizeProps(),
      ...makeTagProps({
        tag: "div"
      }),
      ...makeThemeProps()
    }, "VProgressCircular");
    const VProgressCircular = genericComponent()({
      name: "VProgressCircular",
      props: makeVProgressCircularProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const MAGIC_RADIUS_CONSTANT = 20;
        const CIRCUMFERENCE = 2 * Math.PI * MAGIC_RADIUS_CONSTANT;
        const root = ref$1();
        const {
          themeClasses
        } = provideTheme(props);
        const {
          sizeClasses,
          sizeStyles
        } = useSize(props);
        const {
          textColorClasses,
          textColorStyles
        } = useTextColor(toRef(props, "color"));
        const {
          textColorClasses: underlayColorClasses,
          textColorStyles: underlayColorStyles
        } = useTextColor(toRef(props, "bgColor"));
        const {
          intersectionRef,
          isIntersecting
        } = useIntersectionObserver();
        const {
          resizeRef,
          contentRect
        } = useResizeObserver$1();
        const normalizedValue = computed(() => Math.max(0, Math.min(100, parseFloat(props.modelValue))));
        const width = computed(() => Number(props.width));
        const size2 = computed(() => {
          return sizeStyles.value ? Number(props.size) : contentRect.value ? contentRect.value.width : Math.max(width.value, 32);
        });
        const diameter = computed(() => MAGIC_RADIUS_CONSTANT / (1 - width.value / size2.value) * 2);
        const strokeWidth = computed(() => width.value / size2.value * diameter.value);
        const strokeDashOffset = computed(() => convertToUnit((100 - normalizedValue.value) / 100 * CIRCUMFERENCE));
        watchEffect(() => {
          intersectionRef.value = root.value;
          resizeRef.value = root.value;
        });
        useRender(() => createVNode(props.tag, {
          "ref": root,
          "class": ["v-progress-circular", {
            "v-progress-circular--indeterminate": !!props.indeterminate,
            "v-progress-circular--visible": isIntersecting.value,
            "v-progress-circular--disable-shrink": props.indeterminate === "disable-shrink"
          }, themeClasses.value, sizeClasses.value, textColorClasses.value, props.class],
          "style": [sizeStyles.value, textColorStyles.value, props.style],
          "role": "progressbar",
          "aria-valuemin": "0",
          "aria-valuemax": "100",
          "aria-valuenow": props.indeterminate ? void 0 : normalizedValue.value
        }, {
          default: () => [createVNode("svg", {
            "style": {
              transform: `rotate(calc(-90deg + ${Number(props.rotate)}deg))`
            },
            "xmlns": "http://www.w3.org/2000/svg",
            "viewBox": `0 0 ${diameter.value} ${diameter.value}`
          }, [createVNode("circle", {
            "class": ["v-progress-circular__underlay", underlayColorClasses.value],
            "style": underlayColorStyles.value,
            "fill": "transparent",
            "cx": "50%",
            "cy": "50%",
            "r": MAGIC_RADIUS_CONSTANT,
            "stroke-width": strokeWidth.value,
            "stroke-dasharray": CIRCUMFERENCE,
            "stroke-dashoffset": 0
          }, null), createVNode("circle", {
            "class": "v-progress-circular__overlay",
            "fill": "transparent",
            "cx": "50%",
            "cy": "50%",
            "r": MAGIC_RADIUS_CONSTANT,
            "stroke-width": strokeWidth.value,
            "stroke-dasharray": CIRCUMFERENCE,
            "stroke-dashoffset": strokeDashOffset.value
          }, null)]), slots.default && createVNode("div", {
            "class": "v-progress-circular__content"
          }, [slots.default({
            value: normalizedValue.value
          })])]
        }));
        return {};
      }
    });
    const oppositeMap = {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    };
    const makeLocationProps = propsFactory({
      location: String
    }, "location");
    function useLocation(props) {
      let opposite = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      let offset = arguments.length > 2 ? arguments[2] : void 0;
      const {
        isRtl
      } = useRtl();
      const locationStyles = computed(() => {
        if (!props.location)
          return {};
        const {
          side,
          align
        } = parseAnchor(props.location.split(" ").length > 1 ? props.location : `${props.location} center`, isRtl.value);
        function getOffset2(side2) {
          return offset ? offset(side2) : 0;
        }
        const styles = {};
        if (side !== "center") {
          if (opposite)
            styles[oppositeMap[side]] = `calc(100% - ${getOffset2(side)}px)`;
          else
            styles[side] = 0;
        }
        if (align !== "center") {
          if (opposite)
            styles[oppositeMap[align]] = `calc(100% - ${getOffset2(align)}px)`;
          else
            styles[align] = 0;
        } else {
          if (side === "center")
            styles.top = styles.left = "50%";
          else {
            styles[{
              top: "left",
              bottom: "left",
              left: "top",
              right: "top"
            }[side]] = "50%";
          }
          styles.transform = {
            top: "translateX(-50%)",
            bottom: "translateX(-50%)",
            left: "translateY(-50%)",
            right: "translateY(-50%)",
            center: "translate(-50%, -50%)"
          }[side];
        }
        return styles;
      });
      return {
        locationStyles
      };
    }
    const makeVProgressLinearProps = propsFactory({
      absolute: Boolean,
      active: {
        type: Boolean,
        default: true
      },
      bgColor: String,
      bgOpacity: [Number, String],
      bufferValue: {
        type: [Number, String],
        default: 0
      },
      bufferColor: String,
      bufferOpacity: [Number, String],
      clickable: Boolean,
      color: String,
      height: {
        type: [Number, String],
        default: 4
      },
      indeterminate: Boolean,
      max: {
        type: [Number, String],
        default: 100
      },
      modelValue: {
        type: [Number, String],
        default: 0
      },
      opacity: [Number, String],
      reverse: Boolean,
      stream: Boolean,
      striped: Boolean,
      roundedBar: Boolean,
      ...makeComponentProps(),
      ...makeLocationProps({
        location: "top"
      }),
      ...makeRoundedProps(),
      ...makeTagProps(),
      ...makeThemeProps()
    }, "VProgressLinear");
    const VProgressLinear = genericComponent()({
      name: "VProgressLinear",
      props: makeVProgressLinearProps(),
      emits: {
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        var _a2;
        let {
          slots
        } = _ref;
        const progress = useProxiedModel(props, "modelValue");
        const {
          isRtl,
          rtlClasses
        } = useRtl();
        const {
          themeClasses
        } = provideTheme(props);
        const {
          locationStyles
        } = useLocation(props);
        const {
          textColorClasses,
          textColorStyles
        } = useTextColor(props, "color");
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(computed(() => props.bgColor || props.color));
        const {
          backgroundColorClasses: bufferColorClasses,
          backgroundColorStyles: bufferColorStyles
        } = useBackgroundColor(computed(() => props.bufferColor || props.bgColor || props.color));
        const {
          backgroundColorClasses: barColorClasses,
          backgroundColorStyles: barColorStyles
        } = useBackgroundColor(props, "color");
        const {
          roundedClasses
        } = useRounded(props);
        const {
          intersectionRef,
          isIntersecting
        } = useIntersectionObserver();
        const max = computed(() => parseFloat(props.max));
        const height = computed(() => parseFloat(props.height));
        const normalizedBuffer = computed(() => clamp(parseFloat(props.bufferValue) / max.value * 100, 0, 100));
        const normalizedValue = computed(() => clamp(parseFloat(progress.value) / max.value * 100, 0, 100));
        const isReversed = computed(() => isRtl.value !== props.reverse);
        const transition = computed(() => props.indeterminate ? "fade-transition" : "slide-x-transition");
        const isForcedColorsModeActive = IN_BROWSER && ((_a2 = window.matchMedia) == null ? void 0 : _a2.call(window, "(forced-colors: active)").matches);
        function handleClick(e) {
          if (!intersectionRef.value)
            return;
          const {
            left,
            right,
            width
          } = intersectionRef.value.getBoundingClientRect();
          const value = isReversed.value ? width - e.clientX + (right - width) : e.clientX - left;
          progress.value = Math.round(value / width * max.value);
        }
        useRender(() => createVNode(props.tag, {
          "ref": intersectionRef,
          "class": ["v-progress-linear", {
            "v-progress-linear--absolute": props.absolute,
            "v-progress-linear--active": props.active && isIntersecting.value,
            "v-progress-linear--reverse": isReversed.value,
            "v-progress-linear--rounded": props.rounded,
            "v-progress-linear--rounded-bar": props.roundedBar,
            "v-progress-linear--striped": props.striped
          }, roundedClasses.value, themeClasses.value, rtlClasses.value, props.class],
          "style": [{
            bottom: props.location === "bottom" ? 0 : void 0,
            top: props.location === "top" ? 0 : void 0,
            height: props.active ? convertToUnit(height.value) : 0,
            "--v-progress-linear-height": convertToUnit(height.value),
            ...props.absolute ? locationStyles.value : {}
          }, props.style],
          "role": "progressbar",
          "aria-hidden": props.active ? "false" : "true",
          "aria-valuemin": "0",
          "aria-valuemax": props.max,
          "aria-valuenow": props.indeterminate ? void 0 : normalizedValue.value,
          "onClick": props.clickable && handleClick
        }, {
          default: () => [props.stream && createVNode("div", {
            "key": "stream",
            "class": ["v-progress-linear__stream", textColorClasses.value],
            "style": {
              ...textColorStyles.value,
              [isReversed.value ? "left" : "right"]: convertToUnit(-height.value),
              borderTop: `${convertToUnit(height.value / 2)} dotted`,
              opacity: parseFloat(props.bufferOpacity),
              top: `calc(50% - ${convertToUnit(height.value / 4)})`,
              width: convertToUnit(100 - normalizedBuffer.value, "%"),
              "--v-progress-linear-stream-to": convertToUnit(height.value * (isReversed.value ? 1 : -1))
            }
          }, null), createVNode("div", {
            "class": ["v-progress-linear__background", !isForcedColorsModeActive ? backgroundColorClasses.value : void 0],
            "style": [backgroundColorStyles.value, {
              opacity: parseFloat(props.bgOpacity),
              width: props.stream ? 0 : void 0
            }]
          }, null), createVNode("div", {
            "class": ["v-progress-linear__buffer", !isForcedColorsModeActive ? bufferColorClasses.value : void 0],
            "style": [bufferColorStyles.value, {
              opacity: parseFloat(props.bufferOpacity),
              width: convertToUnit(normalizedBuffer.value, "%")
            }]
          }, null), createVNode(Transition, {
            "name": transition.value
          }, {
            default: () => [!props.indeterminate ? createVNode("div", {
              "class": ["v-progress-linear__determinate", !isForcedColorsModeActive ? barColorClasses.value : void 0],
              "style": [barColorStyles.value, {
                width: convertToUnit(normalizedValue.value, "%")
              }]
            }, null) : createVNode("div", {
              "class": "v-progress-linear__indeterminate"
            }, [["long", "short"].map((bar) => createVNode("div", {
              "key": bar,
              "class": ["v-progress-linear__indeterminate", bar, !isForcedColorsModeActive ? barColorClasses.value : void 0],
              "style": barColorStyles.value
            }, null))])]
          }), slots.default && createVNode("div", {
            "class": "v-progress-linear__content"
          }, [slots.default({
            value: normalizedValue.value,
            buffer: normalizedBuffer.value
          })])]
        }));
        return {};
      }
    });
    const makeLoaderProps = propsFactory({
      loading: [Boolean, String]
    }, "loader");
    function useLoader(props) {
      let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
      const loaderClasses = computed(() => ({
        [`${name}--loading`]: props.loading
      }));
      return {
        loaderClasses
      };
    }
    function LoaderSlot(props, _ref) {
      var _a2;
      let {
        slots
      } = _ref;
      return createVNode("div", {
        "class": `${props.name}__loader`
      }, [((_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
        color: props.color,
        isActive: props.active
      })) || createVNode(VProgressLinear, {
        "absolute": props.absolute,
        "active": props.active,
        "color": props.color,
        "height": "2",
        "indeterminate": true
      }, null)]);
    }
    const positionValues = ["static", "relative", "fixed", "absolute", "sticky"];
    const makePositionProps = propsFactory({
      position: {
        type: String,
        validator: (
          /* istanbul ignore next */
          (v) => positionValues.includes(v)
        )
      }
    }, "position");
    function usePosition(props) {
      let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
      const positionClasses = computed(() => {
        return props.position ? `${name}--${props.position}` : void 0;
      });
      return {
        positionClasses
      };
    }
    function useRoute() {
      const vm = getCurrentInstance("useRoute");
      return computed(() => {
        var _a2;
        return (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$route;
      });
    }
    function useRouter() {
      var _a2, _b;
      return (_b = (_a2 = getCurrentInstance("useRouter")) == null ? void 0 : _a2.proxy) == null ? void 0 : _b.$router;
    }
    function useLink(props, attrs) {
      var _a2, _b;
      const RouterLink2 = resolveDynamicComponent("RouterLink");
      const isLink = computed(() => !!(props.href || props.to));
      const isClickable = computed(() => {
        return (isLink == null ? void 0 : isLink.value) || hasEvent(attrs, "click") || hasEvent(props, "click");
      });
      if (typeof RouterLink2 === "string" || !("useLink" in RouterLink2)) {
        return {
          isLink,
          isClickable,
          href: toRef(props, "href")
        };
      }
      const linkProps = computed(() => ({
        ...props,
        to: toRef(() => props.to || "")
      }));
      const routerLink = RouterLink2.useLink(linkProps.value);
      const link2 = computed(() => props.to ? routerLink : void 0);
      const route = useRoute();
      return {
        isLink,
        isClickable,
        route: (_a2 = link2.value) == null ? void 0 : _a2.route,
        navigate: (_b = link2.value) == null ? void 0 : _b.navigate,
        isActive: computed(() => {
          var _a3, _b2, _c;
          if (!link2.value)
            return false;
          if (!props.exact)
            return ((_a3 = link2.value.isActive) == null ? void 0 : _a3.value) ?? false;
          if (!route.value)
            return ((_b2 = link2.value.isExactActive) == null ? void 0 : _b2.value) ?? false;
          return ((_c = link2.value.isExactActive) == null ? void 0 : _c.value) && deepEqual(link2.value.route.value.query, route.value.query);
        }),
        href: computed(() => {
          var _a3;
          return props.to ? (_a3 = link2.value) == null ? void 0 : _a3.route.value.href : props.href;
        })
      };
    }
    const makeRouterProps = propsFactory({
      href: String,
      replace: Boolean,
      to: [String, Object],
      exact: Boolean
    }, "router");
    let inTransition = false;
    function useBackButton(router2, cb) {
      let popped = false;
      let removeBefore;
      let removeAfter;
      if (IN_BROWSER) {
        nextTick(() => {
          window.addEventListener("popstate", onPopstate);
          removeBefore = router2 == null ? void 0 : router2.beforeEach((to, from, next2) => {
            if (!inTransition) {
              setTimeout(() => popped ? cb(next2) : next2());
            } else {
              popped ? cb(next2) : next2();
            }
            inTransition = true;
          });
          removeAfter = router2 == null ? void 0 : router2.afterEach(() => {
            inTransition = false;
          });
        });
        onScopeDispose(() => {
          window.removeEventListener("popstate", onPopstate);
          removeBefore == null ? void 0 : removeBefore();
          removeAfter == null ? void 0 : removeAfter();
        });
      }
      function onPopstate(e) {
        var _a2;
        if ((_a2 = e.state) == null ? void 0 : _a2.replaced)
          return;
        popped = true;
        setTimeout(() => popped = false);
      }
    }
    function useSelectLink(link2, select) {
      watch(() => {
        var _a2;
        return (_a2 = link2.isActive) == null ? void 0 : _a2.value;
      }, (isActive) => {
        if (link2.isLink.value && isActive && select) {
          nextTick(() => {
            select(true);
          });
        }
      }, {
        immediate: true
      });
    }
    const stopSymbol = Symbol("rippleStop");
    const DELAY_RIPPLE = 80;
    function transform(el2, value) {
      el2.style.transform = value;
      el2.style.webkitTransform = value;
    }
    function isTouchEvent(e) {
      return e.constructor.name === "TouchEvent";
    }
    function isKeyboardEvent(e) {
      return e.constructor.name === "KeyboardEvent";
    }
    const calculate = function(e, el2) {
      var _a2;
      let value = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      let localX = 0;
      let localY = 0;
      if (!isKeyboardEvent(e)) {
        const offset = el2.getBoundingClientRect();
        const target2 = isTouchEvent(e) ? e.touches[e.touches.length - 1] : e;
        localX = target2.clientX - offset.left;
        localY = target2.clientY - offset.top;
      }
      let radius = 0;
      let scale = 0.3;
      if ((_a2 = el2._ripple) == null ? void 0 : _a2.circle) {
        scale = 0.15;
        radius = el2.clientWidth / 2;
        radius = value.center ? radius : radius + Math.sqrt((localX - radius) ** 2 + (localY - radius) ** 2) / 4;
      } else {
        radius = Math.sqrt(el2.clientWidth ** 2 + el2.clientHeight ** 2) / 2;
      }
      const centerX = `${(el2.clientWidth - radius * 2) / 2}px`;
      const centerY = `${(el2.clientHeight - radius * 2) / 2}px`;
      const x2 = value.center ? centerX : `${localX - radius}px`;
      const y = value.center ? centerY : `${localY - radius}px`;
      return {
        radius,
        scale,
        x: x2,
        y,
        centerX,
        centerY
      };
    };
    const ripples = {
      /* eslint-disable max-statements */
      show(e, el2) {
        var _a2;
        let value = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (!((_a2 = el2 == null ? void 0 : el2._ripple) == null ? void 0 : _a2.enabled)) {
          return;
        }
        const container = document.createElement("span");
        const animation = document.createElement("span");
        container.appendChild(animation);
        container.className = "v-ripple__container";
        if (value.class) {
          container.className += ` ${value.class}`;
        }
        const {
          radius,
          scale,
          x: x2,
          y,
          centerX,
          centerY
        } = calculate(e, el2, value);
        const size2 = `${radius * 2}px`;
        animation.className = "v-ripple__animation";
        animation.style.width = size2;
        animation.style.height = size2;
        el2.appendChild(container);
        const computed2 = window.getComputedStyle(el2);
        if (computed2 && computed2.position === "static") {
          el2.style.position = "relative";
          el2.dataset.previousPosition = "static";
        }
        animation.classList.add("v-ripple__animation--enter");
        animation.classList.add("v-ripple__animation--visible");
        transform(animation, `translate(${x2}, ${y}) scale3d(${scale},${scale},${scale})`);
        animation.dataset.activated = String(performance.now());
        setTimeout(() => {
          animation.classList.remove("v-ripple__animation--enter");
          animation.classList.add("v-ripple__animation--in");
          transform(animation, `translate(${centerX}, ${centerY}) scale3d(1,1,1)`);
        }, 0);
      },
      hide(el2) {
        var _a2;
        if (!((_a2 = el2 == null ? void 0 : el2._ripple) == null ? void 0 : _a2.enabled))
          return;
        const ripples2 = el2.getElementsByClassName("v-ripple__animation");
        if (ripples2.length === 0)
          return;
        const animation = ripples2[ripples2.length - 1];
        if (animation.dataset.isHiding)
          return;
        else
          animation.dataset.isHiding = "true";
        const diff = performance.now() - Number(animation.dataset.activated);
        const delay = Math.max(250 - diff, 0);
        setTimeout(() => {
          animation.classList.remove("v-ripple__animation--in");
          animation.classList.add("v-ripple__animation--out");
          setTimeout(() => {
            var _a3;
            const ripples3 = el2.getElementsByClassName("v-ripple__animation");
            if (ripples3.length === 1 && el2.dataset.previousPosition) {
              el2.style.position = el2.dataset.previousPosition;
              delete el2.dataset.previousPosition;
            }
            if (((_a3 = animation.parentNode) == null ? void 0 : _a3.parentNode) === el2)
              el2.removeChild(animation.parentNode);
          }, 300);
        }, delay);
      }
    };
    function isRippleEnabled(value) {
      return typeof value === "undefined" || !!value;
    }
    function rippleShow(e) {
      const value = {};
      const element = e.currentTarget;
      if (!(element == null ? void 0 : element._ripple) || element._ripple.touched || e[stopSymbol])
        return;
      e[stopSymbol] = true;
      if (isTouchEvent(e)) {
        element._ripple.touched = true;
        element._ripple.isTouch = true;
      } else {
        if (element._ripple.isTouch)
          return;
      }
      value.center = element._ripple.centered || isKeyboardEvent(e);
      if (element._ripple.class) {
        value.class = element._ripple.class;
      }
      if (isTouchEvent(e)) {
        if (element._ripple.showTimerCommit)
          return;
        element._ripple.showTimerCommit = () => {
          ripples.show(e, element, value);
        };
        element._ripple.showTimer = window.setTimeout(() => {
          var _a2;
          if ((_a2 = element == null ? void 0 : element._ripple) == null ? void 0 : _a2.showTimerCommit) {
            element._ripple.showTimerCommit();
            element._ripple.showTimerCommit = null;
          }
        }, DELAY_RIPPLE);
      } else {
        ripples.show(e, element, value);
      }
    }
    function rippleStop(e) {
      e[stopSymbol] = true;
    }
    function rippleHide(e) {
      const element = e.currentTarget;
      if (!(element == null ? void 0 : element._ripple))
        return;
      window.clearTimeout(element._ripple.showTimer);
      if (e.type === "touchend" && element._ripple.showTimerCommit) {
        element._ripple.showTimerCommit();
        element._ripple.showTimerCommit = null;
        element._ripple.showTimer = window.setTimeout(() => {
          rippleHide(e);
        });
        return;
      }
      window.setTimeout(() => {
        if (element._ripple) {
          element._ripple.touched = false;
        }
      });
      ripples.hide(element);
    }
    function rippleCancelShow(e) {
      const element = e.currentTarget;
      if (!(element == null ? void 0 : element._ripple))
        return;
      if (element._ripple.showTimerCommit) {
        element._ripple.showTimerCommit = null;
      }
      window.clearTimeout(element._ripple.showTimer);
    }
    let keyboardRipple = false;
    function keyboardRippleShow(e) {
      if (!keyboardRipple && (e.keyCode === keyCodes.enter || e.keyCode === keyCodes.space)) {
        keyboardRipple = true;
        rippleShow(e);
      }
    }
    function keyboardRippleHide(e) {
      keyboardRipple = false;
      rippleHide(e);
    }
    function focusRippleHide(e) {
      if (keyboardRipple) {
        keyboardRipple = false;
        rippleHide(e);
      }
    }
    function updateRipple(el2, binding, wasEnabled) {
      const {
        value,
        modifiers
      } = binding;
      const enabled = isRippleEnabled(value);
      if (!enabled) {
        ripples.hide(el2);
      }
      el2._ripple = el2._ripple ?? {};
      el2._ripple.enabled = enabled;
      el2._ripple.centered = modifiers.center;
      el2._ripple.circle = modifiers.circle;
      if (isObject$3(value) && value.class) {
        el2._ripple.class = value.class;
      }
      if (enabled && !wasEnabled) {
        if (modifiers.stop) {
          el2.addEventListener("touchstart", rippleStop, {
            passive: true
          });
          el2.addEventListener("mousedown", rippleStop);
          return;
        }
        el2.addEventListener("touchstart", rippleShow, {
          passive: true
        });
        el2.addEventListener("touchend", rippleHide, {
          passive: true
        });
        el2.addEventListener("touchmove", rippleCancelShow, {
          passive: true
        });
        el2.addEventListener("touchcancel", rippleHide);
        el2.addEventListener("mousedown", rippleShow);
        el2.addEventListener("mouseup", rippleHide);
        el2.addEventListener("mouseleave", rippleHide);
        el2.addEventListener("keydown", keyboardRippleShow);
        el2.addEventListener("keyup", keyboardRippleHide);
        el2.addEventListener("blur", focusRippleHide);
        el2.addEventListener("dragstart", rippleHide, {
          passive: true
        });
      } else if (!enabled && wasEnabled) {
        removeListeners(el2);
      }
    }
    function removeListeners(el2) {
      el2.removeEventListener("mousedown", rippleShow);
      el2.removeEventListener("touchstart", rippleShow);
      el2.removeEventListener("touchend", rippleHide);
      el2.removeEventListener("touchmove", rippleCancelShow);
      el2.removeEventListener("touchcancel", rippleHide);
      el2.removeEventListener("mouseup", rippleHide);
      el2.removeEventListener("mouseleave", rippleHide);
      el2.removeEventListener("keydown", keyboardRippleShow);
      el2.removeEventListener("keyup", keyboardRippleHide);
      el2.removeEventListener("dragstart", rippleHide);
      el2.removeEventListener("blur", focusRippleHide);
    }
    function mounted$1(el2, binding) {
      updateRipple(el2, binding, false);
    }
    function unmounted$1(el2) {
      delete el2._ripple;
      removeListeners(el2);
    }
    function updated(el2, binding) {
      if (binding.value === binding.oldValue) {
        return;
      }
      const wasEnabled = isRippleEnabled(binding.oldValue);
      updateRipple(el2, binding, wasEnabled);
    }
    const Ripple = {
      mounted: mounted$1,
      unmounted: unmounted$1,
      updated
    };
    const makeVBtnProps = propsFactory({
      active: {
        type: Boolean,
        default: void 0
      },
      baseColor: String,
      symbol: {
        type: null,
        default: VBtnToggleSymbol
      },
      flat: Boolean,
      icon: [Boolean, String, Function, Object],
      prependIcon: IconValue,
      appendIcon: IconValue,
      block: Boolean,
      readonly: Boolean,
      slim: Boolean,
      stacked: Boolean,
      ripple: {
        type: [Boolean, Object],
        default: true
      },
      text: String,
      ...makeBorderProps(),
      ...makeComponentProps(),
      ...makeDensityProps(),
      ...makeDimensionProps(),
      ...makeElevationProps(),
      ...makeGroupItemProps(),
      ...makeLoaderProps(),
      ...makeLocationProps(),
      ...makePositionProps(),
      ...makeRoundedProps(),
      ...makeRouterProps(),
      ...makeSizeProps(),
      ...makeTagProps({
        tag: "button"
      }),
      ...makeThemeProps(),
      ...makeVariantProps({
        variant: "elevated"
      })
    }, "VBtn");
    const VBtn = genericComponent()({
      name: "VBtn",
      props: makeVBtnProps(),
      emits: {
        "group:selected": (val) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          slots
        } = _ref;
        const {
          themeClasses
        } = provideTheme(props);
        const {
          borderClasses
        } = useBorder(props);
        const {
          densityClasses
        } = useDensity(props);
        const {
          dimensionStyles
        } = useDimension(props);
        const {
          elevationClasses
        } = useElevation(props);
        const {
          loaderClasses
        } = useLoader(props);
        const {
          locationStyles
        } = useLocation(props);
        const {
          positionClasses
        } = usePosition(props);
        const {
          roundedClasses
        } = useRounded(props);
        const {
          sizeClasses,
          sizeStyles
        } = useSize(props);
        const group = useGroupItem(props, props.symbol, false);
        const link2 = useLink(props, attrs);
        const isActive = computed(() => {
          var _a2;
          if (props.active !== void 0) {
            return props.active;
          }
          if (link2.isLink.value) {
            return (_a2 = link2.isActive) == null ? void 0 : _a2.value;
          }
          return group == null ? void 0 : group.isSelected.value;
        });
        const variantProps = computed(() => {
          var _a2, _b;
          const showColor = (group == null ? void 0 : group.isSelected.value) && (!link2.isLink.value || ((_a2 = link2.isActive) == null ? void 0 : _a2.value)) || !group || ((_b = link2.isActive) == null ? void 0 : _b.value);
          return {
            color: showColor ? props.color ?? props.baseColor : props.baseColor,
            variant: props.variant
          };
        });
        const {
          colorClasses,
          colorStyles,
          variantClasses
        } = useVariant(variantProps);
        const isDisabled = computed(() => (group == null ? void 0 : group.disabled.value) || props.disabled);
        const isElevated = computed(() => {
          return props.variant === "elevated" && !(props.disabled || props.flat || props.border);
        });
        const valueAttr = computed(() => {
          if (props.value === void 0 || typeof props.value === "symbol")
            return void 0;
          return Object(props.value) === props.value ? JSON.stringify(props.value, null, 0) : props.value;
        });
        function onClick(e) {
          var _a2;
          if (isDisabled.value || link2.isLink.value && (e.metaKey || e.ctrlKey || e.shiftKey || e.button !== 0 || attrs.target === "_blank"))
            return;
          (_a2 = link2.navigate) == null ? void 0 : _a2.call(link2, e);
          group == null ? void 0 : group.toggle();
        }
        useSelectLink(link2, group == null ? void 0 : group.select);
        useRender(() => {
          const Tag2 = link2.isLink.value ? "a" : props.tag;
          const hasPrepend = !!(props.prependIcon || slots.prepend);
          const hasAppend = !!(props.appendIcon || slots.append);
          const hasIcon = !!(props.icon && props.icon !== true);
          return withDirectives(createVNode(Tag2, {
            "type": Tag2 === "a" ? void 0 : "button",
            "class": ["v-btn", group == null ? void 0 : group.selectedClass.value, {
              "v-btn--active": isActive.value,
              "v-btn--block": props.block,
              "v-btn--disabled": isDisabled.value,
              "v-btn--elevated": isElevated.value,
              "v-btn--flat": props.flat,
              "v-btn--icon": !!props.icon,
              "v-btn--loading": props.loading,
              "v-btn--readonly": props.readonly,
              "v-btn--slim": props.slim,
              "v-btn--stacked": props.stacked
            }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, loaderClasses.value, positionClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, props.class],
            "style": [colorStyles.value, dimensionStyles.value, locationStyles.value, sizeStyles.value, props.style],
            "aria-busy": props.loading ? true : void 0,
            "disabled": isDisabled.value || void 0,
            "href": link2.href.value,
            "tabindex": props.loading || props.readonly ? -1 : void 0,
            "onClick": onClick,
            "value": valueAttr.value
          }, {
            default: () => {
              var _a2;
              return [genOverlays(true, "v-btn"), !props.icon && hasPrepend && createVNode("span", {
                "key": "prepend",
                "class": "v-btn__prepend"
              }, [!slots.prepend ? createVNode(VIcon, {
                "key": "prepend-icon",
                "icon": props.prependIcon
              }, null) : createVNode(VDefaultsProvider, {
                "key": "prepend-defaults",
                "disabled": !props.prependIcon,
                "defaults": {
                  VIcon: {
                    icon: props.prependIcon
                  }
                }
              }, slots.prepend)]), createVNode("span", {
                "class": "v-btn__content",
                "data-no-activator": ""
              }, [!slots.default && hasIcon ? createVNode(VIcon, {
                "key": "content-icon",
                "icon": props.icon
              }, null) : createVNode(VDefaultsProvider, {
                "key": "content-defaults",
                "disabled": !hasIcon,
                "defaults": {
                  VIcon: {
                    icon: props.icon
                  }
                }
              }, {
                default: () => {
                  var _a3;
                  return [((_a3 = slots.default) == null ? void 0 : _a3.call(slots)) ?? props.text];
                }
              })]), !props.icon && hasAppend && createVNode("span", {
                "key": "append",
                "class": "v-btn__append"
              }, [!slots.append ? createVNode(VIcon, {
                "key": "append-icon",
                "icon": props.appendIcon
              }, null) : createVNode(VDefaultsProvider, {
                "key": "append-defaults",
                "disabled": !props.appendIcon,
                "defaults": {
                  VIcon: {
                    icon: props.appendIcon
                  }
                }
              }, slots.append)]), !!props.loading && createVNode("span", {
                "key": "loader",
                "class": "v-btn__loader"
              }, [((_a2 = slots.loader) == null ? void 0 : _a2.call(slots)) ?? createVNode(VProgressCircular, {
                "color": typeof props.loading === "boolean" ? void 0 : props.loading,
                "indeterminate": true,
                "width": "2"
              }, null)])];
            }
          }), [[Ripple, !isDisabled.value && props.ripple, "", {
            center: !!props.icon
          }]]);
        });
        return {
          group
        };
      }
    });
    const makeVAppBarNavIconProps = propsFactory({
      ...makeVBtnProps({
        icon: "$menu",
        variant: "text"
      })
    }, "VAppBarNavIcon");
    const VAppBarNavIcon = genericComponent()({
      name: "VAppBarNavIcon",
      props: makeVAppBarNavIconProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        useRender(() => createVNode(VBtn, mergeProps(props, {
          "class": ["v-app-bar-nav-icon"]
        }), slots));
        return {};
      }
    });
    const VCardActions = genericComponent()({
      name: "VCardActions",
      props: makeComponentProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        provideDefaults({
          VBtn: {
            slim: true,
            variant: "text"
          }
        });
        useRender(() => {
          var _a2;
          return createVNode("div", {
            "class": ["v-card-actions", props.class],
            "style": props.style
          }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
        });
        return {};
      }
    });
    const makeVCardSubtitleProps = propsFactory({
      opacity: [Number, String],
      ...makeComponentProps(),
      ...makeTagProps()
    }, "VCardSubtitle");
    const VCardSubtitle = genericComponent()({
      name: "VCardSubtitle",
      props: makeVCardSubtitleProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        useRender(() => createVNode(props.tag, {
          "class": ["v-card-subtitle", props.class],
          "style": [{
            "--v-card-subtitle-opacity": props.opacity
          }, props.style]
        }, slots));
        return {};
      }
    });
    const VCardTitle = createSimpleFunctional("v-card-title");
    const makeVAvatarProps = propsFactory({
      start: Boolean,
      end: Boolean,
      icon: IconValue,
      image: String,
      text: String,
      ...makeComponentProps(),
      ...makeDensityProps(),
      ...makeRoundedProps(),
      ...makeSizeProps(),
      ...makeTagProps(),
      ...makeThemeProps(),
      ...makeVariantProps({
        variant: "flat"
      })
    }, "VAvatar");
    const VAvatar = genericComponent()({
      name: "VAvatar",
      props: makeVAvatarProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          themeClasses
        } = provideTheme(props);
        const {
          colorClasses,
          colorStyles,
          variantClasses
        } = useVariant(props);
        const {
          densityClasses
        } = useDensity(props);
        const {
          roundedClasses
        } = useRounded(props);
        const {
          sizeClasses,
          sizeStyles
        } = useSize(props);
        useRender(() => createVNode(props.tag, {
          "class": ["v-avatar", {
            "v-avatar--start": props.start,
            "v-avatar--end": props.end
          }, themeClasses.value, colorClasses.value, densityClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, props.class],
          "style": [colorStyles.value, sizeStyles.value, props.style]
        }, {
          default: () => [!slots.default ? props.image ? createVNode(VImg, {
            "key": "image",
            "src": props.image,
            "alt": "",
            "cover": true
          }, null) : props.icon ? createVNode(VIcon, {
            "key": "icon",
            "icon": props.icon
          }, null) : props.text : createVNode(VDefaultsProvider, {
            "key": "content-defaults",
            "defaults": {
              VImg: {
                cover: true,
                src: props.image
              },
              VIcon: {
                icon: props.icon
              }
            }
          }, {
            default: () => [slots.default()]
          }), genOverlays(false, "v-avatar")]
        }));
        return {};
      }
    });
    const makeCardItemProps = propsFactory({
      appendAvatar: String,
      appendIcon: IconValue,
      prependAvatar: String,
      prependIcon: IconValue,
      subtitle: [String, Number],
      title: [String, Number],
      ...makeComponentProps(),
      ...makeDensityProps()
    }, "VCardItem");
    const VCardItem = genericComponent()({
      name: "VCardItem",
      props: makeCardItemProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        useRender(() => {
          var _a2;
          const hasPrependMedia = !!(props.prependAvatar || props.prependIcon);
          const hasPrepend = !!(hasPrependMedia || slots.prepend);
          const hasAppendMedia = !!(props.appendAvatar || props.appendIcon);
          const hasAppend = !!(hasAppendMedia || slots.append);
          const hasTitle = !!(props.title != null || slots.title);
          const hasSubtitle = !!(props.subtitle != null || slots.subtitle);
          return createVNode("div", {
            "class": ["v-card-item", props.class],
            "style": props.style
          }, [hasPrepend && createVNode("div", {
            "key": "prepend",
            "class": "v-card-item__prepend"
          }, [!slots.prepend ? createVNode(Fragment, null, [props.prependAvatar && createVNode(VAvatar, {
            "key": "prepend-avatar",
            "density": props.density,
            "image": props.prependAvatar
          }, null), props.prependIcon && createVNode(VIcon, {
            "key": "prepend-icon",
            "density": props.density,
            "icon": props.prependIcon
          }, null)]) : createVNode(VDefaultsProvider, {
            "key": "prepend-defaults",
            "disabled": !hasPrependMedia,
            "defaults": {
              VAvatar: {
                density: props.density,
                image: props.prependAvatar
              },
              VIcon: {
                density: props.density,
                icon: props.prependIcon
              }
            }
          }, slots.prepend)]), createVNode("div", {
            "class": "v-card-item__content"
          }, [hasTitle && createVNode(VCardTitle, {
            "key": "title"
          }, {
            default: () => {
              var _a3;
              return [((_a3 = slots.title) == null ? void 0 : _a3.call(slots)) ?? props.title];
            }
          }), hasSubtitle && createVNode(VCardSubtitle, {
            "key": "subtitle"
          }, {
            default: () => {
              var _a3;
              return [((_a3 = slots.subtitle) == null ? void 0 : _a3.call(slots)) ?? props.subtitle];
            }
          }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), hasAppend && createVNode("div", {
            "key": "append",
            "class": "v-card-item__append"
          }, [!slots.append ? createVNode(Fragment, null, [props.appendIcon && createVNode(VIcon, {
            "key": "append-icon",
            "density": props.density,
            "icon": props.appendIcon
          }, null), props.appendAvatar && createVNode(VAvatar, {
            "key": "append-avatar",
            "density": props.density,
            "image": props.appendAvatar
          }, null)]) : createVNode(VDefaultsProvider, {
            "key": "append-defaults",
            "disabled": !hasAppendMedia,
            "defaults": {
              VAvatar: {
                density: props.density,
                image: props.appendAvatar
              },
              VIcon: {
                density: props.density,
                icon: props.appendIcon
              }
            }
          }, slots.append)])]);
        });
        return {};
      }
    });
    const makeVCardTextProps = propsFactory({
      opacity: [Number, String],
      ...makeComponentProps(),
      ...makeTagProps()
    }, "VCardText");
    const VCardText = genericComponent()({
      name: "VCardText",
      props: makeVCardTextProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        useRender(() => createVNode(props.tag, {
          "class": ["v-card-text", props.class],
          "style": [{
            "--v-card-text-opacity": props.opacity
          }, props.style]
        }, slots));
        return {};
      }
    });
    const makeVCardProps = propsFactory({
      appendAvatar: String,
      appendIcon: IconValue,
      disabled: Boolean,
      flat: Boolean,
      hover: Boolean,
      image: String,
      link: {
        type: Boolean,
        default: void 0
      },
      prependAvatar: String,
      prependIcon: IconValue,
      ripple: {
        type: [Boolean, Object],
        default: true
      },
      subtitle: [String, Number],
      text: [String, Number],
      title: [String, Number],
      ...makeBorderProps(),
      ...makeComponentProps(),
      ...makeDensityProps(),
      ...makeDimensionProps(),
      ...makeElevationProps(),
      ...makeLoaderProps(),
      ...makeLocationProps(),
      ...makePositionProps(),
      ...makeRoundedProps(),
      ...makeRouterProps(),
      ...makeTagProps(),
      ...makeThemeProps(),
      ...makeVariantProps({
        variant: "elevated"
      })
    }, "VCard");
    const VCard = genericComponent()({
      name: "VCard",
      directives: {
        Ripple
      },
      props: makeVCardProps(),
      setup(props, _ref) {
        let {
          attrs,
          slots
        } = _ref;
        const {
          themeClasses
        } = provideTheme(props);
        const {
          borderClasses
        } = useBorder(props);
        const {
          colorClasses,
          colorStyles,
          variantClasses
        } = useVariant(props);
        const {
          densityClasses
        } = useDensity(props);
        const {
          dimensionStyles
        } = useDimension(props);
        const {
          elevationClasses
        } = useElevation(props);
        const {
          loaderClasses
        } = useLoader(props);
        const {
          locationStyles
        } = useLocation(props);
        const {
          positionClasses
        } = usePosition(props);
        const {
          roundedClasses
        } = useRounded(props);
        const link2 = useLink(props, attrs);
        const isLink = computed(() => props.link !== false && link2.isLink.value);
        const isClickable = computed(() => !props.disabled && props.link !== false && (props.link || link2.isClickable.value));
        useRender(() => {
          const Tag2 = isLink.value ? "a" : props.tag;
          const hasTitle = !!(slots.title || props.title != null);
          const hasSubtitle = !!(slots.subtitle || props.subtitle != null);
          const hasHeader = hasTitle || hasSubtitle;
          const hasAppend = !!(slots.append || props.appendAvatar || props.appendIcon);
          const hasPrepend = !!(slots.prepend || props.prependAvatar || props.prependIcon);
          const hasImage = !!(slots.image || props.image);
          const hasCardItem = hasHeader || hasPrepend || hasAppend;
          const hasText = !!(slots.text || props.text != null);
          return withDirectives(createVNode(Tag2, {
            "class": ["v-card", {
              "v-card--disabled": props.disabled,
              "v-card--flat": props.flat,
              "v-card--hover": props.hover && !(props.disabled || props.flat),
              "v-card--link": isClickable.value
            }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, loaderClasses.value, positionClasses.value, roundedClasses.value, variantClasses.value, props.class],
            "style": [colorStyles.value, dimensionStyles.value, locationStyles.value, props.style],
            "href": link2.href.value,
            "onClick": isClickable.value && link2.navigate,
            "tabindex": props.disabled ? -1 : void 0
          }, {
            default: () => {
              var _a2;
              return [hasImage && createVNode("div", {
                "key": "image",
                "class": "v-card__image"
              }, [!slots.image ? createVNode(VImg, {
                "key": "image-img",
                "cover": true,
                "src": props.image
              }, null) : createVNode(VDefaultsProvider, {
                "key": "image-defaults",
                "disabled": !props.image,
                "defaults": {
                  VImg: {
                    cover: true,
                    src: props.image
                  }
                }
              }, slots.image)]), createVNode(LoaderSlot, {
                "name": "v-card",
                "active": !!props.loading,
                "color": typeof props.loading === "boolean" ? void 0 : props.loading
              }, {
                default: slots.loader
              }), hasCardItem && createVNode(VCardItem, {
                "key": "item",
                "prependAvatar": props.prependAvatar,
                "prependIcon": props.prependIcon,
                "title": props.title,
                "subtitle": props.subtitle,
                "appendAvatar": props.appendAvatar,
                "appendIcon": props.appendIcon
              }, {
                default: slots.item,
                prepend: slots.prepend,
                title: slots.title,
                subtitle: slots.subtitle,
                append: slots.append
              }), hasText && createVNode(VCardText, {
                "key": "text"
              }, {
                default: () => {
                  var _a3;
                  return [((_a3 = slots.text) == null ? void 0 : _a3.call(slots)) ?? props.text];
                }
              }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots), slots.actions && createVNode(VCardActions, null, {
                default: slots.actions
              }), genOverlays(isClickable.value, "v-card")];
            }
          }), [[resolveDirective("ripple"), isClickable.value && props.ripple]]);
        });
        return {};
      }
    });
    const makeVContainerProps = propsFactory({
      fluid: {
        type: Boolean,
        default: false
      },
      ...makeComponentProps(),
      ...makeTagProps()
    }, "VContainer");
    const VContainer = genericComponent()({
      name: "VContainer",
      props: makeVContainerProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          rtlClasses
        } = useRtl();
        useRender(() => createVNode(props.tag, {
          "class": ["v-container", {
            "v-container--fluid": props.fluid
          }, rtlClasses.value, props.class],
          "style": props.style
        }, slots));
        return {};
      }
    });
    const breakpoints = ["sm", "md", "lg", "xl", "xxl"];
    const DisplaySymbol = Symbol.for("vuetify:display");
    const defaultDisplayOptions = {
      mobileBreakpoint: "lg",
      thresholds: {
        xs: 0,
        sm: 600,
        md: 960,
        lg: 1280,
        xl: 1920,
        xxl: 2560
      }
    };
    const parseDisplayOptions = function() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultDisplayOptions;
      return mergeDeep(defaultDisplayOptions, options);
    };
    function getClientWidth(ssr) {
      return IN_BROWSER && !ssr ? window.innerWidth : typeof ssr === "object" && ssr.clientWidth || 0;
    }
    function getClientHeight(ssr) {
      return IN_BROWSER && !ssr ? window.innerHeight : typeof ssr === "object" && ssr.clientHeight || 0;
    }
    function getPlatform(ssr) {
      const userAgent = IN_BROWSER && !ssr ? window.navigator.userAgent : "ssr";
      function match(regexp) {
        return Boolean(userAgent.match(regexp));
      }
      const android = match(/android/i);
      const ios = match(/iphone|ipad|ipod/i);
      const cordova = match(/cordova/i);
      const electron = match(/electron/i);
      const chrome = match(/chrome/i);
      const edge = match(/edge/i);
      const firefox = match(/firefox/i);
      const opera = match(/opera/i);
      const win = match(/win/i);
      const mac = match(/mac/i);
      const linux = match(/linux/i);
      return {
        android,
        ios,
        cordova,
        electron,
        chrome,
        edge,
        firefox,
        opera,
        win,
        mac,
        linux,
        touch: SUPPORTS_TOUCH,
        ssr: userAgent === "ssr"
      };
    }
    function createDisplay(options, ssr) {
      const {
        thresholds: thresholds2,
        mobileBreakpoint
      } = parseDisplayOptions(options);
      const height = shallowRef(getClientHeight(ssr));
      const platform = shallowRef(getPlatform(ssr));
      const state = reactive({});
      const width = shallowRef(getClientWidth(ssr));
      function updateSize() {
        height.value = getClientHeight();
        width.value = getClientWidth();
      }
      function update() {
        updateSize();
        platform.value = getPlatform();
      }
      watchEffect(() => {
        const xs = width.value < thresholds2.sm;
        const sm = width.value < thresholds2.md && !xs;
        const md = width.value < thresholds2.lg && !(sm || xs);
        const lg2 = width.value < thresholds2.xl && !(md || sm || xs);
        const xl = width.value < thresholds2.xxl && !(lg2 || md || sm || xs);
        const xxl = width.value >= thresholds2.xxl;
        const name = xs ? "xs" : sm ? "sm" : md ? "md" : lg2 ? "lg" : xl ? "xl" : "xxl";
        const breakpointValue = typeof mobileBreakpoint === "number" ? mobileBreakpoint : thresholds2[mobileBreakpoint];
        const mobile = width.value < breakpointValue;
        state.xs = xs;
        state.sm = sm;
        state.md = md;
        state.lg = lg2;
        state.xl = xl;
        state.xxl = xxl;
        state.smAndUp = !xs;
        state.mdAndUp = !(xs || sm);
        state.lgAndUp = !(xs || sm || md);
        state.xlAndUp = !(xs || sm || md || lg2);
        state.smAndDown = !(md || lg2 || xl || xxl);
        state.mdAndDown = !(lg2 || xl || xxl);
        state.lgAndDown = !(xl || xxl);
        state.xlAndDown = !xxl;
        state.name = name;
        state.height = height.value;
        state.width = width.value;
        state.mobile = mobile;
        state.mobileBreakpoint = mobileBreakpoint;
        state.platform = platform.value;
        state.thresholds = thresholds2;
      });
      if (IN_BROWSER) {
        window.addEventListener("resize", updateSize, {
          passive: true
        });
      }
      return {
        ...toRefs(state),
        update,
        ssr: !!ssr
      };
    }
    const makeDisplayProps = propsFactory({
      mobile: {
        type: Boolean,
        default: false
      },
      mobileBreakpoint: [Number, String]
    }, "display");
    function useDisplay() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
      const display = inject$1(DisplaySymbol);
      if (!display)
        throw new Error("Could not find Vuetify display injection");
      const mobile = computed(() => {
        if (props.mobile != null)
          return props.mobile;
        if (!props.mobileBreakpoint)
          return display.mobile.value;
        const breakpointValue = typeof props.mobileBreakpoint === "number" ? props.mobileBreakpoint : display.thresholds.value[props.mobileBreakpoint];
        return display.width.value < breakpointValue;
      });
      const displayClasses = computed(() => {
        if (!name)
          return {};
        return {
          [`${name}--mobile`]: mobile.value
        };
      });
      return {
        ...display,
        displayClasses,
        mobile
      };
    }
    const breakpointProps = (() => {
      return breakpoints.reduce((props, val) => {
        props[val] = {
          type: [Boolean, String, Number],
          default: false
        };
        return props;
      }, {});
    })();
    const offsetProps = (() => {
      return breakpoints.reduce((props, val) => {
        const offsetKey = "offset" + capitalize(val);
        props[offsetKey] = {
          type: [String, Number],
          default: null
        };
        return props;
      }, {});
    })();
    const orderProps = (() => {
      return breakpoints.reduce((props, val) => {
        const orderKey = "order" + capitalize(val);
        props[orderKey] = {
          type: [String, Number],
          default: null
        };
        return props;
      }, {});
    })();
    const propMap$1 = {
      col: Object.keys(breakpointProps),
      offset: Object.keys(offsetProps),
      order: Object.keys(orderProps)
    };
    function breakpointClass$1(type2, prop2, val) {
      let className = type2;
      if (val == null || val === false) {
        return void 0;
      }
      if (prop2) {
        const breakpoint = prop2.replace(type2, "");
        className += `-${breakpoint}`;
      }
      if (type2 === "col") {
        className = "v-" + className;
      }
      if (type2 === "col" && (val === "" || val === true)) {
        return className.toLowerCase();
      }
      className += `-${val}`;
      return className.toLowerCase();
    }
    const ALIGN_SELF_VALUES = ["auto", "start", "end", "center", "baseline", "stretch"];
    const makeVColProps = propsFactory({
      cols: {
        type: [Boolean, String, Number],
        default: false
      },
      ...breakpointProps,
      offset: {
        type: [String, Number],
        default: null
      },
      ...offsetProps,
      order: {
        type: [String, Number],
        default: null
      },
      ...orderProps,
      alignSelf: {
        type: String,
        default: null,
        validator: (str2) => ALIGN_SELF_VALUES.includes(str2)
      },
      ...makeComponentProps(),
      ...makeTagProps()
    }, "VCol");
    const VCol = genericComponent()({
      name: "VCol",
      props: makeVColProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const classes = computed(() => {
          const classList = [];
          let type2;
          for (type2 in propMap$1) {
            propMap$1[type2].forEach((prop2) => {
              const value = props[prop2];
              const className = breakpointClass$1(type2, prop2, value);
              if (className)
                classList.push(className);
            });
          }
          const hasColClasses = classList.some((className) => className.startsWith("v-col-"));
          classList.push({
            // Default to .v-col if no other col-{bp}-* classes generated nor `cols` specified.
            "v-col": !hasColClasses || !props.cols,
            [`v-col-${props.cols}`]: props.cols,
            [`offset-${props.offset}`]: props.offset,
            [`order-${props.order}`]: props.order,
            [`align-self-${props.alignSelf}`]: props.alignSelf
          });
          return classList;
        });
        return () => {
          var _a2;
          return h(props.tag, {
            class: [classes.value, props.class],
            style: props.style
          }, (_a2 = slots.default) == null ? void 0 : _a2.call(slots));
        };
      }
    });
    const ALIGNMENT = ["start", "end", "center"];
    const SPACE$2 = ["space-between", "space-around", "space-evenly"];
    function makeRowProps(prefix, def2) {
      return breakpoints.reduce((props, val) => {
        const prefixKey = prefix + capitalize(val);
        props[prefixKey] = def2();
        return props;
      }, {});
    }
    const ALIGN_VALUES = [...ALIGNMENT, "baseline", "stretch"];
    const alignValidator = (str2) => ALIGN_VALUES.includes(str2);
    const alignProps = makeRowProps("align", () => ({
      type: String,
      default: null,
      validator: alignValidator
    }));
    const JUSTIFY_VALUES = [...ALIGNMENT, ...SPACE$2];
    const justifyValidator = (str2) => JUSTIFY_VALUES.includes(str2);
    const justifyProps = makeRowProps("justify", () => ({
      type: String,
      default: null,
      validator: justifyValidator
    }));
    const ALIGN_CONTENT_VALUES = [...ALIGNMENT, ...SPACE$2, "stretch"];
    const alignContentValidator = (str2) => ALIGN_CONTENT_VALUES.includes(str2);
    const alignContentProps = makeRowProps("alignContent", () => ({
      type: String,
      default: null,
      validator: alignContentValidator
    }));
    const propMap = {
      align: Object.keys(alignProps),
      justify: Object.keys(justifyProps),
      alignContent: Object.keys(alignContentProps)
    };
    const classMap = {
      align: "align",
      justify: "justify",
      alignContent: "align-content"
    };
    function breakpointClass(type2, prop2, val) {
      let className = classMap[type2];
      if (val == null) {
        return void 0;
      }
      if (prop2) {
        const breakpoint = prop2.replace(type2, "");
        className += `-${breakpoint}`;
      }
      className += `-${val}`;
      return className.toLowerCase();
    }
    const makeVRowProps = propsFactory({
      dense: Boolean,
      noGutters: Boolean,
      align: {
        type: String,
        default: null,
        validator: alignValidator
      },
      ...alignProps,
      justify: {
        type: String,
        default: null,
        validator: justifyValidator
      },
      ...justifyProps,
      alignContent: {
        type: String,
        default: null,
        validator: alignContentValidator
      },
      ...alignContentProps,
      ...makeComponentProps(),
      ...makeTagProps()
    }, "VRow");
    const VRow = genericComponent()({
      name: "VRow",
      props: makeVRowProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const classes = computed(() => {
          const classList = [];
          let type2;
          for (type2 in propMap) {
            propMap[type2].forEach((prop2) => {
              const value = props[prop2];
              const className = breakpointClass(type2, prop2, value);
              if (className)
                classList.push(className);
            });
          }
          classList.push({
            "v-row--no-gutters": props.noGutters,
            "v-row--dense": props.dense,
            [`align-${props.align}`]: props.align,
            [`justify-${props.justify}`]: props.justify,
            [`align-content-${props.alignContent}`]: props.alignContent
          });
          return classList;
        });
        return () => {
          var _a2;
          return h(props.tag, {
            class: ["v-row", classes.value, props.class],
            style: props.style
          }, (_a2 = slots.default) == null ? void 0 : _a2.call(slots));
        };
      }
    });
    const VSpacer = createSimpleFunctional("v-spacer", "div", "VSpacer");
    const ListKey = Symbol.for("vuetify:list");
    function createList() {
      const parent = inject$1(ListKey, {
        hasPrepend: shallowRef(false),
        updateHasPrepend: () => null
      });
      const data = {
        hasPrepend: shallowRef(false),
        updateHasPrepend: (value) => {
          if (value)
            data.hasPrepend.value = value;
        }
      };
      provide(ListKey, data);
      return parent;
    }
    function useList() {
      return inject$1(ListKey, null);
    }
    const independentActiveStrategy = (mandatory) => {
      const strategy = {
        activate: (_ref) => {
          let {
            id: id2,
            value,
            activated
          } = _ref;
          id2 = toRaw(id2);
          if (mandatory && !value && activated.size === 1 && activated.has(id2))
            return activated;
          if (value) {
            activated.add(id2);
          } else {
            activated.delete(id2);
          }
          return activated;
        },
        in: (v, children, parents) => {
          let set2 = /* @__PURE__ */ new Set();
          if (v != null) {
            for (const id2 of wrapInArray(v)) {
              set2 = strategy.activate({
                id: id2,
                value: true,
                activated: new Set(set2),
                children,
                parents
              });
            }
          }
          return set2;
        },
        out: (v) => {
          return Array.from(v);
        }
      };
      return strategy;
    };
    const independentSingleActiveStrategy = (mandatory) => {
      const parentStrategy = independentActiveStrategy(mandatory);
      const strategy = {
        activate: (_ref2) => {
          let {
            activated,
            id: id2,
            ...rest
          } = _ref2;
          id2 = toRaw(id2);
          const singleSelected = activated.has(id2) ? /* @__PURE__ */ new Set([id2]) : /* @__PURE__ */ new Set();
          return parentStrategy.activate({
            ...rest,
            id: id2,
            activated: singleSelected
          });
        },
        in: (v, children, parents) => {
          let set2 = /* @__PURE__ */ new Set();
          if (v != null) {
            const arr = wrapInArray(v);
            if (arr.length) {
              set2 = parentStrategy.in(arr.slice(0, 1), children, parents);
            }
          }
          return set2;
        },
        out: (v, children, parents) => {
          return parentStrategy.out(v, children, parents);
        }
      };
      return strategy;
    };
    const leafActiveStrategy = (mandatory) => {
      const parentStrategy = independentActiveStrategy(mandatory);
      const strategy = {
        activate: (_ref3) => {
          let {
            id: id2,
            activated,
            children,
            ...rest
          } = _ref3;
          id2 = toRaw(id2);
          if (children.has(id2))
            return activated;
          return parentStrategy.activate({
            id: id2,
            activated,
            children,
            ...rest
          });
        },
        in: parentStrategy.in,
        out: parentStrategy.out
      };
      return strategy;
    };
    const leafSingleActiveStrategy = (mandatory) => {
      const parentStrategy = independentSingleActiveStrategy(mandatory);
      const strategy = {
        activate: (_ref4) => {
          let {
            id: id2,
            activated,
            children,
            ...rest
          } = _ref4;
          id2 = toRaw(id2);
          if (children.has(id2))
            return activated;
          return parentStrategy.activate({
            id: id2,
            activated,
            children,
            ...rest
          });
        },
        in: parentStrategy.in,
        out: parentStrategy.out
      };
      return strategy;
    };
    const singleOpenStrategy = {
      open: (_ref) => {
        let {
          id: id2,
          value,
          opened,
          parents
        } = _ref;
        if (value) {
          const newOpened = /* @__PURE__ */ new Set();
          newOpened.add(id2);
          let parent = parents.get(id2);
          while (parent != null) {
            newOpened.add(parent);
            parent = parents.get(parent);
          }
          return newOpened;
        } else {
          opened.delete(id2);
          return opened;
        }
      },
      select: () => null
    };
    const multipleOpenStrategy = {
      open: (_ref2) => {
        let {
          id: id2,
          value,
          opened,
          parents
        } = _ref2;
        if (value) {
          let parent = parents.get(id2);
          opened.add(id2);
          while (parent != null && parent !== id2) {
            opened.add(parent);
            parent = parents.get(parent);
          }
          return opened;
        } else {
          opened.delete(id2);
        }
        return opened;
      },
      select: () => null
    };
    const listOpenStrategy = {
      open: multipleOpenStrategy.open,
      select: (_ref3) => {
        let {
          id: id2,
          value,
          opened,
          parents
        } = _ref3;
        if (!value)
          return opened;
        const path = [];
        let parent = parents.get(id2);
        while (parent != null) {
          path.push(parent);
          parent = parents.get(parent);
        }
        return new Set(path);
      }
    };
    const independentSelectStrategy = (mandatory) => {
      const strategy = {
        select: (_ref) => {
          let {
            id: id2,
            value,
            selected
          } = _ref;
          id2 = toRaw(id2);
          if (mandatory && !value) {
            const on = Array.from(selected.entries()).reduce((arr, _ref2) => {
              let [key, value2] = _ref2;
              if (value2 === "on")
                arr.push(key);
              return arr;
            }, []);
            if (on.length === 1 && on[0] === id2)
              return selected;
          }
          selected.set(id2, value ? "on" : "off");
          return selected;
        },
        in: (v, children, parents) => {
          let map2 = /* @__PURE__ */ new Map();
          for (const id2 of v || []) {
            map2 = strategy.select({
              id: id2,
              value: true,
              selected: new Map(map2),
              children,
              parents
            });
          }
          return map2;
        },
        out: (v) => {
          const arr = [];
          for (const [key, value] of v.entries()) {
            if (value === "on")
              arr.push(key);
          }
          return arr;
        }
      };
      return strategy;
    };
    const independentSingleSelectStrategy = (mandatory) => {
      const parentStrategy = independentSelectStrategy(mandatory);
      const strategy = {
        select: (_ref3) => {
          let {
            selected,
            id: id2,
            ...rest
          } = _ref3;
          id2 = toRaw(id2);
          const singleSelected = selected.has(id2) ? /* @__PURE__ */ new Map([[id2, selected.get(id2)]]) : /* @__PURE__ */ new Map();
          return parentStrategy.select({
            ...rest,
            id: id2,
            selected: singleSelected
          });
        },
        in: (v, children, parents) => {
          let map2 = /* @__PURE__ */ new Map();
          if (v == null ? void 0 : v.length) {
            map2 = parentStrategy.in(v.slice(0, 1), children, parents);
          }
          return map2;
        },
        out: (v, children, parents) => {
          return parentStrategy.out(v, children, parents);
        }
      };
      return strategy;
    };
    const leafSelectStrategy = (mandatory) => {
      const parentStrategy = independentSelectStrategy(mandatory);
      const strategy = {
        select: (_ref4) => {
          let {
            id: id2,
            selected,
            children,
            ...rest
          } = _ref4;
          id2 = toRaw(id2);
          if (children.has(id2))
            return selected;
          return parentStrategy.select({
            id: id2,
            selected,
            children,
            ...rest
          });
        },
        in: parentStrategy.in,
        out: parentStrategy.out
      };
      return strategy;
    };
    const leafSingleSelectStrategy = (mandatory) => {
      const parentStrategy = independentSingleSelectStrategy(mandatory);
      const strategy = {
        select: (_ref5) => {
          let {
            id: id2,
            selected,
            children,
            ...rest
          } = _ref5;
          id2 = toRaw(id2);
          if (children.has(id2))
            return selected;
          return parentStrategy.select({
            id: id2,
            selected,
            children,
            ...rest
          });
        },
        in: parentStrategy.in,
        out: parentStrategy.out
      };
      return strategy;
    };
    const classicSelectStrategy = (mandatory) => {
      const strategy = {
        select: (_ref6) => {
          let {
            id: id2,
            value,
            selected,
            children,
            parents
          } = _ref6;
          id2 = toRaw(id2);
          const original = new Map(selected);
          const items2 = [id2];
          while (items2.length) {
            const item = items2.shift();
            selected.set(item, value ? "on" : "off");
            if (children.has(item)) {
              items2.push(...children.get(item));
            }
          }
          let parent = parents.get(id2);
          while (parent) {
            const childrenIds = children.get(parent);
            const everySelected = childrenIds.every((cid) => selected.get(cid) === "on");
            const noneSelected = childrenIds.every((cid) => !selected.has(cid) || selected.get(cid) === "off");
            selected.set(parent, everySelected ? "on" : noneSelected ? "off" : "indeterminate");
            parent = parents.get(parent);
          }
          if (mandatory && !value) {
            const on = Array.from(selected.entries()).reduce((arr, _ref7) => {
              let [key, value2] = _ref7;
              if (value2 === "on")
                arr.push(key);
              return arr;
            }, []);
            if (on.length === 0)
              return original;
          }
          return selected;
        },
        in: (v, children, parents) => {
          let map2 = /* @__PURE__ */ new Map();
          for (const id2 of v || []) {
            map2 = strategy.select({
              id: id2,
              value: true,
              selected: new Map(map2),
              children,
              parents
            });
          }
          return map2;
        },
        out: (v, children) => {
          const arr = [];
          for (const [key, value] of v.entries()) {
            if (value === "on" && !children.has(key))
              arr.push(key);
          }
          return arr;
        }
      };
      return strategy;
    };
    const VNestedSymbol = Symbol.for("vuetify:nested");
    const emptyNested = {
      id: shallowRef(),
      root: {
        register: () => null,
        unregister: () => null,
        parents: ref$1(/* @__PURE__ */ new Map()),
        children: ref$1(/* @__PURE__ */ new Map()),
        open: () => null,
        openOnSelect: () => null,
        activate: () => null,
        select: () => null,
        activatable: ref$1(false),
        selectable: ref$1(false),
        opened: ref$1(/* @__PURE__ */ new Set()),
        activated: ref$1(/* @__PURE__ */ new Set()),
        selected: ref$1(/* @__PURE__ */ new Map()),
        selectedValues: ref$1([])
      }
    };
    const makeNestedProps = propsFactory({
      activatable: Boolean,
      selectable: Boolean,
      activeStrategy: [String, Function, Object],
      selectStrategy: [String, Function, Object],
      openStrategy: [String, Object],
      opened: null,
      activated: null,
      selected: null,
      mandatory: Boolean
    }, "nested");
    const useNested = (props) => {
      let isUnmounted = false;
      const children = ref$1(/* @__PURE__ */ new Map());
      const parents = ref$1(/* @__PURE__ */ new Map());
      const opened = useProxiedModel(props, "opened", props.opened, (v) => new Set(v), (v) => [...v.values()]);
      const activeStrategy = computed(() => {
        if (typeof props.activeStrategy === "object")
          return props.activeStrategy;
        if (typeof props.activeStrategy === "function")
          return props.activeStrategy(props.mandatory);
        switch (props.activeStrategy) {
          case "leaf":
            return leafActiveStrategy(props.mandatory);
          case "single-leaf":
            return leafSingleActiveStrategy(props.mandatory);
          case "independent":
            return independentActiveStrategy(props.mandatory);
          case "single-independent":
          default:
            return independentSingleActiveStrategy(props.mandatory);
        }
      });
      const selectStrategy = computed(() => {
        if (typeof props.selectStrategy === "object")
          return props.selectStrategy;
        if (typeof props.selectStrategy === "function")
          return props.selectStrategy(props.mandatory);
        switch (props.selectStrategy) {
          case "single-leaf":
            return leafSingleSelectStrategy(props.mandatory);
          case "leaf":
            return leafSelectStrategy(props.mandatory);
          case "independent":
            return independentSelectStrategy(props.mandatory);
          case "single-independent":
            return independentSingleSelectStrategy(props.mandatory);
          case "classic":
          default:
            return classicSelectStrategy(props.mandatory);
        }
      });
      const openStrategy = computed(() => {
        if (typeof props.openStrategy === "object")
          return props.openStrategy;
        switch (props.openStrategy) {
          case "list":
            return listOpenStrategy;
          case "single":
            return singleOpenStrategy;
          case "multiple":
          default:
            return multipleOpenStrategy;
        }
      });
      const activated = useProxiedModel(props, "activated", props.activated, (v) => activeStrategy.value.in(v, children.value, parents.value), (v) => activeStrategy.value.out(v, children.value, parents.value));
      const selected = useProxiedModel(props, "selected", props.selected, (v) => selectStrategy.value.in(v, children.value, parents.value), (v) => selectStrategy.value.out(v, children.value, parents.value));
      onBeforeUnmount(() => {
        isUnmounted = true;
      });
      function getPath(id2) {
        const path = [];
        let parent = id2;
        while (parent != null) {
          path.unshift(parent);
          parent = parents.value.get(parent);
        }
        return path;
      }
      const vm = getCurrentInstance("nested");
      const nested = {
        id: shallowRef(),
        root: {
          opened,
          activatable: toRef(props, "activatable"),
          selectable: toRef(props, "selectable"),
          activated,
          selected,
          selectedValues: computed(() => {
            const arr = [];
            for (const [key, value] of selected.value.entries()) {
              if (value === "on")
                arr.push(key);
            }
            return arr;
          }),
          register: (id2, parentId, isGroup) => {
            parentId && id2 !== parentId && parents.value.set(id2, parentId);
            isGroup && children.value.set(id2, []);
            if (parentId != null) {
              children.value.set(parentId, [...children.value.get(parentId) || [], id2]);
            }
          },
          unregister: (id2) => {
            if (isUnmounted)
              return;
            children.value.delete(id2);
            const parent = parents.value.get(id2);
            if (parent) {
              const list2 = children.value.get(parent) ?? [];
              children.value.set(parent, list2.filter((child) => child !== id2));
            }
            parents.value.delete(id2);
          },
          open: (id2, value, event) => {
            vm.emit("click:open", {
              id: id2,
              value,
              path: getPath(id2),
              event
            });
            const newOpened = openStrategy.value.open({
              id: id2,
              value,
              opened: new Set(opened.value),
              children: children.value,
              parents: parents.value,
              event
            });
            newOpened && (opened.value = newOpened);
          },
          openOnSelect: (id2, value, event) => {
            const newOpened = openStrategy.value.select({
              id: id2,
              value,
              selected: new Map(selected.value),
              opened: new Set(opened.value),
              children: children.value,
              parents: parents.value,
              event
            });
            newOpened && (opened.value = newOpened);
          },
          select: (id2, value, event) => {
            vm.emit("click:select", {
              id: id2,
              value,
              path: getPath(id2),
              event
            });
            const newSelected = selectStrategy.value.select({
              id: id2,
              value,
              selected: new Map(selected.value),
              children: children.value,
              parents: parents.value,
              event
            });
            newSelected && (selected.value = newSelected);
            nested.root.openOnSelect(id2, value, event);
          },
          activate: (id2, value, event) => {
            if (!props.activatable) {
              return nested.root.select(id2, true, event);
            }
            vm.emit("click:activate", {
              id: id2,
              value,
              path: getPath(id2),
              event
            });
            const newActivated = activeStrategy.value.activate({
              id: id2,
              value,
              activated: new Set(activated.value),
              children: children.value,
              parents: parents.value,
              event
            });
            newActivated && (activated.value = newActivated);
          },
          children,
          parents
        }
      };
      provide(VNestedSymbol, nested);
      return nested.root;
    };
    const useNestedItem = (id2, isGroup) => {
      const parent = inject$1(VNestedSymbol, emptyNested);
      const uidSymbol = Symbol(getUid());
      const computedId = computed(() => id2.value !== void 0 ? id2.value : uidSymbol);
      const item = {
        ...parent,
        id: computedId,
        open: (open, e) => parent.root.open(computedId.value, open, e),
        openOnSelect: (open, e) => parent.root.openOnSelect(computedId.value, open, e),
        isOpen: computed(() => parent.root.opened.value.has(computedId.value)),
        parent: computed(() => parent.root.parents.value.get(computedId.value)),
        activate: (activated, e) => parent.root.activate(computedId.value, activated, e),
        isActivated: computed(() => parent.root.activated.value.has(toRaw(computedId.value))),
        select: (selected, e) => parent.root.select(computedId.value, selected, e),
        isSelected: computed(() => parent.root.selected.value.get(toRaw(computedId.value)) === "on"),
        isIndeterminate: computed(() => parent.root.selected.value.get(computedId.value) === "indeterminate"),
        isLeaf: computed(() => !parent.root.children.value.get(computedId.value)),
        isGroupActivator: parent.isGroupActivator
      };
      !parent.isGroupActivator && parent.root.register(computedId.value, parent.id.value, isGroup);
      onBeforeUnmount(() => {
        !parent.isGroupActivator && parent.root.unregister(computedId.value);
      });
      isGroup && provide(VNestedSymbol, item);
      return item;
    };
    const useNestedGroupActivator = () => {
      const parent = inject$1(VNestedSymbol, emptyNested);
      provide(VNestedSymbol, {
        ...parent,
        isGroupActivator: true
      });
    };
    const VListGroupActivator = defineComponent({
      name: "VListGroupActivator",
      setup(_, _ref) {
        let {
          slots
        } = _ref;
        useNestedGroupActivator();
        return () => {
          var _a2;
          return (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
        };
      }
    });
    const makeVListGroupProps = propsFactory({
      /* @deprecated */
      activeColor: String,
      baseColor: String,
      color: String,
      collapseIcon: {
        type: IconValue,
        default: "$collapse"
      },
      expandIcon: {
        type: IconValue,
        default: "$expand"
      },
      prependIcon: IconValue,
      appendIcon: IconValue,
      fluid: Boolean,
      subgroup: Boolean,
      title: String,
      value: null,
      ...makeComponentProps(),
      ...makeTagProps()
    }, "VListGroup");
    const VListGroup = genericComponent()({
      name: "VListGroup",
      props: makeVListGroupProps(),
      setup(props, _ref2) {
        let {
          slots
        } = _ref2;
        const {
          isOpen,
          open,
          id: _id
        } = useNestedItem(toRef(props, "value"), true);
        const id2 = computed(() => `v-list-group--id-${String(_id.value)}`);
        const list2 = useList();
        const {
          isBooted
        } = useSsrBoot();
        function onClick(e) {
          e.stopPropagation();
          open(!isOpen.value, e);
        }
        const activatorProps = computed(() => ({
          onClick,
          class: "v-list-group__header",
          id: id2.value
        }));
        const toggleIcon = computed(() => isOpen.value ? props.collapseIcon : props.expandIcon);
        const activatorDefaults = computed(() => ({
          VListItem: {
            active: isOpen.value,
            activeColor: props.activeColor,
            baseColor: props.baseColor,
            color: props.color,
            prependIcon: props.prependIcon || props.subgroup && toggleIcon.value,
            appendIcon: props.appendIcon || !props.subgroup && toggleIcon.value,
            title: props.title,
            value: props.value
          }
        }));
        useRender(() => createVNode(props.tag, {
          "class": ["v-list-group", {
            "v-list-group--prepend": list2 == null ? void 0 : list2.hasPrepend.value,
            "v-list-group--fluid": props.fluid,
            "v-list-group--subgroup": props.subgroup,
            "v-list-group--open": isOpen.value
          }, props.class],
          "style": props.style
        }, {
          default: () => [slots.activator && createVNode(VDefaultsProvider, {
            "defaults": activatorDefaults.value
          }, {
            default: () => [createVNode(VListGroupActivator, null, {
              default: () => [slots.activator({
                props: activatorProps.value,
                isOpen: isOpen.value
              })]
            })]
          }), createVNode(MaybeTransition, {
            "transition": {
              component: VExpandTransition
            },
            "disabled": !isBooted.value
          }, {
            default: () => {
              var _a2;
              return [withDirectives(createVNode("div", {
                "class": "v-list-group__items",
                "role": "group",
                "aria-labelledby": id2.value
              }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), [[vShow, isOpen.value]])];
            }
          })]
        }));
        return {
          isOpen
        };
      }
    });
    const makeVListItemSubtitleProps = propsFactory({
      opacity: [Number, String],
      ...makeComponentProps(),
      ...makeTagProps()
    }, "VListItemSubtitle");
    const VListItemSubtitle = genericComponent()({
      name: "VListItemSubtitle",
      props: makeVListItemSubtitleProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        useRender(() => createVNode(props.tag, {
          "class": ["v-list-item-subtitle", props.class],
          "style": [{
            "--v-list-item-subtitle-opacity": props.opacity
          }, props.style]
        }, slots));
        return {};
      }
    });
    const VListItemTitle = createSimpleFunctional("v-list-item-title");
    const makeVListItemProps = propsFactory({
      active: {
        type: Boolean,
        default: void 0
      },
      activeClass: String,
      /* @deprecated */
      activeColor: String,
      appendAvatar: String,
      appendIcon: IconValue,
      baseColor: String,
      disabled: Boolean,
      lines: [Boolean, String],
      link: {
        type: Boolean,
        default: void 0
      },
      nav: Boolean,
      prependAvatar: String,
      prependIcon: IconValue,
      ripple: {
        type: [Boolean, Object],
        default: true
      },
      slim: Boolean,
      subtitle: [String, Number],
      title: [String, Number],
      value: null,
      onClick: EventProp(),
      onClickOnce: EventProp(),
      ...makeBorderProps(),
      ...makeComponentProps(),
      ...makeDensityProps(),
      ...makeDimensionProps(),
      ...makeElevationProps(),
      ...makeRoundedProps(),
      ...makeRouterProps(),
      ...makeTagProps(),
      ...makeThemeProps(),
      ...makeVariantProps({
        variant: "text"
      })
    }, "VListItem");
    const VListItem = genericComponent()({
      name: "VListItem",
      directives: {
        Ripple
      },
      props: makeVListItemProps(),
      emits: {
        click: (e) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          slots,
          emit: emit2
        } = _ref;
        const link2 = useLink(props, attrs);
        const id2 = computed(() => props.value === void 0 ? link2.href.value : props.value);
        const {
          activate,
          isActivated,
          select,
          isSelected,
          isIndeterminate,
          isGroupActivator,
          root,
          parent,
          openOnSelect
        } = useNestedItem(id2, false);
        const list2 = useList();
        const isActive = computed(() => {
          var _a2;
          return props.active !== false && (props.active || ((_a2 = link2.isActive) == null ? void 0 : _a2.value) || (root.activatable.value ? isActivated.value : isSelected.value));
        });
        const isLink = computed(() => props.link !== false && link2.isLink.value);
        const isClickable = computed(() => !props.disabled && props.link !== false && (props.link || link2.isClickable.value || !!list2 && (root.selectable.value || root.activatable.value || props.value != null)));
        const roundedProps = computed(() => props.rounded || props.nav);
        const color = computed(() => props.color ?? props.activeColor);
        const variantProps = computed(() => ({
          color: isActive.value ? color.value ?? props.baseColor : props.baseColor,
          variant: props.variant
        }));
        watch(() => {
          var _a2;
          return (_a2 = link2.isActive) == null ? void 0 : _a2.value;
        }, (val) => {
          if (val && parent.value != null) {
            root.open(parent.value, true);
          }
          if (val) {
            openOnSelect(val);
          }
        }, {
          immediate: true
        });
        const {
          themeClasses
        } = provideTheme(props);
        const {
          borderClasses
        } = useBorder(props);
        const {
          colorClasses,
          colorStyles,
          variantClasses
        } = useVariant(variantProps);
        const {
          densityClasses
        } = useDensity(props);
        const {
          dimensionStyles
        } = useDimension(props);
        const {
          elevationClasses
        } = useElevation(props);
        const {
          roundedClasses
        } = useRounded(roundedProps);
        const lineClasses = computed(() => props.lines ? `v-list-item--${props.lines}-line` : void 0);
        const slotProps = computed(() => ({
          isActive: isActive.value,
          select,
          isSelected: isSelected.value,
          isIndeterminate: isIndeterminate.value
        }));
        function onClick(e) {
          var _a2;
          emit2("click", e);
          if (!isClickable.value)
            return;
          (_a2 = link2.navigate) == null ? void 0 : _a2.call(link2, e);
          if (isGroupActivator)
            return;
          if (root.activatable.value) {
            activate(!isActivated.value, e);
          } else if (root.selectable.value) {
            select(!isSelected.value, e);
          } else if (props.value != null) {
            select(!isSelected.value, e);
          }
        }
        function onKeyDown(e) {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            onClick(e);
          }
        }
        useRender(() => {
          const Tag2 = isLink.value ? "a" : props.tag;
          const hasTitle = slots.title || props.title != null;
          const hasSubtitle = slots.subtitle || props.subtitle != null;
          const hasAppendMedia = !!(props.appendAvatar || props.appendIcon);
          const hasAppend = !!(hasAppendMedia || slots.append);
          const hasPrependMedia = !!(props.prependAvatar || props.prependIcon);
          const hasPrepend = !!(hasPrependMedia || slots.prepend);
          list2 == null ? void 0 : list2.updateHasPrepend(hasPrepend);
          if (props.activeColor) {
            deprecate("active-color", ["color", "base-color"]);
          }
          return withDirectives(createVNode(Tag2, {
            "class": ["v-list-item", {
              "v-list-item--active": isActive.value,
              "v-list-item--disabled": props.disabled,
              "v-list-item--link": isClickable.value,
              "v-list-item--nav": props.nav,
              "v-list-item--prepend": !hasPrepend && (list2 == null ? void 0 : list2.hasPrepend.value),
              "v-list-item--slim": props.slim,
              [`${props.activeClass}`]: props.activeClass && isActive.value
            }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, lineClasses.value, roundedClasses.value, variantClasses.value, props.class],
            "style": [colorStyles.value, dimensionStyles.value, props.style],
            "href": link2.href.value,
            "tabindex": isClickable.value ? list2 ? -2 : 0 : void 0,
            "onClick": onClick,
            "onKeydown": isClickable.value && !isLink.value && onKeyDown
          }, {
            default: () => {
              var _a2;
              return [genOverlays(isClickable.value || isActive.value, "v-list-item"), hasPrepend && createVNode("div", {
                "key": "prepend",
                "class": "v-list-item__prepend"
              }, [!slots.prepend ? createVNode(Fragment, null, [props.prependAvatar && createVNode(VAvatar, {
                "key": "prepend-avatar",
                "density": props.density,
                "image": props.prependAvatar
              }, null), props.prependIcon && createVNode(VIcon, {
                "key": "prepend-icon",
                "density": props.density,
                "icon": props.prependIcon
              }, null)]) : createVNode(VDefaultsProvider, {
                "key": "prepend-defaults",
                "disabled": !hasPrependMedia,
                "defaults": {
                  VAvatar: {
                    density: props.density,
                    image: props.prependAvatar
                  },
                  VIcon: {
                    density: props.density,
                    icon: props.prependIcon
                  },
                  VListItemAction: {
                    start: true
                  }
                }
              }, {
                default: () => {
                  var _a3;
                  return [(_a3 = slots.prepend) == null ? void 0 : _a3.call(slots, slotProps.value)];
                }
              }), createVNode("div", {
                "class": "v-list-item__spacer"
              }, null)]), createVNode("div", {
                "class": "v-list-item__content",
                "data-no-activator": ""
              }, [hasTitle && createVNode(VListItemTitle, {
                "key": "title"
              }, {
                default: () => {
                  var _a3;
                  return [((_a3 = slots.title) == null ? void 0 : _a3.call(slots, {
                    title: props.title
                  })) ?? props.title];
                }
              }), hasSubtitle && createVNode(VListItemSubtitle, {
                "key": "subtitle"
              }, {
                default: () => {
                  var _a3;
                  return [((_a3 = slots.subtitle) == null ? void 0 : _a3.call(slots, {
                    subtitle: props.subtitle
                  })) ?? props.subtitle];
                }
              }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots, slotProps.value)]), hasAppend && createVNode("div", {
                "key": "append",
                "class": "v-list-item__append"
              }, [!slots.append ? createVNode(Fragment, null, [props.appendIcon && createVNode(VIcon, {
                "key": "append-icon",
                "density": props.density,
                "icon": props.appendIcon
              }, null), props.appendAvatar && createVNode(VAvatar, {
                "key": "append-avatar",
                "density": props.density,
                "image": props.appendAvatar
              }, null)]) : createVNode(VDefaultsProvider, {
                "key": "append-defaults",
                "disabled": !hasAppendMedia,
                "defaults": {
                  VAvatar: {
                    density: props.density,
                    image: props.appendAvatar
                  },
                  VIcon: {
                    density: props.density,
                    icon: props.appendIcon
                  },
                  VListItemAction: {
                    end: true
                  }
                }
              }, {
                default: () => {
                  var _a3;
                  return [(_a3 = slots.append) == null ? void 0 : _a3.call(slots, slotProps.value)];
                }
              }), createVNode("div", {
                "class": "v-list-item__spacer"
              }, null)])];
            }
          }), [[resolveDirective("ripple"), isClickable.value && props.ripple]]);
        });
        return {
          activate,
          isActivated,
          isGroupActivator,
          isSelected,
          list: list2,
          select
        };
      }
    });
    const makeVListSubheaderProps = propsFactory({
      color: String,
      inset: Boolean,
      sticky: Boolean,
      title: String,
      ...makeComponentProps(),
      ...makeTagProps()
    }, "VListSubheader");
    const VListSubheader = genericComponent()({
      name: "VListSubheader",
      props: makeVListSubheaderProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          textColorClasses,
          textColorStyles
        } = useTextColor(toRef(props, "color"));
        useRender(() => {
          const hasText = !!(slots.default || props.title);
          return createVNode(props.tag, {
            "class": ["v-list-subheader", {
              "v-list-subheader--inset": props.inset,
              "v-list-subheader--sticky": props.sticky
            }, textColorClasses.value, props.class],
            "style": [{
              textColorStyles
            }, props.style]
          }, {
            default: () => {
              var _a2;
              return [hasText && createVNode("div", {
                "class": "v-list-subheader__text"
              }, [((_a2 = slots.default) == null ? void 0 : _a2.call(slots)) ?? props.title])];
            }
          });
        });
        return {};
      }
    });
    const makeVDividerProps = propsFactory({
      color: String,
      inset: Boolean,
      length: [Number, String],
      opacity: [Number, String],
      thickness: [Number, String],
      vertical: Boolean,
      ...makeComponentProps(),
      ...makeThemeProps()
    }, "VDivider");
    const VDivider = genericComponent()({
      name: "VDivider",
      props: makeVDividerProps(),
      setup(props, _ref) {
        let {
          attrs,
          slots
        } = _ref;
        const {
          themeClasses
        } = provideTheme(props);
        const {
          textColorClasses,
          textColorStyles
        } = useTextColor(toRef(props, "color"));
        const dividerStyles = computed(() => {
          const styles = {};
          if (props.length) {
            styles[props.vertical ? "height" : "width"] = convertToUnit(props.length);
          }
          if (props.thickness) {
            styles[props.vertical ? "borderRightWidth" : "borderTopWidth"] = convertToUnit(props.thickness);
          }
          return styles;
        });
        useRender(() => {
          const divider = createVNode("hr", {
            "class": [{
              "v-divider": true,
              "v-divider--inset": props.inset,
              "v-divider--vertical": props.vertical
            }, themeClasses.value, textColorClasses.value, props.class],
            "style": [dividerStyles.value, textColorStyles.value, {
              "--v-border-opacity": props.opacity
            }, props.style],
            "aria-orientation": !attrs.role || attrs.role === "separator" ? props.vertical ? "vertical" : "horizontal" : void 0,
            "role": `${attrs.role || "separator"}`
          }, null);
          if (!slots.default)
            return divider;
          return createVNode("div", {
            "class": ["v-divider__wrapper", {
              "v-divider__wrapper--vertical": props.vertical,
              "v-divider__wrapper--inset": props.inset
            }]
          }, [divider, createVNode("div", {
            "class": "v-divider__content"
          }, [slots.default()]), divider]);
        });
        return {};
      }
    });
    const makeVListChildrenProps = propsFactory({
      items: Array,
      returnObject: Boolean
    }, "VListChildren");
    const VListChildren = genericComponent()({
      name: "VListChildren",
      props: makeVListChildrenProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        createList();
        return () => {
          var _a2, _b;
          return ((_a2 = slots.default) == null ? void 0 : _a2.call(slots)) ?? ((_b = props.items) == null ? void 0 : _b.map((_ref2) => {
            var _a3, _b2;
            let {
              children,
              props: itemProps,
              type: type2,
              raw: item
            } = _ref2;
            if (type2 === "divider") {
              return ((_a3 = slots.divider) == null ? void 0 : _a3.call(slots, {
                props: itemProps
              })) ?? createVNode(VDivider, itemProps, null);
            }
            if (type2 === "subheader") {
              return ((_b2 = slots.subheader) == null ? void 0 : _b2.call(slots, {
                props: itemProps
              })) ?? createVNode(VListSubheader, itemProps, null);
            }
            const slotsWithItem = {
              subtitle: slots.subtitle ? (slotProps) => {
                var _a4;
                return (_a4 = slots.subtitle) == null ? void 0 : _a4.call(slots, {
                  ...slotProps,
                  item
                });
              } : void 0,
              prepend: slots.prepend ? (slotProps) => {
                var _a4;
                return (_a4 = slots.prepend) == null ? void 0 : _a4.call(slots, {
                  ...slotProps,
                  item
                });
              } : void 0,
              append: slots.append ? (slotProps) => {
                var _a4;
                return (_a4 = slots.append) == null ? void 0 : _a4.call(slots, {
                  ...slotProps,
                  item
                });
              } : void 0,
              title: slots.title ? (slotProps) => {
                var _a4;
                return (_a4 = slots.title) == null ? void 0 : _a4.call(slots, {
                  ...slotProps,
                  item
                });
              } : void 0
            };
            const listGroupProps = VListGroup.filterProps(itemProps);
            return children ? createVNode(VListGroup, mergeProps({
              "value": itemProps == null ? void 0 : itemProps.value
            }, listGroupProps), {
              activator: (_ref3) => {
                let {
                  props: activatorProps
                } = _ref3;
                const listItemProps = {
                  ...itemProps,
                  ...activatorProps,
                  value: props.returnObject ? item : itemProps.value
                };
                return slots.header ? slots.header({
                  props: listItemProps
                }) : createVNode(VListItem, listItemProps, slotsWithItem);
              },
              default: () => createVNode(VListChildren, {
                "items": children,
                "returnObject": props.returnObject
              }, slots)
            }) : slots.item ? slots.item({
              props: itemProps
            }) : createVNode(VListItem, mergeProps(itemProps, {
              "value": props.returnObject ? item : itemProps.value
            }), slotsWithItem);
          }));
        };
      }
    });
    const makeItemsProps = propsFactory({
      items: {
        type: Array,
        default: () => []
      },
      itemTitle: {
        type: [String, Array, Function],
        default: "title"
      },
      itemValue: {
        type: [String, Array, Function],
        default: "value"
      },
      itemChildren: {
        type: [Boolean, String, Array, Function],
        default: "children"
      },
      itemProps: {
        type: [Boolean, String, Array, Function],
        default: "props"
      },
      returnObject: Boolean,
      valueComparator: {
        type: Function,
        default: deepEqual
      }
    }, "list-items");
    function transformItem$1(props, item) {
      const title2 = getPropertyFromItem(item, props.itemTitle, item);
      const value = getPropertyFromItem(item, props.itemValue, title2);
      const children = getPropertyFromItem(item, props.itemChildren);
      const itemProps = props.itemProps === true ? typeof item === "object" && item != null && !Array.isArray(item) ? "children" in item ? omit$1(item, ["children"]) : item : void 0 : getPropertyFromItem(item, props.itemProps);
      const _props = {
        title: title2,
        value,
        ...itemProps
      };
      return {
        title: String(_props.title ?? ""),
        value: _props.value,
        props: _props,
        children: Array.isArray(children) ? transformItems$1(props, children) : void 0,
        raw: item
      };
    }
    function transformItems$1(props, items2) {
      const array = [];
      for (const item of items2) {
        array.push(transformItem$1(props, item));
      }
      return array;
    }
    function useItems(props) {
      const items2 = computed(() => transformItems$1(props, props.items));
      const hasNullItem = computed(() => items2.value.some((item) => item.value === null));
      function transformIn(value) {
        if (!hasNullItem.value) {
          value = value.filter((v) => v !== null);
        }
        return value.map((v) => {
          if (props.returnObject && typeof v === "string") {
            return transformItem$1(props, v);
          }
          return items2.value.find((item) => props.valueComparator(v, item.value)) || transformItem$1(props, v);
        });
      }
      function transformOut(value) {
        return props.returnObject ? value.map((_ref) => {
          let {
            raw
          } = _ref;
          return raw;
        }) : value.map((_ref2) => {
          let {
            value: value2
          } = _ref2;
          return value2;
        });
      }
      return {
        items: items2,
        transformIn,
        transformOut
      };
    }
    function isPrimitive(value) {
      return typeof value === "string" || typeof value === "number" || typeof value === "boolean";
    }
    function transformItem(props, item) {
      const type2 = getPropertyFromItem(item, props.itemType, "item");
      const title2 = isPrimitive(item) ? item : getPropertyFromItem(item, props.itemTitle);
      const value = getPropertyFromItem(item, props.itemValue, void 0);
      const children = getPropertyFromItem(item, props.itemChildren);
      const itemProps = props.itemProps === true ? omit$1(item, ["children"]) : getPropertyFromItem(item, props.itemProps);
      const _props = {
        title: title2,
        value,
        ...itemProps
      };
      return {
        type: type2,
        title: _props.title,
        value: _props.value,
        props: _props,
        children: type2 === "item" && children ? transformItems(props, children) : void 0,
        raw: item
      };
    }
    function transformItems(props, items2) {
      const array = [];
      for (const item of items2) {
        array.push(transformItem(props, item));
      }
      return array;
    }
    function useListItems(props) {
      const items2 = computed(() => transformItems(props, props.items));
      return {
        items: items2
      };
    }
    const makeVListProps = propsFactory({
      baseColor: String,
      /* @deprecated */
      activeColor: String,
      activeClass: String,
      bgColor: String,
      disabled: Boolean,
      expandIcon: String,
      collapseIcon: String,
      lines: {
        type: [Boolean, String],
        default: "one"
      },
      slim: Boolean,
      nav: Boolean,
      "onClick:open": EventProp(),
      "onClick:select": EventProp(),
      "onUpdate:opened": EventProp(),
      ...makeNestedProps({
        selectStrategy: "single-leaf",
        openStrategy: "list"
      }),
      ...makeBorderProps(),
      ...makeComponentProps(),
      ...makeDensityProps(),
      ...makeDimensionProps(),
      ...makeElevationProps(),
      itemType: {
        type: String,
        default: "type"
      },
      ...makeItemsProps(),
      ...makeRoundedProps(),
      ...makeTagProps(),
      ...makeThemeProps(),
      ...makeVariantProps({
        variant: "text"
      })
    }, "VList");
    const VList = genericComponent()({
      name: "VList",
      props: makeVListProps(),
      emits: {
        "update:selected": (value) => true,
        "update:activated": (value) => true,
        "update:opened": (value) => true,
        "click:open": (value) => true,
        "click:activate": (value) => true,
        "click:select": (value) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          items: items2
        } = useListItems(props);
        const {
          themeClasses
        } = provideTheme(props);
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(toRef(props, "bgColor"));
        const {
          borderClasses
        } = useBorder(props);
        const {
          densityClasses
        } = useDensity(props);
        const {
          dimensionStyles
        } = useDimension(props);
        const {
          elevationClasses
        } = useElevation(props);
        const {
          roundedClasses
        } = useRounded(props);
        const {
          children,
          open,
          parents,
          select
        } = useNested(props);
        const lineClasses = computed(() => props.lines ? `v-list--${props.lines}-line` : void 0);
        const activeColor = toRef(props, "activeColor");
        const baseColor = toRef(props, "baseColor");
        const color = toRef(props, "color");
        createList();
        provideDefaults({
          VListGroup: {
            activeColor,
            baseColor,
            color,
            expandIcon: toRef(props, "expandIcon"),
            collapseIcon: toRef(props, "collapseIcon")
          },
          VListItem: {
            activeClass: toRef(props, "activeClass"),
            activeColor,
            baseColor,
            color,
            density: toRef(props, "density"),
            disabled: toRef(props, "disabled"),
            lines: toRef(props, "lines"),
            nav: toRef(props, "nav"),
            slim: toRef(props, "slim"),
            variant: toRef(props, "variant")
          }
        });
        const isFocused = shallowRef(false);
        const contentRef = ref$1();
        function onFocusin(e) {
          isFocused.value = true;
        }
        function onFocusout(e) {
          isFocused.value = false;
        }
        function onFocus(e) {
          var _a2;
          if (!isFocused.value && !(e.relatedTarget && ((_a2 = contentRef.value) == null ? void 0 : _a2.contains(e.relatedTarget))))
            focus();
        }
        function onKeydown(e) {
          const target2 = e.target;
          if (!contentRef.value || ["INPUT", "TEXTAREA"].includes(target2.tagName))
            return;
          if (e.key === "ArrowDown") {
            focus("next");
          } else if (e.key === "ArrowUp") {
            focus("prev");
          } else if (e.key === "Home") {
            focus("first");
          } else if (e.key === "End") {
            focus("last");
          } else {
            return;
          }
          e.preventDefault();
        }
        function onMousedown(e) {
          isFocused.value = true;
        }
        function focus(location2) {
          if (contentRef.value) {
            return focusChild(contentRef.value, location2);
          }
        }
        useRender(() => {
          return createVNode(props.tag, {
            "ref": contentRef,
            "class": ["v-list", {
              "v-list--disabled": props.disabled,
              "v-list--nav": props.nav,
              "v-list--slim": props.slim
            }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, lineClasses.value, roundedClasses.value, props.class],
            "style": [backgroundColorStyles.value, dimensionStyles.value, props.style],
            "tabindex": props.disabled || isFocused.value ? -1 : 0,
            "role": "listbox",
            "aria-activedescendant": void 0,
            "onFocusin": onFocusin,
            "onFocusout": onFocusout,
            "onFocus": onFocus,
            "onKeydown": onKeydown,
            "onMousedown": onMousedown
          }, {
            default: () => [createVNode(VListChildren, {
              "items": items2.value,
              "returnObject": props.returnObject
            }, slots)]
          });
        });
        return {
          open,
          select,
          focus,
          children,
          parents
        };
      }
    });
    const makeVListItemActionProps = propsFactory({
      start: Boolean,
      end: Boolean,
      ...makeComponentProps(),
      ...makeTagProps()
    }, "VListItemAction");
    const VListItemAction = genericComponent()({
      name: "VListItemAction",
      props: makeVListItemActionProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        useRender(() => createVNode(props.tag, {
          "class": ["v-list-item-action", {
            "v-list-item-action--start": props.start,
            "v-list-item-action--end": props.end
          }, props.class],
          "style": props.style
        }, slots));
        return {};
      }
    });
    const makeVMainProps = propsFactory({
      scrollable: Boolean,
      ...makeComponentProps(),
      ...makeDimensionProps(),
      ...makeTagProps({
        tag: "main"
      })
    }, "VMain");
    const VMain = genericComponent()({
      name: "VMain",
      props: makeVMainProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          dimensionStyles
        } = useDimension(props);
        const {
          mainStyles,
          layoutIsReady
        } = useLayout();
        const {
          ssrBootStyles
        } = useSsrBoot();
        useRender(() => createVNode(props.tag, {
          "class": ["v-main", {
            "v-main--scrollable": props.scrollable
          }, props.class],
          "style": [mainStyles.value, ssrBootStyles.value, dimensionStyles.value, props.style]
        }, {
          default: () => {
            var _a2, _b;
            return [props.scrollable ? createVNode("div", {
              "class": "v-main__scroller"
            }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]) : (_b = slots.default) == null ? void 0 : _b.call(slots)];
          }
        }));
        return layoutIsReady;
      }
    });
    function useSticky(_ref) {
      let {
        rootEl,
        isSticky,
        layoutItemStyles
      } = _ref;
      const isStuck = shallowRef(false);
      const stuckPosition = shallowRef(0);
      const stickyStyles = computed(() => {
        const side = typeof isStuck.value === "boolean" ? "top" : isStuck.value;
        return [isSticky.value ? {
          top: "auto",
          bottom: "auto",
          height: void 0
        } : void 0, isStuck.value ? {
          [side]: convertToUnit(stuckPosition.value)
        } : {
          top: layoutItemStyles.value.top
        }];
      });
      onMounted(() => {
        watch(isSticky, (val) => {
          if (val) {
            window.addEventListener("scroll", onScroll, {
              passive: true
            });
          } else {
            window.removeEventListener("scroll", onScroll);
          }
        }, {
          immediate: true
        });
      });
      onBeforeUnmount(() => {
        window.removeEventListener("scroll", onScroll);
      });
      let lastScrollTop = 0;
      function onScroll() {
        const direction = lastScrollTop > window.scrollY ? "up" : "down";
        const rect2 = rootEl.value.getBoundingClientRect();
        const layoutTop = parseFloat(layoutItemStyles.value.top ?? 0);
        const top2 = window.scrollY - Math.max(0, stuckPosition.value - layoutTop);
        const bottom2 = rect2.height + Math.max(stuckPosition.value, layoutTop) - window.scrollY - window.innerHeight;
        const bodyScroll = parseFloat(getComputedStyle(rootEl.value).getPropertyValue("--v-body-scroll-y")) || 0;
        if (rect2.height < window.innerHeight - layoutTop) {
          isStuck.value = "top";
          stuckPosition.value = layoutTop;
        } else if (direction === "up" && isStuck.value === "bottom" || direction === "down" && isStuck.value === "top") {
          stuckPosition.value = window.scrollY + rect2.top - bodyScroll;
          isStuck.value = true;
        } else if (direction === "down" && bottom2 <= 0) {
          stuckPosition.value = 0;
          isStuck.value = "bottom";
        } else if (direction === "up" && top2 <= 0) {
          if (!bodyScroll) {
            stuckPosition.value = rect2.top + top2;
            isStuck.value = "top";
          } else if (isStuck.value !== "top") {
            stuckPosition.value = -top2 + bodyScroll + layoutTop;
            isStuck.value = "top";
          }
        }
        lastScrollTop = window.scrollY;
      }
      return {
        isStuck,
        stickyStyles
      };
    }
    const HORIZON = 100;
    const HISTORY = 20;
    function kineticEnergyToVelocity(work) {
      const sqrt2 = 1.41421356237;
      return (work < 0 ? -1 : 1) * Math.sqrt(Math.abs(work)) * sqrt2;
    }
    function calculateImpulseVelocity(samples) {
      if (samples.length < 2) {
        return 0;
      }
      if (samples.length === 2) {
        if (samples[1].t === samples[0].t) {
          return 0;
        }
        return (samples[1].d - samples[0].d) / (samples[1].t - samples[0].t);
      }
      let work = 0;
      for (let i2 = samples.length - 1; i2 > 0; i2--) {
        if (samples[i2].t === samples[i2 - 1].t) {
          continue;
        }
        const vprev = kineticEnergyToVelocity(work);
        const vcurr = (samples[i2].d - samples[i2 - 1].d) / (samples[i2].t - samples[i2 - 1].t);
        work += (vcurr - vprev) * Math.abs(vcurr);
        if (i2 === samples.length - 1) {
          work *= 0.5;
        }
      }
      return kineticEnergyToVelocity(work) * 1e3;
    }
    function useVelocity() {
      const touches = {};
      function addMovement(e) {
        Array.from(e.changedTouches).forEach((touch) => {
          const samples = touches[touch.identifier] ?? (touches[touch.identifier] = new CircularBuffer(HISTORY));
          samples.push([e.timeStamp, touch]);
        });
      }
      function endTouch(e) {
        Array.from(e.changedTouches).forEach((touch) => {
          delete touches[touch.identifier];
        });
      }
      function getVelocity(id2) {
        var _a2;
        const samples = (_a2 = touches[id2]) == null ? void 0 : _a2.values().reverse();
        if (!samples) {
          throw new Error(`No samples for touch id ${id2}`);
        }
        const newest = samples[0];
        const x2 = [];
        const y = [];
        for (const val of samples) {
          if (newest[0] - val[0] > HORIZON)
            break;
          x2.push({
            t: val[0],
            d: val[1].clientX
          });
          y.push({
            t: val[0],
            d: val[1].clientY
          });
        }
        return {
          x: calculateImpulseVelocity(x2),
          y: calculateImpulseVelocity(y),
          get direction() {
            const {
              x: x3,
              y: y2
            } = this;
            const [absX, absY] = [Math.abs(x3), Math.abs(y2)];
            return absX > absY && x3 >= 0 ? "right" : absX > absY && x3 <= 0 ? "left" : absY > absX && y2 >= 0 ? "down" : absY > absX && y2 <= 0 ? "up" : oops$1();
          }
        };
      }
      return {
        addMovement,
        endTouch,
        getVelocity
      };
    }
    function oops$1() {
      throw new Error();
    }
    function useTouch(_ref) {
      let {
        el: el2,
        isActive,
        isTemporary,
        width,
        touchless,
        position
      } = _ref;
      onMounted(() => {
        window.addEventListener("touchstart", onTouchstart, {
          passive: true
        });
        window.addEventListener("touchmove", onTouchmove, {
          passive: false
        });
        window.addEventListener("touchend", onTouchend, {
          passive: true
        });
      });
      onBeforeUnmount(() => {
        window.removeEventListener("touchstart", onTouchstart);
        window.removeEventListener("touchmove", onTouchmove);
        window.removeEventListener("touchend", onTouchend);
      });
      const isHorizontal = computed(() => ["left", "right"].includes(position.value));
      const {
        addMovement,
        endTouch,
        getVelocity
      } = useVelocity();
      let maybeDragging = false;
      const isDragging = shallowRef(false);
      const dragProgress = shallowRef(0);
      const offset = shallowRef(0);
      let start;
      function getOffset2(pos, active) {
        return (position.value === "left" ? pos : position.value === "right" ? document.documentElement.clientWidth - pos : position.value === "top" ? pos : position.value === "bottom" ? document.documentElement.clientHeight - pos : oops()) - (active ? width.value : 0);
      }
      function getProgress(pos) {
        let limit2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        const progress = position.value === "left" ? (pos - offset.value) / width.value : position.value === "right" ? (document.documentElement.clientWidth - pos - offset.value) / width.value : position.value === "top" ? (pos - offset.value) / width.value : position.value === "bottom" ? (document.documentElement.clientHeight - pos - offset.value) / width.value : oops();
        return limit2 ? Math.max(0, Math.min(1, progress)) : progress;
      }
      function onTouchstart(e) {
        if (touchless.value)
          return;
        const touchX = e.changedTouches[0].clientX;
        const touchY = e.changedTouches[0].clientY;
        const touchZone = 25;
        const inTouchZone = position.value === "left" ? touchX < touchZone : position.value === "right" ? touchX > document.documentElement.clientWidth - touchZone : position.value === "top" ? touchY < touchZone : position.value === "bottom" ? touchY > document.documentElement.clientHeight - touchZone : oops();
        const inElement = isActive.value && (position.value === "left" ? touchX < width.value : position.value === "right" ? touchX > document.documentElement.clientWidth - width.value : position.value === "top" ? touchY < width.value : position.value === "bottom" ? touchY > document.documentElement.clientHeight - width.value : oops());
        if (inTouchZone || inElement || isActive.value && isTemporary.value) {
          start = [touchX, touchY];
          offset.value = getOffset2(isHorizontal.value ? touchX : touchY, isActive.value);
          dragProgress.value = getProgress(isHorizontal.value ? touchX : touchY);
          maybeDragging = offset.value > -20 && offset.value < 80;
          endTouch(e);
          addMovement(e);
        }
      }
      function onTouchmove(e) {
        const touchX = e.changedTouches[0].clientX;
        const touchY = e.changedTouches[0].clientY;
        if (maybeDragging) {
          if (!e.cancelable) {
            maybeDragging = false;
            return;
          }
          const dx = Math.abs(touchX - start[0]);
          const dy = Math.abs(touchY - start[1]);
          const thresholdMet = isHorizontal.value ? dx > dy && dx > 3 : dy > dx && dy > 3;
          if (thresholdMet) {
            isDragging.value = true;
            maybeDragging = false;
          } else if ((isHorizontal.value ? dy : dx) > 3) {
            maybeDragging = false;
          }
        }
        if (!isDragging.value)
          return;
        e.preventDefault();
        addMovement(e);
        const progress = getProgress(isHorizontal.value ? touchX : touchY, false);
        dragProgress.value = Math.max(0, Math.min(1, progress));
        if (progress > 1) {
          offset.value = getOffset2(isHorizontal.value ? touchX : touchY, true);
        } else if (progress < 0) {
          offset.value = getOffset2(isHorizontal.value ? touchX : touchY, false);
        }
      }
      function onTouchend(e) {
        maybeDragging = false;
        if (!isDragging.value)
          return;
        addMovement(e);
        isDragging.value = false;
        const velocity = getVelocity(e.changedTouches[0].identifier);
        const vx = Math.abs(velocity.x);
        const vy = Math.abs(velocity.y);
        const thresholdMet = isHorizontal.value ? vx > vy && vx > 400 : vy > vx && vy > 3;
        if (thresholdMet) {
          isActive.value = velocity.direction === ({
            left: "right",
            right: "left",
            top: "down",
            bottom: "up"
          }[position.value] || oops());
        } else {
          isActive.value = dragProgress.value > 0.5;
        }
      }
      const dragStyles = computed(() => {
        return isDragging.value ? {
          transform: position.value === "left" ? `translateX(calc(-100% + ${dragProgress.value * width.value}px))` : position.value === "right" ? `translateX(calc(100% - ${dragProgress.value * width.value}px))` : position.value === "top" ? `translateY(calc(-100% + ${dragProgress.value * width.value}px))` : position.value === "bottom" ? `translateY(calc(100% - ${dragProgress.value * width.value}px))` : oops(),
          transition: "none"
        } : void 0;
      });
      useToggleScope(isDragging, () => {
        var _a2, _b;
        const transform2 = ((_a2 = el2.value) == null ? void 0 : _a2.style.transform) ?? null;
        const transition = ((_b = el2.value) == null ? void 0 : _b.style.transition) ?? null;
        watchEffect(() => {
          var _a3, _b2, _c, _d;
          (_b2 = el2.value) == null ? void 0 : _b2.style.setProperty("transform", ((_a3 = dragStyles.value) == null ? void 0 : _a3.transform) || "none");
          (_d = el2.value) == null ? void 0 : _d.style.setProperty("transition", ((_c = dragStyles.value) == null ? void 0 : _c.transition) || null);
        });
        onScopeDispose(() => {
          var _a3, _b2;
          (_a3 = el2.value) == null ? void 0 : _a3.style.setProperty("transform", transform2);
          (_b2 = el2.value) == null ? void 0 : _b2.style.setProperty("transition", transition);
        });
      });
      return {
        isDragging,
        dragProgress,
        dragStyles
      };
    }
    function oops() {
      throw new Error();
    }
    const firstDay = {
      "001": 1,
      AD: 1,
      AE: 6,
      AF: 6,
      AG: 0,
      AI: 1,
      AL: 1,
      AM: 1,
      AN: 1,
      AR: 1,
      AS: 0,
      AT: 1,
      AU: 1,
      AX: 1,
      AZ: 1,
      BA: 1,
      BD: 0,
      BE: 1,
      BG: 1,
      BH: 6,
      BM: 1,
      BN: 1,
      BR: 0,
      BS: 0,
      BT: 0,
      BW: 0,
      BY: 1,
      BZ: 0,
      CA: 0,
      CH: 1,
      CL: 1,
      CM: 1,
      CN: 1,
      CO: 0,
      CR: 1,
      CY: 1,
      CZ: 1,
      DE: 1,
      DJ: 6,
      DK: 1,
      DM: 0,
      DO: 0,
      DZ: 6,
      EC: 1,
      EE: 1,
      EG: 6,
      ES: 1,
      ET: 0,
      FI: 1,
      FJ: 1,
      FO: 1,
      FR: 1,
      GB: 1,
      "GB-alt-variant": 0,
      GE: 1,
      GF: 1,
      GP: 1,
      GR: 1,
      GT: 0,
      GU: 0,
      HK: 0,
      HN: 0,
      HR: 1,
      HU: 1,
      ID: 0,
      IE: 1,
      IL: 0,
      IN: 0,
      IQ: 6,
      IR: 6,
      IS: 1,
      IT: 1,
      JM: 0,
      JO: 6,
      JP: 0,
      KE: 0,
      KG: 1,
      KH: 0,
      KR: 0,
      KW: 6,
      KZ: 1,
      LA: 0,
      LB: 1,
      LI: 1,
      LK: 1,
      LT: 1,
      LU: 1,
      LV: 1,
      LY: 6,
      MC: 1,
      MD: 1,
      ME: 1,
      MH: 0,
      MK: 1,
      MM: 0,
      MN: 1,
      MO: 0,
      MQ: 1,
      MT: 0,
      MV: 5,
      MX: 0,
      MY: 1,
      MZ: 0,
      NI: 0,
      NL: 1,
      NO: 1,
      NP: 0,
      NZ: 1,
      OM: 6,
      PA: 0,
      PE: 0,
      PH: 0,
      PK: 0,
      PL: 1,
      PR: 0,
      PT: 0,
      PY: 0,
      QA: 6,
      RE: 1,
      RO: 1,
      RS: 1,
      RU: 1,
      SA: 0,
      SD: 6,
      SE: 1,
      SG: 0,
      SI: 1,
      SK: 1,
      SM: 1,
      SV: 0,
      SY: 6,
      TH: 0,
      TJ: 1,
      TM: 1,
      TR: 1,
      TT: 0,
      TW: 0,
      UA: 1,
      UM: 0,
      US: 0,
      UY: 1,
      UZ: 1,
      VA: 1,
      VE: 0,
      VI: 0,
      VN: 1,
      WS: 0,
      XK: 1,
      YE: 0,
      ZA: 0,
      ZW: 0
    };
    function getWeekArray(date2, locale, firstDayOfWeek) {
      const weeks = [];
      let currentWeek = [];
      const firstDayOfMonth = startOfMonth(date2);
      const lastDayOfMonth = endOfMonth(date2);
      const first = firstDayOfWeek ?? firstDay[locale.slice(-2).toUpperCase()] ?? 0;
      const firstDayWeekIndex = (firstDayOfMonth.getDay() - first + 7) % 7;
      const lastDayWeekIndex = (lastDayOfMonth.getDay() - first + 7) % 7;
      for (let i2 = 0; i2 < firstDayWeekIndex; i2++) {
        const adjacentDay = new Date(firstDayOfMonth);
        adjacentDay.setDate(adjacentDay.getDate() - (firstDayWeekIndex - i2));
        currentWeek.push(adjacentDay);
      }
      for (let i2 = 1; i2 <= lastDayOfMonth.getDate(); i2++) {
        const day = new Date(date2.getFullYear(), date2.getMonth(), i2);
        currentWeek.push(day);
        if (currentWeek.length === 7) {
          weeks.push(currentWeek);
          currentWeek = [];
        }
      }
      for (let i2 = 1; i2 < 7 - lastDayWeekIndex; i2++) {
        const adjacentDay = new Date(lastDayOfMonth);
        adjacentDay.setDate(adjacentDay.getDate() + i2);
        currentWeek.push(adjacentDay);
      }
      if (currentWeek.length > 0) {
        weeks.push(currentWeek);
      }
      return weeks;
    }
    function startOfWeek(date2, locale, firstDayOfWeek) {
      const day = firstDayOfWeek ?? firstDay[locale.slice(-2).toUpperCase()] ?? 0;
      const d = new Date(date2);
      while (d.getDay() !== day) {
        d.setDate(d.getDate() - 1);
      }
      return d;
    }
    function endOfWeek(date2, locale) {
      const d = new Date(date2);
      const lastDay = ((firstDay[locale.slice(-2).toUpperCase()] ?? 0) + 6) % 7;
      while (d.getDay() !== lastDay) {
        d.setDate(d.getDate() + 1);
      }
      return d;
    }
    function startOfMonth(date2) {
      return new Date(date2.getFullYear(), date2.getMonth(), 1);
    }
    function endOfMonth(date2) {
      return new Date(date2.getFullYear(), date2.getMonth() + 1, 0);
    }
    function parseLocalDate(value) {
      const parts = value.split("-").map(Number);
      return new Date(parts[0], parts[1] - 1, parts[2]);
    }
    const _YYYMMDD = /^([12]\d{3}-([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[12]\d|3[01]))$/;
    function date(value) {
      if (value == null)
        return /* @__PURE__ */ new Date();
      if (value instanceof Date)
        return value;
      if (typeof value === "string") {
        let parsed;
        if (_YYYMMDD.test(value)) {
          return parseLocalDate(value);
        } else {
          parsed = Date.parse(value);
        }
        if (!isNaN(parsed))
          return new Date(parsed);
      }
      return null;
    }
    const sundayJanuarySecond2000 = new Date(2e3, 0, 2);
    function getWeekdays(locale, firstDayOfWeek) {
      const daysFromSunday = firstDayOfWeek ?? firstDay[locale.slice(-2).toUpperCase()] ?? 0;
      return createRange(7).map((i2) => {
        const weekday = new Date(sundayJanuarySecond2000);
        weekday.setDate(sundayJanuarySecond2000.getDate() + daysFromSunday + i2);
        return new Intl.DateTimeFormat(locale, {
          weekday: "narrow"
        }).format(weekday);
      });
    }
    function format$5(value, formatString, locale, formats2) {
      const newDate = date(value) ?? /* @__PURE__ */ new Date();
      const customFormat = formats2 == null ? void 0 : formats2[formatString];
      if (typeof customFormat === "function") {
        return customFormat(newDate, formatString, locale);
      }
      let options = {};
      switch (formatString) {
        case "fullDate":
          options = {
            year: "numeric",
            month: "long",
            day: "numeric"
          };
          break;
        case "fullDateWithWeekday":
          options = {
            weekday: "long",
            year: "numeric",
            month: "long",
            day: "numeric"
          };
          break;
        case "normalDate":
          const day = newDate.getDate();
          const month = new Intl.DateTimeFormat(locale, {
            month: "long"
          }).format(newDate);
          return `${day} ${month}`;
        case "normalDateWithWeekday":
          options = {
            weekday: "short",
            day: "numeric",
            month: "short"
          };
          break;
        case "shortDate":
          options = {
            month: "short",
            day: "numeric"
          };
          break;
        case "year":
          options = {
            year: "numeric"
          };
          break;
        case "month":
          options = {
            month: "long"
          };
          break;
        case "monthShort":
          options = {
            month: "short"
          };
          break;
        case "monthAndYear":
          options = {
            month: "long",
            year: "numeric"
          };
          break;
        case "monthAndDate":
          options = {
            month: "long",
            day: "numeric"
          };
          break;
        case "weekday":
          options = {
            weekday: "long"
          };
          break;
        case "weekdayShort":
          options = {
            weekday: "short"
          };
          break;
        case "dayOfMonth":
          return new Intl.NumberFormat(locale).format(newDate.getDate());
        case "hours12h":
          options = {
            hour: "numeric",
            hour12: true
          };
          break;
        case "hours24h":
          options = {
            hour: "numeric",
            hour12: false
          };
          break;
        case "minutes":
          options = {
            minute: "numeric"
          };
          break;
        case "seconds":
          options = {
            second: "numeric"
          };
          break;
        case "fullTime":
          options = {
            hour: "numeric",
            minute: "numeric",
            second: "numeric",
            hour12: true
          };
          break;
        case "fullTime12h":
          options = {
            hour: "numeric",
            minute: "numeric",
            second: "numeric",
            hour12: true
          };
          break;
        case "fullTime24h":
          options = {
            hour: "numeric",
            minute: "numeric",
            second: "numeric",
            hour12: false
          };
          break;
        case "fullDateTime":
          options = {
            year: "numeric",
            month: "long",
            day: "numeric",
            hour: "numeric",
            minute: "numeric",
            second: "numeric",
            hour12: true
          };
          break;
        case "fullDateTime12h":
          options = {
            year: "numeric",
            month: "long",
            day: "numeric",
            hour: "numeric",
            minute: "numeric",
            second: "numeric",
            hour12: true
          };
          break;
        case "fullDateTime24h":
          options = {
            year: "numeric",
            month: "long",
            day: "numeric",
            hour: "numeric",
            minute: "numeric",
            second: "numeric",
            hour12: false
          };
          break;
        case "keyboardDate":
          options = {
            year: "numeric",
            month: "2-digit",
            day: "2-digit"
          };
          break;
        case "keyboardDateTime":
          options = {
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "numeric",
            minute: "numeric",
            second: "numeric",
            hour12: false
          };
          break;
        case "keyboardDateTime12h":
          options = {
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "numeric",
            minute: "numeric",
            second: "numeric",
            hour12: true
          };
          break;
        case "keyboardDateTime24h":
          options = {
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "numeric",
            minute: "numeric",
            second: "numeric",
            hour12: false
          };
          break;
        default:
          options = customFormat ?? {
            timeZone: "UTC",
            timeZoneName: "short"
          };
      }
      return new Intl.DateTimeFormat(locale, options).format(newDate);
    }
    function toISO(adapter, value) {
      const date2 = adapter.toJsDate(value);
      const year = date2.getFullYear();
      const month = padStart$2(String(date2.getMonth() + 1), 2, "0");
      const day = padStart$2(String(date2.getDate()), 2, "0");
      return `${year}-${month}-${day}`;
    }
    function parseISO(value) {
      const [year, month, day] = value.split("-").map(Number);
      return new Date(year, month - 1, day);
    }
    function addMinutes(date2, amount) {
      const d = new Date(date2);
      d.setMinutes(d.getMinutes() + amount);
      return d;
    }
    function addHours(date2, amount) {
      const d = new Date(date2);
      d.setHours(d.getHours() + amount);
      return d;
    }
    function addDays(date2, amount) {
      const d = new Date(date2);
      d.setDate(d.getDate() + amount);
      return d;
    }
    function addWeeks(date2, amount) {
      const d = new Date(date2);
      d.setDate(d.getDate() + amount * 7);
      return d;
    }
    function addMonths(date2, amount) {
      const d = new Date(date2);
      d.setDate(1);
      d.setMonth(d.getMonth() + amount);
      return d;
    }
    function getYear(date2) {
      return date2.getFullYear();
    }
    function getMonth(date2) {
      return date2.getMonth();
    }
    function getDate(date2) {
      return date2.getDate();
    }
    function getNextMonth(date2) {
      return new Date(date2.getFullYear(), date2.getMonth() + 1, 1);
    }
    function getPreviousMonth(date2) {
      return new Date(date2.getFullYear(), date2.getMonth() - 1, 1);
    }
    function getHours(date2) {
      return date2.getHours();
    }
    function getMinutes(date2) {
      return date2.getMinutes();
    }
    function startOfYear(date2) {
      return new Date(date2.getFullYear(), 0, 1);
    }
    function endOfYear(date2) {
      return new Date(date2.getFullYear(), 11, 31);
    }
    function isWithinRange(date2, range2) {
      return isAfter(date2, range2[0]) && isBefore(date2, range2[1]);
    }
    function isValid(date2) {
      const d = new Date(date2);
      return d instanceof Date && !isNaN(d.getTime());
    }
    function isAfter(date2, comparing) {
      return date2.getTime() > comparing.getTime();
    }
    function isAfterDay(date2, comparing) {
      return isAfter(startOfDay(date2), startOfDay(comparing));
    }
    function isBefore(date2, comparing) {
      return date2.getTime() < comparing.getTime();
    }
    function isEqual$1(date2, comparing) {
      return date2.getTime() === comparing.getTime();
    }
    function isSameDay(date2, comparing) {
      return date2.getDate() === comparing.getDate() && date2.getMonth() === comparing.getMonth() && date2.getFullYear() === comparing.getFullYear();
    }
    function isSameMonth(date2, comparing) {
      return date2.getMonth() === comparing.getMonth() && date2.getFullYear() === comparing.getFullYear();
    }
    function isSameYear(date2, comparing) {
      return date2.getFullYear() === comparing.getFullYear();
    }
    function getDiff(date2, comparing, unit) {
      const d = new Date(date2);
      const c = new Date(comparing);
      switch (unit) {
        case "years":
          return d.getFullYear() - c.getFullYear();
        case "quarters":
          return Math.floor((d.getMonth() - c.getMonth() + (d.getFullYear() - c.getFullYear()) * 12) / 4);
        case "months":
          return d.getMonth() - c.getMonth() + (d.getFullYear() - c.getFullYear()) * 12;
        case "weeks":
          return Math.floor((d.getTime() - c.getTime()) / (1e3 * 60 * 60 * 24 * 7));
        case "days":
          return Math.floor((d.getTime() - c.getTime()) / (1e3 * 60 * 60 * 24));
        case "hours":
          return Math.floor((d.getTime() - c.getTime()) / (1e3 * 60 * 60));
        case "minutes":
          return Math.floor((d.getTime() - c.getTime()) / (1e3 * 60));
        case "seconds":
          return Math.floor((d.getTime() - c.getTime()) / 1e3);
        default: {
          return d.getTime() - c.getTime();
        }
      }
    }
    function setHours(date2, count) {
      const d = new Date(date2);
      d.setHours(count);
      return d;
    }
    function setMinutes(date2, count) {
      const d = new Date(date2);
      d.setMinutes(count);
      return d;
    }
    function setMonth(date2, count) {
      const d = new Date(date2);
      d.setMonth(count);
      return d;
    }
    function setDate(date2, day) {
      const d = new Date(date2);
      d.setDate(day);
      return d;
    }
    function setYear(date2, year) {
      const d = new Date(date2);
      d.setFullYear(year);
      return d;
    }
    function startOfDay(date2) {
      return new Date(date2.getFullYear(), date2.getMonth(), date2.getDate(), 0, 0, 0, 0);
    }
    function endOfDay(date2) {
      return new Date(date2.getFullYear(), date2.getMonth(), date2.getDate(), 23, 59, 59, 999);
    }
    class VuetifyDateAdapter {
      constructor(options) {
        this.locale = options.locale;
        this.formats = options.formats;
      }
      date(value) {
        return date(value);
      }
      toJsDate(date2) {
        return date2;
      }
      toISO(date2) {
        return toISO(this, date2);
      }
      parseISO(date2) {
        return parseISO(date2);
      }
      addMinutes(date2, amount) {
        return addMinutes(date2, amount);
      }
      addHours(date2, amount) {
        return addHours(date2, amount);
      }
      addDays(date2, amount) {
        return addDays(date2, amount);
      }
      addWeeks(date2, amount) {
        return addWeeks(date2, amount);
      }
      addMonths(date2, amount) {
        return addMonths(date2, amount);
      }
      getWeekArray(date2, firstDayOfWeek) {
        return getWeekArray(date2, this.locale, firstDayOfWeek ? Number(firstDayOfWeek) : void 0);
      }
      startOfWeek(date2, firstDayOfWeek) {
        return startOfWeek(date2, this.locale, firstDayOfWeek ? Number(firstDayOfWeek) : void 0);
      }
      endOfWeek(date2) {
        return endOfWeek(date2, this.locale);
      }
      startOfMonth(date2) {
        return startOfMonth(date2);
      }
      endOfMonth(date2) {
        return endOfMonth(date2);
      }
      format(date2, formatString) {
        return format$5(date2, formatString, this.locale, this.formats);
      }
      isEqual(date2, comparing) {
        return isEqual$1(date2, comparing);
      }
      isValid(date2) {
        return isValid(date2);
      }
      isWithinRange(date2, range2) {
        return isWithinRange(date2, range2);
      }
      isAfter(date2, comparing) {
        return isAfter(date2, comparing);
      }
      isAfterDay(date2, comparing) {
        return isAfterDay(date2, comparing);
      }
      isBefore(date2, comparing) {
        return !isAfter(date2, comparing) && !isEqual$1(date2, comparing);
      }
      isSameDay(date2, comparing) {
        return isSameDay(date2, comparing);
      }
      isSameMonth(date2, comparing) {
        return isSameMonth(date2, comparing);
      }
      isSameYear(date2, comparing) {
        return isSameYear(date2, comparing);
      }
      setMinutes(date2, count) {
        return setMinutes(date2, count);
      }
      setHours(date2, count) {
        return setHours(date2, count);
      }
      setMonth(date2, count) {
        return setMonth(date2, count);
      }
      setDate(date2, day) {
        return setDate(date2, day);
      }
      setYear(date2, year) {
        return setYear(date2, year);
      }
      getDiff(date2, comparing, unit) {
        return getDiff(date2, comparing, unit);
      }
      getWeekdays(firstDayOfWeek) {
        return getWeekdays(this.locale, firstDayOfWeek ? Number(firstDayOfWeek) : void 0);
      }
      getYear(date2) {
        return getYear(date2);
      }
      getMonth(date2) {
        return getMonth(date2);
      }
      getDate(date2) {
        return getDate(date2);
      }
      getNextMonth(date2) {
        return getNextMonth(date2);
      }
      getPreviousMonth(date2) {
        return getPreviousMonth(date2);
      }
      getHours(date2) {
        return getHours(date2);
      }
      getMinutes(date2) {
        return getMinutes(date2);
      }
      startOfDay(date2) {
        return startOfDay(date2);
      }
      endOfDay(date2) {
        return endOfDay(date2);
      }
      startOfYear(date2) {
        return startOfYear(date2);
      }
      endOfYear(date2) {
        return endOfYear(date2);
      }
    }
    const DateOptionsSymbol = Symbol.for("vuetify:date-options");
    const DateAdapterSymbol = Symbol.for("vuetify:date-adapter");
    function createDate(options, locale) {
      const _options = mergeDeep({
        adapter: VuetifyDateAdapter,
        locale: {
          af: "af-ZA",
          // ar: '', # not the same value for all variants
          bg: "bg-BG",
          ca: "ca-ES",
          ckb: "",
          cs: "cs-CZ",
          de: "de-DE",
          el: "el-GR",
          en: "en-US",
          // es: '', # not the same value for all variants
          et: "et-EE",
          fa: "fa-IR",
          fi: "fi-FI",
          // fr: '', #not the same value for all variants
          hr: "hr-HR",
          hu: "hu-HU",
          he: "he-IL",
          id: "id-ID",
          it: "it-IT",
          ja: "ja-JP",
          ko: "ko-KR",
          lv: "lv-LV",
          lt: "lt-LT",
          nl: "nl-NL",
          no: "no-NO",
          pl: "pl-PL",
          pt: "pt-PT",
          ro: "ro-RO",
          ru: "ru-RU",
          sk: "sk-SK",
          sl: "sl-SI",
          srCyrl: "sr-SP",
          srLatn: "sr-SP",
          sv: "sv-SE",
          th: "th-TH",
          tr: "tr-TR",
          az: "az-AZ",
          uk: "uk-UA",
          vi: "vi-VN",
          zhHans: "zh-CN",
          zhHant: "zh-TW"
        }
      }, options);
      return {
        options: _options,
        instance: createInstance(_options, locale)
      };
    }
    function createInstance(options, locale) {
      const instance = reactive(typeof options.adapter === "function" ? new options.adapter({
        locale: options.locale[locale.current.value] ?? locale.current.value,
        formats: options.formats
      }) : options.adapter);
      watch(locale.current, (value) => {
        instance.locale = options.locale[value] ?? value ?? instance.locale;
      });
      return instance;
    }
    function useDate() {
      const options = inject$1(DateOptionsSymbol);
      if (!options)
        throw new Error("[Vuetify] Could not find injected date options");
      const locale = useLocale();
      return createInstance(options, locale);
    }
    function getWeek(adapter, value) {
      const date2 = adapter.toJsDate(value);
      let year = date2.getFullYear();
      let d1w1 = new Date(year, 0, 1);
      if (date2 < d1w1) {
        year = year - 1;
        d1w1 = new Date(year, 0, 1);
      } else {
        const tv = new Date(year + 1, 0, 1);
        if (date2 >= tv) {
          year = year + 1;
          d1w1 = tv;
        }
      }
      const diffTime = Math.abs(date2.getTime() - d1w1.getTime());
      const diffDays = Math.ceil(diffTime / (1e3 * 60 * 60 * 24));
      return Math.floor(diffDays / 7) + 1;
    }
    const GoToSymbol = Symbol.for("vuetify:goto");
    function genDefaults() {
      return {
        container: void 0,
        duration: 300,
        layout: false,
        offset: 0,
        easing: "easeInOutCubic",
        patterns: {
          linear: (t) => t,
          easeInQuad: (t) => t ** 2,
          easeOutQuad: (t) => t * (2 - t),
          easeInOutQuad: (t) => t < 0.5 ? 2 * t ** 2 : -1 + (4 - 2 * t) * t,
          easeInCubic: (t) => t ** 3,
          easeOutCubic: (t) => --t ** 3 + 1,
          easeInOutCubic: (t) => t < 0.5 ? 4 * t ** 3 : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
          easeInQuart: (t) => t ** 4,
          easeOutQuart: (t) => 1 - --t ** 4,
          easeInOutQuart: (t) => t < 0.5 ? 8 * t ** 4 : 1 - 8 * --t ** 4,
          easeInQuint: (t) => t ** 5,
          easeOutQuint: (t) => 1 + --t ** 5,
          easeInOutQuint: (t) => t < 0.5 ? 16 * t ** 5 : 1 + 16 * --t ** 5
        }
      };
    }
    function getContainer(el2) {
      return getTarget$1(el2) ?? (document.scrollingElement || document.body);
    }
    function getTarget$1(el2) {
      return typeof el2 === "string" ? document.querySelector(el2) : refElement(el2);
    }
    function getOffset$2(target2, horizontal, rtl) {
      if (typeof target2 === "number")
        return horizontal && rtl ? -target2 : target2;
      let el2 = getTarget$1(target2);
      let totalOffset = 0;
      while (el2) {
        totalOffset += horizontal ? el2.offsetLeft : el2.offsetTop;
        el2 = el2.offsetParent;
      }
      return totalOffset;
    }
    function createGoTo(options, locale) {
      return {
        rtl: locale.isRtl,
        options: mergeDeep(genDefaults(), options)
      };
    }
    async function scrollTo(_target, _options, horizontal, goTo) {
      const property = horizontal ? "scrollLeft" : "scrollTop";
      const options = mergeDeep((goTo == null ? void 0 : goTo.options) ?? genDefaults(), _options);
      const rtl = goTo == null ? void 0 : goTo.rtl.value;
      const target2 = (typeof _target === "number" ? _target : getTarget$1(_target)) ?? 0;
      const container = options.container === "parent" && target2 instanceof HTMLElement ? target2.parentElement : getContainer(options.container);
      const ease = typeof options.easing === "function" ? options.easing : options.patterns[options.easing];
      if (!ease)
        throw new TypeError(`Easing function "${options.easing}" not found.`);
      let targetLocation;
      if (typeof target2 === "number") {
        targetLocation = getOffset$2(target2, horizontal, rtl);
      } else {
        targetLocation = getOffset$2(target2, horizontal, rtl) - getOffset$2(container, horizontal, rtl);
        if (options.layout) {
          const styles = window.getComputedStyle(target2);
          const layoutOffset = styles.getPropertyValue("--v-layout-top");
          if (layoutOffset)
            targetLocation -= parseInt(layoutOffset, 10);
        }
      }
      targetLocation += options.offset;
      targetLocation = clampTarget(container, targetLocation, !!rtl, !!horizontal);
      const startLocation = container[property] ?? 0;
      if (targetLocation === startLocation)
        return Promise.resolve(targetLocation);
      const startTime = performance.now();
      return new Promise((resolve2) => requestAnimationFrame(function step(currentTime) {
        const timeElapsed = currentTime - startTime;
        const progress = timeElapsed / options.duration;
        const location2 = Math.floor(startLocation + (targetLocation - startLocation) * ease(clamp(progress, 0, 1)));
        container[property] = location2;
        if (progress >= 1 && Math.abs(location2 - container[property]) < 10) {
          return resolve2(targetLocation);
        } else if (progress > 2) {
          return resolve2(container[property]);
        }
        requestAnimationFrame(step);
      }));
    }
    function useGoTo() {
      let _options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const goToInstance = inject$1(GoToSymbol);
      const {
        isRtl
      } = useRtl();
      if (!goToInstance)
        throw new Error("[Vuetify] Could not find injected goto instance");
      const goTo = {
        ...goToInstance,
        // can be set via VLocaleProvider
        rtl: computed(() => goToInstance.rtl.value || isRtl.value)
      };
      async function go(target2, options) {
        return scrollTo(target2, mergeDeep(_options, options), false, goTo);
      }
      go.horizontal = async (target2, options) => {
        return scrollTo(target2, mergeDeep(_options, options), true, goTo);
      };
      return go;
    }
    function clampTarget(container, value, rtl, horizontal) {
      const {
        scrollWidth,
        scrollHeight
      } = container;
      const [containerWidth, containerHeight] = container === document.scrollingElement ? [window.innerWidth, window.innerHeight] : [container.offsetWidth, container.offsetHeight];
      let min;
      let max;
      if (horizontal) {
        if (rtl) {
          min = -(scrollWidth - containerWidth);
          max = 0;
        } else {
          min = 0;
          max = scrollWidth - containerWidth;
        }
      } else {
        min = 0;
        max = scrollHeight + -containerHeight;
      }
      return Math.max(Math.min(value, max), min);
    }
    const makeDelayProps = propsFactory({
      closeDelay: [Number, String],
      openDelay: [Number, String]
    }, "delay");
    function useDelay(props, cb) {
      let clearDelay = () => {
      };
      function runDelay(isOpening) {
        clearDelay == null ? void 0 : clearDelay();
        const delay = Number(isOpening ? props.openDelay : props.closeDelay);
        return new Promise((resolve2) => {
          clearDelay = defer(delay, () => {
            cb == null ? void 0 : cb(isOpening);
            resolve2(isOpening);
          });
        });
      }
      function runOpenDelay() {
        return runDelay(true);
      }
      function runCloseDelay() {
        return runDelay(false);
      }
      return {
        clearDelay,
        runOpenDelay,
        runCloseDelay
      };
    }
    function useScopeId() {
      const vm = getCurrentInstance("useScopeId");
      const scopeId = vm.vnode.scopeId;
      return {
        scopeId: scopeId ? {
          [scopeId]: ""
        } : void 0
      };
    }
    const locations = ["start", "end", "left", "right", "top", "bottom"];
    const makeVNavigationDrawerProps = propsFactory({
      color: String,
      disableResizeWatcher: Boolean,
      disableRouteWatcher: Boolean,
      expandOnHover: Boolean,
      floating: Boolean,
      modelValue: {
        type: Boolean,
        default: null
      },
      permanent: Boolean,
      rail: {
        type: Boolean,
        default: null
      },
      railWidth: {
        type: [Number, String],
        default: 56
      },
      scrim: {
        type: [Boolean, String],
        default: true
      },
      image: String,
      temporary: Boolean,
      persistent: Boolean,
      touchless: Boolean,
      width: {
        type: [Number, String],
        default: 256
      },
      location: {
        type: String,
        default: "start",
        validator: (value) => locations.includes(value)
      },
      sticky: Boolean,
      ...makeBorderProps(),
      ...makeComponentProps(),
      ...makeDelayProps(),
      ...makeDisplayProps({
        mobile: null
      }),
      ...makeElevationProps(),
      ...makeLayoutItemProps(),
      ...makeRoundedProps(),
      ...makeTagProps({
        tag: "nav"
      }),
      ...makeThemeProps()
    }, "VNavigationDrawer");
    const VNavigationDrawer = genericComponent()({
      name: "VNavigationDrawer",
      props: makeVNavigationDrawerProps(),
      emits: {
        "update:modelValue": (val) => true,
        "update:rail": (val) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          emit: emit2,
          slots
        } = _ref;
        const {
          isRtl
        } = useRtl();
        const {
          themeClasses
        } = provideTheme(props);
        const {
          borderClasses
        } = useBorder(props);
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(toRef(props, "color"));
        const {
          elevationClasses
        } = useElevation(props);
        const {
          displayClasses,
          mobile
        } = useDisplay(props);
        const {
          roundedClasses
        } = useRounded(props);
        const router2 = useRouter();
        const isActive = useProxiedModel(props, "modelValue", null, (v) => !!v);
        const {
          ssrBootStyles
        } = useSsrBoot();
        const {
          scopeId
        } = useScopeId();
        const rootEl = ref$1();
        const isHovering = shallowRef(false);
        const {
          runOpenDelay,
          runCloseDelay
        } = useDelay(props, (value) => {
          isHovering.value = value;
        });
        const width = computed(() => {
          return props.rail && props.expandOnHover && isHovering.value ? Number(props.width) : Number(props.rail ? props.railWidth : props.width);
        });
        const location2 = computed(() => {
          return toPhysical(props.location, isRtl.value);
        });
        const isPersistent = computed(() => props.persistent);
        const isTemporary = computed(() => !props.permanent && (mobile.value || props.temporary));
        const isSticky = computed(() => props.sticky && !isTemporary.value && location2.value !== "bottom");
        useToggleScope(() => props.expandOnHover && props.rail != null, () => {
          watch(isHovering, (val) => emit2("update:rail", !val));
        });
        useToggleScope(() => !props.disableResizeWatcher, () => {
          watch(isTemporary, (val) => !props.permanent && nextTick(() => isActive.value = !val));
        });
        useToggleScope(() => !props.disableRouteWatcher && !!router2, () => {
          watch(router2.currentRoute, () => isTemporary.value && (isActive.value = false));
        });
        watch(() => props.permanent, (val) => {
          if (val)
            isActive.value = true;
        });
        if (props.modelValue == null && !isTemporary.value) {
          isActive.value = props.permanent || !mobile.value;
        }
        const {
          isDragging,
          dragProgress
        } = useTouch({
          el: rootEl,
          isActive,
          isTemporary,
          width,
          touchless: toRef(props, "touchless"),
          position: location2
        });
        const layoutSize = computed(() => {
          const size2 = isTemporary.value ? 0 : props.rail && props.expandOnHover ? Number(props.railWidth) : width.value;
          return isDragging.value ? size2 * dragProgress.value : size2;
        });
        const elementSize = computed(() => ["top", "bottom"].includes(props.location) ? 0 : width.value);
        const {
          layoutItemStyles,
          layoutItemScrimStyles,
          layoutIsReady
        } = useLayoutItem({
          id: props.name,
          order: computed(() => parseInt(props.order, 10)),
          position: location2,
          layoutSize,
          elementSize,
          active: computed(() => isActive.value || isDragging.value),
          disableTransitions: computed(() => isDragging.value),
          absolute: computed(() => (
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            props.absolute || isSticky.value && typeof isStuck.value !== "string"
          ))
        });
        const {
          isStuck,
          stickyStyles
        } = useSticky({
          rootEl,
          isSticky,
          layoutItemStyles
        });
        const scrimColor = useBackgroundColor(computed(() => {
          return typeof props.scrim === "string" ? props.scrim : null;
        }));
        const scrimStyles = computed(() => ({
          ...isDragging.value ? {
            opacity: dragProgress.value * 0.2,
            transition: "none"
          } : void 0,
          ...layoutItemScrimStyles.value
        }));
        provideDefaults({
          VList: {
            bgColor: "transparent"
          }
        });
        useRender(() => {
          const hasImage = slots.image || props.image;
          return createVNode(Fragment, null, [createVNode(props.tag, mergeProps({
            "ref": rootEl,
            "onMouseenter": runOpenDelay,
            "onMouseleave": runCloseDelay,
            "class": ["v-navigation-drawer", `v-navigation-drawer--${location2.value}`, {
              "v-navigation-drawer--expand-on-hover": props.expandOnHover,
              "v-navigation-drawer--floating": props.floating,
              "v-navigation-drawer--is-hovering": isHovering.value,
              "v-navigation-drawer--rail": props.rail,
              "v-navigation-drawer--temporary": isTemporary.value,
              "v-navigation-drawer--persistent": isPersistent.value,
              "v-navigation-drawer--active": isActive.value,
              "v-navigation-drawer--sticky": isSticky.value
            }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, displayClasses.value, elevationClasses.value, roundedClasses.value, props.class],
            "style": [backgroundColorStyles.value, layoutItemStyles.value, ssrBootStyles.value, stickyStyles.value, props.style, ["top", "bottom"].includes(location2.value) ? {
              height: "auto"
            } : {}]
          }, scopeId, attrs), {
            default: () => {
              var _a2, _b, _c;
              return [hasImage && createVNode("div", {
                "key": "image",
                "class": "v-navigation-drawer__img"
              }, [!slots.image ? createVNode(VImg, {
                "key": "image-img",
                "alt": "",
                "cover": true,
                "height": "inherit",
                "src": props.image
              }, null) : createVNode(VDefaultsProvider, {
                "key": "image-defaults",
                "disabled": !props.image,
                "defaults": {
                  VImg: {
                    alt: "",
                    cover: true,
                    height: "inherit",
                    src: props.image
                  }
                }
              }, slots.image)]), slots.prepend && createVNode("div", {
                "class": "v-navigation-drawer__prepend"
              }, [(_a2 = slots.prepend) == null ? void 0 : _a2.call(slots)]), createVNode("div", {
                "class": "v-navigation-drawer__content"
              }, [(_b = slots.default) == null ? void 0 : _b.call(slots)]), slots.append && createVNode("div", {
                "class": "v-navigation-drawer__append"
              }, [(_c = slots.append) == null ? void 0 : _c.call(slots)])];
            }
          }), createVNode(Transition, {
            "name": "fade-transition"
          }, {
            default: () => [isTemporary.value && (isDragging.value || isActive.value) && !!props.scrim && createVNode("div", mergeProps({
              "class": ["v-navigation-drawer__scrim", scrimColor.backgroundColorClasses.value],
              "style": [scrimStyles.value, scrimColor.backgroundColorStyles.value],
              "onClick": () => {
                if (isPersistent.value)
                  return;
                isActive.value = false;
              }
            }, scopeId), null)]
          })]);
        });
        return layoutIsReady.then(() => ({
          isStuck
        }));
      }
    });
    function elementToViewport(point, offset) {
      return {
        x: point.x + offset.x,
        y: point.y + offset.y
      };
    }
    function getOffset$1(a, b) {
      return {
        x: a.x - b.x,
        y: a.y - b.y
      };
    }
    function anchorToPoint(anchor, box) {
      if (anchor.side === "top" || anchor.side === "bottom") {
        const {
          side,
          align
        } = anchor;
        const x2 = align === "left" ? 0 : align === "center" ? box.width / 2 : align === "right" ? box.width : align;
        const y = side === "top" ? 0 : side === "bottom" ? box.height : side;
        return elementToViewport({
          x: x2,
          y
        }, box);
      } else if (anchor.side === "left" || anchor.side === "right") {
        const {
          side,
          align
        } = anchor;
        const x2 = side === "left" ? 0 : side === "right" ? box.width : side;
        const y = align === "top" ? 0 : align === "center" ? box.height / 2 : align === "bottom" ? box.height : align;
        return elementToViewport({
          x: x2,
          y
        }, box);
      }
      return elementToViewport({
        x: box.width / 2,
        y: box.height / 2
      }, box);
    }
    const locationStrategies = {
      static: staticLocationStrategy,
      // specific viewport position, usually centered
      connected: connectedLocationStrategy
      // connected to a certain element
    };
    const makeLocationStrategyProps = propsFactory({
      locationStrategy: {
        type: [String, Function],
        default: "static",
        validator: (val) => typeof val === "function" || val in locationStrategies
      },
      location: {
        type: String,
        default: "bottom"
      },
      origin: {
        type: String,
        default: "auto"
      },
      offset: [Number, String, Array]
    }, "VOverlay-location-strategies");
    function useLocationStrategies(props, data) {
      const contentStyles = ref$1({});
      const updateLocation = ref$1();
      if (IN_BROWSER) {
        useToggleScope(() => !!(data.isActive.value && props.locationStrategy), (reset) => {
          var _a2, _b;
          watch(() => props.locationStrategy, reset);
          onScopeDispose(() => {
            window.removeEventListener("resize", onResize);
            updateLocation.value = void 0;
          });
          window.addEventListener("resize", onResize, {
            passive: true
          });
          if (typeof props.locationStrategy === "function") {
            updateLocation.value = (_a2 = props.locationStrategy(data, props, contentStyles)) == null ? void 0 : _a2.updateLocation;
          } else {
            updateLocation.value = (_b = locationStrategies[props.locationStrategy](data, props, contentStyles)) == null ? void 0 : _b.updateLocation;
          }
        });
      }
      function onResize(e) {
        var _a2;
        (_a2 = updateLocation.value) == null ? void 0 : _a2.call(updateLocation, e);
      }
      return {
        contentStyles,
        updateLocation
      };
    }
    function staticLocationStrategy() {
    }
    function getIntrinsicSize(el2, isRtl) {
      if (isRtl) {
        el2.style.removeProperty("left");
      } else {
        el2.style.removeProperty("right");
      }
      const contentBox = nullifyTransforms(el2);
      if (isRtl) {
        contentBox.x += parseFloat(el2.style.right || 0);
      } else {
        contentBox.x -= parseFloat(el2.style.left || 0);
      }
      contentBox.y -= parseFloat(el2.style.top || 0);
      return contentBox;
    }
    function connectedLocationStrategy(data, props, contentStyles) {
      const activatorFixed = Array.isArray(data.target.value) || isFixedPosition(data.target.value);
      if (activatorFixed) {
        Object.assign(contentStyles.value, {
          position: "fixed",
          top: 0,
          [data.isRtl.value ? "right" : "left"]: 0
        });
      }
      const {
        preferredAnchor,
        preferredOrigin
      } = destructComputed(() => {
        const parsedAnchor = parseAnchor(props.location, data.isRtl.value);
        const parsedOrigin = props.origin === "overlap" ? parsedAnchor : props.origin === "auto" ? flipSide(parsedAnchor) : parseAnchor(props.origin, data.isRtl.value);
        if (parsedAnchor.side === parsedOrigin.side && parsedAnchor.align === flipAlign(parsedOrigin).align) {
          return {
            preferredAnchor: flipCorner(parsedAnchor),
            preferredOrigin: flipCorner(parsedOrigin)
          };
        } else {
          return {
            preferredAnchor: parsedAnchor,
            preferredOrigin: parsedOrigin
          };
        }
      });
      const [minWidth, minHeight, maxWidth, maxHeight] = ["minWidth", "minHeight", "maxWidth", "maxHeight"].map((key) => {
        return computed(() => {
          const val = parseFloat(props[key]);
          return isNaN(val) ? Infinity : val;
        });
      });
      const offset = computed(() => {
        if (Array.isArray(props.offset)) {
          return props.offset;
        }
        if (typeof props.offset === "string") {
          const offset2 = props.offset.split(" ").map(parseFloat);
          if (offset2.length < 2)
            offset2.push(0);
          return offset2;
        }
        return typeof props.offset === "number" ? [props.offset, 0] : [0, 0];
      });
      let observe = false;
      const observer = new ResizeObserver(() => {
        if (observe)
          updateLocation();
      });
      watch([data.target, data.contentEl], (_ref, _ref2) => {
        let [newTarget, newContentEl] = _ref;
        let [oldTarget, oldContentEl] = _ref2;
        if (oldTarget && !Array.isArray(oldTarget))
          observer.unobserve(oldTarget);
        if (newTarget && !Array.isArray(newTarget))
          observer.observe(newTarget);
        if (oldContentEl)
          observer.unobserve(oldContentEl);
        if (newContentEl)
          observer.observe(newContentEl);
      }, {
        immediate: true
      });
      onScopeDispose(() => {
        observer.disconnect();
      });
      function updateLocation() {
        observe = false;
        requestAnimationFrame(() => observe = true);
        if (!data.target.value || !data.contentEl.value)
          return;
        const targetBox = getTargetBox(data.target.value);
        const contentBox = getIntrinsicSize(data.contentEl.value, data.isRtl.value);
        const scrollParents = getScrollParents(data.contentEl.value);
        const viewportMargin = 12;
        if (!scrollParents.length) {
          scrollParents.push(document.documentElement);
          if (!(data.contentEl.value.style.top && data.contentEl.value.style.left)) {
            contentBox.x -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x") || 0);
            contentBox.y -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y") || 0);
          }
        }
        const viewport = scrollParents.reduce((box, el2) => {
          const rect2 = el2.getBoundingClientRect();
          const scrollBox = new Box({
            x: el2 === document.documentElement ? 0 : rect2.x,
            y: el2 === document.documentElement ? 0 : rect2.y,
            width: el2.clientWidth,
            height: el2.clientHeight
          });
          if (box) {
            return new Box({
              x: Math.max(box.left, scrollBox.left),
              y: Math.max(box.top, scrollBox.top),
              width: Math.min(box.right, scrollBox.right) - Math.max(box.left, scrollBox.left),
              height: Math.min(box.bottom, scrollBox.bottom) - Math.max(box.top, scrollBox.top)
            });
          }
          return scrollBox;
        }, void 0);
        viewport.x += viewportMargin;
        viewport.y += viewportMargin;
        viewport.width -= viewportMargin * 2;
        viewport.height -= viewportMargin * 2;
        let placement = {
          anchor: preferredAnchor.value,
          origin: preferredOrigin.value
        };
        function checkOverflow(_placement) {
          const box = new Box(contentBox);
          const targetPoint = anchorToPoint(_placement.anchor, targetBox);
          const contentPoint = anchorToPoint(_placement.origin, box);
          let {
            x: x3,
            y: y2
          } = getOffset$1(targetPoint, contentPoint);
          switch (_placement.anchor.side) {
            case "top":
              y2 -= offset.value[0];
              break;
            case "bottom":
              y2 += offset.value[0];
              break;
            case "left":
              x3 -= offset.value[0];
              break;
            case "right":
              x3 += offset.value[0];
              break;
          }
          switch (_placement.anchor.align) {
            case "top":
              y2 -= offset.value[1];
              break;
            case "bottom":
              y2 += offset.value[1];
              break;
            case "left":
              x3 -= offset.value[1];
              break;
            case "right":
              x3 += offset.value[1];
              break;
          }
          box.x += x3;
          box.y += y2;
          box.width = Math.min(box.width, maxWidth.value);
          box.height = Math.min(box.height, maxHeight.value);
          const overflows = getOverflow(box, viewport);
          return {
            overflows,
            x: x3,
            y: y2
          };
        }
        let x2 = 0;
        let y = 0;
        const available = {
          x: 0,
          y: 0
        };
        const flipped = {
          x: false,
          y: false
        };
        let resets = -1;
        while (true) {
          if (resets++ > 10) {
            break;
          }
          const {
            x: _x,
            y: _y,
            overflows
          } = checkOverflow(placement);
          x2 += _x;
          y += _y;
          contentBox.x += _x;
          contentBox.y += _y;
          {
            const axis2 = getAxis(placement.anchor);
            const hasOverflowX = overflows.x.before || overflows.x.after;
            const hasOverflowY = overflows.y.before || overflows.y.after;
            let reset = false;
            ["x", "y"].forEach((key) => {
              if (key === "x" && hasOverflowX && !flipped.x || key === "y" && hasOverflowY && !flipped.y) {
                const newPlacement = {
                  anchor: {
                    ...placement.anchor
                  },
                  origin: {
                    ...placement.origin
                  }
                };
                const flip = key === "x" ? axis2 === "y" ? flipAlign : flipSide : axis2 === "y" ? flipSide : flipAlign;
                newPlacement.anchor = flip(newPlacement.anchor);
                newPlacement.origin = flip(newPlacement.origin);
                const {
                  overflows: newOverflows
                } = checkOverflow(newPlacement);
                if (newOverflows[key].before <= overflows[key].before && newOverflows[key].after <= overflows[key].after || newOverflows[key].before + newOverflows[key].after < (overflows[key].before + overflows[key].after) / 2) {
                  placement = newPlacement;
                  reset = flipped[key] = true;
                }
              }
            });
            if (reset)
              continue;
          }
          if (overflows.x.before) {
            x2 += overflows.x.before;
            contentBox.x += overflows.x.before;
          }
          if (overflows.x.after) {
            x2 -= overflows.x.after;
            contentBox.x -= overflows.x.after;
          }
          if (overflows.y.before) {
            y += overflows.y.before;
            contentBox.y += overflows.y.before;
          }
          if (overflows.y.after) {
            y -= overflows.y.after;
            contentBox.y -= overflows.y.after;
          }
          {
            const overflows2 = getOverflow(contentBox, viewport);
            available.x = viewport.width - overflows2.x.before - overflows2.x.after;
            available.y = viewport.height - overflows2.y.before - overflows2.y.after;
            x2 += overflows2.x.before;
            contentBox.x += overflows2.x.before;
            y += overflows2.y.before;
            contentBox.y += overflows2.y.before;
          }
          break;
        }
        const axis = getAxis(placement.anchor);
        Object.assign(contentStyles.value, {
          "--v-overlay-anchor-origin": `${placement.anchor.side} ${placement.anchor.align}`,
          transformOrigin: `${placement.origin.side} ${placement.origin.align}`,
          // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,
          top: convertToUnit(pixelRound(y)),
          left: data.isRtl.value ? void 0 : convertToUnit(pixelRound(x2)),
          right: data.isRtl.value ? convertToUnit(pixelRound(-x2)) : void 0,
          minWidth: convertToUnit(axis === "y" ? Math.min(minWidth.value, targetBox.width) : minWidth.value),
          maxWidth: convertToUnit(pixelCeil(clamp(available.x, minWidth.value === Infinity ? 0 : minWidth.value, maxWidth.value))),
          maxHeight: convertToUnit(pixelCeil(clamp(available.y, minHeight.value === Infinity ? 0 : minHeight.value, maxHeight.value)))
        });
        return {
          available,
          contentBox
        };
      }
      watch(() => [preferredAnchor.value, preferredOrigin.value, props.offset, props.minWidth, props.minHeight, props.maxWidth, props.maxHeight], () => updateLocation());
      nextTick(() => {
        const result = updateLocation();
        if (!result)
          return;
        const {
          available,
          contentBox
        } = result;
        if (contentBox.height > available.y) {
          requestAnimationFrame(() => {
            updateLocation();
            requestAnimationFrame(() => {
              updateLocation();
            });
          });
        }
      });
      return {
        updateLocation
      };
    }
    function pixelRound(val) {
      return Math.round(val * devicePixelRatio) / devicePixelRatio;
    }
    function pixelCeil(val) {
      return Math.ceil(val * devicePixelRatio) / devicePixelRatio;
    }
    let clean = true;
    const frames = [];
    function requestNewFrame(cb) {
      if (!clean || frames.length) {
        frames.push(cb);
        run();
      } else {
        clean = false;
        cb();
        run();
      }
    }
    let raf = -1;
    function run() {
      cancelAnimationFrame(raf);
      raf = requestAnimationFrame(() => {
        const frame = frames.shift();
        if (frame)
          frame();
        if (frames.length)
          run();
        else
          clean = true;
      });
    }
    const scrollStrategies = {
      none: null,
      close: closeScrollStrategy,
      block: blockScrollStrategy,
      reposition: repositionScrollStrategy
    };
    const makeScrollStrategyProps = propsFactory({
      scrollStrategy: {
        type: [String, Function],
        default: "block",
        validator: (val) => typeof val === "function" || val in scrollStrategies
      }
    }, "VOverlay-scroll-strategies");
    function useScrollStrategies(props, data) {
      if (!IN_BROWSER)
        return;
      let scope2;
      watchEffect(async () => {
        scope2 == null ? void 0 : scope2.stop();
        if (!(data.isActive.value && props.scrollStrategy))
          return;
        scope2 = effectScope();
        await new Promise((resolve2) => setTimeout(resolve2));
        scope2.active && scope2.run(() => {
          var _a2;
          if (typeof props.scrollStrategy === "function") {
            props.scrollStrategy(data, props, scope2);
          } else {
            (_a2 = scrollStrategies[props.scrollStrategy]) == null ? void 0 : _a2.call(scrollStrategies, data, props, scope2);
          }
        });
      });
      onScopeDispose(() => {
        scope2 == null ? void 0 : scope2.stop();
      });
    }
    function closeScrollStrategy(data) {
      function onScroll(e) {
        data.isActive.value = false;
      }
      bindScroll(data.targetEl.value ?? data.contentEl.value, onScroll);
    }
    function blockScrollStrategy(data, props) {
      var _a2;
      const offsetParent = (_a2 = data.root.value) == null ? void 0 : _a2.offsetParent;
      const scrollElements = [.../* @__PURE__ */ new Set([...getScrollParents(data.targetEl.value, props.contained ? offsetParent : void 0), ...getScrollParents(data.contentEl.value, props.contained ? offsetParent : void 0)])].filter((el2) => !el2.classList.contains("v-overlay-scroll-blocked"));
      const scrollbarWidth = window.innerWidth - document.documentElement.offsetWidth;
      const scrollableParent = ((el2) => hasScrollbar(el2) && el2)(offsetParent || document.documentElement);
      if (scrollableParent) {
        data.root.value.classList.add("v-overlay--scroll-blocked");
      }
      scrollElements.forEach((el2, i2) => {
        el2.style.setProperty("--v-body-scroll-x", convertToUnit(-el2.scrollLeft));
        el2.style.setProperty("--v-body-scroll-y", convertToUnit(-el2.scrollTop));
        if (el2 !== document.documentElement) {
          el2.style.setProperty("--v-scrollbar-offset", convertToUnit(scrollbarWidth));
        }
        el2.classList.add("v-overlay-scroll-blocked");
      });
      onScopeDispose(() => {
        scrollElements.forEach((el2, i2) => {
          const x2 = parseFloat(el2.style.getPropertyValue("--v-body-scroll-x"));
          const y = parseFloat(el2.style.getPropertyValue("--v-body-scroll-y"));
          const scrollBehavior = el2.style.scrollBehavior;
          el2.style.scrollBehavior = "auto";
          el2.style.removeProperty("--v-body-scroll-x");
          el2.style.removeProperty("--v-body-scroll-y");
          el2.style.removeProperty("--v-scrollbar-offset");
          el2.classList.remove("v-overlay-scroll-blocked");
          el2.scrollLeft = -x2;
          el2.scrollTop = -y;
          el2.style.scrollBehavior = scrollBehavior;
        });
        if (scrollableParent) {
          data.root.value.classList.remove("v-overlay--scroll-blocked");
        }
      });
    }
    function repositionScrollStrategy(data, props, scope2) {
      let slow = false;
      let raf2 = -1;
      let ric = -1;
      function update(e) {
        requestNewFrame(() => {
          var _a2, _b;
          const start = performance.now();
          (_b = (_a2 = data.updateLocation).value) == null ? void 0 : _b.call(_a2, e);
          const time = performance.now() - start;
          slow = time / (1e3 / 60) > 2;
        });
      }
      ric = (typeof requestIdleCallback === "undefined" ? (cb) => cb() : requestIdleCallback)(() => {
        scope2.run(() => {
          bindScroll(data.targetEl.value ?? data.contentEl.value, (e) => {
            if (slow) {
              cancelAnimationFrame(raf2);
              raf2 = requestAnimationFrame(() => {
                raf2 = requestAnimationFrame(() => {
                  update(e);
                });
              });
            } else {
              update(e);
            }
          });
        });
      });
      onScopeDispose(() => {
        typeof cancelIdleCallback !== "undefined" && cancelIdleCallback(ric);
        cancelAnimationFrame(raf2);
      });
    }
    function bindScroll(el2, onScroll) {
      const scrollElements = [document, ...getScrollParents(el2)];
      scrollElements.forEach((el3) => {
        el3.addEventListener("scroll", onScroll, {
          passive: true
        });
      });
      onScopeDispose(() => {
        scrollElements.forEach((el3) => {
          el3.removeEventListener("scroll", onScroll);
        });
      });
    }
    const VMenuSymbol = Symbol.for("vuetify:v-menu");
    const makeActivatorProps = propsFactory({
      target: [String, Object],
      activator: [String, Object],
      activatorProps: {
        type: Object,
        default: () => ({})
      },
      openOnClick: {
        type: Boolean,
        default: void 0
      },
      openOnHover: Boolean,
      openOnFocus: {
        type: Boolean,
        default: void 0
      },
      closeOnContentClick: Boolean,
      ...makeDelayProps()
    }, "VOverlay-activator");
    function useActivator(props, _ref) {
      let {
        isActive,
        isTop
      } = _ref;
      const vm = getCurrentInstance("useActivator");
      const activatorEl = ref$1();
      let isHovered = false;
      let isFocused = false;
      let firstEnter = true;
      const openOnFocus = computed(() => props.openOnFocus || props.openOnFocus == null && props.openOnHover);
      const openOnClick = computed(() => props.openOnClick || props.openOnClick == null && !props.openOnHover && !openOnFocus.value);
      const {
        runOpenDelay,
        runCloseDelay
      } = useDelay(props, (value) => {
        if (value === (props.openOnHover && isHovered || openOnFocus.value && isFocused) && !(props.openOnHover && isActive.value && !isTop.value)) {
          if (isActive.value !== value) {
            firstEnter = true;
          }
          isActive.value = value;
        }
      });
      const cursorTarget = ref$1();
      const availableEvents = {
        onClick: (e) => {
          e.stopPropagation();
          activatorEl.value = e.currentTarget || e.target;
          if (!isActive.value) {
            cursorTarget.value = [e.clientX, e.clientY];
          }
          isActive.value = !isActive.value;
        },
        onMouseenter: (e) => {
          var _a2;
          if ((_a2 = e.sourceCapabilities) == null ? void 0 : _a2.firesTouchEvents)
            return;
          isHovered = true;
          activatorEl.value = e.currentTarget || e.target;
          runOpenDelay();
        },
        onMouseleave: (e) => {
          isHovered = false;
          runCloseDelay();
        },
        onFocus: (e) => {
          if (matchesSelector(e.target, ":focus-visible") === false)
            return;
          isFocused = true;
          e.stopPropagation();
          activatorEl.value = e.currentTarget || e.target;
          runOpenDelay();
        },
        onBlur: (e) => {
          isFocused = false;
          e.stopPropagation();
          runCloseDelay();
        }
      };
      const activatorEvents = computed(() => {
        const events = {};
        if (openOnClick.value) {
          events.onClick = availableEvents.onClick;
        }
        if (props.openOnHover) {
          events.onMouseenter = availableEvents.onMouseenter;
          events.onMouseleave = availableEvents.onMouseleave;
        }
        if (openOnFocus.value) {
          events.onFocus = availableEvents.onFocus;
          events.onBlur = availableEvents.onBlur;
        }
        return events;
      });
      const contentEvents = computed(() => {
        const events = {};
        if (props.openOnHover) {
          events.onMouseenter = () => {
            isHovered = true;
            runOpenDelay();
          };
          events.onMouseleave = () => {
            isHovered = false;
            runCloseDelay();
          };
        }
        if (openOnFocus.value) {
          events.onFocusin = () => {
            isFocused = true;
            runOpenDelay();
          };
          events.onFocusout = () => {
            isFocused = false;
            runCloseDelay();
          };
        }
        if (props.closeOnContentClick) {
          const menu = inject$1(VMenuSymbol, null);
          events.onClick = () => {
            isActive.value = false;
            menu == null ? void 0 : menu.closeParents();
          };
        }
        return events;
      });
      const scrimEvents = computed(() => {
        const events = {};
        if (props.openOnHover) {
          events.onMouseenter = () => {
            if (firstEnter) {
              isHovered = true;
              firstEnter = false;
              runOpenDelay();
            }
          };
          events.onMouseleave = () => {
            isHovered = false;
            runCloseDelay();
          };
        }
        return events;
      });
      watch(isTop, (val) => {
        if (val && (props.openOnHover && !isHovered && (!openOnFocus.value || !isFocused) || openOnFocus.value && !isFocused && (!props.openOnHover || !isHovered))) {
          isActive.value = false;
        }
      });
      watch(isActive, (val) => {
        if (!val) {
          setTimeout(() => {
            cursorTarget.value = void 0;
          });
        }
      }, {
        flush: "post"
      });
      const activatorRef = templateRef();
      watchEffect(() => {
        if (!activatorRef.value)
          return;
        nextTick(() => {
          activatorEl.value = activatorRef.el;
        });
      });
      const targetRef = templateRef();
      const target2 = computed(() => {
        if (props.target === "cursor" && cursorTarget.value)
          return cursorTarget.value;
        if (targetRef.value)
          return targetRef.el;
        return getTarget(props.target, vm) || activatorEl.value;
      });
      const targetEl = computed(() => {
        return Array.isArray(target2.value) ? void 0 : target2.value;
      });
      let scope2;
      watch(() => !!props.activator, (val) => {
        if (val && IN_BROWSER) {
          scope2 = effectScope();
          scope2.run(() => {
            _useActivator(props, vm, {
              activatorEl,
              activatorEvents
            });
          });
        } else if (scope2) {
          scope2.stop();
        }
      }, {
        flush: "post",
        immediate: true
      });
      onScopeDispose(() => {
        scope2 == null ? void 0 : scope2.stop();
      });
      return {
        activatorEl,
        activatorRef,
        target: target2,
        targetEl,
        targetRef,
        activatorEvents,
        contentEvents,
        scrimEvents
      };
    }
    function _useActivator(props, vm, _ref2) {
      let {
        activatorEl,
        activatorEvents
      } = _ref2;
      watch(() => props.activator, (val, oldVal) => {
        if (oldVal && val !== oldVal) {
          const activator = getActivator(oldVal);
          activator && unbindActivatorProps(activator);
        }
        if (val) {
          nextTick(() => bindActivatorProps());
        }
      }, {
        immediate: true
      });
      watch(() => props.activatorProps, () => {
        bindActivatorProps();
      });
      onScopeDispose(() => {
        unbindActivatorProps();
      });
      function bindActivatorProps() {
        let el2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getActivator();
        let _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : props.activatorProps;
        if (!el2)
          return;
        bindProps(el2, mergeProps(activatorEvents.value, _props));
      }
      function unbindActivatorProps() {
        let el2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getActivator();
        let _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : props.activatorProps;
        if (!el2)
          return;
        unbindProps(el2, mergeProps(activatorEvents.value, _props));
      }
      function getActivator() {
        let selector = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : props.activator;
        const activator = getTarget(selector, vm);
        activatorEl.value = (activator == null ? void 0 : activator.nodeType) === Node.ELEMENT_NODE ? activator : void 0;
        return activatorEl.value;
      }
    }
    function getTarget(selector, vm) {
      var _a2, _b;
      if (!selector)
        return;
      let target2;
      if (selector === "parent") {
        let el2 = (_b = (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$el) == null ? void 0 : _b.parentNode;
        while (el2 == null ? void 0 : el2.hasAttribute("data-no-activator")) {
          el2 = el2.parentNode;
        }
        target2 = el2;
      } else if (typeof selector === "string") {
        target2 = document.querySelector(selector);
      } else if ("$el" in selector) {
        target2 = selector.$el;
      } else {
        target2 = selector;
      }
      return target2;
    }
    function useHydration() {
      if (!IN_BROWSER)
        return shallowRef(false);
      const {
        ssr
      } = useDisplay();
      if (ssr) {
        const isMounted = shallowRef(false);
        onMounted(() => {
          isMounted.value = true;
        });
        return isMounted;
      } else {
        return shallowRef(true);
      }
    }
    const makeLazyProps = propsFactory({
      eager: Boolean
    }, "lazy");
    function useLazy(props, active) {
      const isBooted = shallowRef(false);
      const hasContent = computed(() => isBooted.value || props.eager || active.value);
      watch(active, () => isBooted.value = true);
      function onAfterLeave() {
        if (!props.eager)
          isBooted.value = false;
      }
      return {
        isBooted,
        hasContent,
        onAfterLeave
      };
    }
    const StackSymbol = Symbol.for("vuetify:stack");
    const globalStack = reactive([]);
    function useStack(isActive, zIndex, disableGlobalStack) {
      const vm = getCurrentInstance("useStack");
      const createStackEntry = !disableGlobalStack;
      const parent = inject$1(StackSymbol, void 0);
      const stack2 = reactive({
        activeChildren: /* @__PURE__ */ new Set()
      });
      provide(StackSymbol, stack2);
      const _zIndex = shallowRef(+zIndex.value);
      useToggleScope(isActive, () => {
        var _a2;
        const lastZIndex = (_a2 = globalStack.at(-1)) == null ? void 0 : _a2[1];
        _zIndex.value = lastZIndex ? lastZIndex + 10 : +zIndex.value;
        if (createStackEntry) {
          globalStack.push([vm.uid, _zIndex.value]);
        }
        parent == null ? void 0 : parent.activeChildren.add(vm.uid);
        onScopeDispose(() => {
          if (createStackEntry) {
            const idx = toRaw(globalStack).findIndex((v) => v[0] === vm.uid);
            globalStack.splice(idx, 1);
          }
          parent == null ? void 0 : parent.activeChildren.delete(vm.uid);
        });
      });
      const globalTop = shallowRef(true);
      if (createStackEntry) {
        watchEffect(() => {
          var _a2;
          const _isTop = ((_a2 = globalStack.at(-1)) == null ? void 0 : _a2[0]) === vm.uid;
          setTimeout(() => globalTop.value = _isTop);
        });
      }
      const localTop = computed(() => !stack2.activeChildren.size);
      return {
        globalTop: readonly(globalTop),
        localTop,
        stackStyles: computed(() => ({
          zIndex: _zIndex.value
        }))
      };
    }
    function useTeleport(target2) {
      const teleportTarget = computed(() => {
        const _target = target2();
        if (_target === true || !IN_BROWSER)
          return void 0;
        const targetElement = _target === false ? document.body : typeof _target === "string" ? document.querySelector(_target) : _target;
        if (targetElement == null) {
          return void 0;
        }
        let container = targetElement.querySelector(":scope > .v-overlay-container");
        if (!container) {
          container = document.createElement("div");
          container.className = "v-overlay-container";
          targetElement.appendChild(container);
        }
        return container;
      });
      return {
        teleportTarget
      };
    }
    function defaultConditional() {
      return true;
    }
    function checkEvent(e, el2, binding) {
      if (!e || checkIsActive(e, binding) === false)
        return false;
      const root = attachedRoot(el2);
      if (typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot && root.host === e.target)
        return false;
      const elements = (typeof binding.value === "object" && binding.value.include || (() => []))();
      elements.push(el2);
      return !elements.some((el3) => el3 == null ? void 0 : el3.contains(e.target));
    }
    function checkIsActive(e, binding) {
      const isActive = typeof binding.value === "object" && binding.value.closeConditional || defaultConditional;
      return isActive(e);
    }
    function directive(e, el2, binding) {
      const handler = typeof binding.value === "function" ? binding.value : binding.value.handler;
      el2._clickOutside.lastMousedownWasOutside && checkEvent(e, el2, binding) && setTimeout(() => {
        checkIsActive(e, binding) && handler && handler(e);
      }, 0);
    }
    function handleShadow(el2, callback) {
      const root = attachedRoot(el2);
      callback(document);
      if (typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot) {
        callback(root);
      }
    }
    const ClickOutside = {
      // [data-app] may not be found
      // if using bind, inserted makes
      // sure that the root element is
      // available, iOS does not support
      // clicks on body
      mounted(el2, binding) {
        const onClick = (e) => directive(e, el2, binding);
        const onMousedown = (e) => {
          el2._clickOutside.lastMousedownWasOutside = checkEvent(e, el2, binding);
        };
        handleShadow(el2, (app2) => {
          app2.addEventListener("click", onClick, true);
          app2.addEventListener("mousedown", onMousedown, true);
        });
        if (!el2._clickOutside) {
          el2._clickOutside = {
            lastMousedownWasOutside: false
          };
        }
        el2._clickOutside[binding.instance.$.uid] = {
          onClick,
          onMousedown
        };
      },
      unmounted(el2, binding) {
        if (!el2._clickOutside)
          return;
        handleShadow(el2, (app2) => {
          var _a2;
          if (!app2 || !((_a2 = el2._clickOutside) == null ? void 0 : _a2[binding.instance.$.uid]))
            return;
          const {
            onClick,
            onMousedown
          } = el2._clickOutside[binding.instance.$.uid];
          app2.removeEventListener("click", onClick, true);
          app2.removeEventListener("mousedown", onMousedown, true);
        });
        delete el2._clickOutside[binding.instance.$.uid];
      }
    };
    function Scrim(props) {
      const {
        modelValue,
        color,
        ...rest
      } = props;
      return createVNode(Transition, {
        "name": "fade-transition",
        "appear": true
      }, {
        default: () => [props.modelValue && createVNode("div", mergeProps({
          "class": ["v-overlay__scrim", props.color.backgroundColorClasses.value],
          "style": props.color.backgroundColorStyles.value
        }, rest), null)]
      });
    }
    const makeVOverlayProps = propsFactory({
      absolute: Boolean,
      attach: [Boolean, String, Object],
      closeOnBack: {
        type: Boolean,
        default: true
      },
      contained: Boolean,
      contentClass: null,
      contentProps: null,
      disabled: Boolean,
      opacity: [Number, String],
      noClickAnimation: Boolean,
      modelValue: Boolean,
      persistent: Boolean,
      scrim: {
        type: [Boolean, String],
        default: true
      },
      zIndex: {
        type: [Number, String],
        default: 2e3
      },
      ...makeActivatorProps(),
      ...makeComponentProps(),
      ...makeDimensionProps(),
      ...makeLazyProps(),
      ...makeLocationStrategyProps(),
      ...makeScrollStrategyProps(),
      ...makeThemeProps(),
      ...makeTransitionProps()
    }, "VOverlay");
    const VOverlay = genericComponent()({
      name: "VOverlay",
      directives: {
        ClickOutside
      },
      inheritAttrs: false,
      props: {
        _disableGlobalStack: Boolean,
        ...makeVOverlayProps()
      },
      emits: {
        "click:outside": (e) => true,
        "update:modelValue": (value) => true,
        afterEnter: () => true,
        afterLeave: () => true
      },
      setup(props, _ref) {
        let {
          slots,
          attrs,
          emit: emit2
        } = _ref;
        const model = useProxiedModel(props, "modelValue");
        const isActive = computed({
          get: () => model.value,
          set: (v) => {
            if (!(v && props.disabled))
              model.value = v;
          }
        });
        const {
          themeClasses
        } = provideTheme(props);
        const {
          rtlClasses,
          isRtl
        } = useRtl();
        const {
          hasContent,
          onAfterLeave: _onAfterLeave
        } = useLazy(props, isActive);
        const scrimColor = useBackgroundColor(computed(() => {
          return typeof props.scrim === "string" ? props.scrim : null;
        }));
        const {
          globalTop,
          localTop,
          stackStyles
        } = useStack(isActive, toRef(props, "zIndex"), props._disableGlobalStack);
        const {
          activatorEl,
          activatorRef,
          target: target2,
          targetEl,
          targetRef,
          activatorEvents,
          contentEvents,
          scrimEvents
        } = useActivator(props, {
          isActive,
          isTop: localTop
        });
        const {
          teleportTarget
        } = useTeleport(() => {
          var _a2;
          const target3 = props.attach || props.contained;
          if (target3)
            return target3;
          const rootNode = (_a2 = activatorEl == null ? void 0 : activatorEl.value) == null ? void 0 : _a2.getRootNode();
          if (rootNode instanceof ShadowRoot)
            return rootNode;
          return false;
        });
        const {
          dimensionStyles
        } = useDimension(props);
        const isMounted = useHydration();
        const {
          scopeId
        } = useScopeId();
        watch(() => props.disabled, (v) => {
          if (v)
            isActive.value = false;
        });
        const root = ref$1();
        const scrimEl = ref$1();
        const contentEl = ref$1();
        const {
          contentStyles,
          updateLocation
        } = useLocationStrategies(props, {
          isRtl,
          contentEl,
          target: target2,
          isActive
        });
        useScrollStrategies(props, {
          root,
          contentEl,
          targetEl,
          isActive,
          updateLocation
        });
        function onClickOutside(e) {
          emit2("click:outside", e);
          if (!props.persistent)
            isActive.value = false;
          else
            animateClick();
        }
        function closeConditional(e) {
          return isActive.value && globalTop.value && // If using scrim, only close if clicking on it rather than anything opened on top
          (!props.scrim || e.target === scrimEl.value);
        }
        IN_BROWSER && watch(isActive, (val) => {
          if (val) {
            window.addEventListener("keydown", onKeydown);
          } else {
            window.removeEventListener("keydown", onKeydown);
          }
        }, {
          immediate: true
        });
        onBeforeUnmount(() => {
          if (!IN_BROWSER)
            return;
          window.removeEventListener("keydown", onKeydown);
        });
        function onKeydown(e) {
          var _a2, _b;
          if (e.key === "Escape" && globalTop.value) {
            if (!props.persistent) {
              isActive.value = false;
              if ((_a2 = contentEl.value) == null ? void 0 : _a2.contains(document.activeElement)) {
                (_b = activatorEl.value) == null ? void 0 : _b.focus();
              }
            } else
              animateClick();
          }
        }
        const router2 = useRouter();
        useToggleScope(() => props.closeOnBack, () => {
          useBackButton(router2, (next2) => {
            if (globalTop.value && isActive.value) {
              next2(false);
              if (!props.persistent)
                isActive.value = false;
              else
                animateClick();
            } else {
              next2();
            }
          });
        });
        const top2 = ref$1();
        watch(() => isActive.value && (props.absolute || props.contained) && teleportTarget.value == null, (val) => {
          if (val) {
            const scrollParent = getScrollParent(root.value);
            if (scrollParent && scrollParent !== document.scrollingElement) {
              top2.value = scrollParent.scrollTop;
            }
          }
        });
        function animateClick() {
          if (props.noClickAnimation)
            return;
          contentEl.value && animate(contentEl.value, [{
            transformOrigin: "center"
          }, {
            transform: "scale(1.03)"
          }, {
            transformOrigin: "center"
          }], {
            duration: 150,
            easing: standardEasing
          });
        }
        function onAfterEnter() {
          emit2("afterEnter");
        }
        function onAfterLeave() {
          _onAfterLeave();
          emit2("afterLeave");
        }
        useRender(() => {
          var _a2;
          return createVNode(Fragment, null, [(_a2 = slots.activator) == null ? void 0 : _a2.call(slots, {
            isActive: isActive.value,
            targetRef,
            props: mergeProps({
              ref: activatorRef
            }, activatorEvents.value, props.activatorProps)
          }), isMounted.value && hasContent.value && createVNode(Teleport, {
            "disabled": !teleportTarget.value,
            "to": teleportTarget.value
          }, {
            default: () => [createVNode("div", mergeProps({
              "class": ["v-overlay", {
                "v-overlay--absolute": props.absolute || props.contained,
                "v-overlay--active": isActive.value,
                "v-overlay--contained": props.contained
              }, themeClasses.value, rtlClasses.value, props.class],
              "style": [stackStyles.value, {
                "--v-overlay-opacity": props.opacity,
                top: convertToUnit(top2.value)
              }, props.style],
              "ref": root
            }, scopeId, attrs), [createVNode(Scrim, mergeProps({
              "color": scrimColor,
              "modelValue": isActive.value && !!props.scrim,
              "ref": scrimEl
            }, scrimEvents.value), null), createVNode(MaybeTransition, {
              "appear": true,
              "persisted": true,
              "transition": props.transition,
              "target": target2.value,
              "onAfterEnter": onAfterEnter,
              "onAfterLeave": onAfterLeave
            }, {
              default: () => {
                var _a3;
                return [withDirectives(createVNode("div", mergeProps({
                  "ref": contentEl,
                  "class": ["v-overlay__content", props.contentClass],
                  "style": [dimensionStyles.value, contentStyles.value]
                }, contentEvents.value, props.contentProps), [(_a3 = slots.default) == null ? void 0 : _a3.call(slots, {
                  isActive
                })]), [[vShow, isActive.value], [resolveDirective("click-outside"), {
                  handler: onClickOutside,
                  closeConditional,
                  include: () => [activatorEl.value]
                }]])];
              }
            })])]
          })]);
        });
        return {
          activatorEl,
          scrimEl,
          target: target2,
          animateClick,
          contentEl,
          globalTop,
          localTop,
          updateLocation
        };
      }
    });
    const Refs = Symbol("Forwarded refs");
    function getDescriptor(obj, key) {
      let currentObj = obj;
      while (currentObj) {
        const descriptor = Reflect.getOwnPropertyDescriptor(currentObj, key);
        if (descriptor)
          return descriptor;
        currentObj = Object.getPrototypeOf(currentObj);
      }
      return void 0;
    }
    function forwardRefs(target2) {
      for (var _len = arguments.length, refs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        refs[_key - 1] = arguments[_key];
      }
      target2[Refs] = refs;
      return new Proxy(target2, {
        get(target3, key) {
          if (Reflect.has(target3, key)) {
            return Reflect.get(target3, key);
          }
          if (typeof key === "symbol" || key.startsWith("$") || key.startsWith("__"))
            return;
          for (const ref2 of refs) {
            if (ref2.value && Reflect.has(ref2.value, key)) {
              const val = Reflect.get(ref2.value, key);
              return typeof val === "function" ? val.bind(ref2.value) : val;
            }
          }
        },
        has(target3, key) {
          if (Reflect.has(target3, key)) {
            return true;
          }
          if (typeof key === "symbol" || key.startsWith("$") || key.startsWith("__"))
            return false;
          for (const ref2 of refs) {
            if (ref2.value && Reflect.has(ref2.value, key)) {
              return true;
            }
          }
          return false;
        },
        set(target3, key, value) {
          if (Reflect.has(target3, key)) {
            return Reflect.set(target3, key, value);
          }
          if (typeof key === "symbol" || key.startsWith("$") || key.startsWith("__"))
            return false;
          for (const ref2 of refs) {
            if (ref2.value && Reflect.has(ref2.value, key)) {
              return Reflect.set(ref2.value, key, value);
            }
          }
          return false;
        },
        getOwnPropertyDescriptor(target3, key) {
          var _a2;
          const descriptor = Reflect.getOwnPropertyDescriptor(target3, key);
          if (descriptor)
            return descriptor;
          if (typeof key === "symbol" || key.startsWith("$") || key.startsWith("__"))
            return;
          for (const ref2 of refs) {
            if (!ref2.value)
              continue;
            const descriptor2 = getDescriptor(ref2.value, key) ?? ("_" in ref2.value ? getDescriptor((_a2 = ref2.value._) == null ? void 0 : _a2.setupState, key) : void 0);
            if (descriptor2)
              return descriptor2;
          }
          for (const ref2 of refs) {
            const childRefs = ref2.value && ref2.value[Refs];
            if (!childRefs)
              continue;
            const queue2 = childRefs.slice();
            while (queue2.length) {
              const ref3 = queue2.shift();
              const descriptor2 = getDescriptor(ref3.value, key);
              if (descriptor2)
                return descriptor2;
              const childRefs2 = ref3.value && ref3.value[Refs];
              if (childRefs2)
                queue2.push(...childRefs2);
            }
          }
          return void 0;
        }
      });
    }
    const makeVTooltipProps = propsFactory({
      id: String,
      text: String,
      ...omit$1(makeVOverlayProps({
        closeOnBack: false,
        location: "end",
        locationStrategy: "connected",
        eager: true,
        minWidth: 0,
        offset: 10,
        openOnClick: false,
        openOnHover: true,
        origin: "auto",
        scrim: false,
        scrollStrategy: "reposition",
        transition: false
      }), ["absolute", "persistent"])
    }, "VTooltip");
    const VTooltip = genericComponent()({
      name: "VTooltip",
      props: makeVTooltipProps(),
      emits: {
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const isActive = useProxiedModel(props, "modelValue");
        const {
          scopeId
        } = useScopeId();
        const uid2 = getUid();
        const id2 = computed(() => props.id || `v-tooltip-${uid2}`);
        const overlay = ref$1();
        const location2 = computed(() => {
          return props.location.split(" ").length > 1 ? props.location : props.location + " center";
        });
        const origin = computed(() => {
          return props.origin === "auto" || props.origin === "overlap" || props.origin.split(" ").length > 1 || props.location.split(" ").length > 1 ? props.origin : props.origin + " center";
        });
        const transition = computed(() => {
          if (props.transition)
            return props.transition;
          return isActive.value ? "scale-transition" : "fade-transition";
        });
        const activatorProps = computed(() => mergeProps({
          "aria-describedby": id2.value
        }, props.activatorProps));
        useRender(() => {
          const overlayProps = VOverlay.filterProps(props);
          return createVNode(VOverlay, mergeProps({
            "ref": overlay,
            "class": ["v-tooltip", props.class],
            "style": props.style,
            "id": id2.value
          }, overlayProps, {
            "modelValue": isActive.value,
            "onUpdate:modelValue": ($event) => isActive.value = $event,
            "transition": transition.value,
            "absolute": true,
            "location": location2.value,
            "origin": origin.value,
            "persistent": true,
            "role": "tooltip",
            "activatorProps": activatorProps.value,
            "_disableGlobalStack": true
          }, scopeId), {
            activator: slots.activator,
            default: function() {
              var _a2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return ((_a2 = slots.default) == null ? void 0 : _a2.call(slots, ...args)) ?? props.text;
            }
          });
        });
        return forwardRefs({}, overlay);
      }
    });
    function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_router_view = resolveComponent("router-view");
      return openBlock(), createBlock(VApp, null, {
        default: withCtx(() => [
          createVNode(VAppBar, { color: "primary" }, {
            default: withCtx(() => [
              createVNode(VAppBarNavIcon, {
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.drawer = !_ctx.drawer),
                "data-cy": "hamburger-menu"
              }),
              createVNode(VSpacer),
              createVNode(VImg, {
                class: "mx-4 rotateable",
                "max-height": "40",
                "max-width": "40",
                src: _imports_0
              }),
              createVNode(VToolbarTitle, { class: "app-bar-title" }, {
                default: withCtx(() => [
                  createTextVNode("EVerest Admin Panel")
                ]),
                _: 1
              }),
              createVNode(VSpacer)
            ]),
            _: 1
          }),
          createVNode(VNavigationDrawer, {
            modelValue: _ctx.drawer,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.drawer = $event),
            position: "fixed",
            temporary: ""
          }, {
            default: withCtx(() => [
              createVNode(VList, {
                nav: "",
                density: "compact"
              }, {
                default: withCtx(() => [
                  createVNode(VListItem, {
                    to: "config",
                    "append-icon": "mdi-cog",
                    link: ""
                  }, {
                    default: withCtx(() => [
                      createVNode(VListItemTitle, null, {
                        default: withCtx(() => [
                          createTextVNode("Config")
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }),
                  createVNode(VTooltip, { location: "end" }, {
                    activator: withCtx(({ props }) => [
                      createVNode(VListItem, mergeProps({
                        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.changeInstance()),
                        "append-icon": "mdi-image-filter-hdr",
                        link: ""
                      }, props, { "data-cy": "switch-instance" }), {
                        default: withCtx(() => [
                          createVNode(VListItemTitle, null, {
                            default: withCtx(() => [
                              createTextVNode("Change EVerest instance")
                            ]),
                            _: 1
                          })
                        ]),
                        _: 2
                      }, 1040)
                    ]),
                    default: withCtx(() => [
                      createBaseVNode("span", null, "Connected to " + toDisplayString(_ctx.connectionUrl), 1)
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              createVNode(VListItem, { class: "bottom-list d-flex flex-column" }, {
                default: withCtx(() => [
                  createBaseVNode("span", null, "Version " + toDisplayString(_ctx.version), 1)
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["modelValue"]),
          createVNode(VMain, null, {
            default: withCtx(() => [
              !_ctx.evbc_disconnected ? (openBlock(), createBlock(_component_router_view, { key: 0 })) : (openBlock(), createBlock(VOverlay, {
                key: 1,
                dark: false
              }, {
                default: withCtx(() => [
                  createVNode(VCard, {
                    elevation: "10",
                    loading: "true",
                    width: "400",
                    height: "150"
                  }, {
                    actions: withCtx(() => [
                      createVNode(VProgressLinear, {
                        height: "10",
                        indeterminate: ""
                      })
                    ]),
                    default: withCtx(() => [
                      createVNode(VCardTitle, null, {
                        default: withCtx(() => [
                          createTextVNode("Lost connection to EVerest backend")
                        ]),
                        _: 1
                      }),
                      createVNode(VCardText, null, {
                        default: withCtx(() => [
                          createTextVNode("Trying to reconnect ...")
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }))
            ]),
            _: 1
          })
        ]),
        _: 1
      });
    }
    const MainPanel = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["render", _sfc_render$6], ["__scopeId", "data-v-bf17ecd4"]]);
    /**
      * vee-validate v4.13.2
      * (c) 2024 Abdelrahman Awad
      * @license MIT
      */
    function isCallable(fn) {
      return typeof fn === "function";
    }
    function isNullOrUndefined(value) {
      return value === null || value === void 0;
    }
    const isObject$2 = (obj) => obj !== null && !!obj && typeof obj === "object" && !Array.isArray(obj);
    function isIndex(value) {
      return Number(value) >= 0;
    }
    function toNumber(value) {
      const n = parseFloat(value);
      return isNaN(n) ? value : n;
    }
    function isObjectLike(value) {
      return typeof value === "object" && value !== null;
    }
    function getTag(value) {
      if (value == null) {
        return value === void 0 ? "[object Undefined]" : "[object Null]";
      }
      return Object.prototype.toString.call(value);
    }
    function isPlainObject$2(value) {
      if (!isObjectLike(value) || getTag(value) !== "[object Object]") {
        return false;
      }
      if (Object.getPrototypeOf(value) === null) {
        return true;
      }
      let proto = value;
      while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
      }
      return Object.getPrototypeOf(value) === proto;
    }
    function merge$1(target2, source2) {
      Object.keys(source2).forEach((key) => {
        if (isPlainObject$2(source2[key]) && isPlainObject$2(target2[key])) {
          if (!target2[key]) {
            target2[key] = {};
          }
          merge$1(target2[key], source2[key]);
          return;
        }
        target2[key] = source2[key];
      });
      return target2;
    }
    function normalizeFormPath(path) {
      const pathArr = path.split(".");
      if (!pathArr.length) {
        return "";
      }
      let fullPath = String(pathArr[0]);
      for (let i2 = 1; i2 < pathArr.length; i2++) {
        if (isIndex(pathArr[i2])) {
          fullPath += `[${pathArr[i2]}]`;
          continue;
        }
        fullPath += `.${pathArr[i2]}`;
      }
      return fullPath;
    }
    const RULES = {};
    function resolveRule(id2) {
      return RULES[id2];
    }
    function set$2(obj, key, val) {
      if (typeof val.value === "object")
        val.value = klona(val.value);
      if (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === "__proto__") {
        Object.defineProperty(obj, key, val);
      } else
        obj[key] = val.value;
    }
    function klona(x2) {
      if (typeof x2 !== "object")
        return x2;
      var i2 = 0, k, list2, tmp, str2 = Object.prototype.toString.call(x2);
      if (str2 === "[object Object]") {
        tmp = Object.create(x2.__proto__ || null);
      } else if (str2 === "[object Array]") {
        tmp = Array(x2.length);
      } else if (str2 === "[object Set]") {
        tmp = /* @__PURE__ */ new Set();
        x2.forEach(function(val) {
          tmp.add(klona(val));
        });
      } else if (str2 === "[object Map]") {
        tmp = /* @__PURE__ */ new Map();
        x2.forEach(function(val, key) {
          tmp.set(klona(key), klona(val));
        });
      } else if (str2 === "[object Date]") {
        tmp = /* @__PURE__ */ new Date(+x2);
      } else if (str2 === "[object RegExp]") {
        tmp = new RegExp(x2.source, x2.flags);
      } else if (str2 === "[object DataView]") {
        tmp = new x2.constructor(klona(x2.buffer));
      } else if (str2 === "[object ArrayBuffer]") {
        tmp = x2.slice(0);
      } else if (str2.slice(-6) === "Array]") {
        tmp = new x2.constructor(x2);
      }
      if (tmp) {
        for (list2 = Object.getOwnPropertySymbols(x2); i2 < list2.length; i2++) {
          set$2(tmp, list2[i2], Object.getOwnPropertyDescriptor(x2, list2[i2]));
        }
        for (i2 = 0, list2 = Object.getOwnPropertyNames(x2); i2 < list2.length; i2++) {
          if (Object.hasOwnProperty.call(tmp, k = list2[i2]) && tmp[k] === x2[k])
            continue;
          set$2(tmp, k, Object.getOwnPropertyDescriptor(x2, k));
        }
      }
      return tmp || x2;
    }
    const FormContextKey = Symbol("vee-validate-form");
    const FieldContextKey = Symbol("vee-validate-field-instance");
    const IS_ABSENT = Symbol("Default empty value");
    const isClient$1 = typeof window !== "undefined";
    function isLocator(value) {
      return isCallable(value) && !!value.__locatorRef;
    }
    function isTypedSchema(value) {
      return !!value && isCallable(value.parse) && value.__type === "VVTypedSchema";
    }
    function isYupValidator(value) {
      return !!value && isCallable(value.validate);
    }
    function hasCheckedAttr(type2) {
      return type2 === "checkbox" || type2 === "radio";
    }
    function isContainerValue(value) {
      return isObject$2(value) || Array.isArray(value);
    }
    function isEmptyContainer(value) {
      if (Array.isArray(value)) {
        return value.length === 0;
      }
      return isObject$2(value) && Object.keys(value).length === 0;
    }
    function isNotNestedPath(path) {
      return /^\[.+\]$/i.test(path);
    }
    function isNativeMultiSelect(el2) {
      return isNativeSelect(el2) && el2.multiple;
    }
    function isNativeSelect(el2) {
      return el2.tagName === "SELECT";
    }
    function isFormSubmitEvent(evt) {
      return isEvent(evt) && evt.target && "submit" in evt.target;
    }
    function isEvent(evt) {
      if (!evt) {
        return false;
      }
      if (typeof Event !== "undefined" && isCallable(Event) && evt instanceof Event) {
        return true;
      }
      if (evt && evt.srcElement) {
        return true;
      }
      return false;
    }
    function isEqual(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a === "object" && typeof b === "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i2, keys2;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i2 = length; i2-- !== 0; )
            if (!isEqual(a[i2], b[i2]))
              return false;
          return true;
        }
        if (a instanceof Map && b instanceof Map) {
          if (a.size !== b.size)
            return false;
          for (i2 of a.entries())
            if (!b.has(i2[0]))
              return false;
          for (i2 of a.entries())
            if (!isEqual(i2[1], b.get(i2[0])))
              return false;
          return true;
        }
        if (isFile(a) && isFile(b)) {
          if (a.size !== b.size)
            return false;
          if (a.name !== b.name)
            return false;
          if (a.lastModified !== b.lastModified)
            return false;
          if (a.type !== b.type)
            return false;
          return true;
        }
        if (a instanceof Set && b instanceof Set) {
          if (a.size !== b.size)
            return false;
          for (i2 of a.entries())
            if (!b.has(i2[0]))
              return false;
          return true;
        }
        if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i2 = length; i2-- !== 0; )
            if (a[i2] !== b[i2])
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys2 = Object.keys(a);
        length = keys2.length;
        for (i2 = length; i2-- !== 0; ) {
          var key = keys2[i2];
          if (!isEqual(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    }
    function isFile(a) {
      if (!isClient$1) {
        return false;
      }
      return a instanceof File;
    }
    function cleanupNonNestedPath(path) {
      if (isNotNestedPath(path)) {
        return path.replace(/\[|\]/gi, "");
      }
      return path;
    }
    function getFromPath(object, path, fallback) {
      if (!object) {
        return fallback;
      }
      if (isNotNestedPath(path)) {
        return object[cleanupNonNestedPath(path)];
      }
      const resolvedValue = (path || "").split(/\.|\[(\d+)\]/).filter(Boolean).reduce((acc, propKey) => {
        if (isContainerValue(acc) && propKey in acc) {
          return acc[propKey];
        }
        return fallback;
      }, object);
      return resolvedValue;
    }
    function setInPath(object, path, value) {
      if (isNotNestedPath(path)) {
        object[cleanupNonNestedPath(path)] = value;
        return;
      }
      const keys2 = path.split(/\.|\[(\d+)\]/).filter(Boolean);
      let acc = object;
      for (let i2 = 0; i2 < keys2.length; i2++) {
        if (i2 === keys2.length - 1) {
          acc[keys2[i2]] = value;
          return;
        }
        if (!(keys2[i2] in acc) || isNullOrUndefined(acc[keys2[i2]])) {
          acc[keys2[i2]] = isIndex(keys2[i2 + 1]) ? [] : {};
        }
        acc = acc[keys2[i2]];
      }
    }
    function unset(object, key) {
      if (Array.isArray(object) && isIndex(key)) {
        object.splice(Number(key), 1);
        return;
      }
      if (isObject$2(object)) {
        delete object[key];
      }
    }
    function unsetPath(object, path) {
      if (isNotNestedPath(path)) {
        delete object[cleanupNonNestedPath(path)];
        return;
      }
      const keys2 = path.split(/\.|\[(\d+)\]/).filter(Boolean);
      let acc = object;
      for (let i2 = 0; i2 < keys2.length; i2++) {
        if (i2 === keys2.length - 1) {
          unset(acc, keys2[i2]);
          break;
        }
        if (!(keys2[i2] in acc) || isNullOrUndefined(acc[keys2[i2]])) {
          break;
        }
        acc = acc[keys2[i2]];
      }
      const pathValues = keys2.map((_, idx) => {
        return getFromPath(object, keys2.slice(0, idx).join("."));
      });
      for (let i2 = pathValues.length - 1; i2 >= 0; i2--) {
        if (!isEmptyContainer(pathValues[i2])) {
          continue;
        }
        if (i2 === 0) {
          unset(object, keys2[0]);
          continue;
        }
        unset(pathValues[i2 - 1], keys2[i2 - 1]);
      }
    }
    function keysOf(record) {
      return Object.keys(record);
    }
    function injectWithSelf(symbol, def2 = void 0) {
      const vm = getCurrentInstance$1();
      return (vm === null || vm === void 0 ? void 0 : vm.provides[symbol]) || inject$1(symbol, def2);
    }
    function resolveNextCheckboxValue(currentValue, checkedValue, uncheckedValue) {
      if (Array.isArray(currentValue)) {
        const newVal = [...currentValue];
        const idx = newVal.findIndex((v) => isEqual(v, checkedValue));
        idx >= 0 ? newVal.splice(idx, 1) : newVal.push(checkedValue);
        return newVal;
      }
      return isEqual(currentValue, checkedValue) ? uncheckedValue : checkedValue;
    }
    function debounceAsync(inner, ms2 = 0) {
      let timer = null;
      let resolves = [];
      return function(...args) {
        if (timer) {
          clearTimeout(timer);
        }
        timer = setTimeout(() => {
          const result = inner(...args);
          resolves.forEach((r2) => r2(result));
          resolves = [];
        }, ms2);
        return new Promise((resolve2) => resolves.push(resolve2));
      };
    }
    function applyModelModifiers(value, modifiers) {
      if (!isObject$2(modifiers)) {
        return value;
      }
      if (modifiers.number) {
        return toNumber(value);
      }
      return value;
    }
    function withLatest(fn, onDone) {
      let latestRun;
      return async function runLatest(...args) {
        const pending = fn(...args);
        latestRun = pending;
        const result = await pending;
        if (pending !== latestRun) {
          return result;
        }
        latestRun = void 0;
        return onDone(result, args);
      };
    }
    function normalizeErrorItem(message) {
      return Array.isArray(message) ? message : message ? [message] : [];
    }
    function omit(obj, keys2) {
      const target2 = {};
      for (const key in obj) {
        if (!keys2.includes(key)) {
          target2[key] = obj[key];
        }
      }
      return target2;
    }
    function debounceNextTick(inner) {
      let lastTick = null;
      let resolves = [];
      return function(...args) {
        const thisTick = nextTick(() => {
          if (lastTick !== thisTick) {
            return;
          }
          const result = inner(...args);
          resolves.forEach((r2) => r2(result));
          resolves = [];
          lastTick = null;
        });
        lastTick = thisTick;
        return new Promise((resolve2) => resolves.push(resolve2));
      };
    }
    function getBoundValue(el2) {
      if (hasValueBinding(el2)) {
        return el2._value;
      }
      return void 0;
    }
    function hasValueBinding(el2) {
      return "_value" in el2;
    }
    function parseInputValue(el2) {
      if (el2.type === "number") {
        return Number.isNaN(el2.valueAsNumber) ? el2.value : el2.valueAsNumber;
      }
      if (el2.type === "range") {
        return Number.isNaN(el2.valueAsNumber) ? el2.value : el2.valueAsNumber;
      }
      return el2.value;
    }
    function normalizeEventValue(value) {
      if (!isEvent(value)) {
        return value;
      }
      const input = value.target;
      if (hasCheckedAttr(input.type) && hasValueBinding(input)) {
        return getBoundValue(input);
      }
      if (input.type === "file" && input.files) {
        const files = Array.from(input.files);
        return input.multiple ? files : files[0];
      }
      if (isNativeMultiSelect(input)) {
        return Array.from(input.options).filter((opt) => opt.selected && !opt.disabled).map(getBoundValue);
      }
      if (isNativeSelect(input)) {
        const selectedOption = Array.from(input.options).find((opt) => opt.selected);
        return selectedOption ? getBoundValue(selectedOption) : input.value;
      }
      return parseInputValue(input);
    }
    function normalizeRules(rules2) {
      const acc = {};
      Object.defineProperty(acc, "_$$isNormalized", {
        value: true,
        writable: false,
        enumerable: false,
        configurable: false
      });
      if (!rules2) {
        return acc;
      }
      if (isObject$2(rules2) && rules2._$$isNormalized) {
        return rules2;
      }
      if (isObject$2(rules2)) {
        return Object.keys(rules2).reduce((prev, curr) => {
          const params = normalizeParams(rules2[curr]);
          if (rules2[curr] !== false) {
            prev[curr] = buildParams(params);
          }
          return prev;
        }, acc);
      }
      if (typeof rules2 !== "string") {
        return acc;
      }
      return rules2.split("|").reduce((prev, rule) => {
        const parsedRule = parseRule(rule);
        if (!parsedRule.name) {
          return prev;
        }
        prev[parsedRule.name] = buildParams(parsedRule.params);
        return prev;
      }, acc);
    }
    function normalizeParams(params) {
      if (params === true) {
        return [];
      }
      if (Array.isArray(params)) {
        return params;
      }
      if (isObject$2(params)) {
        return params;
      }
      return [params];
    }
    function buildParams(provided) {
      const mapValueToLocator = (value) => {
        if (typeof value === "string" && value[0] === "@") {
          return createLocator(value.slice(1));
        }
        return value;
      };
      if (Array.isArray(provided)) {
        return provided.map(mapValueToLocator);
      }
      if (provided instanceof RegExp) {
        return [provided];
      }
      return Object.keys(provided).reduce((prev, key) => {
        prev[key] = mapValueToLocator(provided[key]);
        return prev;
      }, {});
    }
    const parseRule = (rule) => {
      let params = [];
      const name = rule.split(":")[0];
      if (rule.includes(":")) {
        params = rule.split(":").slice(1).join(":").split(",");
      }
      return { name, params };
    };
    function createLocator(value) {
      const locator = (crossTable) => {
        const val = getFromPath(crossTable, value) || crossTable[value];
        return val;
      };
      locator.__locatorRef = value;
      return locator;
    }
    function extractLocators(params) {
      if (Array.isArray(params)) {
        return params.filter(isLocator);
      }
      return keysOf(params).filter((key) => isLocator(params[key])).map((key) => params[key]);
    }
    const DEFAULT_CONFIG = {
      generateMessage: ({ field }) => `${field} is not valid.`,
      bails: true,
      validateOnBlur: true,
      validateOnChange: true,
      validateOnInput: false,
      validateOnModelUpdate: true
    };
    let currentConfig = Object.assign({}, DEFAULT_CONFIG);
    const getConfig = () => currentConfig;
    async function validate$1(value, rules2, options = {}) {
      const shouldBail = options === null || options === void 0 ? void 0 : options.bails;
      const field = {
        name: (options === null || options === void 0 ? void 0 : options.name) || "{field}",
        rules: rules2,
        label: options === null || options === void 0 ? void 0 : options.label,
        bails: shouldBail !== null && shouldBail !== void 0 ? shouldBail : true,
        formData: (options === null || options === void 0 ? void 0 : options.values) || {}
      };
      const result = await _validate(field, value);
      return Object.assign(Object.assign({}, result), { valid: !result.errors.length });
    }
    async function _validate(field, value) {
      const rules2 = field.rules;
      if (isTypedSchema(rules2) || isYupValidator(rules2)) {
        return validateFieldWithTypedSchema(value, Object.assign(Object.assign({}, field), { rules: rules2 }));
      }
      if (isCallable(rules2) || Array.isArray(rules2)) {
        const ctx = {
          field: field.label || field.name,
          name: field.name,
          label: field.label,
          form: field.formData,
          value
        };
        const pipeline = Array.isArray(rules2) ? rules2 : [rules2];
        const length2 = pipeline.length;
        const errors22 = [];
        for (let i2 = 0; i2 < length2; i2++) {
          const rule = pipeline[i2];
          const result = await rule(value, ctx);
          const isValid2 = typeof result !== "string" && !Array.isArray(result) && result;
          if (isValid2) {
            continue;
          }
          if (Array.isArray(result)) {
            errors22.push(...result);
          } else {
            const message = typeof result === "string" ? result : _generateFieldError(ctx);
            errors22.push(message);
          }
          if (field.bails) {
            return {
              errors: errors22
            };
          }
        }
        return {
          errors: errors22
        };
      }
      const normalizedContext = Object.assign(Object.assign({}, field), { rules: normalizeRules(rules2) });
      const errors2 = [];
      const rulesKeys = Object.keys(normalizedContext.rules);
      const length = rulesKeys.length;
      for (let i2 = 0; i2 < length; i2++) {
        const rule = rulesKeys[i2];
        const result = await _test(normalizedContext, value, {
          name: rule,
          params: normalizedContext.rules[rule]
        });
        if (result.error) {
          errors2.push(result.error);
          if (field.bails) {
            return {
              errors: errors2
            };
          }
        }
      }
      return {
        errors: errors2
      };
    }
    function isYupError(err) {
      return !!err && err.name === "ValidationError";
    }
    function yupToTypedSchema(yupSchema) {
      const schema2 = {
        __type: "VVTypedSchema",
        async parse(values, context) {
          var _a2;
          try {
            const output = await yupSchema.validate(values, { abortEarly: false, context: (context === null || context === void 0 ? void 0 : context.formData) || {} });
            return {
              output,
              errors: []
            };
          } catch (err) {
            if (!isYupError(err)) {
              throw err;
            }
            if (!((_a2 = err.inner) === null || _a2 === void 0 ? void 0 : _a2.length) && err.errors.length) {
              return { errors: [{ path: err.path, errors: err.errors }] };
            }
            const errors2 = err.inner.reduce((acc, curr) => {
              const path = curr.path || "";
              if (!acc[path]) {
                acc[path] = { errors: [], path };
              }
              acc[path].errors.push(...curr.errors);
              return acc;
            }, {});
            return { errors: Object.values(errors2) };
          }
        }
      };
      return schema2;
    }
    async function validateFieldWithTypedSchema(value, context) {
      const typedSchema = isTypedSchema(context.rules) ? context.rules : yupToTypedSchema(context.rules);
      const result = await typedSchema.parse(value, { formData: context.formData });
      const messages = [];
      for (const error2 of result.errors) {
        if (error2.errors.length) {
          messages.push(...error2.errors);
        }
      }
      return {
        value: result.value,
        errors: messages
      };
    }
    async function _test(field, value, rule) {
      const validator = resolveRule(rule.name);
      if (!validator) {
        throw new Error(`No such validator '${rule.name}' exists.`);
      }
      const params = fillTargetValues(rule.params, field.formData);
      const ctx = {
        field: field.label || field.name,
        name: field.name,
        label: field.label,
        value,
        form: field.formData,
        rule: Object.assign(Object.assign({}, rule), { params })
      };
      const result = await validator(value, params, ctx);
      if (typeof result === "string") {
        return {
          error: result
        };
      }
      return {
        error: result ? void 0 : _generateFieldError(ctx)
      };
    }
    function _generateFieldError(fieldCtx) {
      const message = getConfig().generateMessage;
      if (!message) {
        return "Field is invalid";
      }
      return message(fieldCtx);
    }
    function fillTargetValues(params, crossTable) {
      const normalize2 = (value) => {
        if (isLocator(value)) {
          return value(crossTable);
        }
        return value;
      };
      if (Array.isArray(params)) {
        return params.map(normalize2);
      }
      return Object.keys(params).reduce((acc, param) => {
        acc[param] = normalize2(params[param]);
        return acc;
      }, {});
    }
    async function validateTypedSchema(schema2, values) {
      const typedSchema = isTypedSchema(schema2) ? schema2 : yupToTypedSchema(schema2);
      const validationResult = await typedSchema.parse(klona(values));
      const results = {};
      const errors2 = {};
      for (const error2 of validationResult.errors) {
        const messages = error2.errors;
        const path = (error2.path || "").replace(/\["(\d+)"\]/g, (_, m) => {
          return `[${m}]`;
        });
        results[path] = { valid: !messages.length, errors: messages };
        if (messages.length) {
          errors2[path] = messages[0];
        }
      }
      return {
        valid: !validationResult.errors.length,
        results,
        errors: errors2,
        values: validationResult.value,
        source: "schema"
      };
    }
    async function validateObjectSchema(schema2, values, opts) {
      const paths = keysOf(schema2);
      const validations = paths.map(async (path) => {
        var _a2, _b, _c;
        const strings = (_a2 = opts === null || opts === void 0 ? void 0 : opts.names) === null || _a2 === void 0 ? void 0 : _a2[path];
        const fieldResult = await validate$1(getFromPath(values, path), schema2[path], {
          name: (strings === null || strings === void 0 ? void 0 : strings.name) || path,
          label: strings === null || strings === void 0 ? void 0 : strings.label,
          values,
          bails: (_c = (_b = opts === null || opts === void 0 ? void 0 : opts.bailsMap) === null || _b === void 0 ? void 0 : _b[path]) !== null && _c !== void 0 ? _c : true
        });
        return Object.assign(Object.assign({}, fieldResult), { path });
      });
      let isAllValid = true;
      const validationResults = await Promise.all(validations);
      const results = {};
      const errors2 = {};
      for (const result of validationResults) {
        results[result.path] = {
          valid: result.valid,
          errors: result.errors
        };
        if (!result.valid) {
          isAllValid = false;
          errors2[result.path] = result.errors[0];
        }
      }
      return {
        valid: isAllValid,
        results,
        errors: errors2,
        source: "schema"
      };
    }
    let ID_COUNTER = 0;
    function useFieldState(path, init) {
      const { value, initialValue, setInitialValue } = _useFieldValue(path, init.modelValue, init.form);
      if (!init.form) {
        let setState2 = function(state2) {
          var _a2;
          if ("value" in state2) {
            value.value = state2.value;
          }
          if ("errors" in state2) {
            setErrors(state2.errors);
          }
          if ("touched" in state2) {
            meta.touched = (_a2 = state2.touched) !== null && _a2 !== void 0 ? _a2 : meta.touched;
          }
          if ("initialValue" in state2) {
            setInitialValue(state2.initialValue);
          }
        };
        const { errors: errors22, setErrors } = createFieldErrors();
        const id2 = ID_COUNTER >= Number.MAX_SAFE_INTEGER ? 0 : ++ID_COUNTER;
        const meta = createFieldMeta(value, initialValue, errors22, init.schema);
        return {
          id: id2,
          path,
          value,
          initialValue,
          meta,
          flags: { pendingUnmount: { [id2]: false }, pendingReset: false },
          errors: errors22,
          setState: setState2
        };
      }
      const state = init.form.createPathState(path, {
        bails: init.bails,
        label: init.label,
        type: init.type,
        validate: init.validate,
        schema: init.schema
      });
      const errors2 = computed(() => state.errors);
      function setState(state2) {
        var _a2, _b, _c;
        if ("value" in state2) {
          value.value = state2.value;
        }
        if ("errors" in state2) {
          (_a2 = init.form) === null || _a2 === void 0 ? void 0 : _a2.setFieldError(unref(path), state2.errors);
        }
        if ("touched" in state2) {
          (_b = init.form) === null || _b === void 0 ? void 0 : _b.setFieldTouched(unref(path), (_c = state2.touched) !== null && _c !== void 0 ? _c : false);
        }
        if ("initialValue" in state2) {
          setInitialValue(state2.initialValue);
        }
      }
      return {
        id: Array.isArray(state.id) ? state.id[state.id.length - 1] : state.id,
        path,
        value,
        errors: errors2,
        meta: state,
        initialValue,
        flags: state.__flags,
        setState
      };
    }
    function _useFieldValue(path, modelValue, form) {
      const modelRef = ref$1(unref(modelValue));
      function resolveInitialValue2() {
        if (!form) {
          return unref(modelRef);
        }
        return getFromPath(form.initialValues.value, unref(path), unref(modelRef));
      }
      function setInitialValue(value2) {
        if (!form) {
          modelRef.value = value2;
          return;
        }
        form.setFieldInitialValue(unref(path), value2, true);
      }
      const initialValue = computed(resolveInitialValue2);
      if (!form) {
        const value2 = ref$1(resolveInitialValue2());
        return {
          value: value2,
          initialValue,
          setInitialValue
        };
      }
      const currentValue = resolveModelValue(modelValue, form, initialValue, path);
      form.stageInitialValue(unref(path), currentValue, true);
      const value = computed({
        get() {
          return getFromPath(form.values, unref(path));
        },
        set(newVal) {
          form.setFieldValue(unref(path), newVal, false);
        }
      });
      return {
        value,
        initialValue,
        setInitialValue
      };
    }
    function resolveModelValue(modelValue, form, initialValue, path) {
      if (isRef(modelValue)) {
        return unref(modelValue);
      }
      if (modelValue !== void 0) {
        return modelValue;
      }
      return getFromPath(form.values, unref(path), unref(initialValue));
    }
    function createFieldMeta(currentValue, initialValue, errors2, schema2) {
      const isRequired = computed(() => {
        var _a2, _b, _c;
        return (_c = (_b = (_a2 = toValue$1(schema2)) === null || _a2 === void 0 ? void 0 : _a2.describe) === null || _b === void 0 ? void 0 : _b.call(_a2).required) !== null && _c !== void 0 ? _c : false;
      });
      const meta = reactive({
        touched: false,
        pending: false,
        valid: true,
        required: isRequired,
        validated: !!unref(errors2).length,
        initialValue: computed(() => unref(initialValue)),
        dirty: computed(() => {
          return !isEqual(unref(currentValue), unref(initialValue));
        })
      });
      watch(errors2, (value) => {
        meta.valid = !value.length;
      }, {
        immediate: true,
        flush: "sync"
      });
      return meta;
    }
    function createFieldErrors() {
      const errors2 = ref$1([]);
      return {
        errors: errors2,
        setErrors: (messages) => {
          errors2.value = normalizeErrorItem(messages);
        }
      };
    }
    function useField(path, rules2, opts) {
      if (hasCheckedAttr(opts === null || opts === void 0 ? void 0 : opts.type)) {
        return useFieldWithChecked(path, rules2, opts);
      }
      return _useField(path, rules2, opts);
    }
    function _useField(path, rules2, opts) {
      const { initialValue: modelValue, validateOnMount, bails, type: type2, checkedValue, label, validateOnValueUpdate, uncheckedValue, controlled, keepValueOnUnmount, syncVModel, form: controlForm } = normalizeOptions(opts);
      const injectedForm = controlled ? injectWithSelf(FormContextKey) : void 0;
      const form = controlForm || injectedForm;
      const name = computed(() => normalizeFormPath(toValue$1(path)));
      const validator = computed(() => {
        const schema2 = toValue$1(form === null || form === void 0 ? void 0 : form.schema);
        if (schema2) {
          return void 0;
        }
        const rulesValue = unref(rules2);
        if (isYupValidator(rulesValue) || isTypedSchema(rulesValue) || isCallable(rulesValue) || Array.isArray(rulesValue)) {
          return rulesValue;
        }
        return normalizeRules(rulesValue);
      });
      const isTyped = !isCallable(validator.value) && isTypedSchema(toValue$1(rules2));
      const { id: id2, value, initialValue, meta, setState, errors: errors2, flags } = useFieldState(name, {
        modelValue,
        form,
        bails,
        label,
        type: type2,
        validate: validator.value ? validate$1$1 : void 0,
        schema: isTyped ? rules2 : void 0
      });
      const errorMessage = computed(() => errors2.value[0]);
      if (syncVModel) {
        useVModel({
          value,
          prop: syncVModel,
          handleChange,
          shouldValidate: () => validateOnValueUpdate && !flags.pendingReset
        });
      }
      const handleBlur = (evt, shouldValidate = false) => {
        meta.touched = true;
        if (shouldValidate) {
          validateWithStateMutation();
        }
      };
      async function validateCurrentValue(mode) {
        var _a2, _b;
        if (form === null || form === void 0 ? void 0 : form.validateSchema) {
          const { results } = await form.validateSchema(mode);
          return (_a2 = results[toValue$1(name)]) !== null && _a2 !== void 0 ? _a2 : { valid: true, errors: [] };
        }
        if (validator.value) {
          return validate$1(value.value, validator.value, {
            name: toValue$1(name),
            label: toValue$1(label),
            values: (_b = form === null || form === void 0 ? void 0 : form.values) !== null && _b !== void 0 ? _b : {},
            bails
          });
        }
        return { valid: true, errors: [] };
      }
      const validateWithStateMutation = withLatest(async () => {
        meta.pending = true;
        meta.validated = true;
        return validateCurrentValue("validated-only");
      }, (result) => {
        if (flags.pendingUnmount[field.id]) {
          return result;
        }
        setState({ errors: result.errors });
        meta.pending = false;
        meta.valid = result.valid;
        return result;
      });
      const validateValidStateOnly = withLatest(async () => {
        return validateCurrentValue("silent");
      }, (result) => {
        meta.valid = result.valid;
        return result;
      });
      function validate$1$1(opts2) {
        if ((opts2 === null || opts2 === void 0 ? void 0 : opts2.mode) === "silent") {
          return validateValidStateOnly();
        }
        return validateWithStateMutation();
      }
      function handleChange(e, shouldValidate = true) {
        const newValue = normalizeEventValue(e);
        setValue(newValue, shouldValidate);
      }
      onMounted(() => {
        if (validateOnMount) {
          return validateWithStateMutation();
        }
        if (!form || !form.validateSchema) {
          validateValidStateOnly();
        }
      });
      function setTouched(isTouched) {
        meta.touched = isTouched;
      }
      function resetField(state) {
        var _a2;
        const newValue = state && "value" in state ? state.value : initialValue.value;
        setState({
          value: klona(newValue),
          initialValue: klona(newValue),
          touched: (_a2 = state === null || state === void 0 ? void 0 : state.touched) !== null && _a2 !== void 0 ? _a2 : false,
          errors: (state === null || state === void 0 ? void 0 : state.errors) || []
        });
        meta.pending = false;
        meta.validated = false;
        validateValidStateOnly();
      }
      const vm = getCurrentInstance$1();
      function setValue(newValue, shouldValidate = true) {
        value.value = vm && syncVModel ? applyModelModifiers(newValue, vm.props.modelModifiers) : newValue;
        const validateFn = shouldValidate ? validateWithStateMutation : validateValidStateOnly;
        validateFn();
      }
      function setErrors(errors22) {
        setState({ errors: Array.isArray(errors22) ? errors22 : [errors22] });
      }
      const valueProxy = computed({
        get() {
          return value.value;
        },
        set(newValue) {
          setValue(newValue, validateOnValueUpdate);
        }
      });
      const field = {
        id: id2,
        name,
        label,
        value: valueProxy,
        meta,
        errors: errors2,
        errorMessage,
        type: type2,
        checkedValue,
        uncheckedValue,
        bails,
        keepValueOnUnmount,
        resetField,
        handleReset: () => resetField(),
        validate: validate$1$1,
        handleChange,
        handleBlur,
        setState,
        setTouched,
        setErrors,
        setValue
      };
      provide(FieldContextKey, field);
      if (isRef(rules2) && typeof unref(rules2) !== "function") {
        watch(rules2, (value2, oldValue) => {
          if (isEqual(value2, oldValue)) {
            return;
          }
          meta.validated ? validateWithStateMutation() : validateValidStateOnly();
        }, {
          deep: true
        });
      }
      if (!form) {
        return field;
      }
      const dependencies2 = computed(() => {
        const rulesVal = validator.value;
        if (!rulesVal || isCallable(rulesVal) || isYupValidator(rulesVal) || isTypedSchema(rulesVal) || Array.isArray(rulesVal)) {
          return {};
        }
        return Object.keys(rulesVal).reduce((acc, rule) => {
          const deps = extractLocators(rulesVal[rule]).map((dep) => dep.__locatorRef).reduce((depAcc, depName) => {
            const depValue = getFromPath(form.values, depName) || form.values[depName];
            if (depValue !== void 0) {
              depAcc[depName] = depValue;
            }
            return depAcc;
          }, {});
          Object.assign(acc, deps);
          return acc;
        }, {});
      });
      watch(dependencies2, (deps, oldDeps) => {
        if (!Object.keys(deps).length) {
          return;
        }
        const shouldValidate = !isEqual(deps, oldDeps);
        if (shouldValidate) {
          meta.validated ? validateWithStateMutation() : validateValidStateOnly();
        }
      });
      onBeforeUnmount(() => {
        var _a2;
        const shouldKeepValue = (_a2 = toValue$1(field.keepValueOnUnmount)) !== null && _a2 !== void 0 ? _a2 : toValue$1(form.keepValuesOnUnmount);
        const path2 = toValue$1(name);
        if (shouldKeepValue || !form || flags.pendingUnmount[field.id]) {
          form === null || form === void 0 ? void 0 : form.removePathState(path2, id2);
          return;
        }
        flags.pendingUnmount[field.id] = true;
        const pathState = form.getPathState(path2);
        const matchesId = Array.isArray(pathState === null || pathState === void 0 ? void 0 : pathState.id) && (pathState === null || pathState === void 0 ? void 0 : pathState.multiple) ? pathState === null || pathState === void 0 ? void 0 : pathState.id.includes(field.id) : (pathState === null || pathState === void 0 ? void 0 : pathState.id) === field.id;
        if (!matchesId) {
          return;
        }
        if ((pathState === null || pathState === void 0 ? void 0 : pathState.multiple) && Array.isArray(pathState.value)) {
          const valueIdx = pathState.value.findIndex((i2) => isEqual(i2, toValue$1(field.checkedValue)));
          if (valueIdx > -1) {
            const newVal = [...pathState.value];
            newVal.splice(valueIdx, 1);
            form.setFieldValue(path2, newVal);
          }
          if (Array.isArray(pathState.id)) {
            pathState.id.splice(pathState.id.indexOf(field.id), 1);
          }
        } else {
          form.unsetPathValue(toValue$1(name));
        }
        form.removePathState(path2, id2);
      });
      return field;
    }
    function normalizeOptions(opts) {
      const defaults2 = () => ({
        initialValue: void 0,
        validateOnMount: false,
        bails: true,
        label: void 0,
        validateOnValueUpdate: true,
        keepValueOnUnmount: void 0,
        syncVModel: false,
        controlled: true
      });
      const isVModelSynced = !!(opts === null || opts === void 0 ? void 0 : opts.syncVModel);
      const modelPropName = typeof (opts === null || opts === void 0 ? void 0 : opts.syncVModel) === "string" ? opts.syncVModel : (opts === null || opts === void 0 ? void 0 : opts.modelPropName) || "modelValue";
      const initialValue = isVModelSynced && !("initialValue" in (opts || {})) ? getCurrentModelValue(getCurrentInstance$1(), modelPropName) : opts === null || opts === void 0 ? void 0 : opts.initialValue;
      if (!opts) {
        return Object.assign(Object.assign({}, defaults2()), { initialValue });
      }
      const checkedValue = "valueProp" in opts ? opts.valueProp : opts.checkedValue;
      const controlled = "standalone" in opts ? !opts.standalone : opts.controlled;
      const syncVModel = (opts === null || opts === void 0 ? void 0 : opts.modelPropName) || (opts === null || opts === void 0 ? void 0 : opts.syncVModel) || false;
      return Object.assign(Object.assign(Object.assign({}, defaults2()), opts || {}), {
        initialValue,
        controlled: controlled !== null && controlled !== void 0 ? controlled : true,
        checkedValue,
        syncVModel
      });
    }
    function useFieldWithChecked(name, rules2, opts) {
      const form = !(opts === null || opts === void 0 ? void 0 : opts.standalone) ? injectWithSelf(FormContextKey) : void 0;
      const checkedValue = opts === null || opts === void 0 ? void 0 : opts.checkedValue;
      const uncheckedValue = opts === null || opts === void 0 ? void 0 : opts.uncheckedValue;
      function patchCheckedApi(field) {
        const handleChange = field.handleChange;
        const checked = computed(() => {
          const currentValue = toValue$1(field.value);
          const checkedVal = toValue$1(checkedValue);
          return Array.isArray(currentValue) ? currentValue.findIndex((v) => isEqual(v, checkedVal)) >= 0 : isEqual(checkedVal, currentValue);
        });
        function handleCheckboxChange(e, shouldValidate = true) {
          var _a2, _b;
          if (checked.value === ((_a2 = e === null || e === void 0 ? void 0 : e.target) === null || _a2 === void 0 ? void 0 : _a2.checked)) {
            if (shouldValidate) {
              field.validate();
            }
            return;
          }
          const path = toValue$1(name);
          const pathState = form === null || form === void 0 ? void 0 : form.getPathState(path);
          const value = normalizeEventValue(e);
          let newValue = (_b = toValue$1(checkedValue)) !== null && _b !== void 0 ? _b : value;
          if (form && (pathState === null || pathState === void 0 ? void 0 : pathState.multiple) && pathState.type === "checkbox") {
            newValue = resolveNextCheckboxValue(getFromPath(form.values, path) || [], newValue, void 0);
          } else if ((opts === null || opts === void 0 ? void 0 : opts.type) === "checkbox") {
            newValue = resolveNextCheckboxValue(toValue$1(field.value), newValue, toValue$1(uncheckedValue));
          }
          handleChange(newValue, shouldValidate);
        }
        return Object.assign(Object.assign({}, field), {
          checked,
          checkedValue,
          uncheckedValue,
          handleChange: handleCheckboxChange
        });
      }
      return patchCheckedApi(_useField(name, rules2, opts));
    }
    function useVModel({ prop: prop2, value, handleChange, shouldValidate }) {
      const vm = getCurrentInstance$1();
      if (!vm || !prop2) {
        return;
      }
      const propName = typeof prop2 === "string" ? prop2 : "modelValue";
      const emitName = `update:${propName}`;
      if (!(propName in vm.props)) {
        return;
      }
      watch(value, (newValue) => {
        if (isEqual(newValue, getCurrentModelValue(vm, propName))) {
          return;
        }
        vm.emit(emitName, newValue);
      });
      watch(() => getCurrentModelValue(vm, propName), (propValue) => {
        if (propValue === IS_ABSENT && value.value === void 0) {
          return;
        }
        const newValue = propValue === IS_ABSENT ? void 0 : propValue;
        if (isEqual(newValue, value.value)) {
          return;
        }
        handleChange(newValue, shouldValidate());
      });
    }
    function getCurrentModelValue(vm, propName) {
      if (!vm) {
        return void 0;
      }
      return vm.props[propName];
    }
    let FORM_COUNTER = 0;
    const PRIVATE_PATH_STATE_KEYS = ["bails", "fieldsCount", "id", "multiple", "type", "validate"];
    function resolveInitialValues(opts) {
      const givenInitial = (opts === null || opts === void 0 ? void 0 : opts.initialValues) || {};
      const providedValues = Object.assign({}, toValue$1(givenInitial));
      const schema2 = unref(opts === null || opts === void 0 ? void 0 : opts.validationSchema);
      if (schema2 && isTypedSchema(schema2) && isCallable(schema2.cast)) {
        return klona(schema2.cast(providedValues) || {});
      }
      return klona(providedValues);
    }
    function useForm$1(opts) {
      var _a2;
      const formId = FORM_COUNTER++;
      let FIELD_ID_COUNTER = 0;
      const isSubmitting = ref$1(false);
      const isValidating = ref$1(false);
      const submitCount = ref$1(0);
      const fieldArrays = [];
      const formValues = reactive(resolveInitialValues(opts));
      const pathStates = ref$1([]);
      const extraErrorsBag = ref$1({});
      const pathStateLookup = ref$1({});
      const rebuildPathLookup = debounceNextTick(() => {
        pathStateLookup.value = pathStates.value.reduce((names2, state) => {
          names2[normalizeFormPath(toValue$1(state.path))] = state;
          return names2;
        }, {});
      });
      function setFieldError(field, message) {
        const state = findPathState(field);
        if (!state) {
          if (typeof field === "string") {
            extraErrorsBag.value[normalizeFormPath(field)] = normalizeErrorItem(message);
          }
          return;
        }
        if (typeof field === "string") {
          const normalizedPath = normalizeFormPath(field);
          if (extraErrorsBag.value[normalizedPath]) {
            delete extraErrorsBag.value[normalizedPath];
          }
        }
        state.errors = normalizeErrorItem(message);
        state.valid = !state.errors.length;
      }
      function setErrors(paths) {
        keysOf(paths).forEach((path) => {
          setFieldError(path, paths[path]);
        });
      }
      if (opts === null || opts === void 0 ? void 0 : opts.initialErrors) {
        setErrors(opts.initialErrors);
      }
      const errorBag = computed(() => {
        const pathErrors = pathStates.value.reduce((acc, state) => {
          if (state.errors.length) {
            acc[state.path] = state.errors;
          }
          return acc;
        }, {});
        return Object.assign(Object.assign({}, extraErrorsBag.value), pathErrors);
      });
      const errors2 = computed(() => {
        return keysOf(errorBag.value).reduce((acc, key) => {
          const errors22 = errorBag.value[key];
          if (errors22 === null || errors22 === void 0 ? void 0 : errors22.length) {
            acc[key] = errors22[0];
          }
          return acc;
        }, {});
      });
      const fieldNames = computed(() => {
        return pathStates.value.reduce((names2, state) => {
          names2[state.path] = { name: state.path || "", label: state.label || "" };
          return names2;
        }, {});
      });
      const fieldBailsMap = computed(() => {
        return pathStates.value.reduce((map2, state) => {
          var _a22;
          map2[state.path] = (_a22 = state.bails) !== null && _a22 !== void 0 ? _a22 : true;
          return map2;
        }, {});
      });
      const initialErrors = Object.assign({}, (opts === null || opts === void 0 ? void 0 : opts.initialErrors) || {});
      const keepValuesOnUnmount = (_a2 = opts === null || opts === void 0 ? void 0 : opts.keepValuesOnUnmount) !== null && _a2 !== void 0 ? _a2 : false;
      const { initialValues, originalInitialValues, setInitialValues } = useFormInitialValues(pathStates, formValues, opts);
      const meta = useFormMeta(pathStates, formValues, originalInitialValues, errors2);
      const controlledValues = computed(() => {
        return pathStates.value.reduce((acc, state) => {
          const value = getFromPath(formValues, state.path);
          setInPath(acc, state.path, value);
          return acc;
        }, {});
      });
      const schema2 = opts === null || opts === void 0 ? void 0 : opts.validationSchema;
      function createPathState(path, config2) {
        var _a22, _b;
        const initialValue = computed(() => getFromPath(initialValues.value, toValue$1(path)));
        const pathStateExists = pathStateLookup.value[toValue$1(path)];
        const isCheckboxOrRadio = (config2 === null || config2 === void 0 ? void 0 : config2.type) === "checkbox" || (config2 === null || config2 === void 0 ? void 0 : config2.type) === "radio";
        if (pathStateExists && isCheckboxOrRadio) {
          pathStateExists.multiple = true;
          const id22 = FIELD_ID_COUNTER++;
          if (Array.isArray(pathStateExists.id)) {
            pathStateExists.id.push(id22);
          } else {
            pathStateExists.id = [pathStateExists.id, id22];
          }
          pathStateExists.fieldsCount++;
          pathStateExists.__flags.pendingUnmount[id22] = false;
          return pathStateExists;
        }
        const currentValue = computed(() => getFromPath(formValues, toValue$1(path)));
        const pathValue = toValue$1(path);
        const unsetBatchIndex = UNSET_BATCH.findIndex((_path) => _path === pathValue);
        if (unsetBatchIndex !== -1) {
          UNSET_BATCH.splice(unsetBatchIndex, 1);
        }
        const isRequired = computed(() => {
          var _a3, _b2, _c, _d;
          const schemaValue = toValue$1(schema2);
          if (isTypedSchema(schemaValue)) {
            return (_b2 = (_a3 = schemaValue.describe) === null || _a3 === void 0 ? void 0 : _a3.call(schemaValue, toValue$1(path)).required) !== null && _b2 !== void 0 ? _b2 : false;
          }
          const configSchemaValue = toValue$1(config2 === null || config2 === void 0 ? void 0 : config2.schema);
          if (isTypedSchema(configSchemaValue)) {
            return (_d = (_c = configSchemaValue.describe) === null || _c === void 0 ? void 0 : _c.call(configSchemaValue).required) !== null && _d !== void 0 ? _d : false;
          }
          return false;
        });
        const id2 = FIELD_ID_COUNTER++;
        const state = reactive({
          id: id2,
          path,
          touched: false,
          pending: false,
          valid: true,
          validated: !!((_a22 = initialErrors[pathValue]) === null || _a22 === void 0 ? void 0 : _a22.length),
          required: isRequired,
          initialValue,
          errors: shallowRef([]),
          bails: (_b = config2 === null || config2 === void 0 ? void 0 : config2.bails) !== null && _b !== void 0 ? _b : false,
          label: config2 === null || config2 === void 0 ? void 0 : config2.label,
          type: (config2 === null || config2 === void 0 ? void 0 : config2.type) || "default",
          value: currentValue,
          multiple: false,
          __flags: {
            pendingUnmount: { [id2]: false },
            pendingReset: false
          },
          fieldsCount: 1,
          validate: config2 === null || config2 === void 0 ? void 0 : config2.validate,
          dirty: computed(() => {
            return !isEqual(unref(currentValue), unref(initialValue));
          })
        });
        pathStates.value.push(state);
        pathStateLookup.value[pathValue] = state;
        rebuildPathLookup();
        if (errors2.value[pathValue] && !initialErrors[pathValue]) {
          nextTick(() => {
            validateField(pathValue, { mode: "silent" });
          });
        }
        if (isRef(path)) {
          watch(path, (newPath) => {
            rebuildPathLookup();
            const nextValue = klona(currentValue.value);
            pathStateLookup.value[newPath] = state;
            nextTick(() => {
              setInPath(formValues, newPath, nextValue);
            });
          });
        }
        return state;
      }
      const debouncedSilentValidation = debounceAsync(_validateSchema, 5);
      const debouncedValidation = debounceAsync(_validateSchema, 5);
      const validateSchema = withLatest(async (mode) => {
        return await (mode === "silent" ? debouncedSilentValidation() : debouncedValidation());
      }, (formResult, [mode]) => {
        const currentErrorsPaths = keysOf(formCtx.errorBag.value);
        const paths = [
          .../* @__PURE__ */ new Set([...keysOf(formResult.results), ...pathStates.value.map((p2) => p2.path), ...currentErrorsPaths])
        ].sort();
        const results = paths.reduce((validation2, _path) => {
          var _a22;
          const expectedPath = _path;
          const pathState = findPathState(expectedPath) || findHoistedPath(expectedPath);
          const messages = ((_a22 = formResult.results[expectedPath]) === null || _a22 === void 0 ? void 0 : _a22.errors) || [];
          const path = toValue$1(pathState === null || pathState === void 0 ? void 0 : pathState.path) || expectedPath;
          const fieldResult = mergeValidationResults({ errors: messages, valid: !messages.length }, validation2.results[path]);
          validation2.results[path] = fieldResult;
          if (!fieldResult.valid) {
            validation2.errors[path] = fieldResult.errors[0];
          }
          if (pathState && extraErrorsBag.value[path]) {
            delete extraErrorsBag.value[path];
          }
          if (!pathState) {
            setFieldError(path, messages);
            return validation2;
          }
          pathState.valid = fieldResult.valid;
          if (mode === "silent") {
            return validation2;
          }
          if (mode === "validated-only" && !pathState.validated) {
            return validation2;
          }
          setFieldError(pathState, fieldResult.errors);
          return validation2;
        }, {
          valid: formResult.valid,
          results: {},
          errors: {},
          source: formResult.source
        });
        if (formResult.values) {
          results.values = formResult.values;
          results.source = formResult.source;
        }
        keysOf(results.results).forEach((path) => {
          var _a22;
          const pathState = findPathState(path);
          if (!pathState) {
            return;
          }
          if (mode === "silent") {
            return;
          }
          if (mode === "validated-only" && !pathState.validated) {
            return;
          }
          setFieldError(pathState, (_a22 = results.results[path]) === null || _a22 === void 0 ? void 0 : _a22.errors);
        });
        return results;
      });
      function mutateAllPathState(mutation) {
        pathStates.value.forEach(mutation);
      }
      function findPathState(path) {
        const normalizedPath = typeof path === "string" ? normalizeFormPath(path) : path;
        const pathState = typeof normalizedPath === "string" ? pathStateLookup.value[normalizedPath] : normalizedPath;
        return pathState;
      }
      function findHoistedPath(path) {
        const candidates = pathStates.value.filter((state) => path.startsWith(state.path));
        return candidates.reduce((bestCandidate, candidate) => {
          if (!bestCandidate) {
            return candidate;
          }
          return candidate.path.length > bestCandidate.path.length ? candidate : bestCandidate;
        }, void 0);
      }
      let UNSET_BATCH = [];
      let PENDING_UNSET;
      function unsetPathValue(path) {
        UNSET_BATCH.push(path);
        if (!PENDING_UNSET) {
          PENDING_UNSET = nextTick(() => {
            const sortedPaths = [...UNSET_BATCH].sort().reverse();
            sortedPaths.forEach((p2) => {
              unsetPath(formValues, p2);
            });
            UNSET_BATCH = [];
            PENDING_UNSET = null;
          });
        }
        return PENDING_UNSET;
      }
      function makeSubmissionFactory(onlyControlled) {
        return function submitHandlerFactory(fn, onValidationError) {
          return function submissionHandler(e) {
            if (e instanceof Event) {
              e.preventDefault();
              e.stopPropagation();
            }
            mutateAllPathState((s) => s.touched = true);
            isSubmitting.value = true;
            submitCount.value++;
            return validate2().then((result) => {
              const values = klona(formValues);
              if (result.valid && typeof fn === "function") {
                const controlled = klona(controlledValues.value);
                let submittedValues = onlyControlled ? controlled : values;
                if (result.values) {
                  submittedValues = result.source === "schema" ? result.values : Object.assign({}, submittedValues, result.values);
                }
                return fn(submittedValues, {
                  evt: e,
                  controlledValues: controlled,
                  setErrors,
                  setFieldError,
                  setTouched,
                  setFieldTouched,
                  setValues,
                  setFieldValue,
                  resetForm,
                  resetField
                });
              }
              if (!result.valid && typeof onValidationError === "function") {
                onValidationError({
                  values,
                  evt: e,
                  errors: result.errors,
                  results: result.results
                });
              }
            }).then((returnVal) => {
              isSubmitting.value = false;
              return returnVal;
            }, (err) => {
              isSubmitting.value = false;
              throw err;
            });
          };
        };
      }
      const handleSubmitImpl = makeSubmissionFactory(false);
      const handleSubmit = handleSubmitImpl;
      handleSubmit.withControlled = makeSubmissionFactory(true);
      function removePathState(path, id2) {
        const idx = pathStates.value.findIndex((s) => {
          return s.path === path && (Array.isArray(s.id) ? s.id.includes(id2) : s.id === id2);
        });
        const pathState = pathStates.value[idx];
        if (idx === -1 || !pathState) {
          return;
        }
        nextTick(() => {
          validateField(path, { mode: "silent", warn: false });
        });
        if (pathState.multiple && pathState.fieldsCount) {
          pathState.fieldsCount--;
        }
        if (Array.isArray(pathState.id)) {
          const idIndex = pathState.id.indexOf(id2);
          if (idIndex >= 0) {
            pathState.id.splice(idIndex, 1);
          }
          delete pathState.__flags.pendingUnmount[id2];
        }
        if (!pathState.multiple || pathState.fieldsCount <= 0) {
          pathStates.value.splice(idx, 1);
          unsetInitialValue(path);
          rebuildPathLookup();
          delete pathStateLookup.value[path];
        }
      }
      function destroyPath(path) {
        keysOf(pathStateLookup.value).forEach((key) => {
          if (key.startsWith(path)) {
            delete pathStateLookup.value[key];
          }
        });
        pathStates.value = pathStates.value.filter((s) => !s.path.startsWith(path));
        nextTick(() => {
          rebuildPathLookup();
        });
      }
      const formCtx = {
        formId,
        values: formValues,
        controlledValues,
        errorBag,
        errors: errors2,
        schema: schema2,
        submitCount,
        meta,
        isSubmitting,
        isValidating,
        fieldArrays,
        keepValuesOnUnmount,
        validateSchema: unref(schema2) ? validateSchema : void 0,
        validate: validate2,
        setFieldError,
        validateField,
        setFieldValue,
        setValues,
        setErrors,
        setFieldTouched,
        setTouched,
        resetForm,
        resetField,
        handleSubmit,
        useFieldModel,
        defineInputBinds,
        defineComponentBinds,
        defineField,
        stageInitialValue,
        unsetInitialValue,
        setFieldInitialValue,
        createPathState,
        getPathState: findPathState,
        unsetPathValue,
        removePathState,
        initialValues,
        getAllPathStates: () => pathStates.value,
        destroyPath,
        isFieldTouched,
        isFieldDirty,
        isFieldValid
      };
      function setFieldValue(field, value, shouldValidate = true) {
        const clonedValue = klona(value);
        const path = typeof field === "string" ? field : field.path;
        const pathState = findPathState(path);
        if (!pathState) {
          createPathState(path);
        }
        setInPath(formValues, path, clonedValue);
        if (shouldValidate) {
          validateField(path);
        }
      }
      function forceSetValues(fields, shouldValidate = true) {
        keysOf(formValues).forEach((key) => {
          delete formValues[key];
        });
        keysOf(fields).forEach((path) => {
          setFieldValue(path, fields[path], false);
        });
        if (shouldValidate) {
          validate2();
        }
      }
      function setValues(fields, shouldValidate = true) {
        merge$1(formValues, fields);
        fieldArrays.forEach((f) => f && f.reset());
        if (shouldValidate) {
          validate2();
        }
      }
      function createModel(path, shouldValidate) {
        const pathState = findPathState(toValue$1(path)) || createPathState(path);
        return computed({
          get() {
            return pathState.value;
          },
          set(value) {
            var _a22;
            const pathValue = toValue$1(path);
            setFieldValue(pathValue, value, (_a22 = toValue$1(shouldValidate)) !== null && _a22 !== void 0 ? _a22 : false);
          }
        });
      }
      function setFieldTouched(field, isTouched) {
        const pathState = findPathState(field);
        if (pathState) {
          pathState.touched = isTouched;
        }
      }
      function isFieldTouched(field) {
        const pathState = findPathState(field);
        if (pathState) {
          return pathState.touched;
        }
        return pathStates.value.filter((s) => s.path.startsWith(field)).some((s) => s.touched);
      }
      function isFieldDirty(field) {
        const pathState = findPathState(field);
        if (pathState) {
          return pathState.dirty;
        }
        return pathStates.value.filter((s) => s.path.startsWith(field)).some((s) => s.dirty);
      }
      function isFieldValid(field) {
        const pathState = findPathState(field);
        if (pathState) {
          return pathState.valid;
        }
        return pathStates.value.filter((s) => s.path.startsWith(field)).every((s) => s.valid);
      }
      function setTouched(fields) {
        if (typeof fields === "boolean") {
          mutateAllPathState((state) => {
            state.touched = fields;
          });
          return;
        }
        keysOf(fields).forEach((field) => {
          setFieldTouched(field, !!fields[field]);
        });
      }
      function resetField(field, state) {
        var _a22;
        const newValue = state && "value" in state ? state.value : getFromPath(initialValues.value, field);
        const pathState = findPathState(field);
        if (pathState) {
          pathState.__flags.pendingReset = true;
        }
        setFieldInitialValue(field, klona(newValue), true);
        setFieldValue(field, newValue, false);
        setFieldTouched(field, (_a22 = state === null || state === void 0 ? void 0 : state.touched) !== null && _a22 !== void 0 ? _a22 : false);
        setFieldError(field, (state === null || state === void 0 ? void 0 : state.errors) || []);
        nextTick(() => {
          if (pathState) {
            pathState.__flags.pendingReset = false;
          }
        });
      }
      function resetForm(resetState, opts2) {
        let newValues = klona((resetState === null || resetState === void 0 ? void 0 : resetState.values) ? resetState.values : originalInitialValues.value);
        newValues = (opts2 === null || opts2 === void 0 ? void 0 : opts2.force) ? newValues : merge$1(originalInitialValues.value, newValues);
        newValues = isTypedSchema(schema2) && isCallable(schema2.cast) ? schema2.cast(newValues) : newValues;
        setInitialValues(newValues, { force: opts2 === null || opts2 === void 0 ? void 0 : opts2.force });
        mutateAllPathState((state) => {
          var _a22;
          state.__flags.pendingReset = true;
          state.validated = false;
          state.touched = ((_a22 = resetState === null || resetState === void 0 ? void 0 : resetState.touched) === null || _a22 === void 0 ? void 0 : _a22[state.path]) || false;
          setFieldValue(state.path, getFromPath(newValues, state.path), false);
          setFieldError(state.path, void 0);
        });
        (opts2 === null || opts2 === void 0 ? void 0 : opts2.force) ? forceSetValues(newValues, false) : setValues(newValues, false);
        setErrors((resetState === null || resetState === void 0 ? void 0 : resetState.errors) || {});
        submitCount.value = (resetState === null || resetState === void 0 ? void 0 : resetState.submitCount) || 0;
        nextTick(() => {
          validate2({ mode: "silent" });
          mutateAllPathState((state) => {
            state.__flags.pendingReset = false;
          });
        });
      }
      async function validate2(opts2) {
        const mode = (opts2 === null || opts2 === void 0 ? void 0 : opts2.mode) || "force";
        if (mode === "force") {
          mutateAllPathState((f) => f.validated = true);
        }
        if (formCtx.validateSchema) {
          return formCtx.validateSchema(mode);
        }
        isValidating.value = true;
        const validations = await Promise.all(pathStates.value.map((state) => {
          if (!state.validate) {
            return Promise.resolve({
              key: state.path,
              valid: true,
              errors: [],
              value: void 0
            });
          }
          return state.validate(opts2).then((result) => {
            return {
              key: state.path,
              valid: result.valid,
              errors: result.errors,
              value: result.value
            };
          });
        }));
        isValidating.value = false;
        const results = {};
        const errors22 = {};
        const values = {};
        for (const validation2 of validations) {
          results[validation2.key] = {
            valid: validation2.valid,
            errors: validation2.errors
          };
          if (validation2.value) {
            setInPath(values, validation2.key, validation2.value);
          }
          if (validation2.errors.length) {
            errors22[validation2.key] = validation2.errors[0];
          }
        }
        return {
          valid: validations.every((r2) => r2.valid),
          results,
          errors: errors22,
          values,
          source: "fields"
        };
      }
      async function validateField(path, opts2) {
        var _a22;
        const state = findPathState(path);
        if (state && (opts2 === null || opts2 === void 0 ? void 0 : opts2.mode) !== "silent") {
          state.validated = true;
        }
        if (schema2) {
          const { results } = await validateSchema((opts2 === null || opts2 === void 0 ? void 0 : opts2.mode) || "validated-only");
          return results[path] || { errors: [], valid: true };
        }
        if (state === null || state === void 0 ? void 0 : state.validate) {
          return state.validate(opts2);
        }
        !state && ((_a22 = opts2 === null || opts2 === void 0 ? void 0 : opts2.warn) !== null && _a22 !== void 0 ? _a22 : true);
        return Promise.resolve({ errors: [], valid: true });
      }
      function unsetInitialValue(path) {
        unsetPath(initialValues.value, path);
      }
      function stageInitialValue(path, value, updateOriginal = false) {
        setFieldInitialValue(path, value);
        setInPath(formValues, path, value);
        if (updateOriginal && !(opts === null || opts === void 0 ? void 0 : opts.initialValues)) {
          setInPath(originalInitialValues.value, path, klona(value));
        }
      }
      function setFieldInitialValue(path, value, updateOriginal = false) {
        setInPath(initialValues.value, path, klona(value));
        if (updateOriginal) {
          setInPath(originalInitialValues.value, path, klona(value));
        }
      }
      async function _validateSchema() {
        const schemaValue = unref(schema2);
        if (!schemaValue) {
          return { valid: true, results: {}, errors: {}, source: "none" };
        }
        isValidating.value = true;
        const formResult = isYupValidator(schemaValue) || isTypedSchema(schemaValue) ? await validateTypedSchema(schemaValue, formValues) : await validateObjectSchema(schemaValue, formValues, {
          names: fieldNames.value,
          bailsMap: fieldBailsMap.value
        });
        isValidating.value = false;
        return formResult;
      }
      const submitForm = handleSubmit((_, { evt }) => {
        if (isFormSubmitEvent(evt)) {
          evt.target.submit();
        }
      });
      onMounted(() => {
        if (opts === null || opts === void 0 ? void 0 : opts.initialErrors) {
          setErrors(opts.initialErrors);
        }
        if (opts === null || opts === void 0 ? void 0 : opts.initialTouched) {
          setTouched(opts.initialTouched);
        }
        if (opts === null || opts === void 0 ? void 0 : opts.validateOnMount) {
          validate2();
          return;
        }
        if (formCtx.validateSchema) {
          formCtx.validateSchema("silent");
        }
      });
      if (isRef(schema2)) {
        watch(schema2, () => {
          var _a22;
          (_a22 = formCtx.validateSchema) === null || _a22 === void 0 ? void 0 : _a22.call(formCtx, "validated-only");
        });
      }
      provide(FormContextKey, formCtx);
      function defineField(path, config2) {
        const label = isCallable(config2) ? void 0 : config2 === null || config2 === void 0 ? void 0 : config2.label;
        const pathState = findPathState(toValue$1(path)) || createPathState(path, { label });
        const evalConfig = () => isCallable(config2) ? config2(omit(pathState, PRIVATE_PATH_STATE_KEYS)) : config2 || {};
        function onBlur() {
          var _a22;
          pathState.touched = true;
          const validateOnBlur = (_a22 = evalConfig().validateOnBlur) !== null && _a22 !== void 0 ? _a22 : getConfig().validateOnBlur;
          if (validateOnBlur) {
            validateField(pathState.path);
          }
        }
        function onInput() {
          var _a22;
          const validateOnInput = (_a22 = evalConfig().validateOnInput) !== null && _a22 !== void 0 ? _a22 : getConfig().validateOnInput;
          if (validateOnInput) {
            nextTick(() => {
              validateField(pathState.path);
            });
          }
        }
        function onChange() {
          var _a22;
          const validateOnChange = (_a22 = evalConfig().validateOnChange) !== null && _a22 !== void 0 ? _a22 : getConfig().validateOnChange;
          if (validateOnChange) {
            nextTick(() => {
              validateField(pathState.path);
            });
          }
        }
        const props = computed(() => {
          const base2 = {
            onChange,
            onInput,
            onBlur
          };
          if (isCallable(config2)) {
            return Object.assign(Object.assign({}, base2), config2(omit(pathState, PRIVATE_PATH_STATE_KEYS)).props || {});
          }
          if (config2 === null || config2 === void 0 ? void 0 : config2.props) {
            return Object.assign(Object.assign({}, base2), config2.props(omit(pathState, PRIVATE_PATH_STATE_KEYS)));
          }
          return base2;
        });
        const model = createModel(path, () => {
          var _a22, _b, _c;
          return (_c = (_a22 = evalConfig().validateOnModelUpdate) !== null && _a22 !== void 0 ? _a22 : (_b = getConfig()) === null || _b === void 0 ? void 0 : _b.validateOnModelUpdate) !== null && _c !== void 0 ? _c : true;
        });
        return [model, props];
      }
      function useFieldModel(pathOrPaths) {
        if (!Array.isArray(pathOrPaths)) {
          return createModel(pathOrPaths);
        }
        return pathOrPaths.map((p2) => createModel(p2, true));
      }
      function defineInputBinds(path, config2) {
        const [model, props] = defineField(path, config2);
        function onBlur() {
          props.value.onBlur();
        }
        function onInput(e) {
          const value = normalizeEventValue(e);
          setFieldValue(toValue$1(path), value, false);
          props.value.onInput();
        }
        function onChange(e) {
          const value = normalizeEventValue(e);
          setFieldValue(toValue$1(path), value, false);
          props.value.onChange();
        }
        return computed(() => {
          return Object.assign(Object.assign({}, props.value), {
            onBlur,
            onInput,
            onChange,
            value: model.value
          });
        });
      }
      function defineComponentBinds(path, config2) {
        const [model, props] = defineField(path, config2);
        const pathState = findPathState(toValue$1(path));
        function onUpdateModelValue(value) {
          model.value = value;
        }
        return computed(() => {
          const conf = isCallable(config2) ? config2(omit(pathState, PRIVATE_PATH_STATE_KEYS)) : config2 || {};
          return Object.assign({ [conf.model || "modelValue"]: model.value, [`onUpdate:${conf.model || "modelValue"}`]: onUpdateModelValue }, props.value);
        });
      }
      return Object.assign(Object.assign({}, formCtx), { values: readonly(formValues), handleReset: () => resetForm(), submitForm });
    }
    function useFormMeta(pathsState, currentValues, initialValues, errors2) {
      const MERGE_STRATEGIES = {
        touched: "some",
        pending: "some",
        valid: "every"
      };
      const isDirty = computed(() => {
        return !isEqual(currentValues, unref(initialValues));
      });
      function calculateFlags() {
        const states = pathsState.value;
        return keysOf(MERGE_STRATEGIES).reduce((acc, flag) => {
          const mergeMethod = MERGE_STRATEGIES[flag];
          acc[flag] = states[mergeMethod]((s) => s[flag]);
          return acc;
        }, {});
      }
      const flags = reactive(calculateFlags());
      watchEffect(() => {
        const value = calculateFlags();
        flags.touched = value.touched;
        flags.valid = value.valid;
        flags.pending = value.pending;
      });
      return computed(() => {
        return Object.assign(Object.assign({ initialValues: unref(initialValues) }, flags), { valid: flags.valid && !keysOf(errors2.value).length, dirty: isDirty.value });
      });
    }
    function useFormInitialValues(pathsState, formValues, opts) {
      const values = resolveInitialValues(opts);
      const initialValues = ref$1(values);
      const originalInitialValues = ref$1(klona(values));
      function setInitialValues(values2, opts2) {
        if (opts2 === null || opts2 === void 0 ? void 0 : opts2.force) {
          initialValues.value = klona(values2);
          originalInitialValues.value = klona(values2);
        } else {
          initialValues.value = merge$1(klona(initialValues.value) || {}, klona(values2));
          originalInitialValues.value = merge$1(klona(originalInitialValues.value) || {}, klona(values2));
        }
        if (!(opts2 === null || opts2 === void 0 ? void 0 : opts2.updateFields)) {
          return;
        }
        pathsState.value.forEach((state) => {
          const wasTouched = state.touched;
          if (wasTouched) {
            return;
          }
          const newValue = getFromPath(initialValues.value, state.path);
          setInPath(formValues, state.path, klona(newValue));
        });
      }
      return {
        initialValues,
        originalInitialValues,
        setInitialValues
      };
    }
    function mergeValidationResults(a, b) {
      if (!b) {
        return a;
      }
      return {
        valid: a.valid && b.valid,
        errors: [...a.errors, ...b.errors]
      };
    }
    var ComponentViews = /* @__PURE__ */ ((ComponentViews2) => {
      ComponentViews2[ComponentViews2["LIST"] = 0] = "LIST";
      ComponentViews2[ComponentViews2["EDIT"] = 1] = "EDIT";
      ComponentViews2[ComponentViews2["ADD"] = 2] = "ADD";
      return ComponentViews2;
    })(ComponentViews || {});
    const _sfc_main$K = /* @__PURE__ */ defineComponent$1({
      setup() {
        const evbc2 = inject$1("evbc");
        const servers = reactive([
          {
            id: "Simulator / Mock",
            host: "loopback",
            editable: false,
            protocol: "ws",
            hint: "Mock EVerest Instance for testing: simulates behavior without real data transmission. Not perfect, but useful for development.",
            port: 8849
          },
          {
            id: "Instance on localhost",
            host: "localhost",
            editable: true,
            protocol: "ws",
            port: 8849
          }
        ]);
        const currentView = ref$1(
          0
          /* LIST */
        );
        const connectAutomatically = ref$1(false);
        watch(connectAutomatically, () => {
          submitLocalStorageSettings();
        });
        const currentlyEditing = ref$1(null);
        const connecting = ref$1(false);
        const connectionStatus = ref$1(null);
        const error2 = reactive({ active: false, status: "" });
        const { meta, handleSubmit } = useForm$1({
          validationSchema: {
            instanceId: (value) => {
              if (value === void 0 || value.trim().length < 1) {
                return "Please enter a name with at least one character.";
              } else {
                return true;
              }
            },
            host: (value) => {
              if (value === void 0 || value.trim().length < 1) {
                return "Please enter a host.";
              }
              if (value.includes("://")) {
                return 'Please enter a domain without any protocol (e.g., "test.pionix.de").';
              }
              const domainPattern = /.*:\d+$/;
              if (domainPattern.test(value)) {
                return "Please don't enter a port here.";
              } else {
                return true;
              }
            },
            port: (value) => {
              if (value === void 0 || value < 1 || value > 65535) {
                return "Please enter a valid port number.";
              } else {
                return true;
              }
            }
          }
        });
        const instanceId = useField("instanceId");
        const host = useField("host");
        const port = useField("port");
        const protocol = useField("protocol");
        const openAddServerView = () => {
          resetFields();
          currentView.value = 2;
        };
        const resetFields = () => {
          instanceId.value.value = "";
          host.value.value = "";
          port.value.value = 8849;
          protocol.value.value = "ws";
          currentlyEditing.value = null;
        };
        const openEditServerView = (index) => {
          currentlyEditing.value = servers[index];
          protocol.value.value = servers[index].protocol;
          host.value.value = servers[index].host;
          port.value.value = servers[index].port;
          instanceId.value.value = servers[index].id;
          currentView.value = 1;
        };
        const submitEdit = handleSubmit(async () => {
          if (currentlyEditing.value !== null) {
            currentlyEditing.value.id = instanceId.value.value;
            currentlyEditing.value.host = host.value.value;
            currentlyEditing.value.protocol = protocol.value.value;
            currentlyEditing.value.port = port.value.value;
          } else {
            servers.push({
              id: instanceId.value.value,
              host: host.value.value,
              editable: true,
              protocol: protocol.value.value,
              port: port.value.value
            });
          }
          closeEdit();
          submitLocalStorageSettings();
        });
        const closeEdit = () => {
          currentView.value = 0;
          resetFields();
        };
        const deleteItem = () => {
          servers.splice(servers.indexOf(currentlyEditing.value), 1);
          closeEdit();
          submitLocalStorageSettings();
        };
        const submitLocalStorageSettings = () => {
          window.localStorage.setItem(
            "evbcSettings",
            JSON.stringify({
              servers,
              connectAutomatically: connectAutomatically.value
            })
          );
        };
        const connect = (server) => {
          window.localStorage.setItem("lastConnectedServer", JSON.stringify(server));
          connecting.value = true;
          if (evbc2) {
            evbc2.connect(server.protocol + "://" + server.host + ":" + server.port);
          }
        };
        onMounted(() => {
          var _a2;
          const router2 = useRouter$1();
          const storage = window.localStorage;
          const evbcLsString = storage.getItem("evbcSettings");
          if (evbcLsString) {
            const evbcLocalStorage = JSON.parse(evbcLsString);
            if ("servers" in evbcLocalStorage) {
              servers.splice(0, servers.length);
              servers.push(...evbcLocalStorage.servers);
            }
            if ("connectAutomatically" in evbcLocalStorage) {
              connectAutomatically.value = evbcLocalStorage.connectAutomatically;
              if (router2.currentRoute.value.query.auto_connect !== "false" && connectAutomatically.value && ((_a2 = window.localStorage) == null ? void 0 : _a2.getItem("lastConnectedServer")) !== null) {
                const lastServer = JSON.parse(window.localStorage.getItem("lastConnectedServer"));
                connect(lastServer);
              }
            }
          }
          if (evbc2) {
            const unsubscribe = evbc2.on("connection_state", (ev) => {
              if (ev.type === "INFO") {
                connectionStatus.value = ev.text;
              } else if (ev.type === "INITIALIZED") {
                unsubscribe();
                router2.push({ name: "main" });
              } else if (ev.type === "FAILED") {
                connecting.value = false;
                error2.active = true;
                error2.status = ev.text;
              } else if (ev.type === "IDLE") {
                connecting.value = false;
                connectionStatus.value = "";
              }
            });
          }
        });
        return {
          servers,
          connectAutomatically,
          connecting,
          connectionStatus,
          error: error2,
          openAddServerView,
          openEditServerView,
          submitEdit,
          closeEdit,
          deleteItem,
          submitLocalStorageSettings,
          connect,
          meta,
          host,
          instanceId,
          protocol,
          port,
          currentView,
          currentlyEditing,
          ComponentViews
        };
      }
    });
    const VAlertTitle = createSimpleFunctional("v-alert-title");
    const allowedTypes = ["success", "info", "warning", "error"];
    const makeVAlertProps = propsFactory({
      border: {
        type: [Boolean, String],
        validator: (val) => {
          return typeof val === "boolean" || ["top", "end", "bottom", "start"].includes(val);
        }
      },
      borderColor: String,
      closable: Boolean,
      closeIcon: {
        type: IconValue,
        default: "$close"
      },
      closeLabel: {
        type: String,
        default: "$vuetify.close"
      },
      icon: {
        type: [Boolean, String, Function, Object],
        default: null
      },
      modelValue: {
        type: Boolean,
        default: true
      },
      prominent: Boolean,
      title: String,
      text: String,
      type: {
        type: String,
        validator: (val) => allowedTypes.includes(val)
      },
      ...makeComponentProps(),
      ...makeDensityProps(),
      ...makeDimensionProps(),
      ...makeElevationProps(),
      ...makeLocationProps(),
      ...makePositionProps(),
      ...makeRoundedProps(),
      ...makeTagProps(),
      ...makeThemeProps(),
      ...makeVariantProps({
        variant: "flat"
      })
    }, "VAlert");
    const VAlert = genericComponent()({
      name: "VAlert",
      props: makeVAlertProps(),
      emits: {
        "click:close": (e) => true,
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          emit: emit2,
          slots
        } = _ref;
        const isActive = useProxiedModel(props, "modelValue");
        const icon = computed(() => {
          if (props.icon === false)
            return void 0;
          if (!props.type)
            return props.icon;
          return props.icon ?? `$${props.type}`;
        });
        const variantProps = computed(() => ({
          color: props.color ?? props.type,
          variant: props.variant
        }));
        const {
          themeClasses
        } = provideTheme(props);
        const {
          colorClasses,
          colorStyles,
          variantClasses
        } = useVariant(variantProps);
        const {
          densityClasses
        } = useDensity(props);
        const {
          dimensionStyles
        } = useDimension(props);
        const {
          elevationClasses
        } = useElevation(props);
        const {
          locationStyles
        } = useLocation(props);
        const {
          positionClasses
        } = usePosition(props);
        const {
          roundedClasses
        } = useRounded(props);
        const {
          textColorClasses,
          textColorStyles
        } = useTextColor(toRef(props, "borderColor"));
        const {
          t
        } = useLocale();
        const closeProps = computed(() => ({
          "aria-label": t(props.closeLabel),
          onClick(e) {
            isActive.value = false;
            emit2("click:close", e);
          }
        }));
        return () => {
          const hasPrepend = !!(slots.prepend || icon.value);
          const hasTitle = !!(slots.title || props.title);
          const hasClose = !!(slots.close || props.closable);
          return isActive.value && createVNode(props.tag, {
            "class": ["v-alert", props.border && {
              "v-alert--border": !!props.border,
              [`v-alert--border-${props.border === true ? "start" : props.border}`]: true
            }, {
              "v-alert--prominent": props.prominent
            }, themeClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, variantClasses.value, props.class],
            "style": [colorStyles.value, dimensionStyles.value, locationStyles.value, props.style],
            "role": "alert"
          }, {
            default: () => {
              var _a2, _b;
              return [genOverlays(false, "v-alert"), props.border && createVNode("div", {
                "key": "border",
                "class": ["v-alert__border", textColorClasses.value],
                "style": textColorStyles.value
              }, null), hasPrepend && createVNode("div", {
                "key": "prepend",
                "class": "v-alert__prepend"
              }, [!slots.prepend ? createVNode(VIcon, {
                "key": "prepend-icon",
                "density": props.density,
                "icon": icon.value,
                "size": props.prominent ? 44 : 28
              }, null) : createVNode(VDefaultsProvider, {
                "key": "prepend-defaults",
                "disabled": !icon.value,
                "defaults": {
                  VIcon: {
                    density: props.density,
                    icon: icon.value,
                    size: props.prominent ? 44 : 28
                  }
                }
              }, slots.prepend)]), createVNode("div", {
                "class": "v-alert__content"
              }, [hasTitle && createVNode(VAlertTitle, {
                "key": "title"
              }, {
                default: () => {
                  var _a3;
                  return [((_a3 = slots.title) == null ? void 0 : _a3.call(slots)) ?? props.title];
                }
              }), ((_a2 = slots.text) == null ? void 0 : _a2.call(slots)) ?? props.text, (_b = slots.default) == null ? void 0 : _b.call(slots)]), slots.append && createVNode("div", {
                "key": "append",
                "class": "v-alert__append"
              }, [slots.append()]), hasClose && createVNode("div", {
                "key": "close",
                "class": "v-alert__close"
              }, [!slots.close ? createVNode(VBtn, mergeProps({
                "key": "close-btn",
                "icon": props.closeIcon,
                "size": "x-small",
                "variant": "text"
              }, closeProps.value), null) : createVNode(VDefaultsProvider, {
                "key": "close-defaults",
                "defaults": {
                  VBtn: {
                    icon: props.closeIcon,
                    size: "x-small",
                    variant: "text"
                  }
                }
              }, {
                default: () => {
                  var _a3;
                  return [(_a3 = slots.close) == null ? void 0 : _a3.call(slots, {
                    props: closeProps.value
                  })];
                }
              })])];
            }
          });
        };
      }
    });
    const makeVLabelProps = propsFactory({
      text: String,
      onClick: EventProp(),
      ...makeComponentProps(),
      ...makeThemeProps()
    }, "VLabel");
    const VLabel = genericComponent()({
      name: "VLabel",
      props: makeVLabelProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        useRender(() => {
          var _a2;
          return createVNode("label", {
            "class": ["v-label", {
              "v-label--clickable": !!props.onClick
            }, props.class],
            "style": props.style,
            "onClick": props.onClick
          }, [props.text, (_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
        });
        return {};
      }
    });
    const VSelectionControlGroupSymbol = Symbol.for("vuetify:selection-control-group");
    const makeSelectionControlGroupProps = propsFactory({
      color: String,
      disabled: {
        type: Boolean,
        default: null
      },
      defaultsTarget: String,
      error: Boolean,
      id: String,
      inline: Boolean,
      falseIcon: IconValue,
      trueIcon: IconValue,
      ripple: {
        type: [Boolean, Object],
        default: true
      },
      multiple: {
        type: Boolean,
        default: null
      },
      name: String,
      readonly: {
        type: Boolean,
        default: null
      },
      modelValue: null,
      type: String,
      valueComparator: {
        type: Function,
        default: deepEqual
      },
      ...makeComponentProps(),
      ...makeDensityProps(),
      ...makeThemeProps()
    }, "SelectionControlGroup");
    const makeVSelectionControlGroupProps = propsFactory({
      ...makeSelectionControlGroupProps({
        defaultsTarget: "VSelectionControl"
      })
    }, "VSelectionControlGroup");
    const VSelectionControlGroup = genericComponent()({
      name: "VSelectionControlGroup",
      props: makeVSelectionControlGroupProps(),
      emits: {
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const modelValue = useProxiedModel(props, "modelValue");
        const uid2 = getUid();
        const id2 = computed(() => props.id || `v-selection-control-group-${uid2}`);
        const name = computed(() => props.name || id2.value);
        const updateHandlers = /* @__PURE__ */ new Set();
        provide(VSelectionControlGroupSymbol, {
          modelValue,
          forceUpdate: () => {
            updateHandlers.forEach((fn) => fn());
          },
          onForceUpdate: (cb) => {
            updateHandlers.add(cb);
            onScopeDispose(() => {
              updateHandlers.delete(cb);
            });
          }
        });
        provideDefaults({
          [props.defaultsTarget]: {
            color: toRef(props, "color"),
            disabled: toRef(props, "disabled"),
            density: toRef(props, "density"),
            error: toRef(props, "error"),
            inline: toRef(props, "inline"),
            modelValue,
            multiple: computed(() => !!props.multiple || props.multiple == null && Array.isArray(modelValue.value)),
            name,
            falseIcon: toRef(props, "falseIcon"),
            trueIcon: toRef(props, "trueIcon"),
            readonly: toRef(props, "readonly"),
            ripple: toRef(props, "ripple"),
            type: toRef(props, "type"),
            valueComparator: toRef(props, "valueComparator")
          }
        });
        useRender(() => {
          var _a2;
          return createVNode("div", {
            "class": ["v-selection-control-group", {
              "v-selection-control-group--inline": props.inline
            }, props.class],
            "style": props.style,
            "role": props.type === "radio" ? "radiogroup" : void 0
          }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
        });
        return {};
      }
    });
    const makeVSelectionControlProps = propsFactory({
      label: String,
      baseColor: String,
      trueValue: null,
      falseValue: null,
      value: null,
      ...makeComponentProps(),
      ...makeSelectionControlGroupProps()
    }, "VSelectionControl");
    function useSelectionControl(props) {
      const group = inject$1(VSelectionControlGroupSymbol, void 0);
      const {
        densityClasses
      } = useDensity(props);
      const modelValue = useProxiedModel(props, "modelValue");
      const trueValue = computed(() => props.trueValue !== void 0 ? props.trueValue : props.value !== void 0 ? props.value : true);
      const falseValue = computed(() => props.falseValue !== void 0 ? props.falseValue : false);
      const isMultiple = computed(() => !!props.multiple || props.multiple == null && Array.isArray(modelValue.value));
      const model = computed({
        get() {
          const val = group ? group.modelValue.value : modelValue.value;
          return isMultiple.value ? wrapInArray(val).some((v) => props.valueComparator(v, trueValue.value)) : props.valueComparator(val, trueValue.value);
        },
        set(val) {
          if (props.readonly)
            return;
          const currentValue = val ? trueValue.value : falseValue.value;
          let newVal = currentValue;
          if (isMultiple.value) {
            newVal = val ? [...wrapInArray(modelValue.value), currentValue] : wrapInArray(modelValue.value).filter((item) => !props.valueComparator(item, trueValue.value));
          }
          if (group) {
            group.modelValue.value = newVal;
          } else {
            modelValue.value = newVal;
          }
        }
      });
      const {
        textColorClasses,
        textColorStyles
      } = useTextColor(computed(() => {
        if (props.error || props.disabled)
          return void 0;
        return model.value ? props.color : props.baseColor;
      }));
      const {
        backgroundColorClasses,
        backgroundColorStyles
      } = useBackgroundColor(computed(() => {
        return model.value && !props.error && !props.disabled ? props.color : props.baseColor;
      }));
      const icon = computed(() => model.value ? props.trueIcon : props.falseIcon);
      return {
        group,
        densityClasses,
        trueValue,
        falseValue,
        model,
        textColorClasses,
        textColorStyles,
        backgroundColorClasses,
        backgroundColorStyles,
        icon
      };
    }
    const VSelectionControl = genericComponent()({
      name: "VSelectionControl",
      directives: {
        Ripple
      },
      inheritAttrs: false,
      props: makeVSelectionControlProps(),
      emits: {
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          slots
        } = _ref;
        const {
          group,
          densityClasses,
          icon,
          model,
          textColorClasses,
          textColorStyles,
          backgroundColorClasses,
          backgroundColorStyles,
          trueValue
        } = useSelectionControl(props);
        const uid2 = getUid();
        const isFocused = shallowRef(false);
        const isFocusVisible = shallowRef(false);
        const input = ref$1();
        const id2 = computed(() => props.id || `input-${uid2}`);
        const isInteractive = computed(() => !props.disabled && !props.readonly);
        group == null ? void 0 : group.onForceUpdate(() => {
          if (input.value) {
            input.value.checked = model.value;
          }
        });
        function onFocus(e) {
          if (!isInteractive.value)
            return;
          isFocused.value = true;
          if (matchesSelector(e.target, ":focus-visible") !== false) {
            isFocusVisible.value = true;
          }
        }
        function onBlur() {
          isFocused.value = false;
          isFocusVisible.value = false;
        }
        function onClickLabel(e) {
          e.stopPropagation();
        }
        function onInput(e) {
          if (!isInteractive.value) {
            if (input.value) {
              input.value.checked = model.value;
            }
            return;
          }
          if (props.readonly && group) {
            nextTick(() => group.forceUpdate());
          }
          model.value = e.target.checked;
        }
        useRender(() => {
          var _a2, _b;
          const label = slots.label ? slots.label({
            label: props.label,
            props: {
              for: id2.value
            }
          }) : props.label;
          const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
          const inputNode = createVNode("input", mergeProps({
            "ref": input,
            "checked": model.value,
            "disabled": !!props.disabled,
            "id": id2.value,
            "onBlur": onBlur,
            "onFocus": onFocus,
            "onInput": onInput,
            "aria-disabled": !!props.disabled,
            "aria-label": props.label,
            "type": props.type,
            "value": trueValue.value,
            "name": props.name,
            "aria-checked": props.type === "checkbox" ? model.value : void 0
          }, inputAttrs), null);
          return createVNode("div", mergeProps({
            "class": ["v-selection-control", {
              "v-selection-control--dirty": model.value,
              "v-selection-control--disabled": props.disabled,
              "v-selection-control--error": props.error,
              "v-selection-control--focused": isFocused.value,
              "v-selection-control--focus-visible": isFocusVisible.value,
              "v-selection-control--inline": props.inline
            }, densityClasses.value, props.class]
          }, rootAttrs, {
            "style": props.style
          }), [createVNode("div", {
            "class": ["v-selection-control__wrapper", textColorClasses.value],
            "style": textColorStyles.value
          }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
            backgroundColorClasses,
            backgroundColorStyles
          }), withDirectives(createVNode("div", {
            "class": ["v-selection-control__input"]
          }, [((_b = slots.input) == null ? void 0 : _b.call(slots, {
            model,
            textColorClasses,
            textColorStyles,
            backgroundColorClasses,
            backgroundColorStyles,
            inputNode,
            icon: icon.value,
            props: {
              onFocus,
              onBlur,
              id: id2.value
            }
          })) ?? createVNode(Fragment, null, [icon.value && createVNode(VIcon, {
            "key": "icon",
            "icon": icon.value
          }, null), inputNode])]), [[resolveDirective("ripple"), props.ripple && [!props.disabled && !props.readonly, null, ["center", "circle"]]]])]), label && createVNode(VLabel, {
            "for": id2.value,
            "onClick": onClickLabel
          }, {
            default: () => [label]
          })]);
        });
        return {
          isFocused,
          input
        };
      }
    });
    const makeVCheckboxBtnProps = propsFactory({
      indeterminate: Boolean,
      indeterminateIcon: {
        type: IconValue,
        default: "$checkboxIndeterminate"
      },
      ...makeVSelectionControlProps({
        falseIcon: "$checkboxOff",
        trueIcon: "$checkboxOn"
      })
    }, "VCheckboxBtn");
    const VCheckboxBtn = genericComponent()({
      name: "VCheckboxBtn",
      props: makeVCheckboxBtnProps(),
      emits: {
        "update:modelValue": (value) => true,
        "update:indeterminate": (value) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const indeterminate = useProxiedModel(props, "indeterminate");
        const model = useProxiedModel(props, "modelValue");
        function onChange(v) {
          if (indeterminate.value) {
            indeterminate.value = false;
          }
        }
        const falseIcon = computed(() => {
          return indeterminate.value ? props.indeterminateIcon : props.falseIcon;
        });
        const trueIcon = computed(() => {
          return indeterminate.value ? props.indeterminateIcon : props.trueIcon;
        });
        useRender(() => {
          const controlProps = omit$1(VSelectionControl.filterProps(props), ["modelValue"]);
          return createVNode(VSelectionControl, mergeProps(controlProps, {
            "modelValue": model.value,
            "onUpdate:modelValue": [($event) => model.value = $event, onChange],
            "class": ["v-checkbox-btn", props.class],
            "style": props.style,
            "type": "checkbox",
            "falseIcon": falseIcon.value,
            "trueIcon": trueIcon.value,
            "aria-checked": indeterminate.value ? "mixed" : void 0
          }), slots);
        });
        return {};
      }
    });
    function useInputIcon(props) {
      const {
        t
      } = useLocale();
      function InputIcon(_ref) {
        let {
          name
        } = _ref;
        const localeKey = {
          prepend: "prependAction",
          prependInner: "prependAction",
          append: "appendAction",
          appendInner: "appendAction",
          clear: "clear"
        }[name];
        const listener = props[`onClick:${name}`];
        const label = listener && localeKey ? t(`$vuetify.input.${localeKey}`, props.label ?? "") : void 0;
        return createVNode(VIcon, {
          "icon": props[`${name}Icon`],
          "aria-label": label,
          "onClick": listener
        }, null);
      }
      return {
        InputIcon
      };
    }
    const makeVMessagesProps = propsFactory({
      active: Boolean,
      color: String,
      messages: {
        type: [Array, String],
        default: () => []
      },
      ...makeComponentProps(),
      ...makeTransitionProps({
        transition: {
          component: VSlideYTransition,
          leaveAbsolute: true,
          group: true
        }
      })
    }, "VMessages");
    const VMessages = genericComponent()({
      name: "VMessages",
      props: makeVMessagesProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const messages = computed(() => wrapInArray(props.messages));
        const {
          textColorClasses,
          textColorStyles
        } = useTextColor(computed(() => props.color));
        useRender(() => createVNode(MaybeTransition, {
          "transition": props.transition,
          "tag": "div",
          "class": ["v-messages", textColorClasses.value, props.class],
          "style": [textColorStyles.value, props.style],
          "role": "alert",
          "aria-live": "polite"
        }, {
          default: () => [props.active && messages.value.map((message, i2) => createVNode("div", {
            "class": "v-messages__message",
            "key": `${i2}-${messages.value}`
          }, [slots.message ? slots.message({
            message
          }) : message]))]
        }));
        return {};
      }
    });
    const makeFocusProps = propsFactory({
      focused: Boolean,
      "onUpdate:focused": EventProp()
    }, "focus");
    function useFocus(props) {
      let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
      const isFocused = useProxiedModel(props, "focused");
      const focusClasses = computed(() => {
        return {
          [`${name}--focused`]: isFocused.value
        };
      });
      function focus() {
        isFocused.value = true;
      }
      function blur() {
        isFocused.value = false;
      }
      return {
        focusClasses,
        isFocused,
        focus,
        blur
      };
    }
    const FormKey = Symbol.for("vuetify:form");
    const makeFormProps = propsFactory({
      disabled: Boolean,
      fastFail: Boolean,
      readonly: Boolean,
      modelValue: {
        type: Boolean,
        default: null
      },
      validateOn: {
        type: String,
        default: "input"
      }
    }, "form");
    function createForm(props) {
      const model = useProxiedModel(props, "modelValue");
      const isDisabled = computed(() => props.disabled);
      const isReadonly2 = computed(() => props.readonly);
      const isValidating = shallowRef(false);
      const items2 = ref$1([]);
      const errors2 = ref$1([]);
      async function validate2() {
        const results = [];
        let valid = true;
        errors2.value = [];
        isValidating.value = true;
        for (const item of items2.value) {
          const itemErrorMessages = await item.validate();
          if (itemErrorMessages.length > 0) {
            valid = false;
            results.push({
              id: item.id,
              errorMessages: itemErrorMessages
            });
          }
          if (!valid && props.fastFail)
            break;
        }
        errors2.value = results;
        isValidating.value = false;
        return {
          valid,
          errors: errors2.value
        };
      }
      function reset() {
        items2.value.forEach((item) => item.reset());
      }
      function resetValidation() {
        items2.value.forEach((item) => item.resetValidation());
      }
      watch(items2, () => {
        let valid = 0;
        let invalid = 0;
        const results = [];
        for (const item of items2.value) {
          if (item.isValid === false) {
            invalid++;
            results.push({
              id: item.id,
              errorMessages: item.errorMessages
            });
          } else if (item.isValid === true)
            valid++;
        }
        errors2.value = results;
        model.value = invalid > 0 ? false : valid === items2.value.length ? true : null;
      }, {
        deep: true,
        flush: "post"
      });
      provide(FormKey, {
        register: (_ref) => {
          let {
            id: id2,
            vm,
            validate: validate3,
            reset: reset2,
            resetValidation: resetValidation2
          } = _ref;
          if (items2.value.some((item) => item.id === id2))
            ;
          items2.value.push({
            id: id2,
            validate: validate3,
            reset: reset2,
            resetValidation: resetValidation2,
            vm: markRaw(vm),
            isValid: null,
            errorMessages: []
          });
        },
        unregister: (id2) => {
          items2.value = items2.value.filter((item) => {
            return item.id !== id2;
          });
        },
        update: (id2, isValid2, errorMessages) => {
          const found = items2.value.find((item) => item.id === id2);
          if (!found)
            return;
          found.isValid = isValid2;
          found.errorMessages = errorMessages;
        },
        isDisabled,
        isReadonly: isReadonly2,
        isValidating,
        isValid: model,
        items: items2,
        validateOn: toRef(props, "validateOn")
      });
      return {
        errors: errors2,
        isDisabled,
        isReadonly: isReadonly2,
        isValidating,
        isValid: model,
        items: items2,
        validate: validate2,
        reset,
        resetValidation
      };
    }
    function useForm() {
      return inject$1(FormKey, null);
    }
    const makeValidationProps = propsFactory({
      disabled: {
        type: Boolean,
        default: null
      },
      error: Boolean,
      errorMessages: {
        type: [Array, String],
        default: () => []
      },
      maxErrors: {
        type: [Number, String],
        default: 1
      },
      name: String,
      label: String,
      readonly: {
        type: Boolean,
        default: null
      },
      rules: {
        type: Array,
        default: () => []
      },
      modelValue: null,
      validateOn: String,
      validationValue: null,
      ...makeFocusProps()
    }, "validation");
    function useValidation(props) {
      let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
      let id2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : getUid();
      const model = useProxiedModel(props, "modelValue");
      const validationModel = computed(() => props.validationValue === void 0 ? model.value : props.validationValue);
      const form = useForm();
      const internalErrorMessages = ref$1([]);
      const isPristine = shallowRef(true);
      const isDirty = computed(() => !!(wrapInArray(model.value === "" ? null : model.value).length || wrapInArray(validationModel.value === "" ? null : validationModel.value).length));
      const isDisabled = computed(() => !!(props.disabled ?? (form == null ? void 0 : form.isDisabled.value)));
      const isReadonly2 = computed(() => !!(props.readonly ?? (form == null ? void 0 : form.isReadonly.value)));
      const errorMessages = computed(() => {
        var _a2;
        return ((_a2 = props.errorMessages) == null ? void 0 : _a2.length) ? wrapInArray(props.errorMessages).concat(internalErrorMessages.value).slice(0, Math.max(0, +props.maxErrors)) : internalErrorMessages.value;
      });
      const validateOn = computed(() => {
        let value = (props.validateOn ?? (form == null ? void 0 : form.validateOn.value)) || "input";
        if (value === "lazy")
          value = "input lazy";
        const set2 = new Set((value == null ? void 0 : value.split(" ")) ?? []);
        return {
          blur: set2.has("blur") || set2.has("input"),
          input: set2.has("input"),
          submit: set2.has("submit"),
          lazy: set2.has("lazy")
        };
      });
      const isValid2 = computed(() => {
        var _a2;
        if (props.error || ((_a2 = props.errorMessages) == null ? void 0 : _a2.length))
          return false;
        if (!props.rules.length)
          return true;
        if (isPristine.value) {
          return internalErrorMessages.value.length || validateOn.value.lazy ? null : true;
        } else {
          return !internalErrorMessages.value.length;
        }
      });
      const isValidating = shallowRef(false);
      const validationClasses = computed(() => {
        return {
          [`${name}--error`]: isValid2.value === false,
          [`${name}--dirty`]: isDirty.value,
          [`${name}--disabled`]: isDisabled.value,
          [`${name}--readonly`]: isReadonly2.value
        };
      });
      const vm = getCurrentInstance("validation");
      const uid2 = computed(() => props.name ?? unref(id2));
      onBeforeMount(() => {
        form == null ? void 0 : form.register({
          id: uid2.value,
          vm,
          validate: validate2,
          reset,
          resetValidation
        });
      });
      onBeforeUnmount(() => {
        form == null ? void 0 : form.unregister(uid2.value);
      });
      onMounted(async () => {
        if (!validateOn.value.lazy) {
          await validate2(true);
        }
        form == null ? void 0 : form.update(uid2.value, isValid2.value, errorMessages.value);
      });
      useToggleScope(() => validateOn.value.input, () => {
        watch(validationModel, () => {
          if (validationModel.value != null) {
            validate2();
          } else if (props.focused) {
            const unwatch = watch(() => props.focused, (val) => {
              if (!val)
                validate2();
              unwatch();
            });
          }
        });
      });
      useToggleScope(() => validateOn.value.blur, () => {
        watch(() => props.focused, (val) => {
          if (!val)
            validate2();
        });
      });
      watch([isValid2, errorMessages], () => {
        form == null ? void 0 : form.update(uid2.value, isValid2.value, errorMessages.value);
      });
      async function reset() {
        model.value = null;
        await nextTick();
        await resetValidation();
      }
      async function resetValidation() {
        isPristine.value = true;
        if (!validateOn.value.lazy) {
          await validate2(true);
        } else {
          internalErrorMessages.value = [];
        }
      }
      async function validate2() {
        let silent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        const results = [];
        isValidating.value = true;
        for (const rule of props.rules) {
          if (results.length >= +(props.maxErrors ?? 1)) {
            break;
          }
          const handler = typeof rule === "function" ? rule : () => rule;
          const result = await handler(validationModel.value);
          if (result === true)
            continue;
          if (result !== false && typeof result !== "string") {
            console.warn(`${result} is not a valid value. Rule functions must return boolean true or a string.`);
            continue;
          }
          results.push(result || "");
        }
        internalErrorMessages.value = results;
        isValidating.value = false;
        isPristine.value = silent;
        return internalErrorMessages.value;
      }
      return {
        errorMessages,
        isDirty,
        isDisabled,
        isReadonly: isReadonly2,
        isPristine,
        isValid: isValid2,
        isValidating,
        reset,
        resetValidation,
        validate: validate2,
        validationClasses
      };
    }
    const makeVInputProps = propsFactory({
      id: String,
      appendIcon: IconValue,
      centerAffix: {
        type: Boolean,
        default: true
      },
      prependIcon: IconValue,
      hideDetails: [Boolean, String],
      hideSpinButtons: Boolean,
      hint: String,
      persistentHint: Boolean,
      messages: {
        type: [Array, String],
        default: () => []
      },
      direction: {
        type: String,
        default: "horizontal",
        validator: (v) => ["horizontal", "vertical"].includes(v)
      },
      "onClick:prepend": EventProp(),
      "onClick:append": EventProp(),
      ...makeComponentProps(),
      ...makeDensityProps(),
      ...only(makeDimensionProps(), ["maxWidth", "minWidth", "width"]),
      ...makeThemeProps(),
      ...makeValidationProps()
    }, "VInput");
    const VInput = genericComponent()({
      name: "VInput",
      props: {
        ...makeVInputProps()
      },
      emits: {
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          slots,
          emit: emit2
        } = _ref;
        const {
          densityClasses
        } = useDensity(props);
        const {
          dimensionStyles
        } = useDimension(props);
        const {
          themeClasses
        } = provideTheme(props);
        const {
          rtlClasses
        } = useRtl();
        const {
          InputIcon
        } = useInputIcon(props);
        const uid2 = getUid();
        const id2 = computed(() => props.id || `input-${uid2}`);
        const messagesId = computed(() => `${id2.value}-messages`);
        const {
          errorMessages,
          isDirty,
          isDisabled,
          isReadonly: isReadonly2,
          isPristine,
          isValid: isValid2,
          isValidating,
          reset,
          resetValidation,
          validate: validate2,
          validationClasses
        } = useValidation(props, "v-input", id2);
        const slotProps = computed(() => ({
          id: id2,
          messagesId,
          isDirty,
          isDisabled,
          isReadonly: isReadonly2,
          isPristine,
          isValid: isValid2,
          isValidating,
          reset,
          resetValidation,
          validate: validate2
        }));
        const messages = computed(() => {
          var _a2;
          if (((_a2 = props.errorMessages) == null ? void 0 : _a2.length) || !isPristine.value && errorMessages.value.length) {
            return errorMessages.value;
          } else if (props.hint && (props.persistentHint || props.focused)) {
            return props.hint;
          } else {
            return props.messages;
          }
        });
        useRender(() => {
          var _a2, _b, _c, _d;
          const hasPrepend = !!(slots.prepend || props.prependIcon);
          const hasAppend = !!(slots.append || props.appendIcon);
          const hasMessages = messages.value.length > 0;
          const hasDetails = !props.hideDetails || props.hideDetails === "auto" && (hasMessages || !!slots.details);
          return createVNode("div", {
            "class": ["v-input", `v-input--${props.direction}`, {
              "v-input--center-affix": props.centerAffix,
              "v-input--hide-spin-buttons": props.hideSpinButtons
            }, densityClasses.value, themeClasses.value, rtlClasses.value, validationClasses.value, props.class],
            "style": [dimensionStyles.value, props.style]
          }, [hasPrepend && createVNode("div", {
            "key": "prepend",
            "class": "v-input__prepend"
          }, [(_a2 = slots.prepend) == null ? void 0 : _a2.call(slots, slotProps.value), props.prependIcon && createVNode(InputIcon, {
            "key": "prepend-icon",
            "name": "prepend"
          }, null)]), slots.default && createVNode("div", {
            "class": "v-input__control"
          }, [(_b = slots.default) == null ? void 0 : _b.call(slots, slotProps.value)]), hasAppend && createVNode("div", {
            "key": "append",
            "class": "v-input__append"
          }, [props.appendIcon && createVNode(InputIcon, {
            "key": "append-icon",
            "name": "append"
          }, null), (_c = slots.append) == null ? void 0 : _c.call(slots, slotProps.value)]), hasDetails && createVNode("div", {
            "class": "v-input__details"
          }, [createVNode(VMessages, {
            "id": messagesId.value,
            "active": hasMessages,
            "messages": messages.value
          }, {
            message: slots.message
          }), (_d = slots.details) == null ? void 0 : _d.call(slots, slotProps.value)])]);
        });
        return {
          reset,
          resetValidation,
          validate: validate2,
          isValid: isValid2,
          errorMessages
        };
      }
    });
    const makeVCheckboxProps = propsFactory({
      ...makeVInputProps(),
      ...omit$1(makeVCheckboxBtnProps(), ["inline"])
    }, "VCheckbox");
    const VCheckbox = genericComponent()({
      name: "VCheckbox",
      inheritAttrs: false,
      props: makeVCheckboxProps(),
      emits: {
        "update:modelValue": (value) => true,
        "update:focused": (focused) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          slots
        } = _ref;
        const model = useProxiedModel(props, "modelValue");
        const {
          isFocused,
          focus,
          blur
        } = useFocus(props);
        const uid2 = getUid();
        const id2 = computed(() => props.id || `checkbox-${uid2}`);
        useRender(() => {
          const [rootAttrs, controlAttrs] = filterInputAttrs(attrs);
          const inputProps = VInput.filterProps(props);
          const checkboxProps = VCheckboxBtn.filterProps(props);
          return createVNode(VInput, mergeProps({
            "class": ["v-checkbox", props.class]
          }, rootAttrs, inputProps, {
            "modelValue": model.value,
            "onUpdate:modelValue": ($event) => model.value = $event,
            "id": id2.value,
            "focused": isFocused.value,
            "style": props.style
          }), {
            ...slots,
            default: (_ref2) => {
              let {
                id: id3,
                messagesId,
                isDisabled,
                isReadonly: isReadonly2,
                isValid: isValid2
              } = _ref2;
              return createVNode(VCheckboxBtn, mergeProps(checkboxProps, {
                "id": id3.value,
                "aria-describedby": messagesId.value,
                "disabled": isDisabled.value,
                "readonly": isReadonly2.value
              }, controlAttrs, {
                "error": isValid2.value === false,
                "modelValue": model.value,
                "onUpdate:modelValue": ($event) => model.value = $event,
                "onFocus": focus,
                "onBlur": blur
              }), slots);
            }
          });
        });
        return {};
      }
    });
    function calculateUpdatedTarget(_ref) {
      let {
        selectedElement,
        containerElement,
        isRtl,
        isHorizontal
      } = _ref;
      const containerSize = getOffsetSize(isHorizontal, containerElement);
      const scrollPosition = getScrollPosition(isHorizontal, isRtl, containerElement);
      const childrenSize = getOffsetSize(isHorizontal, selectedElement);
      const childrenStartPosition = getOffsetPosition(isHorizontal, selectedElement);
      const additionalOffset = childrenSize * 0.4;
      if (scrollPosition > childrenStartPosition) {
        return childrenStartPosition - additionalOffset;
      } else if (scrollPosition + containerSize < childrenStartPosition + childrenSize) {
        return childrenStartPosition - containerSize + childrenSize + additionalOffset;
      }
      return scrollPosition;
    }
    function calculateCenteredTarget(_ref2) {
      let {
        selectedElement,
        containerElement,
        isHorizontal
      } = _ref2;
      const containerOffsetSize = getOffsetSize(isHorizontal, containerElement);
      const childrenOffsetPosition = getOffsetPosition(isHorizontal, selectedElement);
      const childrenOffsetSize = getOffsetSize(isHorizontal, selectedElement);
      return childrenOffsetPosition - containerOffsetSize / 2 + childrenOffsetSize / 2;
    }
    function getScrollSize(isHorizontal, element) {
      const key = isHorizontal ? "scrollWidth" : "scrollHeight";
      return (element == null ? void 0 : element[key]) || 0;
    }
    function getClientSize(isHorizontal, element) {
      const key = isHorizontal ? "clientWidth" : "clientHeight";
      return (element == null ? void 0 : element[key]) || 0;
    }
    function getScrollPosition(isHorizontal, rtl, element) {
      if (!element) {
        return 0;
      }
      const {
        scrollLeft,
        offsetWidth,
        scrollWidth
      } = element;
      if (isHorizontal) {
        return rtl ? scrollWidth - offsetWidth + scrollLeft : scrollLeft;
      }
      return element.scrollTop;
    }
    function getOffsetSize(isHorizontal, element) {
      const key = isHorizontal ? "offsetWidth" : "offsetHeight";
      return (element == null ? void 0 : element[key]) || 0;
    }
    function getOffsetPosition(isHorizontal, element) {
      const key = isHorizontal ? "offsetLeft" : "offsetTop";
      return (element == null ? void 0 : element[key]) || 0;
    }
    const VSlideGroupSymbol = Symbol.for("vuetify:v-slide-group");
    const makeVSlideGroupProps = propsFactory({
      centerActive: Boolean,
      direction: {
        type: String,
        default: "horizontal"
      },
      symbol: {
        type: null,
        default: VSlideGroupSymbol
      },
      nextIcon: {
        type: IconValue,
        default: "$next"
      },
      prevIcon: {
        type: IconValue,
        default: "$prev"
      },
      showArrows: {
        type: [Boolean, String],
        validator: (v) => typeof v === "boolean" || ["always", "desktop", "mobile"].includes(v)
      },
      ...makeComponentProps(),
      ...makeDisplayProps({
        mobile: null
      }),
      ...makeTagProps(),
      ...makeGroupProps({
        selectedClass: "v-slide-group-item--active"
      })
    }, "VSlideGroup");
    const VSlideGroup = genericComponent()({
      name: "VSlideGroup",
      props: makeVSlideGroupProps(),
      emits: {
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          isRtl
        } = useRtl();
        const {
          displayClasses,
          mobile
        } = useDisplay(props);
        const group = useGroup(props, props.symbol);
        const isOverflowing = shallowRef(false);
        const scrollOffset = shallowRef(0);
        const containerSize = shallowRef(0);
        const contentSize = shallowRef(0);
        const isHorizontal = computed(() => props.direction === "horizontal");
        const {
          resizeRef: containerRef,
          contentRect: containerRect
        } = useResizeObserver$1();
        const {
          resizeRef: contentRef,
          contentRect
        } = useResizeObserver$1();
        const goTo = useGoTo();
        const goToOptions = computed(() => {
          return {
            container: containerRef.el,
            duration: 200,
            easing: "easeOutQuart"
          };
        });
        const firstSelectedIndex = computed(() => {
          if (!group.selected.value.length)
            return -1;
          return group.items.value.findIndex((item) => item.id === group.selected.value[0]);
        });
        const lastSelectedIndex = computed(() => {
          if (!group.selected.value.length)
            return -1;
          return group.items.value.findIndex((item) => item.id === group.selected.value[group.selected.value.length - 1]);
        });
        if (IN_BROWSER) {
          let frame = -1;
          watch(() => [group.selected.value, containerRect.value, contentRect.value, isHorizontal.value], () => {
            cancelAnimationFrame(frame);
            frame = requestAnimationFrame(() => {
              if (containerRect.value && contentRect.value) {
                const sizeProperty = isHorizontal.value ? "width" : "height";
                containerSize.value = containerRect.value[sizeProperty];
                contentSize.value = contentRect.value[sizeProperty];
                isOverflowing.value = containerSize.value + 1 < contentSize.value;
              }
              if (firstSelectedIndex.value >= 0 && contentRef.el) {
                const selectedElement = contentRef.el.children[lastSelectedIndex.value];
                scrollToChildren(selectedElement, props.centerActive);
              }
            });
          });
        }
        const isFocused = shallowRef(false);
        function scrollToChildren(children, center) {
          let target2 = 0;
          if (center) {
            target2 = calculateCenteredTarget({
              containerElement: containerRef.el,
              isHorizontal: isHorizontal.value,
              selectedElement: children
            });
          } else {
            target2 = calculateUpdatedTarget({
              containerElement: containerRef.el,
              isHorizontal: isHorizontal.value,
              isRtl: isRtl.value,
              selectedElement: children
            });
          }
          scrollToPosition2(target2);
        }
        function scrollToPosition2(newPosition) {
          if (!IN_BROWSER || !containerRef.el)
            return;
          const offsetSize = getOffsetSize(isHorizontal.value, containerRef.el);
          const scrollPosition = getScrollPosition(isHorizontal.value, isRtl.value, containerRef.el);
          const scrollSize = getScrollSize(isHorizontal.value, containerRef.el);
          if (scrollSize <= offsetSize || // Prevent scrolling by only a couple of pixels, which doesn't look smooth
          Math.abs(newPosition - scrollPosition) < 16)
            return;
          if (isHorizontal.value && isRtl.value && containerRef.el) {
            const {
              scrollWidth,
              offsetWidth: containerWidth
            } = containerRef.el;
            newPosition = scrollWidth - containerWidth - newPosition;
          }
          if (isHorizontal.value) {
            goTo.horizontal(newPosition, goToOptions.value);
          } else {
            goTo(newPosition, goToOptions.value);
          }
        }
        function onScroll(e) {
          const {
            scrollTop,
            scrollLeft
          } = e.target;
          scrollOffset.value = isHorizontal.value ? scrollLeft : scrollTop;
        }
        function onFocusin(e) {
          isFocused.value = true;
          if (!isOverflowing.value || !contentRef.el)
            return;
          for (const el2 of e.composedPath()) {
            for (const item of contentRef.el.children) {
              if (item === el2) {
                scrollToChildren(item);
                return;
              }
            }
          }
        }
        function onFocusout(e) {
          isFocused.value = false;
        }
        let ignoreFocusEvent = false;
        function onFocus(e) {
          var _a2;
          if (!ignoreFocusEvent && !isFocused.value && !(e.relatedTarget && ((_a2 = contentRef.el) == null ? void 0 : _a2.contains(e.relatedTarget))))
            focus();
          ignoreFocusEvent = false;
        }
        function onFocusAffixes() {
          ignoreFocusEvent = true;
        }
        function onKeydown(e) {
          if (!contentRef.el)
            return;
          function toFocus(location2) {
            e.preventDefault();
            focus(location2);
          }
          if (isHorizontal.value) {
            if (e.key === "ArrowRight") {
              toFocus(isRtl.value ? "prev" : "next");
            } else if (e.key === "ArrowLeft") {
              toFocus(isRtl.value ? "next" : "prev");
            }
          } else {
            if (e.key === "ArrowDown") {
              toFocus("next");
            } else if (e.key === "ArrowUp") {
              toFocus("prev");
            }
          }
          if (e.key === "Home") {
            toFocus("first");
          } else if (e.key === "End") {
            toFocus("last");
          }
        }
        function focus(location2) {
          var _a2, _b;
          if (!contentRef.el)
            return;
          let el2;
          if (!location2) {
            const focusable = focusableChildren(contentRef.el);
            el2 = focusable[0];
          } else if (location2 === "next") {
            el2 = (_a2 = contentRef.el.querySelector(":focus")) == null ? void 0 : _a2.nextElementSibling;
            if (!el2)
              return focus("first");
          } else if (location2 === "prev") {
            el2 = (_b = contentRef.el.querySelector(":focus")) == null ? void 0 : _b.previousElementSibling;
            if (!el2)
              return focus("last");
          } else if (location2 === "first") {
            el2 = contentRef.el.firstElementChild;
          } else if (location2 === "last") {
            el2 = contentRef.el.lastElementChild;
          }
          if (el2) {
            el2.focus({
              preventScroll: true
            });
          }
        }
        function scrollTo2(location2) {
          const direction = isHorizontal.value && isRtl.value ? -1 : 1;
          const offsetStep = (location2 === "prev" ? -direction : direction) * containerSize.value;
          let newPosition = scrollOffset.value + offsetStep;
          if (isHorizontal.value && isRtl.value && containerRef.el) {
            const {
              scrollWidth,
              offsetWidth: containerWidth
            } = containerRef.el;
            newPosition += scrollWidth - containerWidth;
          }
          scrollToPosition2(newPosition);
        }
        const slotProps = computed(() => ({
          next: group.next,
          prev: group.prev,
          select: group.select,
          isSelected: group.isSelected
        }));
        const hasAffixes = computed(() => {
          switch (props.showArrows) {
            case "always":
              return true;
            case "desktop":
              return !mobile.value;
            case true:
              return isOverflowing.value || Math.abs(scrollOffset.value) > 0;
            case "mobile":
              return mobile.value || isOverflowing.value || Math.abs(scrollOffset.value) > 0;
            default:
              return !mobile.value && (isOverflowing.value || Math.abs(scrollOffset.value) > 0);
          }
        });
        const hasPrev = computed(() => {
          return Math.abs(scrollOffset.value) > 1;
        });
        const hasNext = computed(() => {
          if (!containerRef.value)
            return false;
          const scrollSize = getScrollSize(isHorizontal.value, containerRef.el);
          const clientSize = getClientSize(isHorizontal.value, containerRef.el);
          const scrollSizeMax = scrollSize - clientSize;
          return scrollSizeMax - Math.abs(scrollOffset.value) > 1;
        });
        useRender(() => createVNode(props.tag, {
          "class": ["v-slide-group", {
            "v-slide-group--vertical": !isHorizontal.value,
            "v-slide-group--has-affixes": hasAffixes.value,
            "v-slide-group--is-overflowing": isOverflowing.value
          }, displayClasses.value, props.class],
          "style": props.style,
          "tabindex": isFocused.value || group.selected.value.length ? -1 : 0,
          "onFocus": onFocus
        }, {
          default: () => {
            var _a2, _b, _c;
            return [hasAffixes.value && createVNode("div", {
              "key": "prev",
              "class": ["v-slide-group__prev", {
                "v-slide-group__prev--disabled": !hasPrev.value
              }],
              "onMousedown": onFocusAffixes,
              "onClick": () => hasPrev.value && scrollTo2("prev")
            }, [((_a2 = slots.prev) == null ? void 0 : _a2.call(slots, slotProps.value)) ?? createVNode(VFadeTransition, null, {
              default: () => [createVNode(VIcon, {
                "icon": isRtl.value ? props.nextIcon : props.prevIcon
              }, null)]
            })]), createVNode("div", {
              "key": "container",
              "ref": containerRef,
              "class": "v-slide-group__container",
              "onScroll": onScroll
            }, [createVNode("div", {
              "ref": contentRef,
              "class": "v-slide-group__content",
              "onFocusin": onFocusin,
              "onFocusout": onFocusout,
              "onKeydown": onKeydown
            }, [(_b = slots.default) == null ? void 0 : _b.call(slots, slotProps.value)])]), hasAffixes.value && createVNode("div", {
              "key": "next",
              "class": ["v-slide-group__next", {
                "v-slide-group__next--disabled": !hasNext.value
              }],
              "onMousedown": onFocusAffixes,
              "onClick": () => hasNext.value && scrollTo2("next")
            }, [((_c = slots.next) == null ? void 0 : _c.call(slots, slotProps.value)) ?? createVNode(VFadeTransition, null, {
              default: () => [createVNode(VIcon, {
                "icon": isRtl.value ? props.prevIcon : props.nextIcon
              }, null)]
            })])];
          }
        }));
        return {
          selected: group.selected,
          scrollTo: scrollTo2,
          scrollOffset,
          focus
        };
      }
    });
    const VChipGroupSymbol = Symbol.for("vuetify:v-chip-group");
    const makeVChipGroupProps = propsFactory({
      column: Boolean,
      filter: Boolean,
      valueComparator: {
        type: Function,
        default: deepEqual
      },
      ...makeVSlideGroupProps(),
      ...makeComponentProps(),
      ...makeGroupProps({
        selectedClass: "v-chip--selected"
      }),
      ...makeTagProps(),
      ...makeThemeProps(),
      ...makeVariantProps({
        variant: "tonal"
      })
    }, "VChipGroup");
    genericComponent()({
      name: "VChipGroup",
      props: makeVChipGroupProps(),
      emits: {
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          themeClasses
        } = provideTheme(props);
        const {
          isSelected,
          select,
          next: next2,
          prev,
          selected
        } = useGroup(props, VChipGroupSymbol);
        provideDefaults({
          VChip: {
            color: toRef(props, "color"),
            disabled: toRef(props, "disabled"),
            filter: toRef(props, "filter"),
            variant: toRef(props, "variant")
          }
        });
        useRender(() => {
          const slideGroupProps = VSlideGroup.filterProps(props);
          return createVNode(VSlideGroup, mergeProps(slideGroupProps, {
            "class": ["v-chip-group", {
              "v-chip-group--column": props.column
            }, themeClasses.value, props.class],
            "style": props.style
          }), {
            default: () => {
              var _a2;
              return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
                isSelected,
                select,
                next: next2,
                prev,
                selected: selected.value
              })];
            }
          });
        });
        return {};
      }
    });
    const makeVChipProps = propsFactory({
      activeClass: String,
      appendAvatar: String,
      appendIcon: IconValue,
      closable: Boolean,
      closeIcon: {
        type: IconValue,
        default: "$delete"
      },
      closeLabel: {
        type: String,
        default: "$vuetify.close"
      },
      draggable: Boolean,
      filter: Boolean,
      filterIcon: {
        type: String,
        default: "$complete"
      },
      label: Boolean,
      link: {
        type: Boolean,
        default: void 0
      },
      pill: Boolean,
      prependAvatar: String,
      prependIcon: IconValue,
      ripple: {
        type: [Boolean, Object],
        default: true
      },
      text: String,
      modelValue: {
        type: Boolean,
        default: true
      },
      onClick: EventProp(),
      onClickOnce: EventProp(),
      ...makeBorderProps(),
      ...makeComponentProps(),
      ...makeDensityProps(),
      ...makeElevationProps(),
      ...makeGroupItemProps(),
      ...makeRoundedProps(),
      ...makeRouterProps(),
      ...makeSizeProps(),
      ...makeTagProps({
        tag: "span"
      }),
      ...makeThemeProps(),
      ...makeVariantProps({
        variant: "tonal"
      })
    }, "VChip");
    const VChip = genericComponent()({
      name: "VChip",
      directives: {
        Ripple
      },
      props: makeVChipProps(),
      emits: {
        "click:close": (e) => true,
        "update:modelValue": (value) => true,
        "group:selected": (val) => true,
        click: (e) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          emit: emit2,
          slots
        } = _ref;
        const {
          t
        } = useLocale();
        const {
          borderClasses
        } = useBorder(props);
        const {
          colorClasses,
          colorStyles,
          variantClasses
        } = useVariant(props);
        const {
          densityClasses
        } = useDensity(props);
        const {
          elevationClasses
        } = useElevation(props);
        const {
          roundedClasses
        } = useRounded(props);
        const {
          sizeClasses
        } = useSize(props);
        const {
          themeClasses
        } = provideTheme(props);
        const isActive = useProxiedModel(props, "modelValue");
        const group = useGroupItem(props, VChipGroupSymbol, false);
        const link2 = useLink(props, attrs);
        const isLink = computed(() => props.link !== false && link2.isLink.value);
        const isClickable = computed(() => !props.disabled && props.link !== false && (!!group || props.link || link2.isClickable.value));
        const closeProps = computed(() => ({
          "aria-label": t(props.closeLabel),
          onClick(e) {
            e.preventDefault();
            e.stopPropagation();
            isActive.value = false;
            emit2("click:close", e);
          }
        }));
        function onClick(e) {
          var _a2;
          emit2("click", e);
          if (!isClickable.value)
            return;
          (_a2 = link2.navigate) == null ? void 0 : _a2.call(link2, e);
          group == null ? void 0 : group.toggle();
        }
        function onKeyDown(e) {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            onClick(e);
          }
        }
        return () => {
          const Tag2 = link2.isLink.value ? "a" : props.tag;
          const hasAppendMedia = !!(props.appendIcon || props.appendAvatar);
          const hasAppend = !!(hasAppendMedia || slots.append);
          const hasClose = !!(slots.close || props.closable);
          const hasFilter = !!(slots.filter || props.filter) && group;
          const hasPrependMedia = !!(props.prependIcon || props.prependAvatar);
          const hasPrepend = !!(hasPrependMedia || slots.prepend);
          const hasColor = !group || group.isSelected.value;
          return isActive.value && withDirectives(createVNode(Tag2, {
            "class": ["v-chip", {
              "v-chip--disabled": props.disabled,
              "v-chip--label": props.label,
              "v-chip--link": isClickable.value,
              "v-chip--filter": hasFilter,
              "v-chip--pill": props.pill
            }, themeClasses.value, borderClasses.value, hasColor ? colorClasses.value : void 0, densityClasses.value, elevationClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, group == null ? void 0 : group.selectedClass.value, props.class],
            "style": [hasColor ? colorStyles.value : void 0, props.style],
            "disabled": props.disabled || void 0,
            "draggable": props.draggable,
            "href": link2.href.value,
            "tabindex": isClickable.value ? 0 : void 0,
            "onClick": onClick,
            "onKeydown": isClickable.value && !isLink.value && onKeyDown
          }, {
            default: () => {
              var _a2;
              return [genOverlays(isClickable.value, "v-chip"), hasFilter && createVNode(VExpandXTransition, {
                "key": "filter"
              }, {
                default: () => [withDirectives(createVNode("div", {
                  "class": "v-chip__filter"
                }, [!slots.filter ? createVNode(VIcon, {
                  "key": "filter-icon",
                  "icon": props.filterIcon
                }, null) : createVNode(VDefaultsProvider, {
                  "key": "filter-defaults",
                  "disabled": !props.filterIcon,
                  "defaults": {
                    VIcon: {
                      icon: props.filterIcon
                    }
                  }
                }, slots.filter)]), [[vShow, group.isSelected.value]])]
              }), hasPrepend && createVNode("div", {
                "key": "prepend",
                "class": "v-chip__prepend"
              }, [!slots.prepend ? createVNode(Fragment, null, [props.prependIcon && createVNode(VIcon, {
                "key": "prepend-icon",
                "icon": props.prependIcon,
                "start": true
              }, null), props.prependAvatar && createVNode(VAvatar, {
                "key": "prepend-avatar",
                "image": props.prependAvatar,
                "start": true
              }, null)]) : createVNode(VDefaultsProvider, {
                "key": "prepend-defaults",
                "disabled": !hasPrependMedia,
                "defaults": {
                  VAvatar: {
                    image: props.prependAvatar,
                    start: true
                  },
                  VIcon: {
                    icon: props.prependIcon,
                    start: true
                  }
                }
              }, slots.prepend)]), createVNode("div", {
                "class": "v-chip__content",
                "data-no-activator": ""
              }, [((_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
                isSelected: group == null ? void 0 : group.isSelected.value,
                selectedClass: group == null ? void 0 : group.selectedClass.value,
                select: group == null ? void 0 : group.select,
                toggle: group == null ? void 0 : group.toggle,
                value: group == null ? void 0 : group.value.value,
                disabled: props.disabled
              })) ?? props.text]), hasAppend && createVNode("div", {
                "key": "append",
                "class": "v-chip__append"
              }, [!slots.append ? createVNode(Fragment, null, [props.appendIcon && createVNode(VIcon, {
                "key": "append-icon",
                "end": true,
                "icon": props.appendIcon
              }, null), props.appendAvatar && createVNode(VAvatar, {
                "key": "append-avatar",
                "end": true,
                "image": props.appendAvatar
              }, null)]) : createVNode(VDefaultsProvider, {
                "key": "append-defaults",
                "disabled": !hasAppendMedia,
                "defaults": {
                  VAvatar: {
                    end: true,
                    image: props.appendAvatar
                  },
                  VIcon: {
                    end: true,
                    icon: props.appendIcon
                  }
                }
              }, slots.append)]), hasClose && createVNode("button", mergeProps({
                "key": "close",
                "class": "v-chip__close",
                "type": "button"
              }, closeProps.value), [!slots.close ? createVNode(VIcon, {
                "key": "close-icon",
                "icon": props.closeIcon,
                "size": "x-small"
              }, null) : createVNode(VDefaultsProvider, {
                "key": "close-defaults",
                "defaults": {
                  VIcon: {
                    icon: props.closeIcon,
                    size: "x-small"
                  }
                }
              }, slots.close)])];
            }
          }), [[resolveDirective("ripple"), isClickable.value && props.ripple, null]]);
        };
      }
    });
    const makeVMenuProps = propsFactory({
      // TODO
      // disableKeys: Boolean,
      id: String,
      ...omit$1(makeVOverlayProps({
        closeDelay: 250,
        closeOnContentClick: true,
        locationStrategy: "connected",
        openDelay: 300,
        scrim: false,
        scrollStrategy: "reposition",
        transition: {
          component: VDialogTransition
        }
      }), ["absolute"])
    }, "VMenu");
    const VMenu = genericComponent()({
      name: "VMenu",
      props: makeVMenuProps(),
      emits: {
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const isActive = useProxiedModel(props, "modelValue");
        const {
          scopeId
        } = useScopeId();
        const uid2 = getUid();
        const id2 = computed(() => props.id || `v-menu-${uid2}`);
        const overlay = ref$1();
        const parent = inject$1(VMenuSymbol, null);
        const openChildren = shallowRef(0);
        provide(VMenuSymbol, {
          register() {
            ++openChildren.value;
          },
          unregister() {
            --openChildren.value;
          },
          closeParents(e) {
            setTimeout(() => {
              var _a2;
              if (!openChildren.value && !props.persistent && (e == null || ((_a2 = overlay.value) == null ? void 0 : _a2.contentEl) && !isClickInsideElement(e, overlay.value.contentEl))) {
                isActive.value = false;
                parent == null ? void 0 : parent.closeParents();
              }
            }, 40);
          }
        });
        async function onFocusIn(e) {
          var _a2, _b, _c;
          const before = e.relatedTarget;
          const after = e.target;
          await nextTick();
          if (isActive.value && before !== after && ((_a2 = overlay.value) == null ? void 0 : _a2.contentEl) && // We're the topmost menu
          ((_b = overlay.value) == null ? void 0 : _b.globalTop) && // It isn't the document or the menu body
          ![document, overlay.value.contentEl].includes(after) && // It isn't inside the menu body
          !overlay.value.contentEl.contains(after)) {
            const focusable = focusableChildren(overlay.value.contentEl);
            (_c = focusable[0]) == null ? void 0 : _c.focus();
          }
        }
        watch(isActive, (val) => {
          if (val) {
            parent == null ? void 0 : parent.register();
            document.addEventListener("focusin", onFocusIn, {
              once: true
            });
          } else {
            parent == null ? void 0 : parent.unregister();
            document.removeEventListener("focusin", onFocusIn);
          }
        });
        function onClickOutside(e) {
          parent == null ? void 0 : parent.closeParents(e);
        }
        function onKeydown(e) {
          var _a2, _b, _c;
          if (props.disabled)
            return;
          if (e.key === "Tab" || e.key === "Enter" && !props.closeOnContentClick) {
            if (e.key === "Enter" && (e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLInputElement && !!e.target.closest("form")))
              return;
            if (e.key === "Enter")
              e.preventDefault();
            const nextElement = getNextElement(focusableChildren((_a2 = overlay.value) == null ? void 0 : _a2.contentEl, false), e.shiftKey ? "prev" : "next", (el2) => el2.tabIndex >= 0);
            if (!nextElement) {
              isActive.value = false;
              (_c = (_b = overlay.value) == null ? void 0 : _b.activatorEl) == null ? void 0 : _c.focus();
            }
          } else if (["Enter", " "].includes(e.key) && props.closeOnContentClick) {
            isActive.value = false;
            parent == null ? void 0 : parent.closeParents();
          }
        }
        function onActivatorKeydown(e) {
          var _a2;
          if (props.disabled)
            return;
          const el2 = (_a2 = overlay.value) == null ? void 0 : _a2.contentEl;
          if (el2 && isActive.value) {
            if (e.key === "ArrowDown") {
              e.preventDefault();
              focusChild(el2, "next");
            } else if (e.key === "ArrowUp") {
              e.preventDefault();
              focusChild(el2, "prev");
            }
          } else if (["ArrowDown", "ArrowUp"].includes(e.key)) {
            isActive.value = true;
            e.preventDefault();
            setTimeout(() => setTimeout(() => onActivatorKeydown(e)));
          }
        }
        const activatorProps = computed(() => mergeProps({
          "aria-haspopup": "menu",
          "aria-expanded": String(isActive.value),
          "aria-owns": id2.value,
          onKeydown: onActivatorKeydown
        }, props.activatorProps));
        useRender(() => {
          const overlayProps = VOverlay.filterProps(props);
          return createVNode(VOverlay, mergeProps({
            "ref": overlay,
            "id": id2.value,
            "class": ["v-menu", props.class],
            "style": props.style
          }, overlayProps, {
            "modelValue": isActive.value,
            "onUpdate:modelValue": ($event) => isActive.value = $event,
            "absolute": true,
            "activatorProps": activatorProps.value,
            "onClick:outside": onClickOutside,
            "onKeydown": onKeydown
          }, scopeId), {
            activator: slots.activator,
            default: function() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return createVNode(VDefaultsProvider, {
                "root": "VMenu"
              }, {
                default: () => {
                  var _a2;
                  return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, ...args)];
                }
              });
            }
          });
        });
        return forwardRefs({
          id: id2,
          ΨopenChildren: openChildren
        }, overlay);
      }
    });
    const makeVCounterProps = propsFactory({
      active: Boolean,
      disabled: Boolean,
      max: [Number, String],
      value: {
        type: [Number, String],
        default: 0
      },
      ...makeComponentProps(),
      ...makeTransitionProps({
        transition: {
          component: VSlideYTransition
        }
      })
    }, "VCounter");
    const VCounter = genericComponent()({
      name: "VCounter",
      functional: true,
      props: makeVCounterProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const counter = computed(() => {
          return props.max ? `${props.value} / ${props.max}` : String(props.value);
        });
        useRender(() => createVNode(MaybeTransition, {
          "transition": props.transition
        }, {
          default: () => [withDirectives(createVNode("div", {
            "class": ["v-counter", {
              "text-error": props.max && !props.disabled && parseFloat(props.value) > parseFloat(props.max)
            }, props.class],
            "style": props.style
          }, [slots.default ? slots.default({
            counter: counter.value,
            max: props.max,
            value: props.value
          }) : counter.value]), [[vShow, props.active]])]
        }));
        return {};
      }
    });
    const makeVFieldLabelProps = propsFactory({
      floating: Boolean,
      ...makeComponentProps()
    }, "VFieldLabel");
    const VFieldLabel = genericComponent()({
      name: "VFieldLabel",
      props: makeVFieldLabelProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        useRender(() => createVNode(VLabel, {
          "class": ["v-field-label", {
            "v-field-label--floating": props.floating
          }, props.class],
          "style": props.style,
          "aria-hidden": props.floating || void 0
        }, slots));
        return {};
      }
    });
    const allowedVariants$1 = ["underlined", "outlined", "filled", "solo", "solo-inverted", "solo-filled", "plain"];
    const makeVFieldProps = propsFactory({
      appendInnerIcon: IconValue,
      bgColor: String,
      clearable: Boolean,
      clearIcon: {
        type: IconValue,
        default: "$clear"
      },
      active: Boolean,
      centerAffix: {
        type: Boolean,
        default: void 0
      },
      color: String,
      baseColor: String,
      dirty: Boolean,
      disabled: {
        type: Boolean,
        default: null
      },
      error: Boolean,
      flat: Boolean,
      label: String,
      persistentClear: Boolean,
      prependInnerIcon: IconValue,
      reverse: Boolean,
      singleLine: Boolean,
      variant: {
        type: String,
        default: "filled",
        validator: (v) => allowedVariants$1.includes(v)
      },
      "onClick:clear": EventProp(),
      "onClick:appendInner": EventProp(),
      "onClick:prependInner": EventProp(),
      ...makeComponentProps(),
      ...makeLoaderProps(),
      ...makeRoundedProps(),
      ...makeThemeProps()
    }, "VField");
    const VField = genericComponent()({
      name: "VField",
      inheritAttrs: false,
      props: {
        id: String,
        ...makeFocusProps(),
        ...makeVFieldProps()
      },
      emits: {
        "update:focused": (focused) => true,
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          emit: emit2,
          slots
        } = _ref;
        const {
          themeClasses
        } = provideTheme(props);
        const {
          loaderClasses
        } = useLoader(props);
        const {
          focusClasses,
          isFocused,
          focus,
          blur
        } = useFocus(props);
        const {
          InputIcon
        } = useInputIcon(props);
        const {
          roundedClasses
        } = useRounded(props);
        const {
          rtlClasses
        } = useRtl();
        const isActive = computed(() => props.dirty || props.active);
        const hasLabel = computed(() => !props.singleLine && !!(props.label || slots.label));
        const uid2 = getUid();
        const id2 = computed(() => props.id || `input-${uid2}`);
        const messagesId = computed(() => `${id2.value}-messages`);
        const labelRef = ref$1();
        const floatingLabelRef = ref$1();
        const controlRef = ref$1();
        const isPlainOrUnderlined = computed(() => ["plain", "underlined"].includes(props.variant));
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(toRef(props, "bgColor"));
        const {
          textColorClasses,
          textColorStyles
        } = useTextColor(computed(() => {
          return props.error || props.disabled ? void 0 : isActive.value && isFocused.value ? props.color : props.baseColor;
        }));
        watch(isActive, (val) => {
          if (hasLabel.value) {
            const el2 = labelRef.value.$el;
            const targetEl = floatingLabelRef.value.$el;
            requestAnimationFrame(() => {
              const rect2 = nullifyTransforms(el2);
              const targetRect = targetEl.getBoundingClientRect();
              const x2 = targetRect.x - rect2.x;
              const y = targetRect.y - rect2.y - (rect2.height / 2 - targetRect.height / 2);
              const targetWidth = targetRect.width / 0.75;
              const width = Math.abs(targetWidth - rect2.width) > 1 ? {
                maxWidth: convertToUnit(targetWidth)
              } : void 0;
              const style = getComputedStyle(el2);
              const targetStyle = getComputedStyle(targetEl);
              const duration = parseFloat(style.transitionDuration) * 1e3 || 150;
              const scale = parseFloat(targetStyle.getPropertyValue("--v-field-label-scale"));
              const color = targetStyle.getPropertyValue("color");
              el2.style.visibility = "visible";
              targetEl.style.visibility = "hidden";
              animate(el2, {
                transform: `translate(${x2}px, ${y}px) scale(${scale})`,
                color,
                ...width
              }, {
                duration,
                easing: standardEasing,
                direction: val ? "normal" : "reverse"
              }).finished.then(() => {
                el2.style.removeProperty("visibility");
                targetEl.style.removeProperty("visibility");
              });
            });
          }
        }, {
          flush: "post"
        });
        const slotProps = computed(() => ({
          isActive,
          isFocused,
          controlRef,
          blur,
          focus
        }));
        function onClick(e) {
          if (e.target !== document.activeElement) {
            e.preventDefault();
          }
        }
        function onKeydownClear(e) {
          var _a2;
          if (e.key !== "Enter" && e.key !== " ")
            return;
          e.preventDefault();
          e.stopPropagation();
          (_a2 = props["onClick:clear"]) == null ? void 0 : _a2.call(props, new MouseEvent("click"));
        }
        useRender(() => {
          var _a2, _b, _c;
          const isOutlined = props.variant === "outlined";
          const hasPrepend = !!(slots["prepend-inner"] || props.prependInnerIcon);
          const hasClear = !!(props.clearable || slots.clear);
          const hasAppend = !!(slots["append-inner"] || props.appendInnerIcon || hasClear);
          const label = () => slots.label ? slots.label({
            ...slotProps.value,
            label: props.label,
            props: {
              for: id2.value
            }
          }) : props.label;
          return createVNode("div", mergeProps({
            "class": ["v-field", {
              "v-field--active": isActive.value,
              "v-field--appended": hasAppend,
              "v-field--center-affix": props.centerAffix ?? !isPlainOrUnderlined.value,
              "v-field--disabled": props.disabled,
              "v-field--dirty": props.dirty,
              "v-field--error": props.error,
              "v-field--flat": props.flat,
              "v-field--has-background": !!props.bgColor,
              "v-field--persistent-clear": props.persistentClear,
              "v-field--prepended": hasPrepend,
              "v-field--reverse": props.reverse,
              "v-field--single-line": props.singleLine,
              "v-field--no-label": !label(),
              [`v-field--variant-${props.variant}`]: true
            }, themeClasses.value, backgroundColorClasses.value, focusClasses.value, loaderClasses.value, roundedClasses.value, rtlClasses.value, props.class],
            "style": [backgroundColorStyles.value, props.style],
            "onClick": onClick
          }, attrs), [createVNode("div", {
            "class": "v-field__overlay"
          }, null), createVNode(LoaderSlot, {
            "name": "v-field",
            "active": !!props.loading,
            "color": props.error ? "error" : typeof props.loading === "string" ? props.loading : props.color
          }, {
            default: slots.loader
          }), hasPrepend && createVNode("div", {
            "key": "prepend",
            "class": "v-field__prepend-inner"
          }, [props.prependInnerIcon && createVNode(InputIcon, {
            "key": "prepend-icon",
            "name": "prependInner"
          }, null), (_a2 = slots["prepend-inner"]) == null ? void 0 : _a2.call(slots, slotProps.value)]), createVNode("div", {
            "class": "v-field__field",
            "data-no-activator": ""
          }, [["filled", "solo", "solo-inverted", "solo-filled"].includes(props.variant) && hasLabel.value && createVNode(VFieldLabel, {
            "key": "floating-label",
            "ref": floatingLabelRef,
            "class": [textColorClasses.value],
            "floating": true,
            "for": id2.value,
            "style": textColorStyles.value
          }, {
            default: () => [label()]
          }), createVNode(VFieldLabel, {
            "ref": labelRef,
            "for": id2.value
          }, {
            default: () => [label()]
          }), (_b = slots.default) == null ? void 0 : _b.call(slots, {
            ...slotProps.value,
            props: {
              id: id2.value,
              class: "v-field__input",
              "aria-describedby": messagesId.value
            },
            focus,
            blur
          })]), hasClear && createVNode(VExpandXTransition, {
            "key": "clear"
          }, {
            default: () => [withDirectives(createVNode("div", {
              "class": "v-field__clearable",
              "onMousedown": (e) => {
                e.preventDefault();
                e.stopPropagation();
              }
            }, [createVNode(VDefaultsProvider, {
              "defaults": {
                VIcon: {
                  icon: props.clearIcon
                }
              }
            }, {
              default: () => [slots.clear ? slots.clear({
                ...slotProps.value,
                props: {
                  onKeydown: onKeydownClear,
                  onFocus: focus,
                  onBlur: blur,
                  onClick: props["onClick:clear"]
                }
              }) : createVNode(InputIcon, {
                "name": "clear",
                "onKeydown": onKeydownClear,
                "onFocus": focus,
                "onBlur": blur
              }, null)]
            })]), [[vShow, props.dirty]])]
          }), hasAppend && createVNode("div", {
            "key": "append",
            "class": "v-field__append-inner"
          }, [(_c = slots["append-inner"]) == null ? void 0 : _c.call(slots, slotProps.value), props.appendInnerIcon && createVNode(InputIcon, {
            "key": "append-icon",
            "name": "appendInner"
          }, null)]), createVNode("div", {
            "class": ["v-field__outline", textColorClasses.value],
            "style": textColorStyles.value
          }, [isOutlined && createVNode(Fragment, null, [createVNode("div", {
            "class": "v-field__outline__start"
          }, null), hasLabel.value && createVNode("div", {
            "class": "v-field__outline__notch"
          }, [createVNode(VFieldLabel, {
            "ref": floatingLabelRef,
            "floating": true,
            "for": id2.value
          }, {
            default: () => [label()]
          })]), createVNode("div", {
            "class": "v-field__outline__end"
          }, null)]), isPlainOrUnderlined.value && hasLabel.value && createVNode(VFieldLabel, {
            "ref": floatingLabelRef,
            "floating": true,
            "for": id2.value
          }, {
            default: () => [label()]
          })])]);
        });
        return {
          controlRef
        };
      }
    });
    function filterFieldProps(attrs) {
      const keys2 = Object.keys(VField.props).filter((k) => !isOn(k) && k !== "class" && k !== "style");
      return pick(attrs, keys2);
    }
    const activeTypes = ["color", "file", "time", "date", "datetime-local", "week", "month"];
    const makeVTextFieldProps = propsFactory({
      autofocus: Boolean,
      counter: [Boolean, Number, String],
      counterValue: [Number, Function],
      prefix: String,
      placeholder: String,
      persistentPlaceholder: Boolean,
      persistentCounter: Boolean,
      suffix: String,
      role: String,
      type: {
        type: String,
        default: "text"
      },
      modelModifiers: Object,
      ...makeVInputProps(),
      ...makeVFieldProps()
    }, "VTextField");
    const VTextField = genericComponent()({
      name: "VTextField",
      directives: {
        Intersect: Intersect$1
      },
      inheritAttrs: false,
      props: makeVTextFieldProps(),
      emits: {
        "click:control": (e) => true,
        "mousedown:control": (e) => true,
        "update:focused": (focused) => true,
        "update:modelValue": (val) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          emit: emit2,
          slots
        } = _ref;
        const model = useProxiedModel(props, "modelValue");
        const {
          isFocused,
          focus,
          blur
        } = useFocus(props);
        const counterValue = computed(() => {
          return typeof props.counterValue === "function" ? props.counterValue(model.value) : typeof props.counterValue === "number" ? props.counterValue : (model.value ?? "").toString().length;
        });
        const max = computed(() => {
          if (attrs.maxlength)
            return attrs.maxlength;
          if (!props.counter || typeof props.counter !== "number" && typeof props.counter !== "string")
            return void 0;
          return props.counter;
        });
        const isPlainOrUnderlined = computed(() => ["plain", "underlined"].includes(props.variant));
        function onIntersect(isIntersecting, entries) {
          var _a2, _b;
          if (!props.autofocus || !isIntersecting)
            return;
          (_b = (_a2 = entries[0].target) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
        }
        const vInputRef = ref$1();
        const vFieldRef = ref$1();
        const inputRef = ref$1();
        const isActive = computed(() => activeTypes.includes(props.type) || props.persistentPlaceholder || isFocused.value || props.active);
        function onFocus() {
          var _a2;
          if (inputRef.value !== document.activeElement) {
            (_a2 = inputRef.value) == null ? void 0 : _a2.focus();
          }
          if (!isFocused.value)
            focus();
        }
        function onControlMousedown(e) {
          emit2("mousedown:control", e);
          if (e.target === inputRef.value)
            return;
          onFocus();
          e.preventDefault();
        }
        function onControlClick(e) {
          onFocus();
          emit2("click:control", e);
        }
        function onClear(e) {
          e.stopPropagation();
          onFocus();
          nextTick(() => {
            model.value = null;
            callEvent(props["onClick:clear"], e);
          });
        }
        function onInput(e) {
          var _a2;
          const el2 = e.target;
          model.value = el2.value;
          if (((_a2 = props.modelModifiers) == null ? void 0 : _a2.trim) && ["text", "search", "password", "tel", "url"].includes(props.type)) {
            const caretPosition = [el2.selectionStart, el2.selectionEnd];
            nextTick(() => {
              el2.selectionStart = caretPosition[0];
              el2.selectionEnd = caretPosition[1];
            });
          }
        }
        useRender(() => {
          const hasCounter = !!(slots.counter || props.counter !== false && props.counter != null);
          const hasDetails = !!(hasCounter || slots.details);
          const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
          const {
            modelValue: _,
            ...inputProps
          } = VInput.filterProps(props);
          const fieldProps = filterFieldProps(props);
          return createVNode(VInput, mergeProps({
            "ref": vInputRef,
            "modelValue": model.value,
            "onUpdate:modelValue": ($event) => model.value = $event,
            "class": ["v-text-field", {
              "v-text-field--prefixed": props.prefix,
              "v-text-field--suffixed": props.suffix,
              "v-input--plain-underlined": isPlainOrUnderlined.value
            }, props.class],
            "style": props.style
          }, rootAttrs, inputProps, {
            "centerAffix": !isPlainOrUnderlined.value,
            "focused": isFocused.value
          }), {
            ...slots,
            default: (_ref2) => {
              let {
                id: id2,
                isDisabled,
                isDirty,
                isReadonly: isReadonly2,
                isValid: isValid2
              } = _ref2;
              return createVNode(VField, mergeProps({
                "ref": vFieldRef,
                "onMousedown": onControlMousedown,
                "onClick": onControlClick,
                "onClick:clear": onClear,
                "onClick:prependInner": props["onClick:prependInner"],
                "onClick:appendInner": props["onClick:appendInner"],
                "role": props.role
              }, fieldProps, {
                "id": id2.value,
                "active": isActive.value || isDirty.value,
                "dirty": isDirty.value || props.dirty,
                "disabled": isDisabled.value,
                "focused": isFocused.value,
                "error": isValid2.value === false
              }), {
                ...slots,
                default: (_ref3) => {
                  let {
                    props: {
                      class: fieldClass,
                      ...slotProps
                    }
                  } = _ref3;
                  const inputNode = withDirectives(createVNode("input", mergeProps({
                    "ref": inputRef,
                    "value": model.value,
                    "onInput": onInput,
                    "autofocus": props.autofocus,
                    "readonly": isReadonly2.value,
                    "disabled": isDisabled.value,
                    "name": props.name,
                    "placeholder": props.placeholder,
                    "size": 1,
                    "type": props.type,
                    "onFocus": onFocus,
                    "onBlur": blur
                  }, slotProps, inputAttrs), null), [[resolveDirective("intersect"), {
                    handler: onIntersect
                  }, null, {
                    once: true
                  }]]);
                  return createVNode(Fragment, null, [props.prefix && createVNode("span", {
                    "class": "v-text-field__prefix"
                  }, [createVNode("span", {
                    "class": "v-text-field__prefix__text"
                  }, [props.prefix])]), slots.default ? createVNode("div", {
                    "class": fieldClass,
                    "data-no-activator": ""
                  }, [slots.default(), inputNode]) : cloneVNode(inputNode, {
                    class: fieldClass
                  }), props.suffix && createVNode("span", {
                    "class": "v-text-field__suffix"
                  }, [createVNode("span", {
                    "class": "v-text-field__suffix__text"
                  }, [props.suffix])])]);
                }
              });
            },
            details: hasDetails ? (slotProps) => {
              var _a2;
              return createVNode(Fragment, null, [(_a2 = slots.details) == null ? void 0 : _a2.call(slots, slotProps), hasCounter && createVNode(Fragment, null, [createVNode("span", null, null), createVNode(VCounter, {
                "active": props.persistentCounter || isFocused.value,
                "value": counterValue.value,
                "max": max.value,
                "disabled": props.disabled
              }, slots.counter)])]);
            } : void 0
          });
        });
        return forwardRefs({}, vInputRef, vFieldRef, inputRef);
      }
    });
    const makeVVirtualScrollItemProps = propsFactory({
      renderless: Boolean,
      ...makeComponentProps()
    }, "VVirtualScrollItem");
    const VVirtualScrollItem = genericComponent()({
      name: "VVirtualScrollItem",
      inheritAttrs: false,
      props: makeVVirtualScrollItemProps(),
      emits: {
        "update:height": (height) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          emit: emit2,
          slots
        } = _ref;
        const {
          resizeRef,
          contentRect
        } = useResizeObserver$1(void 0, "border");
        watch(() => {
          var _a2;
          return (_a2 = contentRect.value) == null ? void 0 : _a2.height;
        }, (height) => {
          if (height != null)
            emit2("update:height", height);
        });
        useRender(() => {
          var _a2, _b;
          return props.renderless ? createVNode(Fragment, null, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
            itemRef: resizeRef
          })]) : createVNode("div", mergeProps({
            "ref": resizeRef,
            "class": ["v-virtual-scroll__item", props.class],
            "style": props.style
          }, attrs), [(_b = slots.default) == null ? void 0 : _b.call(slots)]);
        });
      }
    });
    const UP$1 = -1;
    const DOWN$1 = 1;
    const BUFFER_PX = 100;
    const makeVirtualProps = propsFactory({
      itemHeight: {
        type: [Number, String],
        default: null
      },
      height: [Number, String]
    }, "virtual");
    function useVirtual(props, items2) {
      const display = useDisplay();
      const itemHeight = shallowRef(0);
      watchEffect(() => {
        itemHeight.value = parseFloat(props.itemHeight || 0);
      });
      const first = shallowRef(0);
      const last = shallowRef(Math.ceil(
        // Assume 16px items filling the entire screen height if
        // not provided. This is probably incorrect but it minimises
        // the chance of ending up with empty space at the bottom.
        // The default value is set here to avoid poisoning getSize()
        (parseInt(props.height) || display.height.value) / (itemHeight.value || 16)
      ) || 1);
      const paddingTop = shallowRef(0);
      const paddingBottom = shallowRef(0);
      const containerRef = ref$1();
      const markerRef = ref$1();
      let markerOffset = 0;
      const {
        resizeRef,
        contentRect
      } = useResizeObserver$1();
      watchEffect(() => {
        resizeRef.value = containerRef.value;
      });
      const viewportHeight = computed(() => {
        var _a2;
        return containerRef.value === document.documentElement ? display.height.value : ((_a2 = contentRect.value) == null ? void 0 : _a2.height) || parseInt(props.height) || 0;
      });
      const hasInitialRender = computed(() => {
        return !!(containerRef.value && markerRef.value && viewportHeight.value && itemHeight.value);
      });
      let sizes = Array.from({
        length: items2.value.length
      });
      let offsets = Array.from({
        length: items2.value.length
      });
      const updateTime = shallowRef(0);
      let targetScrollIndex = -1;
      function getSize(index) {
        return sizes[index] || itemHeight.value;
      }
      const updateOffsets = debounce(() => {
        const start = performance.now();
        offsets[0] = 0;
        const length = items2.value.length;
        for (let i2 = 1; i2 <= length - 1; i2++) {
          offsets[i2] = (offsets[i2 - 1] || 0) + getSize(i2 - 1);
        }
        updateTime.value = Math.max(updateTime.value, performance.now() - start);
      }, updateTime);
      const unwatch = watch(hasInitialRender, (v) => {
        if (!v)
          return;
        unwatch();
        markerOffset = markerRef.value.offsetTop;
        updateOffsets.immediate();
        calculateVisibleItems();
        if (!~targetScrollIndex)
          return;
        nextTick(() => {
          IN_BROWSER && window.requestAnimationFrame(() => {
            scrollToIndex(targetScrollIndex);
            targetScrollIndex = -1;
          });
        });
      });
      onScopeDispose(() => {
        updateOffsets.clear();
      });
      function handleItemResize(index, height) {
        const prevHeight = sizes[index];
        const prevMinHeight = itemHeight.value;
        itemHeight.value = prevMinHeight ? Math.min(itemHeight.value, height) : height;
        if (prevHeight !== height || prevMinHeight !== itemHeight.value) {
          sizes[index] = height;
          updateOffsets();
        }
      }
      function calculateOffset(index) {
        index = clamp(index, 0, items2.value.length - 1);
        return offsets[index] || 0;
      }
      function calculateIndex(scrollTop) {
        return binaryClosest(offsets, scrollTop);
      }
      let lastScrollTop = 0;
      let scrollVelocity = 0;
      let lastScrollTime = 0;
      watch(viewportHeight, (val, oldVal) => {
        if (oldVal) {
          calculateVisibleItems();
          if (val < oldVal) {
            requestAnimationFrame(() => {
              scrollVelocity = 0;
              calculateVisibleItems();
            });
          }
        }
      });
      function handleScroll() {
        if (!containerRef.value || !markerRef.value)
          return;
        const scrollTop = containerRef.value.scrollTop;
        const scrollTime = performance.now();
        const scrollDeltaT = scrollTime - lastScrollTime;
        if (scrollDeltaT > 500) {
          scrollVelocity = Math.sign(scrollTop - lastScrollTop);
          markerOffset = markerRef.value.offsetTop;
        } else {
          scrollVelocity = scrollTop - lastScrollTop;
        }
        lastScrollTop = scrollTop;
        lastScrollTime = scrollTime;
        calculateVisibleItems();
      }
      function handleScrollend() {
        if (!containerRef.value || !markerRef.value)
          return;
        scrollVelocity = 0;
        lastScrollTime = 0;
        calculateVisibleItems();
      }
      let raf2 = -1;
      function calculateVisibleItems() {
        cancelAnimationFrame(raf2);
        raf2 = requestAnimationFrame(_calculateVisibleItems);
      }
      function _calculateVisibleItems() {
        if (!containerRef.value || !viewportHeight.value)
          return;
        const scrollTop = lastScrollTop - markerOffset;
        const direction = Math.sign(scrollVelocity);
        const startPx = Math.max(0, scrollTop - BUFFER_PX);
        const start = clamp(calculateIndex(startPx), 0, items2.value.length);
        const endPx = scrollTop + viewportHeight.value + BUFFER_PX;
        const end = clamp(calculateIndex(endPx) + 1, start + 1, items2.value.length);
        if (
          // Only update the side we're scrolling towards,
          // the other side will be updated incidentally
          (direction !== UP$1 || start < first.value) && (direction !== DOWN$1 || end > last.value)
        ) {
          const topOverflow = calculateOffset(first.value) - calculateOffset(start);
          const bottomOverflow = calculateOffset(end) - calculateOffset(last.value);
          const bufferOverflow = Math.max(topOverflow, bottomOverflow);
          if (bufferOverflow > BUFFER_PX) {
            first.value = start;
            last.value = end;
          } else {
            if (start <= 0)
              first.value = start;
            if (end >= items2.value.length)
              last.value = end;
          }
        }
        paddingTop.value = calculateOffset(first.value);
        paddingBottom.value = calculateOffset(items2.value.length) - calculateOffset(last.value);
      }
      function scrollToIndex(index) {
        const offset = calculateOffset(index);
        if (!containerRef.value || index && !offset) {
          targetScrollIndex = index;
        } else {
          containerRef.value.scrollTop = offset;
        }
      }
      const computedItems = computed(() => {
        return items2.value.slice(first.value, last.value).map((item, index) => ({
          raw: item,
          index: index + first.value
        }));
      });
      watch(items2, () => {
        sizes = Array.from({
          length: items2.value.length
        });
        offsets = Array.from({
          length: items2.value.length
        });
        updateOffsets.immediate();
        calculateVisibleItems();
      }, {
        deep: true
      });
      return {
        containerRef,
        markerRef,
        computedItems,
        paddingTop,
        paddingBottom,
        scrollToIndex,
        handleScroll,
        handleScrollend,
        handleItemResize
      };
    }
    function binaryClosest(arr, val) {
      let high = arr.length - 1;
      let low = 0;
      let mid2 = 0;
      let item = null;
      let target2 = -1;
      if (arr[high] < val) {
        return high;
      }
      while (low <= high) {
        mid2 = low + high >> 1;
        item = arr[mid2];
        if (item > val) {
          high = mid2 - 1;
        } else if (item < val) {
          target2 = mid2;
          low = mid2 + 1;
        } else if (item === val) {
          return mid2;
        } else {
          return low;
        }
      }
      return target2;
    }
    const makeVVirtualScrollProps = propsFactory({
      items: {
        type: Array,
        default: () => []
      },
      renderless: Boolean,
      ...makeVirtualProps(),
      ...makeComponentProps(),
      ...makeDimensionProps()
    }, "VVirtualScroll");
    const VVirtualScroll = genericComponent()({
      name: "VVirtualScroll",
      props: makeVVirtualScrollProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const vm = getCurrentInstance("VVirtualScroll");
        const {
          dimensionStyles
        } = useDimension(props);
        const {
          containerRef,
          markerRef,
          handleScroll,
          handleScrollend,
          handleItemResize,
          scrollToIndex,
          paddingTop,
          paddingBottom,
          computedItems
        } = useVirtual(props, toRef(props, "items"));
        useToggleScope(() => props.renderless, () => {
          function handleListeners() {
            var _a2, _b;
            let add2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
            const method = add2 ? "addEventListener" : "removeEventListener";
            if (containerRef.value === document.documentElement) {
              document[method]("scroll", handleScroll, {
                passive: true
              });
              document[method]("scrollend", handleScrollend);
            } else {
              (_a2 = containerRef.value) == null ? void 0 : _a2[method]("scroll", handleScroll, {
                passive: true
              });
              (_b = containerRef.value) == null ? void 0 : _b[method]("scrollend", handleScrollend);
            }
          }
          onMounted(() => {
            containerRef.value = getScrollParent(vm.vnode.el, true);
            handleListeners(true);
          });
          onScopeDispose(handleListeners);
        });
        useRender(() => {
          const children = computedItems.value.map((item) => createVNode(VVirtualScrollItem, {
            "key": item.index,
            "renderless": props.renderless,
            "onUpdate:height": (height) => handleItemResize(item.index, height)
          }, {
            default: (slotProps) => {
              var _a2;
              return (_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
                item: item.raw,
                index: item.index,
                ...slotProps
              });
            }
          }));
          return props.renderless ? createVNode(Fragment, null, [createVNode("div", {
            "ref": markerRef,
            "class": "v-virtual-scroll__spacer",
            "style": {
              paddingTop: convertToUnit(paddingTop.value)
            }
          }, null), children, createVNode("div", {
            "class": "v-virtual-scroll__spacer",
            "style": {
              paddingBottom: convertToUnit(paddingBottom.value)
            }
          }, null)]) : createVNode("div", {
            "ref": containerRef,
            "class": ["v-virtual-scroll", props.class],
            "onScrollPassive": handleScroll,
            "onScrollend": handleScrollend,
            "style": [dimensionStyles.value, props.style]
          }, [createVNode("div", {
            "ref": markerRef,
            "class": "v-virtual-scroll__container",
            "style": {
              paddingTop: convertToUnit(paddingTop.value),
              paddingBottom: convertToUnit(paddingBottom.value)
            }
          }, [children])]);
        });
        return {
          scrollToIndex
        };
      }
    });
    function useScrolling(listRef, textFieldRef) {
      const isScrolling = shallowRef(false);
      let scrollTimeout;
      function onListScroll(e) {
        cancelAnimationFrame(scrollTimeout);
        isScrolling.value = true;
        scrollTimeout = requestAnimationFrame(() => {
          scrollTimeout = requestAnimationFrame(() => {
            isScrolling.value = false;
          });
        });
      }
      async function finishScrolling() {
        await new Promise((resolve2) => requestAnimationFrame(resolve2));
        await new Promise((resolve2) => requestAnimationFrame(resolve2));
        await new Promise((resolve2) => requestAnimationFrame(resolve2));
        await new Promise((resolve2) => {
          if (isScrolling.value) {
            const stop = watch(isScrolling, () => {
              stop();
              resolve2();
            });
          } else
            resolve2();
        });
      }
      async function onListKeydown(e) {
        var _a2, _b;
        if (e.key === "Tab") {
          (_a2 = textFieldRef.value) == null ? void 0 : _a2.focus();
        }
        if (!["PageDown", "PageUp", "Home", "End"].includes(e.key))
          return;
        const el2 = (_b = listRef.value) == null ? void 0 : _b.$el;
        if (!el2)
          return;
        if (e.key === "Home" || e.key === "End") {
          el2.scrollTo({
            top: e.key === "Home" ? 0 : el2.scrollHeight,
            behavior: "smooth"
          });
        }
        await finishScrolling();
        const children = el2.querySelectorAll(":scope > :not(.v-virtual-scroll__spacer)");
        if (e.key === "PageDown" || e.key === "Home") {
          const top2 = el2.getBoundingClientRect().top;
          for (const child of children) {
            if (child.getBoundingClientRect().top >= top2) {
              child.focus();
              break;
            }
          }
        } else {
          const bottom2 = el2.getBoundingClientRect().bottom;
          for (const child of [...children].reverse()) {
            if (child.getBoundingClientRect().bottom <= bottom2) {
              child.focus();
              break;
            }
          }
        }
      }
      return {
        onListScroll,
        onListKeydown
      };
    }
    const makeSelectProps = propsFactory({
      chips: Boolean,
      closableChips: Boolean,
      closeText: {
        type: String,
        default: "$vuetify.close"
      },
      openText: {
        type: String,
        default: "$vuetify.open"
      },
      eager: Boolean,
      hideNoData: Boolean,
      hideSelected: Boolean,
      listProps: {
        type: Object
      },
      menu: Boolean,
      menuIcon: {
        type: IconValue,
        default: "$dropdown"
      },
      menuProps: {
        type: Object
      },
      multiple: Boolean,
      noDataText: {
        type: String,
        default: "$vuetify.noDataText"
      },
      openOnClear: Boolean,
      itemColor: String,
      ...makeItemsProps({
        itemChildren: false
      })
    }, "Select");
    const makeVSelectProps = propsFactory({
      ...makeSelectProps(),
      ...omit$1(makeVTextFieldProps({
        modelValue: null,
        role: "combobox"
      }), ["validationValue", "dirty", "appendInnerIcon"]),
      ...makeTransitionProps({
        transition: {
          component: VDialogTransition
        }
      })
    }, "VSelect");
    const VSelect = genericComponent()({
      name: "VSelect",
      props: makeVSelectProps(),
      emits: {
        "update:focused": (focused) => true,
        "update:modelValue": (value) => true,
        "update:menu": (ue) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          t
        } = useLocale();
        const vTextFieldRef = ref$1();
        const vMenuRef = ref$1();
        const vVirtualScrollRef = ref$1();
        const _menu = useProxiedModel(props, "menu");
        const menu = computed({
          get: () => _menu.value,
          set: (v) => {
            var _a2;
            if (_menu.value && !v && ((_a2 = vMenuRef.value) == null ? void 0 : _a2.ΨopenChildren))
              return;
            _menu.value = v;
          }
        });
        const {
          items: items2,
          transformIn,
          transformOut
        } = useItems(props);
        const model = useProxiedModel(props, "modelValue", [], (v) => transformIn(v === null ? [null] : wrapInArray(v)), (v) => {
          const transformed = transformOut(v);
          return props.multiple ? transformed : transformed[0] ?? null;
        });
        const counterValue = computed(() => {
          return typeof props.counterValue === "function" ? props.counterValue(model.value) : typeof props.counterValue === "number" ? props.counterValue : model.value.length;
        });
        const form = useForm();
        const selectedValues = computed(() => model.value.map((selection) => selection.value));
        const isFocused = shallowRef(false);
        const label = computed(() => menu.value ? props.closeText : props.openText);
        let keyboardLookupPrefix = "";
        let keyboardLookupLastTime;
        const displayItems = computed(() => {
          if (props.hideSelected) {
            return items2.value.filter((item) => !model.value.some((s) => props.valueComparator(s, item)));
          }
          return items2.value;
        });
        const menuDisabled = computed(() => props.hideNoData && !displayItems.value.length || props.readonly || (form == null ? void 0 : form.isReadonly.value));
        const computedMenuProps = computed(() => {
          var _a2;
          return {
            ...props.menuProps,
            activatorProps: {
              ...((_a2 = props.menuProps) == null ? void 0 : _a2.activatorProps) || {},
              "aria-haspopup": "listbox"
              // Set aria-haspopup to 'listbox'
            }
          };
        });
        const listRef = ref$1();
        const {
          onListScroll,
          onListKeydown
        } = useScrolling(listRef, vTextFieldRef);
        function onClear(e) {
          if (props.openOnClear) {
            menu.value = true;
          }
        }
        function onMousedownControl() {
          if (menuDisabled.value)
            return;
          menu.value = !menu.value;
        }
        function onKeydown(e) {
          var _a2, _b;
          if (!e.key || props.readonly || (form == null ? void 0 : form.isReadonly.value))
            return;
          if (["Enter", " ", "ArrowDown", "ArrowUp", "Home", "End"].includes(e.key)) {
            e.preventDefault();
          }
          if (["Enter", "ArrowDown", " "].includes(e.key)) {
            menu.value = true;
          }
          if (["Escape", "Tab"].includes(e.key)) {
            menu.value = false;
          }
          if (e.key === "Home") {
            (_a2 = listRef.value) == null ? void 0 : _a2.focus("first");
          } else if (e.key === "End") {
            (_b = listRef.value) == null ? void 0 : _b.focus("last");
          }
          const KEYBOARD_LOOKUP_THRESHOLD = 1e3;
          function checkPrintable(e2) {
            const isPrintableChar = e2.key.length === 1;
            const noModifier = !e2.ctrlKey && !e2.metaKey && !e2.altKey;
            return isPrintableChar && noModifier;
          }
          if (props.multiple || !checkPrintable(e))
            return;
          const now2 = performance.now();
          if (now2 - keyboardLookupLastTime > KEYBOARD_LOOKUP_THRESHOLD) {
            keyboardLookupPrefix = "";
          }
          keyboardLookupPrefix += e.key.toLowerCase();
          keyboardLookupLastTime = now2;
          const item = items2.value.find((item2) => item2.title.toLowerCase().startsWith(keyboardLookupPrefix));
          if (item !== void 0) {
            model.value = [item];
            const index = displayItems.value.indexOf(item);
            IN_BROWSER && window.requestAnimationFrame(() => {
              var _a3;
              index >= 0 && ((_a3 = vVirtualScrollRef.value) == null ? void 0 : _a3.scrollToIndex(index));
            });
          }
        }
        function select(item) {
          let set2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          if (item.props.disabled)
            return;
          if (props.multiple) {
            const index = model.value.findIndex((selection) => props.valueComparator(selection.value, item.value));
            const add2 = set2 == null ? !~index : set2;
            if (~index) {
              const value = add2 ? [...model.value, item] : [...model.value];
              value.splice(index, 1);
              model.value = value;
            } else if (add2) {
              model.value = [...model.value, item];
            }
          } else {
            const add2 = set2 !== false;
            model.value = add2 ? [item] : [];
            nextTick(() => {
              menu.value = false;
            });
          }
        }
        function onBlur(e) {
          var _a2;
          if (!((_a2 = listRef.value) == null ? void 0 : _a2.$el.contains(e.relatedTarget))) {
            menu.value = false;
          }
        }
        function onAfterLeave() {
          var _a2;
          if (isFocused.value) {
            (_a2 = vTextFieldRef.value) == null ? void 0 : _a2.focus();
          }
        }
        function onFocusin(e) {
          isFocused.value = true;
        }
        function onModelUpdate(v) {
          if (v == null)
            model.value = [];
          else if (matchesSelector(vTextFieldRef.value, ":autofill") || matchesSelector(vTextFieldRef.value, ":-webkit-autofill")) {
            const item = items2.value.find((item2) => item2.title === v);
            if (item) {
              select(item);
            }
          } else if (vTextFieldRef.value) {
            vTextFieldRef.value.value = "";
          }
        }
        watch(menu, () => {
          if (!props.hideSelected && menu.value && model.value.length) {
            const index = displayItems.value.findIndex((item) => model.value.some((s) => props.valueComparator(s.value, item.value)));
            IN_BROWSER && window.requestAnimationFrame(() => {
              var _a2;
              index >= 0 && ((_a2 = vVirtualScrollRef.value) == null ? void 0 : _a2.scrollToIndex(index));
            });
          }
        });
        watch(() => props.items, (newVal, oldVal) => {
          if (menu.value)
            return;
          if (isFocused.value && !oldVal.length && newVal.length) {
            menu.value = true;
          }
        });
        useRender(() => {
          const hasChips = !!(props.chips || slots.chip);
          const hasList = !!(!props.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
          const isDirty = model.value.length > 0;
          const textFieldProps = VTextField.filterProps(props);
          const placeholder = isDirty || !isFocused.value && props.label && !props.persistentPlaceholder ? void 0 : props.placeholder;
          return createVNode(VTextField, mergeProps({
            "ref": vTextFieldRef
          }, textFieldProps, {
            "modelValue": model.value.map((v) => v.props.value).join(", "),
            "onUpdate:modelValue": onModelUpdate,
            "focused": isFocused.value,
            "onUpdate:focused": ($event) => isFocused.value = $event,
            "validationValue": model.externalValue,
            "counterValue": counterValue.value,
            "dirty": isDirty,
            "class": ["v-select", {
              "v-select--active-menu": menu.value,
              "v-select--chips": !!props.chips,
              [`v-select--${props.multiple ? "multiple" : "single"}`]: true,
              "v-select--selected": model.value.length,
              "v-select--selection-slot": !!slots.selection
            }, props.class],
            "style": props.style,
            "inputmode": "none",
            "placeholder": placeholder,
            "onClick:clear": onClear,
            "onMousedown:control": onMousedownControl,
            "onBlur": onBlur,
            "onKeydown": onKeydown,
            "aria-label": t(label.value),
            "title": t(label.value)
          }), {
            ...slots,
            default: () => createVNode(Fragment, null, [createVNode(VMenu, mergeProps({
              "ref": vMenuRef,
              "modelValue": menu.value,
              "onUpdate:modelValue": ($event) => menu.value = $event,
              "activator": "parent",
              "contentClass": "v-select__content",
              "disabled": menuDisabled.value,
              "eager": props.eager,
              "maxHeight": 310,
              "openOnClick": false,
              "closeOnContentClick": false,
              "transition": props.transition,
              "onAfterLeave": onAfterLeave
            }, computedMenuProps.value), {
              default: () => [hasList && createVNode(VList, mergeProps({
                "ref": listRef,
                "selected": selectedValues.value,
                "selectStrategy": props.multiple ? "independent" : "single-independent",
                "onMousedown": (e) => e.preventDefault(),
                "onKeydown": onListKeydown,
                "onFocusin": onFocusin,
                "onScrollPassive": onListScroll,
                "tabindex": "-1",
                "aria-live": "polite",
                "color": props.itemColor ?? props.color
              }, props.listProps), {
                default: () => {
                  var _a2, _b, _c;
                  return [(_a2 = slots["prepend-item"]) == null ? void 0 : _a2.call(slots), !displayItems.value.length && !props.hideNoData && (((_b = slots["no-data"]) == null ? void 0 : _b.call(slots)) ?? createVNode(VListItem, {
                    "title": t(props.noDataText)
                  }, null)), createVNode(VVirtualScroll, {
                    "ref": vVirtualScrollRef,
                    "renderless": true,
                    "items": displayItems.value
                  }, {
                    default: (_ref2) => {
                      var _a3;
                      let {
                        item,
                        index,
                        itemRef
                      } = _ref2;
                      const itemProps = mergeProps(item.props, {
                        ref: itemRef,
                        key: index,
                        onClick: () => select(item, null)
                      });
                      return ((_a3 = slots.item) == null ? void 0 : _a3.call(slots, {
                        item,
                        index,
                        props: itemProps
                      })) ?? createVNode(VListItem, mergeProps(itemProps, {
                        "role": "option"
                      }), {
                        prepend: (_ref3) => {
                          let {
                            isSelected
                          } = _ref3;
                          return createVNode(Fragment, null, [props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                            "key": item.value,
                            "modelValue": isSelected,
                            "ripple": false,
                            "tabindex": "-1"
                          }, null) : void 0, item.props.prependAvatar && createVNode(VAvatar, {
                            "image": item.props.prependAvatar
                          }, null), item.props.prependIcon && createVNode(VIcon, {
                            "icon": item.props.prependIcon
                          }, null)]);
                        }
                      });
                    }
                  }), (_c = slots["append-item"]) == null ? void 0 : _c.call(slots)];
                }
              })]
            }), model.value.map((item, index) => {
              function onChipClose(e) {
                e.stopPropagation();
                e.preventDefault();
                select(item, false);
              }
              const slotProps = {
                "onClick:close": onChipClose,
                onKeydown(e) {
                  if (e.key !== "Enter" && e.key !== " ")
                    return;
                  e.preventDefault();
                  e.stopPropagation();
                  onChipClose(e);
                },
                onMousedown(e) {
                  e.preventDefault();
                  e.stopPropagation();
                },
                modelValue: true,
                "onUpdate:modelValue": void 0
              };
              const hasSlot = hasChips ? !!slots.chip : !!slots.selection;
              const slotContent = hasSlot ? ensureValidVNode(hasChips ? slots.chip({
                item,
                index,
                props: slotProps
              }) : slots.selection({
                item,
                index
              })) : void 0;
              if (hasSlot && !slotContent)
                return void 0;
              return createVNode("div", {
                "key": item.value,
                "class": "v-select__selection"
              }, [hasChips ? !slots.chip ? createVNode(VChip, mergeProps({
                "key": "chip",
                "closable": props.closableChips,
                "size": "small",
                "text": item.title,
                "disabled": item.props.disabled
              }, slotProps), null) : createVNode(VDefaultsProvider, {
                "key": "chip-defaults",
                "defaults": {
                  VChip: {
                    closable: props.closableChips,
                    size: "small",
                    text: item.title
                  }
                }
              }, {
                default: () => [slotContent]
              }) : slotContent ?? createVNode("span", {
                "class": "v-select__selection-text"
              }, [item.title, props.multiple && index < model.value.length - 1 && createVNode("span", {
                "class": "v-select__selection-comma"
              }, [createTextVNode(",")])])]);
            })]),
            "append-inner": function() {
              var _a2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return createVNode(Fragment, null, [(_a2 = slots["append-inner"]) == null ? void 0 : _a2.call(slots, ...args), props.menuIcon ? createVNode(VIcon, {
                "class": "v-select__menu-icon",
                "icon": props.menuIcon
              }, null) : void 0]);
            }
          });
        });
        return forwardRefs({
          isFocused,
          menu,
          select
        }, vTextFieldRef);
      }
    });
    const _hoisted_1$a = {
      key: 0,
      class: "pt-10 text-center font-weight-medium text-h6"
    };
    function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Form = resolveComponent("Form");
      return openBlock(), createBlock(VApp, null, {
        default: withCtx(() => [
          createVNode(VMain, null, {
            default: withCtx(() => [
              createVNode(VContainer, {
                fluid: "",
                "fill-height": ""
              }, {
                default: withCtx(() => [
                  createVNode(VRow, {
                    align: "center",
                    justify: "center"
                  }, {
                    default: withCtx(() => [
                      createVNode(VCol, {
                        xs: "12",
                        sm: "10",
                        md: "8"
                      }, {
                        default: withCtx(() => [
                          createVNode(VCard, { elevation: "10" }, {
                            default: withCtx(() => [
                              createVNode(VToolbar, {
                                dark: "",
                                color: "primary"
                              }, {
                                default: withCtx(() => [
                                  _ctx.currentView === _ctx.ComponentViews.LIST ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                                    createVNode(VToolbarTitle, null, {
                                      default: withCtx(() => [
                                        createTextVNode("Choose EVerest instance")
                                      ]),
                                      _: 1
                                    }),
                                    createVNode(VSpacer),
                                    createVNode(VBtn, {
                                      icon: "mdi-plus",
                                      disabled: _ctx.connecting,
                                      onClick: _ctx.openAddServerView,
                                      "data-cy": "add-everest-instance"
                                    }, null, 8, ["disabled", "onClick"])
                                  ], 64)) : (openBlock(), createBlock(VToolbarTitle, { key: 1 }, {
                                    default: withCtx(() => [
                                      createTextVNode(toDisplayString(_ctx.currentView === _ctx.ComponentViews.ADD ? "Add" : "Edit") + " server instance", 1)
                                    ]),
                                    _: 1
                                  }))
                                ]),
                                _: 1
                              }),
                              createVNode(VCardText, null, {
                                default: withCtx(() => [
                                  [_ctx.ComponentViews.ADD, _ctx.ComponentViews.EDIT].includes(_ctx.currentView) ? (openBlock(), createBlock(_component_Form, {
                                    key: 0,
                                    onSubmit: _ctx.submitEdit
                                  }, {
                                    default: withCtx(() => [
                                      createVNode(VContainer, null, {
                                        default: withCtx(() => [
                                          createVNode(VRow, null, {
                                            default: withCtx(() => [
                                              createVNode(VCol, {
                                                cols: "12",
                                                sm: "12"
                                              }, {
                                                default: withCtx(() => [
                                                  createVNode(VTextField, {
                                                    label: "Name of EVerest instance",
                                                    modelValue: _ctx.instanceId.value.value,
                                                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.instanceId.value.value = $event),
                                                    "error-messages": _ctx.instanceId.errorMessage.value,
                                                    hint: "For example 'Local', 'Development'...",
                                                    "data-cy": "instance-name-field"
                                                  }, null, 8, ["modelValue", "error-messages"])
                                                ]),
                                                _: 1
                                              })
                                            ]),
                                            _: 1
                                          }),
                                          createVNode(VRow, null, {
                                            default: withCtx(() => [
                                              createVNode(VCol, {
                                                cols: "3",
                                                sm: "3"
                                              }, {
                                                default: withCtx(() => [
                                                  createVNode(VSelect, {
                                                    modelValue: _ctx.protocol.value.value,
                                                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.protocol.value.value = $event),
                                                    "error-messages": _ctx.protocol.errorMessage.value,
                                                    label: "Protocol",
                                                    "data-cy": "protocol-select-field",
                                                    items: [{ value: "ws", title: "ws://" }, { value: "wss", title: "wss://" }]
                                                  }, null, 8, ["modelValue", "error-messages"])
                                                ]),
                                                _: 1
                                              }),
                                              createVNode(VCol, {
                                                cols: "6",
                                                sm: "6"
                                              }, {
                                                default: withCtx(() => [
                                                  createVNode(VTextField, {
                                                    label: "EVerest instance host address",
                                                    modelValue: _ctx.host.value.value,
                                                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.host.value.value = $event),
                                                    "error-messages": _ctx.host.errorMessage.value,
                                                    "data-cy": "host-address-field",
                                                    hint: "For example, localhost"
                                                  }, null, 8, ["modelValue", "error-messages"])
                                                ]),
                                                _: 1
                                              }),
                                              createVNode(VCol, {
                                                cols: "3",
                                                sm: "3"
                                              }, {
                                                default: withCtx(() => [
                                                  createVNode(VTextField, {
                                                    type: "number",
                                                    label: "Port",
                                                    modelValue: _ctx.port.value.value,
                                                    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.port.value.value = $event),
                                                    "error-messages": _ctx.port.errorMessage.value,
                                                    "data-cy": "port-field",
                                                    hint: "For example, 8849"
                                                  }, null, 8, ["modelValue", "error-messages"])
                                                ]),
                                                _: 1
                                              })
                                            ]),
                                            _: 1
                                          }),
                                          createVNode(VRow, null, {
                                            default: withCtx(() => [
                                              createVNode(VCol, null, {
                                                default: withCtx(() => [
                                                  _ctx.currentView === _ctx.ComponentViews.EDIT ? (openBlock(), createBlock(VBtn, {
                                                    key: 0,
                                                    icon: "mdi-delete",
                                                    elevation: "2",
                                                    onClick: _cache[4] || (_cache[4] = ($event) => _ctx.deleteItem()),
                                                    "data-cy": "delete-instance"
                                                  })) : createCommentVNode("", true)
                                                ]),
                                                _: 1
                                              }),
                                              createVNode(VSpacer),
                                              createVNode(VCol, { class: "text-right" }, {
                                                default: withCtx(() => [
                                                  createVNode(VBtn, {
                                                    class: "mx-4",
                                                    icon: "mdi-close",
                                                    elevation: "2",
                                                    onClick: _cache[5] || (_cache[5] = ($event) => _ctx.closeEdit())
                                                  }),
                                                  createVNode(VBtn, {
                                                    icon: "mdi-check",
                                                    elevation: "2",
                                                    type: "submit",
                                                    disabled: !_ctx.meta.valid,
                                                    "data-cy": "save-instance"
                                                  }, null, 8, ["disabled"])
                                                ]),
                                                _: 1
                                              })
                                            ]),
                                            _: 1
                                          })
                                        ]),
                                        _: 1
                                      })
                                    ]),
                                    _: 1
                                  }, 8, ["onSubmit"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                                    createVNode(VListSubheader, {
                                      lines: "two",
                                      disabled: _ctx.connecting,
                                      class: "mb-3"
                                    }, {
                                      default: withCtx(() => [
                                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.servers, (server, index) => {
                                          return openBlock(), createBlock(VListItem, {
                                            key: server.id,
                                            "prepend-icon": "mdi-server",
                                            "data-cy": "server-list-item",
                                            onClick: ($event) => _ctx.connect(server)
                                          }, {
                                            append: withCtx(() => [
                                              server.editable ? (openBlock(), createBlock(VListItemAction, { key: 0 }, {
                                                default: withCtx(() => [
                                                  createVNode(VBtn, {
                                                    variant: "text",
                                                    icon: "mdi-pencil",
                                                    onClick: withModifiers(($event) => _ctx.openEditServerView(index), ["prevent", "stop"]),
                                                    "data-cy": "edit-instance"
                                                  }, null, 8, ["onClick"])
                                                ]),
                                                _: 2
                                              }, 1024)) : createCommentVNode("", true),
                                              server.hint ? (openBlock(), createBlock(VTooltip, {
                                                key: 1,
                                                text: server.hint
                                              }, {
                                                activator: withCtx(({ props }) => [
                                                  createVNode(VListItemAction, mergeProps({ ref_for: true }, props), {
                                                    default: withCtx(() => [
                                                      createVNode(VBtn, {
                                                        variant: "text",
                                                        icon: "mdi-help-circle"
                                                      })
                                                    ]),
                                                    _: 2
                                                  }, 1040)
                                                ]),
                                                _: 2
                                              }, 1032, ["text"])) : createCommentVNode("", true)
                                            ]),
                                            default: withCtx(() => [
                                              createVNode(VListItemTitle, null, {
                                                default: withCtx(() => [
                                                  createTextVNode(toDisplayString(server.id), 1)
                                                ]),
                                                _: 2
                                              }, 1024),
                                              createVNode(VListItemSubtitle, null, {
                                                default: withCtx(() => [
                                                  createTextVNode(toDisplayString(server.host), 1)
                                                ]),
                                                _: 2
                                              }, 1024)
                                            ]),
                                            _: 2
                                          }, 1032, ["onClick"]);
                                        }), 128))
                                      ]),
                                      _: 1
                                    }, 8, ["disabled"]),
                                    createVNode(VCheckbox, {
                                      modelValue: _ctx.connectAutomatically,
                                      "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => _ctx.connectAutomatically = $event),
                                      "data-cy": "auto-connect-checkbox",
                                      label: "Automatically connect to this instance"
                                    }, null, 8, ["modelValue"]),
                                    createVNode(VAlert, {
                                      text: _ctx.error.status,
                                      prominent: "",
                                      type: "error",
                                      icon: "mdi-cloud-alert",
                                      modelValue: _ctx.error.active,
                                      "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => _ctx.error.active = $event),
                                      closable: ""
                                    }, null, 8, ["text", "modelValue"]),
                                    createVNode(Transition, null, {
                                      default: withCtx(() => [
                                        _ctx.connecting ? (openBlock(), createElementBlock("p", _hoisted_1$a, toDisplayString(_ctx.connectionStatus), 1)) : createCommentVNode("", true)
                                      ]),
                                      _: 1
                                    }),
                                    createVNode(VProgressLinear, {
                                      active: _ctx.connecting,
                                      height: "10",
                                      absolute: "",
                                      location: "bottom",
                                      indeterminate: ""
                                    }, null, 8, ["active"])
                                  ], 64))
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      });
    }
    const ConnectPage = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["render", _sfc_render$5]]);
    var isVue2 = false;
    /*!
     * pinia v2.2.1
     * (c) 2024 Eduardo San Martin Morote
     * @license MIT
     */
    let activePinia;
    const setActivePinia = (pinia2) => activePinia = pinia2;
    const piniaSymbol = (
      /* istanbul ignore next */
      Symbol()
    );
    function isPlainObject$1(o2) {
      return o2 && typeof o2 === "object" && Object.prototype.toString.call(o2) === "[object Object]" && typeof o2.toJSON !== "function";
    }
    var MutationType;
    (function(MutationType2) {
      MutationType2["direct"] = "direct";
      MutationType2["patchObject"] = "patch object";
      MutationType2["patchFunction"] = "patch function";
    })(MutationType || (MutationType = {}));
    function createPinia() {
      const scope2 = effectScope(true);
      const state = scope2.run(() => ref$1({}));
      let _p = [];
      let toBeInstalled = [];
      const pinia2 = markRaw({
        install(app2) {
          setActivePinia(pinia2);
          {
            pinia2._a = app2;
            app2.provide(piniaSymbol, pinia2);
            app2.config.globalProperties.$pinia = pinia2;
            toBeInstalled.forEach((plugin) => _p.push(plugin));
            toBeInstalled = [];
          }
        },
        use(plugin) {
          if (!this._a && !isVue2) {
            toBeInstalled.push(plugin);
          } else {
            _p.push(plugin);
          }
          return this;
        },
        _p,
        // it's actually undefined here
        // @ts-expect-error
        _a: null,
        _e: scope2,
        _s: /* @__PURE__ */ new Map(),
        state
      });
      return pinia2;
    }
    const noop = () => {
    };
    function addSubscription(subscriptions, callback, detached, onCleanup = noop) {
      subscriptions.push(callback);
      const removeSubscription = () => {
        const idx = subscriptions.indexOf(callback);
        if (idx > -1) {
          subscriptions.splice(idx, 1);
          onCleanup();
        }
      };
      if (!detached && getCurrentScope$1()) {
        onScopeDispose(removeSubscription);
      }
      return removeSubscription;
    }
    function triggerSubscriptions(subscriptions, ...args) {
      subscriptions.slice().forEach((callback) => {
        callback(...args);
      });
    }
    const fallbackRunWithContext = (fn) => fn();
    const ACTION_MARKER = Symbol();
    const ACTION_NAME = Symbol();
    function mergeReactiveObjects(target2, patchToApply) {
      if (target2 instanceof Map && patchToApply instanceof Map) {
        patchToApply.forEach((value, key) => target2.set(key, value));
      } else if (target2 instanceof Set && patchToApply instanceof Set) {
        patchToApply.forEach(target2.add, target2);
      }
      for (const key in patchToApply) {
        if (!patchToApply.hasOwnProperty(key))
          continue;
        const subPatch = patchToApply[key];
        const targetValue = target2[key];
        if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && target2.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
          target2[key] = mergeReactiveObjects(targetValue, subPatch);
        } else {
          target2[key] = subPatch;
        }
      }
      return target2;
    }
    const skipHydrateSymbol = (
      /* istanbul ignore next */
      Symbol()
    );
    function shouldHydrate(obj) {
      return !isPlainObject$1(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
    }
    const { assign: assign$2 } = Object;
    function isComputed(o2) {
      return !!(isRef(o2) && o2.effect);
    }
    function createOptionsStore(id2, options, pinia2, hot) {
      const { state, actions, getters } = options;
      const initialState = pinia2.state.value[id2];
      let store;
      function setup2() {
        if (!initialState && true) {
          {
            pinia2.state.value[id2] = state ? state() : {};
          }
        }
        const localState = toRefs(pinia2.state.value[id2]);
        return assign$2(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
          computedGetters[name] = markRaw(computed(() => {
            setActivePinia(pinia2);
            const store2 = pinia2._s.get(id2);
            return getters[name].call(store2, store2);
          }));
          return computedGetters;
        }, {}));
      }
      store = createSetupStore(id2, setup2, options, pinia2, hot, true);
      return store;
    }
    function createSetupStore($id2, setup2, options = {}, pinia2, hot, isOptionsStore) {
      let scope2;
      const optionsForPlugin = assign$2({ actions: {} }, options);
      const $subscribeOptions = { deep: true };
      let isListening;
      let isSyncListening;
      let subscriptions = [];
      let actionSubscriptions = [];
      let debuggerEvents;
      const initialState = pinia2.state.value[$id2];
      if (!isOptionsStore && !initialState && true) {
        {
          pinia2.state.value[$id2] = {};
        }
      }
      ref$1({});
      let activeListener;
      function $patch(partialStateOrMutator) {
        let subscriptionMutation;
        isListening = isSyncListening = false;
        if (typeof partialStateOrMutator === "function") {
          partialStateOrMutator(pinia2.state.value[$id2]);
          subscriptionMutation = {
            type: MutationType.patchFunction,
            storeId: $id2,
            events: debuggerEvents
          };
        } else {
          mergeReactiveObjects(pinia2.state.value[$id2], partialStateOrMutator);
          subscriptionMutation = {
            type: MutationType.patchObject,
            payload: partialStateOrMutator,
            storeId: $id2,
            events: debuggerEvents
          };
        }
        const myListenerId = activeListener = Symbol();
        nextTick().then(() => {
          if (activeListener === myListenerId) {
            isListening = true;
          }
        });
        isSyncListening = true;
        triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id2]);
      }
      const $reset = isOptionsStore ? function $reset2() {
        const { state } = options;
        const newState = state ? state() : {};
        this.$patch(($state) => {
          assign$2($state, newState);
        });
      } : (
        /* istanbul ignore next */
        noop
      );
      function $dispose() {
        scope2.stop();
        subscriptions = [];
        actionSubscriptions = [];
        pinia2._s.delete($id2);
      }
      const action = (fn, name = "") => {
        if (ACTION_MARKER in fn) {
          fn[ACTION_NAME] = name;
          return fn;
        }
        const wrappedAction = function() {
          setActivePinia(pinia2);
          const args = Array.from(arguments);
          const afterCallbackList = [];
          const onErrorCallbackList = [];
          function after(callback) {
            afterCallbackList.push(callback);
          }
          function onError(callback) {
            onErrorCallbackList.push(callback);
          }
          triggerSubscriptions(actionSubscriptions, {
            args,
            name: wrappedAction[ACTION_NAME],
            store,
            after,
            onError
          });
          let ret;
          try {
            ret = fn.apply(this && this.$id === $id2 ? this : store, args);
          } catch (error2) {
            triggerSubscriptions(onErrorCallbackList, error2);
            throw error2;
          }
          if (ret instanceof Promise) {
            return ret.then((value) => {
              triggerSubscriptions(afterCallbackList, value);
              return value;
            }).catch((error2) => {
              triggerSubscriptions(onErrorCallbackList, error2);
              return Promise.reject(error2);
            });
          }
          triggerSubscriptions(afterCallbackList, ret);
          return ret;
        };
        wrappedAction[ACTION_MARKER] = true;
        wrappedAction[ACTION_NAME] = name;
        return wrappedAction;
      };
      const partialStore = {
        _p: pinia2,
        // _s: scope,
        $id: $id2,
        $onAction: addSubscription.bind(null, actionSubscriptions),
        $patch,
        $reset,
        $subscribe(callback, options2 = {}) {
          const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
          const stopWatcher = scope2.run(() => watch(() => pinia2.state.value[$id2], (state) => {
            if (options2.flush === "sync" ? isSyncListening : isListening) {
              callback({
                storeId: $id2,
                type: MutationType.direct,
                events: debuggerEvents
              }, state);
            }
          }, assign$2({}, $subscribeOptions, options2)));
          return removeSubscription;
        },
        $dispose
      };
      const store = reactive(partialStore);
      pinia2._s.set($id2, store);
      const runWithContext = pinia2._a && pinia2._a.runWithContext || fallbackRunWithContext;
      const setupStore = runWithContext(() => pinia2._e.run(() => (scope2 = effectScope()).run(() => setup2({ action }))));
      for (const key in setupStore) {
        const prop2 = setupStore[key];
        if (isRef(prop2) && !isComputed(prop2) || isReactive(prop2)) {
          if (!isOptionsStore) {
            if (initialState && shouldHydrate(prop2)) {
              if (isRef(prop2)) {
                prop2.value = initialState[key];
              } else {
                mergeReactiveObjects(prop2, initialState[key]);
              }
            }
            {
              pinia2.state.value[$id2][key] = prop2;
            }
          }
        } else if (typeof prop2 === "function") {
          const actionValue = action(prop2, key);
          {
            setupStore[key] = actionValue;
          }
          optionsForPlugin.actions[key] = prop2;
        } else
          ;
      }
      {
        assign$2(store, setupStore);
        assign$2(toRaw(store), setupStore);
      }
      Object.defineProperty(store, "$state", {
        get: () => pinia2.state.value[$id2],
        set: (state) => {
          $patch(($state) => {
            assign$2($state, state);
          });
        }
      });
      pinia2._p.forEach((extender) => {
        {
          assign$2(store, scope2.run(() => extender({
            store,
            app: pinia2._a,
            pinia: pinia2,
            options: optionsForPlugin
          })));
        }
      });
      if (initialState && isOptionsStore && options.hydrate) {
        options.hydrate(store.$state, initialState);
      }
      isListening = true;
      isSyncListening = true;
      return store;
    }
    function defineStore(idOrOptions, setup2, setupOptions) {
      let id2;
      let options;
      const isSetupStore = typeof setup2 === "function";
      if (typeof idOrOptions === "string") {
        id2 = idOrOptions;
        options = isSetupStore ? setupOptions : setup2;
      } else {
        options = idOrOptions;
        id2 = idOrOptions.id;
      }
      function useStore(pinia2, hot) {
        const hasContext = hasInjectionContext();
        pinia2 = // in test mode, ignore the argument provided as we can always retrieve a
        // pinia instance with getActivePinia()
        pinia2 || (hasContext ? inject$1(piniaSymbol, null) : null);
        if (pinia2)
          setActivePinia(pinia2);
        pinia2 = activePinia;
        if (!pinia2._s.has(id2)) {
          if (isSetupStore) {
            createSetupStore(id2, setup2, options, pinia2);
          } else {
            createOptionsStore(id2, options, pinia2);
          }
        }
        const store = pinia2._s.get(id2);
        return store;
      }
      useStore.$id = id2;
      return useStore;
    }
    function storeToRefs(store) {
      {
        store = toRaw(store);
        const refs = {};
        for (const key in store) {
          const value = store[key];
          if (isRef(value) || isReactive(value)) {
            refs[key] = // ---
            toRef(store, key);
          }
        }
        return refs;
      }
    }
    class ConfigStageContext {
      constructor() {
        __publicField(this, "_event_handlers", []);
        __publicField(this, "container");
        __publicField(this, "_current_selected_terminal", null);
      }
      // constructor() {}
      add_observer(handler) {
        this._event_handlers.push(handler);
      }
      remove_observer(handler) {
        this._event_handlers.splice(this._event_handlers.indexOf(handler), 1);
      }
      set_container(container) {
        this.container = container;
      }
      _clear_terminal_selection() {
        this._current_selected_terminal = null;
      }
      clicked_instance(id2) {
        this._clear_terminal_selection();
        this._publish({ type: "SELECT", selection: { type: "MODULE_INSTANCE", id: id2 } });
      }
      clicked_terminal(terminal, module_instance_id) {
        if (!this._current_selected_terminal) {
          this._publish({ type: "SELECT", selection: { type: "TERMINAL", terminal } });
          this._current_selected_terminal = {
            ...terminal,
            module_instance_id
          };
          return;
        }
        this._publish({
          type: "ADD_CONNECTION",
          // FIXME (aw): is there a way making this more beautiful?
          connection: {
            providing_impl_name: terminal.type === "provide" ? terminal.id : this._current_selected_terminal.id,
            providing_instance_id: terminal.type === "provide" ? module_instance_id : this._current_selected_terminal.module_instance_id,
            requirement_name: terminal.type === "requirement" ? terminal.id : this._current_selected_terminal.id,
            requiring_instance_id: terminal.type === "requirement" ? module_instance_id : this._current_selected_terminal.module_instance_id
          }
        });
        this.unselect();
      }
      unselect() {
        this._clear_terminal_selection();
        this._publish({
          type: "SELECT",
          selection: { type: "NONE" }
        });
      }
      clicked_connection(id2) {
        this._clear_terminal_selection();
        this._publish({
          type: "SELECT",
          selection: { type: "CONNECTION", id: id2 }
        });
      }
      _publish(event) {
        this._event_handlers.forEach((handler) => {
          handler(event);
        });
      }
    }
    const useEvbcStore = defineStore("evbc", () => {
      const selection = ref$1({ type: "NONE" });
      const current_config = ref$1(null);
      const config_context = reactive(new ConfigStageContext());
      const available_configs = ref$1({});
      config_context.add_observer((ev) => {
        if (ev.type === "SELECT") {
          selection.value = ev.selection;
        }
      });
      function setOpenedConfig(model) {
        current_config.value = model;
      }
      const get_is_config_opened = () => !!current_config.value;
      const get_config_context = () => config_context;
      const get_selected_module_instance = () => get_is_config_opened() && selection.value.type === "MODULE_INSTANCE" ? selection.value.id : null;
      const get_selected_terminal = () => get_is_config_opened() && selection.value.type === "TERMINAL" ? selection.value.terminal : null;
      const get_selected_connection = () => get_is_config_opened() && selection.value.type === "CONNECTION" ? selection.value.id : null;
      return {
        available_configs,
        selection,
        current_config,
        config_context,
        setOpenedConfig,
        get_config_context,
        get_selected_module_instance,
        get_selected_terminal,
        get_selected_connection
      };
    });
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x2) {
      return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
    }
    function getAugmentedNamespace(n) {
      if (n.__esModule)
        return n;
      var f = n.default;
      if (typeof f == "function") {
        var a = function a2() {
          if (this instanceof a2) {
            return Reflect.construct(f, arguments, this.constructor);
          }
          return f.apply(this, arguments);
        };
        a.prototype = f.prototype;
      } else
        a = {};
      Object.defineProperty(a, "__esModule", { value: true });
      Object.keys(n).forEach(function(k) {
        var d = Object.getOwnPropertyDescriptor(n, k);
        Object.defineProperty(a, k, d.get ? d : {
          enumerable: true,
          get: function() {
            return n[k];
          }
        });
      });
      return a;
    }
    var lib$2 = { exports: {} };
    var _FullInternals = {};
    var _CoreInternals = {};
    var Global = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2._registerNode = exports2.Konva = exports2.glob = void 0;
      const PI_OVER_180 = Math.PI / 180;
      function detectBrowser() {
        return typeof window !== "undefined" && ({}.toString.call(window) === "[object Window]" || {}.toString.call(window) === "[object global]");
      }
      exports2.glob = typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" ? self : {};
      exports2.Konva = {
        _global: exports2.glob,
        version: "9.3.14",
        isBrowser: detectBrowser(),
        isUnminified: /param/.test((function(param) {
        }).toString()),
        dblClickWindow: 400,
        getAngle(angle2) {
          return exports2.Konva.angleDeg ? angle2 * PI_OVER_180 : angle2;
        },
        enableTrace: false,
        pointerEventsEnabled: true,
        autoDrawEnabled: true,
        hitOnDragEnabled: false,
        capturePointerEventsEnabled: false,
        _mouseListenClick: false,
        _touchListenClick: false,
        _pointerListenClick: false,
        _mouseInDblClickWindow: false,
        _touchInDblClickWindow: false,
        _pointerInDblClickWindow: false,
        _mouseDblClickPointerId: null,
        _touchDblClickPointerId: null,
        _pointerDblClickPointerId: null,
        _fixTextRendering: false,
        pixelRatio: typeof window !== "undefined" && window.devicePixelRatio || 1,
        dragDistance: 3,
        angleDeg: true,
        showWarnings: true,
        dragButtons: [0, 1],
        isDragging() {
          return exports2.Konva["DD"].isDragging;
        },
        isTransforming() {
          var _a2;
          return (_a2 = exports2.Konva["Transformer"]) === null || _a2 === void 0 ? void 0 : _a2.isTransforming();
        },
        isDragReady() {
          return !!exports2.Konva["DD"].node;
        },
        releaseCanvasOnDestroy: true,
        document: exports2.glob.document,
        _injectGlobal(Konva2) {
          exports2.glob.Konva = Konva2;
        }
      };
      const _registerNode = (NodeClass) => {
        exports2.Konva[NodeClass.prototype.getClassName()] = NodeClass;
      };
      exports2._registerNode = _registerNode;
      exports2.Konva._injectGlobal(exports2.Konva);
    })(Global);
    var Util = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Util = exports2.Transform = void 0;
      const Global_12 = Global;
      class Transform {
        constructor(m = [1, 0, 0, 1, 0, 0]) {
          this.dirty = false;
          this.m = m && m.slice() || [1, 0, 0, 1, 0, 0];
        }
        reset() {
          this.m[0] = 1;
          this.m[1] = 0;
          this.m[2] = 0;
          this.m[3] = 1;
          this.m[4] = 0;
          this.m[5] = 0;
        }
        copy() {
          return new Transform(this.m);
        }
        copyInto(tr) {
          tr.m[0] = this.m[0];
          tr.m[1] = this.m[1];
          tr.m[2] = this.m[2];
          tr.m[3] = this.m[3];
          tr.m[4] = this.m[4];
          tr.m[5] = this.m[5];
        }
        point(point) {
          var m = this.m;
          return {
            x: m[0] * point.x + m[2] * point.y + m[4],
            y: m[1] * point.x + m[3] * point.y + m[5]
          };
        }
        translate(x2, y) {
          this.m[4] += this.m[0] * x2 + this.m[2] * y;
          this.m[5] += this.m[1] * x2 + this.m[3] * y;
          return this;
        }
        scale(sx, sy) {
          this.m[0] *= sx;
          this.m[1] *= sx;
          this.m[2] *= sy;
          this.m[3] *= sy;
          return this;
        }
        rotate(rad) {
          var c = Math.cos(rad);
          var s = Math.sin(rad);
          var m11 = this.m[0] * c + this.m[2] * s;
          var m12 = this.m[1] * c + this.m[3] * s;
          var m21 = this.m[0] * -s + this.m[2] * c;
          var m22 = this.m[1] * -s + this.m[3] * c;
          this.m[0] = m11;
          this.m[1] = m12;
          this.m[2] = m21;
          this.m[3] = m22;
          return this;
        }
        getTranslation() {
          return {
            x: this.m[4],
            y: this.m[5]
          };
        }
        skew(sx, sy) {
          var m11 = this.m[0] + this.m[2] * sy;
          var m12 = this.m[1] + this.m[3] * sy;
          var m21 = this.m[2] + this.m[0] * sx;
          var m22 = this.m[3] + this.m[1] * sx;
          this.m[0] = m11;
          this.m[1] = m12;
          this.m[2] = m21;
          this.m[3] = m22;
          return this;
        }
        multiply(matrix) {
          var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
          var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];
          var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
          var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];
          var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
          var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];
          this.m[0] = m11;
          this.m[1] = m12;
          this.m[2] = m21;
          this.m[3] = m22;
          this.m[4] = dx;
          this.m[5] = dy;
          return this;
        }
        invert() {
          var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
          var m0 = this.m[3] * d;
          var m1 = -this.m[1] * d;
          var m2 = -this.m[2] * d;
          var m3 = this.m[0] * d;
          var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
          var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
          this.m[0] = m0;
          this.m[1] = m1;
          this.m[2] = m2;
          this.m[3] = m3;
          this.m[4] = m4;
          this.m[5] = m5;
          return this;
        }
        getMatrix() {
          return this.m;
        }
        decompose() {
          var a = this.m[0];
          var b = this.m[1];
          var c = this.m[2];
          var d = this.m[3];
          var e = this.m[4];
          var f = this.m[5];
          var delta2 = a * d - b * c;
          let result = {
            x: e,
            y: f,
            rotation: 0,
            scaleX: 0,
            scaleY: 0,
            skewX: 0,
            skewY: 0
          };
          if (a != 0 || b != 0) {
            var r2 = Math.sqrt(a * a + b * b);
            result.rotation = b > 0 ? Math.acos(a / r2) : -Math.acos(a / r2);
            result.scaleX = r2;
            result.scaleY = delta2 / r2;
            result.skewX = (a * c + b * d) / delta2;
            result.skewY = 0;
          } else if (c != 0 || d != 0) {
            var s = Math.sqrt(c * c + d * d);
            result.rotation = Math.PI / 2 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s));
            result.scaleX = delta2 / s;
            result.scaleY = s;
            result.skewX = 0;
            result.skewY = (a * c + b * d) / delta2;
          } else
            ;
          result.rotation = exports2.Util._getRotation(result.rotation);
          return result;
        }
      }
      exports2.Transform = Transform;
      var OBJECT_ARRAY = "[object Array]", OBJECT_NUMBER = "[object Number]", OBJECT_STRING = "[object String]", OBJECT_BOOLEAN = "[object Boolean]", PI_OVER_DEG180 = Math.PI / 180, DEG180_OVER_PI = 180 / Math.PI, HASH2 = "#", EMPTY_STRING2 = "", ZERO = "0", KONVA_WARNING = "Konva warning: ", KONVA_ERROR = "Konva error: ", RGB_PAREN = "rgb(", COLORS = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 132, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 255, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 203],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [119, 128, 144],
        slategrey: [119, 128, 144],
        snow: [255, 255, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        transparent: [255, 255, 255, 0],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 5]
      }, RGB_REGEX = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/, animQueue = [];
      const req = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame || function(f) {
        setTimeout(f, 60);
      };
      exports2.Util = {
        _isElement(obj) {
          return !!(obj && obj.nodeType == 1);
        },
        _isFunction(obj) {
          return !!(obj && obj.constructor && obj.call && obj.apply);
        },
        _isPlainObject(obj) {
          return !!obj && obj.constructor === Object;
        },
        _isArray(obj) {
          return Object.prototype.toString.call(obj) === OBJECT_ARRAY;
        },
        _isNumber(obj) {
          return Object.prototype.toString.call(obj) === OBJECT_NUMBER && !isNaN(obj) && isFinite(obj);
        },
        _isString(obj) {
          return Object.prototype.toString.call(obj) === OBJECT_STRING;
        },
        _isBoolean(obj) {
          return Object.prototype.toString.call(obj) === OBJECT_BOOLEAN;
        },
        isObject(val) {
          return val instanceof Object;
        },
        isValidSelector(selector) {
          if (typeof selector !== "string") {
            return false;
          }
          var firstChar = selector[0];
          return firstChar === "#" || firstChar === "." || firstChar === firstChar.toUpperCase();
        },
        _sign(number) {
          if (number === 0) {
            return 1;
          }
          if (number > 0) {
            return 1;
          } else {
            return -1;
          }
        },
        requestAnimFrame(callback) {
          animQueue.push(callback);
          if (animQueue.length === 1) {
            req(function() {
              const queue2 = animQueue;
              animQueue = [];
              queue2.forEach(function(cb) {
                cb();
              });
            });
          }
        },
        createCanvasElement() {
          var canvas = document.createElement("canvas");
          try {
            canvas.style = canvas.style || {};
          } catch (e) {
          }
          return canvas;
        },
        createImageElement() {
          return document.createElement("img");
        },
        _isInDocument(el2) {
          while (el2 = el2.parentNode) {
            if (el2 == document) {
              return true;
            }
          }
          return false;
        },
        _urlToImage(url, callback) {
          var imageObj = exports2.Util.createImageElement();
          imageObj.onload = function() {
            callback(imageObj);
          };
          imageObj.src = url;
        },
        _rgbToHex(r2, g2, b) {
          return ((1 << 24) + (r2 << 16) + (g2 << 8) + b).toString(16).slice(1);
        },
        _hexToRgb(hex2) {
          hex2 = hex2.replace(HASH2, EMPTY_STRING2);
          var bigint = parseInt(hex2, 16);
          return {
            r: bigint >> 16 & 255,
            g: bigint >> 8 & 255,
            b: bigint & 255
          };
        },
        getRandomColor() {
          var randColor = (Math.random() * 16777215 << 0).toString(16);
          while (randColor.length < 6) {
            randColor = ZERO + randColor;
          }
          return HASH2 + randColor;
        },
        getRGB(color) {
          var rgb2;
          if (color in COLORS) {
            rgb2 = COLORS[color];
            return {
              r: rgb2[0],
              g: rgb2[1],
              b: rgb2[2]
            };
          } else if (color[0] === HASH2) {
            return this._hexToRgb(color.substring(1));
          } else if (color.substr(0, 4) === RGB_PAREN) {
            rgb2 = RGB_REGEX.exec(color.replace(/ /g, ""));
            return {
              r: parseInt(rgb2[1], 10),
              g: parseInt(rgb2[2], 10),
              b: parseInt(rgb2[3], 10)
            };
          } else {
            return {
              r: 0,
              g: 0,
              b: 0
            };
          }
        },
        colorToRGBA(str2) {
          str2 = str2 || "black";
          return exports2.Util._namedColorToRBA(str2) || exports2.Util._hex3ColorToRGBA(str2) || exports2.Util._hex4ColorToRGBA(str2) || exports2.Util._hex6ColorToRGBA(str2) || exports2.Util._hex8ColorToRGBA(str2) || exports2.Util._rgbColorToRGBA(str2) || exports2.Util._rgbaColorToRGBA(str2) || exports2.Util._hslColorToRGBA(str2);
        },
        _namedColorToRBA(str2) {
          var c = COLORS[str2.toLowerCase()];
          if (!c) {
            return null;
          }
          return {
            r: c[0],
            g: c[1],
            b: c[2],
            a: 1
          };
        },
        _rgbColorToRGBA(str2) {
          if (str2.indexOf("rgb(") === 0) {
            str2 = str2.match(/rgb\(([^)]+)\)/)[1];
            var parts = str2.split(/ *, */).map(Number);
            return {
              r: parts[0],
              g: parts[1],
              b: parts[2],
              a: 1
            };
          }
        },
        _rgbaColorToRGBA(str2) {
          if (str2.indexOf("rgba(") === 0) {
            str2 = str2.match(/rgba\(([^)]+)\)/)[1];
            var parts = str2.split(/ *, */).map((n, index) => {
              if (n.slice(-1) === "%") {
                return index === 3 ? parseInt(n) / 100 : parseInt(n) / 100 * 255;
              }
              return Number(n);
            });
            return {
              r: parts[0],
              g: parts[1],
              b: parts[2],
              a: parts[3]
            };
          }
        },
        _hex8ColorToRGBA(str2) {
          if (str2[0] === "#" && str2.length === 9) {
            return {
              r: parseInt(str2.slice(1, 3), 16),
              g: parseInt(str2.slice(3, 5), 16),
              b: parseInt(str2.slice(5, 7), 16),
              a: parseInt(str2.slice(7, 9), 16) / 255
            };
          }
        },
        _hex6ColorToRGBA(str2) {
          if (str2[0] === "#" && str2.length === 7) {
            return {
              r: parseInt(str2.slice(1, 3), 16),
              g: parseInt(str2.slice(3, 5), 16),
              b: parseInt(str2.slice(5, 7), 16),
              a: 1
            };
          }
        },
        _hex4ColorToRGBA(str2) {
          if (str2[0] === "#" && str2.length === 5) {
            return {
              r: parseInt(str2[1] + str2[1], 16),
              g: parseInt(str2[2] + str2[2], 16),
              b: parseInt(str2[3] + str2[3], 16),
              a: parseInt(str2[4] + str2[4], 16) / 255
            };
          }
        },
        _hex3ColorToRGBA(str2) {
          if (str2[0] === "#" && str2.length === 4) {
            return {
              r: parseInt(str2[1] + str2[1], 16),
              g: parseInt(str2[2] + str2[2], 16),
              b: parseInt(str2[3] + str2[3], 16),
              a: 1
            };
          }
        },
        _hslColorToRGBA(str2) {
          if (/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.test(str2)) {
            const [_, ...hsl2] = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(str2);
            const h2 = Number(hsl2[0]) / 360;
            const s = Number(hsl2[1]) / 100;
            const l = Number(hsl2[2]) / 100;
            let t2;
            let t3;
            let val;
            if (s === 0) {
              val = l * 255;
              return {
                r: Math.round(val),
                g: Math.round(val),
                b: Math.round(val),
                a: 1
              };
            }
            if (l < 0.5) {
              t2 = l * (1 + s);
            } else {
              t2 = l + s - l * s;
            }
            const t1 = 2 * l - t2;
            const rgb2 = [0, 0, 0];
            for (let i2 = 0; i2 < 3; i2++) {
              t3 = h2 + 1 / 3 * -(i2 - 1);
              if (t3 < 0) {
                t3++;
              }
              if (t3 > 1) {
                t3--;
              }
              if (6 * t3 < 1) {
                val = t1 + (t2 - t1) * 6 * t3;
              } else if (2 * t3 < 1) {
                val = t2;
              } else if (3 * t3 < 2) {
                val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
              } else {
                val = t1;
              }
              rgb2[i2] = val * 255;
            }
            return {
              r: Math.round(rgb2[0]),
              g: Math.round(rgb2[1]),
              b: Math.round(rgb2[2]),
              a: 1
            };
          }
        },
        haveIntersection(r1, r2) {
          return !(r2.x > r1.x + r1.width || r2.x + r2.width < r1.x || r2.y > r1.y + r1.height || r2.y + r2.height < r1.y);
        },
        cloneObject(obj) {
          var retObj = {};
          for (var key in obj) {
            if (this._isPlainObject(obj[key])) {
              retObj[key] = this.cloneObject(obj[key]);
            } else if (this._isArray(obj[key])) {
              retObj[key] = this.cloneArray(obj[key]);
            } else {
              retObj[key] = obj[key];
            }
          }
          return retObj;
        },
        cloneArray(arr) {
          return arr.slice(0);
        },
        degToRad(deg2) {
          return deg2 * PI_OVER_DEG180;
        },
        radToDeg(rad) {
          return rad * DEG180_OVER_PI;
        },
        _degToRad(deg2) {
          exports2.Util.warn("Util._degToRad is removed. Please use public Util.degToRad instead.");
          return exports2.Util.degToRad(deg2);
        },
        _radToDeg(rad) {
          exports2.Util.warn("Util._radToDeg is removed. Please use public Util.radToDeg instead.");
          return exports2.Util.radToDeg(rad);
        },
        _getRotation(radians) {
          return Global_12.Konva.angleDeg ? exports2.Util.radToDeg(radians) : radians;
        },
        _capitalize(str2) {
          return str2.charAt(0).toUpperCase() + str2.slice(1);
        },
        throw(str2) {
          throw new Error(KONVA_ERROR + str2);
        },
        error(str2) {
          console.error(KONVA_ERROR + str2);
        },
        warn(str2) {
          if (!Global_12.Konva.showWarnings) {
            return;
          }
          console.warn(KONVA_WARNING + str2);
        },
        each(obj, func) {
          for (var key in obj) {
            func(key, obj[key]);
          }
        },
        _inRange(val, left, right) {
          return left <= val && val < right;
        },
        _getProjectionToSegment(x1, y1, x2, y2, x3, y3) {
          var x4, y, dist2;
          var pd2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
          if (pd2 == 0) {
            x4 = x1;
            y = y1;
            dist2 = (x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2);
          } else {
            var u = ((x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1)) / pd2;
            if (u < 0) {
              x4 = x1;
              y = y1;
              dist2 = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3);
            } else if (u > 1) {
              x4 = x2;
              y = y2;
              dist2 = (x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3);
            } else {
              x4 = x1 + u * (x2 - x1);
              y = y1 + u * (y2 - y1);
              dist2 = (x4 - x3) * (x4 - x3) + (y - y3) * (y - y3);
            }
          }
          return [x4, y, dist2];
        },
        _getProjectionToLine(pt, line, isClosed) {
          var pc = exports2.Util.cloneObject(pt);
          var dist2 = Number.MAX_VALUE;
          line.forEach(function(p1, i2) {
            if (!isClosed && i2 === line.length - 1) {
              return;
            }
            var p2 = line[(i2 + 1) % line.length];
            var proj = exports2.Util._getProjectionToSegment(p1.x, p1.y, p2.x, p2.y, pt.x, pt.y);
            var px = proj[0], py = proj[1], pdist = proj[2];
            if (pdist < dist2) {
              pc.x = px;
              pc.y = py;
              dist2 = pdist;
            }
          });
          return pc;
        },
        _prepareArrayForTween(startArray, endArray, isClosed) {
          var n, start = [], end = [];
          if (startArray.length > endArray.length) {
            var temp = endArray;
            endArray = startArray;
            startArray = temp;
          }
          for (n = 0; n < startArray.length; n += 2) {
            start.push({
              x: startArray[n],
              y: startArray[n + 1]
            });
          }
          for (n = 0; n < endArray.length; n += 2) {
            end.push({
              x: endArray[n],
              y: endArray[n + 1]
            });
          }
          var newStart = [];
          end.forEach(function(point) {
            var pr2 = exports2.Util._getProjectionToLine(point, start, isClosed);
            newStart.push(pr2.x);
            newStart.push(pr2.y);
          });
          return newStart;
        },
        _prepareToStringify(obj) {
          var desc;
          obj.visitedByCircularReferenceRemoval = true;
          for (var key in obj) {
            if (!(obj.hasOwnProperty(key) && obj[key] && typeof obj[key] == "object")) {
              continue;
            }
            desc = Object.getOwnPropertyDescriptor(obj, key);
            if (obj[key].visitedByCircularReferenceRemoval || exports2.Util._isElement(obj[key])) {
              if (desc.configurable) {
                delete obj[key];
              } else {
                return null;
              }
            } else if (exports2.Util._prepareToStringify(obj[key]) === null) {
              if (desc.configurable) {
                delete obj[key];
              } else {
                return null;
              }
            }
          }
          delete obj.visitedByCircularReferenceRemoval;
          return obj;
        },
        _assign(target2, source2) {
          for (var key in source2) {
            target2[key] = source2[key];
          }
          return target2;
        },
        _getFirstPointerId(evt) {
          if (!evt.touches) {
            return evt.pointerId || 999;
          } else {
            return evt.changedTouches[0].identifier;
          }
        },
        releaseCanvas(...canvases) {
          if (!Global_12.Konva.releaseCanvasOnDestroy)
            return;
          canvases.forEach((c) => {
            c.width = 0;
            c.height = 0;
          });
        },
        drawRoundedRectPath(context, width, height, cornerRadius) {
          let topLeft = 0;
          let topRight = 0;
          let bottomLeft = 0;
          let bottomRight = 0;
          if (typeof cornerRadius === "number") {
            topLeft = topRight = bottomLeft = bottomRight = Math.min(cornerRadius, width / 2, height / 2);
          } else {
            topLeft = Math.min(cornerRadius[0] || 0, width / 2, height / 2);
            topRight = Math.min(cornerRadius[1] || 0, width / 2, height / 2);
            bottomRight = Math.min(cornerRadius[2] || 0, width / 2, height / 2);
            bottomLeft = Math.min(cornerRadius[3] || 0, width / 2, height / 2);
          }
          context.moveTo(topLeft, 0);
          context.lineTo(width - topRight, 0);
          context.arc(width - topRight, topRight, topRight, Math.PI * 3 / 2, 0, false);
          context.lineTo(width, height - bottomRight);
          context.arc(width - bottomRight, height - bottomRight, bottomRight, 0, Math.PI / 2, false);
          context.lineTo(bottomLeft, height);
          context.arc(bottomLeft, height - bottomLeft, bottomLeft, Math.PI / 2, Math.PI, false);
          context.lineTo(0, topLeft);
          context.arc(topLeft, topLeft, topLeft, Math.PI, Math.PI * 3 / 2, false);
        }
      };
    })(Util);
    var Node$2 = {};
    var Factory = {};
    var Validators = {};
    Object.defineProperty(Validators, "__esModule", { value: true });
    Validators.getComponentValidator = Validators.getBooleanValidator = Validators.getNumberArrayValidator = Validators.getFunctionValidator = Validators.getStringOrGradientValidator = Validators.getStringValidator = Validators.getNumberOrAutoValidator = Validators.getNumberOrArrayOfNumbersValidator = Validators.getNumberValidator = Validators.alphaComponent = Validators.RGBComponent = void 0;
    const Global_1$p = Global;
    const Util_1$f = Util;
    function _formatValue(val) {
      if (Util_1$f.Util._isString(val)) {
        return '"' + val + '"';
      }
      if (Object.prototype.toString.call(val) === "[object Number]") {
        return val;
      }
      if (Util_1$f.Util._isBoolean(val)) {
        return val;
      }
      return Object.prototype.toString.call(val);
    }
    function RGBComponent(val) {
      if (val > 255) {
        return 255;
      } else if (val < 0) {
        return 0;
      }
      return Math.round(val);
    }
    Validators.RGBComponent = RGBComponent;
    function alphaComponent(val) {
      if (val > 1) {
        return 1;
      } else if (val < 1e-4) {
        return 1e-4;
      }
      return val;
    }
    Validators.alphaComponent = alphaComponent;
    function getNumberValidator() {
      if (Global_1$p.Konva.isUnminified) {
        return function(val, attr) {
          if (!Util_1$f.Util._isNumber(val)) {
            Util_1$f.Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a number.');
          }
          return val;
        };
      }
    }
    Validators.getNumberValidator = getNumberValidator;
    function getNumberOrArrayOfNumbersValidator(noOfElements) {
      if (Global_1$p.Konva.isUnminified) {
        return function(val, attr) {
          let isNumber = Util_1$f.Util._isNumber(val);
          let isValidArray = Util_1$f.Util._isArray(val) && val.length == noOfElements;
          if (!isNumber && !isValidArray) {
            Util_1$f.Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a number or Array<number>(' + noOfElements + ")");
          }
          return val;
        };
      }
    }
    Validators.getNumberOrArrayOfNumbersValidator = getNumberOrArrayOfNumbersValidator;
    function getNumberOrAutoValidator() {
      if (Global_1$p.Konva.isUnminified) {
        return function(val, attr) {
          var isNumber = Util_1$f.Util._isNumber(val);
          var isAuto = val === "auto";
          if (!(isNumber || isAuto)) {
            Util_1$f.Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a number or "auto".');
          }
          return val;
        };
      }
    }
    Validators.getNumberOrAutoValidator = getNumberOrAutoValidator;
    function getStringValidator() {
      if (Global_1$p.Konva.isUnminified) {
        return function(val, attr) {
          if (!Util_1$f.Util._isString(val)) {
            Util_1$f.Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a string.');
          }
          return val;
        };
      }
    }
    Validators.getStringValidator = getStringValidator;
    function getStringOrGradientValidator() {
      if (Global_1$p.Konva.isUnminified) {
        return function(val, attr) {
          const isString2 = Util_1$f.Util._isString(val);
          const isGradient = Object.prototype.toString.call(val) === "[object CanvasGradient]" || val && val.addColorStop;
          if (!(isString2 || isGradient)) {
            Util_1$f.Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a string or a native gradient.');
          }
          return val;
        };
      }
    }
    Validators.getStringOrGradientValidator = getStringOrGradientValidator;
    function getFunctionValidator() {
      if (Global_1$p.Konva.isUnminified) {
        return function(val, attr) {
          if (!Util_1$f.Util._isFunction(val)) {
            Util_1$f.Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a function.');
          }
          return val;
        };
      }
    }
    Validators.getFunctionValidator = getFunctionValidator;
    function getNumberArrayValidator() {
      if (Global_1$p.Konva.isUnminified) {
        return function(val, attr) {
          const TypedArray = Int8Array ? Object.getPrototypeOf(Int8Array) : null;
          if (TypedArray && val instanceof TypedArray) {
            return val;
          }
          if (!Util_1$f.Util._isArray(val)) {
            Util_1$f.Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a array of numbers.');
          } else {
            val.forEach(function(item) {
              if (!Util_1$f.Util._isNumber(item)) {
                Util_1$f.Util.warn('"' + attr + '" attribute has non numeric element ' + item + ". Make sure that all elements are numbers.");
              }
            });
          }
          return val;
        };
      }
    }
    Validators.getNumberArrayValidator = getNumberArrayValidator;
    function getBooleanValidator() {
      if (Global_1$p.Konva.isUnminified) {
        return function(val, attr) {
          var isBool = val === true || val === false;
          if (!isBool) {
            Util_1$f.Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a boolean.');
          }
          return val;
        };
      }
    }
    Validators.getBooleanValidator = getBooleanValidator;
    function getComponentValidator(components) {
      if (Global_1$p.Konva.isUnminified) {
        return function(val, attr) {
          if (val === void 0 || val === null) {
            return val;
          }
          if (!Util_1$f.Util.isObject(val)) {
            Util_1$f.Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be an object with properties ' + components);
          }
          return val;
        };
      }
    }
    Validators.getComponentValidator = getComponentValidator;
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Factory = void 0;
      const Util_12 = Util;
      const Validators_12 = Validators;
      var GET = "get", SET2 = "set";
      exports2.Factory = {
        addGetterSetter(constructor, attr, def2, validator, after) {
          exports2.Factory.addGetter(constructor, attr, def2);
          exports2.Factory.addSetter(constructor, attr, validator, after);
          exports2.Factory.addOverloadedGetterSetter(constructor, attr);
        },
        addGetter(constructor, attr, def2) {
          var method = GET + Util_12.Util._capitalize(attr);
          constructor.prototype[method] = constructor.prototype[method] || function() {
            var val = this.attrs[attr];
            return val === void 0 ? def2 : val;
          };
        },
        addSetter(constructor, attr, validator, after) {
          var method = SET2 + Util_12.Util._capitalize(attr);
          if (!constructor.prototype[method]) {
            exports2.Factory.overWriteSetter(constructor, attr, validator, after);
          }
        },
        overWriteSetter(constructor, attr, validator, after) {
          var method = SET2 + Util_12.Util._capitalize(attr);
          constructor.prototype[method] = function(val) {
            if (validator && val !== void 0 && val !== null) {
              val = validator.call(this, val, attr);
            }
            this._setAttr(attr, val);
            if (after) {
              after.call(this);
            }
            return this;
          };
        },
        addComponentsGetterSetter(constructor, attr, components, validator, after) {
          var len = components.length, capitalize2 = Util_12.Util._capitalize, getter = GET + capitalize2(attr), setter = SET2 + capitalize2(attr), n, component;
          constructor.prototype[getter] = function() {
            var ret = {};
            for (n = 0; n < len; n++) {
              component = components[n];
              ret[component] = this.getAttr(attr + capitalize2(component));
            }
            return ret;
          };
          var basicValidator = (0, Validators_12.getComponentValidator)(components);
          constructor.prototype[setter] = function(val) {
            var oldVal = this.attrs[attr], key;
            if (validator) {
              val = validator.call(this, val);
            }
            if (basicValidator) {
              basicValidator.call(this, val, attr);
            }
            for (key in val) {
              if (!val.hasOwnProperty(key)) {
                continue;
              }
              this._setAttr(attr + capitalize2(key), val[key]);
            }
            if (!val) {
              components.forEach((component2) => {
                this._setAttr(attr + capitalize2(component2), void 0);
              });
            }
            this._fireChangeEvent(attr, oldVal, val);
            if (after) {
              after.call(this);
            }
            return this;
          };
          exports2.Factory.addOverloadedGetterSetter(constructor, attr);
        },
        addOverloadedGetterSetter(constructor, attr) {
          var capitalizedAttr = Util_12.Util._capitalize(attr), setter = SET2 + capitalizedAttr, getter = GET + capitalizedAttr;
          constructor.prototype[attr] = function() {
            if (arguments.length) {
              this[setter](arguments[0]);
              return this;
            }
            return this[getter]();
          };
        },
        addDeprecatedGetterSetter(constructor, attr, def2, validator) {
          Util_12.Util.error("Adding deprecated " + attr);
          var method = GET + Util_12.Util._capitalize(attr);
          var message = attr + " property is deprecated and will be removed soon. Look at Konva change log for more information.";
          constructor.prototype[method] = function() {
            Util_12.Util.error(message);
            var val = this.attrs[attr];
            return val === void 0 ? def2 : val;
          };
          exports2.Factory.addSetter(constructor, attr, validator, function() {
            Util_12.Util.error(message);
          });
          exports2.Factory.addOverloadedGetterSetter(constructor, attr);
        },
        backCompat(constructor, methods) {
          Util_12.Util.each(methods, function(oldMethodName, newMethodName) {
            var method = constructor.prototype[newMethodName];
            var oldGetter = GET + Util_12.Util._capitalize(oldMethodName);
            var oldSetter = SET2 + Util_12.Util._capitalize(oldMethodName);
            function deprecated2() {
              method.apply(this, arguments);
              Util_12.Util.error('"' + oldMethodName + '" method is deprecated and will be removed soon. Use ""' + newMethodName + '" instead.');
            }
            constructor.prototype[oldMethodName] = deprecated2;
            constructor.prototype[oldGetter] = deprecated2;
            constructor.prototype[oldSetter] = deprecated2;
          });
        },
        afterSetFilter() {
          this._filterUpToDate = false;
        }
      };
    })(Factory);
    var Canvas$1 = {};
    var Context$1 = {};
    Object.defineProperty(Context$1, "__esModule", { value: true });
    Context$1.HitContext = Context$1.SceneContext = Context$1.Context = void 0;
    const Util_1$e = Util;
    const Global_1$o = Global;
    function simplifyArray(arr) {
      var retArr = [], len = arr.length, util2 = Util_1$e.Util, n, val;
      for (n = 0; n < len; n++) {
        val = arr[n];
        if (util2._isNumber(val)) {
          val = Math.round(val * 1e3) / 1e3;
        } else if (!util2._isString(val)) {
          val = val + "";
        }
        retArr.push(val);
      }
      return retArr;
    }
    var COMMA = ",", OPEN_PAREN = "(", CLOSE_PAREN = ")", OPEN_PAREN_BRACKET = "([", CLOSE_BRACKET_PAREN = "])", SEMICOLON = ";", DOUBLE_PAREN = "()", EQUALS = "=", CONTEXT_METHODS = [
      "arc",
      "arcTo",
      "beginPath",
      "bezierCurveTo",
      "clearRect",
      "clip",
      "closePath",
      "createLinearGradient",
      "createPattern",
      "createRadialGradient",
      "drawImage",
      "ellipse",
      "fill",
      "fillText",
      "getImageData",
      "createImageData",
      "lineTo",
      "moveTo",
      "putImageData",
      "quadraticCurveTo",
      "rect",
      "roundRect",
      "restore",
      "rotate",
      "save",
      "scale",
      "setLineDash",
      "setTransform",
      "stroke",
      "strokeText",
      "transform",
      "translate"
    ];
    var CONTEXT_PROPERTIES = [
      "fillStyle",
      "strokeStyle",
      "shadowColor",
      "shadowBlur",
      "shadowOffsetX",
      "shadowOffsetY",
      "letterSpacing",
      "lineCap",
      "lineDashOffset",
      "lineJoin",
      "lineWidth",
      "miterLimit",
      "direction",
      "font",
      "textAlign",
      "textBaseline",
      "globalAlpha",
      "globalCompositeOperation",
      "imageSmoothingEnabled"
    ];
    const traceArrMax = 100;
    class Context {
      constructor(canvas) {
        this.canvas = canvas;
        if (Global_1$o.Konva.enableTrace) {
          this.traceArr = [];
          this._enableTrace();
        }
      }
      fillShape(shape) {
        if (shape.fillEnabled()) {
          this._fill(shape);
        }
      }
      _fill(shape) {
      }
      strokeShape(shape) {
        if (shape.hasStroke()) {
          this._stroke(shape);
        }
      }
      _stroke(shape) {
      }
      fillStrokeShape(shape) {
        if (shape.attrs.fillAfterStrokeEnabled) {
          this.strokeShape(shape);
          this.fillShape(shape);
        } else {
          this.fillShape(shape);
          this.strokeShape(shape);
        }
      }
      getTrace(relaxed, rounded) {
        var traceArr = this.traceArr, len = traceArr.length, str2 = "", n, trace, method, args;
        for (n = 0; n < len; n++) {
          trace = traceArr[n];
          method = trace.method;
          if (method) {
            args = trace.args;
            str2 += method;
            if (relaxed) {
              str2 += DOUBLE_PAREN;
            } else {
              if (Util_1$e.Util._isArray(args[0])) {
                str2 += OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;
              } else {
                if (rounded) {
                  args = args.map((a) => typeof a === "number" ? Math.floor(a) : a);
                }
                str2 += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;
              }
            }
          } else {
            str2 += trace.property;
            if (!relaxed) {
              str2 += EQUALS + trace.val;
            }
          }
          str2 += SEMICOLON;
        }
        return str2;
      }
      clearTrace() {
        this.traceArr = [];
      }
      _trace(str2) {
        var traceArr = this.traceArr, len;
        traceArr.push(str2);
        len = traceArr.length;
        if (len >= traceArrMax) {
          traceArr.shift();
        }
      }
      reset() {
        var pixelRatio = this.getCanvas().getPixelRatio();
        this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);
      }
      getCanvas() {
        return this.canvas;
      }
      clear(bounds) {
        var canvas = this.getCanvas();
        if (bounds) {
          this.clearRect(bounds.x || 0, bounds.y || 0, bounds.width || 0, bounds.height || 0);
        } else {
          this.clearRect(0, 0, canvas.getWidth() / canvas.pixelRatio, canvas.getHeight() / canvas.pixelRatio);
        }
      }
      _applyLineCap(shape) {
        const lineCap = shape.attrs.lineCap;
        if (lineCap) {
          this.setAttr("lineCap", lineCap);
        }
      }
      _applyOpacity(shape) {
        var absOpacity = shape.getAbsoluteOpacity();
        if (absOpacity !== 1) {
          this.setAttr("globalAlpha", absOpacity);
        }
      }
      _applyLineJoin(shape) {
        const lineJoin = shape.attrs.lineJoin;
        if (lineJoin) {
          this.setAttr("lineJoin", lineJoin);
        }
      }
      setAttr(attr, val) {
        this._context[attr] = val;
      }
      arc(x2, y, radius, startAngle, endAngle, counterClockwise) {
        this._context.arc(x2, y, radius, startAngle, endAngle, counterClockwise);
      }
      arcTo(x1, y1, x2, y2, radius) {
        this._context.arcTo(x1, y1, x2, y2, radius);
      }
      beginPath() {
        this._context.beginPath();
      }
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y) {
        this._context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y);
      }
      clearRect(x2, y, width, height) {
        this._context.clearRect(x2, y, width, height);
      }
      clip(...args) {
        this._context.clip.apply(this._context, args);
      }
      closePath() {
        this._context.closePath();
      }
      createImageData(width, height) {
        var a = arguments;
        if (a.length === 2) {
          return this._context.createImageData(width, height);
        } else if (a.length === 1) {
          return this._context.createImageData(width);
        }
      }
      createLinearGradient(x0, y0, x1, y1) {
        return this._context.createLinearGradient(x0, y0, x1, y1);
      }
      createPattern(image2, repetition) {
        return this._context.createPattern(image2, repetition);
      }
      createRadialGradient(x0, y0, r0, x1, y1, r1) {
        return this._context.createRadialGradient(x0, y0, r0, x1, y1, r1);
      }
      drawImage(image2, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
        var a = arguments, _context = this._context;
        if (a.length === 3) {
          _context.drawImage(image2, sx, sy);
        } else if (a.length === 5) {
          _context.drawImage(image2, sx, sy, sWidth, sHeight);
        } else if (a.length === 9) {
          _context.drawImage(image2, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
        }
      }
      ellipse(x2, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise) {
        this._context.ellipse(x2, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise);
      }
      isPointInPath(x2, y, path, fillRule) {
        if (path) {
          return this._context.isPointInPath(path, x2, y, fillRule);
        }
        return this._context.isPointInPath(x2, y, fillRule);
      }
      fill(...args) {
        this._context.fill.apply(this._context, args);
      }
      fillRect(x2, y, width, height) {
        this._context.fillRect(x2, y, width, height);
      }
      strokeRect(x2, y, width, height) {
        this._context.strokeRect(x2, y, width, height);
      }
      fillText(text2, x2, y, maxWidth) {
        if (maxWidth) {
          this._context.fillText(text2, x2, y, maxWidth);
        } else {
          this._context.fillText(text2, x2, y);
        }
      }
      measureText(text2) {
        return this._context.measureText(text2);
      }
      getImageData(sx, sy, sw, sh) {
        return this._context.getImageData(sx, sy, sw, sh);
      }
      lineTo(x2, y) {
        this._context.lineTo(x2, y);
      }
      moveTo(x2, y) {
        this._context.moveTo(x2, y);
      }
      rect(x2, y, width, height) {
        this._context.rect(x2, y, width, height);
      }
      roundRect(x2, y, width, height, radii) {
        this._context.roundRect(x2, y, width, height, radii);
      }
      putImageData(imageData, dx, dy) {
        this._context.putImageData(imageData, dx, dy);
      }
      quadraticCurveTo(cpx, cpy, x2, y) {
        this._context.quadraticCurveTo(cpx, cpy, x2, y);
      }
      restore() {
        this._context.restore();
      }
      rotate(angle2) {
        this._context.rotate(angle2);
      }
      save() {
        this._context.save();
      }
      scale(x2, y) {
        this._context.scale(x2, y);
      }
      setLineDash(segments) {
        if (this._context.setLineDash) {
          this._context.setLineDash(segments);
        } else if ("mozDash" in this._context) {
          this._context["mozDash"] = segments;
        } else if ("webkitLineDash" in this._context) {
          this._context["webkitLineDash"] = segments;
        }
      }
      getLineDash() {
        return this._context.getLineDash();
      }
      setTransform(a, b, c, d, e, f) {
        this._context.setTransform(a, b, c, d, e, f);
      }
      stroke(path2d) {
        if (path2d) {
          this._context.stroke(path2d);
        } else {
          this._context.stroke();
        }
      }
      strokeText(text2, x2, y, maxWidth) {
        this._context.strokeText(text2, x2, y, maxWidth);
      }
      transform(a, b, c, d, e, f) {
        this._context.transform(a, b, c, d, e, f);
      }
      translate(x2, y) {
        this._context.translate(x2, y);
      }
      _enableTrace() {
        var that = this, len = CONTEXT_METHODS.length, origSetter = this.setAttr, n, args;
        var func = function(methodName) {
          var origMethod = that[methodName], ret;
          that[methodName] = function() {
            args = simplifyArray(Array.prototype.slice.call(arguments, 0));
            ret = origMethod.apply(that, arguments);
            that._trace({
              method: methodName,
              args
            });
            return ret;
          };
        };
        for (n = 0; n < len; n++) {
          func(CONTEXT_METHODS[n]);
        }
        that.setAttr = function() {
          origSetter.apply(that, arguments);
          var prop2 = arguments[0];
          var val = arguments[1];
          if (prop2 === "shadowOffsetX" || prop2 === "shadowOffsetY" || prop2 === "shadowBlur") {
            val = val / this.canvas.getPixelRatio();
          }
          that._trace({
            property: prop2,
            val
          });
        };
      }
      _applyGlobalCompositeOperation(node) {
        const op = node.attrs.globalCompositeOperation;
        var def2 = !op || op === "source-over";
        if (!def2) {
          this.setAttr("globalCompositeOperation", op);
        }
      }
    }
    Context$1.Context = Context;
    CONTEXT_PROPERTIES.forEach(function(prop2) {
      Object.defineProperty(Context.prototype, prop2, {
        get() {
          return this._context[prop2];
        },
        set(val) {
          this._context[prop2] = val;
        }
      });
    });
    class SceneContext extends Context {
      constructor(canvas, { willReadFrequently = false } = {}) {
        super(canvas);
        this._context = canvas._canvas.getContext("2d", {
          willReadFrequently
        });
      }
      _fillColor(shape) {
        var fill = shape.fill();
        this.setAttr("fillStyle", fill);
        shape._fillFunc(this);
      }
      _fillPattern(shape) {
        this.setAttr("fillStyle", shape._getFillPattern());
        shape._fillFunc(this);
      }
      _fillLinearGradient(shape) {
        var grd = shape._getLinearGradient();
        if (grd) {
          this.setAttr("fillStyle", grd);
          shape._fillFunc(this);
        }
      }
      _fillRadialGradient(shape) {
        const grd = shape._getRadialGradient();
        if (grd) {
          this.setAttr("fillStyle", grd);
          shape._fillFunc(this);
        }
      }
      _fill(shape) {
        const hasColor = shape.fill(), fillPriority = shape.getFillPriority();
        if (hasColor && fillPriority === "color") {
          this._fillColor(shape);
          return;
        }
        const hasPattern = shape.getFillPatternImage();
        if (hasPattern && fillPriority === "pattern") {
          this._fillPattern(shape);
          return;
        }
        const hasLinearGradient = shape.getFillLinearGradientColorStops();
        if (hasLinearGradient && fillPriority === "linear-gradient") {
          this._fillLinearGradient(shape);
          return;
        }
        const hasRadialGradient = shape.getFillRadialGradientColorStops();
        if (hasRadialGradient && fillPriority === "radial-gradient") {
          this._fillRadialGradient(shape);
          return;
        }
        if (hasColor) {
          this._fillColor(shape);
        } else if (hasPattern) {
          this._fillPattern(shape);
        } else if (hasLinearGradient) {
          this._fillLinearGradient(shape);
        } else if (hasRadialGradient) {
          this._fillRadialGradient(shape);
        }
      }
      _strokeLinearGradient(shape) {
        const start = shape.getStrokeLinearGradientStartPoint(), end = shape.getStrokeLinearGradientEndPoint(), colorStops = shape.getStrokeLinearGradientColorStops(), grd = this.createLinearGradient(start.x, start.y, end.x, end.y);
        if (colorStops) {
          for (var n = 0; n < colorStops.length; n += 2) {
            grd.addColorStop(colorStops[n], colorStops[n + 1]);
          }
          this.setAttr("strokeStyle", grd);
        }
      }
      _stroke(shape) {
        var dash2 = shape.dash(), strokeScaleEnabled = shape.getStrokeScaleEnabled();
        if (shape.hasStroke()) {
          if (!strokeScaleEnabled) {
            this.save();
            var pixelRatio = this.getCanvas().getPixelRatio();
            this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
          }
          this._applyLineCap(shape);
          if (dash2 && shape.dashEnabled()) {
            this.setLineDash(dash2);
            this.setAttr("lineDashOffset", shape.dashOffset());
          }
          this.setAttr("lineWidth", shape.strokeWidth());
          if (!shape.getShadowForStrokeEnabled()) {
            this.setAttr("shadowColor", "rgba(0,0,0,0)");
          }
          var hasLinearGradient = shape.getStrokeLinearGradientColorStops();
          if (hasLinearGradient) {
            this._strokeLinearGradient(shape);
          } else {
            this.setAttr("strokeStyle", shape.stroke());
          }
          shape._strokeFunc(this);
          if (!strokeScaleEnabled) {
            this.restore();
          }
        }
      }
      _applyShadow(shape) {
        var _a2, _b, _c;
        var color = (_a2 = shape.getShadowRGBA()) !== null && _a2 !== void 0 ? _a2 : "black", blur = (_b = shape.getShadowBlur()) !== null && _b !== void 0 ? _b : 5, offset = (_c = shape.getShadowOffset()) !== null && _c !== void 0 ? _c : {
          x: 0,
          y: 0
        }, scale = shape.getAbsoluteScale(), ratio2 = this.canvas.getPixelRatio(), scaleX = scale.x * ratio2, scaleY = scale.y * ratio2;
        this.setAttr("shadowColor", color);
        this.setAttr("shadowBlur", blur * Math.min(Math.abs(scaleX), Math.abs(scaleY)));
        this.setAttr("shadowOffsetX", offset.x * scaleX);
        this.setAttr("shadowOffsetY", offset.y * scaleY);
      }
    }
    Context$1.SceneContext = SceneContext;
    class HitContext extends Context {
      constructor(canvas) {
        super(canvas);
        this._context = canvas._canvas.getContext("2d", {
          willReadFrequently: true
        });
      }
      _fill(shape) {
        this.save();
        this.setAttr("fillStyle", shape.colorKey);
        shape._fillFuncHit(this);
        this.restore();
      }
      strokeShape(shape) {
        if (shape.hasHitStroke()) {
          this._stroke(shape);
        }
      }
      _stroke(shape) {
        if (shape.hasHitStroke()) {
          const strokeScaleEnabled = shape.getStrokeScaleEnabled();
          if (!strokeScaleEnabled) {
            this.save();
            var pixelRatio = this.getCanvas().getPixelRatio();
            this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
          }
          this._applyLineCap(shape);
          var hitStrokeWidth = shape.hitStrokeWidth();
          var strokeWidth = hitStrokeWidth === "auto" ? shape.strokeWidth() : hitStrokeWidth;
          this.setAttr("lineWidth", strokeWidth);
          this.setAttr("strokeStyle", shape.colorKey);
          shape._strokeFuncHit(this);
          if (!strokeScaleEnabled) {
            this.restore();
          }
        }
      }
    }
    Context$1.HitContext = HitContext;
    Object.defineProperty(Canvas$1, "__esModule", { value: true });
    Canvas$1.HitCanvas = Canvas$1.SceneCanvas = Canvas$1.Canvas = void 0;
    const Util_1$d = Util;
    const Context_1 = Context$1;
    const Global_1$n = Global;
    const Factory_1$z = Factory;
    const Validators_1$y = Validators;
    var _pixelRatio;
    function getDevicePixelRatio() {
      if (_pixelRatio) {
        return _pixelRatio;
      }
      var canvas = Util_1$d.Util.createCanvasElement();
      var context = canvas.getContext("2d");
      _pixelRatio = function() {
        var devicePixelRatio2 = Global_1$n.Konva._global.devicePixelRatio || 1, backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
        return devicePixelRatio2 / backingStoreRatio;
      }();
      Util_1$d.Util.releaseCanvas(canvas);
      return _pixelRatio;
    }
    class Canvas {
      constructor(config2) {
        this.pixelRatio = 1;
        this.width = 0;
        this.height = 0;
        this.isCache = false;
        var conf = config2 || {};
        var pixelRatio = conf.pixelRatio || Global_1$n.Konva.pixelRatio || getDevicePixelRatio();
        this.pixelRatio = pixelRatio;
        this._canvas = Util_1$d.Util.createCanvasElement();
        this._canvas.style.padding = "0";
        this._canvas.style.margin = "0";
        this._canvas.style.border = "0";
        this._canvas.style.background = "transparent";
        this._canvas.style.position = "absolute";
        this._canvas.style.top = "0";
        this._canvas.style.left = "0";
      }
      getContext() {
        return this.context;
      }
      getPixelRatio() {
        return this.pixelRatio;
      }
      setPixelRatio(pixelRatio) {
        var previousRatio = this.pixelRatio;
        this.pixelRatio = pixelRatio;
        this.setSize(this.getWidth() / previousRatio, this.getHeight() / previousRatio);
      }
      setWidth(width) {
        this.width = this._canvas.width = width * this.pixelRatio;
        this._canvas.style.width = width + "px";
        var pixelRatio = this.pixelRatio, _context = this.getContext()._context;
        _context.scale(pixelRatio, pixelRatio);
      }
      setHeight(height) {
        this.height = this._canvas.height = height * this.pixelRatio;
        this._canvas.style.height = height + "px";
        var pixelRatio = this.pixelRatio, _context = this.getContext()._context;
        _context.scale(pixelRatio, pixelRatio);
      }
      getWidth() {
        return this.width;
      }
      getHeight() {
        return this.height;
      }
      setSize(width, height) {
        this.setWidth(width || 0);
        this.setHeight(height || 0);
      }
      toDataURL(mimeType, quality) {
        try {
          return this._canvas.toDataURL(mimeType, quality);
        } catch (e) {
          try {
            return this._canvas.toDataURL();
          } catch (err) {
            Util_1$d.Util.error("Unable to get data URL. " + err.message + " For more info read https://konvajs.org/docs/posts/Tainted_Canvas.html.");
            return "";
          }
        }
      }
    }
    Canvas$1.Canvas = Canvas;
    Factory_1$z.Factory.addGetterSetter(Canvas, "pixelRatio", void 0, (0, Validators_1$y.getNumberValidator)());
    class SceneCanvas extends Canvas {
      constructor(config2 = { width: 0, height: 0, willReadFrequently: false }) {
        super(config2);
        this.context = new Context_1.SceneContext(this, {
          willReadFrequently: config2.willReadFrequently
        });
        this.setSize(config2.width, config2.height);
      }
    }
    Canvas$1.SceneCanvas = SceneCanvas;
    class HitCanvas extends Canvas {
      constructor(config2 = { width: 0, height: 0 }) {
        super(config2);
        this.hitCanvas = true;
        this.context = new Context_1.HitContext(this);
        this.setSize(config2.width, config2.height);
      }
    }
    Canvas$1.HitCanvas = HitCanvas;
    var DragAndDrop = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DD = void 0;
      const Global_12 = Global;
      const Util_12 = Util;
      exports2.DD = {
        get isDragging() {
          var flag = false;
          exports2.DD._dragElements.forEach((elem) => {
            if (elem.dragStatus === "dragging") {
              flag = true;
            }
          });
          return flag;
        },
        justDragged: false,
        get node() {
          var node;
          exports2.DD._dragElements.forEach((elem) => {
            node = elem.node;
          });
          return node;
        },
        _dragElements: /* @__PURE__ */ new Map(),
        _drag(evt) {
          const nodesToFireEvents = [];
          exports2.DD._dragElements.forEach((elem, key) => {
            const { node } = elem;
            const stage = node.getStage();
            stage.setPointersPositions(evt);
            if (elem.pointerId === void 0) {
              elem.pointerId = Util_12.Util._getFirstPointerId(evt);
            }
            const pos = stage._changedPointerPositions.find((pos2) => pos2.id === elem.pointerId);
            if (!pos) {
              return;
            }
            if (elem.dragStatus !== "dragging") {
              var dragDistance = node.dragDistance();
              var distance = Math.max(Math.abs(pos.x - elem.startPointerPos.x), Math.abs(pos.y - elem.startPointerPos.y));
              if (distance < dragDistance) {
                return;
              }
              node.startDrag({ evt });
              if (!node.isDragging()) {
                return;
              }
            }
            node._setDragPosition(evt, elem);
            nodesToFireEvents.push(node);
          });
          nodesToFireEvents.forEach((node) => {
            node.fire("dragmove", {
              type: "dragmove",
              target: node,
              evt
            }, true);
          });
        },
        _endDragBefore(evt) {
          const drawNodes = [];
          exports2.DD._dragElements.forEach((elem) => {
            const { node } = elem;
            const stage = node.getStage();
            if (evt) {
              stage.setPointersPositions(evt);
            }
            const pos = stage._changedPointerPositions.find((pos2) => pos2.id === elem.pointerId);
            if (!pos) {
              return;
            }
            if (elem.dragStatus === "dragging" || elem.dragStatus === "stopped") {
              exports2.DD.justDragged = true;
              Global_12.Konva._mouseListenClick = false;
              Global_12.Konva._touchListenClick = false;
              Global_12.Konva._pointerListenClick = false;
              elem.dragStatus = "stopped";
            }
            const drawNode = elem.node.getLayer() || elem.node instanceof Global_12.Konva["Stage"] && elem.node;
            if (drawNode && drawNodes.indexOf(drawNode) === -1) {
              drawNodes.push(drawNode);
            }
          });
          drawNodes.forEach((drawNode) => {
            drawNode.draw();
          });
        },
        _endDragAfter(evt) {
          exports2.DD._dragElements.forEach((elem, key) => {
            if (elem.dragStatus === "stopped") {
              elem.node.fire("dragend", {
                type: "dragend",
                target: elem.node,
                evt
              }, true);
            }
            if (elem.dragStatus !== "dragging") {
              exports2.DD._dragElements.delete(key);
            }
          });
        }
      };
      if (Global_12.Konva.isBrowser) {
        window.addEventListener("mouseup", exports2.DD._endDragBefore, true);
        window.addEventListener("touchend", exports2.DD._endDragBefore, true);
        window.addEventListener("mousemove", exports2.DD._drag);
        window.addEventListener("touchmove", exports2.DD._drag);
        window.addEventListener("mouseup", exports2.DD._endDragAfter, false);
        window.addEventListener("touchend", exports2.DD._endDragAfter, false);
      }
    })(DragAndDrop);
    Object.defineProperty(Node$2, "__esModule", { value: true });
    Node$2.Node = void 0;
    const Util_1$c = Util;
    const Factory_1$y = Factory;
    const Canvas_1$1 = Canvas$1;
    const Global_1$m = Global;
    const DragAndDrop_1 = DragAndDrop;
    const Validators_1$x = Validators;
    var ABSOLUTE_OPACITY = "absoluteOpacity", ALL_LISTENERS = "allEventListeners", ABSOLUTE_TRANSFORM = "absoluteTransform", ABSOLUTE_SCALE = "absoluteScale", CANVAS = "canvas", CHANGE = "Change", CHILDREN = "children", KONVA = "konva", LISTENING = "listening", MOUSEENTER = "mouseenter", MOUSELEAVE = "mouseleave", SET = "set", SHAPE = "Shape", SPACE$1 = " ", STAGE = "stage", TRANSFORM = "transform", UPPER_STAGE = "Stage", VISIBLE = "visible", TRANSFORM_CHANGE_STR$1 = [
      "xChange.konva",
      "yChange.konva",
      "scaleXChange.konva",
      "scaleYChange.konva",
      "skewXChange.konva",
      "skewYChange.konva",
      "rotationChange.konva",
      "offsetXChange.konva",
      "offsetYChange.konva",
      "transformsEnabledChange.konva"
    ].join(SPACE$1);
    let idCounter = 1;
    let Node$1 = class Node2 {
      constructor(config2) {
        this._id = idCounter++;
        this.eventListeners = {};
        this.attrs = {};
        this.index = 0;
        this._allEventListeners = null;
        this.parent = null;
        this._cache = /* @__PURE__ */ new Map();
        this._attachedDepsListeners = /* @__PURE__ */ new Map();
        this._lastPos = null;
        this._batchingTransformChange = false;
        this._needClearTransformCache = false;
        this._filterUpToDate = false;
        this._isUnderCache = false;
        this._dragEventId = null;
        this._shouldFireChangeEvents = false;
        this.setAttrs(config2);
        this._shouldFireChangeEvents = true;
      }
      hasChildren() {
        return false;
      }
      _clearCache(attr) {
        if ((attr === TRANSFORM || attr === ABSOLUTE_TRANSFORM) && this._cache.get(attr)) {
          this._cache.get(attr).dirty = true;
        } else if (attr) {
          this._cache.delete(attr);
        } else {
          this._cache.clear();
        }
      }
      _getCache(attr, privateGetter) {
        var cache2 = this._cache.get(attr);
        var isTransform = attr === TRANSFORM || attr === ABSOLUTE_TRANSFORM;
        var invalid = cache2 === void 0 || isTransform && cache2.dirty === true;
        if (invalid) {
          cache2 = privateGetter.call(this);
          this._cache.set(attr, cache2);
        }
        return cache2;
      }
      _calculate(name, deps, getter) {
        if (!this._attachedDepsListeners.get(name)) {
          const depsString = deps.map((dep) => dep + "Change.konva").join(SPACE$1);
          this.on(depsString, () => {
            this._clearCache(name);
          });
          this._attachedDepsListeners.set(name, true);
        }
        return this._getCache(name, getter);
      }
      _getCanvasCache() {
        return this._cache.get(CANVAS);
      }
      _clearSelfAndDescendantCache(attr) {
        this._clearCache(attr);
        if (attr === ABSOLUTE_TRANSFORM) {
          this.fire("absoluteTransformChange");
        }
      }
      clearCache() {
        if (this._cache.has(CANVAS)) {
          const { scene, filter, hit } = this._cache.get(CANVAS);
          Util_1$c.Util.releaseCanvas(scene, filter, hit);
          this._cache.delete(CANVAS);
        }
        this._clearSelfAndDescendantCache();
        this._requestDraw();
        return this;
      }
      cache(config2) {
        var conf = config2 || {};
        var rect2 = {};
        if (conf.x === void 0 || conf.y === void 0 || conf.width === void 0 || conf.height === void 0) {
          rect2 = this.getClientRect({
            skipTransform: true,
            relativeTo: this.getParent() || void 0
          });
        }
        var width = Math.ceil(conf.width || rect2.width), height = Math.ceil(conf.height || rect2.height), pixelRatio = conf.pixelRatio, x2 = conf.x === void 0 ? Math.floor(rect2.x) : conf.x, y = conf.y === void 0 ? Math.floor(rect2.y) : conf.y, offset = conf.offset || 0, drawBorder = conf.drawBorder || false, hitCanvasPixelRatio = conf.hitCanvasPixelRatio || 1;
        if (!width || !height) {
          Util_1$c.Util.error("Can not cache the node. Width or height of the node equals 0. Caching is skipped.");
          return;
        }
        const extraPaddingX = Math.abs(Math.round(rect2.x) - x2) > 0.5 ? 1 : 0;
        const extraPaddingY = Math.abs(Math.round(rect2.y) - y) > 0.5 ? 1 : 0;
        width += offset * 2 + extraPaddingX;
        height += offset * 2 + extraPaddingY;
        x2 -= offset;
        y -= offset;
        var cachedSceneCanvas = new Canvas_1$1.SceneCanvas({
          pixelRatio,
          width,
          height
        }), cachedFilterCanvas = new Canvas_1$1.SceneCanvas({
          pixelRatio,
          width: 0,
          height: 0,
          willReadFrequently: true
        }), cachedHitCanvas = new Canvas_1$1.HitCanvas({
          pixelRatio: hitCanvasPixelRatio,
          width,
          height
        }), sceneContext = cachedSceneCanvas.getContext(), hitContext = cachedHitCanvas.getContext();
        cachedHitCanvas.isCache = true;
        cachedSceneCanvas.isCache = true;
        this._cache.delete(CANVAS);
        this._filterUpToDate = false;
        if (conf.imageSmoothingEnabled === false) {
          cachedSceneCanvas.getContext()._context.imageSmoothingEnabled = false;
          cachedFilterCanvas.getContext()._context.imageSmoothingEnabled = false;
        }
        sceneContext.save();
        hitContext.save();
        sceneContext.translate(-x2, -y);
        hitContext.translate(-x2, -y);
        this._isUnderCache = true;
        this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
        this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);
        this.drawScene(cachedSceneCanvas, this);
        this.drawHit(cachedHitCanvas, this);
        this._isUnderCache = false;
        sceneContext.restore();
        hitContext.restore();
        if (drawBorder) {
          sceneContext.save();
          sceneContext.beginPath();
          sceneContext.rect(0, 0, width, height);
          sceneContext.closePath();
          sceneContext.setAttr("strokeStyle", "red");
          sceneContext.setAttr("lineWidth", 5);
          sceneContext.stroke();
          sceneContext.restore();
        }
        this._cache.set(CANVAS, {
          scene: cachedSceneCanvas,
          filter: cachedFilterCanvas,
          hit: cachedHitCanvas,
          x: x2,
          y
        });
        this._requestDraw();
        return this;
      }
      isCached() {
        return this._cache.has(CANVAS);
      }
      getClientRect(config2) {
        throw new Error('abstract "getClientRect" method call');
      }
      _transformedRect(rect2, top2) {
        var points = [
          { x: rect2.x, y: rect2.y },
          { x: rect2.x + rect2.width, y: rect2.y },
          { x: rect2.x + rect2.width, y: rect2.y + rect2.height },
          { x: rect2.x, y: rect2.y + rect2.height }
        ];
        var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        var trans = this.getAbsoluteTransform(top2);
        points.forEach(function(point) {
          var transformed = trans.point(point);
          if (minX === void 0) {
            minX = maxX = transformed.x;
            minY = maxY = transformed.y;
          }
          minX = Math.min(minX, transformed.x);
          minY = Math.min(minY, transformed.y);
          maxX = Math.max(maxX, transformed.x);
          maxY = Math.max(maxY, transformed.y);
        });
        return {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        };
      }
      _drawCachedSceneCanvas(context) {
        context.save();
        context._applyOpacity(this);
        context._applyGlobalCompositeOperation(this);
        const canvasCache = this._getCanvasCache();
        context.translate(canvasCache.x, canvasCache.y);
        var cacheCanvas = this._getCachedSceneCanvas();
        var ratio2 = cacheCanvas.pixelRatio;
        context.drawImage(cacheCanvas._canvas, 0, 0, cacheCanvas.width / ratio2, cacheCanvas.height / ratio2);
        context.restore();
      }
      _drawCachedHitCanvas(context) {
        var canvasCache = this._getCanvasCache(), hitCanvas = canvasCache.hit;
        context.save();
        context.translate(canvasCache.x, canvasCache.y);
        context.drawImage(hitCanvas._canvas, 0, 0, hitCanvas.width / hitCanvas.pixelRatio, hitCanvas.height / hitCanvas.pixelRatio);
        context.restore();
      }
      _getCachedSceneCanvas() {
        var filters = this.filters(), cachedCanvas = this._getCanvasCache(), sceneCanvas = cachedCanvas.scene, filterCanvas = cachedCanvas.filter, filterContext = filterCanvas.getContext(), len, imageData, n, filter;
        if (filters) {
          if (!this._filterUpToDate) {
            var ratio2 = sceneCanvas.pixelRatio;
            filterCanvas.setSize(sceneCanvas.width / sceneCanvas.pixelRatio, sceneCanvas.height / sceneCanvas.pixelRatio);
            try {
              len = filters.length;
              filterContext.clear();
              filterContext.drawImage(sceneCanvas._canvas, 0, 0, sceneCanvas.getWidth() / ratio2, sceneCanvas.getHeight() / ratio2);
              imageData = filterContext.getImageData(0, 0, filterCanvas.getWidth(), filterCanvas.getHeight());
              for (n = 0; n < len; n++) {
                filter = filters[n];
                if (typeof filter !== "function") {
                  Util_1$c.Util.error("Filter should be type of function, but got " + typeof filter + " instead. Please check correct filters");
                  continue;
                }
                filter.call(this, imageData);
                filterContext.putImageData(imageData, 0, 0);
              }
            } catch (e) {
              Util_1$c.Util.error("Unable to apply filter. " + e.message + " This post my help you https://konvajs.org/docs/posts/Tainted_Canvas.html.");
            }
            this._filterUpToDate = true;
          }
          return filterCanvas;
        }
        return sceneCanvas;
      }
      on(evtStr, handler) {
        this._cache && this._cache.delete(ALL_LISTENERS);
        if (arguments.length === 3) {
          return this._delegate.apply(this, arguments);
        }
        var events = evtStr.split(SPACE$1), len = events.length, n, event, parts, baseEvent, name;
        for (n = 0; n < len; n++) {
          event = events[n];
          parts = event.split(".");
          baseEvent = parts[0];
          name = parts[1] || "";
          if (!this.eventListeners[baseEvent]) {
            this.eventListeners[baseEvent] = [];
          }
          this.eventListeners[baseEvent].push({
            name,
            handler
          });
        }
        return this;
      }
      off(evtStr, callback) {
        var events = (evtStr || "").split(SPACE$1), len = events.length, n, t, event, parts, baseEvent, name;
        this._cache && this._cache.delete(ALL_LISTENERS);
        if (!evtStr) {
          for (t in this.eventListeners) {
            this._off(t);
          }
        }
        for (n = 0; n < len; n++) {
          event = events[n];
          parts = event.split(".");
          baseEvent = parts[0];
          name = parts[1];
          if (baseEvent) {
            if (this.eventListeners[baseEvent]) {
              this._off(baseEvent, name, callback);
            }
          } else {
            for (t in this.eventListeners) {
              this._off(t, name, callback);
            }
          }
        }
        return this;
      }
      dispatchEvent(evt) {
        var e = {
          target: this,
          type: evt.type,
          evt
        };
        this.fire(evt.type, e);
        return this;
      }
      addEventListener(type2, handler) {
        this.on(type2, function(evt) {
          handler.call(this, evt.evt);
        });
        return this;
      }
      removeEventListener(type2) {
        this.off(type2);
        return this;
      }
      _delegate(event, selector, handler) {
        var stopNode = this;
        this.on(event, function(evt) {
          var targets = evt.target.findAncestors(selector, true, stopNode);
          for (var i2 = 0; i2 < targets.length; i2++) {
            evt = Util_1$c.Util.cloneObject(evt);
            evt.currentTarget = targets[i2];
            handler.call(targets[i2], evt);
          }
        });
      }
      remove() {
        if (this.isDragging()) {
          this.stopDrag();
        }
        DragAndDrop_1.DD._dragElements.delete(this._id);
        this._remove();
        return this;
      }
      _clearCaches() {
        this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
        this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
        this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);
        this._clearSelfAndDescendantCache(STAGE);
        this._clearSelfAndDescendantCache(VISIBLE);
        this._clearSelfAndDescendantCache(LISTENING);
      }
      _remove() {
        this._clearCaches();
        var parent = this.getParent();
        if (parent && parent.children) {
          parent.children.splice(this.index, 1);
          parent._setChildrenIndices();
          this.parent = null;
        }
      }
      destroy() {
        this.remove();
        this.clearCache();
        return this;
      }
      getAttr(attr) {
        var method = "get" + Util_1$c.Util._capitalize(attr);
        if (Util_1$c.Util._isFunction(this[method])) {
          return this[method]();
        }
        return this.attrs[attr];
      }
      getAncestors() {
        var parent = this.getParent(), ancestors = [];
        while (parent) {
          ancestors.push(parent);
          parent = parent.getParent();
        }
        return ancestors;
      }
      getAttrs() {
        return this.attrs || {};
      }
      setAttrs(config2) {
        this._batchTransformChanges(() => {
          var key, method;
          if (!config2) {
            return this;
          }
          for (key in config2) {
            if (key === CHILDREN) {
              continue;
            }
            method = SET + Util_1$c.Util._capitalize(key);
            if (Util_1$c.Util._isFunction(this[method])) {
              this[method](config2[key]);
            } else {
              this._setAttr(key, config2[key]);
            }
          }
        });
        return this;
      }
      isListening() {
        return this._getCache(LISTENING, this._isListening);
      }
      _isListening(relativeTo) {
        const listening = this.listening();
        if (!listening) {
          return false;
        }
        const parent = this.getParent();
        if (parent && parent !== relativeTo && this !== relativeTo) {
          return parent._isListening(relativeTo);
        } else {
          return true;
        }
      }
      isVisible() {
        return this._getCache(VISIBLE, this._isVisible);
      }
      _isVisible(relativeTo) {
        const visible = this.visible();
        if (!visible) {
          return false;
        }
        const parent = this.getParent();
        if (parent && parent !== relativeTo && this !== relativeTo) {
          return parent._isVisible(relativeTo);
        } else {
          return true;
        }
      }
      shouldDrawHit(top2, skipDragCheck = false) {
        if (top2) {
          return this._isVisible(top2) && this._isListening(top2);
        }
        var layer = this.getLayer();
        var layerUnderDrag = false;
        DragAndDrop_1.DD._dragElements.forEach((elem) => {
          if (elem.dragStatus !== "dragging") {
            return;
          } else if (elem.node.nodeType === "Stage") {
            layerUnderDrag = true;
          } else if (elem.node.getLayer() === layer) {
            layerUnderDrag = true;
          }
        });
        var dragSkip = !skipDragCheck && !Global_1$m.Konva.hitOnDragEnabled && (layerUnderDrag || Global_1$m.Konva.isTransforming());
        return this.isListening() && this.isVisible() && !dragSkip;
      }
      show() {
        this.visible(true);
        return this;
      }
      hide() {
        this.visible(false);
        return this;
      }
      getZIndex() {
        return this.index || 0;
      }
      getAbsoluteZIndex() {
        var depth = this.getDepth(), that = this, index = 0, nodes, len, n, child;
        function addChildren(children) {
          nodes = [];
          len = children.length;
          for (n = 0; n < len; n++) {
            child = children[n];
            index++;
            if (child.nodeType !== SHAPE) {
              nodes = nodes.concat(child.getChildren().slice());
            }
            if (child._id === that._id) {
              n = len;
            }
          }
          if (nodes.length > 0 && nodes[0].getDepth() <= depth) {
            addChildren(nodes);
          }
        }
        const stage = this.getStage();
        if (that.nodeType !== UPPER_STAGE && stage) {
          addChildren(stage.getChildren());
        }
        return index;
      }
      getDepth() {
        var depth = 0, parent = this.parent;
        while (parent) {
          depth++;
          parent = parent.parent;
        }
        return depth;
      }
      _batchTransformChanges(func) {
        this._batchingTransformChange = true;
        func();
        this._batchingTransformChange = false;
        if (this._needClearTransformCache) {
          this._clearCache(TRANSFORM);
          this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
        }
        this._needClearTransformCache = false;
      }
      setPosition(pos) {
        this._batchTransformChanges(() => {
          this.x(pos.x);
          this.y(pos.y);
        });
        return this;
      }
      getPosition() {
        return {
          x: this.x(),
          y: this.y()
        };
      }
      getRelativePointerPosition() {
        const stage = this.getStage();
        if (!stage) {
          return null;
        }
        var pos = stage.getPointerPosition();
        if (!pos) {
          return null;
        }
        var transform2 = this.getAbsoluteTransform().copy();
        transform2.invert();
        return transform2.point(pos);
      }
      getAbsolutePosition(top2) {
        let haveCachedParent = false;
        let parent = this.parent;
        while (parent) {
          if (parent.isCached()) {
            haveCachedParent = true;
            break;
          }
          parent = parent.parent;
        }
        if (haveCachedParent && !top2) {
          top2 = true;
        }
        var absoluteMatrix = this.getAbsoluteTransform(top2).getMatrix(), absoluteTransform = new Util_1$c.Transform(), offset = this.offset();
        absoluteTransform.m = absoluteMatrix.slice();
        absoluteTransform.translate(offset.x, offset.y);
        return absoluteTransform.getTranslation();
      }
      setAbsolutePosition(pos) {
        const { x: x2, y, ...origTrans } = this._clearTransform();
        this.attrs.x = x2;
        this.attrs.y = y;
        this._clearCache(TRANSFORM);
        var it2 = this._getAbsoluteTransform().copy();
        it2.invert();
        it2.translate(pos.x, pos.y);
        pos = {
          x: this.attrs.x + it2.getTranslation().x,
          y: this.attrs.y + it2.getTranslation().y
        };
        this._setTransform(origTrans);
        this.setPosition({ x: pos.x, y: pos.y });
        this._clearCache(TRANSFORM);
        this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
        return this;
      }
      _setTransform(trans) {
        var key;
        for (key in trans) {
          this.attrs[key] = trans[key];
        }
      }
      _clearTransform() {
        var trans = {
          x: this.x(),
          y: this.y(),
          rotation: this.rotation(),
          scaleX: this.scaleX(),
          scaleY: this.scaleY(),
          offsetX: this.offsetX(),
          offsetY: this.offsetY(),
          skewX: this.skewX(),
          skewY: this.skewY()
        };
        this.attrs.x = 0;
        this.attrs.y = 0;
        this.attrs.rotation = 0;
        this.attrs.scaleX = 1;
        this.attrs.scaleY = 1;
        this.attrs.offsetX = 0;
        this.attrs.offsetY = 0;
        this.attrs.skewX = 0;
        this.attrs.skewY = 0;
        return trans;
      }
      move(change) {
        var changeX = change.x, changeY = change.y, x2 = this.x(), y = this.y();
        if (changeX !== void 0) {
          x2 += changeX;
        }
        if (changeY !== void 0) {
          y += changeY;
        }
        this.setPosition({ x: x2, y });
        return this;
      }
      _eachAncestorReverse(func, top2) {
        var family = [], parent = this.getParent(), len, n;
        if (top2 && top2._id === this._id) {
          return;
        }
        family.unshift(this);
        while (parent && (!top2 || parent._id !== top2._id)) {
          family.unshift(parent);
          parent = parent.parent;
        }
        len = family.length;
        for (n = 0; n < len; n++) {
          func(family[n]);
        }
      }
      rotate(theta2) {
        this.rotation(this.rotation() + theta2);
        return this;
      }
      moveToTop() {
        if (!this.parent) {
          Util_1$c.Util.warn("Node has no parent. moveToTop function is ignored.");
          return false;
        }
        var index = this.index, len = this.parent.getChildren().length;
        if (index < len - 1) {
          this.parent.children.splice(index, 1);
          this.parent.children.push(this);
          this.parent._setChildrenIndices();
          return true;
        }
        return false;
      }
      moveUp() {
        if (!this.parent) {
          Util_1$c.Util.warn("Node has no parent. moveUp function is ignored.");
          return false;
        }
        var index = this.index, len = this.parent.getChildren().length;
        if (index < len - 1) {
          this.parent.children.splice(index, 1);
          this.parent.children.splice(index + 1, 0, this);
          this.parent._setChildrenIndices();
          return true;
        }
        return false;
      }
      moveDown() {
        if (!this.parent) {
          Util_1$c.Util.warn("Node has no parent. moveDown function is ignored.");
          return false;
        }
        var index = this.index;
        if (index > 0) {
          this.parent.children.splice(index, 1);
          this.parent.children.splice(index - 1, 0, this);
          this.parent._setChildrenIndices();
          return true;
        }
        return false;
      }
      moveToBottom() {
        if (!this.parent) {
          Util_1$c.Util.warn("Node has no parent. moveToBottom function is ignored.");
          return false;
        }
        var index = this.index;
        if (index > 0) {
          this.parent.children.splice(index, 1);
          this.parent.children.unshift(this);
          this.parent._setChildrenIndices();
          return true;
        }
        return false;
      }
      setZIndex(zIndex) {
        if (!this.parent) {
          Util_1$c.Util.warn("Node has no parent. zIndex parameter is ignored.");
          return this;
        }
        if (zIndex < 0 || zIndex >= this.parent.children.length) {
          Util_1$c.Util.warn("Unexpected value " + zIndex + " for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to " + (this.parent.children.length - 1) + ".");
        }
        var index = this.index;
        this.parent.children.splice(index, 1);
        this.parent.children.splice(zIndex, 0, this);
        this.parent._setChildrenIndices();
        return this;
      }
      getAbsoluteOpacity() {
        return this._getCache(ABSOLUTE_OPACITY, this._getAbsoluteOpacity);
      }
      _getAbsoluteOpacity() {
        var absOpacity = this.opacity();
        var parent = this.getParent();
        if (parent && !parent._isUnderCache) {
          absOpacity *= parent.getAbsoluteOpacity();
        }
        return absOpacity;
      }
      moveTo(newContainer) {
        if (this.getParent() !== newContainer) {
          this._remove();
          newContainer.add(this);
        }
        return this;
      }
      toObject() {
        var attrs = this.getAttrs(), key, val, getter, defaultValue, nonPlainObject;
        const obj = {
          attrs: {},
          className: this.getClassName()
        };
        for (key in attrs) {
          val = attrs[key];
          nonPlainObject = Util_1$c.Util.isObject(val) && !Util_1$c.Util._isPlainObject(val) && !Util_1$c.Util._isArray(val);
          if (nonPlainObject) {
            continue;
          }
          getter = typeof this[key] === "function" && this[key];
          delete attrs[key];
          defaultValue = getter ? getter.call(this) : null;
          attrs[key] = val;
          if (defaultValue !== val) {
            obj.attrs[key] = val;
          }
        }
        return Util_1$c.Util._prepareToStringify(obj);
      }
      toJSON() {
        return JSON.stringify(this.toObject());
      }
      getParent() {
        return this.parent;
      }
      findAncestors(selector, includeSelf, stopNode) {
        var res = [];
        if (includeSelf && this._isMatch(selector)) {
          res.push(this);
        }
        var ancestor = this.parent;
        while (ancestor) {
          if (ancestor === stopNode) {
            return res;
          }
          if (ancestor._isMatch(selector)) {
            res.push(ancestor);
          }
          ancestor = ancestor.parent;
        }
        return res;
      }
      isAncestorOf(node) {
        return false;
      }
      findAncestor(selector, includeSelf, stopNode) {
        return this.findAncestors(selector, includeSelf, stopNode)[0];
      }
      _isMatch(selector) {
        if (!selector) {
          return false;
        }
        if (typeof selector === "function") {
          return selector(this);
        }
        var selectorArr = selector.replace(/ /g, "").split(","), len = selectorArr.length, n, sel;
        for (n = 0; n < len; n++) {
          sel = selectorArr[n];
          if (!Util_1$c.Util.isValidSelector(sel)) {
            Util_1$c.Util.warn('Selector "' + sel + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".');
            Util_1$c.Util.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".');
            Util_1$c.Util.warn("Konva is awesome, right?");
          }
          if (sel.charAt(0) === "#") {
            if (this.id() === sel.slice(1)) {
              return true;
            }
          } else if (sel.charAt(0) === ".") {
            if (this.hasName(sel.slice(1))) {
              return true;
            }
          } else if (this.className === sel || this.nodeType === sel) {
            return true;
          }
        }
        return false;
      }
      getLayer() {
        var parent = this.getParent();
        return parent ? parent.getLayer() : null;
      }
      getStage() {
        return this._getCache(STAGE, this._getStage);
      }
      _getStage() {
        var parent = this.getParent();
        if (parent) {
          return parent.getStage();
        } else {
          return null;
        }
      }
      fire(eventType, evt = {}, bubble) {
        evt.target = evt.target || this;
        if (bubble) {
          this._fireAndBubble(eventType, evt);
        } else {
          this._fire(eventType, evt);
        }
        return this;
      }
      getAbsoluteTransform(top2) {
        if (top2) {
          return this._getAbsoluteTransform(top2);
        } else {
          return this._getCache(ABSOLUTE_TRANSFORM, this._getAbsoluteTransform);
        }
      }
      _getAbsoluteTransform(top2) {
        var at;
        if (top2) {
          at = new Util_1$c.Transform();
          this._eachAncestorReverse(function(node) {
            var transformsEnabled2 = node.transformsEnabled();
            if (transformsEnabled2 === "all") {
              at.multiply(node.getTransform());
            } else if (transformsEnabled2 === "position") {
              at.translate(node.x() - node.offsetX(), node.y() - node.offsetY());
            }
          }, top2);
          return at;
        } else {
          at = this._cache.get(ABSOLUTE_TRANSFORM) || new Util_1$c.Transform();
          if (this.parent) {
            this.parent.getAbsoluteTransform().copyInto(at);
          } else {
            at.reset();
          }
          var transformsEnabled = this.transformsEnabled();
          if (transformsEnabled === "all") {
            at.multiply(this.getTransform());
          } else if (transformsEnabled === "position") {
            const x2 = this.attrs.x || 0;
            const y = this.attrs.y || 0;
            const offsetX = this.attrs.offsetX || 0;
            const offsetY = this.attrs.offsetY || 0;
            at.translate(x2 - offsetX, y - offsetY);
          }
          at.dirty = false;
          return at;
        }
      }
      getAbsoluteScale(top2) {
        var parent = this;
        while (parent) {
          if (parent._isUnderCache) {
            top2 = parent;
          }
          parent = parent.getParent();
        }
        const transform2 = this.getAbsoluteTransform(top2);
        const attrs = transform2.decompose();
        return {
          x: attrs.scaleX,
          y: attrs.scaleY
        };
      }
      getAbsoluteRotation() {
        return this.getAbsoluteTransform().decompose().rotation;
      }
      getTransform() {
        return this._getCache(TRANSFORM, this._getTransform);
      }
      _getTransform() {
        var _a2, _b;
        var m = this._cache.get(TRANSFORM) || new Util_1$c.Transform();
        m.reset();
        var x2 = this.x(), y = this.y(), rotation = Global_1$m.Konva.getAngle(this.rotation()), scaleX = (_a2 = this.attrs.scaleX) !== null && _a2 !== void 0 ? _a2 : 1, scaleY = (_b = this.attrs.scaleY) !== null && _b !== void 0 ? _b : 1, skewX = this.attrs.skewX || 0, skewY = this.attrs.skewY || 0, offsetX = this.attrs.offsetX || 0, offsetY = this.attrs.offsetY || 0;
        if (x2 !== 0 || y !== 0) {
          m.translate(x2, y);
        }
        if (rotation !== 0) {
          m.rotate(rotation);
        }
        if (skewX !== 0 || skewY !== 0) {
          m.skew(skewX, skewY);
        }
        if (scaleX !== 1 || scaleY !== 1) {
          m.scale(scaleX, scaleY);
        }
        if (offsetX !== 0 || offsetY !== 0) {
          m.translate(-1 * offsetX, -1 * offsetY);
        }
        m.dirty = false;
        return m;
      }
      clone(obj) {
        var attrs = Util_1$c.Util.cloneObject(this.attrs), key, allListeners, len, n, listener;
        for (key in obj) {
          attrs[key] = obj[key];
        }
        var node = new this.constructor(attrs);
        for (key in this.eventListeners) {
          allListeners = this.eventListeners[key];
          len = allListeners.length;
          for (n = 0; n < len; n++) {
            listener = allListeners[n];
            if (listener.name.indexOf(KONVA) < 0) {
              if (!node.eventListeners[key]) {
                node.eventListeners[key] = [];
              }
              node.eventListeners[key].push(listener);
            }
          }
        }
        return node;
      }
      _toKonvaCanvas(config2) {
        config2 = config2 || {};
        var box = this.getClientRect();
        var stage = this.getStage(), x2 = config2.x !== void 0 ? config2.x : Math.floor(box.x), y = config2.y !== void 0 ? config2.y : Math.floor(box.y), pixelRatio = config2.pixelRatio || 1, canvas = new Canvas_1$1.SceneCanvas({
          width: config2.width || Math.ceil(box.width) || (stage ? stage.width() : 0),
          height: config2.height || Math.ceil(box.height) || (stage ? stage.height() : 0),
          pixelRatio
        }), context = canvas.getContext();
        const bufferCanvas = new Canvas_1$1.SceneCanvas({
          width: canvas.width / canvas.pixelRatio + Math.abs(x2),
          height: canvas.height / canvas.pixelRatio + Math.abs(y),
          pixelRatio: canvas.pixelRatio
        });
        if (config2.imageSmoothingEnabled === false) {
          context._context.imageSmoothingEnabled = false;
        }
        context.save();
        if (x2 || y) {
          context.translate(-1 * x2, -1 * y);
        }
        this.drawScene(canvas, void 0, bufferCanvas);
        context.restore();
        return canvas;
      }
      toCanvas(config2) {
        return this._toKonvaCanvas(config2)._canvas;
      }
      toDataURL(config2) {
        config2 = config2 || {};
        var mimeType = config2.mimeType || null, quality = config2.quality || null;
        var url = this._toKonvaCanvas(config2).toDataURL(mimeType, quality);
        if (config2.callback) {
          config2.callback(url);
        }
        return url;
      }
      toImage(config2) {
        return new Promise((resolve2, reject) => {
          try {
            const callback = config2 === null || config2 === void 0 ? void 0 : config2.callback;
            if (callback)
              delete config2.callback;
            Util_1$c.Util._urlToImage(this.toDataURL(config2), function(img) {
              resolve2(img);
              callback === null || callback === void 0 ? void 0 : callback(img);
            });
          } catch (err) {
            reject(err);
          }
        });
      }
      toBlob(config2) {
        return new Promise((resolve2, reject) => {
          try {
            const callback = config2 === null || config2 === void 0 ? void 0 : config2.callback;
            if (callback)
              delete config2.callback;
            this.toCanvas(config2).toBlob((blob) => {
              resolve2(blob);
              callback === null || callback === void 0 ? void 0 : callback(blob);
            }, config2 === null || config2 === void 0 ? void 0 : config2.mimeType, config2 === null || config2 === void 0 ? void 0 : config2.quality);
          } catch (err) {
            reject(err);
          }
        });
      }
      setSize(size2) {
        this.width(size2.width);
        this.height(size2.height);
        return this;
      }
      getSize() {
        return {
          width: this.width(),
          height: this.height()
        };
      }
      getClassName() {
        return this.className || this.nodeType;
      }
      getType() {
        return this.nodeType;
      }
      getDragDistance() {
        if (this.attrs.dragDistance !== void 0) {
          return this.attrs.dragDistance;
        } else if (this.parent) {
          return this.parent.getDragDistance();
        } else {
          return Global_1$m.Konva.dragDistance;
        }
      }
      _off(type2, name, callback) {
        var evtListeners = this.eventListeners[type2], i2, evtName, handler;
        for (i2 = 0; i2 < evtListeners.length; i2++) {
          evtName = evtListeners[i2].name;
          handler = evtListeners[i2].handler;
          if ((evtName !== "konva" || name === "konva") && (!name || evtName === name) && (!callback || callback === handler)) {
            evtListeners.splice(i2, 1);
            if (evtListeners.length === 0) {
              delete this.eventListeners[type2];
              break;
            }
            i2--;
          }
        }
      }
      _fireChangeEvent(attr, oldVal, newVal) {
        this._fire(attr + CHANGE, {
          oldVal,
          newVal
        });
      }
      addName(name) {
        if (!this.hasName(name)) {
          var oldName = this.name();
          var newName = oldName ? oldName + " " + name : name;
          this.name(newName);
        }
        return this;
      }
      hasName(name) {
        if (!name) {
          return false;
        }
        const fullName = this.name();
        if (!fullName) {
          return false;
        }
        var names2 = (fullName || "").split(/\s/g);
        return names2.indexOf(name) !== -1;
      }
      removeName(name) {
        var names2 = (this.name() || "").split(/\s/g);
        var index = names2.indexOf(name);
        if (index !== -1) {
          names2.splice(index, 1);
          this.name(names2.join(" "));
        }
        return this;
      }
      setAttr(attr, val) {
        var func = this[SET + Util_1$c.Util._capitalize(attr)];
        if (Util_1$c.Util._isFunction(func)) {
          func.call(this, val);
        } else {
          this._setAttr(attr, val);
        }
        return this;
      }
      _requestDraw() {
        if (Global_1$m.Konva.autoDrawEnabled) {
          const drawNode = this.getLayer() || this.getStage();
          drawNode === null || drawNode === void 0 ? void 0 : drawNode.batchDraw();
        }
      }
      _setAttr(key, val) {
        var oldVal = this.attrs[key];
        if (oldVal === val && !Util_1$c.Util.isObject(val)) {
          return;
        }
        if (val === void 0 || val === null) {
          delete this.attrs[key];
        } else {
          this.attrs[key] = val;
        }
        if (this._shouldFireChangeEvents) {
          this._fireChangeEvent(key, oldVal, val);
        }
        this._requestDraw();
      }
      _setComponentAttr(key, component, val) {
        var oldVal;
        if (val !== void 0) {
          oldVal = this.attrs[key];
          if (!oldVal) {
            this.attrs[key] = this.getAttr(key);
          }
          this.attrs[key][component] = val;
          this._fireChangeEvent(key, oldVal, val);
        }
      }
      _fireAndBubble(eventType, evt, compareShape) {
        if (evt && this.nodeType === SHAPE) {
          evt.target = this;
        }
        var shouldStop = (eventType === MOUSEENTER || eventType === MOUSELEAVE) && (compareShape && (this === compareShape || this.isAncestorOf && this.isAncestorOf(compareShape)) || this.nodeType === "Stage" && !compareShape);
        if (!shouldStop) {
          this._fire(eventType, evt);
          var stopBubble = (eventType === MOUSEENTER || eventType === MOUSELEAVE) && compareShape && compareShape.isAncestorOf && compareShape.isAncestorOf(this) && !compareShape.isAncestorOf(this.parent);
          if ((evt && !evt.cancelBubble || !evt) && this.parent && this.parent.isListening() && !stopBubble) {
            if (compareShape && compareShape.parent) {
              this._fireAndBubble.call(this.parent, eventType, evt, compareShape);
            } else {
              this._fireAndBubble.call(this.parent, eventType, evt);
            }
          }
        }
      }
      _getProtoListeners(eventType) {
        var _a2, _b, _c;
        const allListeners = (_a2 = this._cache.get(ALL_LISTENERS)) !== null && _a2 !== void 0 ? _a2 : {};
        let events = allListeners === null || allListeners === void 0 ? void 0 : allListeners[eventType];
        if (events === void 0) {
          events = [];
          let obj = Object.getPrototypeOf(this);
          while (obj) {
            const hierarchyEvents = (_c = (_b = obj.eventListeners) === null || _b === void 0 ? void 0 : _b[eventType]) !== null && _c !== void 0 ? _c : [];
            events.push(...hierarchyEvents);
            obj = Object.getPrototypeOf(obj);
          }
          allListeners[eventType] = events;
          this._cache.set(ALL_LISTENERS, allListeners);
        }
        return events;
      }
      _fire(eventType, evt) {
        evt = evt || {};
        evt.currentTarget = this;
        evt.type = eventType;
        const topListeners = this._getProtoListeners(eventType);
        if (topListeners) {
          for (var i2 = 0; i2 < topListeners.length; i2++) {
            topListeners[i2].handler.call(this, evt);
          }
        }
        const selfListeners = this.eventListeners[eventType];
        if (selfListeners) {
          for (var i2 = 0; i2 < selfListeners.length; i2++) {
            selfListeners[i2].handler.call(this, evt);
          }
        }
      }
      draw() {
        this.drawScene();
        this.drawHit();
        return this;
      }
      _createDragElement(evt) {
        var pointerId = evt ? evt.pointerId : void 0;
        var stage = this.getStage();
        var ap2 = this.getAbsolutePosition();
        if (!stage) {
          return;
        }
        var pos = stage._getPointerById(pointerId) || stage._changedPointerPositions[0] || ap2;
        DragAndDrop_1.DD._dragElements.set(this._id, {
          node: this,
          startPointerPos: pos,
          offset: {
            x: pos.x - ap2.x,
            y: pos.y - ap2.y
          },
          dragStatus: "ready",
          pointerId
        });
      }
      startDrag(evt, bubbleEvent = true) {
        if (!DragAndDrop_1.DD._dragElements.has(this._id)) {
          this._createDragElement(evt);
        }
        const elem = DragAndDrop_1.DD._dragElements.get(this._id);
        elem.dragStatus = "dragging";
        this.fire("dragstart", {
          type: "dragstart",
          target: this,
          evt: evt && evt.evt
        }, bubbleEvent);
      }
      _setDragPosition(evt, elem) {
        const pos = this.getStage()._getPointerById(elem.pointerId);
        if (!pos) {
          return;
        }
        var newNodePos = {
          x: pos.x - elem.offset.x,
          y: pos.y - elem.offset.y
        };
        var dbf = this.dragBoundFunc();
        if (dbf !== void 0) {
          const bounded = dbf.call(this, newNodePos, evt);
          if (!bounded) {
            Util_1$c.Util.warn("dragBoundFunc did not return any value. That is unexpected behavior. You must return new absolute position from dragBoundFunc.");
          } else {
            newNodePos = bounded;
          }
        }
        if (!this._lastPos || this._lastPos.x !== newNodePos.x || this._lastPos.y !== newNodePos.y) {
          this.setAbsolutePosition(newNodePos);
          this._requestDraw();
        }
        this._lastPos = newNodePos;
      }
      stopDrag(evt) {
        const elem = DragAndDrop_1.DD._dragElements.get(this._id);
        if (elem) {
          elem.dragStatus = "stopped";
        }
        DragAndDrop_1.DD._endDragBefore(evt);
        DragAndDrop_1.DD._endDragAfter(evt);
      }
      setDraggable(draggable) {
        this._setAttr("draggable", draggable);
        this._dragChange();
      }
      isDragging() {
        const elem = DragAndDrop_1.DD._dragElements.get(this._id);
        return elem ? elem.dragStatus === "dragging" : false;
      }
      _listenDrag() {
        this._dragCleanup();
        this.on("mousedown.konva touchstart.konva", function(evt) {
          var shouldCheckButton = evt.evt["button"] !== void 0;
          var canDrag = !shouldCheckButton || Global_1$m.Konva.dragButtons.indexOf(evt.evt["button"]) >= 0;
          if (!canDrag) {
            return;
          }
          if (this.isDragging()) {
            return;
          }
          var hasDraggingChild = false;
          DragAndDrop_1.DD._dragElements.forEach((elem) => {
            if (this.isAncestorOf(elem.node)) {
              hasDraggingChild = true;
            }
          });
          if (!hasDraggingChild) {
            this._createDragElement(evt);
          }
        });
      }
      _dragChange() {
        if (this.attrs.draggable) {
          this._listenDrag();
        } else {
          this._dragCleanup();
          var stage = this.getStage();
          if (!stage) {
            return;
          }
          const dragElement = DragAndDrop_1.DD._dragElements.get(this._id);
          const isDragging = dragElement && dragElement.dragStatus === "dragging";
          const isReady = dragElement && dragElement.dragStatus === "ready";
          if (isDragging) {
            this.stopDrag();
          } else if (isReady) {
            DragAndDrop_1.DD._dragElements.delete(this._id);
          }
        }
      }
      _dragCleanup() {
        this.off("mousedown.konva");
        this.off("touchstart.konva");
      }
      isClientRectOnScreen(margin = { x: 0, y: 0 }) {
        const stage = this.getStage();
        if (!stage) {
          return false;
        }
        const screenRect = {
          x: -margin.x,
          y: -margin.y,
          width: stage.width() + 2 * margin.x,
          height: stage.height() + 2 * margin.y
        };
        return Util_1$c.Util.haveIntersection(screenRect, this.getClientRect());
      }
      static create(data, container) {
        if (Util_1$c.Util._isString(data)) {
          data = JSON.parse(data);
        }
        return this._createNode(data, container);
      }
      static _createNode(obj, container) {
        var className = Node2.prototype.getClassName.call(obj), children = obj.children, no, len, n;
        if (container) {
          obj.attrs.container = container;
        }
        if (!Global_1$m.Konva[className]) {
          Util_1$c.Util.warn('Can not find a node with class name "' + className + '". Fallback to "Shape".');
          className = "Shape";
        }
        const Class = Global_1$m.Konva[className];
        no = new Class(obj.attrs);
        if (children) {
          len = children.length;
          for (n = 0; n < len; n++) {
            no.add(Node2._createNode(children[n]));
          }
        }
        return no;
      }
    };
    Node$2.Node = Node$1;
    Node$1.prototype.nodeType = "Node";
    Node$1.prototype._attrsAffectingSize = [];
    Node$1.prototype.eventListeners = {};
    Node$1.prototype.on.call(Node$1.prototype, TRANSFORM_CHANGE_STR$1, function() {
      if (this._batchingTransformChange) {
        this._needClearTransformCache = true;
        return;
      }
      this._clearCache(TRANSFORM);
      this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
    });
    Node$1.prototype.on.call(Node$1.prototype, "visibleChange.konva", function() {
      this._clearSelfAndDescendantCache(VISIBLE);
    });
    Node$1.prototype.on.call(Node$1.prototype, "listeningChange.konva", function() {
      this._clearSelfAndDescendantCache(LISTENING);
    });
    Node$1.prototype.on.call(Node$1.prototype, "opacityChange.konva", function() {
      this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
    });
    const addGetterSetter = Factory_1$y.Factory.addGetterSetter;
    addGetterSetter(Node$1, "zIndex");
    addGetterSetter(Node$1, "absolutePosition");
    addGetterSetter(Node$1, "position");
    addGetterSetter(Node$1, "x", 0, (0, Validators_1$x.getNumberValidator)());
    addGetterSetter(Node$1, "y", 0, (0, Validators_1$x.getNumberValidator)());
    addGetterSetter(Node$1, "globalCompositeOperation", "source-over", (0, Validators_1$x.getStringValidator)());
    addGetterSetter(Node$1, "opacity", 1, (0, Validators_1$x.getNumberValidator)());
    addGetterSetter(Node$1, "name", "", (0, Validators_1$x.getStringValidator)());
    addGetterSetter(Node$1, "id", "", (0, Validators_1$x.getStringValidator)());
    addGetterSetter(Node$1, "rotation", 0, (0, Validators_1$x.getNumberValidator)());
    Factory_1$y.Factory.addComponentsGetterSetter(Node$1, "scale", ["x", "y"]);
    addGetterSetter(Node$1, "scaleX", 1, (0, Validators_1$x.getNumberValidator)());
    addGetterSetter(Node$1, "scaleY", 1, (0, Validators_1$x.getNumberValidator)());
    Factory_1$y.Factory.addComponentsGetterSetter(Node$1, "skew", ["x", "y"]);
    addGetterSetter(Node$1, "skewX", 0, (0, Validators_1$x.getNumberValidator)());
    addGetterSetter(Node$1, "skewY", 0, (0, Validators_1$x.getNumberValidator)());
    Factory_1$y.Factory.addComponentsGetterSetter(Node$1, "offset", ["x", "y"]);
    addGetterSetter(Node$1, "offsetX", 0, (0, Validators_1$x.getNumberValidator)());
    addGetterSetter(Node$1, "offsetY", 0, (0, Validators_1$x.getNumberValidator)());
    addGetterSetter(Node$1, "dragDistance", null, (0, Validators_1$x.getNumberValidator)());
    addGetterSetter(Node$1, "width", 0, (0, Validators_1$x.getNumberValidator)());
    addGetterSetter(Node$1, "height", 0, (0, Validators_1$x.getNumberValidator)());
    addGetterSetter(Node$1, "listening", true, (0, Validators_1$x.getBooleanValidator)());
    addGetterSetter(Node$1, "preventDefault", true, (0, Validators_1$x.getBooleanValidator)());
    addGetterSetter(Node$1, "filters", null, function(val) {
      this._filterUpToDate = false;
      return val;
    });
    addGetterSetter(Node$1, "visible", true, (0, Validators_1$x.getBooleanValidator)());
    addGetterSetter(Node$1, "transformsEnabled", "all", (0, Validators_1$x.getStringValidator)());
    addGetterSetter(Node$1, "size");
    addGetterSetter(Node$1, "dragBoundFunc");
    addGetterSetter(Node$1, "draggable", false, (0, Validators_1$x.getBooleanValidator)());
    Factory_1$y.Factory.backCompat(Node$1, {
      rotateDeg: "rotate",
      setRotationDeg: "setRotation",
      getRotationDeg: "getRotation"
    });
    var Container$1 = {};
    Object.defineProperty(Container$1, "__esModule", { value: true });
    Container$1.Container = void 0;
    const Factory_1$x = Factory;
    const Node_1$h = Node$2;
    const Validators_1$w = Validators;
    class Container extends Node_1$h.Node {
      constructor() {
        super(...arguments);
        this.children = [];
      }
      getChildren(filterFunc) {
        if (!filterFunc) {
          return this.children || [];
        }
        const children = this.children || [];
        var results = [];
        children.forEach(function(child) {
          if (filterFunc(child)) {
            results.push(child);
          }
        });
        return results;
      }
      hasChildren() {
        return this.getChildren().length > 0;
      }
      removeChildren() {
        this.getChildren().forEach((child) => {
          child.parent = null;
          child.index = 0;
          child.remove();
        });
        this.children = [];
        this._requestDraw();
        return this;
      }
      destroyChildren() {
        this.getChildren().forEach((child) => {
          child.parent = null;
          child.index = 0;
          child.destroy();
        });
        this.children = [];
        this._requestDraw();
        return this;
      }
      add(...children) {
        if (children.length === 0) {
          return this;
        }
        if (children.length > 1) {
          for (var i2 = 0; i2 < children.length; i2++) {
            this.add(children[i2]);
          }
          return this;
        }
        const child = children[0];
        if (child.getParent()) {
          child.moveTo(this);
          return this;
        }
        this._validateAdd(child);
        child.index = this.getChildren().length;
        child.parent = this;
        child._clearCaches();
        this.getChildren().push(child);
        this._fire("add", {
          child
        });
        this._requestDraw();
        return this;
      }
      destroy() {
        if (this.hasChildren()) {
          this.destroyChildren();
        }
        super.destroy();
        return this;
      }
      find(selector) {
        return this._generalFind(selector, false);
      }
      findOne(selector) {
        var result = this._generalFind(selector, true);
        return result.length > 0 ? result[0] : void 0;
      }
      _generalFind(selector, findOne) {
        var retArr = [];
        this._descendants((node) => {
          const valid = node._isMatch(selector);
          if (valid) {
            retArr.push(node);
          }
          if (valid && findOne) {
            return true;
          }
          return false;
        });
        return retArr;
      }
      _descendants(fn) {
        let shouldStop = false;
        const children = this.getChildren();
        for (const child of children) {
          shouldStop = fn(child);
          if (shouldStop) {
            return true;
          }
          if (!child.hasChildren()) {
            continue;
          }
          shouldStop = child._descendants(fn);
          if (shouldStop) {
            return true;
          }
        }
        return false;
      }
      toObject() {
        var obj = Node_1$h.Node.prototype.toObject.call(this);
        obj.children = [];
        this.getChildren().forEach((child) => {
          obj.children.push(child.toObject());
        });
        return obj;
      }
      isAncestorOf(node) {
        var parent = node.getParent();
        while (parent) {
          if (parent._id === this._id) {
            return true;
          }
          parent = parent.getParent();
        }
        return false;
      }
      clone(obj) {
        var node = Node_1$h.Node.prototype.clone.call(this, obj);
        this.getChildren().forEach(function(no) {
          node.add(no.clone());
        });
        return node;
      }
      getAllIntersections(pos) {
        var arr = [];
        this.find("Shape").forEach((shape) => {
          if (shape.isVisible() && shape.intersects(pos)) {
            arr.push(shape);
          }
        });
        return arr;
      }
      _clearSelfAndDescendantCache(attr) {
        var _a2;
        super._clearSelfAndDescendantCache(attr);
        if (this.isCached()) {
          return;
        }
        (_a2 = this.children) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(node) {
          node._clearSelfAndDescendantCache(attr);
        });
      }
      _setChildrenIndices() {
        var _a2;
        (_a2 = this.children) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(child, n) {
          child.index = n;
        });
        this._requestDraw();
      }
      drawScene(can, top2, bufferCanvas) {
        var layer = this.getLayer(), canvas = can || layer && layer.getCanvas(), context = canvas && canvas.getContext(), cachedCanvas = this._getCanvasCache(), cachedSceneCanvas = cachedCanvas && cachedCanvas.scene;
        var caching = canvas && canvas.isCache;
        if (!this.isVisible() && !caching) {
          return this;
        }
        if (cachedSceneCanvas) {
          context.save();
          var m = this.getAbsoluteTransform(top2).getMatrix();
          context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
          this._drawCachedSceneCanvas(context);
          context.restore();
        } else {
          this._drawChildren("drawScene", canvas, top2, bufferCanvas);
        }
        return this;
      }
      drawHit(can, top2) {
        if (!this.shouldDrawHit(top2)) {
          return this;
        }
        var layer = this.getLayer(), canvas = can || layer && layer.hitCanvas, context = canvas && canvas.getContext(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;
        if (cachedHitCanvas) {
          context.save();
          var m = this.getAbsoluteTransform(top2).getMatrix();
          context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
          this._drawCachedHitCanvas(context);
          context.restore();
        } else {
          this._drawChildren("drawHit", canvas, top2);
        }
        return this;
      }
      _drawChildren(drawMethod, canvas, top2, bufferCanvas) {
        var _a2;
        var context = canvas && canvas.getContext(), clipWidth = this.clipWidth(), clipHeight = this.clipHeight(), clipFunc = this.clipFunc(), hasClip = typeof clipWidth === "number" && typeof clipHeight === "number" || clipFunc;
        const selfCache = top2 === this;
        if (hasClip) {
          context.save();
          var transform2 = this.getAbsoluteTransform(top2);
          var m = transform2.getMatrix();
          context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
          context.beginPath();
          let clipArgs;
          if (clipFunc) {
            clipArgs = clipFunc.call(this, context, this);
          } else {
            var clipX = this.clipX();
            var clipY = this.clipY();
            context.rect(clipX || 0, clipY || 0, clipWidth, clipHeight);
          }
          context.clip.apply(context, clipArgs);
          m = transform2.copy().invert().getMatrix();
          context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
        }
        var hasComposition = !selfCache && this.globalCompositeOperation() !== "source-over" && drawMethod === "drawScene";
        if (hasComposition) {
          context.save();
          context._applyGlobalCompositeOperation(this);
        }
        (_a2 = this.children) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(child) {
          child[drawMethod](canvas, top2, bufferCanvas);
        });
        if (hasComposition) {
          context.restore();
        }
        if (hasClip) {
          context.restore();
        }
      }
      getClientRect(config2 = {}) {
        var _a2;
        var skipTransform = config2.skipTransform;
        var relativeTo = config2.relativeTo;
        var minX, minY, maxX, maxY;
        var selfRect = {
          x: Infinity,
          y: Infinity,
          width: 0,
          height: 0
        };
        var that = this;
        (_a2 = this.children) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(child) {
          if (!child.visible()) {
            return;
          }
          var rect2 = child.getClientRect({
            relativeTo: that,
            skipShadow: config2.skipShadow,
            skipStroke: config2.skipStroke
          });
          if (rect2.width === 0 && rect2.height === 0) {
            return;
          }
          if (minX === void 0) {
            minX = rect2.x;
            minY = rect2.y;
            maxX = rect2.x + rect2.width;
            maxY = rect2.y + rect2.height;
          } else {
            minX = Math.min(minX, rect2.x);
            minY = Math.min(minY, rect2.y);
            maxX = Math.max(maxX, rect2.x + rect2.width);
            maxY = Math.max(maxY, rect2.y + rect2.height);
          }
        });
        var shapes = this.find("Shape");
        var hasVisible = false;
        for (var i2 = 0; i2 < shapes.length; i2++) {
          var shape = shapes[i2];
          if (shape._isVisible(this)) {
            hasVisible = true;
            break;
          }
        }
        if (hasVisible && minX !== void 0) {
          selfRect = {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
          };
        } else {
          selfRect = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
        if (!skipTransform) {
          return this._transformedRect(selfRect, relativeTo);
        }
        return selfRect;
      }
    }
    Container$1.Container = Container;
    Factory_1$x.Factory.addComponentsGetterSetter(Container, "clip", [
      "x",
      "y",
      "width",
      "height"
    ]);
    Factory_1$x.Factory.addGetterSetter(Container, "clipX", void 0, (0, Validators_1$w.getNumberValidator)());
    Factory_1$x.Factory.addGetterSetter(Container, "clipY", void 0, (0, Validators_1$w.getNumberValidator)());
    Factory_1$x.Factory.addGetterSetter(Container, "clipWidth", void 0, (0, Validators_1$w.getNumberValidator)());
    Factory_1$x.Factory.addGetterSetter(Container, "clipHeight", void 0, (0, Validators_1$w.getNumberValidator)());
    Factory_1$x.Factory.addGetterSetter(Container, "clipFunc");
    var Stage = {};
    var PointerEvents = {};
    Object.defineProperty(PointerEvents, "__esModule", { value: true });
    PointerEvents.releaseCapture = PointerEvents.setPointerCapture = PointerEvents.hasPointerCapture = PointerEvents.createEvent = PointerEvents.getCapturedShape = void 0;
    const Global_1$l = Global;
    const Captures = /* @__PURE__ */ new Map();
    const SUPPORT_POINTER_EVENTS = Global_1$l.Konva._global["PointerEvent"] !== void 0;
    function getCapturedShape(pointerId) {
      return Captures.get(pointerId);
    }
    PointerEvents.getCapturedShape = getCapturedShape;
    function createEvent(evt) {
      return {
        evt,
        pointerId: evt.pointerId
      };
    }
    PointerEvents.createEvent = createEvent;
    function hasPointerCapture(pointerId, shape) {
      return Captures.get(pointerId) === shape;
    }
    PointerEvents.hasPointerCapture = hasPointerCapture;
    function setPointerCapture(pointerId, shape) {
      releaseCapture(pointerId);
      const stage = shape.getStage();
      if (!stage)
        return;
      Captures.set(pointerId, shape);
      if (SUPPORT_POINTER_EVENTS) {
        shape._fire("gotpointercapture", createEvent(new PointerEvent("gotpointercapture")));
      }
    }
    PointerEvents.setPointerCapture = setPointerCapture;
    function releaseCapture(pointerId, target2) {
      const shape = Captures.get(pointerId);
      if (!shape)
        return;
      const stage = shape.getStage();
      if (stage && stage.content)
        ;
      Captures.delete(pointerId);
      if (SUPPORT_POINTER_EVENTS) {
        shape._fire("lostpointercapture", createEvent(new PointerEvent("lostpointercapture")));
      }
    }
    PointerEvents.releaseCapture = releaseCapture;
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Stage = exports2.stages = void 0;
      const Util_12 = Util;
      const Factory_12 = Factory;
      const Container_12 = Container$1;
      const Global_12 = Global;
      const Canvas_12 = Canvas$1;
      const DragAndDrop_12 = DragAndDrop;
      const Global_22 = Global;
      const PointerEvents$1 = PointerEvents;
      var STAGE2 = "Stage", STRING = "string", PX = "px", MOUSEOUT = "mouseout", MOUSELEAVE2 = "mouseleave", MOUSEOVER = "mouseover", MOUSEENTER2 = "mouseenter", MOUSEMOVE = "mousemove", MOUSEDOWN = "mousedown", MOUSEUP = "mouseup", POINTERMOVE = "pointermove", POINTERDOWN = "pointerdown", POINTERUP = "pointerup", POINTERCANCEL = "pointercancel", LOSTPOINTERCAPTURE = "lostpointercapture", POINTEROUT = "pointerout", POINTERLEAVE = "pointerleave", POINTEROVER = "pointerover", POINTERENTER = "pointerenter", CONTEXTMENU = "contextmenu", TOUCHSTART = "touchstart", TOUCHEND = "touchend", TOUCHMOVE = "touchmove", TOUCHCANCEL = "touchcancel", WHEEL = "wheel", MAX_LAYERS_NUMBER = 5, EVENTS = [
        [MOUSEENTER2, "_pointerenter"],
        [MOUSEDOWN, "_pointerdown"],
        [MOUSEMOVE, "_pointermove"],
        [MOUSEUP, "_pointerup"],
        [MOUSELEAVE2, "_pointerleave"],
        [TOUCHSTART, "_pointerdown"],
        [TOUCHMOVE, "_pointermove"],
        [TOUCHEND, "_pointerup"],
        [TOUCHCANCEL, "_pointercancel"],
        [MOUSEOVER, "_pointerover"],
        [WHEEL, "_wheel"],
        [CONTEXTMENU, "_contextmenu"],
        [POINTERDOWN, "_pointerdown"],
        [POINTERMOVE, "_pointermove"],
        [POINTERUP, "_pointerup"],
        [POINTERCANCEL, "_pointercancel"],
        [LOSTPOINTERCAPTURE, "_lostpointercapture"]
      ];
      const EVENTS_MAP = {
        mouse: {
          [POINTEROUT]: MOUSEOUT,
          [POINTERLEAVE]: MOUSELEAVE2,
          [POINTEROVER]: MOUSEOVER,
          [POINTERENTER]: MOUSEENTER2,
          [POINTERMOVE]: MOUSEMOVE,
          [POINTERDOWN]: MOUSEDOWN,
          [POINTERUP]: MOUSEUP,
          [POINTERCANCEL]: "mousecancel",
          pointerclick: "click",
          pointerdblclick: "dblclick"
        },
        touch: {
          [POINTEROUT]: "touchout",
          [POINTERLEAVE]: "touchleave",
          [POINTEROVER]: "touchover",
          [POINTERENTER]: "touchenter",
          [POINTERMOVE]: TOUCHMOVE,
          [POINTERDOWN]: TOUCHSTART,
          [POINTERUP]: TOUCHEND,
          [POINTERCANCEL]: TOUCHCANCEL,
          pointerclick: "tap",
          pointerdblclick: "dbltap"
        },
        pointer: {
          [POINTEROUT]: POINTEROUT,
          [POINTERLEAVE]: POINTERLEAVE,
          [POINTEROVER]: POINTEROVER,
          [POINTERENTER]: POINTERENTER,
          [POINTERMOVE]: POINTERMOVE,
          [POINTERDOWN]: POINTERDOWN,
          [POINTERUP]: POINTERUP,
          [POINTERCANCEL]: POINTERCANCEL,
          pointerclick: "pointerclick",
          pointerdblclick: "pointerdblclick"
        }
      };
      const getEventType = (type2) => {
        if (type2.indexOf("pointer") >= 0) {
          return "pointer";
        }
        if (type2.indexOf("touch") >= 0) {
          return "touch";
        }
        return "mouse";
      };
      const getEventsMap = (eventType) => {
        const type2 = getEventType(eventType);
        if (type2 === "pointer") {
          return Global_12.Konva.pointerEventsEnabled && EVENTS_MAP.pointer;
        }
        if (type2 === "touch") {
          return EVENTS_MAP.touch;
        }
        if (type2 === "mouse") {
          return EVENTS_MAP.mouse;
        }
      };
      function checkNoClip(attrs = {}) {
        if (attrs.clipFunc || attrs.clipWidth || attrs.clipHeight) {
          Util_12.Util.warn("Stage does not support clipping. Please use clip for Layers or Groups.");
        }
        return attrs;
      }
      const NO_POINTERS_MESSAGE = `Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);`;
      exports2.stages = [];
      class Stage2 extends Container_12.Container {
        constructor(config2) {
          super(checkNoClip(config2));
          this._pointerPositions = [];
          this._changedPointerPositions = [];
          this._buildDOM();
          this._bindContentEvents();
          exports2.stages.push(this);
          this.on("widthChange.konva heightChange.konva", this._resizeDOM);
          this.on("visibleChange.konva", this._checkVisibility);
          this.on("clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva", () => {
            checkNoClip(this.attrs);
          });
          this._checkVisibility();
        }
        _validateAdd(child) {
          const isLayer = child.getType() === "Layer";
          const isFastLayer = child.getType() === "FastLayer";
          const valid = isLayer || isFastLayer;
          if (!valid) {
            Util_12.Util.throw("You may only add layers to the stage.");
          }
        }
        _checkVisibility() {
          if (!this.content) {
            return;
          }
          const style = this.visible() ? "" : "none";
          this.content.style.display = style;
        }
        setContainer(container) {
          if (typeof container === STRING) {
            if (container.charAt(0) === ".") {
              var className = container.slice(1);
              container = document.getElementsByClassName(className)[0];
            } else {
              var id2;
              if (container.charAt(0) !== "#") {
                id2 = container;
              } else {
                id2 = container.slice(1);
              }
              container = document.getElementById(id2);
            }
            if (!container) {
              throw "Can not find container in document with id " + id2;
            }
          }
          this._setAttr("container", container);
          if (this.content) {
            if (this.content.parentElement) {
              this.content.parentElement.removeChild(this.content);
            }
            container.appendChild(this.content);
          }
          return this;
        }
        shouldDrawHit() {
          return true;
        }
        clear() {
          var layers = this.children, len = layers.length, n;
          for (n = 0; n < len; n++) {
            layers[n].clear();
          }
          return this;
        }
        clone(obj) {
          if (!obj) {
            obj = {};
          }
          obj.container = typeof document !== "undefined" && document.createElement("div");
          return Container_12.Container.prototype.clone.call(this, obj);
        }
        destroy() {
          super.destroy();
          var content2 = this.content;
          if (content2 && Util_12.Util._isInDocument(content2)) {
            this.container().removeChild(content2);
          }
          var index = exports2.stages.indexOf(this);
          if (index > -1) {
            exports2.stages.splice(index, 1);
          }
          Util_12.Util.releaseCanvas(this.bufferCanvas._canvas, this.bufferHitCanvas._canvas);
          return this;
        }
        getPointerPosition() {
          const pos = this._pointerPositions[0] || this._changedPointerPositions[0];
          if (!pos) {
            Util_12.Util.warn(NO_POINTERS_MESSAGE);
            return null;
          }
          return {
            x: pos.x,
            y: pos.y
          };
        }
        _getPointerById(id2) {
          return this._pointerPositions.find((p2) => p2.id === id2);
        }
        getPointersPositions() {
          return this._pointerPositions;
        }
        getStage() {
          return this;
        }
        getContent() {
          return this.content;
        }
        _toKonvaCanvas(config2) {
          config2 = config2 || {};
          config2.x = config2.x || 0;
          config2.y = config2.y || 0;
          config2.width = config2.width || this.width();
          config2.height = config2.height || this.height();
          var canvas = new Canvas_12.SceneCanvas({
            width: config2.width,
            height: config2.height,
            pixelRatio: config2.pixelRatio || 1
          });
          var _context = canvas.getContext()._context;
          var layers = this.children;
          if (config2.x || config2.y) {
            _context.translate(-1 * config2.x, -1 * config2.y);
          }
          layers.forEach(function(layer) {
            if (!layer.isVisible()) {
              return;
            }
            var layerCanvas = layer._toKonvaCanvas(config2);
            _context.drawImage(layerCanvas._canvas, config2.x, config2.y, layerCanvas.getWidth() / layerCanvas.getPixelRatio(), layerCanvas.getHeight() / layerCanvas.getPixelRatio());
          });
          return canvas;
        }
        getIntersection(pos) {
          if (!pos) {
            return null;
          }
          var layers = this.children, len = layers.length, end = len - 1, n;
          for (n = end; n >= 0; n--) {
            const shape = layers[n].getIntersection(pos);
            if (shape) {
              return shape;
            }
          }
          return null;
        }
        _resizeDOM() {
          var width = this.width();
          var height = this.height();
          if (this.content) {
            this.content.style.width = width + PX;
            this.content.style.height = height + PX;
          }
          this.bufferCanvas.setSize(width, height);
          this.bufferHitCanvas.setSize(width, height);
          this.children.forEach((layer) => {
            layer.setSize({ width, height });
            layer.draw();
          });
        }
        add(layer, ...rest) {
          if (arguments.length > 1) {
            for (var i2 = 0; i2 < arguments.length; i2++) {
              this.add(arguments[i2]);
            }
            return this;
          }
          super.add(layer);
          var length = this.children.length;
          if (length > MAX_LAYERS_NUMBER) {
            Util_12.Util.warn("The stage has " + length + " layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group.");
          }
          layer.setSize({ width: this.width(), height: this.height() });
          layer.draw();
          if (Global_12.Konva.isBrowser) {
            this.content.appendChild(layer.canvas._canvas);
          }
          return this;
        }
        getParent() {
          return null;
        }
        getLayer() {
          return null;
        }
        hasPointerCapture(pointerId) {
          return PointerEvents$1.hasPointerCapture(pointerId, this);
        }
        setPointerCapture(pointerId) {
          PointerEvents$1.setPointerCapture(pointerId, this);
        }
        releaseCapture(pointerId) {
          PointerEvents$1.releaseCapture(pointerId, this);
        }
        getLayers() {
          return this.children;
        }
        _bindContentEvents() {
          if (!Global_12.Konva.isBrowser) {
            return;
          }
          EVENTS.forEach(([event, methodName]) => {
            this.content.addEventListener(event, (evt) => {
              this[methodName](evt);
            }, { passive: false });
          });
        }
        _pointerenter(evt) {
          this.setPointersPositions(evt);
          const events = getEventsMap(evt.type);
          if (events) {
            this._fire(events.pointerenter, {
              evt,
              target: this,
              currentTarget: this
            });
          }
        }
        _pointerover(evt) {
          this.setPointersPositions(evt);
          const events = getEventsMap(evt.type);
          if (events) {
            this._fire(events.pointerover, {
              evt,
              target: this,
              currentTarget: this
            });
          }
        }
        _getTargetShape(evenType) {
          let shape = this[evenType + "targetShape"];
          if (shape && !shape.getStage()) {
            shape = null;
          }
          return shape;
        }
        _pointerleave(evt) {
          const events = getEventsMap(evt.type);
          const eventType = getEventType(evt.type);
          if (!events) {
            return;
          }
          this.setPointersPositions(evt);
          var targetShape = this._getTargetShape(eventType);
          var eventsEnabled = !(Global_12.Konva.isDragging() || Global_12.Konva.isTransforming()) || Global_12.Konva.hitOnDragEnabled;
          if (targetShape && eventsEnabled) {
            targetShape._fireAndBubble(events.pointerout, { evt });
            targetShape._fireAndBubble(events.pointerleave, { evt });
            this._fire(events.pointerleave, {
              evt,
              target: this,
              currentTarget: this
            });
            this[eventType + "targetShape"] = null;
          } else if (eventsEnabled) {
            this._fire(events.pointerleave, {
              evt,
              target: this,
              currentTarget: this
            });
            this._fire(events.pointerout, {
              evt,
              target: this,
              currentTarget: this
            });
          }
          this.pointerPos = null;
          this._pointerPositions = [];
        }
        _pointerdown(evt) {
          const events = getEventsMap(evt.type);
          const eventType = getEventType(evt.type);
          if (!events) {
            return;
          }
          this.setPointersPositions(evt);
          var triggeredOnShape = false;
          this._changedPointerPositions.forEach((pos) => {
            var shape = this.getIntersection(pos);
            DragAndDrop_12.DD.justDragged = false;
            Global_12.Konva["_" + eventType + "ListenClick"] = true;
            if (!shape || !shape.isListening()) {
              this[eventType + "ClickStartShape"] = void 0;
              return;
            }
            if (Global_12.Konva.capturePointerEventsEnabled) {
              shape.setPointerCapture(pos.id);
            }
            this[eventType + "ClickStartShape"] = shape;
            shape._fireAndBubble(events.pointerdown, {
              evt,
              pointerId: pos.id
            });
            triggeredOnShape = true;
            const isTouch = evt.type.indexOf("touch") >= 0;
            if (shape.preventDefault() && evt.cancelable && isTouch) {
              evt.preventDefault();
            }
          });
          if (!triggeredOnShape) {
            this._fire(events.pointerdown, {
              evt,
              target: this,
              currentTarget: this,
              pointerId: this._pointerPositions[0].id
            });
          }
        }
        _pointermove(evt) {
          const events = getEventsMap(evt.type);
          const eventType = getEventType(evt.type);
          if (!events) {
            return;
          }
          if (Global_12.Konva.isDragging() && DragAndDrop_12.DD.node.preventDefault() && evt.cancelable) {
            evt.preventDefault();
          }
          this.setPointersPositions(evt);
          var eventsEnabled = !(Global_12.Konva.isDragging() || Global_12.Konva.isTransforming()) || Global_12.Konva.hitOnDragEnabled;
          if (!eventsEnabled) {
            return;
          }
          var processedShapesIds = {};
          let triggeredOnShape = false;
          var targetShape = this._getTargetShape(eventType);
          this._changedPointerPositions.forEach((pos) => {
            const shape = PointerEvents$1.getCapturedShape(pos.id) || this.getIntersection(pos);
            const pointerId = pos.id;
            const event = { evt, pointerId };
            var differentTarget = targetShape !== shape;
            if (differentTarget && targetShape) {
              targetShape._fireAndBubble(events.pointerout, { ...event }, shape);
              targetShape._fireAndBubble(events.pointerleave, { ...event }, shape);
            }
            if (shape) {
              if (processedShapesIds[shape._id]) {
                return;
              }
              processedShapesIds[shape._id] = true;
            }
            if (shape && shape.isListening()) {
              triggeredOnShape = true;
              if (differentTarget) {
                shape._fireAndBubble(events.pointerover, { ...event }, targetShape);
                shape._fireAndBubble(events.pointerenter, { ...event }, targetShape);
                this[eventType + "targetShape"] = shape;
              }
              shape._fireAndBubble(events.pointermove, { ...event });
            } else {
              if (targetShape) {
                this._fire(events.pointerover, {
                  evt,
                  target: this,
                  currentTarget: this,
                  pointerId
                });
                this[eventType + "targetShape"] = null;
              }
            }
          });
          if (!triggeredOnShape) {
            this._fire(events.pointermove, {
              evt,
              target: this,
              currentTarget: this,
              pointerId: this._changedPointerPositions[0].id
            });
          }
        }
        _pointerup(evt) {
          const events = getEventsMap(evt.type);
          const eventType = getEventType(evt.type);
          if (!events) {
            return;
          }
          this.setPointersPositions(evt);
          const clickStartShape = this[eventType + "ClickStartShape"];
          const clickEndShape = this[eventType + "ClickEndShape"];
          var processedShapesIds = {};
          let triggeredOnShape = false;
          this._changedPointerPositions.forEach((pos) => {
            const shape = PointerEvents$1.getCapturedShape(pos.id) || this.getIntersection(pos);
            if (shape) {
              shape.releaseCapture(pos.id);
              if (processedShapesIds[shape._id]) {
                return;
              }
              processedShapesIds[shape._id] = true;
            }
            const pointerId = pos.id;
            const event = { evt, pointerId };
            let fireDblClick = false;
            if (Global_12.Konva["_" + eventType + "InDblClickWindow"]) {
              fireDblClick = true;
              clearTimeout(this[eventType + "DblTimeout"]);
            } else if (!DragAndDrop_12.DD.justDragged) {
              Global_12.Konva["_" + eventType + "InDblClickWindow"] = true;
              clearTimeout(this[eventType + "DblTimeout"]);
            }
            this[eventType + "DblTimeout"] = setTimeout(function() {
              Global_12.Konva["_" + eventType + "InDblClickWindow"] = false;
            }, Global_12.Konva.dblClickWindow);
            if (shape && shape.isListening()) {
              triggeredOnShape = true;
              this[eventType + "ClickEndShape"] = shape;
              shape._fireAndBubble(events.pointerup, { ...event });
              if (Global_12.Konva["_" + eventType + "ListenClick"] && clickStartShape && clickStartShape === shape) {
                shape._fireAndBubble(events.pointerclick, { ...event });
                if (fireDblClick && clickEndShape && clickEndShape === shape) {
                  shape._fireAndBubble(events.pointerdblclick, { ...event });
                }
              }
            } else {
              this[eventType + "ClickEndShape"] = null;
              if (Global_12.Konva["_" + eventType + "ListenClick"]) {
                this._fire(events.pointerclick, {
                  evt,
                  target: this,
                  currentTarget: this,
                  pointerId
                });
              }
              if (fireDblClick) {
                this._fire(events.pointerdblclick, {
                  evt,
                  target: this,
                  currentTarget: this,
                  pointerId
                });
              }
            }
          });
          if (!triggeredOnShape) {
            this._fire(events.pointerup, {
              evt,
              target: this,
              currentTarget: this,
              pointerId: this._changedPointerPositions[0].id
            });
          }
          Global_12.Konva["_" + eventType + "ListenClick"] = false;
          if (evt.cancelable && eventType !== "touch") {
            evt.preventDefault();
          }
        }
        _contextmenu(evt) {
          this.setPointersPositions(evt);
          var shape = this.getIntersection(this.getPointerPosition());
          if (shape && shape.isListening()) {
            shape._fireAndBubble(CONTEXTMENU, { evt });
          } else {
            this._fire(CONTEXTMENU, {
              evt,
              target: this,
              currentTarget: this
            });
          }
        }
        _wheel(evt) {
          this.setPointersPositions(evt);
          var shape = this.getIntersection(this.getPointerPosition());
          if (shape && shape.isListening()) {
            shape._fireAndBubble(WHEEL, { evt });
          } else {
            this._fire(WHEEL, {
              evt,
              target: this,
              currentTarget: this
            });
          }
        }
        _pointercancel(evt) {
          this.setPointersPositions(evt);
          const shape = PointerEvents$1.getCapturedShape(evt.pointerId) || this.getIntersection(this.getPointerPosition());
          if (shape) {
            shape._fireAndBubble(POINTERUP, PointerEvents$1.createEvent(evt));
          }
          PointerEvents$1.releaseCapture(evt.pointerId);
        }
        _lostpointercapture(evt) {
          PointerEvents$1.releaseCapture(evt.pointerId);
        }
        setPointersPositions(evt) {
          var contentPosition = this._getContentPosition(), x2 = null, y = null;
          evt = evt ? evt : window.event;
          if (evt.touches !== void 0) {
            this._pointerPositions = [];
            this._changedPointerPositions = [];
            Array.prototype.forEach.call(evt.touches, (touch) => {
              this._pointerPositions.push({
                id: touch.identifier,
                x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,
                y: (touch.clientY - contentPosition.top) / contentPosition.scaleY
              });
            });
            Array.prototype.forEach.call(evt.changedTouches || evt.touches, (touch) => {
              this._changedPointerPositions.push({
                id: touch.identifier,
                x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,
                y: (touch.clientY - contentPosition.top) / contentPosition.scaleY
              });
            });
          } else {
            x2 = (evt.clientX - contentPosition.left) / contentPosition.scaleX;
            y = (evt.clientY - contentPosition.top) / contentPosition.scaleY;
            this.pointerPos = {
              x: x2,
              y
            };
            this._pointerPositions = [{ x: x2, y, id: Util_12.Util._getFirstPointerId(evt) }];
            this._changedPointerPositions = [
              { x: x2, y, id: Util_12.Util._getFirstPointerId(evt) }
            ];
          }
        }
        _setPointerPosition(evt) {
          Util_12.Util.warn('Method _setPointerPosition is deprecated. Use "stage.setPointersPositions(event)" instead.');
          this.setPointersPositions(evt);
        }
        _getContentPosition() {
          if (!this.content || !this.content.getBoundingClientRect) {
            return {
              top: 0,
              left: 0,
              scaleX: 1,
              scaleY: 1
            };
          }
          var rect2 = this.content.getBoundingClientRect();
          return {
            top: rect2.top,
            left: rect2.left,
            scaleX: rect2.width / this.content.clientWidth || 1,
            scaleY: rect2.height / this.content.clientHeight || 1
          };
        }
        _buildDOM() {
          this.bufferCanvas = new Canvas_12.SceneCanvas({
            width: this.width(),
            height: this.height()
          });
          this.bufferHitCanvas = new Canvas_12.HitCanvas({
            pixelRatio: 1,
            width: this.width(),
            height: this.height()
          });
          if (!Global_12.Konva.isBrowser) {
            return;
          }
          var container = this.container();
          if (!container) {
            throw "Stage has no container. A container is required.";
          }
          container.innerHTML = "";
          this.content = document.createElement("div");
          this.content.style.position = "relative";
          this.content.style.userSelect = "none";
          this.content.className = "konvajs-content";
          this.content.setAttribute("role", "presentation");
          container.appendChild(this.content);
          this._resizeDOM();
        }
        cache() {
          Util_12.Util.warn("Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.");
          return this;
        }
        clearCache() {
          return this;
        }
        batchDraw() {
          this.getChildren().forEach(function(layer) {
            layer.batchDraw();
          });
          return this;
        }
      }
      exports2.Stage = Stage2;
      Stage2.prototype.nodeType = STAGE2;
      (0, Global_22._registerNode)(Stage2);
      Factory_12.Factory.addGetterSetter(Stage2, "container");
      if (Global_12.Konva.isBrowser) {
        document.addEventListener("visibilitychange", () => {
          exports2.stages.forEach((stage) => {
            stage.batchDraw();
          });
        });
      }
    })(Stage);
    var Layer$1 = {};
    var Shape = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Shape = exports2.shapes = void 0;
      const Global_12 = Global;
      const Util_12 = Util;
      const Factory_12 = Factory;
      const Node_12 = Node$2;
      const Validators_12 = Validators;
      const Global_22 = Global;
      const PointerEvents$1 = PointerEvents;
      var HAS_SHADOW = "hasShadow";
      var SHADOW_RGBA = "shadowRGBA";
      var patternImage = "patternImage";
      var linearGradient = "linearGradient";
      var radialGradient = "radialGradient";
      let dummyContext2;
      function getDummyContext2() {
        if (dummyContext2) {
          return dummyContext2;
        }
        dummyContext2 = Util_12.Util.createCanvasElement().getContext("2d");
        return dummyContext2;
      }
      exports2.shapes = {};
      function _fillFunc2(context) {
        const fillRule = this.attrs.fillRule;
        if (fillRule) {
          context.fill(fillRule);
        } else {
          context.fill();
        }
      }
      function _strokeFunc2(context) {
        context.stroke();
      }
      function _fillFuncHit(context) {
        const fillRule = this.attrs.fillRule;
        if (fillRule) {
          context.fill(fillRule);
        } else {
          context.fill();
        }
      }
      function _strokeFuncHit(context) {
        context.stroke();
      }
      function _clearHasShadowCache() {
        this._clearCache(HAS_SHADOW);
      }
      function _clearGetShadowRGBACache() {
        this._clearCache(SHADOW_RGBA);
      }
      function _clearFillPatternCache() {
        this._clearCache(patternImage);
      }
      function _clearLinearGradientCache() {
        this._clearCache(linearGradient);
      }
      function _clearRadialGradientCache() {
        this._clearCache(radialGradient);
      }
      class Shape2 extends Node_12.Node {
        constructor(config2) {
          super(config2);
          let key;
          while (true) {
            key = Util_12.Util.getRandomColor();
            if (key && !(key in exports2.shapes)) {
              break;
            }
          }
          this.colorKey = key;
          exports2.shapes[key] = this;
        }
        getContext() {
          Util_12.Util.warn("shape.getContext() method is deprecated. Please do not use it.");
          return this.getLayer().getContext();
        }
        getCanvas() {
          Util_12.Util.warn("shape.getCanvas() method is deprecated. Please do not use it.");
          return this.getLayer().getCanvas();
        }
        getSceneFunc() {
          return this.attrs.sceneFunc || this["_sceneFunc"];
        }
        getHitFunc() {
          return this.attrs.hitFunc || this["_hitFunc"];
        }
        hasShadow() {
          return this._getCache(HAS_SHADOW, this._hasShadow);
        }
        _hasShadow() {
          return this.shadowEnabled() && this.shadowOpacity() !== 0 && !!(this.shadowColor() || this.shadowBlur() || this.shadowOffsetX() || this.shadowOffsetY());
        }
        _getFillPattern() {
          return this._getCache(patternImage, this.__getFillPattern);
        }
        __getFillPattern() {
          if (this.fillPatternImage()) {
            var ctx = getDummyContext2();
            const pattern2 = ctx.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || "repeat");
            if (pattern2 && pattern2.setTransform) {
              const tr = new Util_12.Transform();
              tr.translate(this.fillPatternX(), this.fillPatternY());
              tr.rotate(Global_12.Konva.getAngle(this.fillPatternRotation()));
              tr.scale(this.fillPatternScaleX(), this.fillPatternScaleY());
              tr.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());
              const m = tr.getMatrix();
              const matrix = typeof DOMMatrix === "undefined" ? {
                a: m[0],
                b: m[1],
                c: m[2],
                d: m[3],
                e: m[4],
                f: m[5]
              } : new DOMMatrix(m);
              pattern2.setTransform(matrix);
            }
            return pattern2;
          }
        }
        _getLinearGradient() {
          return this._getCache(linearGradient, this.__getLinearGradient);
        }
        __getLinearGradient() {
          var colorStops = this.fillLinearGradientColorStops();
          if (colorStops) {
            var ctx = getDummyContext2();
            var start = this.fillLinearGradientStartPoint();
            var end = this.fillLinearGradientEndPoint();
            var grd = ctx.createLinearGradient(start.x, start.y, end.x, end.y);
            for (var n = 0; n < colorStops.length; n += 2) {
              grd.addColorStop(colorStops[n], colorStops[n + 1]);
            }
            return grd;
          }
        }
        _getRadialGradient() {
          return this._getCache(radialGradient, this.__getRadialGradient);
        }
        __getRadialGradient() {
          var colorStops = this.fillRadialGradientColorStops();
          if (colorStops) {
            var ctx = getDummyContext2();
            var start = this.fillRadialGradientStartPoint();
            var end = this.fillRadialGradientEndPoint();
            var grd = ctx.createRadialGradient(start.x, start.y, this.fillRadialGradientStartRadius(), end.x, end.y, this.fillRadialGradientEndRadius());
            for (var n = 0; n < colorStops.length; n += 2) {
              grd.addColorStop(colorStops[n], colorStops[n + 1]);
            }
            return grd;
          }
        }
        getShadowRGBA() {
          return this._getCache(SHADOW_RGBA, this._getShadowRGBA);
        }
        _getShadowRGBA() {
          if (!this.hasShadow()) {
            return;
          }
          var rgba2 = Util_12.Util.colorToRGBA(this.shadowColor());
          if (rgba2) {
            return "rgba(" + rgba2.r + "," + rgba2.g + "," + rgba2.b + "," + rgba2.a * (this.shadowOpacity() || 1) + ")";
          }
        }
        hasFill() {
          return this._calculate("hasFill", [
            "fillEnabled",
            "fill",
            "fillPatternImage",
            "fillLinearGradientColorStops",
            "fillRadialGradientColorStops"
          ], () => {
            return this.fillEnabled() && !!(this.fill() || this.fillPatternImage() || this.fillLinearGradientColorStops() || this.fillRadialGradientColorStops());
          });
        }
        hasStroke() {
          return this._calculate("hasStroke", [
            "strokeEnabled",
            "strokeWidth",
            "stroke",
            "strokeLinearGradientColorStops"
          ], () => {
            return this.strokeEnabled() && this.strokeWidth() && !!(this.stroke() || this.strokeLinearGradientColorStops());
          });
        }
        hasHitStroke() {
          const width = this.hitStrokeWidth();
          if (width === "auto") {
            return this.hasStroke();
          }
          return this.strokeEnabled() && !!width;
        }
        intersects(point) {
          var stage = this.getStage();
          if (!stage) {
            return false;
          }
          const bufferHitCanvas = stage.bufferHitCanvas;
          bufferHitCanvas.getContext().clear();
          this.drawHit(bufferHitCanvas, void 0, true);
          const p2 = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data;
          return p2[3] > 0;
        }
        destroy() {
          Node_12.Node.prototype.destroy.call(this);
          delete exports2.shapes[this.colorKey];
          delete this.colorKey;
          return this;
        }
        _useBufferCanvas(forceFill) {
          var _a2;
          const perfectDrawEnabled = (_a2 = this.attrs.perfectDrawEnabled) !== null && _a2 !== void 0 ? _a2 : true;
          if (!perfectDrawEnabled) {
            return false;
          }
          const hasFill = forceFill || this.hasFill();
          const hasStroke = this.hasStroke();
          const isTransparent = this.getAbsoluteOpacity() !== 1;
          if (hasFill && hasStroke && isTransparent) {
            return true;
          }
          const hasShadow = this.hasShadow();
          const strokeForShadow = this.shadowForStrokeEnabled();
          if (hasFill && hasStroke && hasShadow && strokeForShadow) {
            return true;
          }
          return false;
        }
        setStrokeHitEnabled(val) {
          Util_12.Util.warn("strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead.");
          if (val) {
            this.hitStrokeWidth("auto");
          } else {
            this.hitStrokeWidth(0);
          }
        }
        getStrokeHitEnabled() {
          if (this.hitStrokeWidth() === 0) {
            return false;
          } else {
            return true;
          }
        }
        getSelfRect() {
          var size2 = this.size();
          return {
            x: this._centroid ? -size2.width / 2 : 0,
            y: this._centroid ? -size2.height / 2 : 0,
            width: size2.width,
            height: size2.height
          };
        }
        getClientRect(config2 = {}) {
          let hasCachedParent = false;
          let parent = this.getParent();
          while (parent) {
            if (parent.isCached()) {
              hasCachedParent = true;
              break;
            }
            parent = parent.getParent();
          }
          const skipTransform = config2.skipTransform;
          const relativeTo = config2.relativeTo || hasCachedParent && this.getStage() || void 0;
          const fillRect = this.getSelfRect();
          const applyStroke = !config2.skipStroke && this.hasStroke();
          const strokeWidth = applyStroke && this.strokeWidth() || 0;
          const fillAndStrokeWidth = fillRect.width + strokeWidth;
          const fillAndStrokeHeight = fillRect.height + strokeWidth;
          const applyShadow = !config2.skipShadow && this.hasShadow();
          const shadowOffsetX = applyShadow ? this.shadowOffsetX() : 0;
          const shadowOffsetY = applyShadow ? this.shadowOffsetY() : 0;
          const preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);
          const preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);
          const blurRadius = applyShadow && this.shadowBlur() || 0;
          const width = preWidth + blurRadius * 2;
          const height = preHeight + blurRadius * 2;
          const rect2 = {
            width,
            height,
            x: -(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetX, 0) + fillRect.x,
            y: -(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetY, 0) + fillRect.y
          };
          if (!skipTransform) {
            return this._transformedRect(rect2, relativeTo);
          }
          return rect2;
        }
        drawScene(can, top2, bufferCanvas) {
          var layer = this.getLayer();
          var canvas = can || layer.getCanvas(), context = canvas.getContext(), cachedCanvas = this._getCanvasCache(), drawFunc = this.getSceneFunc(), hasShadow = this.hasShadow(), stage, bufferContext;
          var skipBuffer = canvas.isCache;
          var cachingSelf = top2 === this;
          if (!this.isVisible() && !cachingSelf) {
            return this;
          }
          if (cachedCanvas) {
            context.save();
            var m = this.getAbsoluteTransform(top2).getMatrix();
            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
            this._drawCachedSceneCanvas(context);
            context.restore();
            return this;
          }
          if (!drawFunc) {
            return this;
          }
          context.save();
          if (this._useBufferCanvas() && !skipBuffer) {
            stage = this.getStage();
            const bc = bufferCanvas || stage.bufferCanvas;
            bufferContext = bc.getContext();
            bufferContext.clear();
            bufferContext.save();
            bufferContext._applyLineJoin(this);
            var o2 = this.getAbsoluteTransform(top2).getMatrix();
            bufferContext.transform(o2[0], o2[1], o2[2], o2[3], o2[4], o2[5]);
            drawFunc.call(this, bufferContext, this);
            bufferContext.restore();
            var ratio2 = bc.pixelRatio;
            if (hasShadow) {
              context._applyShadow(this);
            }
            context._applyOpacity(this);
            context._applyGlobalCompositeOperation(this);
            context.drawImage(bc._canvas, 0, 0, bc.width / ratio2, bc.height / ratio2);
          } else {
            context._applyLineJoin(this);
            if (!cachingSelf) {
              var o2 = this.getAbsoluteTransform(top2).getMatrix();
              context.transform(o2[0], o2[1], o2[2], o2[3], o2[4], o2[5]);
              context._applyOpacity(this);
              context._applyGlobalCompositeOperation(this);
            }
            if (hasShadow) {
              context._applyShadow(this);
            }
            drawFunc.call(this, context, this);
          }
          context.restore();
          return this;
        }
        drawHit(can, top2, skipDragCheck = false) {
          if (!this.shouldDrawHit(top2, skipDragCheck)) {
            return this;
          }
          var layer = this.getLayer(), canvas = can || layer.hitCanvas, context = canvas && canvas.getContext(), drawFunc = this.hitFunc() || this.sceneFunc(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;
          if (!this.colorKey) {
            Util_12.Util.warn("Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()");
          }
          if (cachedHitCanvas) {
            context.save();
            var m = this.getAbsoluteTransform(top2).getMatrix();
            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
            this._drawCachedHitCanvas(context);
            context.restore();
            return this;
          }
          if (!drawFunc) {
            return this;
          }
          context.save();
          context._applyLineJoin(this);
          const selfCache = this === top2;
          if (!selfCache) {
            var o2 = this.getAbsoluteTransform(top2).getMatrix();
            context.transform(o2[0], o2[1], o2[2], o2[3], o2[4], o2[5]);
          }
          drawFunc.call(this, context, this);
          context.restore();
          return this;
        }
        drawHitFromCache(alphaThreshold = 0) {
          var cachedCanvas = this._getCanvasCache(), sceneCanvas = this._getCachedSceneCanvas(), hitCanvas = cachedCanvas.hit, hitContext = hitCanvas.getContext(), hitWidth = hitCanvas.getWidth(), hitHeight = hitCanvas.getHeight(), hitImageData, hitData, len, rgbColorKey, i2, alpha2;
          hitContext.clear();
          hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);
          try {
            hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);
            hitData = hitImageData.data;
            len = hitData.length;
            rgbColorKey = Util_12.Util._hexToRgb(this.colorKey);
            for (i2 = 0; i2 < len; i2 += 4) {
              alpha2 = hitData[i2 + 3];
              if (alpha2 > alphaThreshold) {
                hitData[i2] = rgbColorKey.r;
                hitData[i2 + 1] = rgbColorKey.g;
                hitData[i2 + 2] = rgbColorKey.b;
                hitData[i2 + 3] = 255;
              } else {
                hitData[i2 + 3] = 0;
              }
            }
            hitContext.putImageData(hitImageData, 0, 0);
          } catch (e) {
            Util_12.Util.error("Unable to draw hit graph from cached scene canvas. " + e.message);
          }
          return this;
        }
        hasPointerCapture(pointerId) {
          return PointerEvents$1.hasPointerCapture(pointerId, this);
        }
        setPointerCapture(pointerId) {
          PointerEvents$1.setPointerCapture(pointerId, this);
        }
        releaseCapture(pointerId) {
          PointerEvents$1.releaseCapture(pointerId, this);
        }
      }
      exports2.Shape = Shape2;
      Shape2.prototype._fillFunc = _fillFunc2;
      Shape2.prototype._strokeFunc = _strokeFunc2;
      Shape2.prototype._fillFuncHit = _fillFuncHit;
      Shape2.prototype._strokeFuncHit = _strokeFuncHit;
      Shape2.prototype._centroid = false;
      Shape2.prototype.nodeType = "Shape";
      (0, Global_22._registerNode)(Shape2);
      Shape2.prototype.eventListeners = {};
      Shape2.prototype.on.call(Shape2.prototype, "shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", _clearHasShadowCache);
      Shape2.prototype.on.call(Shape2.prototype, "shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", _clearGetShadowRGBACache);
      Shape2.prototype.on.call(Shape2.prototype, "fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva", _clearFillPatternCache);
      Shape2.prototype.on.call(Shape2.prototype, "fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva", _clearLinearGradientCache);
      Shape2.prototype.on.call(Shape2.prototype, "fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva", _clearRadialGradientCache);
      Factory_12.Factory.addGetterSetter(Shape2, "stroke", void 0, (0, Validators_12.getStringOrGradientValidator)());
      Factory_12.Factory.addGetterSetter(Shape2, "strokeWidth", 2, (0, Validators_12.getNumberValidator)());
      Factory_12.Factory.addGetterSetter(Shape2, "fillAfterStrokeEnabled", false);
      Factory_12.Factory.addGetterSetter(Shape2, "hitStrokeWidth", "auto", (0, Validators_12.getNumberOrAutoValidator)());
      Factory_12.Factory.addGetterSetter(Shape2, "strokeHitEnabled", true, (0, Validators_12.getBooleanValidator)());
      Factory_12.Factory.addGetterSetter(Shape2, "perfectDrawEnabled", true, (0, Validators_12.getBooleanValidator)());
      Factory_12.Factory.addGetterSetter(Shape2, "shadowForStrokeEnabled", true, (0, Validators_12.getBooleanValidator)());
      Factory_12.Factory.addGetterSetter(Shape2, "lineJoin");
      Factory_12.Factory.addGetterSetter(Shape2, "lineCap");
      Factory_12.Factory.addGetterSetter(Shape2, "sceneFunc");
      Factory_12.Factory.addGetterSetter(Shape2, "hitFunc");
      Factory_12.Factory.addGetterSetter(Shape2, "dash");
      Factory_12.Factory.addGetterSetter(Shape2, "dashOffset", 0, (0, Validators_12.getNumberValidator)());
      Factory_12.Factory.addGetterSetter(Shape2, "shadowColor", void 0, (0, Validators_12.getStringValidator)());
      Factory_12.Factory.addGetterSetter(Shape2, "shadowBlur", 0, (0, Validators_12.getNumberValidator)());
      Factory_12.Factory.addGetterSetter(Shape2, "shadowOpacity", 1, (0, Validators_12.getNumberValidator)());
      Factory_12.Factory.addComponentsGetterSetter(Shape2, "shadowOffset", ["x", "y"]);
      Factory_12.Factory.addGetterSetter(Shape2, "shadowOffsetX", 0, (0, Validators_12.getNumberValidator)());
      Factory_12.Factory.addGetterSetter(Shape2, "shadowOffsetY", 0, (0, Validators_12.getNumberValidator)());
      Factory_12.Factory.addGetterSetter(Shape2, "fillPatternImage");
      Factory_12.Factory.addGetterSetter(Shape2, "fill", void 0, (0, Validators_12.getStringOrGradientValidator)());
      Factory_12.Factory.addGetterSetter(Shape2, "fillPatternX", 0, (0, Validators_12.getNumberValidator)());
      Factory_12.Factory.addGetterSetter(Shape2, "fillPatternY", 0, (0, Validators_12.getNumberValidator)());
      Factory_12.Factory.addGetterSetter(Shape2, "fillLinearGradientColorStops");
      Factory_12.Factory.addGetterSetter(Shape2, "strokeLinearGradientColorStops");
      Factory_12.Factory.addGetterSetter(Shape2, "fillRadialGradientStartRadius", 0);
      Factory_12.Factory.addGetterSetter(Shape2, "fillRadialGradientEndRadius", 0);
      Factory_12.Factory.addGetterSetter(Shape2, "fillRadialGradientColorStops");
      Factory_12.Factory.addGetterSetter(Shape2, "fillPatternRepeat", "repeat");
      Factory_12.Factory.addGetterSetter(Shape2, "fillEnabled", true);
      Factory_12.Factory.addGetterSetter(Shape2, "strokeEnabled", true);
      Factory_12.Factory.addGetterSetter(Shape2, "shadowEnabled", true);
      Factory_12.Factory.addGetterSetter(Shape2, "dashEnabled", true);
      Factory_12.Factory.addGetterSetter(Shape2, "strokeScaleEnabled", true);
      Factory_12.Factory.addGetterSetter(Shape2, "fillPriority", "color");
      Factory_12.Factory.addComponentsGetterSetter(Shape2, "fillPatternOffset", ["x", "y"]);
      Factory_12.Factory.addGetterSetter(Shape2, "fillPatternOffsetX", 0, (0, Validators_12.getNumberValidator)());
      Factory_12.Factory.addGetterSetter(Shape2, "fillPatternOffsetY", 0, (0, Validators_12.getNumberValidator)());
      Factory_12.Factory.addComponentsGetterSetter(Shape2, "fillPatternScale", ["x", "y"]);
      Factory_12.Factory.addGetterSetter(Shape2, "fillPatternScaleX", 1, (0, Validators_12.getNumberValidator)());
      Factory_12.Factory.addGetterSetter(Shape2, "fillPatternScaleY", 1, (0, Validators_12.getNumberValidator)());
      Factory_12.Factory.addComponentsGetterSetter(Shape2, "fillLinearGradientStartPoint", [
        "x",
        "y"
      ]);
      Factory_12.Factory.addComponentsGetterSetter(Shape2, "strokeLinearGradientStartPoint", [
        "x",
        "y"
      ]);
      Factory_12.Factory.addGetterSetter(Shape2, "fillLinearGradientStartPointX", 0);
      Factory_12.Factory.addGetterSetter(Shape2, "strokeLinearGradientStartPointX", 0);
      Factory_12.Factory.addGetterSetter(Shape2, "fillLinearGradientStartPointY", 0);
      Factory_12.Factory.addGetterSetter(Shape2, "strokeLinearGradientStartPointY", 0);
      Factory_12.Factory.addComponentsGetterSetter(Shape2, "fillLinearGradientEndPoint", [
        "x",
        "y"
      ]);
      Factory_12.Factory.addComponentsGetterSetter(Shape2, "strokeLinearGradientEndPoint", [
        "x",
        "y"
      ]);
      Factory_12.Factory.addGetterSetter(Shape2, "fillLinearGradientEndPointX", 0);
      Factory_12.Factory.addGetterSetter(Shape2, "strokeLinearGradientEndPointX", 0);
      Factory_12.Factory.addGetterSetter(Shape2, "fillLinearGradientEndPointY", 0);
      Factory_12.Factory.addGetterSetter(Shape2, "strokeLinearGradientEndPointY", 0);
      Factory_12.Factory.addComponentsGetterSetter(Shape2, "fillRadialGradientStartPoint", [
        "x",
        "y"
      ]);
      Factory_12.Factory.addGetterSetter(Shape2, "fillRadialGradientStartPointX", 0);
      Factory_12.Factory.addGetterSetter(Shape2, "fillRadialGradientStartPointY", 0);
      Factory_12.Factory.addComponentsGetterSetter(Shape2, "fillRadialGradientEndPoint", [
        "x",
        "y"
      ]);
      Factory_12.Factory.addGetterSetter(Shape2, "fillRadialGradientEndPointX", 0);
      Factory_12.Factory.addGetterSetter(Shape2, "fillRadialGradientEndPointY", 0);
      Factory_12.Factory.addGetterSetter(Shape2, "fillPatternRotation", 0);
      Factory_12.Factory.addGetterSetter(Shape2, "fillRule", void 0, (0, Validators_12.getStringValidator)());
      Factory_12.Factory.backCompat(Shape2, {
        dashArray: "dash",
        getDashArray: "getDash",
        setDashArray: "getDash",
        drawFunc: "sceneFunc",
        getDrawFunc: "getSceneFunc",
        setDrawFunc: "setSceneFunc",
        drawHitFunc: "hitFunc",
        getDrawHitFunc: "getHitFunc",
        setDrawHitFunc: "setHitFunc"
      });
    })(Shape);
    Object.defineProperty(Layer$1, "__esModule", { value: true });
    Layer$1.Layer = void 0;
    const Util_1$b = Util;
    const Container_1$1 = Container$1;
    const Node_1$g = Node$2;
    const Factory_1$w = Factory;
    const Canvas_1 = Canvas$1;
    const Validators_1$v = Validators;
    const Shape_1$g = Shape;
    const Global_1$k = Global;
    var HASH = "#", BEFORE_DRAW = "beforeDraw", DRAW = "draw", INTERSECTION_OFFSETS = [
      { x: 0, y: 0 },
      { x: -1, y: -1 },
      { x: 1, y: -1 },
      { x: 1, y: 1 },
      { x: -1, y: 1 }
    ], INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;
    class Layer extends Container_1$1.Container {
      constructor(config2) {
        super(config2);
        this.canvas = new Canvas_1.SceneCanvas();
        this.hitCanvas = new Canvas_1.HitCanvas({
          pixelRatio: 1
        });
        this._waitingForDraw = false;
        this.on("visibleChange.konva", this._checkVisibility);
        this._checkVisibility();
        this.on("imageSmoothingEnabledChange.konva", this._setSmoothEnabled);
        this._setSmoothEnabled();
      }
      createPNGStream() {
        const c = this.canvas._canvas;
        return c.createPNGStream();
      }
      getCanvas() {
        return this.canvas;
      }
      getNativeCanvasElement() {
        return this.canvas._canvas;
      }
      getHitCanvas() {
        return this.hitCanvas;
      }
      getContext() {
        return this.getCanvas().getContext();
      }
      clear(bounds) {
        this.getContext().clear(bounds);
        this.getHitCanvas().getContext().clear(bounds);
        return this;
      }
      setZIndex(index) {
        super.setZIndex(index);
        var stage = this.getStage();
        if (stage && stage.content) {
          stage.content.removeChild(this.getNativeCanvasElement());
          if (index < stage.children.length - 1) {
            stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[index + 1].getCanvas()._canvas);
          } else {
            stage.content.appendChild(this.getNativeCanvasElement());
          }
        }
        return this;
      }
      moveToTop() {
        Node_1$g.Node.prototype.moveToTop.call(this);
        var stage = this.getStage();
        if (stage && stage.content) {
          stage.content.removeChild(this.getNativeCanvasElement());
          stage.content.appendChild(this.getNativeCanvasElement());
        }
        return true;
      }
      moveUp() {
        var moved = Node_1$g.Node.prototype.moveUp.call(this);
        if (!moved) {
          return false;
        }
        var stage = this.getStage();
        if (!stage || !stage.content) {
          return false;
        }
        stage.content.removeChild(this.getNativeCanvasElement());
        if (this.index < stage.children.length - 1) {
          stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[this.index + 1].getCanvas()._canvas);
        } else {
          stage.content.appendChild(this.getNativeCanvasElement());
        }
        return true;
      }
      moveDown() {
        if (Node_1$g.Node.prototype.moveDown.call(this)) {
          var stage = this.getStage();
          if (stage) {
            var children = stage.children;
            if (stage.content) {
              stage.content.removeChild(this.getNativeCanvasElement());
              stage.content.insertBefore(this.getNativeCanvasElement(), children[this.index + 1].getCanvas()._canvas);
            }
          }
          return true;
        }
        return false;
      }
      moveToBottom() {
        if (Node_1$g.Node.prototype.moveToBottom.call(this)) {
          var stage = this.getStage();
          if (stage) {
            var children = stage.children;
            if (stage.content) {
              stage.content.removeChild(this.getNativeCanvasElement());
              stage.content.insertBefore(this.getNativeCanvasElement(), children[1].getCanvas()._canvas);
            }
          }
          return true;
        }
        return false;
      }
      getLayer() {
        return this;
      }
      remove() {
        var _canvas = this.getNativeCanvasElement();
        Node_1$g.Node.prototype.remove.call(this);
        if (_canvas && _canvas.parentNode && Util_1$b.Util._isInDocument(_canvas)) {
          _canvas.parentNode.removeChild(_canvas);
        }
        return this;
      }
      getStage() {
        return this.parent;
      }
      setSize({ width, height }) {
        this.canvas.setSize(width, height);
        this.hitCanvas.setSize(width, height);
        this._setSmoothEnabled();
        return this;
      }
      _validateAdd(child) {
        var type2 = child.getType();
        if (type2 !== "Group" && type2 !== "Shape") {
          Util_1$b.Util.throw("You may only add groups and shapes to a layer.");
        }
      }
      _toKonvaCanvas(config2) {
        config2 = config2 || {};
        config2.width = config2.width || this.getWidth();
        config2.height = config2.height || this.getHeight();
        config2.x = config2.x !== void 0 ? config2.x : this.x();
        config2.y = config2.y !== void 0 ? config2.y : this.y();
        return Node_1$g.Node.prototype._toKonvaCanvas.call(this, config2);
      }
      _checkVisibility() {
        const visible = this.visible();
        if (visible) {
          this.canvas._canvas.style.display = "block";
        } else {
          this.canvas._canvas.style.display = "none";
        }
      }
      _setSmoothEnabled() {
        this.getContext()._context.imageSmoothingEnabled = this.imageSmoothingEnabled();
      }
      getWidth() {
        if (this.parent) {
          return this.parent.width();
        }
      }
      setWidth() {
        Util_1$b.Util.warn('Can not change width of layer. Use "stage.width(value)" function instead.');
      }
      getHeight() {
        if (this.parent) {
          return this.parent.height();
        }
      }
      setHeight() {
        Util_1$b.Util.warn('Can not change height of layer. Use "stage.height(value)" function instead.');
      }
      batchDraw() {
        if (!this._waitingForDraw) {
          this._waitingForDraw = true;
          Util_1$b.Util.requestAnimFrame(() => {
            this.draw();
            this._waitingForDraw = false;
          });
        }
        return this;
      }
      getIntersection(pos) {
        if (!this.isListening() || !this.isVisible()) {
          return null;
        }
        var spiralSearchDistance = 1;
        var continueSearch = false;
        while (true) {
          for (let i2 = 0; i2 < INTERSECTION_OFFSETS_LEN; i2++) {
            const intersectionOffset = INTERSECTION_OFFSETS[i2];
            const obj = this._getIntersection({
              x: pos.x + intersectionOffset.x * spiralSearchDistance,
              y: pos.y + intersectionOffset.y * spiralSearchDistance
            });
            const shape = obj.shape;
            if (shape) {
              return shape;
            }
            continueSearch = !!obj.antialiased;
            if (!obj.antialiased) {
              break;
            }
          }
          if (continueSearch) {
            spiralSearchDistance += 1;
          } else {
            return null;
          }
        }
      }
      _getIntersection(pos) {
        const ratio2 = this.hitCanvas.pixelRatio;
        const p2 = this.hitCanvas.context.getImageData(Math.round(pos.x * ratio2), Math.round(pos.y * ratio2), 1, 1).data;
        const p3 = p2[3];
        if (p3 === 255) {
          const colorKey = Util_1$b.Util._rgbToHex(p2[0], p2[1], p2[2]);
          const shape = Shape_1$g.shapes[HASH + colorKey];
          if (shape) {
            return {
              shape
            };
          }
          return {
            antialiased: true
          };
        } else if (p3 > 0) {
          return {
            antialiased: true
          };
        }
        return {};
      }
      drawScene(can, top2) {
        var layer = this.getLayer(), canvas = can || layer && layer.getCanvas();
        this._fire(BEFORE_DRAW, {
          node: this
        });
        if (this.clearBeforeDraw()) {
          canvas.getContext().clear();
        }
        Container_1$1.Container.prototype.drawScene.call(this, canvas, top2);
        this._fire(DRAW, {
          node: this
        });
        return this;
      }
      drawHit(can, top2) {
        var layer = this.getLayer(), canvas = can || layer && layer.hitCanvas;
        if (layer && layer.clearBeforeDraw()) {
          layer.getHitCanvas().getContext().clear();
        }
        Container_1$1.Container.prototype.drawHit.call(this, canvas, top2);
        return this;
      }
      enableHitGraph() {
        this.hitGraphEnabled(true);
        return this;
      }
      disableHitGraph() {
        this.hitGraphEnabled(false);
        return this;
      }
      setHitGraphEnabled(val) {
        Util_1$b.Util.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead.");
        this.listening(val);
      }
      getHitGraphEnabled(val) {
        Util_1$b.Util.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead.");
        return this.listening();
      }
      toggleHitCanvas() {
        if (!this.parent || !this.parent["content"]) {
          return;
        }
        var parent = this.parent;
        var added = !!this.hitCanvas._canvas.parentNode;
        if (added) {
          parent.content.removeChild(this.hitCanvas._canvas);
        } else {
          parent.content.appendChild(this.hitCanvas._canvas);
        }
      }
      destroy() {
        Util_1$b.Util.releaseCanvas(this.getNativeCanvasElement(), this.getHitCanvas()._canvas);
        return super.destroy();
      }
    }
    Layer$1.Layer = Layer;
    Layer.prototype.nodeType = "Layer";
    (0, Global_1$k._registerNode)(Layer);
    Factory_1$w.Factory.addGetterSetter(Layer, "imageSmoothingEnabled", true);
    Factory_1$w.Factory.addGetterSetter(Layer, "clearBeforeDraw", true);
    Factory_1$w.Factory.addGetterSetter(Layer, "hitGraphEnabled", true, (0, Validators_1$v.getBooleanValidator)());
    var FastLayer$1 = {};
    Object.defineProperty(FastLayer$1, "__esModule", { value: true });
    FastLayer$1.FastLayer = void 0;
    const Util_1$a = Util;
    const Layer_1 = Layer$1;
    const Global_1$j = Global;
    class FastLayer extends Layer_1.Layer {
      constructor(attrs) {
        super(attrs);
        this.listening(false);
        Util_1$a.Util.warn('Konva.Fast layer is deprecated. Please use "new Konva.Layer({ listening: false })" instead.');
      }
    }
    FastLayer$1.FastLayer = FastLayer;
    FastLayer.prototype.nodeType = "FastLayer";
    (0, Global_1$j._registerNode)(FastLayer);
    var Group$1 = {};
    Object.defineProperty(Group$1, "__esModule", { value: true });
    Group$1.Group = void 0;
    const Util_1$9 = Util;
    const Container_1 = Container$1;
    const Global_1$i = Global;
    class Group extends Container_1.Container {
      _validateAdd(child) {
        var type2 = child.getType();
        if (type2 !== "Group" && type2 !== "Shape") {
          Util_1$9.Util.throw("You may only add groups and shapes to groups.");
        }
      }
    }
    Group$1.Group = Group;
    Group.prototype.nodeType = "Group";
    (0, Global_1$i._registerNode)(Group);
    var Animation$1 = {};
    Object.defineProperty(Animation$1, "__esModule", { value: true });
    Animation$1.Animation = void 0;
    const Global_1$h = Global;
    const Util_1$8 = Util;
    const now = function() {
      if (Global_1$h.glob.performance && Global_1$h.glob.performance.now) {
        return function() {
          return Global_1$h.glob.performance.now();
        };
      }
      return function() {
        return (/* @__PURE__ */ new Date()).getTime();
      };
    }();
    class Animation {
      constructor(func, layers) {
        this.id = Animation.animIdCounter++;
        this.frame = {
          time: 0,
          timeDiff: 0,
          lastTime: now(),
          frameRate: 0
        };
        this.func = func;
        this.setLayers(layers);
      }
      setLayers(layers) {
        let lays = [];
        if (layers) {
          lays = Array.isArray(layers) ? layers : [layers];
        }
        this.layers = lays;
        return this;
      }
      getLayers() {
        return this.layers;
      }
      addLayer(layer) {
        const layers = this.layers;
        const len = layers.length;
        for (let n = 0; n < len; n++) {
          if (layers[n]._id === layer._id) {
            return false;
          }
        }
        this.layers.push(layer);
        return true;
      }
      isRunning() {
        const a = Animation;
        const animations = a.animations;
        const len = animations.length;
        for (let n = 0; n < len; n++) {
          if (animations[n].id === this.id) {
            return true;
          }
        }
        return false;
      }
      start() {
        this.stop();
        this.frame.timeDiff = 0;
        this.frame.lastTime = now();
        Animation._addAnimation(this);
        return this;
      }
      stop() {
        Animation._removeAnimation(this);
        return this;
      }
      _updateFrameObject(time) {
        this.frame.timeDiff = time - this.frame.lastTime;
        this.frame.lastTime = time;
        this.frame.time += this.frame.timeDiff;
        this.frame.frameRate = 1e3 / this.frame.timeDiff;
      }
      static _addAnimation(anim) {
        this.animations.push(anim);
        this._handleAnimation();
      }
      static _removeAnimation(anim) {
        const id2 = anim.id;
        const animations = this.animations;
        const len = animations.length;
        for (let n = 0; n < len; n++) {
          if (animations[n].id === id2) {
            this.animations.splice(n, 1);
            break;
          }
        }
      }
      static _runFrames() {
        const layerHash = {};
        const animations = this.animations;
        for (let n = 0; n < animations.length; n++) {
          const anim = animations[n];
          const layers = anim.layers;
          const func = anim.func;
          anim._updateFrameObject(now());
          const layersLen = layers.length;
          let needRedraw;
          if (func) {
            needRedraw = func.call(anim, anim.frame) !== false;
          } else {
            needRedraw = true;
          }
          if (!needRedraw) {
            continue;
          }
          for (let i2 = 0; i2 < layersLen; i2++) {
            const layer = layers[i2];
            if (layer._id !== void 0) {
              layerHash[layer._id] = layer;
            }
          }
        }
        for (let key in layerHash) {
          if (!layerHash.hasOwnProperty(key)) {
            continue;
          }
          layerHash[key].batchDraw();
        }
      }
      static _animationLoop() {
        const Anim = Animation;
        if (Anim.animations.length) {
          Anim._runFrames();
          Util_1$8.Util.requestAnimFrame(Anim._animationLoop);
        } else {
          Anim.animRunning = false;
        }
      }
      static _handleAnimation() {
        if (!this.animRunning) {
          this.animRunning = true;
          Util_1$8.Util.requestAnimFrame(this._animationLoop);
        }
      }
    }
    Animation$1.Animation = Animation;
    Animation.animations = [];
    Animation.animIdCounter = 0;
    Animation.animRunning = false;
    var Tween = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Easings = exports2.Tween = void 0;
      const Util_12 = Util;
      const Animation_12 = Animation$1;
      const Node_12 = Node$2;
      const Global_12 = Global;
      var blacklist = {
        node: 1,
        duration: 1,
        easing: 1,
        onFinish: 1,
        yoyo: 1
      }, PAUSED = 1, PLAYING = 2, REVERSING = 3, idCounter2 = 0, colorAttrs = ["fill", "stroke", "shadowColor"];
      class TweenEngine {
        constructor(prop2, propFunc, func, begin, finish, duration, yoyo) {
          this.prop = prop2;
          this.propFunc = propFunc;
          this.begin = begin;
          this._pos = begin;
          this.duration = duration;
          this._change = 0;
          this.prevPos = 0;
          this.yoyo = yoyo;
          this._time = 0;
          this._position = 0;
          this._startTime = 0;
          this._finish = 0;
          this.func = func;
          this._change = finish - this.begin;
          this.pause();
        }
        fire(str2) {
          var handler = this[str2];
          if (handler) {
            handler();
          }
        }
        setTime(t) {
          if (t > this.duration) {
            if (this.yoyo) {
              this._time = this.duration;
              this.reverse();
            } else {
              this.finish();
            }
          } else if (t < 0) {
            if (this.yoyo) {
              this._time = 0;
              this.play();
            } else {
              this.reset();
            }
          } else {
            this._time = t;
            this.update();
          }
        }
        getTime() {
          return this._time;
        }
        setPosition(p2) {
          this.prevPos = this._pos;
          this.propFunc(p2);
          this._pos = p2;
        }
        getPosition(t) {
          if (t === void 0) {
            t = this._time;
          }
          return this.func(t, this.begin, this._change, this.duration);
        }
        play() {
          this.state = PLAYING;
          this._startTime = this.getTimer() - this._time;
          this.onEnterFrame();
          this.fire("onPlay");
        }
        reverse() {
          this.state = REVERSING;
          this._time = this.duration - this._time;
          this._startTime = this.getTimer() - this._time;
          this.onEnterFrame();
          this.fire("onReverse");
        }
        seek(t) {
          this.pause();
          this._time = t;
          this.update();
          this.fire("onSeek");
        }
        reset() {
          this.pause();
          this._time = 0;
          this.update();
          this.fire("onReset");
        }
        finish() {
          this.pause();
          this._time = this.duration;
          this.update();
          this.fire("onFinish");
        }
        update() {
          this.setPosition(this.getPosition(this._time));
          this.fire("onUpdate");
        }
        onEnterFrame() {
          var t = this.getTimer() - this._startTime;
          if (this.state === PLAYING) {
            this.setTime(t);
          } else if (this.state === REVERSING) {
            this.setTime(this.duration - t);
          }
        }
        pause() {
          this.state = PAUSED;
          this.fire("onPause");
        }
        getTimer() {
          return (/* @__PURE__ */ new Date()).getTime();
        }
      }
      class Tween2 {
        constructor(config2) {
          var that = this, node = config2.node, nodeId = node._id, duration, easing = config2.easing || exports2.Easings.Linear, yoyo = !!config2.yoyo, key;
          if (typeof config2.duration === "undefined") {
            duration = 0.3;
          } else if (config2.duration === 0) {
            duration = 1e-3;
          } else {
            duration = config2.duration;
          }
          this.node = node;
          this._id = idCounter2++;
          var layers = node.getLayer() || (node instanceof Global_12.Konva["Stage"] ? node.getLayers() : null);
          if (!layers) {
            Util_12.Util.error("Tween constructor have `node` that is not in a layer. Please add node into layer first.");
          }
          this.anim = new Animation_12.Animation(function() {
            that.tween.onEnterFrame();
          }, layers);
          this.tween = new TweenEngine(key, function(i2) {
            that._tweenFunc(i2);
          }, easing, 0, 1, duration * 1e3, yoyo);
          this._addListeners();
          if (!Tween2.attrs[nodeId]) {
            Tween2.attrs[nodeId] = {};
          }
          if (!Tween2.attrs[nodeId][this._id]) {
            Tween2.attrs[nodeId][this._id] = {};
          }
          if (!Tween2.tweens[nodeId]) {
            Tween2.tweens[nodeId] = {};
          }
          for (key in config2) {
            if (blacklist[key] === void 0) {
              this._addAttr(key, config2[key]);
            }
          }
          this.reset();
          this.onFinish = config2.onFinish;
          this.onReset = config2.onReset;
          this.onUpdate = config2.onUpdate;
        }
        _addAttr(key, end) {
          var node = this.node, nodeId = node._id, start, diff, tweenId, n, len, trueEnd, trueStart, endRGBA;
          tweenId = Tween2.tweens[nodeId][key];
          if (tweenId) {
            delete Tween2.attrs[nodeId][tweenId][key];
          }
          start = node.getAttr(key);
          if (Util_12.Util._isArray(end)) {
            diff = [];
            len = Math.max(end.length, start.length);
            if (key === "points" && end.length !== start.length) {
              if (end.length > start.length) {
                trueStart = start;
                start = Util_12.Util._prepareArrayForTween(start, end, node.closed());
              } else {
                trueEnd = end;
                end = Util_12.Util._prepareArrayForTween(end, start, node.closed());
              }
            }
            if (key.indexOf("fill") === 0) {
              for (n = 0; n < len; n++) {
                if (n % 2 === 0) {
                  diff.push(end[n] - start[n]);
                } else {
                  var startRGBA = Util_12.Util.colorToRGBA(start[n]);
                  endRGBA = Util_12.Util.colorToRGBA(end[n]);
                  start[n] = startRGBA;
                  diff.push({
                    r: endRGBA.r - startRGBA.r,
                    g: endRGBA.g - startRGBA.g,
                    b: endRGBA.b - startRGBA.b,
                    a: endRGBA.a - startRGBA.a
                  });
                }
              }
            } else {
              for (n = 0; n < len; n++) {
                diff.push(end[n] - start[n]);
              }
            }
          } else if (colorAttrs.indexOf(key) !== -1) {
            start = Util_12.Util.colorToRGBA(start);
            endRGBA = Util_12.Util.colorToRGBA(end);
            diff = {
              r: endRGBA.r - start.r,
              g: endRGBA.g - start.g,
              b: endRGBA.b - start.b,
              a: endRGBA.a - start.a
            };
          } else {
            diff = end - start;
          }
          Tween2.attrs[nodeId][this._id][key] = {
            start,
            diff,
            end,
            trueEnd,
            trueStart
          };
          Tween2.tweens[nodeId][key] = this._id;
        }
        _tweenFunc(i2) {
          var node = this.node, attrs = Tween2.attrs[node._id][this._id], key, attr, start, diff, newVal, n, len, end;
          for (key in attrs) {
            attr = attrs[key];
            start = attr.start;
            diff = attr.diff;
            end = attr.end;
            if (Util_12.Util._isArray(start)) {
              newVal = [];
              len = Math.max(start.length, end.length);
              if (key.indexOf("fill") === 0) {
                for (n = 0; n < len; n++) {
                  if (n % 2 === 0) {
                    newVal.push((start[n] || 0) + diff[n] * i2);
                  } else {
                    newVal.push("rgba(" + Math.round(start[n].r + diff[n].r * i2) + "," + Math.round(start[n].g + diff[n].g * i2) + "," + Math.round(start[n].b + diff[n].b * i2) + "," + (start[n].a + diff[n].a * i2) + ")");
                  }
                }
              } else {
                for (n = 0; n < len; n++) {
                  newVal.push((start[n] || 0) + diff[n] * i2);
                }
              }
            } else if (colorAttrs.indexOf(key) !== -1) {
              newVal = "rgba(" + Math.round(start.r + diff.r * i2) + "," + Math.round(start.g + diff.g * i2) + "," + Math.round(start.b + diff.b * i2) + "," + (start.a + diff.a * i2) + ")";
            } else {
              newVal = start + diff * i2;
            }
            node.setAttr(key, newVal);
          }
        }
        _addListeners() {
          this.tween.onPlay = () => {
            this.anim.start();
          };
          this.tween.onReverse = () => {
            this.anim.start();
          };
          this.tween.onPause = () => {
            this.anim.stop();
          };
          this.tween.onFinish = () => {
            var node = this.node;
            var attrs = Tween2.attrs[node._id][this._id];
            if (attrs.points && attrs.points.trueEnd) {
              node.setAttr("points", attrs.points.trueEnd);
            }
            if (this.onFinish) {
              this.onFinish.call(this);
            }
          };
          this.tween.onReset = () => {
            var node = this.node;
            var attrs = Tween2.attrs[node._id][this._id];
            if (attrs.points && attrs.points.trueStart) {
              node.points(attrs.points.trueStart);
            }
            if (this.onReset) {
              this.onReset();
            }
          };
          this.tween.onUpdate = () => {
            if (this.onUpdate) {
              this.onUpdate.call(this);
            }
          };
        }
        play() {
          this.tween.play();
          return this;
        }
        reverse() {
          this.tween.reverse();
          return this;
        }
        reset() {
          this.tween.reset();
          return this;
        }
        seek(t) {
          this.tween.seek(t * 1e3);
          return this;
        }
        pause() {
          this.tween.pause();
          return this;
        }
        finish() {
          this.tween.finish();
          return this;
        }
        destroy() {
          var nodeId = this.node._id, thisId = this._id, attrs = Tween2.tweens[nodeId], key;
          this.pause();
          for (key in attrs) {
            delete Tween2.tweens[nodeId][key];
          }
          delete Tween2.attrs[nodeId][thisId];
        }
      }
      exports2.Tween = Tween2;
      Tween2.attrs = {};
      Tween2.tweens = {};
      Node_12.Node.prototype.to = function(params) {
        var onFinish = params.onFinish;
        params.node = this;
        params.onFinish = function() {
          this.destroy();
          if (onFinish) {
            onFinish();
          }
        };
        var tween = new Tween2(params);
        tween.play();
      };
      exports2.Easings = {
        BackEaseIn(t, b, c, d) {
          var s = 1.70158;
          return c * (t /= d) * t * ((s + 1) * t - s) + b;
        },
        BackEaseOut(t, b, c, d) {
          var s = 1.70158;
          return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
        },
        BackEaseInOut(t, b, c, d) {
          var s = 1.70158;
          if ((t /= d / 2) < 1) {
            return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
          }
          return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
        },
        ElasticEaseIn(t, b, c, d, a, p2) {
          var s = 0;
          if (t === 0) {
            return b;
          }
          if ((t /= d) === 1) {
            return b + c;
          }
          if (!p2) {
            p2 = d * 0.3;
          }
          if (!a || a < Math.abs(c)) {
            a = c;
            s = p2 / 4;
          } else {
            s = p2 / (2 * Math.PI) * Math.asin(c / a);
          }
          return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p2)) + b;
        },
        ElasticEaseOut(t, b, c, d, a, p2) {
          var s = 0;
          if (t === 0) {
            return b;
          }
          if ((t /= d) === 1) {
            return b + c;
          }
          if (!p2) {
            p2 = d * 0.3;
          }
          if (!a || a < Math.abs(c)) {
            a = c;
            s = p2 / 4;
          } else {
            s = p2 / (2 * Math.PI) * Math.asin(c / a);
          }
          return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p2) + c + b;
        },
        ElasticEaseInOut(t, b, c, d, a, p2) {
          var s = 0;
          if (t === 0) {
            return b;
          }
          if ((t /= d / 2) === 2) {
            return b + c;
          }
          if (!p2) {
            p2 = d * (0.3 * 1.5);
          }
          if (!a || a < Math.abs(c)) {
            a = c;
            s = p2 / 4;
          } else {
            s = p2 / (2 * Math.PI) * Math.asin(c / a);
          }
          if (t < 1) {
            return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p2)) + b;
          }
          return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p2) * 0.5 + c + b;
        },
        BounceEaseOut(t, b, c, d) {
          if ((t /= d) < 1 / 2.75) {
            return c * (7.5625 * t * t) + b;
          } else if (t < 2 / 2.75) {
            return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
          } else if (t < 2.5 / 2.75) {
            return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
          } else {
            return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
          }
        },
        BounceEaseIn(t, b, c, d) {
          return c - exports2.Easings.BounceEaseOut(d - t, 0, c, d) + b;
        },
        BounceEaseInOut(t, b, c, d) {
          if (t < d / 2) {
            return exports2.Easings.BounceEaseIn(t * 2, 0, c, d) * 0.5 + b;
          } else {
            return exports2.Easings.BounceEaseOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
          }
        },
        EaseIn(t, b, c, d) {
          return c * (t /= d) * t + b;
        },
        EaseOut(t, b, c, d) {
          return -c * (t /= d) * (t - 2) + b;
        },
        EaseInOut(t, b, c, d) {
          if ((t /= d / 2) < 1) {
            return c / 2 * t * t + b;
          }
          return -c / 2 * (--t * (t - 2) - 1) + b;
        },
        StrongEaseIn(t, b, c, d) {
          return c * (t /= d) * t * t * t * t + b;
        },
        StrongEaseOut(t, b, c, d) {
          return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
        },
        StrongEaseInOut(t, b, c, d) {
          if ((t /= d / 2) < 1) {
            return c / 2 * t * t * t * t * t + b;
          }
          return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
        },
        Linear(t, b, c, d) {
          return c * t / d + b;
        }
      };
    })(Tween);
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Konva = void 0;
      const Global_12 = Global;
      const Util_12 = Util;
      const Node_12 = Node$2;
      const Container_12 = Container$1;
      const Stage_1 = Stage;
      const Layer_12 = Layer$1;
      const FastLayer_1 = FastLayer$1;
      const Group_12 = Group$1;
      const DragAndDrop_12 = DragAndDrop;
      const Shape_12 = Shape;
      const Animation_12 = Animation$1;
      const Tween_1 = Tween;
      const Context_12 = Context$1;
      const Canvas_12 = Canvas$1;
      exports2.Konva = Util_12.Util._assign(Global_12.Konva, {
        Util: Util_12.Util,
        Transform: Util_12.Transform,
        Node: Node_12.Node,
        Container: Container_12.Container,
        Stage: Stage_1.Stage,
        stages: Stage_1.stages,
        Layer: Layer_12.Layer,
        FastLayer: FastLayer_1.FastLayer,
        Group: Group_12.Group,
        DD: DragAndDrop_12.DD,
        Shape: Shape_12.Shape,
        shapes: Shape_12.shapes,
        Animation: Animation_12.Animation,
        Tween: Tween_1.Tween,
        Easings: Tween_1.Easings,
        Context: Context_12.Context,
        Canvas: Canvas_12.Canvas
      });
      exports2.default = exports2.Konva;
    })(_CoreInternals);
    var Arc$1 = {};
    Object.defineProperty(Arc$1, "__esModule", { value: true });
    Arc$1.Arc = void 0;
    const Factory_1$v = Factory;
    const Shape_1$f = Shape;
    const Global_1$g = Global;
    const Validators_1$u = Validators;
    const Global_2$3 = Global;
    class Arc extends Shape_1$f.Shape {
      _sceneFunc(context) {
        var angle2 = Global_1$g.Konva.getAngle(this.angle()), clockwise = this.clockwise();
        context.beginPath();
        context.arc(0, 0, this.outerRadius(), 0, angle2, clockwise);
        context.arc(0, 0, this.innerRadius(), angle2, 0, !clockwise);
        context.closePath();
        context.fillStrokeShape(this);
      }
      getWidth() {
        return this.outerRadius() * 2;
      }
      getHeight() {
        return this.outerRadius() * 2;
      }
      setWidth(width) {
        this.outerRadius(width / 2);
      }
      setHeight(height) {
        this.outerRadius(height / 2);
      }
      getSelfRect() {
        const innerRadius = this.innerRadius();
        const outerRadius = this.outerRadius();
        const clockwise = this.clockwise();
        const angle2 = Global_1$g.Konva.getAngle(clockwise ? 360 - this.angle() : this.angle());
        const boundLeftRatio = Math.cos(Math.min(angle2, Math.PI));
        const boundRightRatio = 1;
        const boundTopRatio = Math.sin(Math.min(Math.max(Math.PI, angle2), 3 * Math.PI / 2));
        const boundBottomRatio = Math.sin(Math.min(angle2, Math.PI / 2));
        const boundLeft = boundLeftRatio * (boundLeftRatio > 0 ? innerRadius : outerRadius);
        const boundRight = boundRightRatio * outerRadius;
        const boundTop = boundTopRatio * (boundTopRatio > 0 ? innerRadius : outerRadius);
        const boundBottom = boundBottomRatio * (boundBottomRatio > 0 ? outerRadius : innerRadius);
        return {
          x: boundLeft,
          y: clockwise ? -1 * boundBottom : boundTop,
          width: boundRight - boundLeft,
          height: boundBottom - boundTop
        };
      }
    }
    Arc$1.Arc = Arc;
    Arc.prototype._centroid = true;
    Arc.prototype.className = "Arc";
    Arc.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
    (0, Global_2$3._registerNode)(Arc);
    Factory_1$v.Factory.addGetterSetter(Arc, "innerRadius", 0, (0, Validators_1$u.getNumberValidator)());
    Factory_1$v.Factory.addGetterSetter(Arc, "outerRadius", 0, (0, Validators_1$u.getNumberValidator)());
    Factory_1$v.Factory.addGetterSetter(Arc, "angle", 0, (0, Validators_1$u.getNumberValidator)());
    Factory_1$v.Factory.addGetterSetter(Arc, "clockwise", false, (0, Validators_1$u.getBooleanValidator)());
    var Arrow$1 = {};
    var Line$1 = {};
    Object.defineProperty(Line$1, "__esModule", { value: true });
    Line$1.Line = void 0;
    const Factory_1$u = Factory;
    const Shape_1$e = Shape;
    const Validators_1$t = Validators;
    const Global_1$f = Global;
    function getControlPoints(x0, y0, x1, y1, x2, y2, t) {
      var d01 = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2)), d12 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)), fa = t * d01 / (d01 + d12), fb = t * d12 / (d01 + d12), p1x = x1 - fa * (x2 - x0), p1y = y1 - fa * (y2 - y0), p2x = x1 + fb * (x2 - x0), p2y = y1 + fb * (y2 - y0);
      return [p1x, p1y, p2x, p2y];
    }
    function expandPoints(p2, tension) {
      var len = p2.length, allPoints = [], n, cp;
      for (n = 2; n < len - 2; n += 2) {
        cp = getControlPoints(p2[n - 2], p2[n - 1], p2[n], p2[n + 1], p2[n + 2], p2[n + 3], tension);
        if (isNaN(cp[0])) {
          continue;
        }
        allPoints.push(cp[0]);
        allPoints.push(cp[1]);
        allPoints.push(p2[n]);
        allPoints.push(p2[n + 1]);
        allPoints.push(cp[2]);
        allPoints.push(cp[3]);
      }
      return allPoints;
    }
    class Line extends Shape_1$e.Shape {
      constructor(config2) {
        super(config2);
        this.on("pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva", function() {
          this._clearCache("tensionPoints");
        });
      }
      _sceneFunc(context) {
        var points = this.points(), length = points.length, tension = this.tension(), closed = this.closed(), bezier = this.bezier(), tp, len, n;
        if (!length) {
          return;
        }
        context.beginPath();
        context.moveTo(points[0], points[1]);
        if (tension !== 0 && length > 4) {
          tp = this.getTensionPoints();
          len = tp.length;
          n = closed ? 0 : 4;
          if (!closed) {
            context.quadraticCurveTo(tp[0], tp[1], tp[2], tp[3]);
          }
          while (n < len - 2) {
            context.bezierCurveTo(tp[n++], tp[n++], tp[n++], tp[n++], tp[n++], tp[n++]);
          }
          if (!closed) {
            context.quadraticCurveTo(tp[len - 2], tp[len - 1], points[length - 2], points[length - 1]);
          }
        } else if (bezier) {
          n = 2;
          while (n < length) {
            context.bezierCurveTo(points[n++], points[n++], points[n++], points[n++], points[n++], points[n++]);
          }
        } else {
          for (n = 2; n < length; n += 2) {
            context.lineTo(points[n], points[n + 1]);
          }
        }
        if (closed) {
          context.closePath();
          context.fillStrokeShape(this);
        } else {
          context.strokeShape(this);
        }
      }
      getTensionPoints() {
        return this._getCache("tensionPoints", this._getTensionPoints);
      }
      _getTensionPoints() {
        if (this.closed()) {
          return this._getTensionPointsClosed();
        } else {
          return expandPoints(this.points(), this.tension());
        }
      }
      _getTensionPointsClosed() {
        var p2 = this.points(), len = p2.length, tension = this.tension(), firstControlPoints = getControlPoints(p2[len - 2], p2[len - 1], p2[0], p2[1], p2[2], p2[3], tension), lastControlPoints = getControlPoints(p2[len - 4], p2[len - 3], p2[len - 2], p2[len - 1], p2[0], p2[1], tension), middle = expandPoints(p2, tension), tp = [firstControlPoints[2], firstControlPoints[3]].concat(middle).concat([
          lastControlPoints[0],
          lastControlPoints[1],
          p2[len - 2],
          p2[len - 1],
          lastControlPoints[2],
          lastControlPoints[3],
          firstControlPoints[0],
          firstControlPoints[1],
          p2[0],
          p2[1]
        ]);
        return tp;
      }
      getWidth() {
        return this.getSelfRect().width;
      }
      getHeight() {
        return this.getSelfRect().height;
      }
      getSelfRect() {
        var points = this.points();
        if (points.length < 4) {
          return {
            x: points[0] || 0,
            y: points[1] || 0,
            width: 0,
            height: 0
          };
        }
        if (this.tension() !== 0) {
          points = [
            points[0],
            points[1],
            ...this._getTensionPoints(),
            points[points.length - 2],
            points[points.length - 1]
          ];
        } else {
          points = this.points();
        }
        var minX = points[0];
        var maxX = points[0];
        var minY = points[1];
        var maxY = points[1];
        var x2, y;
        for (var i2 = 0; i2 < points.length / 2; i2++) {
          x2 = points[i2 * 2];
          y = points[i2 * 2 + 1];
          minX = Math.min(minX, x2);
          maxX = Math.max(maxX, x2);
          minY = Math.min(minY, y);
          maxY = Math.max(maxY, y);
        }
        return {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        };
      }
    }
    Line$1.Line = Line;
    Line.prototype.className = "Line";
    Line.prototype._attrsAffectingSize = ["points", "bezier", "tension"];
    (0, Global_1$f._registerNode)(Line);
    Factory_1$u.Factory.addGetterSetter(Line, "closed", false);
    Factory_1$u.Factory.addGetterSetter(Line, "bezier", false);
    Factory_1$u.Factory.addGetterSetter(Line, "tension", 0, (0, Validators_1$t.getNumberValidator)());
    Factory_1$u.Factory.addGetterSetter(Line, "points", [], (0, Validators_1$t.getNumberArrayValidator)());
    var Path$1 = {};
    var BezierFunctions = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.t2length = exports2.getQuadraticArcLength = exports2.getCubicArcLength = exports2.binomialCoefficients = exports2.cValues = exports2.tValues = void 0;
      exports2.tValues = [
        [],
        [],
        [
          -0.5773502691896257,
          0.5773502691896257
        ],
        [
          0,
          -0.7745966692414834,
          0.7745966692414834
        ],
        [
          -0.33998104358485626,
          0.33998104358485626,
          -0.8611363115940526,
          0.8611363115940526
        ],
        [
          0,
          -0.5384693101056831,
          0.5384693101056831,
          -0.906179845938664,
          0.906179845938664
        ],
        [
          0.6612093864662645,
          -0.6612093864662645,
          -0.2386191860831969,
          0.2386191860831969,
          -0.932469514203152,
          0.932469514203152
        ],
        [
          0,
          0.4058451513773972,
          -0.4058451513773972,
          -0.7415311855993945,
          0.7415311855993945,
          -0.9491079123427585,
          0.9491079123427585
        ],
        [
          -0.1834346424956498,
          0.1834346424956498,
          -0.525532409916329,
          0.525532409916329,
          -0.7966664774136267,
          0.7966664774136267,
          -0.9602898564975363,
          0.9602898564975363
        ],
        [
          0,
          -0.8360311073266358,
          0.8360311073266358,
          -0.9681602395076261,
          0.9681602395076261,
          -0.3242534234038089,
          0.3242534234038089,
          -0.6133714327005904,
          0.6133714327005904
        ],
        [
          -0.14887433898163122,
          0.14887433898163122,
          -0.4333953941292472,
          0.4333953941292472,
          -0.6794095682990244,
          0.6794095682990244,
          -0.8650633666889845,
          0.8650633666889845,
          -0.9739065285171717,
          0.9739065285171717
        ],
        [
          0,
          -0.26954315595234496,
          0.26954315595234496,
          -0.5190961292068118,
          0.5190961292068118,
          -0.7301520055740494,
          0.7301520055740494,
          -0.8870625997680953,
          0.8870625997680953,
          -0.978228658146057,
          0.978228658146057
        ],
        [
          -0.1252334085114689,
          0.1252334085114689,
          -0.3678314989981802,
          0.3678314989981802,
          -0.5873179542866175,
          0.5873179542866175,
          -0.7699026741943047,
          0.7699026741943047,
          -0.9041172563704749,
          0.9041172563704749,
          -0.9815606342467192,
          0.9815606342467192
        ],
        [
          0,
          -0.2304583159551348,
          0.2304583159551348,
          -0.44849275103644687,
          0.44849275103644687,
          -0.6423493394403402,
          0.6423493394403402,
          -0.8015780907333099,
          0.8015780907333099,
          -0.9175983992229779,
          0.9175983992229779,
          -0.9841830547185881,
          0.9841830547185881
        ],
        [
          -0.10805494870734367,
          0.10805494870734367,
          -0.31911236892788974,
          0.31911236892788974,
          -0.5152486363581541,
          0.5152486363581541,
          -0.6872929048116855,
          0.6872929048116855,
          -0.827201315069765,
          0.827201315069765,
          -0.9284348836635735,
          0.9284348836635735,
          -0.9862838086968123,
          0.9862838086968123
        ],
        [
          0,
          -0.20119409399743451,
          0.20119409399743451,
          -0.3941513470775634,
          0.3941513470775634,
          -0.5709721726085388,
          0.5709721726085388,
          -0.7244177313601701,
          0.7244177313601701,
          -0.8482065834104272,
          0.8482065834104272,
          -0.937273392400706,
          0.937273392400706,
          -0.9879925180204854,
          0.9879925180204854
        ],
        [
          -0.09501250983763744,
          0.09501250983763744,
          -0.2816035507792589,
          0.2816035507792589,
          -0.45801677765722737,
          0.45801677765722737,
          -0.6178762444026438,
          0.6178762444026438,
          -0.755404408355003,
          0.755404408355003,
          -0.8656312023878318,
          0.8656312023878318,
          -0.9445750230732326,
          0.9445750230732326,
          -0.9894009349916499,
          0.9894009349916499
        ],
        [
          0,
          -0.17848418149584785,
          0.17848418149584785,
          -0.3512317634538763,
          0.3512317634538763,
          -0.5126905370864769,
          0.5126905370864769,
          -0.6576711592166907,
          0.6576711592166907,
          -0.7815140038968014,
          0.7815140038968014,
          -0.8802391537269859,
          0.8802391537269859,
          -0.9506755217687678,
          0.9506755217687678,
          -0.9905754753144174,
          0.9905754753144174
        ],
        [
          -0.0847750130417353,
          0.0847750130417353,
          -0.2518862256915055,
          0.2518862256915055,
          -0.41175116146284263,
          0.41175116146284263,
          -0.5597708310739475,
          0.5597708310739475,
          -0.6916870430603532,
          0.6916870430603532,
          -0.8037049589725231,
          0.8037049589725231,
          -0.8926024664975557,
          0.8926024664975557,
          -0.9558239495713977,
          0.9558239495713977,
          -0.9915651684209309,
          0.9915651684209309
        ],
        [
          0,
          -0.16035864564022537,
          0.16035864564022537,
          -0.31656409996362983,
          0.31656409996362983,
          -0.46457074137596094,
          0.46457074137596094,
          -0.600545304661681,
          0.600545304661681,
          -0.7209661773352294,
          0.7209661773352294,
          -0.8227146565371428,
          0.8227146565371428,
          -0.9031559036148179,
          0.9031559036148179,
          -0.96020815213483,
          0.96020815213483,
          -0.9924068438435844,
          0.9924068438435844
        ],
        [
          -0.07652652113349734,
          0.07652652113349734,
          -0.22778585114164507,
          0.22778585114164507,
          -0.37370608871541955,
          0.37370608871541955,
          -0.5108670019508271,
          0.5108670019508271,
          -0.636053680726515,
          0.636053680726515,
          -0.7463319064601508,
          0.7463319064601508,
          -0.8391169718222188,
          0.8391169718222188,
          -0.912234428251326,
          0.912234428251326,
          -0.9639719272779138,
          0.9639719272779138,
          -0.9931285991850949,
          0.9931285991850949
        ],
        [
          0,
          -0.1455618541608951,
          0.1455618541608951,
          -0.2880213168024011,
          0.2880213168024011,
          -0.4243421202074388,
          0.4243421202074388,
          -0.5516188358872198,
          0.5516188358872198,
          -0.6671388041974123,
          0.6671388041974123,
          -0.7684399634756779,
          0.7684399634756779,
          -0.8533633645833173,
          0.8533633645833173,
          -0.9200993341504008,
          0.9200993341504008,
          -0.9672268385663063,
          0.9672268385663063,
          -0.9937521706203895,
          0.9937521706203895
        ],
        [
          -0.06973927331972223,
          0.06973927331972223,
          -0.20786042668822127,
          0.20786042668822127,
          -0.34193582089208424,
          0.34193582089208424,
          -0.469355837986757,
          0.469355837986757,
          -0.5876404035069116,
          0.5876404035069116,
          -0.6944872631866827,
          0.6944872631866827,
          -0.7878168059792081,
          0.7878168059792081,
          -0.8658125777203002,
          0.8658125777203002,
          -0.926956772187174,
          0.926956772187174,
          -0.9700604978354287,
          0.9700604978354287,
          -0.9942945854823992,
          0.9942945854823992
        ],
        [
          0,
          -0.1332568242984661,
          0.1332568242984661,
          -0.26413568097034495,
          0.26413568097034495,
          -0.3903010380302908,
          0.3903010380302908,
          -0.5095014778460075,
          0.5095014778460075,
          -0.6196098757636461,
          0.6196098757636461,
          -0.7186613631319502,
          0.7186613631319502,
          -0.8048884016188399,
          0.8048884016188399,
          -0.8767523582704416,
          0.8767523582704416,
          -0.9329710868260161,
          0.9329710868260161,
          -0.9725424712181152,
          0.9725424712181152,
          -0.9947693349975522,
          0.9947693349975522
        ],
        [
          -0.06405689286260563,
          0.06405689286260563,
          -0.1911188674736163,
          0.1911188674736163,
          -0.3150426796961634,
          0.3150426796961634,
          -0.4337935076260451,
          0.4337935076260451,
          -0.5454214713888396,
          0.5454214713888396,
          -0.6480936519369755,
          0.6480936519369755,
          -0.7401241915785544,
          0.7401241915785544,
          -0.820001985973903,
          0.820001985973903,
          -0.8864155270044011,
          0.8864155270044011,
          -0.9382745520027328,
          0.9382745520027328,
          -0.9747285559713095,
          0.9747285559713095,
          -0.9951872199970213,
          0.9951872199970213
        ]
      ];
      exports2.cValues = [
        [],
        [],
        [1, 1],
        [
          0.8888888888888888,
          0.5555555555555556,
          0.5555555555555556
        ],
        [
          0.6521451548625461,
          0.6521451548625461,
          0.34785484513745385,
          0.34785484513745385
        ],
        [
          0.5688888888888889,
          0.47862867049936647,
          0.47862867049936647,
          0.23692688505618908,
          0.23692688505618908
        ],
        [
          0.3607615730481386,
          0.3607615730481386,
          0.46791393457269104,
          0.46791393457269104,
          0.17132449237917036,
          0.17132449237917036
        ],
        [
          0.4179591836734694,
          0.3818300505051189,
          0.3818300505051189,
          0.27970539148927664,
          0.27970539148927664,
          0.1294849661688697,
          0.1294849661688697
        ],
        [
          0.362683783378362,
          0.362683783378362,
          0.31370664587788727,
          0.31370664587788727,
          0.22238103445337448,
          0.22238103445337448,
          0.10122853629037626,
          0.10122853629037626
        ],
        [
          0.3302393550012598,
          0.1806481606948574,
          0.1806481606948574,
          0.08127438836157441,
          0.08127438836157441,
          0.31234707704000286,
          0.31234707704000286,
          0.26061069640293544,
          0.26061069640293544
        ],
        [
          0.29552422471475287,
          0.29552422471475287,
          0.26926671930999635,
          0.26926671930999635,
          0.21908636251598204,
          0.21908636251598204,
          0.1494513491505806,
          0.1494513491505806,
          0.06667134430868814,
          0.06667134430868814
        ],
        [
          0.2729250867779006,
          0.26280454451024665,
          0.26280454451024665,
          0.23319376459199048,
          0.23319376459199048,
          0.18629021092773426,
          0.18629021092773426,
          0.1255803694649046,
          0.1255803694649046,
          0.05566856711617366,
          0.05566856711617366
        ],
        [
          0.24914704581340277,
          0.24914704581340277,
          0.2334925365383548,
          0.2334925365383548,
          0.20316742672306592,
          0.20316742672306592,
          0.16007832854334622,
          0.16007832854334622,
          0.10693932599531843,
          0.10693932599531843,
          0.04717533638651183,
          0.04717533638651183
        ],
        [
          0.2325515532308739,
          0.22628318026289723,
          0.22628318026289723,
          0.2078160475368885,
          0.2078160475368885,
          0.17814598076194574,
          0.17814598076194574,
          0.13887351021978725,
          0.13887351021978725,
          0.09212149983772845,
          0.09212149983772845,
          0.04048400476531588,
          0.04048400476531588
        ],
        [
          0.2152638534631578,
          0.2152638534631578,
          0.2051984637212956,
          0.2051984637212956,
          0.18553839747793782,
          0.18553839747793782,
          0.15720316715819355,
          0.15720316715819355,
          0.12151857068790319,
          0.12151857068790319,
          0.08015808715976021,
          0.08015808715976021,
          0.03511946033175186,
          0.03511946033175186
        ],
        [
          0.2025782419255613,
          0.19843148532711158,
          0.19843148532711158,
          0.1861610000155622,
          0.1861610000155622,
          0.16626920581699392,
          0.16626920581699392,
          0.13957067792615432,
          0.13957067792615432,
          0.10715922046717194,
          0.10715922046717194,
          0.07036604748810812,
          0.07036604748810812,
          0.03075324199611727,
          0.03075324199611727
        ],
        [
          0.1894506104550685,
          0.1894506104550685,
          0.18260341504492358,
          0.18260341504492358,
          0.16915651939500254,
          0.16915651939500254,
          0.14959598881657674,
          0.14959598881657674,
          0.12462897125553388,
          0.12462897125553388,
          0.09515851168249279,
          0.09515851168249279,
          0.062253523938647894,
          0.062253523938647894,
          0.027152459411754096,
          0.027152459411754096
        ],
        [
          0.17944647035620653,
          0.17656270536699264,
          0.17656270536699264,
          0.16800410215645004,
          0.16800410215645004,
          0.15404576107681028,
          0.15404576107681028,
          0.13513636846852548,
          0.13513636846852548,
          0.11188384719340397,
          0.11188384719340397,
          0.08503614831717918,
          0.08503614831717918,
          0.0554595293739872,
          0.0554595293739872,
          0.02414830286854793,
          0.02414830286854793
        ],
        [
          0.1691423829631436,
          0.1691423829631436,
          0.16427648374583273,
          0.16427648374583273,
          0.15468467512626524,
          0.15468467512626524,
          0.14064291467065065,
          0.14064291467065065,
          0.12255520671147846,
          0.12255520671147846,
          0.10094204410628717,
          0.10094204410628717,
          0.07642573025488905,
          0.07642573025488905,
          0.0497145488949698,
          0.0497145488949698,
          0.02161601352648331,
          0.02161601352648331
        ],
        [
          0.1610544498487837,
          0.15896884339395434,
          0.15896884339395434,
          0.15276604206585967,
          0.15276604206585967,
          0.1426067021736066,
          0.1426067021736066,
          0.12875396253933621,
          0.12875396253933621,
          0.11156664554733399,
          0.11156664554733399,
          0.09149002162245,
          0.09149002162245,
          0.06904454273764123,
          0.06904454273764123,
          0.0448142267656996,
          0.0448142267656996,
          0.019461788229726478,
          0.019461788229726478
        ],
        [
          0.15275338713072584,
          0.15275338713072584,
          0.14917298647260374,
          0.14917298647260374,
          0.14209610931838204,
          0.14209610931838204,
          0.13168863844917664,
          0.13168863844917664,
          0.11819453196151841,
          0.11819453196151841,
          0.10193011981724044,
          0.10193011981724044,
          0.08327674157670475,
          0.08327674157670475,
          0.06267204833410907,
          0.06267204833410907,
          0.04060142980038694,
          0.04060142980038694,
          0.017614007139152118,
          0.017614007139152118
        ],
        [
          0.14608113364969041,
          0.14452440398997005,
          0.14452440398997005,
          0.13988739479107315,
          0.13988739479107315,
          0.13226893863333747,
          0.13226893863333747,
          0.12183141605372853,
          0.12183141605372853,
          0.10879729916714838,
          0.10879729916714838,
          0.09344442345603386,
          0.09344442345603386,
          0.0761001136283793,
          0.0761001136283793,
          0.057134425426857205,
          0.057134425426857205,
          0.036953789770852494,
          0.036953789770852494,
          0.016017228257774335,
          0.016017228257774335
        ],
        [
          0.13925187285563198,
          0.13925187285563198,
          0.13654149834601517,
          0.13654149834601517,
          0.13117350478706238,
          0.13117350478706238,
          0.12325237681051242,
          0.12325237681051242,
          0.11293229608053922,
          0.11293229608053922,
          0.10041414444288096,
          0.10041414444288096,
          0.08594160621706773,
          0.08594160621706773,
          0.06979646842452049,
          0.06979646842452049,
          0.052293335152683286,
          0.052293335152683286,
          0.03377490158481415,
          0.03377490158481415,
          0.0146279952982722,
          0.0146279952982722
        ],
        [
          0.13365457218610619,
          0.1324620394046966,
          0.1324620394046966,
          0.12890572218808216,
          0.12890572218808216,
          0.12304908430672953,
          0.12304908430672953,
          0.11499664022241136,
          0.11499664022241136,
          0.10489209146454141,
          0.10489209146454141,
          0.09291576606003515,
          0.09291576606003515,
          0.07928141177671895,
          0.07928141177671895,
          0.06423242140852585,
          0.06423242140852585,
          0.04803767173108467,
          0.04803767173108467,
          0.030988005856979445,
          0.030988005856979445,
          0.013411859487141771,
          0.013411859487141771
        ],
        [
          0.12793819534675216,
          0.12793819534675216,
          0.1258374563468283,
          0.1258374563468283,
          0.12167047292780339,
          0.12167047292780339,
          0.1155056680537256,
          0.1155056680537256,
          0.10744427011596563,
          0.10744427011596563,
          0.09761865210411388,
          0.09761865210411388,
          0.08619016153195327,
          0.08619016153195327,
          0.0733464814110803,
          0.0733464814110803,
          0.05929858491543678,
          0.05929858491543678,
          0.04427743881741981,
          0.04427743881741981,
          0.028531388628933663,
          0.028531388628933663,
          0.0123412297999872,
          0.0123412297999872
        ]
      ];
      exports2.binomialCoefficients = [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]];
      const getCubicArcLength = (xs, ys, t) => {
        let z;
        let sum2;
        let correctedT;
        const n = 20;
        z = t / 2;
        sum2 = 0;
        for (let i2 = 0; i2 < n; i2++) {
          correctedT = z * exports2.tValues[n][i2] + z;
          sum2 += exports2.cValues[n][i2] * BFunc(xs, ys, correctedT);
        }
        return z * sum2;
      };
      exports2.getCubicArcLength = getCubicArcLength;
      const getQuadraticArcLength = (xs, ys, t) => {
        if (t === void 0) {
          t = 1;
        }
        const ax = xs[0] - 2 * xs[1] + xs[2];
        const ay = ys[0] - 2 * ys[1] + ys[2];
        const bx = 2 * xs[1] - 2 * xs[0];
        const by = 2 * ys[1] - 2 * ys[0];
        const A = 4 * (ax * ax + ay * ay);
        const B = 4 * (ax * bx + ay * by);
        const C = bx * bx + by * by;
        if (A === 0) {
          return t * Math.sqrt(Math.pow(xs[2] - xs[0], 2) + Math.pow(ys[2] - ys[0], 2));
        }
        const b = B / (2 * A);
        const c = C / A;
        const u = t + b;
        const k = c - b * b;
        const uuk = u * u + k > 0 ? Math.sqrt(u * u + k) : 0;
        const bbk = b * b + k > 0 ? Math.sqrt(b * b + k) : 0;
        const term = b + Math.sqrt(b * b + k) !== 0 ? k * Math.log(Math.abs((u + uuk) / (b + bbk))) : 0;
        return Math.sqrt(A) / 2 * (u * uuk - b * bbk + term);
      };
      exports2.getQuadraticArcLength = getQuadraticArcLength;
      function BFunc(xs, ys, t) {
        const xbase = getDerivative(1, t, xs);
        const ybase = getDerivative(1, t, ys);
        const combined = xbase * xbase + ybase * ybase;
        return Math.sqrt(combined);
      }
      const getDerivative = (derivative, t, vs) => {
        const n = vs.length - 1;
        let _vs;
        let value;
        if (n === 0) {
          return 0;
        }
        if (derivative === 0) {
          value = 0;
          for (let k = 0; k <= n; k++) {
            value += exports2.binomialCoefficients[n][k] * Math.pow(1 - t, n - k) * Math.pow(t, k) * vs[k];
          }
          return value;
        } else {
          _vs = new Array(n);
          for (let k = 0; k < n; k++) {
            _vs[k] = n * (vs[k + 1] - vs[k]);
          }
          return getDerivative(derivative - 1, t, _vs);
        }
      };
      const t2length = (length, totalLength, func) => {
        let error2 = 1;
        let t = length / totalLength;
        let step = (length - func(t)) / totalLength;
        let numIterations = 0;
        while (error2 > 1e-3) {
          const increasedTLength = func(t + step);
          const increasedTError = Math.abs(length - increasedTLength) / totalLength;
          if (increasedTError < error2) {
            error2 = increasedTError;
            t += step;
          } else {
            const decreasedTLength = func(t - step);
            const decreasedTError = Math.abs(length - decreasedTLength) / totalLength;
            if (decreasedTError < error2) {
              error2 = decreasedTError;
              t -= step;
            } else {
              step /= 2;
            }
          }
          numIterations++;
          if (numIterations > 500) {
            break;
          }
        }
        return t;
      };
      exports2.t2length = t2length;
    })(BezierFunctions);
    Object.defineProperty(Path$1, "__esModule", { value: true });
    Path$1.Path = void 0;
    const Factory_1$t = Factory;
    const Shape_1$d = Shape;
    const Global_1$e = Global;
    const BezierFunctions_1 = BezierFunctions;
    class Path extends Shape_1$d.Shape {
      constructor(config2) {
        super(config2);
        this.dataArray = [];
        this.pathLength = 0;
        this._readDataAttribute();
        this.on("dataChange.konva", function() {
          this._readDataAttribute();
        });
      }
      _readDataAttribute() {
        this.dataArray = Path.parsePathData(this.data());
        this.pathLength = Path.getPathLength(this.dataArray);
      }
      _sceneFunc(context) {
        var ca2 = this.dataArray;
        context.beginPath();
        var isClosed = false;
        for (var n = 0; n < ca2.length; n++) {
          var c = ca2[n].command;
          var p2 = ca2[n].points;
          switch (c) {
            case "L":
              context.lineTo(p2[0], p2[1]);
              break;
            case "M":
              context.moveTo(p2[0], p2[1]);
              break;
            case "C":
              context.bezierCurveTo(p2[0], p2[1], p2[2], p2[3], p2[4], p2[5]);
              break;
            case "Q":
              context.quadraticCurveTo(p2[0], p2[1], p2[2], p2[3]);
              break;
            case "A":
              var cx = p2[0], cy = p2[1], rx2 = p2[2], ry = p2[3], theta2 = p2[4], dTheta = p2[5], psi2 = p2[6], fs = p2[7];
              var r2 = rx2 > ry ? rx2 : ry;
              var scaleX = rx2 > ry ? 1 : rx2 / ry;
              var scaleY = rx2 > ry ? ry / rx2 : 1;
              context.translate(cx, cy);
              context.rotate(psi2);
              context.scale(scaleX, scaleY);
              context.arc(0, 0, r2, theta2, theta2 + dTheta, 1 - fs);
              context.scale(1 / scaleX, 1 / scaleY);
              context.rotate(-psi2);
              context.translate(-cx, -cy);
              break;
            case "z":
              isClosed = true;
              context.closePath();
              break;
          }
        }
        if (!isClosed && !this.hasFill()) {
          context.strokeShape(this);
        } else {
          context.fillStrokeShape(this);
        }
      }
      getSelfRect() {
        var points = [];
        this.dataArray.forEach(function(data) {
          if (data.command === "A") {
            var start = data.points[4];
            var dTheta = data.points[5];
            var end = data.points[4] + dTheta;
            var inc = Math.PI / 180;
            if (Math.abs(start - end) < inc) {
              inc = Math.abs(start - end);
            }
            if (dTheta < 0) {
              for (let t = start - inc; t > end; t -= inc) {
                const point = Path.getPointOnEllipticalArc(data.points[0], data.points[1], data.points[2], data.points[3], t, 0);
                points.push(point.x, point.y);
              }
            } else {
              for (let t = start + inc; t < end; t += inc) {
                const point = Path.getPointOnEllipticalArc(data.points[0], data.points[1], data.points[2], data.points[3], t, 0);
                points.push(point.x, point.y);
              }
            }
          } else if (data.command === "C") {
            for (let t = 0; t <= 1; t += 0.01) {
              const point = Path.getPointOnCubicBezier(t, data.start.x, data.start.y, data.points[0], data.points[1], data.points[2], data.points[3], data.points[4], data.points[5]);
              points.push(point.x, point.y);
            }
          } else {
            points = points.concat(data.points);
          }
        });
        var minX = points[0];
        var maxX = points[0];
        var minY = points[1];
        var maxY = points[1];
        var x2, y;
        for (var i2 = 0; i2 < points.length / 2; i2++) {
          x2 = points[i2 * 2];
          y = points[i2 * 2 + 1];
          if (!isNaN(x2)) {
            minX = Math.min(minX, x2);
            maxX = Math.max(maxX, x2);
          }
          if (!isNaN(y)) {
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
          }
        }
        return {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        };
      }
      getLength() {
        return this.pathLength;
      }
      getPointAtLength(length) {
        return Path.getPointAtLengthOfDataArray(length, this.dataArray);
      }
      static getLineLength(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      }
      static getPathLength(dataArray) {
        let pathLength = 0;
        for (var i2 = 0; i2 < dataArray.length; ++i2) {
          pathLength += dataArray[i2].pathLength;
        }
        return pathLength;
      }
      static getPointAtLengthOfDataArray(length, dataArray) {
        var point, i2 = 0, ii2 = dataArray.length;
        if (!ii2) {
          return null;
        }
        while (i2 < ii2 && length > dataArray[i2].pathLength) {
          length -= dataArray[i2].pathLength;
          ++i2;
        }
        if (i2 === ii2) {
          point = dataArray[i2 - 1].points.slice(-2);
          return {
            x: point[0],
            y: point[1]
          };
        }
        if (length < 0.01) {
          point = dataArray[i2].points.slice(0, 2);
          return {
            x: point[0],
            y: point[1]
          };
        }
        var cp = dataArray[i2];
        var p2 = cp.points;
        switch (cp.command) {
          case "L":
            return Path.getPointOnLine(length, cp.start.x, cp.start.y, p2[0], p2[1]);
          case "C":
            return Path.getPointOnCubicBezier((0, BezierFunctions_1.t2length)(length, Path.getPathLength(dataArray), (i3) => {
              return (0, BezierFunctions_1.getCubicArcLength)([cp.start.x, p2[0], p2[2], p2[4]], [cp.start.y, p2[1], p2[3], p2[5]], i3);
            }), cp.start.x, cp.start.y, p2[0], p2[1], p2[2], p2[3], p2[4], p2[5]);
          case "Q":
            return Path.getPointOnQuadraticBezier((0, BezierFunctions_1.t2length)(length, Path.getPathLength(dataArray), (i3) => {
              return (0, BezierFunctions_1.getQuadraticArcLength)([cp.start.x, p2[0], p2[2]], [cp.start.y, p2[1], p2[3]], i3);
            }), cp.start.x, cp.start.y, p2[0], p2[1], p2[2], p2[3]);
          case "A":
            var cx = p2[0], cy = p2[1], rx2 = p2[2], ry = p2[3], theta2 = p2[4], dTheta = p2[5], psi2 = p2[6];
            theta2 += dTheta * length / cp.pathLength;
            return Path.getPointOnEllipticalArc(cx, cy, rx2, ry, theta2, psi2);
        }
        return null;
      }
      static getPointOnLine(dist2, P1x, P1y, P2x, P2y, fromX, fromY) {
        fromX = fromX !== null && fromX !== void 0 ? fromX : P1x;
        fromY = fromY !== null && fromY !== void 0 ? fromY : P1y;
        const len = this.getLineLength(P1x, P1y, P2x, P2y);
        if (len < 1e-10) {
          return { x: P1x, y: P1y };
        }
        if (P2x === P1x) {
          return { x: fromX, y: fromY + (P2y > P1y ? dist2 : -dist2) };
        }
        const m = (P2y - P1y) / (P2x - P1x);
        const run2 = Math.sqrt(dist2 * dist2 / (1 + m * m)) * (P2x < P1x ? -1 : 1);
        const rise = m * run2;
        if (Math.abs(fromY - P1y - m * (fromX - P1x)) < 1e-10) {
          return { x: fromX + run2, y: fromY + rise };
        }
        const u = ((fromX - P1x) * (P2x - P1x) + (fromY - P1y) * (P2y - P1y)) / (len * len);
        const ix = P1x + u * (P2x - P1x);
        const iy = P1y + u * (P2y - P1y);
        const pRise = this.getLineLength(fromX, fromY, ix, iy);
        const pRun = Math.sqrt(dist2 * dist2 - pRise * pRise);
        const adjustedRun = Math.sqrt(pRun * pRun / (1 + m * m)) * (P2x < P1x ? -1 : 1);
        const adjustedRise = m * adjustedRun;
        return { x: ix + adjustedRun, y: iy + adjustedRise };
      }
      static getPointOnCubicBezier(pct, P1x, P1y, P2x, P2y, P3x, P3y, P4x, P4y) {
        function CB1(t) {
          return t * t * t;
        }
        function CB2(t) {
          return 3 * t * t * (1 - t);
        }
        function CB3(t) {
          return 3 * t * (1 - t) * (1 - t);
        }
        function CB4(t) {
          return (1 - t) * (1 - t) * (1 - t);
        }
        var x2 = P4x * CB1(pct) + P3x * CB2(pct) + P2x * CB3(pct) + P1x * CB4(pct);
        var y = P4y * CB1(pct) + P3y * CB2(pct) + P2y * CB3(pct) + P1y * CB4(pct);
        return {
          x: x2,
          y
        };
      }
      static getPointOnQuadraticBezier(pct, P1x, P1y, P2x, P2y, P3x, P3y) {
        function QB1(t) {
          return t * t;
        }
        function QB2(t) {
          return 2 * t * (1 - t);
        }
        function QB3(t) {
          return (1 - t) * (1 - t);
        }
        var x2 = P3x * QB1(pct) + P2x * QB2(pct) + P1x * QB3(pct);
        var y = P3y * QB1(pct) + P2y * QB2(pct) + P1y * QB3(pct);
        return {
          x: x2,
          y
        };
      }
      static getPointOnEllipticalArc(cx, cy, rx2, ry, theta2, psi2) {
        var cosPsi = Math.cos(psi2), sinPsi = Math.sin(psi2);
        var pt = {
          x: rx2 * Math.cos(theta2),
          y: ry * Math.sin(theta2)
        };
        return {
          x: cx + (pt.x * cosPsi - pt.y * sinPsi),
          y: cy + (pt.x * sinPsi + pt.y * cosPsi)
        };
      }
      static parsePathData(data) {
        if (!data) {
          return [];
        }
        var cs2 = data;
        var cc = [
          "m",
          "M",
          "l",
          "L",
          "v",
          "V",
          "h",
          "H",
          "z",
          "Z",
          "c",
          "C",
          "q",
          "Q",
          "t",
          "T",
          "s",
          "S",
          "a",
          "A"
        ];
        cs2 = cs2.replace(new RegExp(" ", "g"), ",");
        for (var n = 0; n < cc.length; n++) {
          cs2 = cs2.replace(new RegExp(cc[n], "g"), "|" + cc[n]);
        }
        var arr = cs2.split("|");
        var ca2 = [];
        var coords = [];
        var cpx = 0;
        var cpy = 0;
        var re2 = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi;
        var match;
        for (n = 1; n < arr.length; n++) {
          var str2 = arr[n];
          var c = str2.charAt(0);
          str2 = str2.slice(1);
          coords.length = 0;
          while (match = re2.exec(str2)) {
            coords.push(match[0]);
          }
          var p2 = [];
          for (var j = 0, jlen = coords.length; j < jlen; j++) {
            if (coords[j] === "00") {
              p2.push(0, 0);
              continue;
            }
            var parsed = parseFloat(coords[j]);
            if (!isNaN(parsed)) {
              p2.push(parsed);
            } else {
              p2.push(0);
            }
          }
          while (p2.length > 0) {
            if (isNaN(p2[0])) {
              break;
            }
            var cmd = "";
            var points = [];
            var startX = cpx, startY = cpy;
            var prevCmd, ctlPtx, ctlPty;
            var rx2, ry, psi2, fa, fs, x1, y1;
            switch (c) {
              case "l":
                cpx += p2.shift();
                cpy += p2.shift();
                cmd = "L";
                points.push(cpx, cpy);
                break;
              case "L":
                cpx = p2.shift();
                cpy = p2.shift();
                points.push(cpx, cpy);
                break;
              case "m":
                var dx = p2.shift();
                var dy = p2.shift();
                cpx += dx;
                cpy += dy;
                cmd = "M";
                if (ca2.length > 2 && ca2[ca2.length - 1].command === "z") {
                  for (var idx = ca2.length - 2; idx >= 0; idx--) {
                    if (ca2[idx].command === "M") {
                      cpx = ca2[idx].points[0] + dx;
                      cpy = ca2[idx].points[1] + dy;
                      break;
                    }
                  }
                }
                points.push(cpx, cpy);
                c = "l";
                break;
              case "M":
                cpx = p2.shift();
                cpy = p2.shift();
                cmd = "M";
                points.push(cpx, cpy);
                c = "L";
                break;
              case "h":
                cpx += p2.shift();
                cmd = "L";
                points.push(cpx, cpy);
                break;
              case "H":
                cpx = p2.shift();
                cmd = "L";
                points.push(cpx, cpy);
                break;
              case "v":
                cpy += p2.shift();
                cmd = "L";
                points.push(cpx, cpy);
                break;
              case "V":
                cpy = p2.shift();
                cmd = "L";
                points.push(cpx, cpy);
                break;
              case "C":
                points.push(p2.shift(), p2.shift(), p2.shift(), p2.shift());
                cpx = p2.shift();
                cpy = p2.shift();
                points.push(cpx, cpy);
                break;
              case "c":
                points.push(cpx + p2.shift(), cpy + p2.shift(), cpx + p2.shift(), cpy + p2.shift());
                cpx += p2.shift();
                cpy += p2.shift();
                cmd = "C";
                points.push(cpx, cpy);
                break;
              case "S":
                ctlPtx = cpx;
                ctlPty = cpy;
                prevCmd = ca2[ca2.length - 1];
                if (prevCmd.command === "C") {
                  ctlPtx = cpx + (cpx - prevCmd.points[2]);
                  ctlPty = cpy + (cpy - prevCmd.points[3]);
                }
                points.push(ctlPtx, ctlPty, p2.shift(), p2.shift());
                cpx = p2.shift();
                cpy = p2.shift();
                cmd = "C";
                points.push(cpx, cpy);
                break;
              case "s":
                ctlPtx = cpx;
                ctlPty = cpy;
                prevCmd = ca2[ca2.length - 1];
                if (prevCmd.command === "C") {
                  ctlPtx = cpx + (cpx - prevCmd.points[2]);
                  ctlPty = cpy + (cpy - prevCmd.points[3]);
                }
                points.push(ctlPtx, ctlPty, cpx + p2.shift(), cpy + p2.shift());
                cpx += p2.shift();
                cpy += p2.shift();
                cmd = "C";
                points.push(cpx, cpy);
                break;
              case "Q":
                points.push(p2.shift(), p2.shift());
                cpx = p2.shift();
                cpy = p2.shift();
                points.push(cpx, cpy);
                break;
              case "q":
                points.push(cpx + p2.shift(), cpy + p2.shift());
                cpx += p2.shift();
                cpy += p2.shift();
                cmd = "Q";
                points.push(cpx, cpy);
                break;
              case "T":
                ctlPtx = cpx;
                ctlPty = cpy;
                prevCmd = ca2[ca2.length - 1];
                if (prevCmd.command === "Q") {
                  ctlPtx = cpx + (cpx - prevCmd.points[0]);
                  ctlPty = cpy + (cpy - prevCmd.points[1]);
                }
                cpx = p2.shift();
                cpy = p2.shift();
                cmd = "Q";
                points.push(ctlPtx, ctlPty, cpx, cpy);
                break;
              case "t":
                ctlPtx = cpx;
                ctlPty = cpy;
                prevCmd = ca2[ca2.length - 1];
                if (prevCmd.command === "Q") {
                  ctlPtx = cpx + (cpx - prevCmd.points[0]);
                  ctlPty = cpy + (cpy - prevCmd.points[1]);
                }
                cpx += p2.shift();
                cpy += p2.shift();
                cmd = "Q";
                points.push(ctlPtx, ctlPty, cpx, cpy);
                break;
              case "A":
                rx2 = p2.shift();
                ry = p2.shift();
                psi2 = p2.shift();
                fa = p2.shift();
                fs = p2.shift();
                x1 = cpx;
                y1 = cpy;
                cpx = p2.shift();
                cpy = p2.shift();
                cmd = "A";
                points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx2, ry, psi2);
                break;
              case "a":
                rx2 = p2.shift();
                ry = p2.shift();
                psi2 = p2.shift();
                fa = p2.shift();
                fs = p2.shift();
                x1 = cpx;
                y1 = cpy;
                cpx += p2.shift();
                cpy += p2.shift();
                cmd = "A";
                points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx2, ry, psi2);
                break;
            }
            ca2.push({
              command: cmd || c,
              points,
              start: {
                x: startX,
                y: startY
              },
              pathLength: this.calcLength(startX, startY, cmd || c, points)
            });
          }
          if (c === "z" || c === "Z") {
            ca2.push({
              command: "z",
              points: [],
              start: void 0,
              pathLength: 0
            });
          }
        }
        return ca2;
      }
      static calcLength(x2, y, cmd, points) {
        var len, p1, p2, t;
        var path = Path;
        switch (cmd) {
          case "L":
            return path.getLineLength(x2, y, points[0], points[1]);
          case "C":
            return (0, BezierFunctions_1.getCubicArcLength)([x2, points[0], points[2], points[4]], [y, points[1], points[3], points[5]], 1);
          case "Q":
            return (0, BezierFunctions_1.getQuadraticArcLength)([x2, points[0], points[2]], [y, points[1], points[3]], 1);
          case "A":
            len = 0;
            var start = points[4];
            var dTheta = points[5];
            var end = points[4] + dTheta;
            var inc = Math.PI / 180;
            if (Math.abs(start - end) < inc) {
              inc = Math.abs(start - end);
            }
            p1 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);
            if (dTheta < 0) {
              for (t = start - inc; t > end; t -= inc) {
                p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                p1 = p2;
              }
            } else {
              for (t = start + inc; t < end; t += inc) {
                p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                p1 = p2;
              }
            }
            p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
            len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
            return len;
        }
        return 0;
      }
      static convertEndpointToCenterParameterization(x1, y1, x2, y2, fa, fs, rx2, ry, psiDeg) {
        var psi2 = psiDeg * (Math.PI / 180);
        var xp = Math.cos(psi2) * (x1 - x2) / 2 + Math.sin(psi2) * (y1 - y2) / 2;
        var yp = -1 * Math.sin(psi2) * (x1 - x2) / 2 + Math.cos(psi2) * (y1 - y2) / 2;
        var lambda2 = xp * xp / (rx2 * rx2) + yp * yp / (ry * ry);
        if (lambda2 > 1) {
          rx2 *= Math.sqrt(lambda2);
          ry *= Math.sqrt(lambda2);
        }
        var f = Math.sqrt((rx2 * rx2 * (ry * ry) - rx2 * rx2 * (yp * yp) - ry * ry * (xp * xp)) / (rx2 * rx2 * (yp * yp) + ry * ry * (xp * xp)));
        if (fa === fs) {
          f *= -1;
        }
        if (isNaN(f)) {
          f = 0;
        }
        var cxp = f * rx2 * yp / ry;
        var cyp = f * -ry * xp / rx2;
        var cx = (x1 + x2) / 2 + Math.cos(psi2) * cxp - Math.sin(psi2) * cyp;
        var cy = (y1 + y2) / 2 + Math.sin(psi2) * cxp + Math.cos(psi2) * cyp;
        var vMag = function(v2) {
          return Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
        };
        var vRatio = function(u2, v2) {
          return (u2[0] * v2[0] + u2[1] * v2[1]) / (vMag(u2) * vMag(v2));
        };
        var vAngle = function(u2, v2) {
          return (u2[0] * v2[1] < u2[1] * v2[0] ? -1 : 1) * Math.acos(vRatio(u2, v2));
        };
        var theta2 = vAngle([1, 0], [(xp - cxp) / rx2, (yp - cyp) / ry]);
        var u = [(xp - cxp) / rx2, (yp - cyp) / ry];
        var v = [(-1 * xp - cxp) / rx2, (-1 * yp - cyp) / ry];
        var dTheta = vAngle(u, v);
        if (vRatio(u, v) <= -1) {
          dTheta = Math.PI;
        }
        if (vRatio(u, v) >= 1) {
          dTheta = 0;
        }
        if (fs === 0 && dTheta > 0) {
          dTheta = dTheta - 2 * Math.PI;
        }
        if (fs === 1 && dTheta < 0) {
          dTheta = dTheta + 2 * Math.PI;
        }
        return [cx, cy, rx2, ry, theta2, dTheta, psi2, fs];
      }
    }
    Path$1.Path = Path;
    Path.prototype.className = "Path";
    Path.prototype._attrsAffectingSize = ["data"];
    (0, Global_1$e._registerNode)(Path);
    Factory_1$t.Factory.addGetterSetter(Path, "data");
    Object.defineProperty(Arrow$1, "__esModule", { value: true });
    Arrow$1.Arrow = void 0;
    const Factory_1$s = Factory;
    const Line_1$1 = Line$1;
    const Validators_1$s = Validators;
    const Global_1$d = Global;
    const Path_1$2 = Path$1;
    class Arrow extends Line_1$1.Line {
      _sceneFunc(ctx) {
        super._sceneFunc(ctx);
        var PI2 = Math.PI * 2;
        var points = this.points();
        var tp = points;
        var fromTension = this.tension() !== 0 && points.length > 4;
        if (fromTension) {
          tp = this.getTensionPoints();
        }
        var length = this.pointerLength();
        var n = points.length;
        var dx, dy;
        if (fromTension) {
          const lp = [
            tp[tp.length - 4],
            tp[tp.length - 3],
            tp[tp.length - 2],
            tp[tp.length - 1],
            points[n - 2],
            points[n - 1]
          ];
          const lastLength = Path_1$2.Path.calcLength(tp[tp.length - 4], tp[tp.length - 3], "C", lp);
          const previous = Path_1$2.Path.getPointOnQuadraticBezier(Math.min(1, 1 - length / lastLength), lp[0], lp[1], lp[2], lp[3], lp[4], lp[5]);
          dx = points[n - 2] - previous.x;
          dy = points[n - 1] - previous.y;
        } else {
          dx = points[n - 2] - points[n - 4];
          dy = points[n - 1] - points[n - 3];
        }
        var radians = (Math.atan2(dy, dx) + PI2) % PI2;
        var width = this.pointerWidth();
        if (this.pointerAtEnding()) {
          ctx.save();
          ctx.beginPath();
          ctx.translate(points[n - 2], points[n - 1]);
          ctx.rotate(radians);
          ctx.moveTo(0, 0);
          ctx.lineTo(-length, width / 2);
          ctx.lineTo(-length, -width / 2);
          ctx.closePath();
          ctx.restore();
          this.__fillStroke(ctx);
        }
        if (this.pointerAtBeginning()) {
          ctx.save();
          ctx.beginPath();
          ctx.translate(points[0], points[1]);
          if (fromTension) {
            dx = (tp[0] + tp[2]) / 2 - points[0];
            dy = (tp[1] + tp[3]) / 2 - points[1];
          } else {
            dx = points[2] - points[0];
            dy = points[3] - points[1];
          }
          ctx.rotate((Math.atan2(-dy, -dx) + PI2) % PI2);
          ctx.moveTo(0, 0);
          ctx.lineTo(-length, width / 2);
          ctx.lineTo(-length, -width / 2);
          ctx.closePath();
          ctx.restore();
          this.__fillStroke(ctx);
        }
      }
      __fillStroke(ctx) {
        var isDashEnabled = this.dashEnabled();
        if (isDashEnabled) {
          this.attrs.dashEnabled = false;
          ctx.setLineDash([]);
        }
        ctx.fillStrokeShape(this);
        if (isDashEnabled) {
          this.attrs.dashEnabled = true;
        }
      }
      getSelfRect() {
        const lineRect = super.getSelfRect();
        const offset = this.pointerWidth() / 2;
        return {
          x: lineRect.x - offset,
          y: lineRect.y - offset,
          width: lineRect.width + offset * 2,
          height: lineRect.height + offset * 2
        };
      }
    }
    Arrow$1.Arrow = Arrow;
    Arrow.prototype.className = "Arrow";
    (0, Global_1$d._registerNode)(Arrow);
    Factory_1$s.Factory.addGetterSetter(Arrow, "pointerLength", 10, (0, Validators_1$s.getNumberValidator)());
    Factory_1$s.Factory.addGetterSetter(Arrow, "pointerWidth", 10, (0, Validators_1$s.getNumberValidator)());
    Factory_1$s.Factory.addGetterSetter(Arrow, "pointerAtBeginning", false);
    Factory_1$s.Factory.addGetterSetter(Arrow, "pointerAtEnding", true);
    var Circle$1 = {};
    Object.defineProperty(Circle$1, "__esModule", { value: true });
    Circle$1.Circle = void 0;
    const Factory_1$r = Factory;
    const Shape_1$c = Shape;
    const Validators_1$r = Validators;
    const Global_1$c = Global;
    class Circle extends Shape_1$c.Shape {
      _sceneFunc(context) {
        context.beginPath();
        context.arc(0, 0, this.attrs.radius || 0, 0, Math.PI * 2, false);
        context.closePath();
        context.fillStrokeShape(this);
      }
      getWidth() {
        return this.radius() * 2;
      }
      getHeight() {
        return this.radius() * 2;
      }
      setWidth(width) {
        if (this.radius() !== width / 2) {
          this.radius(width / 2);
        }
      }
      setHeight(height) {
        if (this.radius() !== height / 2) {
          this.radius(height / 2);
        }
      }
    }
    Circle$1.Circle = Circle;
    Circle.prototype._centroid = true;
    Circle.prototype.className = "Circle";
    Circle.prototype._attrsAffectingSize = ["radius"];
    (0, Global_1$c._registerNode)(Circle);
    Factory_1$r.Factory.addGetterSetter(Circle, "radius", 0, (0, Validators_1$r.getNumberValidator)());
    var Ellipse$1 = {};
    Object.defineProperty(Ellipse$1, "__esModule", { value: true });
    Ellipse$1.Ellipse = void 0;
    const Factory_1$q = Factory;
    const Shape_1$b = Shape;
    const Validators_1$q = Validators;
    const Global_1$b = Global;
    class Ellipse extends Shape_1$b.Shape {
      _sceneFunc(context) {
        var rx2 = this.radiusX(), ry = this.radiusY();
        context.beginPath();
        context.save();
        if (rx2 !== ry) {
          context.scale(1, ry / rx2);
        }
        context.arc(0, 0, rx2, 0, Math.PI * 2, false);
        context.restore();
        context.closePath();
        context.fillStrokeShape(this);
      }
      getWidth() {
        return this.radiusX() * 2;
      }
      getHeight() {
        return this.radiusY() * 2;
      }
      setWidth(width) {
        this.radiusX(width / 2);
      }
      setHeight(height) {
        this.radiusY(height / 2);
      }
    }
    Ellipse$1.Ellipse = Ellipse;
    Ellipse.prototype.className = "Ellipse";
    Ellipse.prototype._centroid = true;
    Ellipse.prototype._attrsAffectingSize = ["radiusX", "radiusY"];
    (0, Global_1$b._registerNode)(Ellipse);
    Factory_1$q.Factory.addComponentsGetterSetter(Ellipse, "radius", ["x", "y"]);
    Factory_1$q.Factory.addGetterSetter(Ellipse, "radiusX", 0, (0, Validators_1$q.getNumberValidator)());
    Factory_1$q.Factory.addGetterSetter(Ellipse, "radiusY", 0, (0, Validators_1$q.getNumberValidator)());
    var Image$2 = {};
    Object.defineProperty(Image$2, "__esModule", { value: true });
    Image$2.Image = void 0;
    const Util_1$7 = Util;
    const Factory_1$p = Factory;
    const Shape_1$a = Shape;
    const Global_1$a = Global;
    const Validators_1$p = Validators;
    let Image$1 = class Image2 extends Shape_1$a.Shape {
      constructor(attrs) {
        super(attrs);
        this.on("imageChange.konva", () => {
          this._setImageLoad();
        });
        this._setImageLoad();
      }
      _setImageLoad() {
        const image2 = this.image();
        if (image2 && image2.complete) {
          return;
        }
        if (image2 && image2.readyState === 4) {
          return;
        }
        if (image2 && image2["addEventListener"]) {
          image2["addEventListener"]("load", () => {
            this._requestDraw();
          });
        }
      }
      _useBufferCanvas() {
        const hasCornerRadius = !!this.cornerRadius();
        const hasShadow = this.hasShadow();
        if (hasCornerRadius && hasShadow) {
          return true;
        }
        return super._useBufferCanvas(true);
      }
      _sceneFunc(context) {
        const width = this.getWidth();
        const height = this.getHeight();
        const cornerRadius = this.cornerRadius();
        const image2 = this.attrs.image;
        let params;
        if (image2) {
          const cropWidth = this.attrs.cropWidth;
          const cropHeight = this.attrs.cropHeight;
          if (cropWidth && cropHeight) {
            params = [
              image2,
              this.cropX(),
              this.cropY(),
              cropWidth,
              cropHeight,
              0,
              0,
              width,
              height
            ];
          } else {
            params = [image2, 0, 0, width, height];
          }
        }
        if (this.hasFill() || this.hasStroke() || cornerRadius) {
          context.beginPath();
          cornerRadius ? Util_1$7.Util.drawRoundedRectPath(context, width, height, cornerRadius) : context.rect(0, 0, width, height);
          context.closePath();
          context.fillStrokeShape(this);
        }
        if (image2) {
          if (cornerRadius) {
            context.clip();
          }
          context.drawImage.apply(context, params);
        }
      }
      _hitFunc(context) {
        var width = this.width(), height = this.height(), cornerRadius = this.cornerRadius();
        context.beginPath();
        if (!cornerRadius) {
          context.rect(0, 0, width, height);
        } else {
          Util_1$7.Util.drawRoundedRectPath(context, width, height, cornerRadius);
        }
        context.closePath();
        context.fillStrokeShape(this);
      }
      getWidth() {
        var _a2, _b;
        return (_a2 = this.attrs.width) !== null && _a2 !== void 0 ? _a2 : (_b = this.image()) === null || _b === void 0 ? void 0 : _b.width;
      }
      getHeight() {
        var _a2, _b;
        return (_a2 = this.attrs.height) !== null && _a2 !== void 0 ? _a2 : (_b = this.image()) === null || _b === void 0 ? void 0 : _b.height;
      }
      static fromURL(url, callback, onError = null) {
        var img = Util_1$7.Util.createImageElement();
        img.onload = function() {
          var image2 = new Image2({
            image: img
          });
          callback(image2);
        };
        img.onerror = onError;
        img.crossOrigin = "Anonymous";
        img.src = url;
      }
    };
    Image$2.Image = Image$1;
    Image$1.prototype.className = "Image";
    (0, Global_1$a._registerNode)(Image$1);
    Factory_1$p.Factory.addGetterSetter(Image$1, "cornerRadius", 0, (0, Validators_1$p.getNumberOrArrayOfNumbersValidator)(4));
    Factory_1$p.Factory.addGetterSetter(Image$1, "image");
    Factory_1$p.Factory.addComponentsGetterSetter(Image$1, "crop", ["x", "y", "width", "height"]);
    Factory_1$p.Factory.addGetterSetter(Image$1, "cropX", 0, (0, Validators_1$p.getNumberValidator)());
    Factory_1$p.Factory.addGetterSetter(Image$1, "cropY", 0, (0, Validators_1$p.getNumberValidator)());
    Factory_1$p.Factory.addGetterSetter(Image$1, "cropWidth", 0, (0, Validators_1$p.getNumberValidator)());
    Factory_1$p.Factory.addGetterSetter(Image$1, "cropHeight", 0, (0, Validators_1$p.getNumberValidator)());
    var Label$1 = {};
    Object.defineProperty(Label$1, "__esModule", { value: true });
    Label$1.Tag = Label$1.Label = void 0;
    const Factory_1$o = Factory;
    const Shape_1$9 = Shape;
    const Group_1$1 = Group$1;
    const Validators_1$o = Validators;
    const Global_1$9 = Global;
    var ATTR_CHANGE_LIST$2 = [
      "fontFamily",
      "fontSize",
      "fontStyle",
      "padding",
      "lineHeight",
      "text",
      "width",
      "height",
      "pointerDirection",
      "pointerWidth",
      "pointerHeight"
    ], CHANGE_KONVA$1 = "Change.konva", NONE$1 = "none", UP = "up", RIGHT$1 = "right", DOWN = "down", LEFT$1 = "left", attrChangeListLen$1 = ATTR_CHANGE_LIST$2.length;
    class Label extends Group_1$1.Group {
      constructor(config2) {
        super(config2);
        this.on("add.konva", function(evt) {
          this._addListeners(evt.child);
          this._sync();
        });
      }
      getText() {
        return this.find("Text")[0];
      }
      getTag() {
        return this.find("Tag")[0];
      }
      _addListeners(text2) {
        var that = this, n;
        var func = function() {
          that._sync();
        };
        for (n = 0; n < attrChangeListLen$1; n++) {
          text2.on(ATTR_CHANGE_LIST$2[n] + CHANGE_KONVA$1, func);
        }
      }
      getWidth() {
        return this.getText().width();
      }
      getHeight() {
        return this.getText().height();
      }
      _sync() {
        var text2 = this.getText(), tag = this.getTag(), width, height, pointerDirection, pointerWidth, x2, y, pointerHeight;
        if (text2 && tag) {
          width = text2.width();
          height = text2.height();
          pointerDirection = tag.pointerDirection();
          pointerWidth = tag.pointerWidth();
          pointerHeight = tag.pointerHeight();
          x2 = 0;
          y = 0;
          switch (pointerDirection) {
            case UP:
              x2 = width / 2;
              y = -1 * pointerHeight;
              break;
            case RIGHT$1:
              x2 = width + pointerWidth;
              y = height / 2;
              break;
            case DOWN:
              x2 = width / 2;
              y = height + pointerHeight;
              break;
            case LEFT$1:
              x2 = -1 * pointerWidth;
              y = height / 2;
              break;
          }
          tag.setAttrs({
            x: -1 * x2,
            y: -1 * y,
            width,
            height
          });
          text2.setAttrs({
            x: -1 * x2,
            y: -1 * y
          });
        }
      }
    }
    Label$1.Label = Label;
    Label.prototype.className = "Label";
    (0, Global_1$9._registerNode)(Label);
    class Tag extends Shape_1$9.Shape {
      _sceneFunc(context) {
        var width = this.width(), height = this.height(), pointerDirection = this.pointerDirection(), pointerWidth = this.pointerWidth(), pointerHeight = this.pointerHeight(), cornerRadius = this.cornerRadius();
        let topLeft = 0;
        let topRight = 0;
        let bottomLeft = 0;
        let bottomRight = 0;
        if (typeof cornerRadius === "number") {
          topLeft = topRight = bottomLeft = bottomRight = Math.min(cornerRadius, width / 2, height / 2);
        } else {
          topLeft = Math.min(cornerRadius[0] || 0, width / 2, height / 2);
          topRight = Math.min(cornerRadius[1] || 0, width / 2, height / 2);
          bottomRight = Math.min(cornerRadius[2] || 0, width / 2, height / 2);
          bottomLeft = Math.min(cornerRadius[3] || 0, width / 2, height / 2);
        }
        context.beginPath();
        context.moveTo(topLeft, 0);
        if (pointerDirection === UP) {
          context.lineTo((width - pointerWidth) / 2, 0);
          context.lineTo(width / 2, -1 * pointerHeight);
          context.lineTo((width + pointerWidth) / 2, 0);
        }
        context.lineTo(width - topRight, 0);
        context.arc(width - topRight, topRight, topRight, Math.PI * 3 / 2, 0, false);
        if (pointerDirection === RIGHT$1) {
          context.lineTo(width, (height - pointerHeight) / 2);
          context.lineTo(width + pointerWidth, height / 2);
          context.lineTo(width, (height + pointerHeight) / 2);
        }
        context.lineTo(width, height - bottomRight);
        context.arc(width - bottomRight, height - bottomRight, bottomRight, 0, Math.PI / 2, false);
        if (pointerDirection === DOWN) {
          context.lineTo((width + pointerWidth) / 2, height);
          context.lineTo(width / 2, height + pointerHeight);
          context.lineTo((width - pointerWidth) / 2, height);
        }
        context.lineTo(bottomLeft, height);
        context.arc(bottomLeft, height - bottomLeft, bottomLeft, Math.PI / 2, Math.PI, false);
        if (pointerDirection === LEFT$1) {
          context.lineTo(0, (height + pointerHeight) / 2);
          context.lineTo(-1 * pointerWidth, height / 2);
          context.lineTo(0, (height - pointerHeight) / 2);
        }
        context.lineTo(0, topLeft);
        context.arc(topLeft, topLeft, topLeft, Math.PI, Math.PI * 3 / 2, false);
        context.closePath();
        context.fillStrokeShape(this);
      }
      getSelfRect() {
        var x2 = 0, y = 0, pointerWidth = this.pointerWidth(), pointerHeight = this.pointerHeight(), direction = this.pointerDirection(), width = this.width(), height = this.height();
        if (direction === UP) {
          y -= pointerHeight;
          height += pointerHeight;
        } else if (direction === DOWN) {
          height += pointerHeight;
        } else if (direction === LEFT$1) {
          x2 -= pointerWidth * 1.5;
          width += pointerWidth;
        } else if (direction === RIGHT$1) {
          width += pointerWidth * 1.5;
        }
        return {
          x: x2,
          y,
          width,
          height
        };
      }
    }
    Label$1.Tag = Tag;
    Tag.prototype.className = "Tag";
    (0, Global_1$9._registerNode)(Tag);
    Factory_1$o.Factory.addGetterSetter(Tag, "pointerDirection", NONE$1);
    Factory_1$o.Factory.addGetterSetter(Tag, "pointerWidth", 0, (0, Validators_1$o.getNumberValidator)());
    Factory_1$o.Factory.addGetterSetter(Tag, "pointerHeight", 0, (0, Validators_1$o.getNumberValidator)());
    Factory_1$o.Factory.addGetterSetter(Tag, "cornerRadius", 0, (0, Validators_1$o.getNumberOrArrayOfNumbersValidator)(4));
    var Rect$1 = {};
    Object.defineProperty(Rect$1, "__esModule", { value: true });
    Rect$1.Rect = void 0;
    const Factory_1$n = Factory;
    const Shape_1$8 = Shape;
    const Global_1$8 = Global;
    const Util_1$6 = Util;
    const Validators_1$n = Validators;
    class Rect extends Shape_1$8.Shape {
      _sceneFunc(context) {
        var cornerRadius = this.cornerRadius(), width = this.width(), height = this.height();
        context.beginPath();
        if (!cornerRadius) {
          context.rect(0, 0, width, height);
        } else {
          Util_1$6.Util.drawRoundedRectPath(context, width, height, cornerRadius);
        }
        context.closePath();
        context.fillStrokeShape(this);
      }
    }
    Rect$1.Rect = Rect;
    Rect.prototype.className = "Rect";
    (0, Global_1$8._registerNode)(Rect);
    Factory_1$n.Factory.addGetterSetter(Rect, "cornerRadius", 0, (0, Validators_1$n.getNumberOrArrayOfNumbersValidator)(4));
    var RegularPolygon$1 = {};
    Object.defineProperty(RegularPolygon$1, "__esModule", { value: true });
    RegularPolygon$1.RegularPolygon = void 0;
    const Factory_1$m = Factory;
    const Shape_1$7 = Shape;
    const Validators_1$m = Validators;
    const Global_1$7 = Global;
    class RegularPolygon extends Shape_1$7.Shape {
      _sceneFunc(context) {
        const points = this._getPoints();
        context.beginPath();
        context.moveTo(points[0].x, points[0].y);
        for (var n = 1; n < points.length; n++) {
          context.lineTo(points[n].x, points[n].y);
        }
        context.closePath();
        context.fillStrokeShape(this);
      }
      _getPoints() {
        const sides = this.attrs.sides;
        const radius = this.attrs.radius || 0;
        const points = [];
        for (var n = 0; n < sides; n++) {
          points.push({
            x: radius * Math.sin(n * 2 * Math.PI / sides),
            y: -1 * radius * Math.cos(n * 2 * Math.PI / sides)
          });
        }
        return points;
      }
      getSelfRect() {
        const points = this._getPoints();
        var minX = points[0].x;
        var maxX = points[0].y;
        var minY = points[0].x;
        var maxY = points[0].y;
        points.forEach((point) => {
          minX = Math.min(minX, point.x);
          maxX = Math.max(maxX, point.x);
          minY = Math.min(minY, point.y);
          maxY = Math.max(maxY, point.y);
        });
        return {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        };
      }
      getWidth() {
        return this.radius() * 2;
      }
      getHeight() {
        return this.radius() * 2;
      }
      setWidth(width) {
        this.radius(width / 2);
      }
      setHeight(height) {
        this.radius(height / 2);
      }
    }
    RegularPolygon$1.RegularPolygon = RegularPolygon;
    RegularPolygon.prototype.className = "RegularPolygon";
    RegularPolygon.prototype._centroid = true;
    RegularPolygon.prototype._attrsAffectingSize = ["radius"];
    (0, Global_1$7._registerNode)(RegularPolygon);
    Factory_1$m.Factory.addGetterSetter(RegularPolygon, "radius", 0, (0, Validators_1$m.getNumberValidator)());
    Factory_1$m.Factory.addGetterSetter(RegularPolygon, "sides", 0, (0, Validators_1$m.getNumberValidator)());
    var Ring$1 = {};
    Object.defineProperty(Ring$1, "__esModule", { value: true });
    Ring$1.Ring = void 0;
    const Factory_1$l = Factory;
    const Shape_1$6 = Shape;
    const Validators_1$l = Validators;
    const Global_1$6 = Global;
    var PIx2 = Math.PI * 2;
    class Ring extends Shape_1$6.Shape {
      _sceneFunc(context) {
        context.beginPath();
        context.arc(0, 0, this.innerRadius(), 0, PIx2, false);
        context.moveTo(this.outerRadius(), 0);
        context.arc(0, 0, this.outerRadius(), PIx2, 0, true);
        context.closePath();
        context.fillStrokeShape(this);
      }
      getWidth() {
        return this.outerRadius() * 2;
      }
      getHeight() {
        return this.outerRadius() * 2;
      }
      setWidth(width) {
        this.outerRadius(width / 2);
      }
      setHeight(height) {
        this.outerRadius(height / 2);
      }
    }
    Ring$1.Ring = Ring;
    Ring.prototype.className = "Ring";
    Ring.prototype._centroid = true;
    Ring.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
    (0, Global_1$6._registerNode)(Ring);
    Factory_1$l.Factory.addGetterSetter(Ring, "innerRadius", 0, (0, Validators_1$l.getNumberValidator)());
    Factory_1$l.Factory.addGetterSetter(Ring, "outerRadius", 0, (0, Validators_1$l.getNumberValidator)());
    var Sprite$1 = {};
    Object.defineProperty(Sprite$1, "__esModule", { value: true });
    Sprite$1.Sprite = void 0;
    const Factory_1$k = Factory;
    const Shape_1$5 = Shape;
    const Animation_1 = Animation$1;
    const Validators_1$k = Validators;
    const Global_1$5 = Global;
    class Sprite extends Shape_1$5.Shape {
      constructor(config2) {
        super(config2);
        this._updated = true;
        this.anim = new Animation_1.Animation(() => {
          var updated2 = this._updated;
          this._updated = false;
          return updated2;
        });
        this.on("animationChange.konva", function() {
          this.frameIndex(0);
        });
        this.on("frameIndexChange.konva", function() {
          this._updated = true;
        });
        this.on("frameRateChange.konva", function() {
          if (!this.anim.isRunning()) {
            return;
          }
          clearInterval(this.interval);
          this._setInterval();
        });
      }
      _sceneFunc(context) {
        var anim = this.animation(), index = this.frameIndex(), ix4 = index * 4, set2 = this.animations()[anim], offsets = this.frameOffsets(), x2 = set2[ix4 + 0], y = set2[ix4 + 1], width = set2[ix4 + 2], height = set2[ix4 + 3], image2 = this.image();
        if (this.hasFill() || this.hasStroke()) {
          context.beginPath();
          context.rect(0, 0, width, height);
          context.closePath();
          context.fillStrokeShape(this);
        }
        if (image2) {
          if (offsets) {
            var offset = offsets[anim], ix2 = index * 2;
            context.drawImage(image2, x2, y, width, height, offset[ix2 + 0], offset[ix2 + 1], width, height);
          } else {
            context.drawImage(image2, x2, y, width, height, 0, 0, width, height);
          }
        }
      }
      _hitFunc(context) {
        var anim = this.animation(), index = this.frameIndex(), ix4 = index * 4, set2 = this.animations()[anim], offsets = this.frameOffsets(), width = set2[ix4 + 2], height = set2[ix4 + 3];
        context.beginPath();
        if (offsets) {
          var offset = offsets[anim];
          var ix2 = index * 2;
          context.rect(offset[ix2 + 0], offset[ix2 + 1], width, height);
        } else {
          context.rect(0, 0, width, height);
        }
        context.closePath();
        context.fillShape(this);
      }
      _useBufferCanvas() {
        return super._useBufferCanvas(true);
      }
      _setInterval() {
        var that = this;
        this.interval = setInterval(function() {
          that._updateIndex();
        }, 1e3 / this.frameRate());
      }
      start() {
        if (this.isRunning()) {
          return;
        }
        var layer = this.getLayer();
        this.anim.setLayers(layer);
        this._setInterval();
        this.anim.start();
      }
      stop() {
        this.anim.stop();
        clearInterval(this.interval);
      }
      isRunning() {
        return this.anim.isRunning();
      }
      _updateIndex() {
        var index = this.frameIndex(), animation = this.animation(), animations = this.animations(), anim = animations[animation], len = anim.length / 4;
        if (index < len - 1) {
          this.frameIndex(index + 1);
        } else {
          this.frameIndex(0);
        }
      }
    }
    Sprite$1.Sprite = Sprite;
    Sprite.prototype.className = "Sprite";
    (0, Global_1$5._registerNode)(Sprite);
    Factory_1$k.Factory.addGetterSetter(Sprite, "animation");
    Factory_1$k.Factory.addGetterSetter(Sprite, "animations");
    Factory_1$k.Factory.addGetterSetter(Sprite, "frameOffsets");
    Factory_1$k.Factory.addGetterSetter(Sprite, "image");
    Factory_1$k.Factory.addGetterSetter(Sprite, "frameIndex", 0, (0, Validators_1$k.getNumberValidator)());
    Factory_1$k.Factory.addGetterSetter(Sprite, "frameRate", 17, (0, Validators_1$k.getNumberValidator)());
    Factory_1$k.Factory.backCompat(Sprite, {
      index: "frameIndex",
      getIndex: "getFrameIndex",
      setIndex: "setFrameIndex"
    });
    var Star$2 = {};
    Object.defineProperty(Star$2, "__esModule", { value: true });
    Star$2.Star = void 0;
    const Factory_1$j = Factory;
    const Shape_1$4 = Shape;
    const Validators_1$j = Validators;
    const Global_1$4 = Global;
    let Star$1 = class Star extends Shape_1$4.Shape {
      _sceneFunc(context) {
        var innerRadius = this.innerRadius(), outerRadius = this.outerRadius(), numPoints = this.numPoints();
        context.beginPath();
        context.moveTo(0, 0 - outerRadius);
        for (var n = 1; n < numPoints * 2; n++) {
          var radius = n % 2 === 0 ? outerRadius : innerRadius;
          var x2 = radius * Math.sin(n * Math.PI / numPoints);
          var y = -1 * radius * Math.cos(n * Math.PI / numPoints);
          context.lineTo(x2, y);
        }
        context.closePath();
        context.fillStrokeShape(this);
      }
      getWidth() {
        return this.outerRadius() * 2;
      }
      getHeight() {
        return this.outerRadius() * 2;
      }
      setWidth(width) {
        this.outerRadius(width / 2);
      }
      setHeight(height) {
        this.outerRadius(height / 2);
      }
    };
    Star$2.Star = Star$1;
    Star$1.prototype.className = "Star";
    Star$1.prototype._centroid = true;
    Star$1.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
    (0, Global_1$4._registerNode)(Star$1);
    Factory_1$j.Factory.addGetterSetter(Star$1, "numPoints", 5, (0, Validators_1$j.getNumberValidator)());
    Factory_1$j.Factory.addGetterSetter(Star$1, "innerRadius", 0, (0, Validators_1$j.getNumberValidator)());
    Factory_1$j.Factory.addGetterSetter(Star$1, "outerRadius", 0, (0, Validators_1$j.getNumberValidator)());
    var Text$1 = {};
    Object.defineProperty(Text$1, "__esModule", { value: true });
    Text$1.Text = Text$1.stringToArray = void 0;
    const Util_1$5 = Util;
    const Factory_1$i = Factory;
    const Shape_1$3 = Shape;
    const Global_1$3 = Global;
    const Validators_1$i = Validators;
    const Global_2$2 = Global;
    function stringToArray(string) {
      return Array.from(string);
    }
    Text$1.stringToArray = stringToArray;
    var AUTO = "auto", CENTER = "center", INHERIT = "inherit", JUSTIFY = "justify", CHANGE_KONVA = "Change.konva", CONTEXT_2D = "2d", DASH = "-", LEFT = "left", TEXT = "text", TEXT_UPPER = "Text", TOP = "top", BOTTOM = "bottom", MIDDLE = "middle", NORMAL$1 = "normal", PX_SPACE = "px ", SPACE = " ", RIGHT = "right", RTL = "rtl", WORD = "word", CHAR = "char", NONE = "none", ELLIPSIS = "…", ATTR_CHANGE_LIST$1 = [
      "direction",
      "fontFamily",
      "fontSize",
      "fontStyle",
      "fontVariant",
      "padding",
      "align",
      "verticalAlign",
      "lineHeight",
      "text",
      "width",
      "height",
      "wrap",
      "ellipsis",
      "letterSpacing"
    ], attrChangeListLen = ATTR_CHANGE_LIST$1.length;
    function normalizeFontFamily(fontFamily) {
      return fontFamily.split(",").map((family) => {
        family = family.trim();
        const hasSpace = family.indexOf(" ") >= 0;
        const hasQuotes = family.indexOf('"') >= 0 || family.indexOf("'") >= 0;
        if (hasSpace && !hasQuotes) {
          family = `"${family}"`;
        }
        return family;
      }).join(", ");
    }
    var dummyContext;
    function getDummyContext() {
      if (dummyContext) {
        return dummyContext;
      }
      dummyContext = Util_1$5.Util.createCanvasElement().getContext(CONTEXT_2D);
      return dummyContext;
    }
    function _fillFunc$1(context) {
      context.fillText(this._partialText, this._partialTextX, this._partialTextY);
    }
    function _strokeFunc$1(context) {
      context.setAttr("miterLimit", 2);
      context.strokeText(this._partialText, this._partialTextX, this._partialTextY);
    }
    function checkDefaultFill(config2) {
      config2 = config2 || {};
      if (!config2.fillLinearGradientColorStops && !config2.fillRadialGradientColorStops && !config2.fillPatternImage) {
        config2.fill = config2.fill || "black";
      }
      return config2;
    }
    class Text extends Shape_1$3.Shape {
      constructor(config2) {
        super(checkDefaultFill(config2));
        this._partialTextX = 0;
        this._partialTextY = 0;
        for (var n = 0; n < attrChangeListLen; n++) {
          this.on(ATTR_CHANGE_LIST$1[n] + CHANGE_KONVA, this._setTextData);
        }
        this._setTextData();
      }
      _sceneFunc(context) {
        var textArr = this.textArr, textArrLen = textArr.length;
        if (!this.text()) {
          return;
        }
        var padding = this.padding(), fontSize = this.fontSize(), lineHeightPx = this.lineHeight() * fontSize, verticalAlign = this.verticalAlign(), direction = this.direction(), alignY = 0, align = this.align(), totalWidth = this.getWidth(), letterSpacing = this.letterSpacing(), fill = this.fill(), textDecoration = this.textDecoration(), shouldUnderline = textDecoration.indexOf("underline") !== -1, shouldLineThrough = textDecoration.indexOf("line-through") !== -1, n;
        direction = direction === INHERIT ? context.direction : direction;
        var translateY = lineHeightPx / 2;
        var baseline = MIDDLE;
        if (Global_1$3.Konva._fixTextRendering) {
          var metrics = this.measureSize("M");
          baseline = "alphabetic";
          translateY = (metrics.fontBoundingBoxAscent - metrics.fontBoundingBoxDescent) / 2 + lineHeightPx / 2;
        }
        var lineTranslateX = 0;
        var lineTranslateY = 0;
        if (direction === RTL) {
          context.setAttr("direction", direction);
        }
        context.setAttr("font", this._getContextFont());
        context.setAttr("textBaseline", baseline);
        context.setAttr("textAlign", LEFT);
        if (verticalAlign === MIDDLE) {
          alignY = (this.getHeight() - textArrLen * lineHeightPx - padding * 2) / 2;
        } else if (verticalAlign === BOTTOM) {
          alignY = this.getHeight() - textArrLen * lineHeightPx - padding * 2;
        }
        context.translate(padding, alignY + padding);
        for (n = 0; n < textArrLen; n++) {
          var lineTranslateX = 0;
          var lineTranslateY = 0;
          var obj = textArr[n], text2 = obj.text, width = obj.width, lastLine = obj.lastInParagraph, spacesNumber, oneWord, lineWidth;
          context.save();
          if (align === RIGHT) {
            lineTranslateX += totalWidth - width - padding * 2;
          } else if (align === CENTER) {
            lineTranslateX += (totalWidth - width - padding * 2) / 2;
          }
          if (shouldUnderline) {
            context.save();
            context.beginPath();
            let yOffset = Global_1$3.Konva._fixTextRendering ? Math.round(fontSize / 4) : Math.round(fontSize / 2);
            const x2 = lineTranslateX;
            const y = translateY + lineTranslateY + yOffset;
            context.moveTo(x2, y);
            spacesNumber = text2.split(" ").length - 1;
            oneWord = spacesNumber === 0;
            lineWidth = align === JUSTIFY && !lastLine ? totalWidth - padding * 2 : width;
            context.lineTo(x2 + Math.round(lineWidth), y);
            context.lineWidth = fontSize / 15;
            const gradient = this._getLinearGradient();
            context.strokeStyle = gradient || fill;
            context.stroke();
            context.restore();
          }
          if (shouldLineThrough) {
            context.save();
            context.beginPath();
            let yOffset = Global_1$3.Konva._fixTextRendering ? -Math.round(fontSize / 4) : 0;
            context.moveTo(lineTranslateX, translateY + lineTranslateY + yOffset);
            spacesNumber = text2.split(" ").length - 1;
            oneWord = spacesNumber === 0;
            lineWidth = align === JUSTIFY && lastLine && !oneWord ? totalWidth - padding * 2 : width;
            context.lineTo(lineTranslateX + Math.round(lineWidth), translateY + lineTranslateY + yOffset);
            context.lineWidth = fontSize / 15;
            const gradient = this._getLinearGradient();
            context.strokeStyle = gradient || fill;
            context.stroke();
            context.restore();
          }
          if (direction !== RTL && (letterSpacing !== 0 || align === JUSTIFY)) {
            spacesNumber = text2.split(" ").length - 1;
            var array = stringToArray(text2);
            for (var li = 0; li < array.length; li++) {
              var letter = array[li];
              if (letter === " " && !lastLine && align === JUSTIFY) {
                lineTranslateX += (totalWidth - padding * 2 - width) / spacesNumber;
              }
              this._partialTextX = lineTranslateX;
              this._partialTextY = translateY + lineTranslateY;
              this._partialText = letter;
              context.fillStrokeShape(this);
              lineTranslateX += this.measureSize(letter).width + letterSpacing;
            }
          } else {
            if (letterSpacing !== 0) {
              context.setAttr("letterSpacing", `${letterSpacing}px`);
            }
            this._partialTextX = lineTranslateX;
            this._partialTextY = translateY + lineTranslateY;
            this._partialText = text2;
            context.fillStrokeShape(this);
          }
          context.restore();
          if (textArrLen > 1) {
            translateY += lineHeightPx;
          }
        }
      }
      _hitFunc(context) {
        var width = this.getWidth(), height = this.getHeight();
        context.beginPath();
        context.rect(0, 0, width, height);
        context.closePath();
        context.fillStrokeShape(this);
      }
      setText(text2) {
        var str2 = Util_1$5.Util._isString(text2) ? text2 : text2 === null || text2 === void 0 ? "" : text2 + "";
        this._setAttr(TEXT, str2);
        return this;
      }
      getWidth() {
        var isAuto = this.attrs.width === AUTO || this.attrs.width === void 0;
        return isAuto ? this.getTextWidth() + this.padding() * 2 : this.attrs.width;
      }
      getHeight() {
        var isAuto = this.attrs.height === AUTO || this.attrs.height === void 0;
        return isAuto ? this.fontSize() * this.textArr.length * this.lineHeight() + this.padding() * 2 : this.attrs.height;
      }
      getTextWidth() {
        return this.textWidth;
      }
      getTextHeight() {
        Util_1$5.Util.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.");
        return this.textHeight;
      }
      measureSize(text2) {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        var _context = getDummyContext(), fontSize = this.fontSize(), metrics;
        _context.save();
        _context.font = this._getContextFont();
        metrics = _context.measureText(text2);
        _context.restore();
        const scaleFactor = fontSize / 100;
        return {
          actualBoundingBoxAscent: (_a2 = metrics.actualBoundingBoxAscent) !== null && _a2 !== void 0 ? _a2 : 71.58203125 * scaleFactor,
          actualBoundingBoxDescent: (_b = metrics.actualBoundingBoxDescent) !== null && _b !== void 0 ? _b : 0,
          actualBoundingBoxLeft: (_c = metrics.actualBoundingBoxLeft) !== null && _c !== void 0 ? _c : -7.421875 * scaleFactor,
          actualBoundingBoxRight: (_d = metrics.actualBoundingBoxRight) !== null && _d !== void 0 ? _d : 75.732421875 * scaleFactor,
          alphabeticBaseline: (_e = metrics.alphabeticBaseline) !== null && _e !== void 0 ? _e : 0,
          emHeightAscent: (_f = metrics.emHeightAscent) !== null && _f !== void 0 ? _f : 100 * scaleFactor,
          emHeightDescent: (_g = metrics.emHeightDescent) !== null && _g !== void 0 ? _g : -20 * scaleFactor,
          fontBoundingBoxAscent: (_h = metrics.fontBoundingBoxAscent) !== null && _h !== void 0 ? _h : 91 * scaleFactor,
          fontBoundingBoxDescent: (_j = metrics.fontBoundingBoxDescent) !== null && _j !== void 0 ? _j : 21 * scaleFactor,
          hangingBaseline: (_k = metrics.hangingBaseline) !== null && _k !== void 0 ? _k : 72.80000305175781 * scaleFactor,
          ideographicBaseline: (_l = metrics.ideographicBaseline) !== null && _l !== void 0 ? _l : -21 * scaleFactor,
          width: metrics.width,
          height: fontSize
        };
      }
      _getContextFont() {
        return this.fontStyle() + SPACE + this.fontVariant() + SPACE + (this.fontSize() + PX_SPACE) + normalizeFontFamily(this.fontFamily());
      }
      _addTextLine(line) {
        const align = this.align();
        if (align === JUSTIFY) {
          line = line.trim();
        }
        var width = this._getTextWidth(line);
        return this.textArr.push({
          text: line,
          width,
          lastInParagraph: false
        });
      }
      _getTextWidth(text2) {
        var letterSpacing = this.letterSpacing();
        var length = text2.length;
        return getDummyContext().measureText(text2).width + (length ? letterSpacing * (length - 1) : 0);
      }
      _setTextData() {
        var lines = this.text().split("\n"), fontSize = +this.fontSize(), textWidth = 0, lineHeightPx = this.lineHeight() * fontSize, width = this.attrs.width, height = this.attrs.height, fixedWidth = width !== AUTO && width !== void 0, fixedHeight = height !== AUTO && height !== void 0, padding = this.padding(), maxWidth = width - padding * 2, maxHeightPx = height - padding * 2, currentHeightPx = 0, wrap = this.wrap(), shouldWrap = wrap !== NONE, wrapAtWord = wrap !== CHAR && shouldWrap, shouldAddEllipsis = this.ellipsis();
        this.textArr = [];
        getDummyContext().font = this._getContextFont();
        var additionalWidth = shouldAddEllipsis ? this._getTextWidth(ELLIPSIS) : 0;
        for (var i2 = 0, max = lines.length; i2 < max; ++i2) {
          var line = lines[i2];
          var lineWidth = this._getTextWidth(line);
          if (fixedWidth && lineWidth > maxWidth) {
            while (line.length > 0) {
              var low = 0, high = line.length, match = "", matchWidth = 0;
              while (low < high) {
                var mid2 = low + high >>> 1, substr = line.slice(0, mid2 + 1), substrWidth = this._getTextWidth(substr) + additionalWidth;
                if (substrWidth <= maxWidth) {
                  low = mid2 + 1;
                  match = substr;
                  matchWidth = substrWidth;
                } else {
                  high = mid2;
                }
              }
              if (match) {
                if (wrapAtWord) {
                  var wrapIndex;
                  var nextChar = line[match.length];
                  var nextIsSpaceOrDash = nextChar === SPACE || nextChar === DASH;
                  if (nextIsSpaceOrDash && matchWidth <= maxWidth) {
                    wrapIndex = match.length;
                  } else {
                    wrapIndex = Math.max(match.lastIndexOf(SPACE), match.lastIndexOf(DASH)) + 1;
                  }
                  if (wrapIndex > 0) {
                    low = wrapIndex;
                    match = match.slice(0, low);
                    matchWidth = this._getTextWidth(match);
                  }
                }
                match = match.trimRight();
                this._addTextLine(match);
                textWidth = Math.max(textWidth, matchWidth);
                currentHeightPx += lineHeightPx;
                var shouldHandleEllipsis = this._shouldHandleEllipsis(currentHeightPx);
                if (shouldHandleEllipsis) {
                  this._tryToAddEllipsisToLastLine();
                  break;
                }
                line = line.slice(low);
                line = line.trimLeft();
                if (line.length > 0) {
                  lineWidth = this._getTextWidth(line);
                  if (lineWidth <= maxWidth) {
                    this._addTextLine(line);
                    currentHeightPx += lineHeightPx;
                    textWidth = Math.max(textWidth, lineWidth);
                    break;
                  }
                }
              } else {
                break;
              }
            }
          } else {
            this._addTextLine(line);
            currentHeightPx += lineHeightPx;
            textWidth = Math.max(textWidth, lineWidth);
            if (this._shouldHandleEllipsis(currentHeightPx) && i2 < max - 1) {
              this._tryToAddEllipsisToLastLine();
            }
          }
          if (this.textArr[this.textArr.length - 1]) {
            this.textArr[this.textArr.length - 1].lastInParagraph = true;
          }
          if (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx) {
            break;
          }
        }
        this.textHeight = fontSize;
        this.textWidth = textWidth;
      }
      _shouldHandleEllipsis(currentHeightPx) {
        var fontSize = +this.fontSize(), lineHeightPx = this.lineHeight() * fontSize, height = this.attrs.height, fixedHeight = height !== AUTO && height !== void 0, padding = this.padding(), maxHeightPx = height - padding * 2, wrap = this.wrap(), shouldWrap = wrap !== NONE;
        return !shouldWrap || fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx;
      }
      _tryToAddEllipsisToLastLine() {
        var width = this.attrs.width, fixedWidth = width !== AUTO && width !== void 0, padding = this.padding(), maxWidth = width - padding * 2, shouldAddEllipsis = this.ellipsis();
        var lastLine = this.textArr[this.textArr.length - 1];
        if (!lastLine || !shouldAddEllipsis) {
          return;
        }
        if (fixedWidth) {
          var haveSpace = this._getTextWidth(lastLine.text + ELLIPSIS) < maxWidth;
          if (!haveSpace) {
            lastLine.text = lastLine.text.slice(0, lastLine.text.length - 3);
          }
        }
        this.textArr.splice(this.textArr.length - 1, 1);
        this._addTextLine(lastLine.text + ELLIPSIS);
      }
      getStrokeScaleEnabled() {
        return true;
      }
      _useBufferCanvas() {
        const hasLine = this.textDecoration().indexOf("underline") !== -1 || this.textDecoration().indexOf("line-through") !== -1;
        const hasShadow = this.hasShadow();
        if (hasLine && hasShadow) {
          return true;
        }
        return super._useBufferCanvas();
      }
    }
    Text$1.Text = Text;
    Text.prototype._fillFunc = _fillFunc$1;
    Text.prototype._strokeFunc = _strokeFunc$1;
    Text.prototype.className = TEXT_UPPER;
    Text.prototype._attrsAffectingSize = [
      "text",
      "fontSize",
      "padding",
      "wrap",
      "lineHeight",
      "letterSpacing"
    ];
    (0, Global_2$2._registerNode)(Text);
    Factory_1$i.Factory.overWriteSetter(Text, "width", (0, Validators_1$i.getNumberOrAutoValidator)());
    Factory_1$i.Factory.overWriteSetter(Text, "height", (0, Validators_1$i.getNumberOrAutoValidator)());
    Factory_1$i.Factory.addGetterSetter(Text, "direction", INHERIT);
    Factory_1$i.Factory.addGetterSetter(Text, "fontFamily", "Arial");
    Factory_1$i.Factory.addGetterSetter(Text, "fontSize", 12, (0, Validators_1$i.getNumberValidator)());
    Factory_1$i.Factory.addGetterSetter(Text, "fontStyle", NORMAL$1);
    Factory_1$i.Factory.addGetterSetter(Text, "fontVariant", NORMAL$1);
    Factory_1$i.Factory.addGetterSetter(Text, "padding", 0, (0, Validators_1$i.getNumberValidator)());
    Factory_1$i.Factory.addGetterSetter(Text, "align", LEFT);
    Factory_1$i.Factory.addGetterSetter(Text, "verticalAlign", TOP);
    Factory_1$i.Factory.addGetterSetter(Text, "lineHeight", 1, (0, Validators_1$i.getNumberValidator)());
    Factory_1$i.Factory.addGetterSetter(Text, "wrap", WORD);
    Factory_1$i.Factory.addGetterSetter(Text, "ellipsis", false, (0, Validators_1$i.getBooleanValidator)());
    Factory_1$i.Factory.addGetterSetter(Text, "letterSpacing", 0, (0, Validators_1$i.getNumberValidator)());
    Factory_1$i.Factory.addGetterSetter(Text, "text", "", (0, Validators_1$i.getStringValidator)());
    Factory_1$i.Factory.addGetterSetter(Text, "textDecoration", "");
    var TextPath$1 = {};
    Object.defineProperty(TextPath$1, "__esModule", { value: true });
    TextPath$1.TextPath = void 0;
    const Util_1$4 = Util;
    const Factory_1$h = Factory;
    const Shape_1$2 = Shape;
    const Path_1$1 = Path$1;
    const Text_1$1 = Text$1;
    const Validators_1$h = Validators;
    const Global_1$2 = Global;
    var EMPTY_STRING = "", NORMAL = "normal";
    function _fillFunc(context) {
      context.fillText(this.partialText, 0, 0);
    }
    function _strokeFunc(context) {
      context.strokeText(this.partialText, 0, 0);
    }
    class TextPath extends Shape_1$2.Shape {
      constructor(config2) {
        super(config2);
        this.dummyCanvas = Util_1$4.Util.createCanvasElement();
        this.dataArray = [];
        this._readDataAttribute();
        this.on("dataChange.konva", function() {
          this._readDataAttribute();
          this._setTextData();
        });
        this.on("textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva", this._setTextData);
        this._setTextData();
      }
      _getTextPathLength() {
        return Path_1$1.Path.getPathLength(this.dataArray);
      }
      _getPointAtLength(length) {
        if (!this.attrs.data) {
          return null;
        }
        const totalLength = this.pathLength;
        if (length - 1 > totalLength) {
          return null;
        }
        return Path_1$1.Path.getPointAtLengthOfDataArray(length, this.dataArray);
      }
      _readDataAttribute() {
        this.dataArray = Path_1$1.Path.parsePathData(this.attrs.data);
        this.pathLength = this._getTextPathLength();
      }
      _sceneFunc(context) {
        context.setAttr("font", this._getContextFont());
        context.setAttr("textBaseline", this.textBaseline());
        context.setAttr("textAlign", "left");
        context.save();
        var textDecoration = this.textDecoration();
        var fill = this.fill();
        var fontSize = this.fontSize();
        var glyphInfo = this.glyphInfo;
        if (textDecoration === "underline") {
          context.beginPath();
        }
        for (var i2 = 0; i2 < glyphInfo.length; i2++) {
          context.save();
          var p0 = glyphInfo[i2].p0;
          context.translate(p0.x, p0.y);
          context.rotate(glyphInfo[i2].rotation);
          this.partialText = glyphInfo[i2].text;
          context.fillStrokeShape(this);
          if (textDecoration === "underline") {
            if (i2 === 0) {
              context.moveTo(0, fontSize / 2 + 1);
            }
            context.lineTo(fontSize, fontSize / 2 + 1);
          }
          context.restore();
        }
        if (textDecoration === "underline") {
          context.strokeStyle = fill;
          context.lineWidth = fontSize / 20;
          context.stroke();
        }
        context.restore();
      }
      _hitFunc(context) {
        context.beginPath();
        var glyphInfo = this.glyphInfo;
        if (glyphInfo.length >= 1) {
          var p0 = glyphInfo[0].p0;
          context.moveTo(p0.x, p0.y);
        }
        for (var i2 = 0; i2 < glyphInfo.length; i2++) {
          var p1 = glyphInfo[i2].p1;
          context.lineTo(p1.x, p1.y);
        }
        context.setAttr("lineWidth", this.fontSize());
        context.setAttr("strokeStyle", this.colorKey);
        context.stroke();
      }
      getTextWidth() {
        return this.textWidth;
      }
      getTextHeight() {
        Util_1$4.Util.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.");
        return this.textHeight;
      }
      setText(text2) {
        return Text_1$1.Text.prototype.setText.call(this, text2);
      }
      _getContextFont() {
        return Text_1$1.Text.prototype._getContextFont.call(this);
      }
      _getTextSize(text2) {
        var dummyCanvas = this.dummyCanvas;
        var _context = dummyCanvas.getContext("2d");
        _context.save();
        _context.font = this._getContextFont();
        var metrics = _context.measureText(text2);
        _context.restore();
        return {
          width: metrics.width,
          height: parseInt(`${this.fontSize()}`, 10)
        };
      }
      _setTextData() {
        const { width, height } = this._getTextSize(this.attrs.text);
        this.textWidth = width;
        this.textHeight = height;
        this.glyphInfo = [];
        if (!this.attrs.data) {
          return null;
        }
        const letterSpacing = this.letterSpacing();
        const align = this.align();
        const kerningFunc = this.kerningFunc();
        const textWidth = Math.max(this.textWidth + ((this.attrs.text || "").length - 1) * letterSpacing, 0);
        let offset = 0;
        if (align === "center") {
          offset = Math.max(0, this.pathLength / 2 - textWidth / 2);
        }
        if (align === "right") {
          offset = Math.max(0, this.pathLength - textWidth);
        }
        const charArr = (0, Text_1$1.stringToArray)(this.text());
        let offsetToGlyph = offset;
        for (var i2 = 0; i2 < charArr.length; i2++) {
          const charStartPoint = this._getPointAtLength(offsetToGlyph);
          if (!charStartPoint)
            return;
          let glyphWidth = this._getTextSize(charArr[i2]).width + letterSpacing;
          if (charArr[i2] === " " && align === "justify") {
            const numberOfSpaces = this.text().split(" ").length - 1;
            glyphWidth += (this.pathLength - textWidth) / numberOfSpaces;
          }
          const charEndPoint = this._getPointAtLength(offsetToGlyph + glyphWidth);
          if (!charEndPoint)
            return;
          const width2 = Path_1$1.Path.getLineLength(charStartPoint.x, charStartPoint.y, charEndPoint.x, charEndPoint.y);
          let kern = 0;
          if (kerningFunc) {
            try {
              kern = kerningFunc(charArr[i2 - 1], charArr[i2]) * this.fontSize();
            } catch (e) {
              kern = 0;
            }
          }
          charStartPoint.x += kern;
          charEndPoint.x += kern;
          this.textWidth += kern;
          const midpoint = Path_1$1.Path.getPointOnLine(kern + width2 / 2, charStartPoint.x, charStartPoint.y, charEndPoint.x, charEndPoint.y);
          const rotation = Math.atan2(charEndPoint.y - charStartPoint.y, charEndPoint.x - charStartPoint.x);
          this.glyphInfo.push({
            transposeX: midpoint.x,
            transposeY: midpoint.y,
            text: charArr[i2],
            rotation,
            p0: charStartPoint,
            p1: charEndPoint
          });
          offsetToGlyph += glyphWidth;
        }
      }
      getSelfRect() {
        if (!this.glyphInfo.length) {
          return {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
        var points = [];
        this.glyphInfo.forEach(function(info) {
          points.push(info.p0.x);
          points.push(info.p0.y);
          points.push(info.p1.x);
          points.push(info.p1.y);
        });
        var minX = points[0] || 0;
        var maxX = points[0] || 0;
        var minY = points[1] || 0;
        var maxY = points[1] || 0;
        var x2, y;
        for (var i2 = 0; i2 < points.length / 2; i2++) {
          x2 = points[i2 * 2];
          y = points[i2 * 2 + 1];
          minX = Math.min(minX, x2);
          maxX = Math.max(maxX, x2);
          minY = Math.min(minY, y);
          maxY = Math.max(maxY, y);
        }
        var fontSize = this.fontSize();
        return {
          x: minX - fontSize / 2,
          y: minY - fontSize / 2,
          width: maxX - minX + fontSize,
          height: maxY - minY + fontSize
        };
      }
      destroy() {
        Util_1$4.Util.releaseCanvas(this.dummyCanvas);
        return super.destroy();
      }
    }
    TextPath$1.TextPath = TextPath;
    TextPath.prototype._fillFunc = _fillFunc;
    TextPath.prototype._strokeFunc = _strokeFunc;
    TextPath.prototype._fillFuncHit = _fillFunc;
    TextPath.prototype._strokeFuncHit = _strokeFunc;
    TextPath.prototype.className = "TextPath";
    TextPath.prototype._attrsAffectingSize = ["text", "fontSize", "data"];
    (0, Global_1$2._registerNode)(TextPath);
    Factory_1$h.Factory.addGetterSetter(TextPath, "data");
    Factory_1$h.Factory.addGetterSetter(TextPath, "fontFamily", "Arial");
    Factory_1$h.Factory.addGetterSetter(TextPath, "fontSize", 12, (0, Validators_1$h.getNumberValidator)());
    Factory_1$h.Factory.addGetterSetter(TextPath, "fontStyle", NORMAL);
    Factory_1$h.Factory.addGetterSetter(TextPath, "align", "left");
    Factory_1$h.Factory.addGetterSetter(TextPath, "letterSpacing", 0, (0, Validators_1$h.getNumberValidator)());
    Factory_1$h.Factory.addGetterSetter(TextPath, "textBaseline", "middle");
    Factory_1$h.Factory.addGetterSetter(TextPath, "fontVariant", NORMAL);
    Factory_1$h.Factory.addGetterSetter(TextPath, "text", EMPTY_STRING);
    Factory_1$h.Factory.addGetterSetter(TextPath, "textDecoration", null);
    Factory_1$h.Factory.addGetterSetter(TextPath, "kerningFunc", null);
    var Transformer$1 = {};
    Object.defineProperty(Transformer$1, "__esModule", { value: true });
    Transformer$1.Transformer = void 0;
    const Util_1$3 = Util;
    const Factory_1$g = Factory;
    const Node_1$f = Node$2;
    const Shape_1$1 = Shape;
    const Rect_1$1 = Rect$1;
    const Group_1 = Group$1;
    const Global_1$1 = Global;
    const Validators_1$g = Validators;
    const Global_2$1 = Global;
    var EVENTS_NAME = "tr-konva";
    var ATTR_CHANGE_LIST = [
      "resizeEnabledChange",
      "rotateAnchorOffsetChange",
      "rotateEnabledChange",
      "enabledAnchorsChange",
      "anchorSizeChange",
      "borderEnabledChange",
      "borderStrokeChange",
      "borderStrokeWidthChange",
      "borderDashChange",
      "anchorStrokeChange",
      "anchorStrokeWidthChange",
      "anchorFillChange",
      "anchorCornerRadiusChange",
      "ignoreStrokeChange",
      "anchorStyleFuncChange"
    ].map((e) => e + `.${EVENTS_NAME}`).join(" ");
    var NODES_RECT = "nodesRect";
    var TRANSFORM_CHANGE_STR = [
      "widthChange",
      "heightChange",
      "scaleXChange",
      "scaleYChange",
      "skewXChange",
      "skewYChange",
      "rotationChange",
      "offsetXChange",
      "offsetYChange",
      "transformsEnabledChange",
      "strokeWidthChange"
    ];
    var ANGLES = {
      "top-left": -45,
      "top-center": 0,
      "top-right": 45,
      "middle-right": -90,
      "middle-left": 90,
      "bottom-left": -135,
      "bottom-center": 180,
      "bottom-right": 135
    };
    const TOUCH_DEVICE = "ontouchstart" in Global_1$1.Konva._global;
    function getCursor(anchorName, rad, rotateCursor) {
      if (anchorName === "rotater") {
        return rotateCursor;
      }
      rad += Util_1$3.Util.degToRad(ANGLES[anchorName] || 0);
      var angle2 = (Util_1$3.Util.radToDeg(rad) % 360 + 360) % 360;
      if (Util_1$3.Util._inRange(angle2, 315 + 22.5, 360) || Util_1$3.Util._inRange(angle2, 0, 22.5)) {
        return "ns-resize";
      } else if (Util_1$3.Util._inRange(angle2, 45 - 22.5, 45 + 22.5)) {
        return "nesw-resize";
      } else if (Util_1$3.Util._inRange(angle2, 90 - 22.5, 90 + 22.5)) {
        return "ew-resize";
      } else if (Util_1$3.Util._inRange(angle2, 135 - 22.5, 135 + 22.5)) {
        return "nwse-resize";
      } else if (Util_1$3.Util._inRange(angle2, 180 - 22.5, 180 + 22.5)) {
        return "ns-resize";
      } else if (Util_1$3.Util._inRange(angle2, 225 - 22.5, 225 + 22.5)) {
        return "nesw-resize";
      } else if (Util_1$3.Util._inRange(angle2, 270 - 22.5, 270 + 22.5)) {
        return "ew-resize";
      } else if (Util_1$3.Util._inRange(angle2, 315 - 22.5, 315 + 22.5)) {
        return "nwse-resize";
      } else {
        Util_1$3.Util.error("Transformer has unknown angle for cursor detection: " + angle2);
        return "pointer";
      }
    }
    var ANCHORS_NAMES = [
      "top-left",
      "top-center",
      "top-right",
      "middle-right",
      "middle-left",
      "bottom-left",
      "bottom-center",
      "bottom-right"
    ];
    var MAX_SAFE_INTEGER = 1e8;
    function getCenter(shape) {
      return {
        x: shape.x + shape.width / 2 * Math.cos(shape.rotation) + shape.height / 2 * Math.sin(-shape.rotation),
        y: shape.y + shape.height / 2 * Math.cos(shape.rotation) + shape.width / 2 * Math.sin(shape.rotation)
      };
    }
    function rotateAroundPoint(shape, angleRad, point) {
      const x2 = point.x + (shape.x - point.x) * Math.cos(angleRad) - (shape.y - point.y) * Math.sin(angleRad);
      const y = point.y + (shape.x - point.x) * Math.sin(angleRad) + (shape.y - point.y) * Math.cos(angleRad);
      return {
        ...shape,
        rotation: shape.rotation + angleRad,
        x: x2,
        y
      };
    }
    function rotateAroundCenter(shape, deltaRad) {
      const center = getCenter(shape);
      return rotateAroundPoint(shape, deltaRad, center);
    }
    function getSnap(snaps, newRotationRad, tol) {
      let snapped = newRotationRad;
      for (let i2 = 0; i2 < snaps.length; i2++) {
        const angle2 = Global_1$1.Konva.getAngle(snaps[i2]);
        const absDiff = Math.abs(angle2 - newRotationRad) % (Math.PI * 2);
        const dif = Math.min(absDiff, Math.PI * 2 - absDiff);
        if (dif < tol) {
          snapped = angle2;
        }
      }
      return snapped;
    }
    let activeTransformersCount = 0;
    class Transformer extends Group_1.Group {
      constructor(config2) {
        super(config2);
        this._movingAnchorName = null;
        this._transforming = false;
        this._createElements();
        this._handleMouseMove = this._handleMouseMove.bind(this);
        this._handleMouseUp = this._handleMouseUp.bind(this);
        this.update = this.update.bind(this);
        this.on(ATTR_CHANGE_LIST, this.update);
        if (this.getNode()) {
          this.update();
        }
      }
      attachTo(node) {
        this.setNode(node);
        return this;
      }
      setNode(node) {
        Util_1$3.Util.warn("tr.setNode(shape), tr.node(shape) and tr.attachTo(shape) methods are deprecated. Please use tr.nodes(nodesArray) instead.");
        return this.setNodes([node]);
      }
      getNode() {
        return this._nodes && this._nodes[0];
      }
      _getEventNamespace() {
        return EVENTS_NAME + this._id;
      }
      setNodes(nodes = []) {
        if (this._nodes && this._nodes.length) {
          this.detach();
        }
        const filteredNodes = nodes.filter((node) => {
          if (node.isAncestorOf(this)) {
            Util_1$3.Util.error("Konva.Transformer cannot be an a child of the node you are trying to attach");
            return false;
          }
          return true;
        });
        this._nodes = nodes = filteredNodes;
        if (nodes.length === 1 && this.useSingleNodeRotation()) {
          this.rotation(nodes[0].getAbsoluteRotation());
        } else {
          this.rotation(0);
        }
        this._nodes.forEach((node) => {
          const onChange = () => {
            if (this.nodes().length === 1 && this.useSingleNodeRotation()) {
              this.rotation(this.nodes()[0].getAbsoluteRotation());
            }
            this._resetTransformCache();
            if (!this._transforming && !this.isDragging()) {
              this.update();
            }
          };
          const additionalEvents = node._attrsAffectingSize.map((prop2) => prop2 + "Change." + this._getEventNamespace()).join(" ");
          node.on(additionalEvents, onChange);
          node.on(TRANSFORM_CHANGE_STR.map((e) => e + `.${this._getEventNamespace()}`).join(" "), onChange);
          node.on(`absoluteTransformChange.${this._getEventNamespace()}`, onChange);
          this._proxyDrag(node);
        });
        this._resetTransformCache();
        var elementsCreated = !!this.findOne(".top-left");
        if (elementsCreated) {
          this.update();
        }
        return this;
      }
      _proxyDrag(node) {
        let lastPos;
        node.on(`dragstart.${this._getEventNamespace()}`, (e) => {
          lastPos = node.getAbsolutePosition();
          if (!this.isDragging() && node !== this.findOne(".back")) {
            this.startDrag(e, false);
          }
        });
        node.on(`dragmove.${this._getEventNamespace()}`, (e) => {
          if (!lastPos) {
            return;
          }
          const abs = node.getAbsolutePosition();
          const dx = abs.x - lastPos.x;
          const dy = abs.y - lastPos.y;
          this.nodes().forEach((otherNode) => {
            if (otherNode === node) {
              return;
            }
            if (otherNode.isDragging()) {
              return;
            }
            const otherAbs = otherNode.getAbsolutePosition();
            otherNode.setAbsolutePosition({
              x: otherAbs.x + dx,
              y: otherAbs.y + dy
            });
            otherNode.startDrag(e);
          });
          lastPos = null;
        });
      }
      getNodes() {
        return this._nodes || [];
      }
      getActiveAnchor() {
        return this._movingAnchorName;
      }
      detach() {
        if (this._nodes) {
          this._nodes.forEach((node) => {
            node.off("." + this._getEventNamespace());
          });
        }
        this._nodes = [];
        this._resetTransformCache();
      }
      _resetTransformCache() {
        this._clearCache(NODES_RECT);
        this._clearCache("transform");
        this._clearSelfAndDescendantCache("absoluteTransform");
      }
      _getNodeRect() {
        return this._getCache(NODES_RECT, this.__getNodeRect);
      }
      __getNodeShape(node, rot = this.rotation(), relative) {
        var rect2 = node.getClientRect({
          skipTransform: true,
          skipShadow: true,
          skipStroke: this.ignoreStroke()
        });
        var absScale = node.getAbsoluteScale(relative);
        var absPos = node.getAbsolutePosition(relative);
        var dx = rect2.x * absScale.x - node.offsetX() * absScale.x;
        var dy = rect2.y * absScale.y - node.offsetY() * absScale.y;
        const rotation = (Global_1$1.Konva.getAngle(node.getAbsoluteRotation()) + Math.PI * 2) % (Math.PI * 2);
        const box = {
          x: absPos.x + dx * Math.cos(rotation) + dy * Math.sin(-rotation),
          y: absPos.y + dy * Math.cos(rotation) + dx * Math.sin(rotation),
          width: rect2.width * absScale.x,
          height: rect2.height * absScale.y,
          rotation
        };
        return rotateAroundPoint(box, -Global_1$1.Konva.getAngle(rot), {
          x: 0,
          y: 0
        });
      }
      __getNodeRect() {
        var node = this.getNode();
        if (!node) {
          return {
            x: -MAX_SAFE_INTEGER,
            y: -MAX_SAFE_INTEGER,
            width: 0,
            height: 0,
            rotation: 0
          };
        }
        const totalPoints = [];
        this.nodes().map((node2) => {
          const box = node2.getClientRect({
            skipTransform: true,
            skipShadow: true,
            skipStroke: this.ignoreStroke()
          });
          var points = [
            { x: box.x, y: box.y },
            { x: box.x + box.width, y: box.y },
            { x: box.x + box.width, y: box.y + box.height },
            { x: box.x, y: box.y + box.height }
          ];
          var trans = node2.getAbsoluteTransform();
          points.forEach(function(point) {
            var transformed = trans.point(point);
            totalPoints.push(transformed);
          });
        });
        const tr = new Util_1$3.Transform();
        tr.rotate(-Global_1$1.Konva.getAngle(this.rotation()));
        var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        totalPoints.forEach(function(point) {
          var transformed = tr.point(point);
          if (minX === void 0) {
            minX = maxX = transformed.x;
            minY = maxY = transformed.y;
          }
          minX = Math.min(minX, transformed.x);
          minY = Math.min(minY, transformed.y);
          maxX = Math.max(maxX, transformed.x);
          maxY = Math.max(maxY, transformed.y);
        });
        tr.invert();
        const p2 = tr.point({ x: minX, y: minY });
        return {
          x: p2.x,
          y: p2.y,
          width: maxX - minX,
          height: maxY - minY,
          rotation: Global_1$1.Konva.getAngle(this.rotation())
        };
      }
      getX() {
        return this._getNodeRect().x;
      }
      getY() {
        return this._getNodeRect().y;
      }
      getWidth() {
        return this._getNodeRect().width;
      }
      getHeight() {
        return this._getNodeRect().height;
      }
      _createElements() {
        this._createBack();
        ANCHORS_NAMES.forEach((name) => {
          this._createAnchor(name);
        });
        this._createAnchor("rotater");
      }
      _createAnchor(name) {
        var anchor = new Rect_1$1.Rect({
          stroke: "rgb(0, 161, 255)",
          fill: "white",
          strokeWidth: 1,
          name: name + " _anchor",
          dragDistance: 0,
          draggable: true,
          hitStrokeWidth: TOUCH_DEVICE ? 10 : "auto"
        });
        var self2 = this;
        anchor.on("mousedown touchstart", function(e) {
          self2._handleMouseDown(e);
        });
        anchor.on("dragstart", (e) => {
          anchor.stopDrag();
          e.cancelBubble = true;
        });
        anchor.on("dragend", (e) => {
          e.cancelBubble = true;
        });
        anchor.on("mouseenter", () => {
          var rad = Global_1$1.Konva.getAngle(this.rotation());
          var rotateCursor = this.rotateAnchorCursor();
          var cursor = getCursor(name, rad, rotateCursor);
          anchor.getStage().content && (anchor.getStage().content.style.cursor = cursor);
          this._cursorChange = true;
        });
        anchor.on("mouseout", () => {
          anchor.getStage().content && (anchor.getStage().content.style.cursor = "");
          this._cursorChange = false;
        });
        this.add(anchor);
      }
      _createBack() {
        var back = new Shape_1$1.Shape({
          name: "back",
          width: 0,
          height: 0,
          draggable: true,
          sceneFunc(ctx, shape) {
            var tr = shape.getParent();
            var padding = tr.padding();
            ctx.beginPath();
            ctx.rect(-padding, -padding, shape.width() + padding * 2, shape.height() + padding * 2);
            ctx.moveTo(shape.width() / 2, -padding);
            if (tr.rotateEnabled() && tr.rotateLineVisible()) {
              ctx.lineTo(shape.width() / 2, -tr.rotateAnchorOffset() * Util_1$3.Util._sign(shape.height()) - padding);
            }
            ctx.fillStrokeShape(shape);
          },
          hitFunc: (ctx, shape) => {
            if (!this.shouldOverdrawWholeArea()) {
              return;
            }
            var padding = this.padding();
            ctx.beginPath();
            ctx.rect(-padding, -padding, shape.width() + padding * 2, shape.height() + padding * 2);
            ctx.fillStrokeShape(shape);
          }
        });
        this.add(back);
        this._proxyDrag(back);
        back.on("dragstart", (e) => {
          e.cancelBubble = true;
        });
        back.on("dragmove", (e) => {
          e.cancelBubble = true;
        });
        back.on("dragend", (e) => {
          e.cancelBubble = true;
        });
        this.on("dragmove", (e) => {
          this.update();
        });
      }
      _handleMouseDown(e) {
        if (this._transforming) {
          return;
        }
        this._movingAnchorName = e.target.name().split(" ")[0];
        var attrs = this._getNodeRect();
        var width = attrs.width;
        var height = attrs.height;
        var hypotenuse = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));
        this.sin = Math.abs(height / hypotenuse);
        this.cos = Math.abs(width / hypotenuse);
        if (typeof window !== "undefined") {
          window.addEventListener("mousemove", this._handleMouseMove);
          window.addEventListener("touchmove", this._handleMouseMove);
          window.addEventListener("mouseup", this._handleMouseUp, true);
          window.addEventListener("touchend", this._handleMouseUp, true);
        }
        this._transforming = true;
        var ap2 = e.target.getAbsolutePosition();
        var pos = e.target.getStage().getPointerPosition();
        this._anchorDragOffset = {
          x: pos.x - ap2.x,
          y: pos.y - ap2.y
        };
        activeTransformersCount++;
        this._fire("transformstart", { evt: e.evt, target: this.getNode() });
        this._nodes.forEach((target2) => {
          target2._fire("transformstart", { evt: e.evt, target: target2 });
        });
      }
      _handleMouseMove(e) {
        var x2, y, newHypotenuse;
        var anchorNode = this.findOne("." + this._movingAnchorName);
        var stage = anchorNode.getStage();
        stage.setPointersPositions(e);
        const pp = stage.getPointerPosition();
        let newNodePos = {
          x: pp.x - this._anchorDragOffset.x,
          y: pp.y - this._anchorDragOffset.y
        };
        const oldAbs = anchorNode.getAbsolutePosition();
        if (this.anchorDragBoundFunc()) {
          newNodePos = this.anchorDragBoundFunc()(oldAbs, newNodePos, e);
        }
        anchorNode.setAbsolutePosition(newNodePos);
        const newAbs = anchorNode.getAbsolutePosition();
        if (oldAbs.x === newAbs.x && oldAbs.y === newAbs.y) {
          return;
        }
        if (this._movingAnchorName === "rotater") {
          var attrs = this._getNodeRect();
          x2 = anchorNode.x() - attrs.width / 2;
          y = -anchorNode.y() + attrs.height / 2;
          let delta2 = Math.atan2(-y, x2) + Math.PI / 2;
          if (attrs.height < 0) {
            delta2 -= Math.PI;
          }
          var oldRotation = Global_1$1.Konva.getAngle(this.rotation());
          const newRotation = oldRotation + delta2;
          const tol = Global_1$1.Konva.getAngle(this.rotationSnapTolerance());
          const snappedRot = getSnap(this.rotationSnaps(), newRotation, tol);
          const diff = snappedRot - attrs.rotation;
          const shape = rotateAroundCenter(attrs, diff);
          this._fitNodesInto(shape, e);
          return;
        }
        var shiftBehavior = this.shiftBehavior();
        var keepProportion;
        if (shiftBehavior === "inverted") {
          keepProportion = this.keepRatio() && !e.shiftKey;
        } else if (shiftBehavior === "none") {
          keepProportion = this.keepRatio();
        } else {
          keepProportion = this.keepRatio() || e.shiftKey;
        }
        var centeredScaling = this.centeredScaling() || e.altKey;
        if (this._movingAnchorName === "top-left") {
          if (keepProportion) {
            var comparePoint = centeredScaling ? {
              x: this.width() / 2,
              y: this.height() / 2
            } : {
              x: this.findOne(".bottom-right").x(),
              y: this.findOne(".bottom-right").y()
            };
            newHypotenuse = Math.sqrt(Math.pow(comparePoint.x - anchorNode.x(), 2) + Math.pow(comparePoint.y - anchorNode.y(), 2));
            var reverseX = this.findOne(".top-left").x() > comparePoint.x ? -1 : 1;
            var reverseY = this.findOne(".top-left").y() > comparePoint.y ? -1 : 1;
            x2 = newHypotenuse * this.cos * reverseX;
            y = newHypotenuse * this.sin * reverseY;
            this.findOne(".top-left").x(comparePoint.x - x2);
            this.findOne(".top-left").y(comparePoint.y - y);
          }
        } else if (this._movingAnchorName === "top-center") {
          this.findOne(".top-left").y(anchorNode.y());
        } else if (this._movingAnchorName === "top-right") {
          if (keepProportion) {
            var comparePoint = centeredScaling ? {
              x: this.width() / 2,
              y: this.height() / 2
            } : {
              x: this.findOne(".bottom-left").x(),
              y: this.findOne(".bottom-left").y()
            };
            newHypotenuse = Math.sqrt(Math.pow(anchorNode.x() - comparePoint.x, 2) + Math.pow(comparePoint.y - anchorNode.y(), 2));
            var reverseX = this.findOne(".top-right").x() < comparePoint.x ? -1 : 1;
            var reverseY = this.findOne(".top-right").y() > comparePoint.y ? -1 : 1;
            x2 = newHypotenuse * this.cos * reverseX;
            y = newHypotenuse * this.sin * reverseY;
            this.findOne(".top-right").x(comparePoint.x + x2);
            this.findOne(".top-right").y(comparePoint.y - y);
          }
          var pos = anchorNode.position();
          this.findOne(".top-left").y(pos.y);
          this.findOne(".bottom-right").x(pos.x);
        } else if (this._movingAnchorName === "middle-left") {
          this.findOne(".top-left").x(anchorNode.x());
        } else if (this._movingAnchorName === "middle-right") {
          this.findOne(".bottom-right").x(anchorNode.x());
        } else if (this._movingAnchorName === "bottom-left") {
          if (keepProportion) {
            var comparePoint = centeredScaling ? {
              x: this.width() / 2,
              y: this.height() / 2
            } : {
              x: this.findOne(".top-right").x(),
              y: this.findOne(".top-right").y()
            };
            newHypotenuse = Math.sqrt(Math.pow(comparePoint.x - anchorNode.x(), 2) + Math.pow(anchorNode.y() - comparePoint.y, 2));
            var reverseX = comparePoint.x < anchorNode.x() ? -1 : 1;
            var reverseY = anchorNode.y() < comparePoint.y ? -1 : 1;
            x2 = newHypotenuse * this.cos * reverseX;
            y = newHypotenuse * this.sin * reverseY;
            anchorNode.x(comparePoint.x - x2);
            anchorNode.y(comparePoint.y + y);
          }
          pos = anchorNode.position();
          this.findOne(".top-left").x(pos.x);
          this.findOne(".bottom-right").y(pos.y);
        } else if (this._movingAnchorName === "bottom-center") {
          this.findOne(".bottom-right").y(anchorNode.y());
        } else if (this._movingAnchorName === "bottom-right") {
          if (keepProportion) {
            var comparePoint = centeredScaling ? {
              x: this.width() / 2,
              y: this.height() / 2
            } : {
              x: this.findOne(".top-left").x(),
              y: this.findOne(".top-left").y()
            };
            newHypotenuse = Math.sqrt(Math.pow(anchorNode.x() - comparePoint.x, 2) + Math.pow(anchorNode.y() - comparePoint.y, 2));
            var reverseX = this.findOne(".bottom-right").x() < comparePoint.x ? -1 : 1;
            var reverseY = this.findOne(".bottom-right").y() < comparePoint.y ? -1 : 1;
            x2 = newHypotenuse * this.cos * reverseX;
            y = newHypotenuse * this.sin * reverseY;
            this.findOne(".bottom-right").x(comparePoint.x + x2);
            this.findOne(".bottom-right").y(comparePoint.y + y);
          }
        } else {
          console.error(new Error("Wrong position argument of selection resizer: " + this._movingAnchorName));
        }
        var centeredScaling = this.centeredScaling() || e.altKey;
        if (centeredScaling) {
          var topLeft = this.findOne(".top-left");
          var bottomRight = this.findOne(".bottom-right");
          var topOffsetX = topLeft.x();
          var topOffsetY = topLeft.y();
          var bottomOffsetX = this.getWidth() - bottomRight.x();
          var bottomOffsetY = this.getHeight() - bottomRight.y();
          bottomRight.move({
            x: -topOffsetX,
            y: -topOffsetY
          });
          topLeft.move({
            x: bottomOffsetX,
            y: bottomOffsetY
          });
        }
        var absPos = this.findOne(".top-left").getAbsolutePosition();
        x2 = absPos.x;
        y = absPos.y;
        var width = this.findOne(".bottom-right").x() - this.findOne(".top-left").x();
        var height = this.findOne(".bottom-right").y() - this.findOne(".top-left").y();
        this._fitNodesInto({
          x: x2,
          y,
          width,
          height,
          rotation: Global_1$1.Konva.getAngle(this.rotation())
        }, e);
      }
      _handleMouseUp(e) {
        this._removeEvents(e);
      }
      getAbsoluteTransform() {
        return this.getTransform();
      }
      _removeEvents(e) {
        var _a2;
        if (this._transforming) {
          this._transforming = false;
          if (typeof window !== "undefined") {
            window.removeEventListener("mousemove", this._handleMouseMove);
            window.removeEventListener("touchmove", this._handleMouseMove);
            window.removeEventListener("mouseup", this._handleMouseUp, true);
            window.removeEventListener("touchend", this._handleMouseUp, true);
          }
          var node = this.getNode();
          activeTransformersCount--;
          this._fire("transformend", { evt: e, target: node });
          (_a2 = this.getLayer()) === null || _a2 === void 0 ? void 0 : _a2.batchDraw();
          if (node) {
            this._nodes.forEach((target2) => {
              var _a3;
              target2._fire("transformend", { evt: e, target: target2 });
              (_a3 = target2.getLayer()) === null || _a3 === void 0 ? void 0 : _a3.batchDraw();
            });
          }
          this._movingAnchorName = null;
        }
      }
      _fitNodesInto(newAttrs, evt) {
        var oldAttrs = this._getNodeRect();
        const minSize = 1;
        if (Util_1$3.Util._inRange(newAttrs.width, -this.padding() * 2 - minSize, minSize)) {
          this.update();
          return;
        }
        if (Util_1$3.Util._inRange(newAttrs.height, -this.padding() * 2 - minSize, minSize)) {
          this.update();
          return;
        }
        var t = new Util_1$3.Transform();
        t.rotate(Global_1$1.Konva.getAngle(this.rotation()));
        if (this._movingAnchorName && newAttrs.width < 0 && this._movingAnchorName.indexOf("left") >= 0) {
          const offset = t.point({
            x: -this.padding() * 2,
            y: 0
          });
          newAttrs.x += offset.x;
          newAttrs.y += offset.y;
          newAttrs.width += this.padding() * 2;
          this._movingAnchorName = this._movingAnchorName.replace("left", "right");
          this._anchorDragOffset.x -= offset.x;
          this._anchorDragOffset.y -= offset.y;
        } else if (this._movingAnchorName && newAttrs.width < 0 && this._movingAnchorName.indexOf("right") >= 0) {
          const offset = t.point({
            x: this.padding() * 2,
            y: 0
          });
          this._movingAnchorName = this._movingAnchorName.replace("right", "left");
          this._anchorDragOffset.x -= offset.x;
          this._anchorDragOffset.y -= offset.y;
          newAttrs.width += this.padding() * 2;
        }
        if (this._movingAnchorName && newAttrs.height < 0 && this._movingAnchorName.indexOf("top") >= 0) {
          const offset = t.point({
            x: 0,
            y: -this.padding() * 2
          });
          newAttrs.x += offset.x;
          newAttrs.y += offset.y;
          this._movingAnchorName = this._movingAnchorName.replace("top", "bottom");
          this._anchorDragOffset.x -= offset.x;
          this._anchorDragOffset.y -= offset.y;
          newAttrs.height += this.padding() * 2;
        } else if (this._movingAnchorName && newAttrs.height < 0 && this._movingAnchorName.indexOf("bottom") >= 0) {
          const offset = t.point({
            x: 0,
            y: this.padding() * 2
          });
          this._movingAnchorName = this._movingAnchorName.replace("bottom", "top");
          this._anchorDragOffset.x -= offset.x;
          this._anchorDragOffset.y -= offset.y;
          newAttrs.height += this.padding() * 2;
        }
        if (this.boundBoxFunc()) {
          const bounded = this.boundBoxFunc()(oldAttrs, newAttrs);
          if (bounded) {
            newAttrs = bounded;
          } else {
            Util_1$3.Util.warn("boundBoxFunc returned falsy. You should return new bound rect from it!");
          }
        }
        const baseSize = 1e7;
        const oldTr = new Util_1$3.Transform();
        oldTr.translate(oldAttrs.x, oldAttrs.y);
        oldTr.rotate(oldAttrs.rotation);
        oldTr.scale(oldAttrs.width / baseSize, oldAttrs.height / baseSize);
        const newTr = new Util_1$3.Transform();
        const newScaleX = newAttrs.width / baseSize;
        const newScaleY = newAttrs.height / baseSize;
        if (this.flipEnabled() === false) {
          newTr.translate(newAttrs.x, newAttrs.y);
          newTr.rotate(newAttrs.rotation);
          newTr.translate(newAttrs.width < 0 ? newAttrs.width : 0, newAttrs.height < 0 ? newAttrs.height : 0);
          newTr.scale(Math.abs(newScaleX), Math.abs(newScaleY));
        } else {
          newTr.translate(newAttrs.x, newAttrs.y);
          newTr.rotate(newAttrs.rotation);
          newTr.scale(newScaleX, newScaleY);
        }
        const delta2 = newTr.multiply(oldTr.invert());
        this._nodes.forEach((node) => {
          var _a2;
          const parentTransform = node.getParent().getAbsoluteTransform();
          const localTransform = node.getTransform().copy();
          localTransform.translate(node.offsetX(), node.offsetY());
          const newLocalTransform = new Util_1$3.Transform();
          newLocalTransform.multiply(parentTransform.copy().invert()).multiply(delta2).multiply(parentTransform).multiply(localTransform);
          const attrs = newLocalTransform.decompose();
          node.setAttrs(attrs);
          (_a2 = node.getLayer()) === null || _a2 === void 0 ? void 0 : _a2.batchDraw();
        });
        this.rotation(Util_1$3.Util._getRotation(newAttrs.rotation));
        this._nodes.forEach((node) => {
          this._fire("transform", { evt, target: node });
          node._fire("transform", { evt, target: node });
        });
        this._resetTransformCache();
        this.update();
        this.getLayer().batchDraw();
      }
      forceUpdate() {
        this._resetTransformCache();
        this.update();
      }
      _batchChangeChild(selector, attrs) {
        const anchor = this.findOne(selector);
        anchor.setAttrs(attrs);
      }
      update() {
        var _a2;
        var attrs = this._getNodeRect();
        this.rotation(Util_1$3.Util._getRotation(attrs.rotation));
        var width = attrs.width;
        var height = attrs.height;
        var enabledAnchors = this.enabledAnchors();
        var resizeEnabled = this.resizeEnabled();
        var padding = this.padding();
        var anchorSize = this.anchorSize();
        const anchors = this.find("._anchor");
        anchors.forEach((node) => {
          node.setAttrs({
            width: anchorSize,
            height: anchorSize,
            offsetX: anchorSize / 2,
            offsetY: anchorSize / 2,
            stroke: this.anchorStroke(),
            strokeWidth: this.anchorStrokeWidth(),
            fill: this.anchorFill(),
            cornerRadius: this.anchorCornerRadius()
          });
        });
        this._batchChangeChild(".top-left", {
          x: 0,
          y: 0,
          offsetX: anchorSize / 2 + padding,
          offsetY: anchorSize / 2 + padding,
          visible: resizeEnabled && enabledAnchors.indexOf("top-left") >= 0
        });
        this._batchChangeChild(".top-center", {
          x: width / 2,
          y: 0,
          offsetY: anchorSize / 2 + padding,
          visible: resizeEnabled && enabledAnchors.indexOf("top-center") >= 0
        });
        this._batchChangeChild(".top-right", {
          x: width,
          y: 0,
          offsetX: anchorSize / 2 - padding,
          offsetY: anchorSize / 2 + padding,
          visible: resizeEnabled && enabledAnchors.indexOf("top-right") >= 0
        });
        this._batchChangeChild(".middle-left", {
          x: 0,
          y: height / 2,
          offsetX: anchorSize / 2 + padding,
          visible: resizeEnabled && enabledAnchors.indexOf("middle-left") >= 0
        });
        this._batchChangeChild(".middle-right", {
          x: width,
          y: height / 2,
          offsetX: anchorSize / 2 - padding,
          visible: resizeEnabled && enabledAnchors.indexOf("middle-right") >= 0
        });
        this._batchChangeChild(".bottom-left", {
          x: 0,
          y: height,
          offsetX: anchorSize / 2 + padding,
          offsetY: anchorSize / 2 - padding,
          visible: resizeEnabled && enabledAnchors.indexOf("bottom-left") >= 0
        });
        this._batchChangeChild(".bottom-center", {
          x: width / 2,
          y: height,
          offsetY: anchorSize / 2 - padding,
          visible: resizeEnabled && enabledAnchors.indexOf("bottom-center") >= 0
        });
        this._batchChangeChild(".bottom-right", {
          x: width,
          y: height,
          offsetX: anchorSize / 2 - padding,
          offsetY: anchorSize / 2 - padding,
          visible: resizeEnabled && enabledAnchors.indexOf("bottom-right") >= 0
        });
        this._batchChangeChild(".rotater", {
          x: width / 2,
          y: -this.rotateAnchorOffset() * Util_1$3.Util._sign(height) - padding,
          visible: this.rotateEnabled()
        });
        this._batchChangeChild(".back", {
          width,
          height,
          visible: this.borderEnabled(),
          stroke: this.borderStroke(),
          strokeWidth: this.borderStrokeWidth(),
          dash: this.borderDash(),
          x: 0,
          y: 0
        });
        const styleFunc = this.anchorStyleFunc();
        if (styleFunc) {
          anchors.forEach((node) => {
            styleFunc(node);
          });
        }
        (_a2 = this.getLayer()) === null || _a2 === void 0 ? void 0 : _a2.batchDraw();
      }
      isTransforming() {
        return this._transforming;
      }
      stopTransform() {
        if (this._transforming) {
          this._removeEvents();
          var anchorNode = this.findOne("." + this._movingAnchorName);
          if (anchorNode) {
            anchorNode.stopDrag();
          }
        }
      }
      destroy() {
        if (this.getStage() && this._cursorChange) {
          this.getStage().content && (this.getStage().content.style.cursor = "");
        }
        Group_1.Group.prototype.destroy.call(this);
        this.detach();
        this._removeEvents();
        return this;
      }
      toObject() {
        return Node_1$f.Node.prototype.toObject.call(this);
      }
      clone(obj) {
        var node = Node_1$f.Node.prototype.clone.call(this, obj);
        return node;
      }
      getClientRect() {
        if (this.nodes().length > 0) {
          return super.getClientRect();
        } else {
          return { x: 0, y: 0, width: 0, height: 0 };
        }
      }
    }
    Transformer$1.Transformer = Transformer;
    Transformer.isTransforming = () => {
      return activeTransformersCount > 0;
    };
    function validateAnchors(val) {
      if (!(val instanceof Array)) {
        Util_1$3.Util.warn("enabledAnchors value should be an array");
      }
      if (val instanceof Array) {
        val.forEach(function(name) {
          if (ANCHORS_NAMES.indexOf(name) === -1) {
            Util_1$3.Util.warn("Unknown anchor name: " + name + ". Available names are: " + ANCHORS_NAMES.join(", "));
          }
        });
      }
      return val || [];
    }
    Transformer.prototype.className = "Transformer";
    (0, Global_2$1._registerNode)(Transformer);
    Factory_1$g.Factory.addGetterSetter(Transformer, "enabledAnchors", ANCHORS_NAMES, validateAnchors);
    Factory_1$g.Factory.addGetterSetter(Transformer, "flipEnabled", true, (0, Validators_1$g.getBooleanValidator)());
    Factory_1$g.Factory.addGetterSetter(Transformer, "resizeEnabled", true);
    Factory_1$g.Factory.addGetterSetter(Transformer, "anchorSize", 10, (0, Validators_1$g.getNumberValidator)());
    Factory_1$g.Factory.addGetterSetter(Transformer, "rotateEnabled", true);
    Factory_1$g.Factory.addGetterSetter(Transformer, "rotateLineVisible", true);
    Factory_1$g.Factory.addGetterSetter(Transformer, "rotationSnaps", []);
    Factory_1$g.Factory.addGetterSetter(Transformer, "rotateAnchorOffset", 50, (0, Validators_1$g.getNumberValidator)());
    Factory_1$g.Factory.addGetterSetter(Transformer, "rotateAnchorCursor", "crosshair");
    Factory_1$g.Factory.addGetterSetter(Transformer, "rotationSnapTolerance", 5, (0, Validators_1$g.getNumberValidator)());
    Factory_1$g.Factory.addGetterSetter(Transformer, "borderEnabled", true);
    Factory_1$g.Factory.addGetterSetter(Transformer, "anchorStroke", "rgb(0, 161, 255)");
    Factory_1$g.Factory.addGetterSetter(Transformer, "anchorStrokeWidth", 1, (0, Validators_1$g.getNumberValidator)());
    Factory_1$g.Factory.addGetterSetter(Transformer, "anchorFill", "white");
    Factory_1$g.Factory.addGetterSetter(Transformer, "anchorCornerRadius", 0, (0, Validators_1$g.getNumberValidator)());
    Factory_1$g.Factory.addGetterSetter(Transformer, "borderStroke", "rgb(0, 161, 255)");
    Factory_1$g.Factory.addGetterSetter(Transformer, "borderStrokeWidth", 1, (0, Validators_1$g.getNumberValidator)());
    Factory_1$g.Factory.addGetterSetter(Transformer, "borderDash");
    Factory_1$g.Factory.addGetterSetter(Transformer, "keepRatio", true);
    Factory_1$g.Factory.addGetterSetter(Transformer, "shiftBehavior", "default");
    Factory_1$g.Factory.addGetterSetter(Transformer, "centeredScaling", false);
    Factory_1$g.Factory.addGetterSetter(Transformer, "ignoreStroke", false);
    Factory_1$g.Factory.addGetterSetter(Transformer, "padding", 0, (0, Validators_1$g.getNumberValidator)());
    Factory_1$g.Factory.addGetterSetter(Transformer, "node");
    Factory_1$g.Factory.addGetterSetter(Transformer, "nodes");
    Factory_1$g.Factory.addGetterSetter(Transformer, "boundBoxFunc");
    Factory_1$g.Factory.addGetterSetter(Transformer, "anchorDragBoundFunc");
    Factory_1$g.Factory.addGetterSetter(Transformer, "anchorStyleFunc");
    Factory_1$g.Factory.addGetterSetter(Transformer, "shouldOverdrawWholeArea", false);
    Factory_1$g.Factory.addGetterSetter(Transformer, "useSingleNodeRotation", true);
    Factory_1$g.Factory.backCompat(Transformer, {
      lineEnabled: "borderEnabled",
      rotateHandlerOffset: "rotateAnchorOffset",
      enabledHandlers: "enabledAnchors"
    });
    var Wedge$2 = {};
    Object.defineProperty(Wedge$2, "__esModule", { value: true });
    Wedge$2.Wedge = void 0;
    const Factory_1$f = Factory;
    const Shape_1 = Shape;
    const Global_1 = Global;
    const Validators_1$f = Validators;
    const Global_2 = Global;
    let Wedge$1 = class Wedge extends Shape_1.Shape {
      _sceneFunc(context) {
        context.beginPath();
        context.arc(0, 0, this.radius(), 0, Global_1.Konva.getAngle(this.angle()), this.clockwise());
        context.lineTo(0, 0);
        context.closePath();
        context.fillStrokeShape(this);
      }
      getWidth() {
        return this.radius() * 2;
      }
      getHeight() {
        return this.radius() * 2;
      }
      setWidth(width) {
        this.radius(width / 2);
      }
      setHeight(height) {
        this.radius(height / 2);
      }
    };
    Wedge$2.Wedge = Wedge$1;
    Wedge$1.prototype.className = "Wedge";
    Wedge$1.prototype._centroid = true;
    Wedge$1.prototype._attrsAffectingSize = ["radius"];
    (0, Global_2._registerNode)(Wedge$1);
    Factory_1$f.Factory.addGetterSetter(Wedge$1, "radius", 0, (0, Validators_1$f.getNumberValidator)());
    Factory_1$f.Factory.addGetterSetter(Wedge$1, "angle", 0, (0, Validators_1$f.getNumberValidator)());
    Factory_1$f.Factory.addGetterSetter(Wedge$1, "clockwise", false);
    Factory_1$f.Factory.backCompat(Wedge$1, {
      angleDeg: "angle",
      getAngleDeg: "getAngle",
      setAngleDeg: "setAngle"
    });
    var Blur$1 = {};
    Object.defineProperty(Blur$1, "__esModule", { value: true });
    Blur$1.Blur = void 0;
    const Factory_1$e = Factory;
    const Node_1$e = Node$2;
    const Validators_1$e = Validators;
    function BlurStack() {
      this.r = 0;
      this.g = 0;
      this.b = 0;
      this.a = 0;
      this.next = null;
    }
    var mul_table = [
      512,
      512,
      456,
      512,
      328,
      456,
      335,
      512,
      405,
      328,
      271,
      456,
      388,
      335,
      292,
      512,
      454,
      405,
      364,
      328,
      298,
      271,
      496,
      456,
      420,
      388,
      360,
      335,
      312,
      292,
      273,
      512,
      482,
      454,
      428,
      405,
      383,
      364,
      345,
      328,
      312,
      298,
      284,
      271,
      259,
      496,
      475,
      456,
      437,
      420,
      404,
      388,
      374,
      360,
      347,
      335,
      323,
      312,
      302,
      292,
      282,
      273,
      265,
      512,
      497,
      482,
      468,
      454,
      441,
      428,
      417,
      405,
      394,
      383,
      373,
      364,
      354,
      345,
      337,
      328,
      320,
      312,
      305,
      298,
      291,
      284,
      278,
      271,
      265,
      259,
      507,
      496,
      485,
      475,
      465,
      456,
      446,
      437,
      428,
      420,
      412,
      404,
      396,
      388,
      381,
      374,
      367,
      360,
      354,
      347,
      341,
      335,
      329,
      323,
      318,
      312,
      307,
      302,
      297,
      292,
      287,
      282,
      278,
      273,
      269,
      265,
      261,
      512,
      505,
      497,
      489,
      482,
      475,
      468,
      461,
      454,
      447,
      441,
      435,
      428,
      422,
      417,
      411,
      405,
      399,
      394,
      389,
      383,
      378,
      373,
      368,
      364,
      359,
      354,
      350,
      345,
      341,
      337,
      332,
      328,
      324,
      320,
      316,
      312,
      309,
      305,
      301,
      298,
      294,
      291,
      287,
      284,
      281,
      278,
      274,
      271,
      268,
      265,
      262,
      259,
      257,
      507,
      501,
      496,
      491,
      485,
      480,
      475,
      470,
      465,
      460,
      456,
      451,
      446,
      442,
      437,
      433,
      428,
      424,
      420,
      416,
      412,
      408,
      404,
      400,
      396,
      392,
      388,
      385,
      381,
      377,
      374,
      370,
      367,
      363,
      360,
      357,
      354,
      350,
      347,
      344,
      341,
      338,
      335,
      332,
      329,
      326,
      323,
      320,
      318,
      315,
      312,
      310,
      307,
      304,
      302,
      299,
      297,
      294,
      292,
      289,
      287,
      285,
      282,
      280,
      278,
      275,
      273,
      271,
      269,
      267,
      265,
      263,
      261,
      259
    ];
    var shg_table = [
      9,
      11,
      12,
      13,
      13,
      14,
      14,
      15,
      15,
      15,
      15,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24
    ];
    function filterGaussBlurRGBA(imageData, radius) {
      var pixels = imageData.data, width = imageData.width, height = imageData.height;
      var x2, y, i2, p2, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, r_out_sum, g_out_sum, b_out_sum, a_out_sum, r_in_sum, g_in_sum, b_in_sum, a_in_sum, pr2, pg, pb, pa, rbs;
      var div2 = radius + radius + 1, widthMinus1 = width - 1, heightMinus1 = height - 1, radiusPlus1 = radius + 1, sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2, stackStart = new BlurStack(), stackEnd = null, stack2 = stackStart, stackIn = null, stackOut = null, mul_sum = mul_table[radius], shg_sum = shg_table[radius];
      for (i2 = 1; i2 < div2; i2++) {
        stack2 = stack2.next = new BlurStack();
        if (i2 === radiusPlus1) {
          stackEnd = stack2;
        }
      }
      stack2.next = stackStart;
      yw = yi = 0;
      for (y = 0; y < height; y++) {
        r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
        r_out_sum = radiusPlus1 * (pr2 = pixels[yi]);
        g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
        b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
        a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
        r_sum += sumFactor * pr2;
        g_sum += sumFactor * pg;
        b_sum += sumFactor * pb;
        a_sum += sumFactor * pa;
        stack2 = stackStart;
        for (i2 = 0; i2 < radiusPlus1; i2++) {
          stack2.r = pr2;
          stack2.g = pg;
          stack2.b = pb;
          stack2.a = pa;
          stack2 = stack2.next;
        }
        for (i2 = 1; i2 < radiusPlus1; i2++) {
          p2 = yi + ((widthMinus1 < i2 ? widthMinus1 : i2) << 2);
          r_sum += (stack2.r = pr2 = pixels[p2]) * (rbs = radiusPlus1 - i2);
          g_sum += (stack2.g = pg = pixels[p2 + 1]) * rbs;
          b_sum += (stack2.b = pb = pixels[p2 + 2]) * rbs;
          a_sum += (stack2.a = pa = pixels[p2 + 3]) * rbs;
          r_in_sum += pr2;
          g_in_sum += pg;
          b_in_sum += pb;
          a_in_sum += pa;
          stack2 = stack2.next;
        }
        stackIn = stackStart;
        stackOut = stackEnd;
        for (x2 = 0; x2 < width; x2++) {
          pixels[yi + 3] = pa = a_sum * mul_sum >> shg_sum;
          if (pa !== 0) {
            pa = 255 / pa;
            pixels[yi] = (r_sum * mul_sum >> shg_sum) * pa;
            pixels[yi + 1] = (g_sum * mul_sum >> shg_sum) * pa;
            pixels[yi + 2] = (b_sum * mul_sum >> shg_sum) * pa;
          } else {
            pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
          }
          r_sum -= r_out_sum;
          g_sum -= g_out_sum;
          b_sum -= b_out_sum;
          a_sum -= a_out_sum;
          r_out_sum -= stackIn.r;
          g_out_sum -= stackIn.g;
          b_out_sum -= stackIn.b;
          a_out_sum -= stackIn.a;
          p2 = yw + ((p2 = x2 + radius + 1) < widthMinus1 ? p2 : widthMinus1) << 2;
          r_in_sum += stackIn.r = pixels[p2];
          g_in_sum += stackIn.g = pixels[p2 + 1];
          b_in_sum += stackIn.b = pixels[p2 + 2];
          a_in_sum += stackIn.a = pixels[p2 + 3];
          r_sum += r_in_sum;
          g_sum += g_in_sum;
          b_sum += b_in_sum;
          a_sum += a_in_sum;
          stackIn = stackIn.next;
          r_out_sum += pr2 = stackOut.r;
          g_out_sum += pg = stackOut.g;
          b_out_sum += pb = stackOut.b;
          a_out_sum += pa = stackOut.a;
          r_in_sum -= pr2;
          g_in_sum -= pg;
          b_in_sum -= pb;
          a_in_sum -= pa;
          stackOut = stackOut.next;
          yi += 4;
        }
        yw += width;
      }
      for (x2 = 0; x2 < width; x2++) {
        g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
        yi = x2 << 2;
        r_out_sum = radiusPlus1 * (pr2 = pixels[yi]);
        g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
        b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
        a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
        r_sum += sumFactor * pr2;
        g_sum += sumFactor * pg;
        b_sum += sumFactor * pb;
        a_sum += sumFactor * pa;
        stack2 = stackStart;
        for (i2 = 0; i2 < radiusPlus1; i2++) {
          stack2.r = pr2;
          stack2.g = pg;
          stack2.b = pb;
          stack2.a = pa;
          stack2 = stack2.next;
        }
        yp = width;
        for (i2 = 1; i2 <= radius; i2++) {
          yi = yp + x2 << 2;
          r_sum += (stack2.r = pr2 = pixels[yi]) * (rbs = radiusPlus1 - i2);
          g_sum += (stack2.g = pg = pixels[yi + 1]) * rbs;
          b_sum += (stack2.b = pb = pixels[yi + 2]) * rbs;
          a_sum += (stack2.a = pa = pixels[yi + 3]) * rbs;
          r_in_sum += pr2;
          g_in_sum += pg;
          b_in_sum += pb;
          a_in_sum += pa;
          stack2 = stack2.next;
          if (i2 < heightMinus1) {
            yp += width;
          }
        }
        yi = x2;
        stackIn = stackStart;
        stackOut = stackEnd;
        for (y = 0; y < height; y++) {
          p2 = yi << 2;
          pixels[p2 + 3] = pa = a_sum * mul_sum >> shg_sum;
          if (pa > 0) {
            pa = 255 / pa;
            pixels[p2] = (r_sum * mul_sum >> shg_sum) * pa;
            pixels[p2 + 1] = (g_sum * mul_sum >> shg_sum) * pa;
            pixels[p2 + 2] = (b_sum * mul_sum >> shg_sum) * pa;
          } else {
            pixels[p2] = pixels[p2 + 1] = pixels[p2 + 2] = 0;
          }
          r_sum -= r_out_sum;
          g_sum -= g_out_sum;
          b_sum -= b_out_sum;
          a_sum -= a_out_sum;
          r_out_sum -= stackIn.r;
          g_out_sum -= stackIn.g;
          b_out_sum -= stackIn.b;
          a_out_sum -= stackIn.a;
          p2 = x2 + ((p2 = y + radiusPlus1) < heightMinus1 ? p2 : heightMinus1) * width << 2;
          r_sum += r_in_sum += stackIn.r = pixels[p2];
          g_sum += g_in_sum += stackIn.g = pixels[p2 + 1];
          b_sum += b_in_sum += stackIn.b = pixels[p2 + 2];
          a_sum += a_in_sum += stackIn.a = pixels[p2 + 3];
          stackIn = stackIn.next;
          r_out_sum += pr2 = stackOut.r;
          g_out_sum += pg = stackOut.g;
          b_out_sum += pb = stackOut.b;
          a_out_sum += pa = stackOut.a;
          r_in_sum -= pr2;
          g_in_sum -= pg;
          b_in_sum -= pb;
          a_in_sum -= pa;
          stackOut = stackOut.next;
          yi += width;
        }
      }
    }
    const Blur = function Blur2(imageData) {
      var radius = Math.round(this.blurRadius());
      if (radius > 0) {
        filterGaussBlurRGBA(imageData, radius);
      }
    };
    Blur$1.Blur = Blur;
    Factory_1$e.Factory.addGetterSetter(Node_1$e.Node, "blurRadius", 0, (0, Validators_1$e.getNumberValidator)(), Factory_1$e.Factory.afterSetFilter);
    var Brighten$1 = {};
    Object.defineProperty(Brighten$1, "__esModule", { value: true });
    Brighten$1.Brighten = void 0;
    const Factory_1$d = Factory;
    const Node_1$d = Node$2;
    const Validators_1$d = Validators;
    const Brighten = function(imageData) {
      var brightness = this.brightness() * 255, data = imageData.data, len = data.length, i2;
      for (i2 = 0; i2 < len; i2 += 4) {
        data[i2] += brightness;
        data[i2 + 1] += brightness;
        data[i2 + 2] += brightness;
      }
    };
    Brighten$1.Brighten = Brighten;
    Factory_1$d.Factory.addGetterSetter(Node_1$d.Node, "brightness", 0, (0, Validators_1$d.getNumberValidator)(), Factory_1$d.Factory.afterSetFilter);
    var Contrast$1 = {};
    Object.defineProperty(Contrast$1, "__esModule", { value: true });
    Contrast$1.Contrast = void 0;
    const Factory_1$c = Factory;
    const Node_1$c = Node$2;
    const Validators_1$c = Validators;
    const Contrast = function(imageData) {
      var adjust = Math.pow((this.contrast() + 100) / 100, 2);
      var data = imageData.data, nPixels = data.length, red2 = 150, green2 = 150, blue2 = 150, i2;
      for (i2 = 0; i2 < nPixels; i2 += 4) {
        red2 = data[i2];
        green2 = data[i2 + 1];
        blue2 = data[i2 + 2];
        red2 /= 255;
        red2 -= 0.5;
        red2 *= adjust;
        red2 += 0.5;
        red2 *= 255;
        green2 /= 255;
        green2 -= 0.5;
        green2 *= adjust;
        green2 += 0.5;
        green2 *= 255;
        blue2 /= 255;
        blue2 -= 0.5;
        blue2 *= adjust;
        blue2 += 0.5;
        blue2 *= 255;
        red2 = red2 < 0 ? 0 : red2 > 255 ? 255 : red2;
        green2 = green2 < 0 ? 0 : green2 > 255 ? 255 : green2;
        blue2 = blue2 < 0 ? 0 : blue2 > 255 ? 255 : blue2;
        data[i2] = red2;
        data[i2 + 1] = green2;
        data[i2 + 2] = blue2;
      }
    };
    Contrast$1.Contrast = Contrast;
    Factory_1$c.Factory.addGetterSetter(Node_1$c.Node, "contrast", 0, (0, Validators_1$c.getNumberValidator)(), Factory_1$c.Factory.afterSetFilter);
    var Emboss$1 = {};
    Object.defineProperty(Emboss$1, "__esModule", { value: true });
    Emboss$1.Emboss = void 0;
    const Factory_1$b = Factory;
    const Node_1$b = Node$2;
    const Util_1$2 = Util;
    const Validators_1$b = Validators;
    const Emboss = function(imageData) {
      var strength = this.embossStrength() * 10, greyLevel = this.embossWhiteLevel() * 255, direction = this.embossDirection(), blend = this.embossBlend(), dirY = 0, dirX = 0, data = imageData.data, w = imageData.width, h2 = imageData.height, w4 = w * 4, y = h2;
      switch (direction) {
        case "top-left":
          dirY = -1;
          dirX = -1;
          break;
        case "top":
          dirY = -1;
          dirX = 0;
          break;
        case "top-right":
          dirY = -1;
          dirX = 1;
          break;
        case "right":
          dirY = 0;
          dirX = 1;
          break;
        case "bottom-right":
          dirY = 1;
          dirX = 1;
          break;
        case "bottom":
          dirY = 1;
          dirX = 0;
          break;
        case "bottom-left":
          dirY = 1;
          dirX = -1;
          break;
        case "left":
          dirY = 0;
          dirX = -1;
          break;
        default:
          Util_1$2.Util.error("Unknown emboss direction: " + direction);
      }
      do {
        var offsetY = (y - 1) * w4;
        var otherY = dirY;
        if (y + otherY < 1) {
          otherY = 0;
        }
        if (y + otherY > h2) {
          otherY = 0;
        }
        var offsetYOther = (y - 1 + otherY) * w * 4;
        var x2 = w;
        do {
          var offset = offsetY + (x2 - 1) * 4;
          var otherX = dirX;
          if (x2 + otherX < 1) {
            otherX = 0;
          }
          if (x2 + otherX > w) {
            otherX = 0;
          }
          var offsetOther = offsetYOther + (x2 - 1 + otherX) * 4;
          var dR = data[offset] - data[offsetOther];
          var dG = data[offset + 1] - data[offsetOther + 1];
          var dB = data[offset + 2] - data[offsetOther + 2];
          var dif = dR;
          var absDif = dif > 0 ? dif : -dif;
          var absG = dG > 0 ? dG : -dG;
          var absB = dB > 0 ? dB : -dB;
          if (absG > absDif) {
            dif = dG;
          }
          if (absB > absDif) {
            dif = dB;
          }
          dif *= strength;
          if (blend) {
            var r2 = data[offset] + dif;
            var g2 = data[offset + 1] + dif;
            var b = data[offset + 2] + dif;
            data[offset] = r2 > 255 ? 255 : r2 < 0 ? 0 : r2;
            data[offset + 1] = g2 > 255 ? 255 : g2 < 0 ? 0 : g2;
            data[offset + 2] = b > 255 ? 255 : b < 0 ? 0 : b;
          } else {
            var grey2 = greyLevel - dif;
            if (grey2 < 0) {
              grey2 = 0;
            } else if (grey2 > 255) {
              grey2 = 255;
            }
            data[offset] = data[offset + 1] = data[offset + 2] = grey2;
          }
        } while (--x2);
      } while (--y);
    };
    Emboss$1.Emboss = Emboss;
    Factory_1$b.Factory.addGetterSetter(Node_1$b.Node, "embossStrength", 0.5, (0, Validators_1$b.getNumberValidator)(), Factory_1$b.Factory.afterSetFilter);
    Factory_1$b.Factory.addGetterSetter(Node_1$b.Node, "embossWhiteLevel", 0.5, (0, Validators_1$b.getNumberValidator)(), Factory_1$b.Factory.afterSetFilter);
    Factory_1$b.Factory.addGetterSetter(Node_1$b.Node, "embossDirection", "top-left", null, Factory_1$b.Factory.afterSetFilter);
    Factory_1$b.Factory.addGetterSetter(Node_1$b.Node, "embossBlend", false, null, Factory_1$b.Factory.afterSetFilter);
    var Enhance$1 = {};
    Object.defineProperty(Enhance$1, "__esModule", { value: true });
    Enhance$1.Enhance = void 0;
    const Factory_1$a = Factory;
    const Node_1$a = Node$2;
    const Validators_1$a = Validators;
    function remap(fromValue, fromMin, fromMax, toMin, toMax) {
      var fromRange = fromMax - fromMin, toRange = toMax - toMin, toValue2;
      if (fromRange === 0) {
        return toMin + toRange / 2;
      }
      if (toRange === 0) {
        return toMin;
      }
      toValue2 = (fromValue - fromMin) / fromRange;
      toValue2 = toRange * toValue2 + toMin;
      return toValue2;
    }
    const Enhance = function(imageData) {
      var data = imageData.data, nSubPixels = data.length, rMin = data[0], rMax = rMin, r2, gMin = data[1], gMax = gMin, g2, bMin = data[2], bMax = bMin, b, i2;
      var enhanceAmount = this.enhance();
      if (enhanceAmount === 0) {
        return;
      }
      for (i2 = 0; i2 < nSubPixels; i2 += 4) {
        r2 = data[i2 + 0];
        if (r2 < rMin) {
          rMin = r2;
        } else if (r2 > rMax) {
          rMax = r2;
        }
        g2 = data[i2 + 1];
        if (g2 < gMin) {
          gMin = g2;
        } else if (g2 > gMax) {
          gMax = g2;
        }
        b = data[i2 + 2];
        if (b < bMin) {
          bMin = b;
        } else if (b > bMax) {
          bMax = b;
        }
      }
      if (rMax === rMin) {
        rMax = 255;
        rMin = 0;
      }
      if (gMax === gMin) {
        gMax = 255;
        gMin = 0;
      }
      if (bMax === bMin) {
        bMax = 255;
        bMin = 0;
      }
      var rMid, rGoalMax, rGoalMin, gMid, gGoalMax, gGoalMin, bMid, bGoalMax, bGoalMin;
      if (enhanceAmount > 0) {
        rGoalMax = rMax + enhanceAmount * (255 - rMax);
        rGoalMin = rMin - enhanceAmount * (rMin - 0);
        gGoalMax = gMax + enhanceAmount * (255 - gMax);
        gGoalMin = gMin - enhanceAmount * (gMin - 0);
        bGoalMax = bMax + enhanceAmount * (255 - bMax);
        bGoalMin = bMin - enhanceAmount * (bMin - 0);
      } else {
        rMid = (rMax + rMin) * 0.5;
        rGoalMax = rMax + enhanceAmount * (rMax - rMid);
        rGoalMin = rMin + enhanceAmount * (rMin - rMid);
        gMid = (gMax + gMin) * 0.5;
        gGoalMax = gMax + enhanceAmount * (gMax - gMid);
        gGoalMin = gMin + enhanceAmount * (gMin - gMid);
        bMid = (bMax + bMin) * 0.5;
        bGoalMax = bMax + enhanceAmount * (bMax - bMid);
        bGoalMin = bMin + enhanceAmount * (bMin - bMid);
      }
      for (i2 = 0; i2 < nSubPixels; i2 += 4) {
        data[i2 + 0] = remap(data[i2 + 0], rMin, rMax, rGoalMin, rGoalMax);
        data[i2 + 1] = remap(data[i2 + 1], gMin, gMax, gGoalMin, gGoalMax);
        data[i2 + 2] = remap(data[i2 + 2], bMin, bMax, bGoalMin, bGoalMax);
      }
    };
    Enhance$1.Enhance = Enhance;
    Factory_1$a.Factory.addGetterSetter(Node_1$a.Node, "enhance", 0, (0, Validators_1$a.getNumberValidator)(), Factory_1$a.Factory.afterSetFilter);
    var Grayscale$1 = {};
    Object.defineProperty(Grayscale$1, "__esModule", { value: true });
    Grayscale$1.Grayscale = void 0;
    const Grayscale = function(imageData) {
      var data = imageData.data, len = data.length, i2, brightness;
      for (i2 = 0; i2 < len; i2 += 4) {
        brightness = 0.34 * data[i2] + 0.5 * data[i2 + 1] + 0.16 * data[i2 + 2];
        data[i2] = brightness;
        data[i2 + 1] = brightness;
        data[i2 + 2] = brightness;
      }
    };
    Grayscale$1.Grayscale = Grayscale;
    var HSL$1 = {};
    Object.defineProperty(HSL$1, "__esModule", { value: true });
    HSL$1.HSL = void 0;
    const Factory_1$9 = Factory;
    const Node_1$9 = Node$2;
    const Validators_1$9 = Validators;
    Factory_1$9.Factory.addGetterSetter(Node_1$9.Node, "hue", 0, (0, Validators_1$9.getNumberValidator)(), Factory_1$9.Factory.afterSetFilter);
    Factory_1$9.Factory.addGetterSetter(Node_1$9.Node, "saturation", 0, (0, Validators_1$9.getNumberValidator)(), Factory_1$9.Factory.afterSetFilter);
    Factory_1$9.Factory.addGetterSetter(Node_1$9.Node, "luminance", 0, (0, Validators_1$9.getNumberValidator)(), Factory_1$9.Factory.afterSetFilter);
    const HSL = function(imageData) {
      var data = imageData.data, nPixels = data.length, v = 1, s = Math.pow(2, this.saturation()), h2 = Math.abs(this.hue() + 360) % 360, l = this.luminance() * 127, i2;
      var vsu = v * s * Math.cos(h2 * Math.PI / 180), vsw = v * s * Math.sin(h2 * Math.PI / 180);
      var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw, rg = 0.587 * v - 0.587 * vsu + 0.33 * vsw, rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
      var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw, gg2 = 0.587 * v + 0.413 * vsu + 0.035 * vsw, gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
      var br = 0.299 * v - 0.3 * vsu + 1.25 * vsw, bg = 0.587 * v - 0.586 * vsu - 1.05 * vsw, bb = 0.114 * v + 0.886 * vsu - 0.2 * vsw;
      var r2, g2, b, a;
      for (i2 = 0; i2 < nPixels; i2 += 4) {
        r2 = data[i2 + 0];
        g2 = data[i2 + 1];
        b = data[i2 + 2];
        a = data[i2 + 3];
        data[i2 + 0] = rr * r2 + rg * g2 + rb * b + l;
        data[i2 + 1] = gr * r2 + gg2 * g2 + gb * b + l;
        data[i2 + 2] = br * r2 + bg * g2 + bb * b + l;
        data[i2 + 3] = a;
      }
    };
    HSL$1.HSL = HSL;
    var HSV$1 = {};
    Object.defineProperty(HSV$1, "__esModule", { value: true });
    HSV$1.HSV = void 0;
    const Factory_1$8 = Factory;
    const Node_1$8 = Node$2;
    const Validators_1$8 = Validators;
    const HSV = function(imageData) {
      var data = imageData.data, nPixels = data.length, v = Math.pow(2, this.value()), s = Math.pow(2, this.saturation()), h2 = Math.abs(this.hue() + 360) % 360, i2;
      var vsu = v * s * Math.cos(h2 * Math.PI / 180), vsw = v * s * Math.sin(h2 * Math.PI / 180);
      var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw, rg = 0.587 * v - 0.587 * vsu + 0.33 * vsw, rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
      var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw, gg2 = 0.587 * v + 0.413 * vsu + 0.035 * vsw, gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
      var br = 0.299 * v - 0.3 * vsu + 1.25 * vsw, bg = 0.587 * v - 0.586 * vsu - 1.05 * vsw, bb = 0.114 * v + 0.886 * vsu - 0.2 * vsw;
      var r2, g2, b, a;
      for (i2 = 0; i2 < nPixels; i2 += 4) {
        r2 = data[i2 + 0];
        g2 = data[i2 + 1];
        b = data[i2 + 2];
        a = data[i2 + 3];
        data[i2 + 0] = rr * r2 + rg * g2 + rb * b;
        data[i2 + 1] = gr * r2 + gg2 * g2 + gb * b;
        data[i2 + 2] = br * r2 + bg * g2 + bb * b;
        data[i2 + 3] = a;
      }
    };
    HSV$1.HSV = HSV;
    Factory_1$8.Factory.addGetterSetter(Node_1$8.Node, "hue", 0, (0, Validators_1$8.getNumberValidator)(), Factory_1$8.Factory.afterSetFilter);
    Factory_1$8.Factory.addGetterSetter(Node_1$8.Node, "saturation", 0, (0, Validators_1$8.getNumberValidator)(), Factory_1$8.Factory.afterSetFilter);
    Factory_1$8.Factory.addGetterSetter(Node_1$8.Node, "value", 0, (0, Validators_1$8.getNumberValidator)(), Factory_1$8.Factory.afterSetFilter);
    var Invert$1 = {};
    Object.defineProperty(Invert$1, "__esModule", { value: true });
    Invert$1.Invert = void 0;
    const Invert = function(imageData) {
      var data = imageData.data, len = data.length, i2;
      for (i2 = 0; i2 < len; i2 += 4) {
        data[i2] = 255 - data[i2];
        data[i2 + 1] = 255 - data[i2 + 1];
        data[i2 + 2] = 255 - data[i2 + 2];
      }
    };
    Invert$1.Invert = Invert;
    var Kaleidoscope$1 = {};
    Object.defineProperty(Kaleidoscope$1, "__esModule", { value: true });
    Kaleidoscope$1.Kaleidoscope = void 0;
    const Factory_1$7 = Factory;
    const Node_1$7 = Node$2;
    const Util_1$1 = Util;
    const Validators_1$7 = Validators;
    var ToPolar = function(src, dst, opt) {
      var srcPixels = src.data, dstPixels = dst.data, xSize = src.width, ySize = src.height, xMid = opt.polarCenterX || xSize / 2, yMid = opt.polarCenterY || ySize / 2, i2, x2, y, r2 = 0, g2 = 0, b = 0, a = 0;
      var rad, rMax = Math.sqrt(xMid * xMid + yMid * yMid);
      x2 = xSize - xMid;
      y = ySize - yMid;
      rad = Math.sqrt(x2 * x2 + y * y);
      rMax = rad > rMax ? rad : rMax;
      var rSize = ySize, tSize = xSize, radius, theta2;
      var conversion = 360 / tSize * Math.PI / 180, sin, cos;
      for (theta2 = 0; theta2 < tSize; theta2 += 1) {
        sin = Math.sin(theta2 * conversion);
        cos = Math.cos(theta2 * conversion);
        for (radius = 0; radius < rSize; radius += 1) {
          x2 = Math.floor(xMid + rMax * radius / rSize * cos);
          y = Math.floor(yMid + rMax * radius / rSize * sin);
          i2 = (y * xSize + x2) * 4;
          r2 = srcPixels[i2 + 0];
          g2 = srcPixels[i2 + 1];
          b = srcPixels[i2 + 2];
          a = srcPixels[i2 + 3];
          i2 = (theta2 + radius * xSize) * 4;
          dstPixels[i2 + 0] = r2;
          dstPixels[i2 + 1] = g2;
          dstPixels[i2 + 2] = b;
          dstPixels[i2 + 3] = a;
        }
      }
    };
    var FromPolar = function(src, dst, opt) {
      var srcPixels = src.data, dstPixels = dst.data, xSize = src.width, ySize = src.height, xMid = opt.polarCenterX || xSize / 2, yMid = opt.polarCenterY || ySize / 2, i2, x2, y, dx, dy, r2 = 0, g2 = 0, b = 0, a = 0;
      var rad, rMax = Math.sqrt(xMid * xMid + yMid * yMid);
      x2 = xSize - xMid;
      y = ySize - yMid;
      rad = Math.sqrt(x2 * x2 + y * y);
      rMax = rad > rMax ? rad : rMax;
      var rSize = ySize, tSize = xSize, radius, theta2, phaseShift = opt.polarRotation || 0;
      var x1, y1;
      for (x2 = 0; x2 < xSize; x2 += 1) {
        for (y = 0; y < ySize; y += 1) {
          dx = x2 - xMid;
          dy = y - yMid;
          radius = Math.sqrt(dx * dx + dy * dy) * rSize / rMax;
          theta2 = (Math.atan2(dy, dx) * 180 / Math.PI + 360 + phaseShift) % 360;
          theta2 = theta2 * tSize / 360;
          x1 = Math.floor(theta2);
          y1 = Math.floor(radius);
          i2 = (y1 * xSize + x1) * 4;
          r2 = srcPixels[i2 + 0];
          g2 = srcPixels[i2 + 1];
          b = srcPixels[i2 + 2];
          a = srcPixels[i2 + 3];
          i2 = (y * xSize + x2) * 4;
          dstPixels[i2 + 0] = r2;
          dstPixels[i2 + 1] = g2;
          dstPixels[i2 + 2] = b;
          dstPixels[i2 + 3] = a;
        }
      }
    };
    const Kaleidoscope = function(imageData) {
      var xSize = imageData.width, ySize = imageData.height;
      var x2, y, xoff, i2, r2, g2, b, a, srcPos, dstPos;
      var power = Math.round(this.kaleidoscopePower());
      var angle2 = Math.round(this.kaleidoscopeAngle());
      var offset = Math.floor(xSize * (angle2 % 360) / 360);
      if (power < 1) {
        return;
      }
      var tempCanvas = Util_1$1.Util.createCanvasElement();
      tempCanvas.width = xSize;
      tempCanvas.height = ySize;
      var scratchData = tempCanvas.getContext("2d").getImageData(0, 0, xSize, ySize);
      Util_1$1.Util.releaseCanvas(tempCanvas);
      ToPolar(imageData, scratchData, {
        polarCenterX: xSize / 2,
        polarCenterY: ySize / 2
      });
      var minSectionSize = xSize / Math.pow(2, power);
      while (minSectionSize <= 8) {
        minSectionSize = minSectionSize * 2;
        power -= 1;
      }
      minSectionSize = Math.ceil(minSectionSize);
      var sectionSize = minSectionSize;
      var xStart = 0, xEnd = sectionSize, xDelta = 1;
      if (offset + minSectionSize > xSize) {
        xStart = sectionSize;
        xEnd = 0;
        xDelta = -1;
      }
      for (y = 0; y < ySize; y += 1) {
        for (x2 = xStart; x2 !== xEnd; x2 += xDelta) {
          xoff = Math.round(x2 + offset) % xSize;
          srcPos = (xSize * y + xoff) * 4;
          r2 = scratchData.data[srcPos + 0];
          g2 = scratchData.data[srcPos + 1];
          b = scratchData.data[srcPos + 2];
          a = scratchData.data[srcPos + 3];
          dstPos = (xSize * y + x2) * 4;
          scratchData.data[dstPos + 0] = r2;
          scratchData.data[dstPos + 1] = g2;
          scratchData.data[dstPos + 2] = b;
          scratchData.data[dstPos + 3] = a;
        }
      }
      for (y = 0; y < ySize; y += 1) {
        sectionSize = Math.floor(minSectionSize);
        for (i2 = 0; i2 < power; i2 += 1) {
          for (x2 = 0; x2 < sectionSize + 1; x2 += 1) {
            srcPos = (xSize * y + x2) * 4;
            r2 = scratchData.data[srcPos + 0];
            g2 = scratchData.data[srcPos + 1];
            b = scratchData.data[srcPos + 2];
            a = scratchData.data[srcPos + 3];
            dstPos = (xSize * y + sectionSize * 2 - x2 - 1) * 4;
            scratchData.data[dstPos + 0] = r2;
            scratchData.data[dstPos + 1] = g2;
            scratchData.data[dstPos + 2] = b;
            scratchData.data[dstPos + 3] = a;
          }
          sectionSize *= 2;
        }
      }
      FromPolar(scratchData, imageData, { polarRotation: 0 });
    };
    Kaleidoscope$1.Kaleidoscope = Kaleidoscope;
    Factory_1$7.Factory.addGetterSetter(Node_1$7.Node, "kaleidoscopePower", 2, (0, Validators_1$7.getNumberValidator)(), Factory_1$7.Factory.afterSetFilter);
    Factory_1$7.Factory.addGetterSetter(Node_1$7.Node, "kaleidoscopeAngle", 0, (0, Validators_1$7.getNumberValidator)(), Factory_1$7.Factory.afterSetFilter);
    var Mask$1 = {};
    Object.defineProperty(Mask$1, "__esModule", { value: true });
    Mask$1.Mask = void 0;
    const Factory_1$6 = Factory;
    const Node_1$6 = Node$2;
    const Validators_1$6 = Validators;
    function pixelAt(idata, x2, y) {
      var idx = (y * idata.width + x2) * 4;
      var d = [];
      d.push(idata.data[idx++], idata.data[idx++], idata.data[idx++], idata.data[idx++]);
      return d;
    }
    function rgbDistance(p1, p2) {
      return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2) + Math.pow(p1[2] - p2[2], 2));
    }
    function rgbMean(pTab) {
      var m = [0, 0, 0];
      for (var i2 = 0; i2 < pTab.length; i2++) {
        m[0] += pTab[i2][0];
        m[1] += pTab[i2][1];
        m[2] += pTab[i2][2];
      }
      m[0] /= pTab.length;
      m[1] /= pTab.length;
      m[2] /= pTab.length;
      return m;
    }
    function backgroundMask(idata, threshold) {
      var rgbv_no = pixelAt(idata, 0, 0);
      var rgbv_ne = pixelAt(idata, idata.width - 1, 0);
      var rgbv_so = pixelAt(idata, 0, idata.height - 1);
      var rgbv_se = pixelAt(idata, idata.width - 1, idata.height - 1);
      var thres = threshold || 10;
      if (rgbDistance(rgbv_no, rgbv_ne) < thres && rgbDistance(rgbv_ne, rgbv_se) < thres && rgbDistance(rgbv_se, rgbv_so) < thres && rgbDistance(rgbv_so, rgbv_no) < thres) {
        var mean = rgbMean([rgbv_ne, rgbv_no, rgbv_se, rgbv_so]);
        var mask = [];
        for (var i2 = 0; i2 < idata.width * idata.height; i2++) {
          var d = rgbDistance(mean, [
            idata.data[i2 * 4],
            idata.data[i2 * 4 + 1],
            idata.data[i2 * 4 + 2]
          ]);
          mask[i2] = d < thres ? 0 : 255;
        }
        return mask;
      }
    }
    function applyMask(idata, mask) {
      for (var i2 = 0; i2 < idata.width * idata.height; i2++) {
        idata.data[4 * i2 + 3] = mask[i2];
      }
    }
    function erodeMask(mask, sw, sh) {
      var weights = [1, 1, 1, 1, 0, 1, 1, 1, 1];
      var side = Math.round(Math.sqrt(weights.length));
      var halfSide = Math.floor(side / 2);
      var maskResult = [];
      for (var y = 0; y < sh; y++) {
        for (var x2 = 0; x2 < sw; x2++) {
          var so = y * sw + x2;
          var a = 0;
          for (var cy = 0; cy < side; cy++) {
            for (var cx = 0; cx < side; cx++) {
              var scy2 = y + cy - halfSide;
              var scx = x2 + cx - halfSide;
              if (scy2 >= 0 && scy2 < sh && scx >= 0 && scx < sw) {
                var srcOff = scy2 * sw + scx;
                var wt = weights[cy * side + cx];
                a += mask[srcOff] * wt;
              }
            }
          }
          maskResult[so] = a === 255 * 8 ? 255 : 0;
        }
      }
      return maskResult;
    }
    function dilateMask(mask, sw, sh) {
      var weights = [1, 1, 1, 1, 1, 1, 1, 1, 1];
      var side = Math.round(Math.sqrt(weights.length));
      var halfSide = Math.floor(side / 2);
      var maskResult = [];
      for (var y = 0; y < sh; y++) {
        for (var x2 = 0; x2 < sw; x2++) {
          var so = y * sw + x2;
          var a = 0;
          for (var cy = 0; cy < side; cy++) {
            for (var cx = 0; cx < side; cx++) {
              var scy2 = y + cy - halfSide;
              var scx = x2 + cx - halfSide;
              if (scy2 >= 0 && scy2 < sh && scx >= 0 && scx < sw) {
                var srcOff = scy2 * sw + scx;
                var wt = weights[cy * side + cx];
                a += mask[srcOff] * wt;
              }
            }
          }
          maskResult[so] = a >= 255 * 4 ? 255 : 0;
        }
      }
      return maskResult;
    }
    function smoothEdgeMask(mask, sw, sh) {
      var weights = [1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9];
      var side = Math.round(Math.sqrt(weights.length));
      var halfSide = Math.floor(side / 2);
      var maskResult = [];
      for (var y = 0; y < sh; y++) {
        for (var x2 = 0; x2 < sw; x2++) {
          var so = y * sw + x2;
          var a = 0;
          for (var cy = 0; cy < side; cy++) {
            for (var cx = 0; cx < side; cx++) {
              var scy2 = y + cy - halfSide;
              var scx = x2 + cx - halfSide;
              if (scy2 >= 0 && scy2 < sh && scx >= 0 && scx < sw) {
                var srcOff = scy2 * sw + scx;
                var wt = weights[cy * side + cx];
                a += mask[srcOff] * wt;
              }
            }
          }
          maskResult[so] = a;
        }
      }
      return maskResult;
    }
    const Mask = function(imageData) {
      var threshold = this.threshold(), mask = backgroundMask(imageData, threshold);
      if (mask) {
        mask = erodeMask(mask, imageData.width, imageData.height);
        mask = dilateMask(mask, imageData.width, imageData.height);
        mask = smoothEdgeMask(mask, imageData.width, imageData.height);
        applyMask(imageData, mask);
      }
      return imageData;
    };
    Mask$1.Mask = Mask;
    Factory_1$6.Factory.addGetterSetter(Node_1$6.Node, "threshold", 0, (0, Validators_1$6.getNumberValidator)(), Factory_1$6.Factory.afterSetFilter);
    var Noise$1 = {};
    Object.defineProperty(Noise$1, "__esModule", { value: true });
    Noise$1.Noise = void 0;
    const Factory_1$5 = Factory;
    const Node_1$5 = Node$2;
    const Validators_1$5 = Validators;
    const Noise = function(imageData) {
      var amount = this.noise() * 255, data = imageData.data, nPixels = data.length, half2 = amount / 2, i2;
      for (i2 = 0; i2 < nPixels; i2 += 4) {
        data[i2 + 0] += half2 - 2 * half2 * Math.random();
        data[i2 + 1] += half2 - 2 * half2 * Math.random();
        data[i2 + 2] += half2 - 2 * half2 * Math.random();
      }
    };
    Noise$1.Noise = Noise;
    Factory_1$5.Factory.addGetterSetter(Node_1$5.Node, "noise", 0.2, (0, Validators_1$5.getNumberValidator)(), Factory_1$5.Factory.afterSetFilter);
    var Pixelate$1 = {};
    Object.defineProperty(Pixelate$1, "__esModule", { value: true });
    Pixelate$1.Pixelate = void 0;
    const Factory_1$4 = Factory;
    const Util_1 = Util;
    const Node_1$4 = Node$2;
    const Validators_1$4 = Validators;
    const Pixelate = function(imageData) {
      var pixelSize = Math.ceil(this.pixelSize()), width = imageData.width, height = imageData.height, x2, y, i2, red2, green2, blue2, alpha2, nBinsX = Math.ceil(width / pixelSize), nBinsY = Math.ceil(height / pixelSize), xBinStart, xBinEnd, yBinStart, yBinEnd, xBin, yBin, pixelsInBin, data = imageData.data;
      if (pixelSize <= 0) {
        Util_1.Util.error("pixelSize value can not be <= 0");
        return;
      }
      for (xBin = 0; xBin < nBinsX; xBin += 1) {
        for (yBin = 0; yBin < nBinsY; yBin += 1) {
          red2 = 0;
          green2 = 0;
          blue2 = 0;
          alpha2 = 0;
          xBinStart = xBin * pixelSize;
          xBinEnd = xBinStart + pixelSize;
          yBinStart = yBin * pixelSize;
          yBinEnd = yBinStart + pixelSize;
          pixelsInBin = 0;
          for (x2 = xBinStart; x2 < xBinEnd; x2 += 1) {
            if (x2 >= width) {
              continue;
            }
            for (y = yBinStart; y < yBinEnd; y += 1) {
              if (y >= height) {
                continue;
              }
              i2 = (width * y + x2) * 4;
              red2 += data[i2 + 0];
              green2 += data[i2 + 1];
              blue2 += data[i2 + 2];
              alpha2 += data[i2 + 3];
              pixelsInBin += 1;
            }
          }
          red2 = red2 / pixelsInBin;
          green2 = green2 / pixelsInBin;
          blue2 = blue2 / pixelsInBin;
          alpha2 = alpha2 / pixelsInBin;
          for (x2 = xBinStart; x2 < xBinEnd; x2 += 1) {
            if (x2 >= width) {
              continue;
            }
            for (y = yBinStart; y < yBinEnd; y += 1) {
              if (y >= height) {
                continue;
              }
              i2 = (width * y + x2) * 4;
              data[i2 + 0] = red2;
              data[i2 + 1] = green2;
              data[i2 + 2] = blue2;
              data[i2 + 3] = alpha2;
            }
          }
        }
      }
    };
    Pixelate$1.Pixelate = Pixelate;
    Factory_1$4.Factory.addGetterSetter(Node_1$4.Node, "pixelSize", 8, (0, Validators_1$4.getNumberValidator)(), Factory_1$4.Factory.afterSetFilter);
    var Posterize$1 = {};
    Object.defineProperty(Posterize$1, "__esModule", { value: true });
    Posterize$1.Posterize = void 0;
    const Factory_1$3 = Factory;
    const Node_1$3 = Node$2;
    const Validators_1$3 = Validators;
    const Posterize = function(imageData) {
      var levels = Math.round(this.levels() * 254) + 1, data = imageData.data, len = data.length, scale = 255 / levels, i2;
      for (i2 = 0; i2 < len; i2 += 1) {
        data[i2] = Math.floor(data[i2] / scale) * scale;
      }
    };
    Posterize$1.Posterize = Posterize;
    Factory_1$3.Factory.addGetterSetter(Node_1$3.Node, "levels", 0.5, (0, Validators_1$3.getNumberValidator)(), Factory_1$3.Factory.afterSetFilter);
    var RGB$1 = {};
    Object.defineProperty(RGB$1, "__esModule", { value: true });
    RGB$1.RGB = void 0;
    const Factory_1$2 = Factory;
    const Node_1$2 = Node$2;
    const Validators_1$2 = Validators;
    const RGB = function(imageData) {
      var data = imageData.data, nPixels = data.length, red2 = this.red(), green2 = this.green(), blue2 = this.blue(), i2, brightness;
      for (i2 = 0; i2 < nPixels; i2 += 4) {
        brightness = (0.34 * data[i2] + 0.5 * data[i2 + 1] + 0.16 * data[i2 + 2]) / 255;
        data[i2] = brightness * red2;
        data[i2 + 1] = brightness * green2;
        data[i2 + 2] = brightness * blue2;
        data[i2 + 3] = data[i2 + 3];
      }
    };
    RGB$1.RGB = RGB;
    Factory_1$2.Factory.addGetterSetter(Node_1$2.Node, "red", 0, function(val) {
      this._filterUpToDate = false;
      if (val > 255) {
        return 255;
      } else if (val < 0) {
        return 0;
      } else {
        return Math.round(val);
      }
    });
    Factory_1$2.Factory.addGetterSetter(Node_1$2.Node, "green", 0, function(val) {
      this._filterUpToDate = false;
      if (val > 255) {
        return 255;
      } else if (val < 0) {
        return 0;
      } else {
        return Math.round(val);
      }
    });
    Factory_1$2.Factory.addGetterSetter(Node_1$2.Node, "blue", 0, Validators_1$2.RGBComponent, Factory_1$2.Factory.afterSetFilter);
    var RGBA$1 = {};
    Object.defineProperty(RGBA$1, "__esModule", { value: true });
    RGBA$1.RGBA = void 0;
    const Factory_1$1 = Factory;
    const Node_1$1 = Node$2;
    const Validators_1$1 = Validators;
    const RGBA = function(imageData) {
      var data = imageData.data, nPixels = data.length, red2 = this.red(), green2 = this.green(), blue2 = this.blue(), alpha2 = this.alpha(), i2, ia;
      for (i2 = 0; i2 < nPixels; i2 += 4) {
        ia = 1 - alpha2;
        data[i2] = red2 * alpha2 + data[i2] * ia;
        data[i2 + 1] = green2 * alpha2 + data[i2 + 1] * ia;
        data[i2 + 2] = blue2 * alpha2 + data[i2 + 2] * ia;
      }
    };
    RGBA$1.RGBA = RGBA;
    Factory_1$1.Factory.addGetterSetter(Node_1$1.Node, "red", 0, function(val) {
      this._filterUpToDate = false;
      if (val > 255) {
        return 255;
      } else if (val < 0) {
        return 0;
      } else {
        return Math.round(val);
      }
    });
    Factory_1$1.Factory.addGetterSetter(Node_1$1.Node, "green", 0, function(val) {
      this._filterUpToDate = false;
      if (val > 255) {
        return 255;
      } else if (val < 0) {
        return 0;
      } else {
        return Math.round(val);
      }
    });
    Factory_1$1.Factory.addGetterSetter(Node_1$1.Node, "blue", 0, Validators_1$1.RGBComponent, Factory_1$1.Factory.afterSetFilter);
    Factory_1$1.Factory.addGetterSetter(Node_1$1.Node, "alpha", 1, function(val) {
      this._filterUpToDate = false;
      if (val > 1) {
        return 1;
      } else if (val < 0) {
        return 0;
      } else {
        return val;
      }
    });
    var Sepia$1 = {};
    Object.defineProperty(Sepia$1, "__esModule", { value: true });
    Sepia$1.Sepia = void 0;
    const Sepia = function(imageData) {
      var data = imageData.data, nPixels = data.length, i2, r2, g2, b;
      for (i2 = 0; i2 < nPixels; i2 += 4) {
        r2 = data[i2 + 0];
        g2 = data[i2 + 1];
        b = data[i2 + 2];
        data[i2 + 0] = Math.min(255, r2 * 0.393 + g2 * 0.769 + b * 0.189);
        data[i2 + 1] = Math.min(255, r2 * 0.349 + g2 * 0.686 + b * 0.168);
        data[i2 + 2] = Math.min(255, r2 * 0.272 + g2 * 0.534 + b * 0.131);
      }
    };
    Sepia$1.Sepia = Sepia;
    var Solarize$1 = {};
    Object.defineProperty(Solarize$1, "__esModule", { value: true });
    Solarize$1.Solarize = void 0;
    const Solarize = function(imageData) {
      var data = imageData.data, w = imageData.width, h2 = imageData.height, w4 = w * 4, y = h2;
      do {
        var offsetY = (y - 1) * w4;
        var x2 = w;
        do {
          var offset = offsetY + (x2 - 1) * 4;
          var r2 = data[offset];
          var g2 = data[offset + 1];
          var b = data[offset + 2];
          if (r2 > 127) {
            r2 = 255 - r2;
          }
          if (g2 > 127) {
            g2 = 255 - g2;
          }
          if (b > 127) {
            b = 255 - b;
          }
          data[offset] = r2;
          data[offset + 1] = g2;
          data[offset + 2] = b;
        } while (--x2);
      } while (--y);
    };
    Solarize$1.Solarize = Solarize;
    var Threshold$1 = {};
    Object.defineProperty(Threshold$1, "__esModule", { value: true });
    Threshold$1.Threshold = void 0;
    const Factory_1 = Factory;
    const Node_1 = Node$2;
    const Validators_1 = Validators;
    const Threshold = function(imageData) {
      var level = this.threshold() * 255, data = imageData.data, len = data.length, i2;
      for (i2 = 0; i2 < len; i2 += 1) {
        data[i2] = data[i2] < level ? 0 : 255;
      }
    };
    Threshold$1.Threshold = Threshold;
    Factory_1.Factory.addGetterSetter(Node_1.Node, "threshold", 0.5, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
    Object.defineProperty(_FullInternals, "__esModule", { value: true });
    _FullInternals.Konva = void 0;
    const _CoreInternals_1 = _CoreInternals;
    const Arc_1 = Arc$1;
    const Arrow_1 = Arrow$1;
    const Circle_1 = Circle$1;
    const Ellipse_1 = Ellipse$1;
    const Image_1 = Image$2;
    const Label_1 = Label$1;
    const Line_1 = Line$1;
    const Path_1 = Path$1;
    const Rect_1 = Rect$1;
    const RegularPolygon_1 = RegularPolygon$1;
    const Ring_1 = Ring$1;
    const Sprite_1 = Sprite$1;
    const Star_1 = Star$2;
    const Text_1 = Text$1;
    const TextPath_1 = TextPath$1;
    const Transformer_1 = Transformer$1;
    const Wedge_1 = Wedge$2;
    const Blur_1 = Blur$1;
    const Brighten_1 = Brighten$1;
    const Contrast_1 = Contrast$1;
    const Emboss_1 = Emboss$1;
    const Enhance_1 = Enhance$1;
    const Grayscale_1 = Grayscale$1;
    const HSL_1 = HSL$1;
    const HSV_1 = HSV$1;
    const Invert_1 = Invert$1;
    const Kaleidoscope_1 = Kaleidoscope$1;
    const Mask_1 = Mask$1;
    const Noise_1 = Noise$1;
    const Pixelate_1 = Pixelate$1;
    const Posterize_1 = Posterize$1;
    const RGB_1 = RGB$1;
    const RGBA_1 = RGBA$1;
    const Sepia_1 = Sepia$1;
    const Solarize_1 = Solarize$1;
    const Threshold_1 = Threshold$1;
    _FullInternals.Konva = _CoreInternals_1.Konva.Util._assign(_CoreInternals_1.Konva, {
      Arc: Arc_1.Arc,
      Arrow: Arrow_1.Arrow,
      Circle: Circle_1.Circle,
      Ellipse: Ellipse_1.Ellipse,
      Image: Image_1.Image,
      Label: Label_1.Label,
      Tag: Label_1.Tag,
      Line: Line_1.Line,
      Path: Path_1.Path,
      Rect: Rect_1.Rect,
      RegularPolygon: RegularPolygon_1.RegularPolygon,
      Ring: Ring_1.Ring,
      Sprite: Sprite_1.Sprite,
      Star: Star_1.Star,
      Text: Text_1.Text,
      TextPath: TextPath_1.TextPath,
      Transformer: Transformer_1.Transformer,
      Wedge: Wedge_1.Wedge,
      Filters: {
        Blur: Blur_1.Blur,
        Brighten: Brighten_1.Brighten,
        Contrast: Contrast_1.Contrast,
        Emboss: Emboss_1.Emboss,
        Enhance: Enhance_1.Enhance,
        Grayscale: Grayscale_1.Grayscale,
        HSL: HSL_1.HSL,
        HSV: HSV_1.HSV,
        Invert: Invert_1.Invert,
        Kaleidoscope: Kaleidoscope_1.Kaleidoscope,
        Mask: Mask_1.Mask,
        Noise: Noise_1.Noise,
        Pixelate: Pixelate_1.Pixelate,
        Posterize: Posterize_1.Posterize,
        RGB: RGB_1.RGB,
        RGBA: RGBA_1.RGBA,
        Sepia: Sepia_1.Sepia,
        Solarize: Solarize_1.Solarize,
        Threshold: Threshold_1.Threshold
      }
    });
    var lib$1 = lib$2.exports;
    Object.defineProperty(lib$1, "__esModule", { value: true });
    const _FullInternals_1 = _FullInternals;
    lib$2.exports = _FullInternals_1.Konva;
    var libExports = lib$2.exports;
    const Konva = /* @__PURE__ */ getDefaultExportFromCjs(libExports);
    const md3 = {
      defaults: {
        VAppBar: {
          flat: true
        },
        VAutocomplete: {
          variant: "filled"
        },
        VBanner: {
          color: "primary"
        },
        VBottomSheet: {
          contentClass: "rounded-t-xl overflow-hidden"
        },
        VBtn: {
          color: "primary",
          rounded: "xl"
        },
        VBtnGroup: {
          rounded: "xl",
          VBtn: {
            rounded: null
          }
        },
        VCard: {
          rounded: "lg"
        },
        VCheckbox: {
          color: "secondary",
          inset: true
        },
        VChip: {
          rounded: "sm"
        },
        VCombobox: {
          variant: "filled"
        },
        VNavigationDrawer: {
          // VList: {
          //   nav: true,
          //   VListItem: {
          //     rounded: 'xl',
          //   },
          // },
        },
        VSelect: {
          variant: "filled"
        },
        VSlider: {
          color: "primary"
        },
        VTabs: {
          color: "primary"
        },
        VTextarea: {
          variant: "filled"
        },
        VTextField: {
          variant: "filled"
        },
        VToolbar: {
          VBtn: {
            color: null
          }
        }
      },
      icons: {
        defaultSet: "mdi",
        sets: {
          mdi
        }
      },
      theme: {
        themes: {
          light: {
            colors: {
              primary: "#6750a4",
              secondary: "#b4b0bb",
              tertiary: "#7d5260",
              error: "#b3261e",
              surface: "#fffbfe"
            }
          }
        }
      }
    };
    function createVuetify() {
      let vuetify2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        blueprint,
        ...rest
      } = vuetify2;
      const options = mergeDeep(blueprint, rest);
      const {
        aliases: aliases2 = {},
        components = {},
        directives = {}
      } = options;
      const defaults2 = createDefaults(options.defaults);
      const display = createDisplay(options.display, options.ssr);
      const theme = createTheme(options.theme);
      const icons = createIcons(options.icons);
      const locale = createLocale(options.locale);
      const date2 = createDate(options.date, locale);
      const goTo = createGoTo(options.goTo, locale);
      const install = (app2) => {
        for (const key in directives) {
          app2.directive(key, directives[key]);
        }
        for (const key in components) {
          app2.component(key, components[key]);
        }
        for (const key in aliases2) {
          app2.component(key, defineComponent({
            ...aliases2[key],
            name: key,
            aliasName: aliases2[key].name
          }));
        }
        theme.install(app2);
        app2.provide(DefaultsSymbol, defaults2);
        app2.provide(DisplaySymbol, display);
        app2.provide(ThemeSymbol, theme);
        app2.provide(IconSymbol, icons);
        app2.provide(LocaleSymbol, locale);
        app2.provide(DateOptionsSymbol, date2.options);
        app2.provide(DateAdapterSymbol, date2.instance);
        app2.provide(GoToSymbol, goTo);
        if (IN_BROWSER && options.ssr) {
          if (app2.$nuxt) {
            app2.$nuxt.hook("app:suspense:resolve", () => {
              display.update();
            });
          } else {
            const {
              mount
            } = app2;
            app2.mount = function() {
              const vm = mount(...arguments);
              nextTick(() => display.update());
              app2.mount = mount;
              return vm;
            };
          }
        }
        getUid.reset();
        {
          app2.mixin({
            computed: {
              $vuetify() {
                return reactive({
                  defaults: inject.call(this, DefaultsSymbol),
                  display: inject.call(this, DisplaySymbol),
                  theme: inject.call(this, ThemeSymbol),
                  icons: inject.call(this, IconSymbol),
                  locale: inject.call(this, LocaleSymbol),
                  date: inject.call(this, DateAdapterSymbol)
                });
              }
            }
          });
        }
      };
      return {
        install,
        defaults: defaults2,
        display,
        theme,
        icons,
        locale,
        date: date2,
        goTo
      };
    }
    const version$1 = "3.6.14";
    createVuetify.version = version$1;
    function inject(key) {
      var _a2, _b;
      const vm = this.$;
      const provides = ((_a2 = vm.parent) == null ? void 0 : _a2.provides) ?? ((_b = vm.vnode.appContext) == null ? void 0 : _b.provides);
      if (provides && key in provides) {
        return provides[key];
      }
    }
    const everestTheme = {
      dark: false,
      colors: {
        background: "#EFEDE8",
        surface: "#EFEDE8",
        primary: "#254C84",
        secondary: "#35CE7C",
        error: "#b9352b",
        info: "#254C84",
        success: "#35CE7C",
        warning: "#c09112",
        "on-background": "#212121",
        "on-surface": "#212121"
      }
    };
    const currentTheme = everestTheme;
    const vuetify = createVuetify({
      blueprint: md3,
      theme: {
        defaultTheme: "everestTheme",
        themes: {
          everestTheme
        }
      }
    });
    const COLOR = {
      TERMINAL_REQUIREMENT: currentTheme.colors.secondary,
      TERMINAL_REQUIREMENT_DISABLED: "#d5d4cc",
      TERMINAL_PROVIDE: currentTheme.colors.warning,
      TERMINAL_PROVIDE_DISABLED: "#d5d4cc",
      CONNECTION: currentTheme.colors.secondary
    };
    const ICON_DATA = {
      EDIT: "M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z",
      GRAB: "M13,6V11H18V7.75L22.25,12L18,16.25V13H13V18H16.25L12,22.25L7.75,18H11V13H6V16.25L1.75,12L6,7.75V11H11V6H7.75L12,1.75L16.25,6H13Z",
      TERMINAL: "M12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20M17,14L12,9L7,14H17Z",
      DISABLED: "M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2C6.47,2 2,6.47 2,12C2,17.53 6.47,22 12,22C17.53,22 22,17.53 22,12C22,6.47 17.53,2 12,2M14.59,8L12,10.59L9.41,8L8,9.41L10.59,12L8,14.59L9.41,16L12,13.41L14.59,16L16,14.59L13.41,12L16,9.41L14.59,8Z"
    };
    const SIZE = {
      GRID: 24,
      FRAME_WIDTH: 288,
      FRAME_HEIGHT: 144,
      TERMINAL: 24,
      CONNECTION_WIDTH: 4,
      CONNECTION_CTRL: 100
    };
    const NORMAL_TEXT = {
      fontFamily: "Roboto, sans-serif"
    };
    const MONO_TEXT = {
      fontFamily: "Roboto Mono, monospace"
    };
    const TOOLTIP = {
      position: {
        x: 10,
        y: 10
      }
    };
    const INITIAL_RPC_TIMEOUT_VALUE = 1e4;
    class TerminalShape extends Konva.Path {
      constructor(config2) {
        config2.data = config2.data || ICON_DATA.TERMINAL;
        config2.fill = config2.fill || config2.terminal_type === "requirement" ? COLOR.TERMINAL_REQUIREMENT : COLOR.TERMINAL_PROVIDE;
        config2.x = config2.x || 0;
        config2.y = config2.y || 0;
        config2.offset = config2.offset || { x: SIZE.TERMINAL / 2, y: SIZE.TERMINAL / 2 };
        config2.hitFunc = config2.hitFunc || function(context, shape) {
          context.beginPath();
          context.rect(0, 0, SIZE.TERMINAL, SIZE.TERMINAL);
          context.closePath();
          context.fillShape(shape);
        };
        super(config2);
        if (config2.terminal_alignment) {
          this.set_alignment(config2.terminal_alignment);
        }
      }
      get terminal_type() {
        return this.getAttr("terminal_type");
      }
      get terminal_id() {
        return this.getAttr("terminal_id");
      }
      get terminal_alignment() {
        return this.getAttr("terminal_alignment");
      }
      set_alignment(alignment) {
        this.setAttr("terminal_alignment", alignment);
        const is_provide = this.terminal_type === "provide";
        if (alignment === "top") {
          this.rotation(is_provide ? 0 : 180);
        } else if (alignment === "right") {
          this.rotation(is_provide ? 90 : 270);
        } else if (alignment === "bottom") {
          this.rotation(is_provide ? 180 : 0);
        } else if (alignment === "left") {
          this.rotation(is_provide ? 270 : 90);
        }
      }
      // get_rotation(alignment: TerminalAlignment): number {
      //   const provide = this.terminal_type === "provide";
      //   if (alignment === "top") {
      //     return provide ? 0 : 180;
      //   } else if (alignment === "right") {
      //     return provide ? 90 : 270;
      //   } else if (alignment === "bottom") {
      //     return provide ? 180 : 0;
      //   } else {
      //     return provide ? 270 : 90;
      //   }
      // }
      set_appearence(look) {
        if (look !== "DISABLED") {
          this.data(ICON_DATA.TERMINAL);
        }
        if (look === "DISABLED") {
          this.data(ICON_DATA.DISABLED);
          this.fill(this.terminal_type === "requirement" ? COLOR.TERMINAL_REQUIREMENT_DISABLED : COLOR.TERMINAL_PROVIDE_DISABLED);
          this.listening(false);
        } else if (look === "PLACEHOLDER") {
          this.fill(this.terminal_type === "requirement" ? COLOR.TERMINAL_REQUIREMENT_DISABLED : COLOR.TERMINAL_PROVIDE_DISABLED);
          this.listening(false);
        } else if (look === "NORMAL") {
          this.fill(this.terminal_type === "requirement" ? COLOR.TERMINAL_REQUIREMENT : COLOR.TERMINAL_PROVIDE);
          this.listening(true);
        }
      }
    }
    function check_hit(x2, y, terminal_distribution) {
      let align = null;
      let index = null;
      if (0 < x2 && x2 < SIZE.FRAME_WIDTH) {
        if (-SIZE.TERMINAL < y && y < 0) {
          align = "top";
          index = Math.floor(terminal_distribution.top.length * x2 / SIZE.FRAME_WIDTH + 0.5);
        } else if (y > SIZE.FRAME_HEIGHT && y < SIZE.FRAME_HEIGHT + SIZE.TERMINAL) {
          align = "bottom";
          index = Math.floor(terminal_distribution.bottom.length * x2 / SIZE.FRAME_WIDTH + 0.5);
        }
      }
      if (0 < y && y < SIZE.FRAME_HEIGHT) {
        if (-SIZE.TERMINAL < x2 && x2 < 0) {
          align = "left";
          index = Math.floor(terminal_distribution.left.length * y / SIZE.FRAME_HEIGHT + 0.5);
        } else if (x2 > SIZE.FRAME_WIDTH && x2 < SIZE.FRAME_WIDTH + SIZE.TERMINAL) {
          align = "right";
          index = Math.floor(terminal_distribution.right.length * y / SIZE.FRAME_HEIGHT + 0.5);
        }
      }
      return {
        align,
        index
      };
    }
    class ModuleView {
      constructor(view_model) {
        __publicField(this, "group");
        __publicField(this, "_vm");
        __publicField(this, "_terminal_views");
        __publicField(this, "_title");
        __publicField(this, "_observers", []);
        this.group = new Konva.Group({
          draggable: true
        });
        this._vm = view_model;
        this._terminal_views = view_model.terminal_lookup.map((item, terminal_id) => {
          const view = new TerminalShape({
            terminal_type: item.terminal.type,
            terminal_id,
            terminal_alignment: item.alignment
          });
          view.setDraggable(true);
          view.on("dragstart", () => this._terminal_dragstart_handler(view));
          view.on("dragmove", () => this._terminal_dragmove_handler(view));
          view.on("dragend", () => this._terminal_dragend_handler(view));
          view.on("mouseenter", () => {
            this._vm.set_cursor("pointer");
            const showTooltip = {
              type: "SHOW_TOOLTIP",
              text: `Interface type: ${item.terminal.interface}`
            };
            this._vm.notify_stage_context(showTooltip);
          });
          view.on("mouseleave", () => {
            this._vm.set_cursor("default");
            const hideTooltip = {
              type: "HIDE_TOOLTIP"
            };
            this._vm.notify_stage_context(hideTooltip);
          });
          view.on("pointerclick", (ev) => {
            view_model.clicked_terminal(terminal_id);
            ev.cancelBubble = true;
          });
          return view;
        });
        Object.entries(view_model.terminal_dist).forEach(([_alignment, terminal_ids]) => {
          this._recalculate_terminal_position(_alignment, terminal_ids, false);
        });
        view_model.add_observer((ev) => this._vm_event_handler(ev));
        this.group.on("dragmove", () => this._module_dragmove_handler());
        this.group.position({
          x: view_model.grid_position.x * SIZE.GRID,
          y: view_model.grid_position.y * SIZE.GRID
        });
        const frame = new Konva.Rect({
          cornerRadius: 4,
          width: SIZE.FRAME_WIDTH,
          height: SIZE.FRAME_HEIGHT,
          fill: currentTheme.colors.primary,
          shadowBlur: 4,
          shadowOpacity: 0.4,
          shadowOffset: {
            x: 2,
            y: 2
          },
          fillAfterStrokeEnabled: true,
          listening: true
        });
        const strokeWidth = 8;
        const topStroke = new Konva.Line({
          cornerRadius: 4,
          points: [
            0,
            strokeWidth / 2,
            // Start at the top-left corner of where the rectangle is positioned
            SIZE.FRAME_WIDTH,
            strokeWidth / 2
            // End at the top-right corner of where the rectangle is positioned
          ],
          stroke: currentTheme.colors.secondary,
          strokeWidth,
          x: frame.x(),
          y: frame.y(),
          listening: true
        });
        const title2 = new Konva.Text({
          wrap: "none",
          text: view_model.id,
          fontFamily: NORMAL_TEXT.fontFamily,
          ellipsis: true,
          fill: "white",
          fontSize: 16 * 2,
          padding: 16,
          y: strokeWidth,
          width: SIZE.FRAME_WIDTH,
          listening: true
        });
        const typeInfo = new Konva.Text({
          wrap: "none",
          text: `${view_model.type}`,
          fontFamily: MONO_TEXT.fontFamily,
          ellipsis: true,
          fill: "white",
          opacity: 0.5,
          fontSize: 16,
          padding: 8,
          width: SIZE.FRAME_WIDTH,
          y: frame.height() - 16 * 2,
          align: "right",
          listening: true
        });
        [frame, title2, topStroke, typeInfo].forEach((e) => {
          e.on("mouseenter", () => {
            this._vm.set_cursor("pointer");
          });
          e.on("mouseleave", () => {
            this._vm.set_cursor("default");
          });
          e.on("pointerclick", (ev) => {
            this._vm.clicked_title();
            ev.cancelBubble = true;
          });
        });
        this._title = title2;
        this.group.add(frame, topStroke, typeInfo, title2, ...this._terminal_views);
      }
      get_terminal_placement(id2) {
        const terminal_view = this._terminal_views[id2];
        const relative_position = terminal_view.position();
        const module_position = this.group.position();
        return {
          x: relative_position.x + module_position.x,
          y: relative_position.y + module_position.y,
          alignment: terminal_view.terminal_alignment
        };
      }
      add_observer(handler) {
        this._observers.push(handler);
        return () => {
          this._observers = this._observers.filter((other) => other !== handler);
        };
      }
      _notify(ev) {
        this._observers.forEach((handler) => handler(ev));
      }
      _vm_event_handler(ev) {
        if (ev.type === "TERMINAL_MODIFY_APPEARENCE") {
          ev.disable.forEach((id2) => {
            this._terminal_views[id2].set_appearence("DISABLED");
          });
          ev.normal.forEach((id2) => {
            this._terminal_views[id2].set_appearence("NORMAL");
          });
          if (this.group.children.length > 0) {
            this.group.cache();
          }
        } else if (ev.type === "MODULE_MODEL_UPDATE") {
          this._title.setText(this._vm.id);
          if (this.group.children.length > 0) {
            this.group.cache();
          }
        }
      }
      _module_dragmove_handler() {
        const pos = this.group.position();
        const new_grid_pos = {
          x: Math.round(pos.x / SIZE.GRID),
          y: Math.round(pos.y / SIZE.GRID)
        };
        const cur_grid_pos = this._vm.grid_position;
        const new_group_pos = {
          x: new_grid_pos.x * SIZE.GRID,
          y: new_grid_pos.y * SIZE.GRID
        };
        this.group.position(new_group_pos);
        if (cur_grid_pos.x != new_grid_pos.x || cur_grid_pos.y != new_grid_pos.y) {
          this._vm.grid_position = new_grid_pos;
          const update_terminals = this._terminal_views.map((item, id2) => {
            return {
              alignment: item.terminal_alignment,
              id: id2,
              x: item.x() + new_group_pos.x,
              y: item.y() + new_group_pos.y
            };
          });
          this._notify({
            type: "TERMINALS_UPDATED",
            terminals: update_terminals,
            module_moved: true
          });
        }
      }
      _terminal_dragstart_handler(view) {
        const replace_terminal = view.clone();
        replace_terminal.set_appearence("PLACEHOLDER");
        this._terminal_views[view.terminal_id] = replace_terminal;
        this.group.add(replace_terminal);
        view.moveToTop();
        this.group.clearCache();
      }
      _terminal_dragmove_handler(view) {
        const hit = check_hit(view.x(), view.y(), this._vm.terminal_dist);
        if (!hit.align) {
          return;
        }
        if (hit.align != this._vm.terminal_lookup[view.terminal_id].alignment) {
          view.set_alignment(hit.align);
        }
        const changed_areas = this._vm.move_terminal(view.terminal_id, hit.align, hit.index);
        changed_areas.forEach((alignment) => {
          this._recalculate_terminal_position(alignment, this._vm.terminal_dist[alignment], true);
        });
      }
      _terminal_dragend_handler(view) {
        this._terminal_views[view.terminal_id].destroy();
        this._terminal_views[view.terminal_id] = view;
        const end_align = this._vm.terminal_lookup[view.terminal_id].alignment;
        this._recalculate_terminal_position(end_align, this._vm.terminal_dist[end_align]);
        if (this.group.children.length > 0) {
          this.group.cache();
        }
      }
      _recalculate_terminal_position(alignment, terminal_ids, animate2 = false) {
        const horizontal_align = alignment === "top" || alignment === "bottom";
        const x_offset = alignment === "right" ? SIZE.FRAME_WIDTH + SIZE.TERMINAL : 0;
        const y_offset = alignment === "bottom" ? SIZE.FRAME_HEIGHT + SIZE.TERMINAL : 0;
        const size2 = horizontal_align ? SIZE.FRAME_WIDTH : SIZE.FRAME_HEIGHT;
        const terminal_count = terminal_ids.length;
        const terminal_update_event = {
          type: "TERMINALS_UPDATED",
          terminals: [],
          module_moved: false
        };
        terminal_ids.forEach((terminal_id, index) => {
          const terminal_view = this._terminal_views[terminal_id];
          const list_offset = (index + 0.5) * size2 / terminal_count;
          const x2 = x_offset + (horizontal_align ? list_offset : -SIZE.TERMINAL / 2);
          const y = y_offset + (horizontal_align ? -SIZE.TERMINAL / 2 : list_offset);
          terminal_view.set_alignment(alignment);
          if (animate2) {
            terminal_view.to({
              duration: 0.2,
              ease: "EaseIn",
              x: x2,
              y
            });
          } else {
            terminal_view.x(x2);
            terminal_view.y(y);
          }
          terminal_update_event.terminals.push({
            alignment,
            id: terminal_id,
            x: x2 + this.group.x(),
            y: y + this.group.y()
          });
        });
        this._notify(terminal_update_event);
      }
    }
    class ModuleViewModel {
      constructor(model, id2, stage_context) {
        __publicField(this, "_grid_position");
        __publicField(this, "terminal_dist", {
          top: [],
          right: [],
          bottom: [],
          left: []
        });
        __publicField(this, "terminal_lookup", []);
        __publicField(this, "type");
        __publicField(this, "_instance_id");
        __publicField(this, "_config_model");
        __publicField(this, "_module_instance");
        __publicField(this, "_observers", []);
        __publicField(this, "_stage_context");
        this._instance_id = id2;
        this._config_model = model;
        this._stage_context = stage_context;
        this._module_instance = model.get_module_instance(id2);
        this._initialize_terminals(this._module_instance.view_config.terminals);
        this._grid_position = this._module_instance.view_config.position;
        this.type = this._module_instance.type;
        stage_context.add_observer((ev) => this._handle_stage_context_event(ev));
        model.add_observer((ev) => {
          if (ev.type == "MODULE_INSTANCE_UPDATED" && ev.id == id2) {
            this._notify({ type: "MODULE_MODEL_UPDATE" });
          }
        });
      }
      _initialize_terminals(terminal_arrangement) {
        Object.entries(terminal_arrangement).forEach(([_alignment, terminals]) => {
          const alignment = _alignment;
          terminals.forEach((terminal) => {
            const index = this.terminal_dist[alignment].length;
            const terminal_id = this.terminal_lookup.length;
            this.terminal_lookup.push({
              terminal,
              alignment,
              index
            });
            this.terminal_dist[alignment].push(terminal_id);
          });
        });
      }
      add_observer(handler) {
        this._observers.push(handler);
        return () => {
          this._observers = this._observers.filter((other) => other !== handler);
        };
      }
      notify_stage_context(event) {
        this._stage_context._publish(event);
      }
      _notify(ev) {
        this._observers.forEach((handler) => handler(ev));
      }
      clicked_terminal(terminal_id) {
        const terminal = this.terminal_lookup[terminal_id].terminal;
        this._stage_context.clicked_terminal(terminal, this._instance_id);
      }
      clicked_title() {
        this._stage_context.clicked_instance(this._instance_id);
      }
      set_cursor(type2) {
        this._stage_context.container.style.cursor = type2;
      }
      _handle_stage_context_event(event) {
        if (event.type !== "SELECT") {
          return;
        }
        const selection_event = event.selection;
        if (selection_event.type === "TERMINAL") {
          const modify_event = {
            type: "TERMINAL_MODIFY_APPEARENCE",
            disable: [],
            highlight: [],
            normal: []
          };
          const terminal = selection_event.terminal;
          this.terminal_lookup.forEach((item, id2) => {
            if (item.terminal.type !== terminal.type && (terminal.type === "provide" ? this._config_model.interfaces_match(terminal.interface, item.terminal.interface) : this._config_model.interfaces_match(item.terminal.interface, terminal.interface))) {
              return;
            }
            modify_event.disable.push(id2);
          });
          this._notify(modify_event);
        } else {
          this._notify({
            type: "TERMINAL_MODIFY_APPEARENCE",
            normal: Array.from(this.terminal_lookup.keys()),
            disable: [],
            highlight: []
          });
        }
      }
      get id() {
        return this._module_instance.id;
      }
      get grid_position() {
        return this._grid_position;
      }
      // returns diff or null
      set grid_position(pos) {
        this._grid_position = pos;
        this._config_model.update_module_view_position(this._instance_id, pos);
      }
      move_terminal(terminal_id, new_align, new_index) {
        const cur_align = this.terminal_lookup[terminal_id].alignment;
        const cur_index = this.terminal_lookup[terminal_id].index;
        if (new_align != cur_align) {
          this.terminal_dist[cur_align].splice(cur_index, 1);
          this.terminal_dist[new_align].splice(new_index, 0, terminal_id);
          this.terminal_lookup[terminal_id].alignment = new_align;
          this._recalculate_terminal_index([cur_align, new_align]);
          return [cur_align, new_align];
        } else {
          if (new_index > cur_index + 1 || new_index < cur_index) {
            this.terminal_dist[cur_align].splice(cur_index, 1);
            const corrected_new_index = new_index < cur_index ? new_index : new_index - 1;
            this.terminal_dist[cur_align].splice(corrected_new_index, 0, terminal_id);
            this._recalculate_terminal_index([cur_align]);
            return [cur_align];
          } else {
            return [];
          }
        }
      }
      get_terminal_lookup_id(name, type2) {
        return this.terminal_lookup.findIndex((item) => item.terminal.id === name && item.terminal.type === type2);
      }
      _recalculate_terminal_index(alignments) {
        const new_arrangement = {};
        alignments.forEach((alignment) => {
          this.terminal_dist[alignment].forEach((terminal_id, index) => {
            this.terminal_lookup[terminal_id].index = index;
          });
          new_arrangement[alignment] = this.terminal_dist[alignment].map((id2) => this.terminal_lookup[id2].terminal);
        });
        this._config_model.update_module_view_terminals(this._instance_id, new_arrangement);
      }
    }
    const correction = {
      top: {
        x: 0,
        y: -SIZE.GRID / 2
      },
      right: {
        x: SIZE.GRID / 2,
        y: 0
      },
      bottom: {
        x: 0,
        y: SIZE.GRID / 2
      },
      left: {
        x: -SIZE.GRID / 2,
        y: 0
      }
    };
    class ConnectionShape extends Konva.Line {
      constructor(config2) {
        config2.bezier = config2.bezier || true;
        config2.strokeWidth = config2.strokeWidth || SIZE.CONNECTION_WIDTH;
        config2.stroke = config2.stroke || COLOR.CONNECTION;
        super(config2);
        this.update_terminals(config2.requirement, config2.provide);
      }
      update_terminals(requirement, provide2, animate2 = false) {
        requirement = requirement || this.getAttr("requirement");
        provide2 = provide2 || this.getAttr("provide");
        const req_x = requirement.x + correction[requirement.alignment].x;
        const req_y = requirement.y + correction[requirement.alignment].y;
        const prov_x = provide2.x + correction[provide2.alignment].x;
        const prov_y = provide2.y + correction[provide2.alignment].y;
        const x_dist = prov_x - req_x;
        const y_dist = prov_y - req_y;
        const cps = [
          [requirement.alignment, req_x, req_y, x_dist, y_dist],
          [provide2.alignment, prov_x, prov_y, -x_dist, -y_dist]
        ].map((item) => {
          const [alignment, pos_x, pos_y, dist_x, dist_y] = item;
          if (alignment === "top") {
            return [pos_x, pos_y - Math.max(SIZE.CONNECTION_CTRL, -dist_y)];
          } else if (alignment === "right") {
            return [pos_x + Math.max(SIZE.CONNECTION_CTRL, dist_x), pos_y];
          } else if (alignment === "bottom") {
            return [pos_x, pos_y + Math.max(SIZE.CONNECTION_CTRL, dist_y)];
          } else {
            return [pos_x - Math.max(SIZE.CONNECTION_CTRL, -dist_x), pos_y];
          }
        });
        const points = [req_x, req_y, cps[0][0], cps[0][1], cps[1][0], cps[1][1], prov_x, prov_y];
        if (animate2) {
          this.to({
            points,
            duration: 0.2,
            ease: "EaseIn"
          });
        } else {
          this.points(points);
        }
        this.setAttrs({
          requirement,
          provide: provide2
        });
      }
    }
    class ConnectionManager {
      constructor(stage_context) {
        __publicField(this, "group");
        __publicField(this, "connections", []);
        __publicField(this, "_registered_modules", []);
        __publicField(this, "_stage_context");
        this.group = new Konva.Group();
        this._stage_context = stage_context;
      }
      add_connection(id2, provide2, requirement) {
        const providing_placement = provide2.module_view.get_terminal_placement(provide2.terminal_lookup_id);
        const requiring_placement = requirement.module_view.get_terminal_placement(requirement.terminal_lookup_id);
        const connection_view = new ConnectionShape({
          provide: providing_placement,
          requirement: requiring_placement,
          hitStrokeWidth: 12
          // FIXME (aw): constant
        });
        const connection_item = {
          id: id2,
          view: connection_view
        };
        connection_view.on("pointerclick", () => this._stage_context.clicked_connection(id2));
        connection_view.on("mouseenter", () => {
          this._stage_context.container.style.cursor = "pointer";
        });
        connection_view.on("mouseleave", () => {
          this._stage_context.container.style.cursor = "default";
        });
        this.connections.push(connection_item);
        this._insert_terminal_for_module_view(provide2, connection_item, "provide");
        this._insert_terminal_for_module_view(requirement, connection_item, "requirement");
        this.group.add(connection_view);
      }
      delete_connection(id2) {
        const cxn_index = this.connections.findIndex((cxn) => cxn.id === id2);
        const cxn_item = this.connections[cxn_index];
        cxn_item.view.destroy();
        this.connections.slice(cxn_index, 1);
      }
      // FIXME (aw): naming on half etc
      _insert_terminal_for_module_view(half2, connection_item, type2) {
        const module2 = this._registered_modules.find((item) => item.view === half2.module_view);
        if (module2) {
          const terminal = module2.terminal_lookup[half2.terminal_lookup_id];
          if (terminal) {
            terminal.connections.push(connection_item);
          } else {
            module2.terminal_lookup[half2.terminal_lookup_id] = {
              type: type2,
              connections: [connection_item]
            };
          }
          return;
        }
        const new_module = {
          view: half2.module_view,
          terminal_lookup: Array(half2.module_view._terminal_views.length)
        };
        new_module.terminal_lookup[half2.terminal_lookup_id] = {
          type: type2,
          connections: [connection_item]
        };
        this._registered_modules.push(new_module);
        new_module.view.add_observer((ev) => {
          if (ev.type === "TERMINALS_UPDATED") {
            const is_animated = ev.module_moved === false;
            ev.terminals.forEach((terminal) => {
              if (!new_module.terminal_lookup[terminal.id])
                return;
              const { connections, type: type22 } = new_module.terminal_lookup[terminal.id];
              connections.forEach((cxn) => {
                if (type22 === "provide") {
                  cxn.view.update_terminals(null, terminal, is_animated);
                } else {
                  cxn.view.update_terminals(terminal, null, is_animated);
                }
              });
            });
          }
        });
      }
    }
    class ConfigStage {
      constructor(config2, context) {
        // view part
        __publicField(this, "_konva");
        __publicField(this, "_module_views", {});
        // view model part
        __publicField(this, "_model", null);
        __publicField(this, "_module_vms", {});
        __publicField(this, "_conn_man");
        __publicField(this, "context");
        __publicField(this, "_stage");
        __publicField(this, "_bg");
        this.config = config2;
        this._stage = new Konva.Stage(config2);
        this.resizeStage = this.resizeStage.bind(this);
        Konva.dragButtons = [0, 2];
        this._stage.on("contextmenu", (e) => e.evt.preventDefault());
        const tooltipLayer = new Konva.Layer({});
        const tooltip = new Konva.Text({
          text: "",
          fontFamily: NORMAL_TEXT.fontFamily,
          fontSize: 16,
          padding: 5,
          fill: "white",
          alpha: 0.75,
          visible: false,
          sceneFunc: function(context2, shape) {
            const { width, height } = shape.size();
            const borderRadius = 3;
            context2.beginPath();
            context2.moveTo(borderRadius, 0);
            context2.lineTo(width - borderRadius, 0);
            context2.arcTo(width, 0, width, borderRadius, borderRadius);
            context2.lineTo(width, height - borderRadius);
            context2.arcTo(width, height, width - borderRadius, height, borderRadius);
            context2.lineTo(borderRadius, height);
            context2.arcTo(0, height, 0, height - borderRadius, borderRadius);
            context2.lineTo(0, borderRadius);
            context2.arcTo(0, 0, borderRadius, 0, borderRadius);
            context2.closePath();
            context2.fillStyle = currentTheme.colors.secondary;
            context2.fill();
            shape._sceneFunc(context2);
          },
          ...TOOLTIP.position
        });
        tooltipLayer.add(tooltip);
        const static_layer = new Konva.Layer({
          draggable: true
        });
        this._reset_static_layer(static_layer);
        this._stage.on("wheel", (event) => {
          event.evt.preventDefault();
          const oldScale = static_layer.scaleX();
          const pointer = this._stage.getPointerPosition();
          if (!pointer) {
            return;
          }
          const mousePointTo = {
            x: (pointer.x - static_layer.x()) / oldScale,
            y: (pointer.y - static_layer.y()) / oldScale
          };
          const delta2 = event.evt.deltaY === 1 || event.evt.deltaY === -1 ? event.evt.deltaY * 0.2 : event.evt.deltaY;
          const zoomIntensity = 5e-3;
          const scaleBy = Math.exp(delta2 * zoomIntensity);
          const newScale = oldScale * scaleBy;
          const newPos = {
            x: pointer.x - mousePointTo.x * newScale,
            y: pointer.y - mousePointTo.y * newScale
          };
          this.setNewPosAndScale(static_layer, newPos, newScale);
        });
        this._stage.add(static_layer);
        this._stage.add(tooltipLayer);
        this._konva = {
          stage: this._stage,
          tooltip,
          static_layer,
          anim_layer: null
        };
        this.context = context;
        context.set_container(this._stage.container());
        this.context.add_observer((ev) => this._handle_stage_context_event(ev));
        this.registerListeners();
        setTimeout(() => this.resizeStage(), 1500);
      }
      setNewPosAndScale(static_layer, newPos, newScale) {
        static_layer.scale({ x: newScale, y: newScale });
        static_layer.position(newPos);
        this._bg.width(this._stage.width() / newScale);
        this._bg.height(this._stage.height() / newScale);
        this._bg.setAbsolutePosition({ x: 0, y: 0 });
        static_layer.batchDraw();
      }
      registerListeners() {
        window.addEventListener("resize", this.resizeStage);
      }
      unregisterListeners() {
        window.removeEventListener("resize", this.resizeStage);
      }
      destroy() {
        this.unregisterListeners();
        this._stage.destroy();
      }
      resizeStage() {
        const container = document.getElementById(this.config.container);
        if (!container)
          return;
        const containerWidth = container.offsetWidth;
        const containerHeight = container.offsetHeight;
        this._stage.width(containerWidth);
        this._stage.height(containerHeight);
      }
      reset_view() {
        this.setNewPosAndScale(this._konva.static_layer, { x: 0, y: 0 }, 1);
      }
      set_model(model) {
        if (this._model)
          ;
        this._conn_man = new ConnectionManager(this.context);
        this._reset_static_layer(this._konva.static_layer);
        this._konva.static_layer.add(this._conn_man.group);
        this._model = model;
        Object.keys(model._instances).forEach((id2) => this._add_module_instance_to_stage(Number(id2)));
        Object.keys(model._connections).forEach((id2) => {
          try {
            this._add_connection_to_stage(Number(id2));
          } catch (e) {
            console.warn(e);
          }
        });
        model.add_observer((ev) => this._handle_config_event(ev));
      }
      _handle_config_event(ev) {
        if (ev.type === "MODULE_INSTANCE_ADDED") {
          this._add_module_instance_to_stage(ev.id);
        } else if (ev.type === "CONNECTION_ADDED") {
          this._add_connection_to_stage(ev.id);
        } else if (ev.type === "CONNECTION_DELETED") {
          this._conn_man.delete_connection(ev.id);
          this.context.unselect();
        } else if (ev.type === "MODULE_INSTANCE_DELETED") {
          const id2 = ev.id;
          this._module_views[id2].group.destroy();
          delete this._module_views[id2];
          delete this._module_vms[id2];
          this.context.unselect();
        }
      }
      _handle_stage_context_event(ev) {
        if (ev.type === "ADD_CONNECTION") {
          this._model.add_connection(ev.connection);
        } else if (ev.type === "SHOW_TOOLTIP") {
          this._konva.tooltip.text(ev.text);
          this._konva.tooltip.show();
        } else if (ev.type === "HIDE_TOOLTIP") {
          this._konva.tooltip.hide();
        }
      }
      _add_module_instance_to_stage(id2) {
        const module_view_model = new ModuleViewModel(this._model, id2, this.context);
        this._module_vms[id2] = module_view_model;
        if (!module_view_model.grid_position) {
          module_view_model.grid_position = {
            x: id2,
            y: id2
          };
        }
        const module_view = new ModuleView(module_view_model);
        this._module_views[id2] = module_view;
        this._konva.static_layer.add(module_view.group);
      }
      _add_connection_to_stage(id2) {
        const cxn = this._model._connections[id2];
        const requiring_view_model = this._module_vms[cxn.requiring_instance_id];
        const requiring_view = this._module_views[cxn.requiring_instance_id];
        const providing_view_model = this._module_vms[cxn.providing_instance_id];
        const providing_view = this._module_views[cxn.providing_instance_id];
        const providing_terminal_lookup_id = providing_view_model.get_terminal_lookup_id(
          cxn.providing_impl_name,
          "provide"
        );
        if (providing_terminal_lookup_id === -1) {
          throw Error(`Couldn't add connection to stage, terminal ${cxn.providing_impl_name} not found on ${providing_view_model.type}.`);
        }
        const requiring_terminal_lookup_id = requiring_view_model.get_terminal_lookup_id(
          cxn.requirement_name,
          "requirement"
        );
        if (requiring_terminal_lookup_id === -1) {
          throw Error(`Couldn't add connection to stage, terminal ${cxn.requirement_name} not found on ${requiring_view_model.type}.`);
        }
        this._conn_man.add_connection(
          id2,
          { module_view: providing_view, terminal_lookup_id: providing_terminal_lookup_id },
          { module_view: requiring_view, terminal_lookup_id: requiring_terminal_lookup_id }
        );
      }
      _reset_static_layer(static_layer) {
        static_layer.destroyChildren();
        this._bg = new Konva.Rect({
          width: this._stage.width(),
          height: this._stage.height(),
          fill: "rgba(255, 0, 0, 0)"
        });
        this._bg.on("pointerclick", () => this.context.unselect());
        static_layer.add(this._bg);
        static_layer.on("dragstart", () => {
          this._stage.container().style.cursor = "grab";
        });
        static_layer.on("dragend", () => {
          this._stage.container().style.cursor = "default";
          this._bg.setAbsolutePosition({ x: 0, y: 0 });
        });
      }
    }
    /*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
    function isNothing(subject) {
      return typeof subject === "undefined" || subject === null;
    }
    function isObject$1(subject) {
      return typeof subject === "object" && subject !== null;
    }
    function toArray(sequence) {
      if (Array.isArray(sequence))
        return sequence;
      else if (isNothing(sequence))
        return [];
      return [sequence];
    }
    function extend(target2, source2) {
      var index, length, key, sourceKeys;
      if (source2) {
        sourceKeys = Object.keys(source2);
        for (index = 0, length = sourceKeys.length; index < length; index += 1) {
          key = sourceKeys[index];
          target2[key] = source2[key];
        }
      }
      return target2;
    }
    function repeat(string, count) {
      var result = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result += string;
      }
      return result;
    }
    function isNegativeZero(number) {
      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
    }
    var isNothing_1 = isNothing;
    var isObject_1 = isObject$1;
    var toArray_1 = toArray;
    var repeat_1 = repeat;
    var isNegativeZero_1 = isNegativeZero;
    var extend_1 = extend;
    var common$1 = {
      isNothing: isNothing_1,
      isObject: isObject_1,
      toArray: toArray_1,
      repeat: repeat_1,
      isNegativeZero: isNegativeZero_1,
      extend: extend_1
    };
    function formatError(exception2, compact) {
      var where = "", message = exception2.reason || "(unknown reason)";
      if (!exception2.mark)
        return message;
      if (exception2.mark.name) {
        where += 'in "' + exception2.mark.name + '" ';
      }
      where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
      if (!compact && exception2.mark.snippet) {
        where += "\n\n" + exception2.mark.snippet;
      }
      return message + " " + where;
    }
    function YAMLException$1(reason, mark) {
      Error.call(this);
      this.name = "YAMLException";
      this.reason = reason;
      this.mark = mark;
      this.message = formatError(this, false);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack || "";
      }
    }
    YAMLException$1.prototype = Object.create(Error.prototype);
    YAMLException$1.prototype.constructor = YAMLException$1;
    YAMLException$1.prototype.toString = function toString(compact) {
      return this.name + ": " + formatError(this, compact);
    };
    var exception = YAMLException$1;
    function getLine$1(buffer, lineStart, lineEnd, position, maxLineLength) {
      var head = "";
      var tail = "";
      var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
      if (position - lineStart > maxHalfLength) {
        head = " ... ";
        lineStart = position - maxHalfLength + head.length;
      }
      if (lineEnd - position > maxHalfLength) {
        tail = " ...";
        lineEnd = position + maxHalfLength - tail.length;
      }
      return {
        str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "→") + tail,
        pos: position - lineStart + head.length
        // relative position
      };
    }
    function padStart$1(string, max) {
      return common$1.repeat(" ", max - string.length) + string;
    }
    function makeSnippet(mark, options) {
      options = Object.create(options || null);
      if (!mark.buffer)
        return null;
      if (!options.maxLength)
        options.maxLength = 79;
      if (typeof options.indent !== "number")
        options.indent = 1;
      if (typeof options.linesBefore !== "number")
        options.linesBefore = 3;
      if (typeof options.linesAfter !== "number")
        options.linesAfter = 2;
      var re2 = /\r?\n|\r|\0/g;
      var lineStarts = [0];
      var lineEnds = [];
      var match;
      var foundLineNo = -1;
      while (match = re2.exec(mark.buffer)) {
        lineEnds.push(match.index);
        lineStarts.push(match.index + match[0].length);
        if (mark.position <= match.index && foundLineNo < 0) {
          foundLineNo = lineStarts.length - 2;
        }
      }
      if (foundLineNo < 0)
        foundLineNo = lineStarts.length - 1;
      var result = "", i2, line;
      var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
      var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
      for (i2 = 1; i2 <= options.linesBefore; i2++) {
        if (foundLineNo - i2 < 0)
          break;
        line = getLine$1(
          mark.buffer,
          lineStarts[foundLineNo - i2],
          lineEnds[foundLineNo - i2],
          mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i2]),
          maxLineLength
        );
        result = common$1.repeat(" ", options.indent) + padStart$1((mark.line - i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
      }
      line = getLine$1(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
      result += common$1.repeat(" ", options.indent) + padStart$1((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      result += common$1.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
      for (i2 = 1; i2 <= options.linesAfter; i2++) {
        if (foundLineNo + i2 >= lineEnds.length)
          break;
        line = getLine$1(
          mark.buffer,
          lineStarts[foundLineNo + i2],
          lineEnds[foundLineNo + i2],
          mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i2]),
          maxLineLength
        );
        result += common$1.repeat(" ", options.indent) + padStart$1((mark.line + i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      }
      return result.replace(/\n$/, "");
    }
    var snippet = makeSnippet;
    var TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "multi",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "representName",
      "defaultStyle",
      "styleAliases"
    ];
    var YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases(map2) {
      var result = {};
      if (map2 !== null) {
        Object.keys(map2).forEach(function(style) {
          map2[style].forEach(function(alias) {
            result[String(alias)] = style;
          });
        });
      }
      return result;
    }
    function Type$1(tag, options) {
      options = options || {};
      Object.keys(options).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
          throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
      });
      this.options = options;
      this.tag = tag;
      this.kind = options["kind"] || null;
      this.resolve = options["resolve"] || function() {
        return true;
      };
      this.construct = options["construct"] || function(data) {
        return data;
      };
      this.instanceOf = options["instanceOf"] || null;
      this.predicate = options["predicate"] || null;
      this.represent = options["represent"] || null;
      this.representName = options["representName"] || null;
      this.defaultStyle = options["defaultStyle"] || null;
      this.multi = options["multi"] || false;
      this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
      }
    }
    var type$9 = Type$1;
    function compileList(schema2, name) {
      var result = [];
      schema2[name].forEach(function(currentType) {
        var newIndex = result.length;
        result.forEach(function(previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
            newIndex = previousIndex;
          }
        });
        result[newIndex] = currentType;
      });
      return result;
    }
    function compileMap() {
      var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
          scalar: [],
          sequence: [],
          mapping: [],
          fallback: []
        }
      }, index, length;
      function collectType(type2) {
        if (type2.multi) {
          result.multi[type2.kind].push(type2);
          result.multi["fallback"].push(type2);
        } else {
          result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
        }
      }
      for (index = 0, length = arguments.length; index < length; index += 1) {
        arguments[index].forEach(collectType);
      }
      return result;
    }
    function Schema$1(definition) {
      return this.extend(definition);
    }
    Schema$1.prototype.extend = function extend2(definition) {
      var implicit = [];
      var explicit = [];
      if (definition instanceof type$9) {
        explicit.push(definition);
      } else if (Array.isArray(definition)) {
        explicit = explicit.concat(definition);
      } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
        if (definition.implicit)
          implicit = implicit.concat(definition.implicit);
        if (definition.explicit)
          explicit = explicit.concat(definition.explicit);
      } else {
        throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
      }
      implicit.forEach(function(type$12) {
        if (!(type$12 instanceof type$9)) {
          throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
        if (type$12.loadKind && type$12.loadKind !== "scalar") {
          throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
        if (type$12.multi) {
          throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
        }
      });
      explicit.forEach(function(type$12) {
        if (!(type$12 instanceof type$9)) {
          throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
      });
      var result = Object.create(Schema$1.prototype);
      result.implicit = (this.implicit || []).concat(implicit);
      result.explicit = (this.explicit || []).concat(explicit);
      result.compiledImplicit = compileList(result, "implicit");
      result.compiledExplicit = compileList(result, "explicit");
      result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
      return result;
    };
    var schema$2 = Schema$1;
    var str = new type$9("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
    var seq = new type$9("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
    var map$2 = new type$9("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
    var failsafe = new schema$2({
      explicit: [
        str,
        seq,
        map$2
      ]
    });
    function resolveYamlNull(data) {
      if (data === null)
        return true;
      var max = data.length;
      return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull(object) {
      return object === null;
    }
    var _null = new type$9("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        },
        empty: function() {
          return "";
        }
      },
      defaultStyle: "lowercase"
    });
    function resolveYamlBoolean(data) {
      if (data === null)
        return false;
      var max = data.length;
      return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
    }
    function constructYamlBoolean(data) {
      return data === "true" || data === "True" || data === "TRUE";
    }
    function isBoolean(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    var bool = new type$9("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
    function isHexCode(c) {
      return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
    }
    function isOctCode(c) {
      return 48 <= c && c <= 55;
    }
    function isDecCode(c) {
      return 48 <= c && c <= 57;
    }
    function resolveYamlInteger(data) {
      if (data === null)
        return false;
      var max = data.length, index = 0, hasDigits = false, ch;
      if (!max)
        return false;
      ch = data[index];
      if (ch === "-" || ch === "+") {
        ch = data[++index];
      }
      if (ch === "0") {
        if (index + 1 === max)
          return true;
        ch = data[++index];
        if (ch === "b") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (ch !== "0" && ch !== "1")
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (!isHexCode(data.charCodeAt(index)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "o") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (!isOctCode(data.charCodeAt(index)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
      }
      if (ch === "_")
        return false;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isDecCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits || ch === "_")
        return false;
      return true;
    }
    function constructYamlInteger(data) {
      var value = data, sign = 1, ch;
      if (value.indexOf("_") !== -1) {
        value = value.replace(/_/g, "");
      }
      ch = value[0];
      if (ch === "-" || ch === "+") {
        if (ch === "-")
          sign = -1;
        value = value.slice(1);
        ch = value[0];
      }
      if (value === "0")
        return 0;
      if (ch === "0") {
        if (value[1] === "b")
          return sign * parseInt(value.slice(2), 2);
        if (value[1] === "x")
          return sign * parseInt(value.slice(2), 16);
        if (value[1] === "o")
          return sign * parseInt(value.slice(2), 8);
      }
      return sign * parseInt(value, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common$1.isNegativeZero(object));
    }
    var int$1 = new type$9("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        /* eslint-disable max-len */
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
    var YAML_FLOAT_PATTERN = new RegExp(
      // 2.5e4, 2.5 and integers
      "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
    );
    function resolveYamlFloat(data) {
      if (data === null)
        return false;
      if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === "_") {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data) {
      var value, sign;
      value = data.replace(/_/g, "").toLowerCase();
      sign = value[0] === "-" ? -1 : 1;
      if ("+-".indexOf(value[0]) >= 0) {
        value = value.slice(1);
      }
      if (value === ".inf") {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value === ".nan") {
        return NaN;
      }
      return sign * parseFloat(value, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object)) {
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      } else if (common$1.isNegativeZero(object)) {
        return "-0.0";
      }
      res = object.toString(10);
      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common$1.isNegativeZero(object));
    }
    var float = new type$9("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
    var json$1 = failsafe.extend({
      implicit: [
        _null,
        bool,
        int$1,
        float
      ]
    });
    var core$5 = json$1;
    var YAML_DATE_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
    );
    var YAML_TIMESTAMP_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
    );
    function resolveYamlTimestamp(data) {
      if (data === null)
        return false;
      if (YAML_DATE_REGEXP.exec(data) !== null)
        return true;
      if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
        return true;
      return false;
    }
    function constructYamlTimestamp(data) {
      var match, year, month, day, hour, minute, second, fraction = 0, delta2 = null, tz_hour, tz_minute, date2;
      match = YAML_DATE_REGEXP.exec(data);
      if (match === null)
        match = YAML_TIMESTAMP_REGEXP.exec(data);
      if (match === null)
        throw new Error("Date resolve error");
      year = +match[1];
      month = +match[2] - 1;
      day = +match[3];
      if (!match[4]) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = +match[4];
      minute = +match[5];
      second = +match[6];
      if (match[7]) {
        fraction = match[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction += "0";
        }
        fraction = +fraction;
      }
      if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta2 = (tz_hour * 60 + tz_minute) * 6e4;
        if (match[9] === "-")
          delta2 = -delta2;
      }
      date2 = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta2)
        date2.setTime(date2.getTime() - delta2);
      return date2;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    var timestamp = new type$9("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
    function resolveYamlMerge(data) {
      return data === "<<" || data === null;
    }
    var merge = new type$9("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
    var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    function resolveYamlBinary(data) {
      if (data === null)
        return false;
      var code2, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        code2 = map2.indexOf(data.charAt(idx));
        if (code2 > 64)
          continue;
        if (code2 < 0)
          return false;
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data) {
      var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
      for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        }
        bits = bits << 6 | map2.indexOf(input.charAt(idx));
      }
      tailbits = max % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 255);
        result.push(bits >> 2 & 255);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 255);
      }
      return new Uint8Array(result);
    }
    function representYamlBinary(object) {
      var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map2[bits >> 18 & 63];
          result += map2[bits >> 12 & 63];
          result += map2[bits >> 6 & 63];
          result += map2[bits & 63];
        }
        bits = (bits << 8) + object[idx];
      }
      tail = max % 3;
      if (tail === 0) {
        result += map2[bits >> 18 & 63];
        result += map2[bits >> 12 & 63];
        result += map2[bits >> 6 & 63];
        result += map2[bits & 63];
      } else if (tail === 2) {
        result += map2[bits >> 10 & 63];
        result += map2[bits >> 4 & 63];
        result += map2[bits << 2 & 63];
        result += map2[64];
      } else if (tail === 1) {
        result += map2[bits >> 2 & 63];
        result += map2[bits << 4 & 63];
        result += map2[64];
        result += map2[64];
      }
      return result;
    }
    function isBinary(obj) {
      return Object.prototype.toString.call(obj) === "[object Uint8Array]";
    }
    var binary = new type$9("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
    var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
    var _toString$2 = Object.prototype.toString;
    function resolveYamlOmap(data) {
      if (data === null)
        return true;
      var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        pairHasKey = false;
        if (_toString$2.call(pair) !== "[object Object]")
          return false;
        for (pairKey in pair) {
          if (_hasOwnProperty$3.call(pair, pairKey)) {
            if (!pairHasKey)
              pairHasKey = true;
            else
              return false;
          }
        }
        if (!pairHasKey)
          return false;
        if (objectKeys.indexOf(pairKey) === -1)
          objectKeys.push(pairKey);
        else
          return false;
      }
      return true;
    }
    function constructYamlOmap(data) {
      return data !== null ? data : [];
    }
    var omap = new type$9("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
    var _toString$1 = Object.prototype.toString;
    function resolveYamlPairs(data) {
      if (data === null)
        return true;
      var index, length, pair, keys2, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        if (_toString$1.call(pair) !== "[object Object]")
          return false;
        keys2 = Object.keys(pair);
        if (keys2.length !== 1)
          return false;
        result[index] = [keys2[0], pair[keys2[0]]];
      }
      return true;
    }
    function constructYamlPairs(data) {
      if (data === null)
        return [];
      var index, length, pair, keys2, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        keys2 = Object.keys(pair);
        result[index] = [keys2[0], pair[keys2[0]]];
      }
      return result;
    }
    var pairs = new type$9("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
    var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data) {
      if (data === null)
        return true;
      var key, object = data;
      for (key in object) {
        if (_hasOwnProperty$2.call(object, key)) {
          if (object[key] !== null)
            return false;
        }
      }
      return true;
    }
    function constructYamlSet(data) {
      return data !== null ? data : {};
    }
    var set$1 = new type$9("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
    var _default$1 = core$5.extend({
      implicit: [
        timestamp,
        merge
      ],
      explicit: [
        binary,
        omap,
        pairs,
        set$1
      ]
    });
    var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class$1(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c) {
      return c === 10 || c === 13;
    }
    function is_WHITE_SPACE(c) {
      return c === 9 || c === 32;
    }
    function is_WS_OR_EOL(c) {
      return c === 9 || c === 32 || c === 10 || c === 13;
    }
    function is_FLOW_INDICATOR(c) {
      return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
    }
    function fromHexCode(c) {
      var lc;
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      lc = c | 32;
      if (97 <= lc && lc <= 102) {
        return lc - 97 + 10;
      }
      return -1;
    }
    function escapedHexLen(c) {
      if (c === 120) {
        return 2;
      }
      if (c === 117) {
        return 4;
      }
      if (c === 85) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c) {
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      return -1;
    }
    function simpleEscapeSequence(c) {
      return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "" : c === 95 ? " " : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(c) {
      if (c <= 65535) {
        return String.fromCharCode(c);
      }
      return String.fromCharCode(
        (c - 65536 >> 10) + 55296,
        (c - 65536 & 1023) + 56320
      );
    }
    var simpleEscapeCheck = new Array(256);
    var simpleEscapeMap = new Array(256);
    for (var i$1 = 0; i$1 < 256; i$1++) {
      simpleEscapeCheck[i$1] = simpleEscapeSequence(i$1) ? 1 : 0;
      simpleEscapeMap[i$1] = simpleEscapeSequence(i$1);
    }
    function State$1(input, options) {
      this.input = input;
      this.filename = options["filename"] || null;
      this.schema = options["schema"] || _default$1;
      this.onWarning = options["onWarning"] || null;
      this.legacy = options["legacy"] || false;
      this.json = options["json"] || false;
      this.listener = options["listener"] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.firstTabInLine = -1;
      this.documents = [];
    }
    function generateError(state, message) {
      var mark = {
        name: state.filename,
        buffer: state.input.slice(0, -1),
        // omit trailing \0
        position: state.position,
        line: state.line,
        column: state.position - state.lineStart
      };
      mark.snippet = snippet(mark);
      return new exception(message, mark);
    }
    function throwError(state, message) {
      throw generateError(state, message);
    }
    function throwWarning(state, message) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message));
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty$1.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        try {
          prefix = decodeURIComponent(prefix);
        } catch (err) {
          throwError(state, "tag prefix is malformed: " + prefix);
        }
        state.tagMap[handle] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
              throwError(state, "expected valid JSON character");
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, "the stream contains non-printable characters");
        }
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source2, overridableKeys) {
      var sourceKeys, key, index, quantity;
      if (!common$1.isObject(source2)) {
        throwError(state, "cannot merge mappings; the provided source object is unacceptable");
      }
      sourceKeys = Object.keys(source2);
      for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
        key = sourceKeys[index];
        if (!_hasOwnProperty$1.call(destination, key)) {
          destination[key] = source2[key];
          overridableKeys[key] = true;
        }
      }
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
      var index, quantity;
      if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
          if (Array.isArray(keyNode[index])) {
            throwError(state, "nested arrays are not supported inside keys");
          }
          if (typeof keyNode === "object" && _class$1(keyNode[index]) === "[object Object]") {
            keyNode[index] = "[object Object]";
          }
        }
      }
      if (typeof keyNode === "object" && _class$1(keyNode) === "[object Object]") {
        keyNode = "[object Object]";
      }
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
          for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
            mergeMappings(state, _result, valueNode[index], overridableKeys);
          }
        } else {
          mergeMappings(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.lineStart = startLineStart || state.lineStart;
          state.position = startPos || state.position;
          throwError(state, "duplicated mapping key");
        }
        if (keyNode === "__proto__") {
          Object.defineProperty(_result, keyNode, {
            configurable: true,
            enumerable: true,
            writable: true,
            value: valueNode
          });
        } else {
          _result[keyNode] = valueNode;
        }
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 10) {
        state.position++;
      } else if (ch === 13) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 10) {
          state.position++;
        }
      } else {
        throwError(state, "a line break is expected");
      }
      state.line += 1;
      state.lineStart = state.position;
      state.firstTabInLine = -1;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          if (ch === 9 && state.firstTabInLine === -1) {
            state.firstTabInLine = state.position;
          }
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 10 && ch !== 13 && ch !== 0);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      ch = state.input.charCodeAt(_position);
      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, count) {
      if (count === 1) {
        state.result += " ";
      } else if (count > 1) {
        state.result += common$1.repeat("\n", count - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
        return false;
      }
      if (ch === 63 || ch === 45) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = "scalar";
      state.result = "";
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 58) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 35) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 39) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 39) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 39) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 34) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 34) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 92) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, "expected hexadecimal character");
              }
            }
            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, "unknown escape sequence");
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 91) {
        terminator = 93;
        isMapping = false;
        _result = [];
      } else if (ch === 123) {
        terminator = 125;
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? "mapping" : "sequence";
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError(state, "missed comma between flow collection entries");
        } else if (ch === 44) {
          throwError(state, "expected the node content, but found ','");
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 63) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        _lineStart = state.lineStart;
        _pos = state.position;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 58) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
        } else if (isPair) {
          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 44) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 124) {
        folding = false;
      } else if (ch === 62) {
        folding = true;
      } else {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 43 || ch === 45) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, "repeat of a chomping mode identifier");
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, "repeat of an indentation width identifier");
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP) {
            state.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (didReadContent) {
              state.result += "\n";
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            state.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common$1.repeat("\n", emptyLines + 1);
          } else if (emptyLines === 0) {
            if (didReadContent) {
              state.result += " ";
            }
          } else {
            state.result += common$1.repeat("\n", emptyLines);
          }
        } else {
          state.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
      if (state.firstTabInLine !== -1)
        return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError(state, "tab characters must not be used in indentation");
        }
        if (ch !== 45) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
      if (state.firstTabInLine !== -1)
        return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (!atExplicitKey && state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError(state, "tab characters must not be used in indentation");
        }
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
          if (ch === 63) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
          }
          state.position += 1;
          ch = following;
        } else {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
          if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
            break;
          }
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 58) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (atExplicitKey) {
            _keyLine = state.line;
            _keyLineStart = state.lineStart;
            _keyPos = state.position;
          }
          if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 33)
        return false;
      if (state.tag !== null) {
        throwError(state, "duplication of a tag property");
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 60) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 33) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = "!";
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 62);
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, "unexpected end of the stream within a verbatim tag");
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          if (ch === 33) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, "named tag handle cannot contain such characters");
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, "tag suffix cannot contain exclamation marks");
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, "tag suffix cannot contain flow indicator characters");
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
      }
      try {
        tagName = decodeURIComponent(tagName);
      } catch (err) {
        throwError(state, "tag name is malformed: " + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
      } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 38)
        return false;
      if (state.anchor !== null) {
        throwError(state, "duplication of an anchor property");
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 42)
        return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an alias node must contain at least one character");
      }
      alias = state.input.slice(_position, state.position);
      if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
      }
      state.result = state.anchorMap[alias];
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
      if (state.listener !== null) {
        state.listener("open", state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError(state, "alias node should not have any properties");
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = "?";
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (state.tag === null) {
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      } else if (state.tag === "?") {
        if (state.result !== null && state.kind !== "scalar") {
          throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
        }
        for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
          type2 = state.implicitTypes[typeIndex];
          if (type2.resolve(state.result)) {
            state.result = type2.construct(state.result);
            state.tag = type2.tag;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
            break;
          }
        }
      } else if (state.tag !== "!") {
        if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
          type2 = state.typeMap[state.kind || "fallback"][state.tag];
        } else {
          type2 = null;
          typeList = state.typeMap.multi[state.kind || "fallback"];
          for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
            if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
              type2 = typeList[typeIndex];
              break;
            }
          }
        }
        if (!type2) {
          throwError(state, "unknown tag !<" + state.tag + ">");
        }
        if (state.result !== null && type2.kind !== state.kind) {
          throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
        }
        if (!type2.resolve(state.result, state.tag)) {
          throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
        } else {
          state.result = type2.construct(state.result, state.tag);
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      }
      if (state.listener !== null) {
        state.listener("close", state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = /* @__PURE__ */ Object.create(null);
      state.anchorMap = /* @__PURE__ */ Object.create(null);
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 37) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, "directive name must not be less than one character in length");
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch))
            break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0)
          readLineBreak(state);
        if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
      }
      composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 46) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
      } else {
        return;
      }
    }
    function loadDocuments(input, options) {
      input = String(input);
      options = options || {};
      if (input.length !== 0) {
        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
          input += "\n";
        }
        if (input.charCodeAt(0) === 65279) {
          input = input.slice(1);
        }
      }
      var state = new State$1(input, options);
      var nullpos = input.indexOf("\0");
      if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, "null byte is not allowed in input");
      }
      state.input += "\0";
      while (state.input.charCodeAt(state.position) === 32) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument(state);
      }
      return state.documents;
    }
    function loadAll$1(input, iterator, options) {
      if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
        options = iterator;
        iterator = null;
      }
      var documents = loadDocuments(input, options);
      if (typeof iterator !== "function") {
        return documents;
      }
      for (var index = 0, length = documents.length; index < length; index += 1) {
        iterator(documents[index]);
      }
    }
    function load$1(input, options) {
      var documents = loadDocuments(input, options);
      if (documents.length === 0) {
        return void 0;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new exception("expected a single document in the stream, but found more");
    }
    var loadAll_1 = loadAll$1;
    var load_1 = load$1;
    var loader = {
      loadAll: loadAll_1,
      load: load_1
    };
    var _toString = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_BOM = 65279;
    var CHAR_TAB = 9;
    var CHAR_LINE_FEED = 10;
    var CHAR_CARRIAGE_RETURN = 13;
    var CHAR_SPACE = 32;
    var CHAR_EXCLAMATION = 33;
    var CHAR_DOUBLE_QUOTE = 34;
    var CHAR_SHARP = 35;
    var CHAR_PERCENT = 37;
    var CHAR_AMPERSAND = 38;
    var CHAR_SINGLE_QUOTE = 39;
    var CHAR_ASTERISK = 42;
    var CHAR_COMMA = 44;
    var CHAR_MINUS = 45;
    var CHAR_COLON = 58;
    var CHAR_EQUALS = 61;
    var CHAR_GREATER_THAN = 62;
    var CHAR_QUESTION = 63;
    var CHAR_COMMERCIAL_AT = 64;
    var CHAR_LEFT_SQUARE_BRACKET = 91;
    var CHAR_RIGHT_SQUARE_BRACKET = 93;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
    function compileStyleMap(schema2, map2) {
      var result, keys2, index, length, tag, style, type2;
      if (map2 === null)
        return {};
      result = {};
      keys2 = Object.keys(map2);
      for (index = 0, length = keys2.length; index < length; index += 1) {
        tag = keys2[index];
        style = String(map2[tag]);
        if (tag.slice(0, 2) === "!!") {
          tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type2 = schema2.compiledTypeMap["fallback"][tag];
        if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
          style = type2.styleAliases[style];
        }
        result[tag] = style;
      }
      return result;
    }
    function encodeHex(character) {
      var string, handle, length;
      string = character.toString(16).toUpperCase();
      if (character <= 255) {
        handle = "x";
        length = 2;
      } else if (character <= 65535) {
        handle = "u";
        length = 4;
      } else if (character <= 4294967295) {
        handle = "U";
        length = 8;
      } else {
        throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
      }
      return "\\" + handle + common$1.repeat("0", length - string.length) + string;
    }
    var QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;
    function State(options) {
      this.schema = options["schema"] || _default$1;
      this.indent = Math.max(1, options["indent"] || 2);
      this.noArrayIndent = options["noArrayIndent"] || false;
      this.skipInvalid = options["skipInvalid"] || false;
      this.flowLevel = common$1.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
      this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
      this.sortKeys = options["sortKeys"] || false;
      this.lineWidth = options["lineWidth"] || 80;
      this.noRefs = options["noRefs"] || false;
      this.noCompatMode = options["noCompatMode"] || false;
      this.condenseFlow = options["condenseFlow"] || false;
      this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
      this.forceQuotes = options["forceQuotes"] || false;
      this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = "";
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString(string, spaces) {
      var ind = common$1.repeat(" ", spaces), position = 0, next2 = -1, result = "", line, length = string.length;
      while (position < length) {
        next2 = string.indexOf("\n", position);
        if (next2 === -1) {
          line = string.slice(position);
          position = length;
        } else {
          line = string.slice(position, next2 + 1);
          position = next2 + 1;
        }
        if (line.length && line !== "\n")
          result += ind;
        result += line;
      }
      return result;
    }
    function generateNextLine(state, level) {
      return "\n" + common$1.repeat(" ", state.indent * level);
    }
    function testImplicitResolving(state, str2) {
      var index, length, type2;
      for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
        type2 = state.implicitTypes[index];
        if (type2.resolve(str2)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace(c) {
      return c === CHAR_SPACE || c === CHAR_TAB;
    }
    function isPrintable(c) {
      return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
    }
    function isNsCharOrWhitespace(c) {
      return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
    }
    function isPlainSafe(c, prev, inblock) {
      var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
      var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
      return (
        // ns-plain-safe
        (inblock ? (
          // c = flow-in
          cIsNsCharOrWhitespace
        ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
      );
    }
    function isPlainSafeFirst(c) {
      return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
    }
    function isPlainSafeLast(c) {
      return !isWhitespace(c) && c !== CHAR_COLON;
    }
    function codePointAt(string, pos) {
      var first = string.charCodeAt(pos), second;
      if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
        second = string.charCodeAt(pos + 1);
        if (second >= 56320 && second <= 57343) {
          return (first - 55296) * 1024 + second - 56320 + 65536;
        }
      }
      return first;
    }
    function needIndentIndicator(string) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string);
    }
    var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
    function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
      var i2;
      var char = 0;
      var prevChar = null;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
      if (singleLineOnly || forceQuotes) {
        for (i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
          char = codePointAt(string, i2);
          if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char, prevChar, inblock);
          prevChar = char;
        }
      } else {
        for (i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
          char = codePointAt(string, i2);
          if (char === CHAR_LINE_FEED) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
              i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
              previousLineBreak = i2;
            }
          } else if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char, prevChar, inblock);
          prevChar = char;
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
      }
      if (!hasLineBreak && !hasFoldableLine) {
        if (plain && !forceQuotes && !testAmbiguousType(string)) {
          return STYLE_PLAIN;
        }
        return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
      }
      if (indentPerLevel > 9 && needIndentIndicator(string)) {
        return STYLE_DOUBLE;
      }
      if (!forceQuotes) {
        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    function writeScalar(state, string, level, iskey, inblock) {
      state.dump = function() {
        if (string.length === 0) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
        }
        if (!state.noCompatMode) {
          if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
            return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
          }
        }
        var indent = state.indent * Math.max(1, level);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string2) {
          return testImplicitResolving(state, string2);
        }
        switch (chooseScalarStyle(
          string,
          singleLineOnly,
          state.indent,
          lineWidth,
          testAmbiguity,
          state.quotingType,
          state.forceQuotes && !iskey,
          inblock
        )) {
          case STYLE_PLAIN:
            return string;
          case STYLE_SINGLE:
            return "'" + string.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string) + '"';
          default:
            throw new exception("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(string, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
      var clip = string[string.length - 1] === "\n";
      var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
      var chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + "\n";
    }
    function dropEndingNewline(string) {
      return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
    }
    function foldString(string, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result = function() {
        var nextLF = string.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string.slice(0, nextLF), width);
      }();
      var prevMoreIndented = string[0] === "\n" || string[0] === " ";
      var moreIndented;
      var match;
      while (match = lineRe.exec(string)) {
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line, width) {
      if (line === "" || line[0] === " ")
        return line;
      var breakRe = / [^ ]/g;
      var match;
      var start = 0, end, curr = 0, next2 = 0;
      var result = "";
      while (match = breakRe.exec(line)) {
        next2 = match.index;
        if (next2 - start > width) {
          end = curr > start ? curr : next2;
          result += "\n" + line.slice(start, end);
          start = end + 1;
        }
        curr = next2;
      }
      result += "\n";
      if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
      } else {
        result += line.slice(start);
      }
      return result.slice(1);
    }
    function escapeString(string) {
      var result = "";
      var char = 0;
      var escapeSeq;
      for (var i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
        char = codePointAt(string, i2);
        escapeSeq = ESCAPE_SEQUENCES[char];
        if (!escapeSeq && isPrintable(char)) {
          result += string[i2];
          if (char >= 65536)
            result += string[i2 + 1];
        } else {
          result += escapeSeq || encodeHex(char);
        }
      }
      return result;
    }
    function writeFlowSequence(state, level, object) {
      var _result = "", _tag = state.tag, index, length, value;
      for (index = 0, length = object.length; index < length; index += 1) {
        value = object[index];
        if (state.replacer) {
          value = state.replacer.call(object, String(index), value);
        }
        if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
          if (_result !== "")
            _result += "," + (!state.condenseFlow ? " " : "");
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = "", _tag = state.tag, index, length, value;
      for (index = 0, length = object.length; index < length; index += 1) {
        value = object[index];
        if (state.replacer) {
          value = state.replacer.call(object, String(index), value);
        }
        if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
          if (!compact || _result !== "") {
            _result += generateNextLine(state, level);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += "-";
          } else {
            _result += "- ";
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (_result !== "")
          pairBuffer += ", ";
        if (state.condenseFlow)
          pairBuffer += '"';
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024)
          pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === "function") {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new exception("sortKeys must be a boolean or a function");
      }
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (!compact || _result !== "") {
          pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += "?";
          } else {
            pairBuffer += "? ";
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ":";
        } else {
          pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || "{}";
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index, length, type2, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index = 0, length = typeList.length; index < length; index += 1) {
        type2 = typeList[index];
        if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
          if (explicit) {
            if (type2.multi && type2.representName) {
              state.tag = type2.representName(object);
            } else {
              state.tag = type2.tag;
            }
          } else {
            state.tag = "?";
          }
          if (type2.represent) {
            style = state.styleMap[type2.tag] || type2.defaultStyle;
            if (_toString.call(type2.represent) === "[object Function]") {
              _result = type2.represent(object, style);
            } else if (_hasOwnProperty.call(type2.represent, style)) {
              _result = type2.represent[style](object, style);
            } else {
              throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode(state, level, object, block2, compact, iskey, isblockseq) {
      state.tag = null;
      state.dump = object;
      if (!detectType(state, object, false)) {
        detectType(state, object, true);
      }
      var type2 = _toString.call(state.dump);
      var inblock = block2;
      var tagStr;
      if (block2) {
        block2 = state.flowLevel < 0 || state.flowLevel > level;
      }
      var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type2 === "[object Object]") {
          if (block2 && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type2 === "[object Array]") {
          if (block2 && state.dump.length !== 0) {
            if (state.noArrayIndent && !isblockseq && level > 0) {
              writeBlockSequence(state, level - 1, state.dump, compact);
            } else {
              writeBlockSequence(state, level, state.dump, compact);
            }
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type2 === "[object String]") {
          if (state.tag !== "?") {
            writeScalar(state, state.dump, level, iskey, inblock);
          }
        } else if (type2 === "[object Undefined]") {
          return false;
        } else {
          if (state.skipInvalid)
            return false;
          throw new exception("unacceptable kind of an object to dump " + type2);
        }
        if (state.tag !== null && state.tag !== "?") {
          tagStr = encodeURI(
            state.tag[0] === "!" ? state.tag.slice(1) : state.tag
          ).replace(/!/g, "%21");
          if (state.tag[0] === "!") {
            tagStr = "!" + tagStr;
          } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
            tagStr = "!!" + tagStr.slice(18);
          } else {
            tagStr = "!<" + tagStr + ">";
          }
          state.dump = tagStr + " " + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index, length;
      inspectNode(object, objects, duplicatesIndexes);
      for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index, length;
      if (object !== null && typeof object === "object") {
        index = objects.indexOf(object);
        if (index !== -1) {
          if (duplicatesIndexes.indexOf(index) === -1) {
            duplicatesIndexes.push(index);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index = 0, length = object.length; index < length; index += 1) {
              inspectNode(object[index], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index = 0, length = objectKeyList.length; index < length; index += 1) {
              inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump$1(input, options) {
      options = options || {};
      var state = new State(options);
      if (!state.noRefs)
        getDuplicateReferences(input, state);
      var value = input;
      if (state.replacer) {
        value = state.replacer.call({ "": value }, "", value);
      }
      if (writeNode(state, 0, value, true, true))
        return state.dump + "\n";
      return "";
    }
    var dump_1 = dump$1;
    var dumper = {
      dump: dump_1
    };
    function renamed(from, to) {
      return function() {
        throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
      };
    }
    var Type$2 = type$9;
    var Schema = schema$2;
    var FAILSAFE_SCHEMA = failsafe;
    var JSON_SCHEMA = json$1;
    var CORE_SCHEMA = core$5;
    var DEFAULT_SCHEMA = _default$1;
    var load = loader.load;
    var loadAll = loader.loadAll;
    var dump = dumper.dump;
    var YAMLException = exception;
    var types$1 = {
      binary,
      float,
      map: map$2,
      null: _null,
      pairs,
      set: set$1,
      timestamp,
      bool,
      int: int$1,
      merge,
      omap,
      seq,
      str
    };
    var safeLoad = renamed("safeLoad", "load");
    var safeLoadAll = renamed("safeLoadAll", "loadAll");
    var safeDump = renamed("safeDump", "dump");
    var jsYaml = {
      Type: Type$2,
      Schema,
      FAILSAFE_SCHEMA,
      JSON_SCHEMA,
      CORE_SCHEMA,
      DEFAULT_SCHEMA,
      load,
      loadAll,
      dump,
      YAMLException,
      types: types$1,
      safeLoad,
      safeLoadAll,
      safeDump
    };
    function deepFreeze(obj) {
      if (obj instanceof Map) {
        obj.clear = obj.delete = obj.set = function() {
          throw new Error("map is read-only");
        };
      } else if (obj instanceof Set) {
        obj.add = obj.clear = obj.delete = function() {
          throw new Error("set is read-only");
        };
      }
      Object.freeze(obj);
      Object.getOwnPropertyNames(obj).forEach((name) => {
        const prop2 = obj[name];
        const type2 = typeof prop2;
        if ((type2 === "object" || type2 === "function") && !Object.isFrozen(prop2)) {
          deepFreeze(prop2);
        }
      });
      return obj;
    }
    class Response {
      /**
       * @param {CompiledMode} mode
       */
      constructor(mode) {
        if (mode.data === void 0)
          mode.data = {};
        this.data = mode.data;
        this.isMatchIgnored = false;
      }
      ignoreMatch() {
        this.isMatchIgnored = true;
      }
    }
    function escapeHTML(value) {
      return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
    }
    function inherit$1(original, ...objects) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const key in original) {
        result[key] = original[key];
      }
      objects.forEach(function(obj) {
        for (const key in obj) {
          result[key] = obj[key];
        }
      });
      return (
        /** @type {T} */
        result
      );
    }
    const SPAN_CLOSE = "</span>";
    const emitsWrappingTags = (node) => {
      return !!node.scope;
    };
    const scopeToCSSClass = (name, { prefix }) => {
      if (name.startsWith("language:")) {
        return name.replace("language:", "language-");
      }
      if (name.includes(".")) {
        const pieces = name.split(".");
        return [
          `${prefix}${pieces.shift()}`,
          ...pieces.map((x2, i2) => `${x2}${"_".repeat(i2 + 1)}`)
        ].join(" ");
      }
      return `${prefix}${name}`;
    };
    class HTMLRenderer {
      /**
       * Creates a new HTMLRenderer
       *
       * @param {Tree} parseTree - the parse tree (must support `walk` API)
       * @param {{classPrefix: string}} options
       */
      constructor(parseTree, options) {
        this.buffer = "";
        this.classPrefix = options.classPrefix;
        parseTree.walk(this);
      }
      /**
       * Adds texts to the output stream
       *
       * @param {string} text */
      addText(text2) {
        this.buffer += escapeHTML(text2);
      }
      /**
       * Adds a node open to the output stream (if needed)
       *
       * @param {Node} node */
      openNode(node) {
        if (!emitsWrappingTags(node))
          return;
        const className = scopeToCSSClass(
          node.scope,
          { prefix: this.classPrefix }
        );
        this.span(className);
      }
      /**
       * Adds a node close to the output stream (if needed)
       *
       * @param {Node} node */
      closeNode(node) {
        if (!emitsWrappingTags(node))
          return;
        this.buffer += SPAN_CLOSE;
      }
      /**
       * returns the accumulated buffer
      */
      value() {
        return this.buffer;
      }
      // helpers
      /**
       * Builds a span element
       *
       * @param {string} className */
      span(className) {
        this.buffer += `<span class="${className}">`;
      }
    }
    const newNode = (opts = {}) => {
      const result = { children: [] };
      Object.assign(result, opts);
      return result;
    };
    class TokenTree {
      constructor() {
        this.rootNode = newNode();
        this.stack = [this.rootNode];
      }
      get top() {
        return this.stack[this.stack.length - 1];
      }
      get root() {
        return this.rootNode;
      }
      /** @param {Node} node */
      add(node) {
        this.top.children.push(node);
      }
      /** @param {string} scope */
      openNode(scope2) {
        const node = newNode({ scope: scope2 });
        this.add(node);
        this.stack.push(node);
      }
      closeNode() {
        if (this.stack.length > 1) {
          return this.stack.pop();
        }
        return void 0;
      }
      closeAllNodes() {
        while (this.closeNode())
          ;
      }
      toJSON() {
        return JSON.stringify(this.rootNode, null, 4);
      }
      /**
       * @typedef { import("./html_renderer").Renderer } Renderer
       * @param {Renderer} builder
       */
      walk(builder) {
        return this.constructor._walk(builder, this.rootNode);
      }
      /**
       * @param {Renderer} builder
       * @param {Node} node
       */
      static _walk(builder, node) {
        if (typeof node === "string") {
          builder.addText(node);
        } else if (node.children) {
          builder.openNode(node);
          node.children.forEach((child) => this._walk(builder, child));
          builder.closeNode(node);
        }
        return builder;
      }
      /**
       * @param {Node} node
       */
      static _collapse(node) {
        if (typeof node === "string")
          return;
        if (!node.children)
          return;
        if (node.children.every((el2) => typeof el2 === "string")) {
          node.children = [node.children.join("")];
        } else {
          node.children.forEach((child) => {
            TokenTree._collapse(child);
          });
        }
      }
    }
    class TokenTreeEmitter extends TokenTree {
      /**
       * @param {*} options
       */
      constructor(options) {
        super();
        this.options = options;
      }
      /**
       * @param {string} text
       */
      addText(text2) {
        if (text2 === "") {
          return;
        }
        this.add(text2);
      }
      /** @param {string} scope */
      startScope(scope2) {
        this.openNode(scope2);
      }
      endScope() {
        this.closeNode();
      }
      /**
       * @param {Emitter & {root: DataNode}} emitter
       * @param {string} name
       */
      __addSublanguage(emitter, name) {
        const node = emitter.root;
        if (name)
          node.scope = `language:${name}`;
        this.add(node);
      }
      toHTML() {
        const renderer2 = new HTMLRenderer(this, this.options);
        return renderer2.value();
      }
      finalize() {
        this.closeAllNodes();
        return true;
      }
    }
    function source(re2) {
      if (!re2)
        return null;
      if (typeof re2 === "string")
        return re2;
      return re2.source;
    }
    function lookahead(re2) {
      return concat("(?=", re2, ")");
    }
    function anyNumberOfTimes(re2) {
      return concat("(?:", re2, ")*");
    }
    function optional(re2) {
      return concat("(?:", re2, ")?");
    }
    function concat(...args) {
      const joined = args.map((x2) => source(x2)).join("");
      return joined;
    }
    function stripOptionsFromArgs(args) {
      const opts = args[args.length - 1];
      if (typeof opts === "object" && opts.constructor === Object) {
        args.splice(args.length - 1, 1);
        return opts;
      } else {
        return {};
      }
    }
    function either(...args) {
      const opts = stripOptionsFromArgs(args);
      const joined = "(" + (opts.capture ? "" : "?:") + args.map((x2) => source(x2)).join("|") + ")";
      return joined;
    }
    function countMatchGroups(re2) {
      return new RegExp(re2.toString() + "|").exec("").length - 1;
    }
    function startsWith(re2, lexeme) {
      const match = re2 && re2.exec(lexeme);
      return match && match.index === 0;
    }
    const BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
    function _rewriteBackreferences(regexps, { joinWith }) {
      let numCaptures = 0;
      return regexps.map((regex2) => {
        numCaptures += 1;
        const offset = numCaptures;
        let re2 = source(regex2);
        let out = "";
        while (re2.length > 0) {
          const match = BACKREF_RE.exec(re2);
          if (!match) {
            out += re2;
            break;
          }
          out += re2.substring(0, match.index);
          re2 = re2.substring(match.index + match[0].length);
          if (match[0][0] === "\\" && match[1]) {
            out += "\\" + String(Number(match[1]) + offset);
          } else {
            out += match[0];
            if (match[0] === "(") {
              numCaptures++;
            }
          }
        }
        return out;
      }).map((re2) => `(${re2})`).join(joinWith);
    }
    const MATCH_NOTHING_RE = /\b\B/;
    const IDENT_RE = "[a-zA-Z]\\w*";
    const UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*";
    const NUMBER_RE = "\\b\\d+(\\.\\d+)?";
    const C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
    const BINARY_NUMBER_RE = "\\b(0b[01]+)";
    const RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
    const SHEBANG = (opts = {}) => {
      const beginShebang = /^#![ ]*\//;
      if (opts.binary) {
        opts.begin = concat(
          beginShebang,
          /.*\b/,
          opts.binary,
          /\b.*/
        );
      }
      return inherit$1({
        scope: "meta",
        begin: beginShebang,
        end: /$/,
        relevance: 0,
        /** @type {ModeCallback} */
        "on:begin": (m, resp) => {
          if (m.index !== 0)
            resp.ignoreMatch();
        }
      }, opts);
    };
    const BACKSLASH_ESCAPE = {
      begin: "\\\\[\\s\\S]",
      relevance: 0
    };
    const APOS_STRING_MODE = {
      scope: "string",
      begin: "'",
      end: "'",
      illegal: "\\n",
      contains: [BACKSLASH_ESCAPE]
    };
    const QUOTE_STRING_MODE = {
      scope: "string",
      begin: '"',
      end: '"',
      illegal: "\\n",
      contains: [BACKSLASH_ESCAPE]
    };
    const PHRASAL_WORDS_MODE = {
      begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
    };
    const COMMENT = function(begin, end, modeOptions = {}) {
      const mode = inherit$1(
        {
          scope: "comment",
          begin,
          end,
          contains: []
        },
        modeOptions
      );
      mode.contains.push({
        scope: "doctag",
        // hack to avoid the space from being included. the space is necessary to
        // match here to prevent the plain text rule below from gobbling up doctags
        begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
        end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
        excludeBegin: true,
        relevance: 0
      });
      const ENGLISH_WORD = either(
        // list of common 1 and 2 letter words in English
        "I",
        "a",
        "is",
        "so",
        "us",
        "to",
        "at",
        "if",
        "in",
        "it",
        "on",
        // note: this is not an exhaustive list of contractions, just popular ones
        /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
        // contractions - can't we'd they're let's, etc
        /[A-Za-z]+[-][a-z]+/,
        // `no-way`, etc.
        /[A-Za-z][a-z]{2,}/
        // allow capitalized words at beginning of sentences
      );
      mode.contains.push(
        {
          // TODO: how to include ", (, ) without breaking grammars that use these for
          // comment delimiters?
          // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
          // ---
          // this tries to find sequences of 3 english words in a row (without any
          // "programming" type syntax) this gives us a strong signal that we've
          // TRULY found a comment - vs perhaps scanning with the wrong language.
          // It's possible to find something that LOOKS like the start of the
          // comment - but then if there is no readable text - good chance it is a
          // false match and not a comment.
          //
          // for a visual example please see:
          // https://github.com/highlightjs/highlight.js/issues/2827
          begin: concat(
            /[ ]+/,
            // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
            "(",
            ENGLISH_WORD,
            /[.]?[:]?([.][ ]|[ ])/,
            "){3}"
          )
          // look for 3 words in a row
        }
      );
      return mode;
    };
    const C_LINE_COMMENT_MODE = COMMENT("//", "$");
    const C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/");
    const HASH_COMMENT_MODE = COMMENT("#", "$");
    const NUMBER_MODE = {
      scope: "number",
      begin: NUMBER_RE,
      relevance: 0
    };
    const C_NUMBER_MODE = {
      scope: "number",
      begin: C_NUMBER_RE,
      relevance: 0
    };
    const BINARY_NUMBER_MODE = {
      scope: "number",
      begin: BINARY_NUMBER_RE,
      relevance: 0
    };
    const REGEXP_MODE = {
      scope: "regexp",
      begin: /\/(?=[^/\n]*\/)/,
      end: /\/[gimuy]*/,
      contains: [
        BACKSLASH_ESCAPE,
        {
          begin: /\[/,
          end: /\]/,
          relevance: 0,
          contains: [BACKSLASH_ESCAPE]
        }
      ]
    };
    const TITLE_MODE = {
      scope: "title",
      begin: IDENT_RE,
      relevance: 0
    };
    const UNDERSCORE_TITLE_MODE = {
      scope: "title",
      begin: UNDERSCORE_IDENT_RE,
      relevance: 0
    };
    const METHOD_GUARD = {
      // excludes method names from keyword processing
      begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
      relevance: 0
    };
    const END_SAME_AS_BEGIN = function(mode) {
      return Object.assign(
        mode,
        {
          /** @type {ModeCallback} */
          "on:begin": (m, resp) => {
            resp.data._beginMatch = m[1];
          },
          /** @type {ModeCallback} */
          "on:end": (m, resp) => {
            if (resp.data._beginMatch !== m[1])
              resp.ignoreMatch();
          }
        }
      );
    };
    var MODES = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      APOS_STRING_MODE,
      BACKSLASH_ESCAPE,
      BINARY_NUMBER_MODE,
      BINARY_NUMBER_RE,
      COMMENT,
      C_BLOCK_COMMENT_MODE,
      C_LINE_COMMENT_MODE,
      C_NUMBER_MODE,
      C_NUMBER_RE,
      END_SAME_AS_BEGIN,
      HASH_COMMENT_MODE,
      IDENT_RE,
      MATCH_NOTHING_RE,
      METHOD_GUARD,
      NUMBER_MODE,
      NUMBER_RE,
      PHRASAL_WORDS_MODE,
      QUOTE_STRING_MODE,
      REGEXP_MODE,
      RE_STARTERS_RE,
      SHEBANG,
      TITLE_MODE,
      UNDERSCORE_IDENT_RE,
      UNDERSCORE_TITLE_MODE
    });
    function skipIfHasPrecedingDot(match, response) {
      const before = match.input[match.index - 1];
      if (before === ".") {
        response.ignoreMatch();
      }
    }
    function scopeClassName(mode, _parent) {
      if (mode.className !== void 0) {
        mode.scope = mode.className;
        delete mode.className;
      }
    }
    function beginKeywords(mode, parent) {
      if (!parent)
        return;
      if (!mode.beginKeywords)
        return;
      mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
      mode.__beforeBegin = skipIfHasPrecedingDot;
      mode.keywords = mode.keywords || mode.beginKeywords;
      delete mode.beginKeywords;
      if (mode.relevance === void 0)
        mode.relevance = 0;
    }
    function compileIllegal(mode, _parent) {
      if (!Array.isArray(mode.illegal))
        return;
      mode.illegal = either(...mode.illegal);
    }
    function compileMatch(mode, _parent) {
      if (!mode.match)
        return;
      if (mode.begin || mode.end)
        throw new Error("begin & end are not supported with match");
      mode.begin = mode.match;
      delete mode.match;
    }
    function compileRelevance(mode, _parent) {
      if (mode.relevance === void 0)
        mode.relevance = 1;
    }
    const beforeMatchExt = (mode, parent) => {
      if (!mode.beforeMatch)
        return;
      if (mode.starts)
        throw new Error("beforeMatch cannot be used with starts");
      const originalMode = Object.assign({}, mode);
      Object.keys(mode).forEach((key) => {
        delete mode[key];
      });
      mode.keywords = originalMode.keywords;
      mode.begin = concat(originalMode.beforeMatch, lookahead(originalMode.begin));
      mode.starts = {
        relevance: 0,
        contains: [
          Object.assign(originalMode, { endsParent: true })
        ]
      };
      mode.relevance = 0;
      delete originalMode.beforeMatch;
    };
    const COMMON_KEYWORDS = [
      "of",
      "and",
      "for",
      "in",
      "not",
      "or",
      "if",
      "then",
      "parent",
      // common variable name
      "list",
      // common variable name
      "value"
      // common variable name
    ];
    const DEFAULT_KEYWORD_SCOPE = "keyword";
    function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {
      const compiledKeywords = /* @__PURE__ */ Object.create(null);
      if (typeof rawKeywords === "string") {
        compileList2(scopeName, rawKeywords.split(" "));
      } else if (Array.isArray(rawKeywords)) {
        compileList2(scopeName, rawKeywords);
      } else {
        Object.keys(rawKeywords).forEach(function(scopeName2) {
          Object.assign(
            compiledKeywords,
            compileKeywords(rawKeywords[scopeName2], caseInsensitive, scopeName2)
          );
        });
      }
      return compiledKeywords;
      function compileList2(scopeName2, keywordList) {
        if (caseInsensitive) {
          keywordList = keywordList.map((x2) => x2.toLowerCase());
        }
        keywordList.forEach(function(keyword2) {
          const pair = keyword2.split("|");
          compiledKeywords[pair[0]] = [scopeName2, scoreForKeyword(pair[0], pair[1])];
        });
      }
    }
    function scoreForKeyword(keyword2, providedScore) {
      if (providedScore) {
        return Number(providedScore);
      }
      return commonKeyword(keyword2) ? 0 : 1;
    }
    function commonKeyword(keyword2) {
      return COMMON_KEYWORDS.includes(keyword2.toLowerCase());
    }
    const seenDeprecations = {};
    const error$m = (message) => {
      console.error(message);
    };
    const warn = (message, ...args) => {
      console.log(`WARN: ${message}`, ...args);
    };
    const deprecated = (version2, message) => {
      if (seenDeprecations[`${version2}/${message}`])
        return;
      console.log(`Deprecated as of ${version2}. ${message}`);
      seenDeprecations[`${version2}/${message}`] = true;
    };
    const MultiClassError = new Error();
    function remapScopeNames(mode, regexes, { key }) {
      let offset = 0;
      const scopeNames = mode[key];
      const emit2 = {};
      const positions = {};
      for (let i2 = 1; i2 <= regexes.length; i2++) {
        positions[i2 + offset] = scopeNames[i2];
        emit2[i2 + offset] = true;
        offset += countMatchGroups(regexes[i2 - 1]);
      }
      mode[key] = positions;
      mode[key]._emit = emit2;
      mode[key]._multi = true;
    }
    function beginMultiClass(mode) {
      if (!Array.isArray(mode.begin))
        return;
      if (mode.skip || mode.excludeBegin || mode.returnBegin) {
        error$m("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
        throw MultiClassError;
      }
      if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
        error$m("beginScope must be object");
        throw MultiClassError;
      }
      remapScopeNames(mode, mode.begin, { key: "beginScope" });
      mode.begin = _rewriteBackreferences(mode.begin, { joinWith: "" });
    }
    function endMultiClass(mode) {
      if (!Array.isArray(mode.end))
        return;
      if (mode.skip || mode.excludeEnd || mode.returnEnd) {
        error$m("skip, excludeEnd, returnEnd not compatible with endScope: {}");
        throw MultiClassError;
      }
      if (typeof mode.endScope !== "object" || mode.endScope === null) {
        error$m("endScope must be object");
        throw MultiClassError;
      }
      remapScopeNames(mode, mode.end, { key: "endScope" });
      mode.end = _rewriteBackreferences(mode.end, { joinWith: "" });
    }
    function scopeSugar(mode) {
      if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
        mode.beginScope = mode.scope;
        delete mode.scope;
      }
    }
    function MultiClass(mode) {
      scopeSugar(mode);
      if (typeof mode.beginScope === "string") {
        mode.beginScope = { _wrap: mode.beginScope };
      }
      if (typeof mode.endScope === "string") {
        mode.endScope = { _wrap: mode.endScope };
      }
      beginMultiClass(mode);
      endMultiClass(mode);
    }
    function compileLanguage(language) {
      function langRe(value, global2) {
        return new RegExp(
          source(value),
          "m" + (language.case_insensitive ? "i" : "") + (language.unicodeRegex ? "u" : "") + (global2 ? "g" : "")
        );
      }
      class MultiRegex {
        constructor() {
          this.matchIndexes = {};
          this.regexes = [];
          this.matchAt = 1;
          this.position = 0;
        }
        // @ts-ignore
        addRule(re2, opts) {
          opts.position = this.position++;
          this.matchIndexes[this.matchAt] = opts;
          this.regexes.push([opts, re2]);
          this.matchAt += countMatchGroups(re2) + 1;
        }
        compile() {
          if (this.regexes.length === 0) {
            this.exec = () => null;
          }
          const terminators = this.regexes.map((el2) => el2[1]);
          this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: "|" }), true);
          this.lastIndex = 0;
        }
        /** @param {string} s */
        exec(s) {
          this.matcherRe.lastIndex = this.lastIndex;
          const match = this.matcherRe.exec(s);
          if (!match) {
            return null;
          }
          const i2 = match.findIndex((el2, i3) => i3 > 0 && el2 !== void 0);
          const matchData = this.matchIndexes[i2];
          match.splice(0, i2);
          return Object.assign(match, matchData);
        }
      }
      class ResumableMultiRegex {
        constructor() {
          this.rules = [];
          this.multiRegexes = [];
          this.count = 0;
          this.lastIndex = 0;
          this.regexIndex = 0;
        }
        // @ts-ignore
        getMatcher(index) {
          if (this.multiRegexes[index])
            return this.multiRegexes[index];
          const matcher = new MultiRegex();
          this.rules.slice(index).forEach(([re2, opts]) => matcher.addRule(re2, opts));
          matcher.compile();
          this.multiRegexes[index] = matcher;
          return matcher;
        }
        resumingScanAtSamePosition() {
          return this.regexIndex !== 0;
        }
        considerAll() {
          this.regexIndex = 0;
        }
        // @ts-ignore
        addRule(re2, opts) {
          this.rules.push([re2, opts]);
          if (opts.type === "begin")
            this.count++;
        }
        /** @param {string} s */
        exec(s) {
          const m = this.getMatcher(this.regexIndex);
          m.lastIndex = this.lastIndex;
          let result = m.exec(s);
          if (this.resumingScanAtSamePosition()) {
            if (result && result.index === this.lastIndex)
              ;
            else {
              const m2 = this.getMatcher(0);
              m2.lastIndex = this.lastIndex + 1;
              result = m2.exec(s);
            }
          }
          if (result) {
            this.regexIndex += result.position + 1;
            if (this.regexIndex === this.count) {
              this.considerAll();
            }
          }
          return result;
        }
      }
      function buildModeRegex(mode) {
        const mm = new ResumableMultiRegex();
        mode.contains.forEach((term) => mm.addRule(term.begin, { rule: term, type: "begin" }));
        if (mode.terminatorEnd) {
          mm.addRule(mode.terminatorEnd, { type: "end" });
        }
        if (mode.illegal) {
          mm.addRule(mode.illegal, { type: "illegal" });
        }
        return mm;
      }
      function compileMode(mode, parent) {
        const cmode = (
          /** @type CompiledMode */
          mode
        );
        if (mode.isCompiled)
          return cmode;
        [
          scopeClassName,
          // do this early so compiler extensions generally don't have to worry about
          // the distinction between match/begin
          compileMatch,
          MultiClass,
          beforeMatchExt
        ].forEach((ext) => ext(mode, parent));
        language.compilerExtensions.forEach((ext) => ext(mode, parent));
        mode.__beforeBegin = null;
        [
          beginKeywords,
          // do this later so compiler extensions that come earlier have access to the
          // raw array if they wanted to perhaps manipulate it, etc.
          compileIllegal,
          // default to 1 relevance if not specified
          compileRelevance
        ].forEach((ext) => ext(mode, parent));
        mode.isCompiled = true;
        let keywordPattern = null;
        if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
          mode.keywords = Object.assign({}, mode.keywords);
          keywordPattern = mode.keywords.$pattern;
          delete mode.keywords.$pattern;
        }
        keywordPattern = keywordPattern || /\w+/;
        if (mode.keywords) {
          mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
        }
        cmode.keywordPatternRe = langRe(keywordPattern, true);
        if (parent) {
          if (!mode.begin)
            mode.begin = /\B|\b/;
          cmode.beginRe = langRe(cmode.begin);
          if (!mode.end && !mode.endsWithParent)
            mode.end = /\B|\b/;
          if (mode.end)
            cmode.endRe = langRe(cmode.end);
          cmode.terminatorEnd = source(cmode.end) || "";
          if (mode.endsWithParent && parent.terminatorEnd) {
            cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
          }
        }
        if (mode.illegal)
          cmode.illegalRe = langRe(
            /** @type {RegExp | string} */
            mode.illegal
          );
        if (!mode.contains)
          mode.contains = [];
        mode.contains = [].concat(...mode.contains.map(function(c) {
          return expandOrCloneMode(c === "self" ? mode : c);
        }));
        mode.contains.forEach(function(c) {
          compileMode(
            /** @type Mode */
            c,
            cmode
          );
        });
        if (mode.starts) {
          compileMode(mode.starts, parent);
        }
        cmode.matcher = buildModeRegex(cmode);
        return cmode;
      }
      if (!language.compilerExtensions)
        language.compilerExtensions = [];
      if (language.contains && language.contains.includes("self")) {
        throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
      }
      language.classNameAliases = inherit$1(language.classNameAliases || {});
      return compileMode(
        /** @type Mode */
        language
      );
    }
    function dependencyOnParent(mode) {
      if (!mode)
        return false;
      return mode.endsWithParent || dependencyOnParent(mode.starts);
    }
    function expandOrCloneMode(mode) {
      if (mode.variants && !mode.cachedVariants) {
        mode.cachedVariants = mode.variants.map(function(variant) {
          return inherit$1(mode, { variants: null }, variant);
        });
      }
      if (mode.cachedVariants) {
        return mode.cachedVariants;
      }
      if (dependencyOnParent(mode)) {
        return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });
      }
      if (Object.isFrozen(mode)) {
        return inherit$1(mode);
      }
      return mode;
    }
    var version = "11.10.0";
    class HTMLInjectionError extends Error {
      constructor(reason, html) {
        super(reason);
        this.name = "HTMLInjectionError";
        this.html = html;
      }
    }
    const escape$1 = escapeHTML;
    const inherit = inherit$1;
    const NO_MATCH = Symbol("nomatch");
    const MAX_KEYWORD_HITS = 7;
    const HLJS = function(hljs) {
      const languages = /* @__PURE__ */ Object.create(null);
      const aliases2 = /* @__PURE__ */ Object.create(null);
      const plugins2 = [];
      let SAFE_MODE = true;
      const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
      const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: "Plain text", contains: [] };
      let options = {
        ignoreUnescapedHTML: false,
        throwUnescapedHTML: false,
        noHighlightRe: /^(no-?highlight)$/i,
        languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
        classPrefix: "hljs-",
        cssSelector: "pre code",
        languages: null,
        // beta configuration options, subject to change, welcome to discuss
        // https://github.com/highlightjs/highlight.js/issues/1086
        __emitter: TokenTreeEmitter
      };
      function shouldNotHighlight(languageName) {
        return options.noHighlightRe.test(languageName);
      }
      function blockLanguage(block2) {
        let classes = block2.className + " ";
        classes += block2.parentNode ? block2.parentNode.className : "";
        const match = options.languageDetectRe.exec(classes);
        if (match) {
          const language = getLanguage(match[1]);
          if (!language) {
            warn(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
            warn("Falling back to no-highlight mode for this block.", block2);
          }
          return language ? match[1] : "no-highlight";
        }
        return classes.split(/\s+/).find((_class2) => shouldNotHighlight(_class2) || getLanguage(_class2));
      }
      function highlight2(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
        let code2 = "";
        let languageName = "";
        if (typeof optionsOrCode === "object") {
          code2 = codeOrLanguageName;
          ignoreIllegals = optionsOrCode.ignoreIllegals;
          languageName = optionsOrCode.language;
        } else {
          deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
          deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
          languageName = codeOrLanguageName;
          code2 = optionsOrCode;
        }
        if (ignoreIllegals === void 0) {
          ignoreIllegals = true;
        }
        const context = {
          code: code2,
          language: languageName
        };
        fire("before:highlight", context);
        const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
        result.code = context.code;
        fire("after:highlight", result);
        return result;
      }
      function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
        const keywordHits = /* @__PURE__ */ Object.create(null);
        function keywordData(mode, matchText) {
          return mode.keywords[matchText];
        }
        function processKeywords() {
          if (!top2.keywords) {
            emitter.addText(modeBuffer);
            return;
          }
          let lastIndex = 0;
          top2.keywordPatternRe.lastIndex = 0;
          let match = top2.keywordPatternRe.exec(modeBuffer);
          let buf = "";
          while (match) {
            buf += modeBuffer.substring(lastIndex, match.index);
            const word = language.case_insensitive ? match[0].toLowerCase() : match[0];
            const data = keywordData(top2, word);
            if (data) {
              const [kind, keywordRelevance] = data;
              emitter.addText(buf);
              buf = "";
              keywordHits[word] = (keywordHits[word] || 0) + 1;
              if (keywordHits[word] <= MAX_KEYWORD_HITS)
                relevance += keywordRelevance;
              if (kind.startsWith("_")) {
                buf += match[0];
              } else {
                const cssClass = language.classNameAliases[kind] || kind;
                emitKeyword(match[0], cssClass);
              }
            } else {
              buf += match[0];
            }
            lastIndex = top2.keywordPatternRe.lastIndex;
            match = top2.keywordPatternRe.exec(modeBuffer);
          }
          buf += modeBuffer.substring(lastIndex);
          emitter.addText(buf);
        }
        function processSubLanguage() {
          if (modeBuffer === "")
            return;
          let result2 = null;
          if (typeof top2.subLanguage === "string") {
            if (!languages[top2.subLanguage]) {
              emitter.addText(modeBuffer);
              return;
            }
            result2 = _highlight(top2.subLanguage, modeBuffer, true, continuations[top2.subLanguage]);
            continuations[top2.subLanguage] = /** @type {CompiledMode} */
            result2._top;
          } else {
            result2 = highlightAuto(modeBuffer, top2.subLanguage.length ? top2.subLanguage : null);
          }
          if (top2.relevance > 0) {
            relevance += result2.relevance;
          }
          emitter.__addSublanguage(result2._emitter, result2.language);
        }
        function processBuffer() {
          if (top2.subLanguage != null) {
            processSubLanguage();
          } else {
            processKeywords();
          }
          modeBuffer = "";
        }
        function emitKeyword(keyword2, scope2) {
          if (keyword2 === "")
            return;
          emitter.startScope(scope2);
          emitter.addText(keyword2);
          emitter.endScope();
        }
        function emitMultiClass(scope2, match) {
          let i2 = 1;
          const max = match.length - 1;
          while (i2 <= max) {
            if (!scope2._emit[i2]) {
              i2++;
              continue;
            }
            const klass = language.classNameAliases[scope2[i2]] || scope2[i2];
            const text2 = match[i2];
            if (klass) {
              emitKeyword(text2, klass);
            } else {
              modeBuffer = text2;
              processKeywords();
              modeBuffer = "";
            }
            i2++;
          }
        }
        function startNewMode(mode, match) {
          if (mode.scope && typeof mode.scope === "string") {
            emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);
          }
          if (mode.beginScope) {
            if (mode.beginScope._wrap) {
              emitKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
              modeBuffer = "";
            } else if (mode.beginScope._multi) {
              emitMultiClass(mode.beginScope, match);
              modeBuffer = "";
            }
          }
          top2 = Object.create(mode, { parent: { value: top2 } });
          return top2;
        }
        function endOfMode(mode, match, matchPlusRemainder) {
          let matched = startsWith(mode.endRe, matchPlusRemainder);
          if (matched) {
            if (mode["on:end"]) {
              const resp = new Response(mode);
              mode["on:end"](match, resp);
              if (resp.isMatchIgnored)
                matched = false;
            }
            if (matched) {
              while (mode.endsParent && mode.parent) {
                mode = mode.parent;
              }
              return mode;
            }
          }
          if (mode.endsWithParent) {
            return endOfMode(mode.parent, match, matchPlusRemainder);
          }
        }
        function doIgnore(lexeme) {
          if (top2.matcher.regexIndex === 0) {
            modeBuffer += lexeme[0];
            return 1;
          } else {
            resumeScanAtSamePosition = true;
            return 0;
          }
        }
        function doBeginMatch(match) {
          const lexeme = match[0];
          const newMode = match.rule;
          const resp = new Response(newMode);
          const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
          for (const cb of beforeCallbacks) {
            if (!cb)
              continue;
            cb(match, resp);
            if (resp.isMatchIgnored)
              return doIgnore(lexeme);
          }
          if (newMode.skip) {
            modeBuffer += lexeme;
          } else {
            if (newMode.excludeBegin) {
              modeBuffer += lexeme;
            }
            processBuffer();
            if (!newMode.returnBegin && !newMode.excludeBegin) {
              modeBuffer = lexeme;
            }
          }
          startNewMode(newMode, match);
          return newMode.returnBegin ? 0 : lexeme.length;
        }
        function doEndMatch(match) {
          const lexeme = match[0];
          const matchPlusRemainder = codeToHighlight.substring(match.index);
          const endMode = endOfMode(top2, match, matchPlusRemainder);
          if (!endMode) {
            return NO_MATCH;
          }
          const origin = top2;
          if (top2.endScope && top2.endScope._wrap) {
            processBuffer();
            emitKeyword(lexeme, top2.endScope._wrap);
          } else if (top2.endScope && top2.endScope._multi) {
            processBuffer();
            emitMultiClass(top2.endScope, match);
          } else if (origin.skip) {
            modeBuffer += lexeme;
          } else {
            if (!(origin.returnEnd || origin.excludeEnd)) {
              modeBuffer += lexeme;
            }
            processBuffer();
            if (origin.excludeEnd) {
              modeBuffer = lexeme;
            }
          }
          do {
            if (top2.scope) {
              emitter.closeNode();
            }
            if (!top2.skip && !top2.subLanguage) {
              relevance += top2.relevance;
            }
            top2 = top2.parent;
          } while (top2 !== endMode.parent);
          if (endMode.starts) {
            startNewMode(endMode.starts, match);
          }
          return origin.returnEnd ? 0 : lexeme.length;
        }
        function processContinuations() {
          const list2 = [];
          for (let current2 = top2; current2 !== language; current2 = current2.parent) {
            if (current2.scope) {
              list2.unshift(current2.scope);
            }
          }
          list2.forEach((item) => emitter.openNode(item));
        }
        let lastMatch = {};
        function processLexeme(textBeforeMatch, match) {
          const lexeme = match && match[0];
          modeBuffer += textBeforeMatch;
          if (lexeme == null) {
            processBuffer();
            return 0;
          }
          if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
            modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
            if (!SAFE_MODE) {
              const err = new Error(`0 width match regex (${languageName})`);
              err.languageName = languageName;
              err.badRule = lastMatch.rule;
              throw err;
            }
            return 1;
          }
          lastMatch = match;
          if (match.type === "begin") {
            return doBeginMatch(match);
          } else if (match.type === "illegal" && !ignoreIllegals) {
            const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top2.scope || "<unnamed>") + '"');
            err.mode = top2;
            throw err;
          } else if (match.type === "end") {
            const processed = doEndMatch(match);
            if (processed !== NO_MATCH) {
              return processed;
            }
          }
          if (match.type === "illegal" && lexeme === "") {
            return 1;
          }
          if (iterations > 1e5 && iterations > match.index * 3) {
            const err = new Error("potential infinite loop, way more iterations than matches");
            throw err;
          }
          modeBuffer += lexeme;
          return lexeme.length;
        }
        const language = getLanguage(languageName);
        if (!language) {
          error$m(LANGUAGE_NOT_FOUND.replace("{}", languageName));
          throw new Error('Unknown language: "' + languageName + '"');
        }
        const md = compileLanguage(language);
        let result = "";
        let top2 = continuation || md;
        const continuations = {};
        const emitter = new options.__emitter(options);
        processContinuations();
        let modeBuffer = "";
        let relevance = 0;
        let index = 0;
        let iterations = 0;
        let resumeScanAtSamePosition = false;
        try {
          if (!language.__emitTokens) {
            top2.matcher.considerAll();
            for (; ; ) {
              iterations++;
              if (resumeScanAtSamePosition) {
                resumeScanAtSamePosition = false;
              } else {
                top2.matcher.considerAll();
              }
              top2.matcher.lastIndex = index;
              const match = top2.matcher.exec(codeToHighlight);
              if (!match)
                break;
              const beforeMatch = codeToHighlight.substring(index, match.index);
              const processedCount = processLexeme(beforeMatch, match);
              index = match.index + processedCount;
            }
            processLexeme(codeToHighlight.substring(index));
          } else {
            language.__emitTokens(codeToHighlight, emitter);
          }
          emitter.finalize();
          result = emitter.toHTML();
          return {
            language: languageName,
            value: result,
            relevance,
            illegal: false,
            _emitter: emitter,
            _top: top2
          };
        } catch (err) {
          if (err.message && err.message.includes("Illegal")) {
            return {
              language: languageName,
              value: escape$1(codeToHighlight),
              illegal: true,
              relevance: 0,
              _illegalBy: {
                message: err.message,
                index,
                context: codeToHighlight.slice(index - 100, index + 100),
                mode: err.mode,
                resultSoFar: result
              },
              _emitter: emitter
            };
          } else if (SAFE_MODE) {
            return {
              language: languageName,
              value: escape$1(codeToHighlight),
              illegal: false,
              relevance: 0,
              errorRaised: err,
              _emitter: emitter,
              _top: top2
            };
          } else {
            throw err;
          }
        }
      }
      function justTextHighlightResult(code2) {
        const result = {
          value: escape$1(code2),
          illegal: false,
          relevance: 0,
          _top: PLAINTEXT_LANGUAGE,
          _emitter: new options.__emitter(options)
        };
        result._emitter.addText(code2);
        return result;
      }
      function highlightAuto(code2, languageSubset) {
        languageSubset = languageSubset || options.languages || Object.keys(languages);
        const plaintext = justTextHighlightResult(code2);
        const results = languageSubset.filter(getLanguage).filter(autoDetection).map(
          (name) => _highlight(name, code2, false)
        );
        results.unshift(plaintext);
        const sorted = results.sort((a, b) => {
          if (a.relevance !== b.relevance)
            return b.relevance - a.relevance;
          if (a.language && b.language) {
            if (getLanguage(a.language).supersetOf === b.language) {
              return 1;
            } else if (getLanguage(b.language).supersetOf === a.language) {
              return -1;
            }
          }
          return 0;
        });
        const [best, secondBest] = sorted;
        const result = best;
        result.secondBest = secondBest;
        return result;
      }
      function updateClassName(element, currentLang, resultLang) {
        const language = currentLang && aliases2[currentLang] || resultLang;
        element.classList.add("hljs");
        element.classList.add(`language-${language}`);
      }
      function highlightElement(element) {
        let node = null;
        const language = blockLanguage(element);
        if (shouldNotHighlight(language))
          return;
        fire(
          "before:highlightElement",
          { el: element, language }
        );
        if (element.dataset.highlighted) {
          console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", element);
          return;
        }
        if (element.children.length > 0) {
          if (!options.ignoreUnescapedHTML) {
            console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
            console.warn("https://github.com/highlightjs/highlight.js/wiki/security");
            console.warn("The element with unescaped HTML:");
            console.warn(element);
          }
          if (options.throwUnescapedHTML) {
            const err = new HTMLInjectionError(
              "One of your code blocks includes unescaped HTML.",
              element.innerHTML
            );
            throw err;
          }
        }
        node = element;
        const text2 = node.textContent;
        const result = language ? highlight2(text2, { language, ignoreIllegals: true }) : highlightAuto(text2);
        element.innerHTML = result.value;
        element.dataset.highlighted = "yes";
        updateClassName(element, language, result.language);
        element.result = {
          language: result.language,
          // TODO: remove with version 11.0
          re: result.relevance,
          relevance: result.relevance
        };
        if (result.secondBest) {
          element.secondBest = {
            language: result.secondBest.language,
            relevance: result.secondBest.relevance
          };
        }
        fire("after:highlightElement", { el: element, result, text: text2 });
      }
      function configure(userOptions) {
        options = inherit(options, userOptions);
      }
      const initHighlighting = () => {
        highlightAll();
        deprecated("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
      };
      function initHighlightingOnLoad() {
        highlightAll();
        deprecated("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
      }
      let wantsHighlight = false;
      function highlightAll() {
        if (document.readyState === "loading") {
          wantsHighlight = true;
          return;
        }
        const blocks = document.querySelectorAll(options.cssSelector);
        blocks.forEach(highlightElement);
      }
      function boot() {
        if (wantsHighlight)
          highlightAll();
      }
      if (typeof window !== "undefined" && window.addEventListener) {
        window.addEventListener("DOMContentLoaded", boot, false);
      }
      function registerLanguage(languageName, languageDefinition) {
        let lang2 = null;
        try {
          lang2 = languageDefinition(hljs);
        } catch (error$12) {
          error$m("Language definition for '{}' could not be registered.".replace("{}", languageName));
          if (!SAFE_MODE) {
            throw error$12;
          } else {
            error$m(error$12);
          }
          lang2 = PLAINTEXT_LANGUAGE;
        }
        if (!lang2.name)
          lang2.name = languageName;
        languages[languageName] = lang2;
        lang2.rawDefinition = languageDefinition.bind(null, hljs);
        if (lang2.aliases) {
          registerAliases(lang2.aliases, { languageName });
        }
      }
      function unregisterLanguage(languageName) {
        delete languages[languageName];
        for (const alias of Object.keys(aliases2)) {
          if (aliases2[alias] === languageName) {
            delete aliases2[alias];
          }
        }
      }
      function listLanguages() {
        return Object.keys(languages);
      }
      function getLanguage(name) {
        name = (name || "").toLowerCase();
        return languages[name] || languages[aliases2[name]];
      }
      function registerAliases(aliasList, { languageName }) {
        if (typeof aliasList === "string") {
          aliasList = [aliasList];
        }
        aliasList.forEach((alias) => {
          aliases2[alias.toLowerCase()] = languageName;
        });
      }
      function autoDetection(name) {
        const lang2 = getLanguage(name);
        return lang2 && !lang2.disableAutodetect;
      }
      function upgradePluginAPI(plugin) {
        if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
          plugin["before:highlightElement"] = (data) => {
            plugin["before:highlightBlock"](
              Object.assign({ block: data.el }, data)
            );
          };
        }
        if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
          plugin["after:highlightElement"] = (data) => {
            plugin["after:highlightBlock"](
              Object.assign({ block: data.el }, data)
            );
          };
        }
      }
      function addPlugin(plugin) {
        upgradePluginAPI(plugin);
        plugins2.push(plugin);
      }
      function removePlugin(plugin) {
        const index = plugins2.indexOf(plugin);
        if (index !== -1) {
          plugins2.splice(index, 1);
        }
      }
      function fire(event, args) {
        const cb = event;
        plugins2.forEach(function(plugin) {
          if (plugin[cb]) {
            plugin[cb](args);
          }
        });
      }
      function deprecateHighlightBlock(el2) {
        deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
        deprecated("10.7.0", "Please use highlightElement now.");
        return highlightElement(el2);
      }
      Object.assign(hljs, {
        highlight: highlight2,
        highlightAuto,
        highlightAll,
        highlightElement,
        // TODO: Remove with v12 API
        highlightBlock: deprecateHighlightBlock,
        configure,
        initHighlighting,
        initHighlightingOnLoad,
        registerLanguage,
        unregisterLanguage,
        listLanguages,
        getLanguage,
        registerAliases,
        autoDetection,
        inherit,
        addPlugin,
        removePlugin
      });
      hljs.debugMode = function() {
        SAFE_MODE = false;
      };
      hljs.safeMode = function() {
        SAFE_MODE = true;
      };
      hljs.versionString = version;
      hljs.regex = {
        concat,
        lookahead,
        either,
        optional,
        anyNumberOfTimes
      };
      for (const key in MODES) {
        if (typeof MODES[key] === "object") {
          deepFreeze(MODES[key]);
        }
      }
      Object.assign(hljs, MODES);
      return hljs;
    };
    const highlight = HLJS({});
    highlight.newInstance = () => HLJS({});
    var core$4 = highlight;
    highlight.HighlightJS = highlight;
    highlight.default = highlight;
    const HighlightJS = /* @__PURE__ */ getDefaultExportFromCjs(core$4);
    var r = /* @__PURE__ */ defineComponent$1({ props: { code: { type: String, required: true }, language: { type: String, default: "" }, autodetect: { type: Boolean, default: true }, ignoreIllegals: { type: Boolean, default: true } }, setup: function(e) {
      var n = ref$1(e.language);
      watch(function() {
        return e.language;
      }, function(e2) {
        n.value = e2;
      });
      var r2 = computed(function() {
        return e.autodetect || !n.value;
      }), o2 = computed(function() {
        return !r2.value && !HighlightJS.getLanguage(n.value);
      });
      return { className: computed(function() {
        return o2.value ? "" : "hljs " + n.value;
      }), highlightedCode: computed(function() {
        var l;
        if (o2.value)
          return console.warn('The language "' + n.value + '" you specified could not be found.'), e.code.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
        if (r2.value) {
          var a = HighlightJS.highlightAuto(e.code);
          return n.value = null !== (l = a.language) && void 0 !== l ? l : "", a.value;
        }
        return (a = HighlightJS.highlight(e.code, { language: n.value, ignoreIllegals: e.ignoreIllegals })).value;
      }) };
    }, render: function() {
      return h("pre", {}, [h("code", { class: this.className, innerHTML: this.highlightedCode })]);
    } }), o = { install: function(e) {
      e.component("highlightjs", r);
    }, component: r };
    const makeVDialogProps = propsFactory({
      fullscreen: Boolean,
      retainFocus: {
        type: Boolean,
        default: true
      },
      scrollable: Boolean,
      ...makeVOverlayProps({
        origin: "center center",
        scrollStrategy: "block",
        transition: {
          component: VDialogTransition
        },
        zIndex: 2400
      })
    }, "VDialog");
    const VDialog = genericComponent()({
      name: "VDialog",
      props: makeVDialogProps(),
      emits: {
        "update:modelValue": (value) => true,
        afterLeave: () => true
      },
      setup(props, _ref) {
        let {
          emit: emit2,
          slots
        } = _ref;
        const isActive = useProxiedModel(props, "modelValue");
        const {
          scopeId
        } = useScopeId();
        const overlay = ref$1();
        function onFocusin(e) {
          var _a2, _b;
          const before = e.relatedTarget;
          const after = e.target;
          if (before !== after && ((_a2 = overlay.value) == null ? void 0 : _a2.contentEl) && // We're the topmost dialog
          ((_b = overlay.value) == null ? void 0 : _b.globalTop) && // It isn't the document or the dialog body
          ![document, overlay.value.contentEl].includes(after) && // It isn't inside the dialog body
          !overlay.value.contentEl.contains(after)) {
            const focusable = focusableChildren(overlay.value.contentEl);
            if (!focusable.length)
              return;
            const firstElement = focusable[0];
            const lastElement = focusable[focusable.length - 1];
            if (before === firstElement) {
              lastElement.focus();
            } else {
              firstElement.focus();
            }
          }
        }
        if (IN_BROWSER) {
          watch(() => isActive.value && props.retainFocus, (val) => {
            val ? document.addEventListener("focusin", onFocusin) : document.removeEventListener("focusin", onFocusin);
          }, {
            immediate: true
          });
        }
        function onAfterEnter() {
          var _a2;
          if (((_a2 = overlay.value) == null ? void 0 : _a2.contentEl) && !overlay.value.contentEl.contains(document.activeElement)) {
            overlay.value.contentEl.focus({
              preventScroll: true
            });
          }
        }
        function onAfterLeave() {
          emit2("afterLeave");
        }
        watch(isActive, async (val) => {
          var _a2;
          if (!val) {
            await nextTick();
            (_a2 = overlay.value.activatorEl) == null ? void 0 : _a2.focus({
              preventScroll: true
            });
          }
        });
        useRender(() => {
          const overlayProps = VOverlay.filterProps(props);
          const activatorProps = mergeProps({
            "aria-haspopup": "dialog",
            "aria-expanded": String(isActive.value)
          }, props.activatorProps);
          const contentProps = mergeProps({
            tabindex: -1
          }, props.contentProps);
          return createVNode(VOverlay, mergeProps({
            "ref": overlay,
            "class": ["v-dialog", {
              "v-dialog--fullscreen": props.fullscreen,
              "v-dialog--scrollable": props.scrollable
            }, props.class],
            "style": props.style
          }, overlayProps, {
            "modelValue": isActive.value,
            "onUpdate:modelValue": ($event) => isActive.value = $event,
            "aria-modal": "true",
            "activatorProps": activatorProps,
            "contentProps": contentProps,
            "role": "dialog",
            "onAfterEnter": onAfterEnter,
            "onAfterLeave": onAfterLeave
          }, scopeId), {
            activator: slots.activator,
            default: function() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return createVNode(VDefaultsProvider, {
                "root": "VDialog"
              }, {
                default: () => {
                  var _a2;
                  return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, ...args)];
                }
              });
            }
          });
        });
        return forwardRefs({}, overlay);
      }
    });
    const VTabsSymbol = Symbol.for("vuetify:v-tabs");
    const makeVTabProps = propsFactory({
      fixed: Boolean,
      sliderColor: String,
      hideSlider: Boolean,
      direction: {
        type: String,
        default: "horizontal"
      },
      ...omit$1(makeVBtnProps({
        selectedClass: "v-tab--selected",
        variant: "text"
      }), ["active", "block", "flat", "location", "position", "symbol"])
    }, "VTab");
    const VTab = genericComponent()({
      name: "VTab",
      props: makeVTabProps(),
      setup(props, _ref) {
        let {
          slots,
          attrs
        } = _ref;
        const {
          textColorClasses: sliderColorClasses,
          textColorStyles: sliderColorStyles
        } = useTextColor(props, "sliderColor");
        const rootEl = ref$1();
        const sliderEl = ref$1();
        const isHorizontal = computed(() => props.direction === "horizontal");
        const isSelected = computed(() => {
          var _a2, _b;
          return ((_b = (_a2 = rootEl.value) == null ? void 0 : _a2.group) == null ? void 0 : _b.isSelected.value) ?? false;
        });
        function updateSlider(_ref2) {
          var _a2, _b;
          let {
            value
          } = _ref2;
          if (value) {
            const prevEl = (_b = (_a2 = rootEl.value) == null ? void 0 : _a2.$el.parentElement) == null ? void 0 : _b.querySelector(".v-tab--selected .v-tab__slider");
            const nextEl = sliderEl.value;
            if (!prevEl || !nextEl)
              return;
            const color = getComputedStyle(prevEl).color;
            const prevBox = prevEl.getBoundingClientRect();
            const nextBox = nextEl.getBoundingClientRect();
            const xy = isHorizontal.value ? "x" : "y";
            const XY = isHorizontal.value ? "X" : "Y";
            const rightBottom = isHorizontal.value ? "right" : "bottom";
            const widthHeight = isHorizontal.value ? "width" : "height";
            const prevPos = prevBox[xy];
            const nextPos = nextBox[xy];
            const delta2 = prevPos > nextPos ? prevBox[rightBottom] - nextBox[rightBottom] : prevBox[xy] - nextBox[xy];
            const origin = Math.sign(delta2) > 0 ? isHorizontal.value ? "right" : "bottom" : Math.sign(delta2) < 0 ? isHorizontal.value ? "left" : "top" : "center";
            const size2 = Math.abs(delta2) + (Math.sign(delta2) < 0 ? prevBox[widthHeight] : nextBox[widthHeight]);
            const scale = size2 / Math.max(prevBox[widthHeight], nextBox[widthHeight]) || 0;
            const initialScale = prevBox[widthHeight] / nextBox[widthHeight] || 0;
            const sigma2 = 1.5;
            animate(nextEl, {
              backgroundColor: [color, "currentcolor"],
              transform: [`translate${XY}(${delta2}px) scale${XY}(${initialScale})`, `translate${XY}(${delta2 / sigma2}px) scale${XY}(${(scale - 1) / sigma2 + 1})`, "none"],
              transformOrigin: Array(3).fill(origin)
            }, {
              duration: 225,
              easing: standardEasing
            });
          }
        }
        useRender(() => {
          const btnProps = VBtn.filterProps(props);
          return createVNode(VBtn, mergeProps({
            "symbol": VTabsSymbol,
            "ref": rootEl,
            "class": ["v-tab", props.class],
            "style": props.style,
            "tabindex": isSelected.value ? 0 : -1,
            "role": "tab",
            "aria-selected": String(isSelected.value),
            "active": false
          }, btnProps, attrs, {
            "block": props.fixed,
            "maxWidth": props.fixed ? 300 : void 0,
            "onGroup:selected": updateSlider
          }), {
            ...slots,
            default: () => {
              var _a2;
              return createVNode(Fragment, null, [((_a2 = slots.default) == null ? void 0 : _a2.call(slots)) ?? props.text, !props.hideSlider && createVNode("div", {
                "ref": sliderEl,
                "class": ["v-tab__slider", sliderColorClasses.value],
                "style": sliderColorStyles.value
              }, null)]);
            }
          });
        });
        return forwardRefs({}, rootEl);
      }
    });
    const handleGesture = (wrapper) => {
      const {
        touchstartX,
        touchendX,
        touchstartY,
        touchendY
      } = wrapper;
      const dirRatio = 0.5;
      const minDistance = 16;
      wrapper.offsetX = touchendX - touchstartX;
      wrapper.offsetY = touchendY - touchstartY;
      if (Math.abs(wrapper.offsetY) < dirRatio * Math.abs(wrapper.offsetX)) {
        wrapper.left && touchendX < touchstartX - minDistance && wrapper.left(wrapper);
        wrapper.right && touchendX > touchstartX + minDistance && wrapper.right(wrapper);
      }
      if (Math.abs(wrapper.offsetX) < dirRatio * Math.abs(wrapper.offsetY)) {
        wrapper.up && touchendY < touchstartY - minDistance && wrapper.up(wrapper);
        wrapper.down && touchendY > touchstartY + minDistance && wrapper.down(wrapper);
      }
    };
    function touchstart(event, wrapper) {
      var _a2;
      const touch = event.changedTouches[0];
      wrapper.touchstartX = touch.clientX;
      wrapper.touchstartY = touch.clientY;
      (_a2 = wrapper.start) == null ? void 0 : _a2.call(wrapper, {
        originalEvent: event,
        ...wrapper
      });
    }
    function touchend(event, wrapper) {
      var _a2;
      const touch = event.changedTouches[0];
      wrapper.touchendX = touch.clientX;
      wrapper.touchendY = touch.clientY;
      (_a2 = wrapper.end) == null ? void 0 : _a2.call(wrapper, {
        originalEvent: event,
        ...wrapper
      });
      handleGesture(wrapper);
    }
    function touchmove(event, wrapper) {
      var _a2;
      const touch = event.changedTouches[0];
      wrapper.touchmoveX = touch.clientX;
      wrapper.touchmoveY = touch.clientY;
      (_a2 = wrapper.move) == null ? void 0 : _a2.call(wrapper, {
        originalEvent: event,
        ...wrapper
      });
    }
    function createHandlers() {
      let value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const wrapper = {
        touchstartX: 0,
        touchstartY: 0,
        touchendX: 0,
        touchendY: 0,
        touchmoveX: 0,
        touchmoveY: 0,
        offsetX: 0,
        offsetY: 0,
        left: value.left,
        right: value.right,
        up: value.up,
        down: value.down,
        start: value.start,
        move: value.move,
        end: value.end
      };
      return {
        touchstart: (e) => touchstart(e, wrapper),
        touchend: (e) => touchend(e, wrapper),
        touchmove: (e) => touchmove(e, wrapper)
      };
    }
    function mounted(el2, binding) {
      var _a2;
      const value = binding.value;
      const target2 = (value == null ? void 0 : value.parent) ? el2.parentElement : el2;
      const options = (value == null ? void 0 : value.options) ?? {
        passive: true
      };
      const uid2 = (_a2 = binding.instance) == null ? void 0 : _a2.$.uid;
      if (!target2 || !uid2)
        return;
      const handlers2 = createHandlers(binding.value);
      target2._touchHandlers = target2._touchHandlers ?? /* @__PURE__ */ Object.create(null);
      target2._touchHandlers[uid2] = handlers2;
      keys(handlers2).forEach((eventName2) => {
        target2.addEventListener(eventName2, handlers2[eventName2], options);
      });
    }
    function unmounted(el2, binding) {
      var _a2, _b;
      const target2 = ((_a2 = binding.value) == null ? void 0 : _a2.parent) ? el2.parentElement : el2;
      const uid2 = (_b = binding.instance) == null ? void 0 : _b.$.uid;
      if (!(target2 == null ? void 0 : target2._touchHandlers) || !uid2)
        return;
      const handlers2 = target2._touchHandlers[uid2];
      keys(handlers2).forEach((eventName2) => {
        target2.removeEventListener(eventName2, handlers2[eventName2]);
      });
      delete target2._touchHandlers[uid2];
    }
    const Touch = {
      mounted,
      unmounted
    };
    const Touch$1 = Touch;
    const VWindowSymbol = Symbol.for("vuetify:v-window");
    const VWindowGroupSymbol = Symbol.for("vuetify:v-window-group");
    const makeVWindowProps = propsFactory({
      continuous: Boolean,
      nextIcon: {
        type: [Boolean, String, Function, Object],
        default: "$next"
      },
      prevIcon: {
        type: [Boolean, String, Function, Object],
        default: "$prev"
      },
      reverse: Boolean,
      showArrows: {
        type: [Boolean, String],
        validator: (v) => typeof v === "boolean" || v === "hover"
      },
      touch: {
        type: [Object, Boolean],
        default: void 0
      },
      direction: {
        type: String,
        default: "horizontal"
      },
      modelValue: null,
      disabled: Boolean,
      selectedClass: {
        type: String,
        default: "v-window-item--active"
      },
      // TODO: mandatory should probably not be exposed but do this for now
      mandatory: {
        type: [Boolean, String],
        default: "force"
      },
      ...makeComponentProps(),
      ...makeTagProps(),
      ...makeThemeProps()
    }, "VWindow");
    const VWindow = genericComponent()({
      name: "VWindow",
      directives: {
        Touch
      },
      props: makeVWindowProps(),
      emits: {
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          themeClasses
        } = provideTheme(props);
        const {
          isRtl
        } = useRtl();
        const {
          t
        } = useLocale();
        const group = useGroup(props, VWindowGroupSymbol);
        const rootRef = ref$1();
        const isRtlReverse = computed(() => isRtl.value ? !props.reverse : props.reverse);
        const isReversed = shallowRef(false);
        const transition = computed(() => {
          const axis = props.direction === "vertical" ? "y" : "x";
          const reverse = isRtlReverse.value ? !isReversed.value : isReversed.value;
          const direction = reverse ? "-reverse" : "";
          return `v-window-${axis}${direction}-transition`;
        });
        const transitionCount = shallowRef(0);
        const transitionHeight = ref$1(void 0);
        const activeIndex = computed(() => {
          return group.items.value.findIndex((item) => group.selected.value.includes(item.id));
        });
        watch(activeIndex, (newVal, oldVal) => {
          const itemsLength = group.items.value.length;
          const lastIndex = itemsLength - 1;
          if (itemsLength <= 2) {
            isReversed.value = newVal < oldVal;
          } else if (newVal === lastIndex && oldVal === 0) {
            isReversed.value = true;
          } else if (newVal === 0 && oldVal === lastIndex) {
            isReversed.value = false;
          } else {
            isReversed.value = newVal < oldVal;
          }
        });
        provide(VWindowSymbol, {
          transition,
          isReversed,
          transitionCount,
          transitionHeight,
          rootRef
        });
        const canMoveBack = computed(() => props.continuous || activeIndex.value !== 0);
        const canMoveForward = computed(() => props.continuous || activeIndex.value !== group.items.value.length - 1);
        function prev() {
          canMoveBack.value && group.prev();
        }
        function next2() {
          canMoveForward.value && group.next();
        }
        const arrows = computed(() => {
          const arrows2 = [];
          const prevProps = {
            icon: isRtl.value ? props.nextIcon : props.prevIcon,
            class: `v-window__${isRtlReverse.value ? "right" : "left"}`,
            onClick: group.prev,
            "aria-label": t("$vuetify.carousel.prev")
          };
          arrows2.push(canMoveBack.value ? slots.prev ? slots.prev({
            props: prevProps
          }) : createVNode(VBtn, prevProps, null) : createVNode("div", null, null));
          const nextProps = {
            icon: isRtl.value ? props.prevIcon : props.nextIcon,
            class: `v-window__${isRtlReverse.value ? "left" : "right"}`,
            onClick: group.next,
            "aria-label": t("$vuetify.carousel.next")
          };
          arrows2.push(canMoveForward.value ? slots.next ? slots.next({
            props: nextProps
          }) : createVNode(VBtn, nextProps, null) : createVNode("div", null, null));
          return arrows2;
        });
        const touchOptions = computed(() => {
          if (props.touch === false)
            return props.touch;
          const options = {
            left: () => {
              isRtlReverse.value ? prev() : next2();
            },
            right: () => {
              isRtlReverse.value ? next2() : prev();
            },
            start: (_ref2) => {
              let {
                originalEvent
              } = _ref2;
              originalEvent.stopPropagation();
            }
          };
          return {
            ...options,
            ...props.touch === true ? {} : props.touch
          };
        });
        useRender(() => withDirectives(createVNode(props.tag, {
          "ref": rootRef,
          "class": ["v-window", {
            "v-window--show-arrows-on-hover": props.showArrows === "hover"
          }, themeClasses.value, props.class],
          "style": props.style
        }, {
          default: () => {
            var _a2, _b;
            return [createVNode("div", {
              "class": "v-window__container",
              "style": {
                height: transitionHeight.value
              }
            }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
              group
            }), props.showArrows !== false && createVNode("div", {
              "class": "v-window__controls"
            }, [arrows.value])]), (_b = slots.additional) == null ? void 0 : _b.call(slots, {
              group
            })];
          }
        }), [[resolveDirective("touch"), touchOptions.value]]));
        return {
          group
        };
      }
    });
    const makeVTabsWindowProps = propsFactory({
      ...omit$1(makeVWindowProps(), ["continuous", "nextIcon", "prevIcon", "showArrows", "touch", "mandatory"])
    }, "VTabsWindow");
    const VTabsWindow = genericComponent()({
      name: "VTabsWindow",
      props: makeVTabsWindowProps(),
      emits: {
        "update:modelValue": (v) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const group = inject$1(VTabsSymbol, null);
        const _model = useProxiedModel(props, "modelValue");
        const model = computed({
          get() {
            var _a2;
            if (_model.value != null || !group)
              return _model.value;
            return (_a2 = group.items.value.find((item) => group.selected.value.includes(item.id))) == null ? void 0 : _a2.value;
          },
          set(val) {
            _model.value = val;
          }
        });
        useRender(() => {
          const windowProps = VWindow.filterProps(props);
          return createVNode(VWindow, mergeProps({
            "_as": "VTabsWindow"
          }, windowProps, {
            "modelValue": model.value,
            "onUpdate:modelValue": ($event) => model.value = $event,
            "class": ["v-tabs-window", props.class],
            "style": props.style,
            "mandatory": false,
            "touch": false
          }), slots);
        });
        return {};
      }
    });
    const makeVWindowItemProps = propsFactory({
      reverseTransition: {
        type: [Boolean, String],
        default: void 0
      },
      transition: {
        type: [Boolean, String],
        default: void 0
      },
      ...makeComponentProps(),
      ...makeGroupItemProps(),
      ...makeLazyProps()
    }, "VWindowItem");
    const VWindowItem = genericComponent()({
      name: "VWindowItem",
      directives: {
        Touch: Touch$1
      },
      props: makeVWindowItemProps(),
      emits: {
        "group:selected": (val) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const window2 = inject$1(VWindowSymbol);
        const groupItem = useGroupItem(props, VWindowGroupSymbol);
        const {
          isBooted
        } = useSsrBoot();
        if (!window2 || !groupItem)
          throw new Error("[Vuetify] VWindowItem must be used inside VWindow");
        const isTransitioning = shallowRef(false);
        const hasTransition = computed(() => isBooted.value && (window2.isReversed.value ? props.reverseTransition !== false : props.transition !== false));
        function onAfterTransition() {
          if (!isTransitioning.value || !window2) {
            return;
          }
          isTransitioning.value = false;
          if (window2.transitionCount.value > 0) {
            window2.transitionCount.value -= 1;
            if (window2.transitionCount.value === 0) {
              window2.transitionHeight.value = void 0;
            }
          }
        }
        function onBeforeTransition() {
          var _a2;
          if (isTransitioning.value || !window2) {
            return;
          }
          isTransitioning.value = true;
          if (window2.transitionCount.value === 0) {
            window2.transitionHeight.value = convertToUnit((_a2 = window2.rootRef.value) == null ? void 0 : _a2.clientHeight);
          }
          window2.transitionCount.value += 1;
        }
        function onTransitionCancelled() {
          onAfterTransition();
        }
        function onEnterTransition(el2) {
          if (!isTransitioning.value) {
            return;
          }
          nextTick(() => {
            if (!hasTransition.value || !isTransitioning.value || !window2) {
              return;
            }
            window2.transitionHeight.value = convertToUnit(el2.clientHeight);
          });
        }
        const transition = computed(() => {
          const name = window2.isReversed.value ? props.reverseTransition : props.transition;
          return !hasTransition.value ? false : {
            name: typeof name !== "string" ? window2.transition.value : name,
            onBeforeEnter: onBeforeTransition,
            onAfterEnter: onAfterTransition,
            onEnterCancelled: onTransitionCancelled,
            onBeforeLeave: onBeforeTransition,
            onAfterLeave: onAfterTransition,
            onLeaveCancelled: onTransitionCancelled,
            onEnter: onEnterTransition
          };
        });
        const {
          hasContent
        } = useLazy(props, groupItem.isSelected);
        useRender(() => createVNode(MaybeTransition, {
          "transition": transition.value,
          "disabled": !isBooted.value
        }, {
          default: () => {
            var _a2;
            return [withDirectives(createVNode("div", {
              "class": ["v-window-item", groupItem.selectedClass.value, props.class],
              "style": props.style
            }, [hasContent.value && ((_a2 = slots.default) == null ? void 0 : _a2.call(slots))]), [[vShow, groupItem.isSelected.value]])];
          }
        }));
        return {
          groupItem
        };
      }
    });
    const makeVTabsWindowItemProps = propsFactory({
      ...makeVWindowItemProps()
    }, "VTabsWindowItem");
    const VTabsWindowItem = genericComponent()({
      name: "VTabsWindowItem",
      props: makeVTabsWindowItemProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        useRender(() => {
          const windowItemProps = VWindowItem.filterProps(props);
          return createVNode(VWindowItem, mergeProps({
            "_as": "VTabsWindowItem"
          }, windowItemProps, {
            "class": ["v-tabs-window-item", props.class],
            "style": props.style
          }), slots);
        });
        return {};
      }
    });
    function parseItems(items2) {
      if (!items2)
        return [];
      return items2.map((item) => {
        if (!isObject$3(item))
          return {
            text: item,
            value: item
          };
        return item;
      });
    }
    const makeVTabsProps = propsFactory({
      alignTabs: {
        type: String,
        default: "start"
      },
      color: String,
      fixedTabs: Boolean,
      items: {
        type: Array,
        default: () => []
      },
      stacked: Boolean,
      bgColor: String,
      grow: Boolean,
      height: {
        type: [Number, String],
        default: void 0
      },
      hideSlider: Boolean,
      sliderColor: String,
      ...makeVSlideGroupProps({
        mandatory: "force",
        selectedClass: "v-tab-item--selected"
      }),
      ...makeDensityProps(),
      ...makeTagProps()
    }, "VTabs");
    const VTabs = genericComponent()({
      name: "VTabs",
      props: makeVTabsProps(),
      emits: {
        "update:modelValue": (v) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          slots
        } = _ref;
        const model = useProxiedModel(props, "modelValue");
        const items2 = computed(() => parseItems(props.items));
        const {
          densityClasses
        } = useDensity(props);
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(toRef(props, "bgColor"));
        const {
          scopeId
        } = useScopeId();
        provideDefaults({
          VTab: {
            color: toRef(props, "color"),
            direction: toRef(props, "direction"),
            stacked: toRef(props, "stacked"),
            fixed: toRef(props, "fixedTabs"),
            sliderColor: toRef(props, "sliderColor"),
            hideSlider: toRef(props, "hideSlider")
          }
        });
        useRender(() => {
          const slideGroupProps = VSlideGroup.filterProps(props);
          const hasWindow = !!(slots.window || props.items.length > 0);
          return createVNode(Fragment, null, [createVNode(VSlideGroup, mergeProps(slideGroupProps, {
            "modelValue": model.value,
            "onUpdate:modelValue": ($event) => model.value = $event,
            "class": ["v-tabs", `v-tabs--${props.direction}`, `v-tabs--align-tabs-${props.alignTabs}`, {
              "v-tabs--fixed-tabs": props.fixedTabs,
              "v-tabs--grow": props.grow,
              "v-tabs--stacked": props.stacked
            }, densityClasses.value, backgroundColorClasses.value, props.class],
            "style": [{
              "--v-tabs-height": convertToUnit(props.height)
            }, backgroundColorStyles.value, props.style],
            "role": "tablist",
            "symbol": VTabsSymbol
          }, scopeId, attrs), {
            default: () => {
              var _a2;
              return [((_a2 = slots.default) == null ? void 0 : _a2.call(slots)) ?? items2.value.map((item) => {
                var _a3;
                return ((_a3 = slots.tab) == null ? void 0 : _a3.call(slots, {
                  item
                })) ?? createVNode(VTab, mergeProps(item, {
                  "key": item.text,
                  "value": item.value
                }), {
                  default: slots[`tab.${item.value}`] ? () => {
                    var _a4;
                    return (_a4 = slots[`tab.${item.value}`]) == null ? void 0 : _a4.call(slots, {
                      item
                    });
                  } : void 0
                });
              })];
            }
          }), hasWindow && createVNode(VTabsWindow, mergeProps({
            "modelValue": model.value,
            "onUpdate:modelValue": ($event) => model.value = $event,
            "key": "tabs-window"
          }, scopeId), {
            default: () => {
              var _a2;
              return [items2.value.map((item) => {
                var _a3;
                return ((_a3 = slots.item) == null ? void 0 : _a3.call(slots, {
                  item
                })) ?? createVNode(VTabsWindowItem, {
                  "value": item.value
                }, {
                  default: () => {
                    var _a4;
                    return (_a4 = slots[`item.${item.value}`]) == null ? void 0 : _a4.call(slots, {
                      item
                    });
                  }
                });
              }), (_a2 = slots.window) == null ? void 0 : _a2.call(slots)];
            }
          })]);
        });
        return {};
      }
    });
    const _hoisted_1$9 = { class: "title-content" };
    const _hoisted_2$4 = { class: "controls" };
    const __default__ = {
      components: {
        highlightjs: o.component
      }
    };
    const _sfc_main$J = /* @__PURE__ */ defineComponent$1({
      ...__default__,
      __name: "ConfigPreview",
      props: {
        config: {}
      },
      setup(__props) {
        const notyf2 = inject$1("notyf");
        const dialogVisible = ref$1(false);
        const closeDialog = () => {
          dialogVisible.value = false;
        };
        const props = __props;
        const tab = ref$1("yaml");
        const jsonCode = computed(() => JSON.stringify(props.config.serialize(), null, 2));
        const yamlCode = computed(() => jsYaml.dump(props.config.serialize()));
        const downloadConfig = () => {
          let filename = "";
          let contentType = "";
          let content2 = "";
          if (tab.value === "json") {
            filename = `${props.config._name}.json`;
            contentType = "application/json";
            content2 = jsonCode.value;
          } else if (tab.value === "yaml") {
            filename = `${props.config._name}.yaml`;
            contentType = "text/yaml";
            content2 = yamlCode.value;
          }
          const blob = new Blob([content2], { type: contentType });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        };
        const copyConfig = () => {
          let content2 = "";
          if (tab.value === "json") {
            content2 = jsonCode.value;
          } else if (tab.value === "yaml") {
            content2 = yamlCode.value;
          }
          navigator.clipboard.writeText(content2);
          notyf2.success("Copied to clipboard!");
        };
        return (_ctx, _cache) => {
          const _component_highlightjs = resolveComponent("highlightjs");
          return openBlock(), createBlock(VDialog, {
            modelValue: dialogVisible.value,
            "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => dialogVisible.value = $event)
          }, {
            activator: withCtx(({ props: activatorProps }) => [
              renderSlot(_ctx.$slots, "activator", { activatorProps }, void 0, true)
            ]),
            default: withCtx(({ isActive }) => [
              createVNode(VCard, null, {
                default: withCtx(() => [
                  createVNode(VCardTitle, null, {
                    default: withCtx(() => [
                      createBaseVNode("div", _hoisted_1$9, [
                        createBaseVNode("div", _hoisted_2$4, [
                          createVNode(VBtn, {
                            icon: "mdi-download",
                            onClick: _cache[0] || (_cache[0] = ($event) => downloadConfig())
                          }),
                          createVNode(VBtn, {
                            icon: "mdi-content-copy",
                            onClick: _cache[1] || (_cache[1] = ($event) => copyConfig())
                          })
                        ]),
                        createVNode(VBtn, {
                          class: "close-button",
                          icon: "mdi-close",
                          variant: "plain",
                          density: "compact",
                          onClick: _cache[2] || (_cache[2] = ($event) => closeDialog())
                        })
                      ])
                    ]),
                    _: 1
                  }),
                  createVNode(VCardText, null, {
                    default: withCtx(() => [
                      createVNode(VTabs, {
                        modelValue: tab.value,
                        "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => tab.value = $event)
                      }, {
                        default: withCtx(() => [
                          createVNode(VTab, { value: "yaml" }, {
                            default: withCtx(() => [
                              createTextVNode(" YAML ")
                            ]),
                            _: 1
                          }),
                          createVNode(VTab, { value: "json" }, {
                            default: withCtx(() => [
                              createTextVNode(" JSON ")
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }, 8, ["modelValue"]),
                      createVNode(VWindow, {
                        modelValue: tab.value,
                        "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => tab.value = $event)
                      }, {
                        default: withCtx(() => [
                          createVNode(VWindowItem, { value: "yaml" }, {
                            default: withCtx(() => [
                              createVNode(_component_highlightjs, {
                                language: "yaml",
                                code: yamlCode.value
                              }, null, 8, ["code"])
                            ]),
                            _: 1
                          }),
                          createVNode(VWindowItem, { value: "json" }, {
                            default: withCtx(() => [
                              createVNode(_component_highlightjs, {
                                language: "json",
                                code: jsonCode.value
                              }, null, 8, ["code"])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }, 8, ["modelValue"])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 3
          }, 8, ["modelValue"]);
        };
      }
    });
    const ConfigPreview = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["__scopeId", "data-v-82fa1853"]]);
    const _sfc_main$I = /* @__PURE__ */ defineComponent$1({
      components: { ConfigPreview },
      setup() {
        const evbcStore2 = useEvbcStore();
        const evbc2 = inject$1("evbc");
        const selected_interface = null;
        const notyf2 = inject$1("notyf");
        const { current_config } = storeToRefs(evbcStore2);
        ref$1(false);
        let stage;
        onMounted(() => {
          stage = new ConfigStage(
            {
              container: "konva-stage",
              width: 1024,
              // will automatically be resized responsively
              height: 800,
              draggable: false
              // we only want to have the static layer draggable
            },
            evbcStore2.config_context
          );
          if (current_config.value) {
            stage.set_model(current_config.value);
          }
        });
        onBeforeUnmount(() => {
          stage.destroy();
        });
        const reset_view = () => {
          stage.reset_view();
        };
        const save_config = () => {
          if (!current_config.value)
            return;
          evbc2.save_config(current_config.value).then(() => {
            notyf2.success(`Successfully saved ${current_config.value._name}`);
          }).catch((error2) => {
            notyf2.error(`Failed to save ${current_config.value._name}
Reason: ${error2}`);
          });
        };
        watch(current_config, (new_config, old_config) => {
          stage.set_model(new_config);
        });
        return {
          selected_interface,
          stage,
          current_config,
          reset_view,
          save_config
        };
      }
    });
    const makeVSheetProps = propsFactory({
      color: String,
      ...makeBorderProps(),
      ...makeComponentProps(),
      ...makeDimensionProps(),
      ...makeElevationProps(),
      ...makeLocationProps(),
      ...makePositionProps(),
      ...makeRoundedProps(),
      ...makeTagProps(),
      ...makeThemeProps()
    }, "VSheet");
    const VSheet = genericComponent()({
      name: "VSheet",
      props: makeVSheetProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          themeClasses
        } = provideTheme(props);
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(toRef(props, "color"));
        const {
          borderClasses
        } = useBorder(props);
        const {
          dimensionStyles
        } = useDimension(props);
        const {
          elevationClasses
        } = useElevation(props);
        const {
          locationStyles
        } = useLocation(props);
        const {
          positionClasses
        } = usePosition(props);
        const {
          roundedClasses
        } = useRounded(props);
        useRender(() => createVNode(props.tag, {
          "class": ["v-sheet", themeClasses.value, backgroundColorClasses.value, borderClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, props.class],
          "style": [backgroundColorStyles.value, dimensionStyles.value, locationStyles.value, props.style]
        }, slots));
        return {};
      }
    });
    const _hoisted_1$8 = /* @__PURE__ */ createBaseVNode("div", { id: "konva-stage" }, null, -1);
    const _hoisted_2$3 = { id: "stage-controls" };
    const _hoisted_3$2 = /* @__PURE__ */ createBaseVNode("span", null, "Show config preview", -1);
    const _hoisted_4$1 = /* @__PURE__ */ createBaseVNode("span", null, "Reset View", -1);
    const _hoisted_5$1 = /* @__PURE__ */ createBaseVNode("span", null, "Save Config", -1);
    function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_config_preview = resolveComponent("config-preview");
      return openBlock(), createBlock(VSheet, {
        id: "konva-stage-container",
        width: "100%",
        height: "100vh",
        elevation: "0"
      }, {
        default: withCtx(() => [
          _hoisted_1$8,
          createBaseVNode("div", _hoisted_2$3, [
            _ctx.current_config ? (openBlock(), createBlock(_component_config_preview, {
              key: 0,
              config: _ctx.current_config
            }, {
              activator: withCtx(({ activatorProps }) => [
                createVNode(VTooltip, { location: "left" }, {
                  activator: withCtx(({ props }) => [
                    createVNode(VBtn, mergeProps({
                      id: "show-preview-button",
                      color: "primary"
                    }, { ...activatorProps, ...props }, {
                      "prepend-icon": "mdi-code-tags",
                      icon: "mdi-code-tags"
                    }), null, 16)
                  ]),
                  default: withCtx(() => [
                    _hoisted_3$2
                  ]),
                  _: 2
                }, 1024)
              ]),
              _: 1
            }, 8, ["config"])) : createCommentVNode("", true),
            createVNode(VTooltip, { location: "left" }, {
              activator: withCtx(({ props }) => [
                createVNode(VBtn, mergeProps({
                  id: "reset-view-button",
                  icon: "mdi-undo",
                  color: "primary",
                  onClick: _ctx.reset_view
                }, props), null, 16, ["onClick"])
              ]),
              default: withCtx(() => [
                _hoisted_4$1
              ]),
              _: 1
            }),
            _ctx.current_config ? (openBlock(), createBlock(VTooltip, {
              key: 1,
              location: "left"
            }, {
              activator: withCtx(({ props }) => [
                createVNode(VBtn, mergeProps({
                  id: "config-save-button",
                  icon: "mdi-content-save",
                  color: "primary",
                  onClick: _ctx.save_config
                }, props), null, 16, ["onClick"])
              ]),
              default: withCtx(() => [
                _hoisted_5$1
              ]),
              _: 1
            })) : createCommentVNode("", true)
          ])
        ]),
        _: 1
      });
    }
    const EvConfigCanvas = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["render", _sfc_render$4]]);
    const _sfc_main$H = /* @__PURE__ */ defineComponent$1({
      props: {
        show_dialog: {
          type: Boolean,
          required: true
        },
        title: {
          type: String,
          required: true
        },
        text: {
          type: String,
          required: true
        },
        accept_text: {
          type: String,
          required: true
        },
        deny_text: {
          type: String,
          required: true
        }
      },
      methods: {
        accept() {
          this.$emit("accept");
        },
        deny() {
          this.$emit("deny");
        }
      }
    });
    function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createBlock(VDialog, {
        "model-value": _ctx.show_dialog,
        "onClick:outside": _ctx.deny,
        width: "auto"
      }, {
        default: withCtx(() => [
          createVNode(VCard, null, {
            default: withCtx(() => [
              createVNode(VCardTitle, { class: "d-flex flex-row align-baseline" }, {
                default: withCtx(() => [
                  createVNode(VIcon, {
                    size: "large",
                    color: "error"
                  }, {
                    default: withCtx(() => [
                      createTextVNode(" mdi-alert-circle ")
                    ]),
                    _: 1
                  }),
                  createTextVNode("   " + toDisplayString(_ctx.$props.title), 1)
                ]),
                _: 1
              }),
              createVNode(VCardText, null, {
                default: withCtx(() => [
                  createBaseVNode("p", null, toDisplayString(_ctx.$props.text), 1)
                ]),
                _: 1
              }),
              createVNode(VCardActions, null, {
                default: withCtx(() => [
                  createVNode(VBtn, {
                    color: "error",
                    onClick: _ctx.accept
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.$props.accept_text), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick"]),
                  createVNode(VBtn, { onClick: _ctx.deny }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.$props.deny_text), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick"])
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["model-value", "onClick:outside"]);
    }
    const EvDialog = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["render", _sfc_render$3]]);
    var ajv$1 = { exports: {} };
    var core$3 = {};
    var validate = {};
    var boolSchema = {};
    var errors$1 = {};
    var codegen = {};
    var code$2 = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.regexpCode = exports2.getEsmExportName = exports2.getProperty = exports2.safeStringify = exports2.stringify = exports2.strConcat = exports2.addCodeArg = exports2.str = exports2._ = exports2.nil = exports2._Code = exports2.Name = exports2.IDENTIFIER = exports2._CodeOrName = void 0;
      class _CodeOrName {
      }
      exports2._CodeOrName = _CodeOrName;
      exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
      class Name extends _CodeOrName {
        constructor(s) {
          super();
          if (!exports2.IDENTIFIER.test(s))
            throw new Error("CodeGen: name must be a valid identifier");
          this.str = s;
        }
        toString() {
          return this.str;
        }
        emptyStr() {
          return false;
        }
        get names() {
          return { [this.str]: 1 };
        }
      }
      exports2.Name = Name;
      class _Code extends _CodeOrName {
        constructor(code2) {
          super();
          this._items = typeof code2 === "string" ? [code2] : code2;
        }
        toString() {
          return this.str;
        }
        emptyStr() {
          if (this._items.length > 1)
            return false;
          const item = this._items[0];
          return item === "" || item === '""';
        }
        get str() {
          var _a2;
          return (_a2 = this._str) !== null && _a2 !== void 0 ? _a2 : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
        }
        get names() {
          var _a2;
          return (_a2 = this._names) !== null && _a2 !== void 0 ? _a2 : this._names = this._items.reduce((names2, c) => {
            if (c instanceof Name)
              names2[c.str] = (names2[c.str] || 0) + 1;
            return names2;
          }, {});
        }
      }
      exports2._Code = _Code;
      exports2.nil = new _Code("");
      function _(strs, ...args) {
        const code2 = [strs[0]];
        let i2 = 0;
        while (i2 < args.length) {
          addCodeArg(code2, args[i2]);
          code2.push(strs[++i2]);
        }
        return new _Code(code2);
      }
      exports2._ = _;
      const plus2 = new _Code("+");
      function str2(strs, ...args) {
        const expr = [safeStringify(strs[0])];
        let i2 = 0;
        while (i2 < args.length) {
          expr.push(plus2);
          addCodeArg(expr, args[i2]);
          expr.push(plus2, safeStringify(strs[++i2]));
        }
        optimize(expr);
        return new _Code(expr);
      }
      exports2.str = str2;
      function addCodeArg(code2, arg) {
        if (arg instanceof _Code)
          code2.push(...arg._items);
        else if (arg instanceof Name)
          code2.push(arg);
        else
          code2.push(interpolate(arg));
      }
      exports2.addCodeArg = addCodeArg;
      function optimize(expr) {
        let i2 = 1;
        while (i2 < expr.length - 1) {
          if (expr[i2] === plus2) {
            const res = mergeExprItems(expr[i2 - 1], expr[i2 + 1]);
            if (res !== void 0) {
              expr.splice(i2 - 1, 3, res);
              continue;
            }
            expr[i2++] = "+";
          }
          i2++;
        }
      }
      function mergeExprItems(a, b) {
        if (b === '""')
          return a;
        if (a === '""')
          return b;
        if (typeof a == "string") {
          if (b instanceof Name || a[a.length - 1] !== '"')
            return;
          if (typeof b != "string")
            return `${a.slice(0, -1)}${b}"`;
          if (b[0] === '"')
            return a.slice(0, -1) + b.slice(1);
          return;
        }
        if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
          return `"${a}${b.slice(1)}`;
        return;
      }
      function strConcat(c1, c2) {
        return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str2`${c1}${c2}`;
      }
      exports2.strConcat = strConcat;
      function interpolate(x2) {
        return typeof x2 == "number" || typeof x2 == "boolean" || x2 === null ? x2 : safeStringify(Array.isArray(x2) ? x2.join(",") : x2);
      }
      function stringify(x2) {
        return new _Code(safeStringify(x2));
      }
      exports2.stringify = stringify;
      function safeStringify(x2) {
        return JSON.stringify(x2).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      }
      exports2.safeStringify = safeStringify;
      function getProperty(key) {
        return typeof key == "string" && exports2.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
      }
      exports2.getProperty = getProperty;
      function getEsmExportName(key) {
        if (typeof key == "string" && exports2.IDENTIFIER.test(key)) {
          return new _Code(`${key}`);
        }
        throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
      }
      exports2.getEsmExportName = getEsmExportName;
      function regexpCode(rx2) {
        return new _Code(rx2.toString());
      }
      exports2.regexpCode = regexpCode;
    })(code$2);
    var scope = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ValueScope = exports2.ValueScopeName = exports2.Scope = exports2.varKinds = exports2.UsedValueState = void 0;
      const code_12 = code$2;
      class ValueError extends Error {
        constructor(name) {
          super(`CodeGen: "code" for ${name} not defined`);
          this.value = name.value;
        }
      }
      var UsedValueState;
      (function(UsedValueState2) {
        UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
        UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
      })(UsedValueState || (exports2.UsedValueState = UsedValueState = {}));
      exports2.varKinds = {
        const: new code_12.Name("const"),
        let: new code_12.Name("let"),
        var: new code_12.Name("var")
      };
      class Scope {
        constructor({ prefixes: prefixes2, parent } = {}) {
          this._names = {};
          this._prefixes = prefixes2;
          this._parent = parent;
        }
        toName(nameOrPrefix) {
          return nameOrPrefix instanceof code_12.Name ? nameOrPrefix : this.name(nameOrPrefix);
        }
        name(prefix) {
          return new code_12.Name(this._newName(prefix));
        }
        _newName(prefix) {
          const ng = this._names[prefix] || this._nameGroup(prefix);
          return `${prefix}${ng.index++}`;
        }
        _nameGroup(prefix) {
          var _a2, _b;
          if (((_b = (_a2 = this._parent) === null || _a2 === void 0 ? void 0 : _a2._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
            throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
          }
          return this._names[prefix] = { prefix, index: 0 };
        }
      }
      exports2.Scope = Scope;
      class ValueScopeName extends code_12.Name {
        constructor(prefix, nameStr) {
          super(nameStr);
          this.prefix = prefix;
        }
        setValue(value, { property, itemIndex }) {
          this.value = value;
          this.scopePath = (0, code_12._)`.${new code_12.Name(property)}[${itemIndex}]`;
        }
      }
      exports2.ValueScopeName = ValueScopeName;
      const line = (0, code_12._)`\n`;
      class ValueScope extends Scope {
        constructor(opts) {
          super(opts);
          this._values = {};
          this._scope = opts.scope;
          this.opts = { ...opts, _n: opts.lines ? line : code_12.nil };
        }
        get() {
          return this._scope;
        }
        name(prefix) {
          return new ValueScopeName(prefix, this._newName(prefix));
        }
        value(nameOrPrefix, value) {
          var _a2;
          if (value.ref === void 0)
            throw new Error("CodeGen: ref must be passed in value");
          const name = this.toName(nameOrPrefix);
          const { prefix } = name;
          const valueKey = (_a2 = value.key) !== null && _a2 !== void 0 ? _a2 : value.ref;
          let vs = this._values[prefix];
          if (vs) {
            const _name = vs.get(valueKey);
            if (_name)
              return _name;
          } else {
            vs = this._values[prefix] = /* @__PURE__ */ new Map();
          }
          vs.set(valueKey, name);
          const s = this._scope[prefix] || (this._scope[prefix] = []);
          const itemIndex = s.length;
          s[itemIndex] = value.ref;
          name.setValue(value, { property: prefix, itemIndex });
          return name;
        }
        getValue(prefix, keyOrRef) {
          const vs = this._values[prefix];
          if (!vs)
            return;
          return vs.get(keyOrRef);
        }
        scopeRefs(scopeName, values = this._values) {
          return this._reduceValues(values, (name) => {
            if (name.scopePath === void 0)
              throw new Error(`CodeGen: name "${name}" has no value`);
            return (0, code_12._)`${scopeName}${name.scopePath}`;
          });
        }
        scopeCode(values = this._values, usedValues, getCode) {
          return this._reduceValues(values, (name) => {
            if (name.value === void 0)
              throw new Error(`CodeGen: name "${name}" has no value`);
            return name.value.code;
          }, usedValues, getCode);
        }
        _reduceValues(values, valueCode, usedValues = {}, getCode) {
          let code2 = code_12.nil;
          for (const prefix in values) {
            const vs = values[prefix];
            if (!vs)
              continue;
            const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
            vs.forEach((name) => {
              if (nameSet.has(name))
                return;
              nameSet.set(name, UsedValueState.Started);
              let c = valueCode(name);
              if (c) {
                const def2 = this.opts.es5 ? exports2.varKinds.var : exports2.varKinds.const;
                code2 = (0, code_12._)`${code2}${def2} ${name} = ${c};${this.opts._n}`;
              } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
                code2 = (0, code_12._)`${code2}${c}${this.opts._n}`;
              } else {
                throw new ValueError(name);
              }
              nameSet.set(name, UsedValueState.Completed);
            });
          }
          return code2;
        }
      }
      exports2.ValueScope = ValueScope;
    })(scope);
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.or = exports2.and = exports2.not = exports2.CodeGen = exports2.operators = exports2.varKinds = exports2.ValueScopeName = exports2.ValueScope = exports2.Scope = exports2.Name = exports2.regexpCode = exports2.stringify = exports2.getProperty = exports2.nil = exports2.strConcat = exports2.str = exports2._ = void 0;
      const code_12 = code$2;
      const scope_1 = scope;
      var code_2 = code$2;
      Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
        return code_2._;
      } });
      Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
        return code_2.str;
      } });
      Object.defineProperty(exports2, "strConcat", { enumerable: true, get: function() {
        return code_2.strConcat;
      } });
      Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
        return code_2.nil;
      } });
      Object.defineProperty(exports2, "getProperty", { enumerable: true, get: function() {
        return code_2.getProperty;
      } });
      Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
        return code_2.stringify;
      } });
      Object.defineProperty(exports2, "regexpCode", { enumerable: true, get: function() {
        return code_2.regexpCode;
      } });
      Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
        return code_2.Name;
      } });
      var scope_2 = scope;
      Object.defineProperty(exports2, "Scope", { enumerable: true, get: function() {
        return scope_2.Scope;
      } });
      Object.defineProperty(exports2, "ValueScope", { enumerable: true, get: function() {
        return scope_2.ValueScope;
      } });
      Object.defineProperty(exports2, "ValueScopeName", { enumerable: true, get: function() {
        return scope_2.ValueScopeName;
      } });
      Object.defineProperty(exports2, "varKinds", { enumerable: true, get: function() {
        return scope_2.varKinds;
      } });
      exports2.operators = {
        GT: new code_12._Code(">"),
        GTE: new code_12._Code(">="),
        LT: new code_12._Code("<"),
        LTE: new code_12._Code("<="),
        EQ: new code_12._Code("==="),
        NEQ: new code_12._Code("!=="),
        NOT: new code_12._Code("!"),
        OR: new code_12._Code("||"),
        AND: new code_12._Code("&&"),
        ADD: new code_12._Code("+")
      };
      class Node2 {
        optimizeNodes() {
          return this;
        }
        optimizeNames(_names, _constants) {
          return this;
        }
      }
      class Def extends Node2 {
        constructor(varKind, name, rhs) {
          super();
          this.varKind = varKind;
          this.name = name;
          this.rhs = rhs;
        }
        render({ es5, _n }) {
          const varKind = es5 ? scope_1.varKinds.var : this.varKind;
          const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
          return `${varKind} ${this.name}${rhs};` + _n;
        }
        optimizeNames(names2, constants) {
          if (!names2[this.name.str])
            return;
          if (this.rhs)
            this.rhs = optimizeExpr(this.rhs, names2, constants);
          return this;
        }
        get names() {
          return this.rhs instanceof code_12._CodeOrName ? this.rhs.names : {};
        }
      }
      class Assign2 extends Node2 {
        constructor(lhs, rhs, sideEffects) {
          super();
          this.lhs = lhs;
          this.rhs = rhs;
          this.sideEffects = sideEffects;
        }
        render({ _n }) {
          return `${this.lhs} = ${this.rhs};` + _n;
        }
        optimizeNames(names2, constants) {
          if (this.lhs instanceof code_12.Name && !names2[this.lhs.str] && !this.sideEffects)
            return;
          this.rhs = optimizeExpr(this.rhs, names2, constants);
          return this;
        }
        get names() {
          const names2 = this.lhs instanceof code_12.Name ? {} : { ...this.lhs.names };
          return addExprNames(names2, this.rhs);
        }
      }
      class AssignOp extends Assign2 {
        constructor(lhs, op, rhs, sideEffects) {
          super(lhs, rhs, sideEffects);
          this.op = op;
        }
        render({ _n }) {
          return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
        }
      }
      class Label2 extends Node2 {
        constructor(label) {
          super();
          this.label = label;
          this.names = {};
        }
        render({ _n }) {
          return `${this.label}:` + _n;
        }
      }
      class Break extends Node2 {
        constructor(label) {
          super();
          this.label = label;
          this.names = {};
        }
        render({ _n }) {
          const label = this.label ? ` ${this.label}` : "";
          return `break${label};` + _n;
        }
      }
      class Throw extends Node2 {
        constructor(error2) {
          super();
          this.error = error2;
        }
        render({ _n }) {
          return `throw ${this.error};` + _n;
        }
        get names() {
          return this.error.names;
        }
      }
      class AnyCode extends Node2 {
        constructor(code2) {
          super();
          this.code = code2;
        }
        render({ _n }) {
          return `${this.code};` + _n;
        }
        optimizeNodes() {
          return `${this.code}` ? this : void 0;
        }
        optimizeNames(names2, constants) {
          this.code = optimizeExpr(this.code, names2, constants);
          return this;
        }
        get names() {
          return this.code instanceof code_12._CodeOrName ? this.code.names : {};
        }
      }
      class ParentNode extends Node2 {
        constructor(nodes = []) {
          super();
          this.nodes = nodes;
        }
        render(opts) {
          return this.nodes.reduce((code2, n) => code2 + n.render(opts), "");
        }
        optimizeNodes() {
          const { nodes } = this;
          let i2 = nodes.length;
          while (i2--) {
            const n = nodes[i2].optimizeNodes();
            if (Array.isArray(n))
              nodes.splice(i2, 1, ...n);
            else if (n)
              nodes[i2] = n;
            else
              nodes.splice(i2, 1);
          }
          return nodes.length > 0 ? this : void 0;
        }
        optimizeNames(names2, constants) {
          const { nodes } = this;
          let i2 = nodes.length;
          while (i2--) {
            const n = nodes[i2];
            if (n.optimizeNames(names2, constants))
              continue;
            subtractNames(names2, n.names);
            nodes.splice(i2, 1);
          }
          return nodes.length > 0 ? this : void 0;
        }
        get names() {
          return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
        }
      }
      class BlockNode extends ParentNode {
        render(opts) {
          return "{" + opts._n + super.render(opts) + "}" + opts._n;
        }
      }
      class Root extends ParentNode {
      }
      class Else extends BlockNode {
      }
      Else.kind = "else";
      class If extends BlockNode {
        constructor(condition, nodes) {
          super(nodes);
          this.condition = condition;
        }
        render(opts) {
          let code2 = `if(${this.condition})` + super.render(opts);
          if (this.else)
            code2 += "else " + this.else.render(opts);
          return code2;
        }
        optimizeNodes() {
          super.optimizeNodes();
          const cond = this.condition;
          if (cond === true)
            return this.nodes;
          let e = this.else;
          if (e) {
            const ns = e.optimizeNodes();
            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
          }
          if (e) {
            if (cond === false)
              return e instanceof If ? e : e.nodes;
            if (this.nodes.length)
              return this;
            return new If(not2(cond), e instanceof If ? [e] : e.nodes);
          }
          if (cond === false || !this.nodes.length)
            return void 0;
          return this;
        }
        optimizeNames(names2, constants) {
          var _a2;
          this.else = (_a2 = this.else) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names2, constants);
          if (!(super.optimizeNames(names2, constants) || this.else))
            return;
          this.condition = optimizeExpr(this.condition, names2, constants);
          return this;
        }
        get names() {
          const names2 = super.names;
          addExprNames(names2, this.condition);
          if (this.else)
            addNames(names2, this.else.names);
          return names2;
        }
      }
      If.kind = "if";
      class For extends BlockNode {
      }
      For.kind = "for";
      class ForLoop extends For {
        constructor(iteration) {
          super();
          this.iteration = iteration;
        }
        render(opts) {
          return `for(${this.iteration})` + super.render(opts);
        }
        optimizeNames(names2, constants) {
          if (!super.optimizeNames(names2, constants))
            return;
          this.iteration = optimizeExpr(this.iteration, names2, constants);
          return this;
        }
        get names() {
          return addNames(super.names, this.iteration.names);
        }
      }
      class ForRange extends For {
        constructor(varKind, name, from, to) {
          super();
          this.varKind = varKind;
          this.name = name;
          this.from = from;
          this.to = to;
        }
        render(opts) {
          const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
          const { name, from, to } = this;
          return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
        }
        get names() {
          const names2 = addExprNames(super.names, this.from);
          return addExprNames(names2, this.to);
        }
      }
      class ForIter extends For {
        constructor(loop, varKind, name, iterable) {
          super();
          this.loop = loop;
          this.varKind = varKind;
          this.name = name;
          this.iterable = iterable;
        }
        render(opts) {
          return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
        }
        optimizeNames(names2, constants) {
          if (!super.optimizeNames(names2, constants))
            return;
          this.iterable = optimizeExpr(this.iterable, names2, constants);
          return this;
        }
        get names() {
          return addNames(super.names, this.iterable.names);
        }
      }
      class Func extends BlockNode {
        constructor(name, args, async) {
          super();
          this.name = name;
          this.args = args;
          this.async = async;
        }
        render(opts) {
          const _async = this.async ? "async " : "";
          return `${_async}function ${this.name}(${this.args})` + super.render(opts);
        }
      }
      Func.kind = "func";
      class Return extends ParentNode {
        render(opts) {
          return "return " + super.render(opts);
        }
      }
      Return.kind = "return";
      class Try extends BlockNode {
        render(opts) {
          let code2 = "try" + super.render(opts);
          if (this.catch)
            code2 += this.catch.render(opts);
          if (this.finally)
            code2 += this.finally.render(opts);
          return code2;
        }
        optimizeNodes() {
          var _a2, _b;
          super.optimizeNodes();
          (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNodes();
          (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
          return this;
        }
        optimizeNames(names2, constants) {
          var _a2, _b;
          super.optimizeNames(names2, constants);
          (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names2, constants);
          (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants);
          return this;
        }
        get names() {
          const names2 = super.names;
          if (this.catch)
            addNames(names2, this.catch.names);
          if (this.finally)
            addNames(names2, this.finally.names);
          return names2;
        }
      }
      class Catch extends BlockNode {
        constructor(error2) {
          super();
          this.error = error2;
        }
        render(opts) {
          return `catch(${this.error})` + super.render(opts);
        }
      }
      Catch.kind = "catch";
      class Finally extends BlockNode {
        render(opts) {
          return "finally" + super.render(opts);
        }
      }
      Finally.kind = "finally";
      class CodeGen {
        constructor(extScope, opts = {}) {
          this._values = {};
          this._blockStarts = [];
          this._constants = {};
          this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
          this._extScope = extScope;
          this._scope = new scope_1.Scope({ parent: extScope });
          this._nodes = [new Root()];
        }
        toString() {
          return this._root.render(this.opts);
        }
        // returns unique name in the internal scope
        name(prefix) {
          return this._scope.name(prefix);
        }
        // reserves unique name in the external scope
        scopeName(prefix) {
          return this._extScope.name(prefix);
        }
        // reserves unique name in the external scope and assigns value to it
        scopeValue(prefixOrName, value) {
          const name = this._extScope.value(prefixOrName, value);
          const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
          vs.add(name);
          return name;
        }
        getScopeValue(prefix, keyOrRef) {
          return this._extScope.getValue(prefix, keyOrRef);
        }
        // return code that assigns values in the external scope to the names that are used internally
        // (same names that were returned by gen.scopeName or gen.scopeValue)
        scopeRefs(scopeName) {
          return this._extScope.scopeRefs(scopeName, this._values);
        }
        scopeCode() {
          return this._extScope.scopeCode(this._values);
        }
        _def(varKind, nameOrPrefix, rhs, constant) {
          const name = this._scope.toName(nameOrPrefix);
          if (rhs !== void 0 && constant)
            this._constants[name.str] = rhs;
          this._leafNode(new Def(varKind, name, rhs));
          return name;
        }
        // `const` declaration (`var` in es5 mode)
        const(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
        }
        // `let` declaration with optional assignment (`var` in es5 mode)
        let(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
        }
        // `var` declaration with optional assignment
        var(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
        }
        // assignment code
        assign(lhs, rhs, sideEffects) {
          return this._leafNode(new Assign2(lhs, rhs, sideEffects));
        }
        // `+=` code
        add(lhs, rhs) {
          return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));
        }
        // appends passed SafeExpr to code or executes Block
        code(c) {
          if (typeof c == "function")
            c();
          else if (c !== code_12.nil)
            this._leafNode(new AnyCode(c));
          return this;
        }
        // returns code for object literal for the passed argument list of key-value pairs
        object(...keyValues2) {
          const code2 = ["{"];
          for (const [key, value] of keyValues2) {
            if (code2.length > 1)
              code2.push(",");
            code2.push(key);
            if (key !== value || this.opts.es5) {
              code2.push(":");
              (0, code_12.addCodeArg)(code2, value);
            }
          }
          code2.push("}");
          return new code_12._Code(code2);
        }
        // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
        if(condition, thenBody, elseBody) {
          this._blockNode(new If(condition));
          if (thenBody && elseBody) {
            this.code(thenBody).else().code(elseBody).endIf();
          } else if (thenBody) {
            this.code(thenBody).endIf();
          } else if (elseBody) {
            throw new Error('CodeGen: "else" body without "then" body');
          }
          return this;
        }
        // `else if` clause - invalid without `if` or after `else` clauses
        elseIf(condition) {
          return this._elseNode(new If(condition));
        }
        // `else` clause - only valid after `if` or `else if` clauses
        else() {
          return this._elseNode(new Else());
        }
        // end `if` statement (needed if gen.if was used only with condition)
        endIf() {
          return this._endBlockNode(If, Else);
        }
        _for(node, forBody) {
          this._blockNode(node);
          if (forBody)
            this.code(forBody).endFor();
          return this;
        }
        // a generic `for` clause (or statement if `forBody` is passed)
        for(iteration, forBody) {
          return this._for(new ForLoop(iteration), forBody);
        }
        // `for` statement for a range of values
        forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
          const name = this._scope.toName(nameOrPrefix);
          return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
        }
        // `for-of` statement (in es5 mode replace with a normal for loop)
        forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
          const name = this._scope.toName(nameOrPrefix);
          if (this.opts.es5) {
            const arr = iterable instanceof code_12.Name ? iterable : this.var("_arr", iterable);
            return this.forRange("_i", 0, (0, code_12._)`${arr}.length`, (i2) => {
              this.var(name, (0, code_12._)`${arr}[${i2}]`);
              forBody(name);
            });
          }
          return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
        }
        // `for-in` statement.
        // With option `ownProperties` replaced with a `for-of` loop for object keys
        forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
          if (this.opts.ownProperties) {
            return this.forOf(nameOrPrefix, (0, code_12._)`Object.keys(${obj})`, forBody);
          }
          const name = this._scope.toName(nameOrPrefix);
          return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
        }
        // end `for` loop
        endFor() {
          return this._endBlockNode(For);
        }
        // `label` statement
        label(label) {
          return this._leafNode(new Label2(label));
        }
        // `break` statement
        break(label) {
          return this._leafNode(new Break(label));
        }
        // `return` statement
        return(value) {
          const node = new Return();
          this._blockNode(node);
          this.code(value);
          if (node.nodes.length !== 1)
            throw new Error('CodeGen: "return" should have one node');
          return this._endBlockNode(Return);
        }
        // `try` statement
        try(tryBody, catchCode, finallyCode) {
          if (!catchCode && !finallyCode)
            throw new Error('CodeGen: "try" without "catch" and "finally"');
          const node = new Try();
          this._blockNode(node);
          this.code(tryBody);
          if (catchCode) {
            const error2 = this.name("e");
            this._currNode = node.catch = new Catch(error2);
            catchCode(error2);
          }
          if (finallyCode) {
            this._currNode = node.finally = new Finally();
            this.code(finallyCode);
          }
          return this._endBlockNode(Catch, Finally);
        }
        // `throw` statement
        throw(error2) {
          return this._leafNode(new Throw(error2));
        }
        // start self-balancing block
        block(body, nodeCount) {
          this._blockStarts.push(this._nodes.length);
          if (body)
            this.code(body).endBlock(nodeCount);
          return this;
        }
        // end the current self-balancing block
        endBlock(nodeCount) {
          const len = this._blockStarts.pop();
          if (len === void 0)
            throw new Error("CodeGen: not in self-balancing block");
          const toClose = this._nodes.length - len;
          if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
          }
          this._nodes.length = len;
          return this;
        }
        // `function` heading (or definition if funcBody is passed)
        func(name, args = code_12.nil, async, funcBody) {
          this._blockNode(new Func(name, args, async));
          if (funcBody)
            this.code(funcBody).endFunc();
          return this;
        }
        // end function definition
        endFunc() {
          return this._endBlockNode(Func);
        }
        optimize(n = 1) {
          while (n-- > 0) {
            this._root.optimizeNodes();
            this._root.optimizeNames(this._root.names, this._constants);
          }
        }
        _leafNode(node) {
          this._currNode.nodes.push(node);
          return this;
        }
        _blockNode(node) {
          this._currNode.nodes.push(node);
          this._nodes.push(node);
        }
        _endBlockNode(N1, N2) {
          const n = this._currNode;
          if (n instanceof N1 || N2 && n instanceof N2) {
            this._nodes.pop();
            return this;
          }
          throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
        }
        _elseNode(node) {
          const n = this._currNode;
          if (!(n instanceof If)) {
            throw new Error('CodeGen: "else" without "if"');
          }
          this._currNode = n.else = node;
          return this;
        }
        get _root() {
          return this._nodes[0];
        }
        get _currNode() {
          const ns = this._nodes;
          return ns[ns.length - 1];
        }
        set _currNode(node) {
          const ns = this._nodes;
          ns[ns.length - 1] = node;
        }
      }
      exports2.CodeGen = CodeGen;
      function addNames(names2, from) {
        for (const n in from)
          names2[n] = (names2[n] || 0) + (from[n] || 0);
        return names2;
      }
      function addExprNames(names2, from) {
        return from instanceof code_12._CodeOrName ? addNames(names2, from.names) : names2;
      }
      function optimizeExpr(expr, names2, constants) {
        if (expr instanceof code_12.Name)
          return replaceName(expr);
        if (!canOptimize(expr))
          return expr;
        return new code_12._Code(expr._items.reduce((items2, c) => {
          if (c instanceof code_12.Name)
            c = replaceName(c);
          if (c instanceof code_12._Code)
            items2.push(...c._items);
          else
            items2.push(c);
          return items2;
        }, []));
        function replaceName(n) {
          const c = constants[n.str];
          if (c === void 0 || names2[n.str] !== 1)
            return n;
          delete names2[n.str];
          return c;
        }
        function canOptimize(e) {
          return e instanceof code_12._Code && e._items.some((c) => c instanceof code_12.Name && names2[c.str] === 1 && constants[c.str] !== void 0);
        }
      }
      function subtractNames(names2, from) {
        for (const n in from)
          names2[n] = (names2[n] || 0) - (from[n] || 0);
      }
      function not2(x2) {
        return typeof x2 == "boolean" || typeof x2 == "number" || x2 === null ? !x2 : (0, code_12._)`!${par2(x2)}`;
      }
      exports2.not = not2;
      const andCode = mappend(exports2.operators.AND);
      function and2(...args) {
        return args.reduce(andCode);
      }
      exports2.and = and2;
      const orCode = mappend(exports2.operators.OR);
      function or2(...args) {
        return args.reduce(orCode);
      }
      exports2.or = or2;
      function mappend(op) {
        return (x2, y) => x2 === code_12.nil ? y : y === code_12.nil ? x2 : (0, code_12._)`${par2(x2)} ${op} ${par2(y)}`;
      }
      function par2(x2) {
        return x2 instanceof code_12.Name ? x2 : (0, code_12._)`(${x2})`;
      }
    })(codegen);
    var util = {};
    Object.defineProperty(util, "__esModule", { value: true });
    util.checkStrictMode = util.getErrorPath = util.Type = util.useFunc = util.setEvaluated = util.evaluatedPropsToName = util.mergeEvaluated = util.eachItem = util.unescapeJsonPointer = util.escapeJsonPointer = util.escapeFragment = util.unescapeFragment = util.schemaRefOrVal = util.schemaHasRulesButRef = util.schemaHasRules = util.checkUnknownRules = util.alwaysValidSchema = util.toHash = void 0;
    const codegen_1$z = codegen;
    const code_1$a = code$2;
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    util.toHash = toHash;
    function alwaysValidSchema(it2, schema2) {
      if (typeof schema2 == "boolean")
        return schema2;
      if (Object.keys(schema2).length === 0)
        return true;
      checkUnknownRules(it2, schema2);
      return !schemaHasRules(schema2, it2.self.RULES.all);
    }
    util.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it2, schema2 = it2.schema) {
      const { opts, self: self2 } = it2;
      if (!opts.strictSchema)
        return;
      if (typeof schema2 === "boolean")
        return;
      const rules2 = self2.RULES.keywords;
      for (const key in schema2) {
        if (!rules2[key])
          checkStrictMode(it2, `unknown keyword: "${key}"`);
      }
    }
    util.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema2, rules2) {
      if (typeof schema2 == "boolean")
        return !schema2;
      for (const key in schema2)
        if (rules2[key])
          return true;
      return false;
    }
    util.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema2, RULES2) {
      if (typeof schema2 == "boolean")
        return !schema2;
      for (const key in schema2)
        if (key !== "$ref" && RULES2.all[key])
          return true;
      return false;
    }
    util.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema2, keyword2, $data) {
      if (!$data) {
        if (typeof schema2 == "number" || typeof schema2 == "boolean")
          return schema2;
        if (typeof schema2 == "string")
          return (0, codegen_1$z._)`${schema2}`;
      }
      return (0, codegen_1$z._)`${topSchemaRef}${schemaPath}${(0, codegen_1$z.getProperty)(keyword2)}`;
    }
    util.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str2) {
      return unescapeJsonPointer(decodeURIComponent(str2));
    }
    util.unescapeFragment = unescapeFragment;
    function escapeFragment(str2) {
      return encodeURIComponent(escapeJsonPointer(str2));
    }
    util.escapeFragment = escapeFragment;
    function escapeJsonPointer(str2) {
      if (typeof str2 == "number")
        return `${str2}`;
      return str2.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    util.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str2) {
      return str2.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    util.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x2 of xs)
          f(x2);
      } else {
        f(xs);
      }
    }
    util.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1$z.Name ? (from instanceof codegen_1$z.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1$z.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1$z.Name && !(res instanceof codegen_1$z.Name) ? resultToName(gen, res) : res;
      };
    }
    util.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1$z._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1$z._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1$z._)`${to} || {}`).code((0, codegen_1$z._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1$z._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1$z._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1$z._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1$z._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1$z._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1$z._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items2) => gen.var("items", items2)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1$z._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    util.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p2) => gen.assign((0, codegen_1$z._)`${props}${(0, codegen_1$z.getProperty)(p2)}`, true));
    }
    util.setEvaluated = setEvaluated;
    const snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1$a._Code(f.code))
      });
    }
    util.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (util.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1$z.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1$z._)`"[" + ${dataProp} + "]"` : (0, codegen_1$z._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1$z._)`"/" + ${dataProp}` : (0, codegen_1$z._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1$z.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    util.getErrorPath = getErrorPath;
    function checkStrictMode(it2, msg, mode = it2.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it2.self.logger.warn(msg);
    }
    util.checkStrictMode = checkStrictMode;
    var names$2 = {};
    Object.defineProperty(names$2, "__esModule", { value: true });
    const codegen_1$y = codegen;
    const names$1 = {
      // validation function arguments
      data: new codegen_1$y.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1$y.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1$y.Name("instancePath"),
      parentData: new codegen_1$y.Name("parentData"),
      parentDataProperty: new codegen_1$y.Name("parentDataProperty"),
      rootData: new codegen_1$y.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1$y.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1$y.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1$y.Name("errors"),
      // counter of validation errors
      this: new codegen_1$y.Name("this"),
      // "globals"
      self: new codegen_1$y.Name("self"),
      scope: new codegen_1$y.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1$y.Name("json"),
      jsonPos: new codegen_1$y.Name("jsonPos"),
      jsonLen: new codegen_1$y.Name("jsonLen"),
      jsonPart: new codegen_1$y.Name("jsonPart")
    };
    names$2.default = names$1;
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.extendErrors = exports2.resetErrorsCount = exports2.reportExtraError = exports2.reportError = exports2.keyword$DataError = exports2.keywordError = void 0;
      const codegen_12 = codegen;
      const util_12 = util;
      const names_12 = names$2;
      exports2.keywordError = {
        message: ({ keyword: keyword2 }) => (0, codegen_12.str)`must pass "${keyword2}" keyword validation`
      };
      exports2.keyword$DataError = {
        message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_12.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_12.str)`"${keyword2}" keyword is invalid ($data)`
      };
      function reportError(cxt, error2 = exports2.keywordError, errorPaths, overrideAllErrors) {
        const { it: it2 } = cxt;
        const { gen, compositeRule, allErrors } = it2;
        const errObj = errorObjectCode(cxt, error2, errorPaths);
        if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
          addError(gen, errObj);
        } else {
          returnErrors(it2, (0, codegen_12._)`[${errObj}]`);
        }
      }
      exports2.reportError = reportError;
      function reportExtraError(cxt, error2 = exports2.keywordError, errorPaths) {
        const { it: it2 } = cxt;
        const { gen, compositeRule, allErrors } = it2;
        const errObj = errorObjectCode(cxt, error2, errorPaths);
        addError(gen, errObj);
        if (!(compositeRule || allErrors)) {
          returnErrors(it2, names_12.default.vErrors);
        }
      }
      exports2.reportExtraError = reportExtraError;
      function resetErrorsCount(gen, errsCount) {
        gen.assign(names_12.default.errors, errsCount);
        gen.if((0, codegen_12._)`${names_12.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_12._)`${names_12.default.vErrors}.length`, errsCount), () => gen.assign(names_12.default.vErrors, null)));
      }
      exports2.resetErrorsCount = resetErrorsCount;
      function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it: it2 }) {
        if (errsCount === void 0)
          throw new Error("ajv implementation error");
        const err = gen.name("err");
        gen.forRange("i", errsCount, names_12.default.errors, (i2) => {
          gen.const(err, (0, codegen_12._)`${names_12.default.vErrors}[${i2}]`);
          gen.if((0, codegen_12._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_12._)`${err}.instancePath`, (0, codegen_12.strConcat)(names_12.default.instancePath, it2.errorPath)));
          gen.assign((0, codegen_12._)`${err}.schemaPath`, (0, codegen_12.str)`${it2.errSchemaPath}/${keyword2}`);
          if (it2.opts.verbose) {
            gen.assign((0, codegen_12._)`${err}.schema`, schemaValue);
            gen.assign((0, codegen_12._)`${err}.data`, data);
          }
        });
      }
      exports2.extendErrors = extendErrors;
      function addError(gen, errObj) {
        const err = gen.const("err", errObj);
        gen.if((0, codegen_12._)`${names_12.default.vErrors} === null`, () => gen.assign(names_12.default.vErrors, (0, codegen_12._)`[${err}]`), (0, codegen_12._)`${names_12.default.vErrors}.push(${err})`);
        gen.code((0, codegen_12._)`${names_12.default.errors}++`);
      }
      function returnErrors(it2, errs) {
        const { gen, validateName, schemaEnv } = it2;
        if (schemaEnv.$async) {
          gen.throw((0, codegen_12._)`new ${it2.ValidationError}(${errs})`);
        } else {
          gen.assign((0, codegen_12._)`${validateName}.errors`, errs);
          gen.return(false);
        }
      }
      const E = {
        keyword: new codegen_12.Name("keyword"),
        schemaPath: new codegen_12.Name("schemaPath"),
        // also used in JTD errors
        params: new codegen_12.Name("params"),
        propertyName: new codegen_12.Name("propertyName"),
        message: new codegen_12.Name("message"),
        schema: new codegen_12.Name("schema"),
        parentSchema: new codegen_12.Name("parentSchema")
      };
      function errorObjectCode(cxt, error2, errorPaths) {
        const { createErrors } = cxt.it;
        if (createErrors === false)
          return (0, codegen_12._)`{}`;
        return errorObject(cxt, error2, errorPaths);
      }
      function errorObject(cxt, error2, errorPaths = {}) {
        const { gen, it: it2 } = cxt;
        const keyValues2 = [
          errorInstancePath(it2, errorPaths),
          errorSchemaPath(cxt, errorPaths)
        ];
        extraErrorProps(cxt, error2, keyValues2);
        return gen.object(...keyValues2);
      }
      function errorInstancePath({ errorPath }, { instancePath }) {
        const instPath = instancePath ? (0, codegen_12.str)`${errorPath}${(0, util_12.getErrorPath)(instancePath, util_12.Type.Str)}` : errorPath;
        return [names_12.default.instancePath, (0, codegen_12.strConcat)(names_12.default.instancePath, instPath)];
      }
      function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
        let schPath = parentSchema ? errSchemaPath : (0, codegen_12.str)`${errSchemaPath}/${keyword2}`;
        if (schemaPath) {
          schPath = (0, codegen_12.str)`${schPath}${(0, util_12.getErrorPath)(schemaPath, util_12.Type.Str)}`;
        }
        return [E.schemaPath, schPath];
      }
      function extraErrorProps(cxt, { params, message }, keyValues2) {
        const { keyword: keyword2, data, schemaValue, it: it2 } = cxt;
        const { opts, propertyName, topSchemaRef, schemaPath } = it2;
        keyValues2.push([E.keyword, keyword2], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_12._)`{}`]);
        if (opts.messages) {
          keyValues2.push([E.message, typeof message == "function" ? message(cxt) : message]);
        }
        if (opts.verbose) {
          keyValues2.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_12._)`${topSchemaRef}${schemaPath}`], [names_12.default.data, data]);
        }
        if (propertyName)
          keyValues2.push([E.propertyName, propertyName]);
      }
    })(errors$1);
    Object.defineProperty(boolSchema, "__esModule", { value: true });
    boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
    const errors_1$3 = errors$1;
    const codegen_1$x = codegen;
    const names_1$9 = names$2;
    const boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it2) {
      const { gen, schema: schema2, validateName } = it2;
      if (schema2 === false) {
        falseSchemaError(it2, false);
      } else if (typeof schema2 == "object" && schema2.$async === true) {
        gen.return(names_1$9.default.data);
      } else {
        gen.assign((0, codegen_1$x._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it2, valid) {
      const { gen, schema: schema2 } = it2;
      if (schema2 === false) {
        gen.var(valid, false);
        falseSchemaError(it2);
      } else {
        gen.var(valid, true);
      }
    }
    boolSchema.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it2, overrideAllErrors) {
      const { gen, data } = it2;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it: it2
      };
      (0, errors_1$3.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
    var dataType = {};
    var rules = {};
    Object.defineProperty(rules, "__esModule", { value: true });
    rules.getRules = rules.isJSONType = void 0;
    const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    const jsonTypes = new Set(_jsonTypes);
    function isJSONType(x2) {
      return typeof x2 == "string" && jsonTypes.has(x2);
    }
    rules.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    rules.getRules = getRules;
    var applicability = {};
    Object.defineProperty(applicability, "__esModule", { value: true });
    applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema: schema2, self: self2 }, type2) {
      const group = self2.RULES.types[type2];
      return group && group !== true && shouldUseGroup(schema2, group);
    }
    applicability.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema2, group) {
      return group.rules.some((rule) => shouldUseRule(schema2, rule));
    }
    applicability.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema2, rule) {
      var _a2;
      return schema2[rule.keyword] !== void 0 || ((_a2 = rule.definition.implements) === null || _a2 === void 0 ? void 0 : _a2.some((kwd) => schema2[kwd] !== void 0));
    }
    applicability.shouldUseRule = shouldUseRule;
    Object.defineProperty(dataType, "__esModule", { value: true });
    dataType.reportTypeError = dataType.checkDataTypes = dataType.checkDataType = dataType.coerceAndCheckDataType = dataType.getJSONTypes = dataType.getSchemaTypes = dataType.DataType = void 0;
    const rules_1 = rules;
    const applicability_1$1 = applicability;
    const errors_1$2 = errors$1;
    const codegen_1$w = codegen;
    const util_1$u = util;
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (dataType.DataType = DataType = {}));
    function getSchemaTypes(schema2) {
      const types2 = getJSONTypes(schema2.type);
      const hasNull = types2.includes("null");
      if (hasNull) {
        if (schema2.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types2.length && schema2.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema2.nullable === true)
          types2.push("null");
      }
      return types2;
    }
    dataType.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types2.every(rules_1.isJSONType))
        return types2;
      throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
    }
    dataType.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it2, types2) {
      const { gen, data, opts } = it2;
      const coerceTo = coerceToTypes(types2, opts.coerceTypes);
      const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1$1.schemaHasRulesForType)(it2, types2[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types2, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it2, types2, coerceTo);
          else
            reportTypeError(it2);
        });
      }
      return checkTypes;
    }
    dataType.coerceAndCheckDataType = coerceAndCheckDataType;
    const COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types2, coerceTypes) {
      return coerceTypes ? types2.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it2, types2, coerceTo) {
      const { gen, data, opts } = it2;
      const dataType2 = gen.let("dataType", (0, codegen_1$w._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1$w._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1$w._)`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1$w._)`${data}[0]`).assign(dataType2, (0, codegen_1$w._)`typeof ${data}`).if(checkDataTypes(types2, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1$w._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it2);
      gen.endIf();
      gen.if((0, codegen_1$w._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it2, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1$w._)`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, (0, codegen_1$w._)`"" + ${data}`).elseIf((0, codegen_1$w._)`${data} === null`).assign(coerced, (0, codegen_1$w._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1$w._)`${dataType2} == "boolean" || ${data} === null
              || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1$w._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1$w._)`${dataType2} === "boolean" || ${data} === null
              || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1$w._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1$w._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1$w._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1$w._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1$w._)`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1$w._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1$w._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1$w._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType2, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1$w.operators.EQ : codegen_1$w.operators.NEQ;
      let cond;
      switch (dataType2) {
        case "null":
          return (0, codegen_1$w._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1$w._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1$w._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1$w._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1$w._)`typeof ${data} ${EQ} ${dataType2}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1$w.not)(cond);
      function numCond(_cond = codegen_1$w.nil) {
        return (0, codegen_1$w.and)((0, codegen_1$w._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1$w._)`isFinite(${data})` : codegen_1$w.nil);
      }
    }
    dataType.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types2 = (0, util_1$u.toHash)(dataTypes);
      if (types2.array && types2.object) {
        const notObj = (0, codegen_1$w._)`typeof ${data} != "object"`;
        cond = types2.null ? notObj : (0, codegen_1$w._)`!${data} || ${notObj}`;
        delete types2.null;
        delete types2.array;
        delete types2.object;
      } else {
        cond = codegen_1$w.nil;
      }
      if (types2.number)
        delete types2.integer;
      for (const t in types2)
        cond = (0, codegen_1$w.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    dataType.checkDataTypes = checkDataTypes;
    const typeError = {
      message: ({ schema: schema2 }) => `must be ${schema2}`,
      params: ({ schema: schema2, schemaValue }) => typeof schema2 == "string" ? (0, codegen_1$w._)`{type: ${schema2}}` : (0, codegen_1$w._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it2) {
      const cxt = getTypeErrorContext(it2);
      (0, errors_1$2.reportError)(cxt, typeError);
    }
    dataType.reportTypeError = reportTypeError;
    function getTypeErrorContext(it2) {
      const { gen, data, schema: schema2 } = it2;
      const schemaCode = (0, util_1$u.schemaRefOrVal)(it2, schema2, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema2.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema2,
        params: {},
        it: it2
      };
    }
    var defaults = {};
    Object.defineProperty(defaults, "__esModule", { value: true });
    defaults.assignDefaults = void 0;
    const codegen_1$v = codegen;
    const util_1$t = util;
    function assignDefaults(it2, ty) {
      const { properties: properties2, items: items2 } = it2.schema;
      if (ty === "object" && properties2) {
        for (const key in properties2) {
          assignDefault(it2, key, properties2[key].default);
        }
      } else if (ty === "array" && Array.isArray(items2)) {
        items2.forEach((sch, i2) => assignDefault(it2, i2, sch.default));
      }
    }
    defaults.assignDefaults = assignDefaults;
    function assignDefault(it2, prop2, defaultValue) {
      const { gen, compositeRule, data, opts } = it2;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1$v._)`${data}${(0, codegen_1$v.getProperty)(prop2)}`;
      if (compositeRule) {
        (0, util_1$t.checkStrictMode)(it2, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1$v._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1$v._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1$v._)`${childData} = ${(0, codegen_1$v.stringify)(defaultValue)}`);
    }
    var keyword = {};
    var code$1 = {};
    Object.defineProperty(code$1, "__esModule", { value: true });
    code$1.validateUnion = code$1.validateArray = code$1.usePattern = code$1.callValidateCode = code$1.schemaProperties = code$1.allSchemaProperties = code$1.noPropertyInData = code$1.propertyInData = code$1.isOwnProperty = code$1.hasPropFunc = code$1.reportMissingProp = code$1.checkMissingProp = code$1.checkReportMissingProp = void 0;
    const codegen_1$u = codegen;
    const util_1$s = util;
    const names_1$8 = names$2;
    const util_2$1 = util;
    function checkReportMissingProp(cxt, prop2) {
      const { gen, data, it: it2 } = cxt;
      gen.if(noPropertyInData(gen, data, prop2, it2.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1$u._)`${prop2}` }, true);
        cxt.error();
      });
    }
    code$1.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties2, missing) {
      return (0, codegen_1$u.or)(...properties2.map((prop2) => (0, codegen_1$u.and)(noPropertyInData(gen, data, prop2, opts.ownProperties), (0, codegen_1$u._)`${missing} = ${prop2}`)));
    }
    code$1.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    code$1.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1$u._)`Object.prototype.hasOwnProperty`
      });
    }
    code$1.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1$u._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    code$1.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1$u._)`${data}${(0, codegen_1$u.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1$u._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    code$1.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1$u._)`${data}${(0, codegen_1$u.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1$u.or)(cond, (0, codegen_1$u.not)(isOwnProperty(gen, data, property))) : cond;
    }
    code$1.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p2) => p2 !== "__proto__") : [];
    }
    code$1.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it2, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p2) => !(0, util_1$s.alwaysValidSchema)(it2, schemaMap[p2]));
    }
    code$1.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it: it2 }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1$u._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1$8.default.instancePath, (0, codegen_1$u.strConcat)(names_1$8.default.instancePath, errorPath)],
        [names_1$8.default.parentData, it2.parentData],
        [names_1$8.default.parentDataProperty, it2.parentDataProperty],
        [names_1$8.default.rootData, names_1$8.default.rootData]
      ];
      if (it2.opts.dynamicRef)
        valCxt.push([names_1$8.default.dynamicAnchors, names_1$8.default.dynamicAnchors]);
      const args = (0, codegen_1$u._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1$u.nil ? (0, codegen_1$u._)`${func}.call(${context}, ${args})` : (0, codegen_1$u._)`${func}(${args})`;
    }
    code$1.callValidateCode = callValidateCode;
    const newRegExp = (0, codegen_1$u._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern2) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx2 = regExp(pattern2, u);
      return gen.scopeValue("pattern", {
        key: rx2.toString(),
        ref: rx2,
        code: (0, codegen_1$u._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2$1.useFunc)(gen, regExp)}(${pattern2}, ${u})`
      });
    }
    code$1.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword: keyword2, it: it2 } = cxt;
      const valid = gen.name("valid");
      if (it2.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1$u._)`${data}.length`);
        gen.forRange("i", 0, len, (i2) => {
          cxt.subschema({
            keyword: keyword2,
            dataProp: i2,
            dataPropType: util_1$s.Type.Num
          }, valid);
          gen.if((0, codegen_1$u.not)(valid), notValid);
        });
      }
    }
    code$1.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema: schema2, keyword: keyword2, it: it2 } = cxt;
      if (!Array.isArray(schema2))
        throw new Error("ajv implementation error");
      const alwaysValid = schema2.some((sch) => (0, util_1$s.alwaysValidSchema)(it2, sch));
      if (alwaysValid && !it2.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema2.forEach((_sch, i2) => {
        const schCxt = cxt.subschema({
          keyword: keyword2,
          schemaProp: i2,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1$u._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1$u.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    code$1.validateUnion = validateUnion;
    Object.defineProperty(keyword, "__esModule", { value: true });
    keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
    const codegen_1$t = codegen;
    const names_1$7 = names$2;
    const code_1$9 = code$1;
    const errors_1$1 = errors$1;
    function macroKeywordCode(cxt, def2) {
      const { gen, keyword: keyword2, schema: schema2, parentSchema, it: it2 } = cxt;
      const macroSchema = def2.macro.call(it2.self, schema2, parentSchema, it2);
      const schemaRef = useKeyword(gen, keyword2, macroSchema);
      if (it2.opts.validateSchema !== false)
        it2.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1$t.nil,
        errSchemaPath: `${it2.errSchemaPath}/${keyword2}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    keyword.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def2) {
      var _a2;
      const { gen, keyword: keyword2, schema: schema2, parentSchema, $data, it: it2 } = cxt;
      checkAsyncKeyword(it2, def2);
      const validate2 = !$data && def2.compile ? def2.compile.call(it2.self, schema2, parentSchema, it2) : def2.validate;
      const validateRef = useKeyword(gen, keyword2, validate2);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a2 = def2.valid) !== null && _a2 !== void 0 ? _a2 : valid);
      function validateKeyword() {
        if (def2.errors === false) {
          assignValid();
          if (def2.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def2.async ? validateAsync() : validateSync();
          if (def2.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1$t._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1$t._)`${e} instanceof ${it2.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1$t._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1$t._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1$t.nil);
        return validateErrs;
      }
      function assignValid(_await = def2.async ? (0, codegen_1$t._)`await ` : codegen_1$t.nil) {
        const passCxt = it2.opts.passContext ? names_1$7.default.this : names_1$7.default.self;
        const passSchema = !("compile" in def2 && !$data || def2.schema === false);
        gen.assign(valid, (0, codegen_1$t._)`${_await}${(0, code_1$9.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def2.modifying);
      }
      function reportErrs(errors2) {
        var _a3;
        gen.if((0, codegen_1$t.not)((_a3 = def2.valid) !== null && _a3 !== void 0 ? _a3 : valid), errors2);
      }
    }
    keyword.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it: it2 } = cxt;
      gen.if(it2.parentData, () => gen.assign(data, (0, codegen_1$t._)`${it2.parentData}[${it2.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1$t._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1$7.default.vErrors, (0, codegen_1$t._)`${names_1$7.default.vErrors} === null ? ${errs} : ${names_1$7.default.vErrors}.concat(${errs})`).assign(names_1$7.default.errors, (0, codegen_1$t._)`${names_1$7.default.vErrors}.length`);
        (0, errors_1$1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def2) {
      if (def2.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword2, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword2}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1$t.stringify)(result) });
    }
    function validSchemaType(schema2, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema2) : st === "object" ? schema2 && typeof schema2 == "object" && !Array.isArray(schema2) : typeof schema2 == st || allowUndefined && typeof schema2 == "undefined");
    }
    keyword.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema: schema2, opts, self: self2, errSchemaPath }, def2, keyword2) {
      if (Array.isArray(def2.keyword) ? !def2.keyword.includes(keyword2) : def2.keyword !== keyword2) {
        throw new Error("ajv implementation error");
      }
      const deps = def2.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema2, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
      }
      if (def2.validateSchema) {
        const valid = def2.validateSchema(schema2[keyword2]);
        if (!valid) {
          const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def2.validateSchema.errors);
          if (opts.validateSchema === "log")
            self2.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    keyword.validateKeywordUsage = validateKeywordUsage;
    var subschema = {};
    Object.defineProperty(subschema, "__esModule", { value: true });
    subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
    const codegen_1$s = codegen;
    const util_1$r = util;
    function getSubschema(it2, { keyword: keyword2, schemaProp, schema: schema2, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword2 !== void 0 && schema2 !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword2 !== void 0) {
        const sch = it2.schema[keyword2];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1$s._)`${it2.schemaPath}${(0, codegen_1$s.getProperty)(keyword2)}`,
          errSchemaPath: `${it2.errSchemaPath}/${keyword2}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1$s._)`${it2.schemaPath}${(0, codegen_1$s.getProperty)(keyword2)}${(0, codegen_1$s.getProperty)(schemaProp)}`,
          errSchemaPath: `${it2.errSchemaPath}/${keyword2}/${(0, util_1$r.escapeFragment)(schemaProp)}`
        };
      }
      if (schema2 !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema: schema2,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    subschema.getSubschema = getSubschema;
    function extendSubschemaData(subschema2, it2, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it2;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it2;
        const nextData = gen.let("data", (0, codegen_1$s._)`${it2.data}${(0, codegen_1$s.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema2.errorPath = (0, codegen_1$s.str)`${errorPath}${(0, util_1$r.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema2.parentDataProperty = (0, codegen_1$s._)`${dataProp}`;
        subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1$s.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema2.propertyName = propertyName;
      }
      if (dataTypes)
        subschema2.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema2.data = _nextData;
        subschema2.dataLevel = it2.dataLevel + 1;
        subschema2.dataTypes = [];
        it2.definedProperties = /* @__PURE__ */ new Set();
        subschema2.parentData = it2.data;
        subschema2.dataNames = [...it2.dataNames, _nextData];
      }
    }
    subschema.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema2.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema2.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema2.allErrors = allErrors;
      subschema2.jtdDiscriminator = jtdDiscriminator;
      subschema2.jtdMetadata = jtdMetadata;
    }
    subschema.extendSubschemaMode = extendSubschemaMode;
    var resolve$2 = {};
    var fastDeepEqual = function equal2(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i2, keys2;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i2 = length; i2-- !== 0; )
            if (!equal2(a[i2], b[i2]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys2 = Object.keys(a);
        length = keys2.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i2 = length; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys2[i2]))
            return false;
        for (i2 = length; i2-- !== 0; ) {
          var key = keys2[i2];
          if (!equal2(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
    var jsonSchemaTraverse = { exports: {} };
    var traverse$1 = jsonSchemaTraverse.exports = function(schema2, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre2 = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre2, post, schema2, "", schema2);
    };
    traverse$1.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse$1.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse$1.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse$1.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre2, post, schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema2 && typeof schema2 == "object" && !Array.isArray(schema2)) {
        pre2(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema2) {
          var sch = schema2[key];
          if (Array.isArray(sch)) {
            if (key in traverse$1.arrayKeywords) {
              for (var i2 = 0; i2 < sch.length; i2++)
                _traverse(opts, pre2, post, sch[i2], jsonPtr + "/" + key + "/" + i2, rootSchema, jsonPtr, key, schema2, i2);
            }
          } else if (key in traverse$1.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop2 in sch)
                _traverse(opts, pre2, post, sch[prop2], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop2), rootSchema, jsonPtr, key, schema2, prop2);
            }
          } else if (key in traverse$1.keywords || opts.allKeys && !(key in traverse$1.skipKeywords)) {
            _traverse(opts, pre2, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema2);
          }
        }
        post(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str2) {
      return str2.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    var jsonSchemaTraverseExports = jsonSchemaTraverse.exports;
    Object.defineProperty(resolve$2, "__esModule", { value: true });
    resolve$2.getSchemaRefs = resolve$2.resolveUrl = resolve$2.normalizeId = resolve$2._getFullPath = resolve$2.getFullPath = resolve$2.inlineRef = void 0;
    const util_1$q = util;
    const equal$3 = fastDeepEqual;
    const traverse = jsonSchemaTraverseExports;
    const SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema2, limit2 = true) {
      if (typeof schema2 == "boolean")
        return true;
      if (limit2 === true)
        return !hasRef(schema2);
      if (!limit2)
        return false;
      return countKeys(schema2) <= limit2;
    }
    resolve$2.inlineRef = inlineRef;
    const REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema2) {
      for (const key in schema2) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema2[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema2) {
      let count = 0;
      for (const key in schema2) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema2[key] == "object") {
          (0, util_1$q.eachItem)(schema2[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id2 = "", normalize2) {
      if (normalize2 !== false)
        id2 = normalizeId(id2);
      const p2 = resolver.parse(id2);
      return _getFullPath(resolver, p2);
    }
    resolve$2.getFullPath = getFullPath;
    function _getFullPath(resolver, p2) {
      const serialized = resolver.serialize(p2);
      return serialized.split("#")[0] + "#";
    }
    resolve$2._getFullPath = _getFullPath;
    const TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id2) {
      return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
    }
    resolve$2.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id2) {
      id2 = normalizeId(id2);
      return resolver.resolve(baseId, id2);
    }
    resolve$2.resolveUrl = resolveUrl;
    const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema2, baseId) {
      if (typeof schema2 == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema2[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema2, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref2) {
          const _resolve = this.opts.uriResolver.resolve;
          ref2 = normalizeId(innerBaseId ? _resolve(innerBaseId, ref2) : ref2);
          if (schemaRefs.has(ref2))
            throw ambiguos(ref2);
          schemaRefs.add(ref2);
          let schOrRef = this.refs[ref2];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref2);
          } else if (ref2 !== normalizeId(fullPath)) {
            if (ref2[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref2], ref2);
              localRefs[ref2] = sch;
            } else {
              this.refs[ref2] = fullPath;
            }
          }
          return ref2;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref2) {
        if (sch2 !== void 0 && !equal$3(sch1, sch2))
          throw ambiguos(ref2);
      }
      function ambiguos(ref2) {
        return new Error(`reference "${ref2}" resolves to more than one schema`);
      }
    }
    resolve$2.getSchemaRefs = getSchemaRefs;
    Object.defineProperty(validate, "__esModule", { value: true });
    validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
    const boolSchema_1 = boolSchema;
    const dataType_1$1 = dataType;
    const applicability_1 = applicability;
    const dataType_2 = dataType;
    const defaults_1 = defaults;
    const keyword_1 = keyword;
    const subschema_1 = subschema;
    const codegen_1$r = codegen;
    const names_1$6 = names$2;
    const resolve_1$2 = resolve$2;
    const util_1$p = util;
    const errors_1 = errors$1;
    function validateFunctionCode(it2) {
      if (isSchemaObj(it2)) {
        checkKeywords(it2);
        if (schemaCxtHasRules(it2)) {
          topSchemaObjCode(it2);
          return;
        }
      }
      validateFunction(it2, () => (0, boolSchema_1.topBoolOrEmptySchema)(it2));
    }
    validate.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema: schema2, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1$r._)`${names_1$6.default.data}, ${names_1$6.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1$r._)`"use strict"; ${funcSourceUrl(schema2, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1$r._)`${names_1$6.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema2, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1$r._)`{${names_1$6.default.instancePath}="", ${names_1$6.default.parentData}, ${names_1$6.default.parentDataProperty}, ${names_1$6.default.rootData}=${names_1$6.default.data}${opts.dynamicRef ? (0, codegen_1$r._)`, ${names_1$6.default.dynamicAnchors}={}` : codegen_1$r.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1$6.default.valCxt, () => {
        gen.var(names_1$6.default.instancePath, (0, codegen_1$r._)`${names_1$6.default.valCxt}.${names_1$6.default.instancePath}`);
        gen.var(names_1$6.default.parentData, (0, codegen_1$r._)`${names_1$6.default.valCxt}.${names_1$6.default.parentData}`);
        gen.var(names_1$6.default.parentDataProperty, (0, codegen_1$r._)`${names_1$6.default.valCxt}.${names_1$6.default.parentDataProperty}`);
        gen.var(names_1$6.default.rootData, (0, codegen_1$r._)`${names_1$6.default.valCxt}.${names_1$6.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1$6.default.dynamicAnchors, (0, codegen_1$r._)`${names_1$6.default.valCxt}.${names_1$6.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1$6.default.instancePath, (0, codegen_1$r._)`""`);
        gen.var(names_1$6.default.parentData, (0, codegen_1$r._)`undefined`);
        gen.var(names_1$6.default.parentDataProperty, (0, codegen_1$r._)`undefined`);
        gen.var(names_1$6.default.rootData, names_1$6.default.data);
        if (opts.dynamicRef)
          gen.var(names_1$6.default.dynamicAnchors, (0, codegen_1$r._)`{}`);
      });
    }
    function topSchemaObjCode(it2) {
      const { schema: schema2, opts, gen } = it2;
      validateFunction(it2, () => {
        if (opts.$comment && schema2.$comment)
          commentKeyword(it2);
        checkNoDefault(it2);
        gen.let(names_1$6.default.vErrors, null);
        gen.let(names_1$6.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it2);
        typeAndKeywords(it2);
        returnResults(it2);
      });
      return;
    }
    function resetEvaluated(it2) {
      const { gen, validateName } = it2;
      it2.evaluated = gen.const("evaluated", (0, codegen_1$r._)`${validateName}.evaluated`);
      gen.if((0, codegen_1$r._)`${it2.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1$r._)`${it2.evaluated}.props`, (0, codegen_1$r._)`undefined`));
      gen.if((0, codegen_1$r._)`${it2.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1$r._)`${it2.evaluated}.items`, (0, codegen_1$r._)`undefined`));
    }
    function funcSourceUrl(schema2, opts) {
      const schId = typeof schema2 == "object" && schema2[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1$r._)`/*# sourceURL=${schId} */` : codegen_1$r.nil;
    }
    function subschemaCode(it2, valid) {
      if (isSchemaObj(it2)) {
        checkKeywords(it2);
        if (schemaCxtHasRules(it2)) {
          subSchemaObjCode(it2, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it2, valid);
    }
    function schemaCxtHasRules({ schema: schema2, self: self2 }) {
      if (typeof schema2 == "boolean")
        return !schema2;
      for (const key in schema2)
        if (self2.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it2) {
      return typeof it2.schema != "boolean";
    }
    function subSchemaObjCode(it2, valid) {
      const { schema: schema2, gen, opts } = it2;
      if (opts.$comment && schema2.$comment)
        commentKeyword(it2);
      updateContext(it2);
      checkAsyncSchema(it2);
      const errsCount = gen.const("_errs", names_1$6.default.errors);
      typeAndKeywords(it2, errsCount);
      gen.var(valid, (0, codegen_1$r._)`${errsCount} === ${names_1$6.default.errors}`);
    }
    function checkKeywords(it2) {
      (0, util_1$p.checkUnknownRules)(it2);
      checkRefsAndKeywords(it2);
    }
    function typeAndKeywords(it2, errsCount) {
      if (it2.opts.jtd)
        return schemaKeywords(it2, [], false, errsCount);
      const types2 = (0, dataType_1$1.getSchemaTypes)(it2.schema);
      const checkedTypes = (0, dataType_1$1.coerceAndCheckDataType)(it2, types2);
      schemaKeywords(it2, types2, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it2) {
      const { schema: schema2, errSchemaPath, opts, self: self2 } = it2;
      if (schema2.$ref && opts.ignoreKeywordsWithRef && (0, util_1$p.schemaHasRulesButRef)(schema2, self2.RULES)) {
        self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it2) {
      const { schema: schema2, opts } = it2;
      if (schema2.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1$p.checkStrictMode)(it2, "default is ignored in the schema root");
      }
    }
    function updateContext(it2) {
      const schId = it2.schema[it2.opts.schemaId];
      if (schId)
        it2.baseId = (0, resolve_1$2.resolveUrl)(it2.opts.uriResolver, it2.baseId, schId);
    }
    function checkAsyncSchema(it2) {
      if (it2.schema.$async && !it2.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema: schema2, errSchemaPath, opts }) {
      const msg = schema2.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1$r._)`${names_1$6.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1$r.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1$r._)`${names_1$6.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it2) {
      const { gen, schemaEnv, validateName, ValidationError: ValidationError2, opts } = it2;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1$r._)`${names_1$6.default.errors} === 0`, () => gen.return(names_1$6.default.data), () => gen.throw((0, codegen_1$r._)`new ${ValidationError2}(${names_1$6.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1$r._)`${validateName}.errors`, names_1$6.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it2);
        gen.return((0, codegen_1$r._)`${names_1$6.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items: items2 }) {
      if (props instanceof codegen_1$r.Name)
        gen.assign((0, codegen_1$r._)`${evaluated}.props`, props);
      if (items2 instanceof codegen_1$r.Name)
        gen.assign((0, codegen_1$r._)`${evaluated}.items`, items2);
    }
    function schemaKeywords(it2, types2, typeErrors, errsCount) {
      const { gen, schema: schema2, data, allErrors, opts, self: self2 } = it2;
      const { RULES: RULES2 } = self2;
      if (schema2.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1$p.schemaHasRulesButRef)(schema2, RULES2))) {
        gen.block(() => keywordCode(it2, "$ref", RULES2.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it2, types2);
      gen.block(() => {
        for (const group of RULES2.rules)
          groupKeywords(group);
        groupKeywords(RULES2.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema2, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it2, group);
          if (types2.length === 1 && types2[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it2);
          }
          gen.endIf();
        } else {
          iterateKeywords(it2, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1$r._)`${names_1$6.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it2, group) {
      const { gen, schema: schema2, opts: { useDefaults: useDefaults2 } } = it2;
      if (useDefaults2)
        (0, defaults_1.assignDefaults)(it2, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema2, rule)) {
            keywordCode(it2, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it2, types2) {
      if (it2.schemaEnv.meta || !it2.opts.strictTypes)
        return;
      checkContextTypes(it2, types2);
      if (!it2.opts.allowUnionTypes)
        checkMultipleTypes(it2, types2);
      checkKeywordTypes(it2, it2.dataTypes);
    }
    function checkContextTypes(it2, types2) {
      if (!types2.length)
        return;
      if (!it2.dataTypes.length) {
        it2.dataTypes = types2;
        return;
      }
      types2.forEach((t) => {
        if (!includesType(it2.dataTypes, t)) {
          strictTypesError(it2, `type "${t}" not allowed by context "${it2.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it2, types2);
    }
    function checkMultipleTypes(it2, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it2, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it2, ts) {
      const rules2 = it2.self.RULES.all;
      for (const keyword2 in rules2) {
        const rule = rules2[keyword2];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it2.schema, rule)) {
          const { type: type2 } = rule.definition;
          if (type2.length && !type2.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it2, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it2, withTypes) {
      const ts = [];
      for (const t of it2.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it2.dataTypes = ts;
    }
    function strictTypesError(it2, msg) {
      const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1$p.checkStrictMode)(it2, msg, it2.opts.strictTypes);
    }
    class KeywordCxt {
      constructor(it2, def2, keyword2) {
        (0, keyword_1.validateKeywordUsage)(it2, def2, keyword2);
        this.gen = it2.gen;
        this.allErrors = it2.allErrors;
        this.keyword = keyword2;
        this.data = it2.data;
        this.schema = it2.schema[keyword2];
        this.$data = def2.$data && it2.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1$p.schemaRefOrVal)(it2, this.schema, keyword2, this.$data);
        this.schemaType = def2.schemaType;
        this.parentSchema = it2.schema;
        this.params = {};
        this.it = it2;
        this.def = def2;
        if (this.$data) {
          this.schemaCode = it2.gen.const("vSchema", getData(this.$data, it2));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def2.schemaType, def2.allowUndefined)) {
            throw new Error(`${keyword2} value must be ${JSON.stringify(def2.schemaType)}`);
          }
        }
        if ("code" in def2 ? def2.trackErrors : def2.errors !== false) {
          this.errsCount = it2.gen.const("_errs", names_1$6.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1$r.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1$r.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1$r._)`${schemaCode} !== undefined && (${(0, codegen_1$r.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign2) {
        if (assign2)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1$r.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1$r.nil, $dataValid = codegen_1$r.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def: def2 } = this;
        gen.if((0, codegen_1$r.or)((0, codegen_1$r._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1$r.nil)
          gen.assign(valid, true);
        if (schemaType.length || def2.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1$r.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def: def2, it: it2 } = this;
        return (0, codegen_1$r.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1$r.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1$r._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it2.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1$r.nil;
        }
        function invalid$DataSchema() {
          if (def2.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def2.validateSchema });
            return (0, codegen_1$r._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1$r.nil;
        }
      }
      subschema(appl, valid) {
        const subschema2 = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema2, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema2, appl);
        const nextContext = { ...this.it, ...subschema2, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it: it2, gen } = this;
        if (!it2.opts.unevaluated)
          return;
        if (it2.props !== true && schemaCxt.props !== void 0) {
          it2.props = util_1$p.mergeEvaluated.props(gen, schemaCxt.props, it2.props, toName);
        }
        if (it2.items !== true && schemaCxt.items !== void 0) {
          it2.items = util_1$p.mergeEvaluated.items(gen, schemaCxt.items, it2.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it: it2, gen } = this;
        if (it2.opts.unevaluated && (it2.props !== true || it2.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1$r.Name));
          return true;
        }
      }
    }
    validate.KeywordCxt = KeywordCxt;
    function keywordCode(it2, keyword2, def2, ruleType) {
      const cxt = new KeywordCxt(it2, def2, keyword2);
      if ("code" in def2) {
        def2.code(cxt, ruleType);
      } else if (cxt.$data && def2.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def2);
      } else if ("macro" in def2) {
        (0, keyword_1.macroKeywordCode)(cxt, def2);
      } else if (def2.compile || def2.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def2);
      }
    }
    const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1$6.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1$6.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1$r._)`${data}${(0, codegen_1$r.getProperty)((0, util_1$p.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1$r._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    validate.getData = getData;
    var validation_error = {};
    Object.defineProperty(validation_error, "__esModule", { value: true });
    class ValidationError extends Error {
      constructor(errors2) {
        super("validation failed");
        this.errors = errors2;
        this.ajv = this.validation = true;
      }
    }
    validation_error.default = ValidationError;
    var ref_error = {};
    Object.defineProperty(ref_error, "__esModule", { value: true });
    const resolve_1$1 = resolve$2;
    class MissingRefError extends Error {
      constructor(resolver, baseId, ref2, msg) {
        super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
        this.missingRef = (0, resolve_1$1.resolveUrl)(resolver, baseId, ref2);
        this.missingSchema = (0, resolve_1$1.normalizeId)((0, resolve_1$1.getFullPath)(resolver, this.missingRef));
      }
    }
    ref_error.default = MissingRefError;
    var compile$2 = {};
    Object.defineProperty(compile$2, "__esModule", { value: true });
    compile$2.resolveSchema = compile$2.getCompilingSchema = compile$2.resolveRef = compile$2.compileSchema = compile$2.SchemaEnv = void 0;
    const codegen_1$q = codegen;
    const validation_error_1 = validation_error;
    const names_1$5 = names$2;
    const resolve_1 = resolve$2;
    const util_1$o = util;
    const validate_1$1 = validate;
    class SchemaEnv {
      constructor(env) {
        var _a2;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema2;
        if (typeof env.schema == "object")
          schema2 = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a2 = env.baseId) !== null && _a2 !== void 0 ? _a2 : (0, resolve_1.normalizeId)(schema2 === null || schema2 === void 0 ? void 0 : schema2[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema2 === null || schema2 === void 0 ? void 0 : schema2.$async;
        this.refs = {};
      }
    }
    compile$2.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1$q.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1$q._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1$5.default.data,
        parentData: names_1$5.default.parentData,
        parentDataProperty: names_1$5.default.parentDataProperty,
        dataNames: [names_1$5.default.data],
        dataPathArr: [codegen_1$q.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1$q.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1$q.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1$q._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1$1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1$5.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1$5.default.self}`, `${names_1$5.default.scope}`, sourceCode);
        const validate2 = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate2 });
        validate2.errors = null;
        validate2.schema = sch.schema;
        validate2.schemaEnv = sch;
        if (sch.$async)
          validate2.$async = true;
        if (this.opts.code.source === true) {
          validate2.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items: items2 } = schemaCxt;
          validate2.evaluated = {
            props: props instanceof codegen_1$q.Name ? void 0 : props,
            items: items2 instanceof codegen_1$q.Name ? void 0 : items2,
            dynamicProps: props instanceof codegen_1$q.Name,
            dynamicItems: items2 instanceof codegen_1$q.Name
          };
          if (validate2.source)
            validate2.source.evaluated = (0, codegen_1$q.stringify)(validate2.evaluated);
        }
        sch.validate = validate2;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    compile$2.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref2) {
      var _a2;
      ref2 = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref2);
      const schOrFunc = root.refs[ref2];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve$1.call(this, root, ref2);
      if (_sch === void 0) {
        const schema2 = (_a2 = root.localRefs) === null || _a2 === void 0 ? void 0 : _a2[ref2];
        const { schemaId } = this.opts;
        if (schema2)
          _sch = new SchemaEnv({ schema: schema2, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref2] = inlineOrCompile.call(this, _sch);
    }
    compile$2.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    compile$2.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve$1(root, ref2) {
      let sch;
      while (typeof (sch = this.refs[ref2]) == "string")
        ref2 = sch;
      return sch || this.schemas[ref2] || resolveSchema.call(this, root, ref2);
    }
    function resolveSchema(root, ref2) {
      const p2 = this.opts.uriResolver.parse(ref2);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p2);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p2, root);
      }
      const id2 = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id2] || this.schemas[id2];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p2, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id2 === (0, resolve_1.normalizeId)(ref2)) {
        const { schema: schema2 } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema2[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema: schema2, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p2, schOrRef);
    }
    compile$2.resolveSchema = resolveSchema;
    const PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema: schema2, root }) {
      var _a2;
      if (((_a2 = parsedRef.fragment) === null || _a2 === void 0 ? void 0 : _a2[0]) !== "/")
        return;
      for (const part2 of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema2 === "boolean")
          return;
        const partSchema = schema2[(0, util_1$o.unescapeFragment)(part2)];
        if (partSchema === void 0)
          return;
        schema2 = partSchema;
        const schId = typeof schema2 === "object" && schema2[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part2) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema2 != "boolean" && schema2.$ref && !(0, util_1$o.schemaHasRulesButRef)(schema2, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema2.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema: schema2, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
    const $id$8 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
    const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
    const type$8 = "object";
    const required$1 = [
      "$data"
    ];
    const properties$9 = {
      $data: {
        type: "string",
        anyOf: [
          {
            format: "relative-json-pointer"
          },
          {
            format: "json-pointer"
          }
        ]
      }
    };
    const additionalProperties$1 = false;
    const require$$9 = {
      $id: $id$8,
      description,
      type: type$8,
      required: required$1,
      properties: properties$9,
      additionalProperties: additionalProperties$1
    };
    var uri$1 = {};
    var fastUri$1 = { exports: {} };
    const HEX$1 = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    var scopedChars = {
      HEX: HEX$1
    };
    const { HEX } = scopedChars;
    function normalizeIPv4$1(host) {
      if (findToken(host, ".") < 3) {
        return { host, isIPV4: false };
      }
      const matches = host.match(/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/u) || [];
      const [address] = matches;
      if (address) {
        return { host: stripLeadingZeros(address, "."), isIPV4: true };
      } else {
        return { host, isIPV4: false };
      }
    }
    function stringArrayToHexStripped(input, keepZero = false) {
      let acc = "";
      let strip = true;
      for (const c of input) {
        if (HEX[c] === void 0)
          return void 0;
        if (c !== "0" && strip === true)
          strip = false;
        if (!strip)
          acc += c;
      }
      if (keepZero && acc.length === 0)
        acc = "0";
      return acc;
    }
    function getIPV6(input) {
      let tokenCount = 0;
      const output = { error: false, address: "", zone: "" };
      const address = [];
      const buffer = [];
      let isZone = false;
      let endipv6Encountered = false;
      let endIpv6 = false;
      function consume() {
        if (buffer.length) {
          if (isZone === false) {
            const hex2 = stringArrayToHexStripped(buffer);
            if (hex2 !== void 0) {
              address.push(hex2);
            } else {
              output.error = true;
              return false;
            }
          }
          buffer.length = 0;
        }
        return true;
      }
      for (let i2 = 0; i2 < input.length; i2++) {
        const cursor = input[i2];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume()) {
            break;
          }
          tokenCount++;
          address.push(":");
          if (tokenCount > 7) {
            output.error = true;
            break;
          }
          if (i2 - 1 >= 0 && input[i2 - 1] === ":") {
            endipv6Encountered = true;
          }
          continue;
        } else if (cursor === "%") {
          if (!consume()) {
            break;
          }
          isZone = true;
        } else {
          buffer.push(cursor);
          continue;
        }
      }
      if (buffer.length) {
        if (isZone) {
          output.zone = buffer.join("");
        } else if (endIpv6) {
          address.push(buffer.join(""));
        } else {
          address.push(stringArrayToHexStripped(buffer));
        }
      }
      output.address = address.join("");
      return output;
    }
    function normalizeIPv6$1(host, opts = {}) {
      if (findToken(host, ":") < 2) {
        return { host, isIPV6: false };
      }
      const ipv6 = getIPV6(host);
      if (!ipv6.error) {
        let newHost = ipv6.address;
        let escapedHost = ipv6.address;
        if (ipv6.zone) {
          newHost += "%" + ipv6.zone;
          escapedHost += "%25" + ipv6.zone;
        }
        return { host: newHost, escapedHost, isIPV6: true };
      } else {
        return { host, isIPV6: false };
      }
    }
    function stripLeadingZeros(str2, token2) {
      let out = "";
      let skip = true;
      const l = str2.length;
      for (let i2 = 0; i2 < l; i2++) {
        const c = str2[i2];
        if (c === "0" && skip) {
          if (i2 + 1 <= l && str2[i2 + 1] === token2 || i2 + 1 === l) {
            out += c;
            skip = false;
          }
        } else {
          if (c === token2) {
            skip = true;
          } else {
            skip = false;
          }
          out += c;
        }
      }
      return out;
    }
    function findToken(str2, token2) {
      let ind = 0;
      for (let i2 = 0; i2 < str2.length; i2++) {
        if (str2[i2] === token2)
          ind++;
      }
      return ind;
    }
    const RDS1 = /^\.\.?\//u;
    const RDS2 = /^\/\.(?:\/|$)/u;
    const RDS3 = /^\/\.\.(?:\/|$)/u;
    const RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
    function removeDotSegments$1(input) {
      const output = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          const im = input.match(RDS5);
          if (im) {
            const s = im[0];
            input = input.slice(s.length);
            output.push(s);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output.join("");
    }
    function normalizeComponentEncoding$1(components, esc) {
      const func = esc !== true ? escape : unescape;
      if (components.scheme !== void 0) {
        components.scheme = func(components.scheme);
      }
      if (components.userinfo !== void 0) {
        components.userinfo = func(components.userinfo);
      }
      if (components.host !== void 0) {
        components.host = func(components.host);
      }
      if (components.path !== void 0) {
        components.path = func(components.path);
      }
      if (components.query !== void 0) {
        components.query = func(components.query);
      }
      if (components.fragment !== void 0) {
        components.fragment = func(components.fragment);
      }
      return components;
    }
    function recomposeAuthority$1(components, options) {
      const uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        let host = unescape(components.host);
        const ipV4res = normalizeIPv4$1(host);
        if (ipV4res.isIPV4) {
          host = ipV4res.host;
        } else {
          const ipV6res = normalizeIPv6$1(ipV4res.host, { isIPV4: false });
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = components.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    var utils$2 = {
      recomposeAuthority: recomposeAuthority$1,
      normalizeComponentEncoding: normalizeComponentEncoding$1,
      removeDotSegments: removeDotSegments$1,
      normalizeIPv4: normalizeIPv4$1,
      normalizeIPv6: normalizeIPv6$1,
      stringArrayToHexStripped
    };
    const UUID_REG = /^[\da-f]{8}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{12}$/iu;
    const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    function httpParse(components) {
      if (!components.host) {
        components.error = components.error || "HTTP URIs must have a host.";
      }
      return components;
    }
    function httpSerialize(components) {
      const secure = String(components.scheme).toLowerCase() === "https";
      if (components.port === (secure ? 443 : 80) || components.port === "") {
        components.port = void 0;
      }
      if (!components.path) {
        components.path = "/";
      }
      return components;
    }
    function wsParse(wsComponents) {
      wsComponents.secure = isSecure(wsComponents);
      wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
      wsComponents.path = void 0;
      wsComponents.query = void 0;
      return wsComponents;
    }
    function wsSerialize(wsComponents) {
      if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
        wsComponents.port = void 0;
      }
      if (typeof wsComponents.secure === "boolean") {
        wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
        wsComponents.secure = void 0;
      }
      if (wsComponents.resourceName) {
        const [path, query] = wsComponents.resourceName.split("?");
        wsComponents.path = path && path !== "/" ? path : void 0;
        wsComponents.query = query;
        wsComponents.resourceName = void 0;
      }
      wsComponents.fragment = void 0;
      return wsComponents;
    }
    function urnParse(urnComponents, options) {
      if (!urnComponents.path) {
        urnComponents.error = "URN can not be parsed";
        return urnComponents;
      }
      const matches = urnComponents.path.match(URN_REG);
      if (matches) {
        const scheme = options.scheme || urnComponents.scheme || "urn";
        urnComponents.nid = matches[1].toLowerCase();
        urnComponents.nss = matches[2];
        const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
        const schemeHandler = SCHEMES$1[urnScheme];
        urnComponents.path = void 0;
        if (schemeHandler) {
          urnComponents = schemeHandler.parse(urnComponents, options);
        }
      } else {
        urnComponents.error = urnComponents.error || "URN can not be parsed.";
      }
      return urnComponents;
    }
    function urnSerialize(urnComponents, options) {
      const scheme = options.scheme || urnComponents.scheme || "urn";
      const nid = urnComponents.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = SCHEMES$1[urnScheme];
      if (schemeHandler) {
        urnComponents = schemeHandler.serialize(urnComponents, options);
      }
      const uriComponents = urnComponents;
      const nss = urnComponents.nss;
      uriComponents.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponents;
    }
    function urnuuidParse(urnComponents, options) {
      const uuidComponents = urnComponents;
      uuidComponents.uuid = uuidComponents.nss;
      uuidComponents.nss = void 0;
      if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
        uuidComponents.error = uuidComponents.error || "UUID is not valid.";
      }
      return uuidComponents;
    }
    function urnuuidSerialize(uuidComponents) {
      const urnComponents = uuidComponents;
      urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
      return urnComponents;
    }
    const http = {
      scheme: "http",
      domainHost: true,
      parse: httpParse,
      serialize: httpSerialize
    };
    const https = {
      scheme: "https",
      domainHost: http.domainHost,
      parse: httpParse,
      serialize: httpSerialize
    };
    const ws = {
      scheme: "ws",
      domainHost: true,
      parse: wsParse,
      serialize: wsSerialize
    };
    const wss = {
      scheme: "wss",
      domainHost: ws.domainHost,
      parse: ws.parse,
      serialize: ws.serialize
    };
    const urn = {
      scheme: "urn",
      parse: urnParse,
      serialize: urnSerialize,
      skipNormalize: true
    };
    const urnuuid = {
      scheme: "urn:uuid",
      parse: urnuuidParse,
      serialize: urnuuidSerialize,
      skipNormalize: true
    };
    const SCHEMES$1 = {
      http,
      https,
      ws,
      wss,
      urn,
      "urn:uuid": urnuuid
    };
    var schemes = SCHEMES$1;
    const { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = utils$2;
    const SCHEMES = schemes;
    function normalize$1(uri2, options) {
      if (typeof uri2 === "string") {
        uri2 = serialize(parse$1(uri2, options), options);
      } else if (typeof uri2 === "object") {
        uri2 = parse$1(serialize(uri2, options), options);
      }
      return uri2;
    }
    function resolve(baseURI, relativeURI, options) {
      const schemelessOptions = Object.assign({ scheme: "null" }, options);
      const resolved = resolveComponents(parse$1(baseURI, schemelessOptions), parse$1(relativeURI, schemelessOptions), schemelessOptions, true);
      return serialize(resolved, { ...schemelessOptions, skipEscape: true });
    }
    function resolveComponents(base2, relative, options, skipNormalization) {
      const target2 = {};
      if (!skipNormalization) {
        base2 = parse$1(serialize(base2, options), options);
        relative = parse$1(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target2.scheme = relative.scheme;
        target2.userinfo = relative.userinfo;
        target2.host = relative.host;
        target2.port = relative.port;
        target2.path = removeDotSegments(relative.path || "");
        target2.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target2.userinfo = relative.userinfo;
          target2.host = relative.host;
          target2.port = relative.port;
          target2.path = removeDotSegments(relative.path || "");
          target2.query = relative.query;
        } else {
          if (!relative.path) {
            target2.path = base2.path;
            if (relative.query !== void 0) {
              target2.query = relative.query;
            } else {
              target2.query = base2.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target2.path = removeDotSegments(relative.path);
            } else {
              if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                target2.path = "/" + relative.path;
              } else if (!base2.path) {
                target2.path = relative.path;
              } else {
                target2.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
              }
              target2.path = removeDotSegments(target2.path);
            }
            target2.query = relative.query;
          }
          target2.userinfo = base2.userinfo;
          target2.host = base2.host;
          target2.port = base2.port;
        }
        target2.scheme = base2.scheme;
      }
      target2.fragment = relative.fragment;
      return target2;
    }
    function equal$2(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse$1(uriA, options), true), { ...options, skipEscape: true });
      } else if (typeof uriA === "object") {
        uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse$1(uriB, options), true), { ...options, skipEscape: true });
      } else if (typeof uriB === "object") {
        uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      const components = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize)
        schemeHandler.serialize(components, options);
      if (components.path !== void 0) {
        if (!options.skipEscape) {
          components.path = escape(components.path);
          if (components.scheme !== void 0) {
            components.path = components.path.split("%3A").join(":");
          }
        } else {
          components.path = unescape(components.path);
        }
      }
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
      }
      const authority = recomposeAuthority(components, options);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        let s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0) {
          s = s.replace(/^\/\//u, "/%2F");
        }
        uriTokens.push(s);
      }
      if (components.query !== void 0) {
        uriTokens.push("?");
        uriTokens.push(components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
      }
      return uriTokens.join("");
    }
    const hexLookUp = Array.from({ length: 127 }, (v, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));
    function nonSimpleDomain(value) {
      let code2 = 0;
      for (let i2 = 0, len = value.length; i2 < len; ++i2) {
        code2 = value.charCodeAt(i2);
        if (code2 > 126 || hexLookUp[code2]) {
          return true;
        }
      }
      return false;
    }
    const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse$1(uri2, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      const gotEncoding = uri2.indexOf("%") !== -1;
      let isIP = false;
      if (options.reference === "suffix")
        uri2 = (options.scheme ? options.scheme + ":" : "") + "//" + uri2;
      const matches = uri2.match(URI_PARSE);
      if (matches) {
        parsed.scheme = matches[1];
        parsed.userinfo = matches[3];
        parsed.host = matches[4];
        parsed.port = parseInt(matches[5], 10);
        parsed.path = matches[6] || "";
        parsed.query = matches[7];
        parsed.fragment = matches[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches[5];
        }
        if (parsed.host) {
          const ipv4result = normalizeIPv4(parsed.host);
          if (ipv4result.isIPV4 === false) {
            const ipv6result = normalizeIPv6(ipv4result.host, { isIPV4: false });
            parsed.host = ipv6result.host.toLowerCase();
            isIP = ipv6result.isIPV6;
          } else {
            parsed.host = ipv4result.host;
            isIP = true;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && !parsed.path && parsed.query === void 0) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (gotEncoding && parsed.scheme !== void 0) {
            parsed.scheme = unescape(parsed.scheme);
          }
          if (gotEncoding && parsed.userinfo !== void 0) {
            parsed.userinfo = unescape(parsed.userinfo);
          }
          if (gotEncoding && parsed.host !== void 0) {
            parsed.host = unescape(parsed.host);
          }
          if (parsed.path !== void 0 && parsed.path.length) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment !== void 0 && parsed.fragment.length) {
            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    const fastUri = {
      SCHEMES,
      normalize: normalize$1,
      resolve,
      resolveComponents,
      equal: equal$2,
      serialize,
      parse: parse$1
    };
    fastUri$1.exports = fastUri;
    fastUri$1.exports.default = fastUri;
    fastUri$1.exports.fastUri = fastUri;
    var fastUriExports = fastUri$1.exports;
    Object.defineProperty(uri$1, "__esModule", { value: true });
    const uri = fastUriExports;
    uri.code = 'require("ajv/dist/runtime/uri").default';
    uri$1.default = uri;
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
      var validate_12 = validate;
      Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
        return validate_12.KeywordCxt;
      } });
      var codegen_12 = codegen;
      Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
        return codegen_12._;
      } });
      Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
        return codegen_12.str;
      } });
      Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
        return codegen_12.stringify;
      } });
      Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
        return codegen_12.nil;
      } });
      Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
        return codegen_12.Name;
      } });
      Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
        return codegen_12.CodeGen;
      } });
      const validation_error_12 = validation_error;
      const ref_error_12 = ref_error;
      const rules_12 = rules;
      const compile_12 = compile$2;
      const codegen_2 = codegen;
      const resolve_12 = resolve$2;
      const dataType_12 = dataType;
      const util_12 = util;
      const $dataRefSchema = require$$9;
      const uri_1 = uri$1;
      const defaultRegExp = (str2, flags) => new RegExp(str2, flags);
      defaultRegExp.code = "new RegExp";
      const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
      const EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
        "validate",
        "serialize",
        "parse",
        "wrapper",
        "root",
        "schema",
        "keyword",
        "pattern",
        "formats",
        "validate$data",
        "func",
        "obj",
        "Error"
      ]);
      const removedOptions = {
        errorDataPath: "",
        format: "`validateFormats: false` can be used instead.",
        nullable: '"nullable" keyword is supported by default.',
        jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
        extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
        missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
        processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
        sourceCode: "Use option `code: {source: true}`",
        strictDefaults: "It is default now, see option `strict`.",
        strictKeywords: "It is default now, see option `strict`.",
        uniqueItems: '"uniqueItems" keyword is always validated.',
        unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
        cache: "Map is used as cache, schema object as key.",
        serialize: "Map is used as cache, schema object as key.",
        ajvErrors: "It is default now."
      };
      const deprecatedOptions = {
        ignoreKeywordsWithRef: "",
        jsPropertySyntax: "",
        unicode: '"minLength"/"maxLength" account for unicode characters by default.'
      };
      const MAX_EXPRESSION = 200;
      function requiredOptions(o2) {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
        const s = o2.strict;
        const _optz = (_a2 = o2.code) === null || _a2 === void 0 ? void 0 : _a2.optimize;
        const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
        const regExp = (_c = (_b = o2.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
        const uriResolver = (_d = o2.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
        return {
          strictSchema: (_f = (_e = o2.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
          strictNumbers: (_h = (_g = o2.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
          strictTypes: (_k = (_j = o2.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
          strictTuples: (_m = (_l = o2.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
          strictRequired: (_p = (_o = o2.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
          code: o2.code ? { ...o2.code, optimize, regExp } : { optimize, regExp },
          loopRequired: (_q = o2.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
          loopEnum: (_r = o2.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
          meta: (_s = o2.meta) !== null && _s !== void 0 ? _s : true,
          messages: (_t = o2.messages) !== null && _t !== void 0 ? _t : true,
          inlineRefs: (_u = o2.inlineRefs) !== null && _u !== void 0 ? _u : true,
          schemaId: (_v = o2.schemaId) !== null && _v !== void 0 ? _v : "$id",
          addUsedSchema: (_w = o2.addUsedSchema) !== null && _w !== void 0 ? _w : true,
          validateSchema: (_x = o2.validateSchema) !== null && _x !== void 0 ? _x : true,
          validateFormats: (_y = o2.validateFormats) !== null && _y !== void 0 ? _y : true,
          unicodeRegExp: (_z = o2.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
          int32range: (_0 = o2.int32range) !== null && _0 !== void 0 ? _0 : true,
          uriResolver
        };
      }
      class Ajv2 {
        constructor(opts = {}) {
          this.schemas = {};
          this.refs = {};
          this.formats = {};
          this._compilations = /* @__PURE__ */ new Set();
          this._loading = {};
          this._cache = /* @__PURE__ */ new Map();
          opts = this.opts = { ...opts, ...requiredOptions(opts) };
          const { es5, lines } = this.opts.code;
          this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
          this.logger = getLogger(opts.logger);
          const formatOpt = opts.validateFormats;
          opts.validateFormats = false;
          this.RULES = (0, rules_12.getRules)();
          checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
          checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
          this._metaOpts = getMetaSchemaOptions.call(this);
          if (opts.formats)
            addInitialFormats.call(this);
          this._addVocabularies();
          this._addDefaultMetaSchema();
          if (opts.keywords)
            addInitialKeywords.call(this, opts.keywords);
          if (typeof opts.meta == "object")
            this.addMetaSchema(opts.meta);
          addInitialSchemas.call(this);
          opts.validateFormats = formatOpt;
        }
        _addVocabularies() {
          this.addKeyword("$async");
        }
        _addDefaultMetaSchema() {
          const { $data, meta, schemaId } = this.opts;
          let _dataRefSchema = $dataRefSchema;
          if (schemaId === "id") {
            _dataRefSchema = { ...$dataRefSchema };
            _dataRefSchema.id = _dataRefSchema.$id;
            delete _dataRefSchema.$id;
          }
          if (meta && $data)
            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
        }
        defaultMeta() {
          const { meta, schemaId } = this.opts;
          return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
        }
        validate(schemaKeyRef, data) {
          let v;
          if (typeof schemaKeyRef == "string") {
            v = this.getSchema(schemaKeyRef);
            if (!v)
              throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
          } else {
            v = this.compile(schemaKeyRef);
          }
          const valid = v(data);
          if (!("$async" in v))
            this.errors = v.errors;
          return valid;
        }
        compile(schema2, _meta) {
          const sch = this._addSchema(schema2, _meta);
          return sch.validate || this._compileSchemaEnv(sch);
        }
        compileAsync(schema2, meta) {
          if (typeof this.opts.loadSchema != "function") {
            throw new Error("options.loadSchema should be a function");
          }
          const { loadSchema } = this.opts;
          return runCompileAsync.call(this, schema2, meta);
          async function runCompileAsync(_schema, _meta) {
            await loadMetaSchema.call(this, _schema.$schema);
            const sch = this._addSchema(_schema, _meta);
            return sch.validate || _compileAsync.call(this, sch);
          }
          async function loadMetaSchema($ref) {
            if ($ref && !this.getSchema($ref)) {
              await runCompileAsync.call(this, { $ref }, true);
            }
          }
          async function _compileAsync(sch) {
            try {
              return this._compileSchemaEnv(sch);
            } catch (e) {
              if (!(e instanceof ref_error_12.default))
                throw e;
              checkLoaded.call(this, e);
              await loadMissingSchema.call(this, e.missingSchema);
              return _compileAsync.call(this, sch);
            }
          }
          function checkLoaded({ missingSchema: ref2, missingRef }) {
            if (this.refs[ref2]) {
              throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
            }
          }
          async function loadMissingSchema(ref2) {
            const _schema = await _loadSchema.call(this, ref2);
            if (!this.refs[ref2])
              await loadMetaSchema.call(this, _schema.$schema);
            if (!this.refs[ref2])
              this.addSchema(_schema, ref2, meta);
          }
          async function _loadSchema(ref2) {
            const p2 = this._loading[ref2];
            if (p2)
              return p2;
            try {
              return await (this._loading[ref2] = loadSchema(ref2));
            } finally {
              delete this._loading[ref2];
            }
          }
        }
        // Adds schema to the instance
        addSchema(schema2, key, _meta, _validateSchema = this.opts.validateSchema) {
          if (Array.isArray(schema2)) {
            for (const sch of schema2)
              this.addSchema(sch, void 0, _meta, _validateSchema);
            return this;
          }
          let id2;
          if (typeof schema2 === "object") {
            const { schemaId } = this.opts;
            id2 = schema2[schemaId];
            if (id2 !== void 0 && typeof id2 != "string") {
              throw new Error(`schema ${schemaId} must be string`);
            }
          }
          key = (0, resolve_12.normalizeId)(key || id2);
          this._checkUnique(key);
          this.schemas[key] = this._addSchema(schema2, _meta, key, _validateSchema, true);
          return this;
        }
        // Add schema that will be used to validate other schemas
        // options in META_IGNORE_OPTIONS are alway set to false
        addMetaSchema(schema2, key, _validateSchema = this.opts.validateSchema) {
          this.addSchema(schema2, key, true, _validateSchema);
          return this;
        }
        //  Validate schema against its meta-schema
        validateSchema(schema2, throwOrLogError) {
          if (typeof schema2 == "boolean")
            return true;
          let $schema2;
          $schema2 = schema2.$schema;
          if ($schema2 !== void 0 && typeof $schema2 != "string") {
            throw new Error("$schema must be a string");
          }
          $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
          if (!$schema2) {
            this.logger.warn("meta-schema not available");
            this.errors = null;
            return true;
          }
          const valid = this.validate($schema2, schema2);
          if (!valid && throwOrLogError) {
            const message = "schema is invalid: " + this.errorsText();
            if (this.opts.validateSchema === "log")
              this.logger.error(message);
            else
              throw new Error(message);
          }
          return valid;
        }
        // Get compiled schema by `key` or `ref`.
        // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
        getSchema(keyRef) {
          let sch;
          while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
            keyRef = sch;
          if (sch === void 0) {
            const { schemaId } = this.opts;
            const root = new compile_12.SchemaEnv({ schema: {}, schemaId });
            sch = compile_12.resolveSchema.call(this, root, keyRef);
            if (!sch)
              return;
            this.refs[keyRef] = sch;
          }
          return sch.validate || this._compileSchemaEnv(sch);
        }
        // Remove cached schema(s).
        // If no parameter is passed all schemas but meta-schemas are removed.
        // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
        // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
        removeSchema(schemaKeyRef) {
          if (schemaKeyRef instanceof RegExp) {
            this._removeAllSchemas(this.schemas, schemaKeyRef);
            this._removeAllSchemas(this.refs, schemaKeyRef);
            return this;
          }
          switch (typeof schemaKeyRef) {
            case "undefined":
              this._removeAllSchemas(this.schemas);
              this._removeAllSchemas(this.refs);
              this._cache.clear();
              return this;
            case "string": {
              const sch = getSchEnv.call(this, schemaKeyRef);
              if (typeof sch == "object")
                this._cache.delete(sch.schema);
              delete this.schemas[schemaKeyRef];
              delete this.refs[schemaKeyRef];
              return this;
            }
            case "object": {
              const cacheKey = schemaKeyRef;
              this._cache.delete(cacheKey);
              let id2 = schemaKeyRef[this.opts.schemaId];
              if (id2) {
                id2 = (0, resolve_12.normalizeId)(id2);
                delete this.schemas[id2];
                delete this.refs[id2];
              }
              return this;
            }
            default:
              throw new Error("ajv.removeSchema: invalid parameter");
          }
        }
        // add "vocabulary" - a collection of keywords
        addVocabulary(definitions2) {
          for (const def2 of definitions2)
            this.addKeyword(def2);
          return this;
        }
        addKeyword(kwdOrDef, def2) {
          let keyword2;
          if (typeof kwdOrDef == "string") {
            keyword2 = kwdOrDef;
            if (typeof def2 == "object") {
              this.logger.warn("these parameters are deprecated, see docs for addKeyword");
              def2.keyword = keyword2;
            }
          } else if (typeof kwdOrDef == "object" && def2 === void 0) {
            def2 = kwdOrDef;
            keyword2 = def2.keyword;
            if (Array.isArray(keyword2) && !keyword2.length) {
              throw new Error("addKeywords: keyword must be string or non-empty array");
            }
          } else {
            throw new Error("invalid addKeywords parameters");
          }
          checkKeyword.call(this, keyword2, def2);
          if (!def2) {
            (0, util_12.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
            return this;
          }
          keywordMetaschema.call(this, def2);
          const definition = {
            ...def2,
            type: (0, dataType_12.getJSONTypes)(def2.type),
            schemaType: (0, dataType_12.getJSONTypes)(def2.schemaType)
          };
          (0, util_12.eachItem)(keyword2, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
          return this;
        }
        getKeyword(keyword2) {
          const rule = this.RULES.all[keyword2];
          return typeof rule == "object" ? rule.definition : !!rule;
        }
        // Remove keyword
        removeKeyword(keyword2) {
          const { RULES: RULES2 } = this;
          delete RULES2.keywords[keyword2];
          delete RULES2.all[keyword2];
          for (const group of RULES2.rules) {
            const i2 = group.rules.findIndex((rule) => rule.keyword === keyword2);
            if (i2 >= 0)
              group.rules.splice(i2, 1);
          }
          return this;
        }
        // Add format
        addFormat(name, format2) {
          if (typeof format2 == "string")
            format2 = new RegExp(format2);
          this.formats[name] = format2;
          return this;
        }
        errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
          if (!errors2 || errors2.length === 0)
            return "No errors";
          return errors2.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text2, msg) => text2 + separator + msg);
        }
        $dataMetaSchema(metaSchema2, keywordsJsonPointers) {
          const rules2 = this.RULES.all;
          metaSchema2 = JSON.parse(JSON.stringify(metaSchema2));
          for (const jsonPointer of keywordsJsonPointers) {
            const segments = jsonPointer.split("/").slice(1);
            let keywords = metaSchema2;
            for (const seg of segments)
              keywords = keywords[seg];
            for (const key in rules2) {
              const rule = rules2[key];
              if (typeof rule != "object")
                continue;
              const { $data } = rule.definition;
              const schema2 = keywords[key];
              if ($data && schema2)
                keywords[key] = schemaOrData(schema2);
            }
          }
          return metaSchema2;
        }
        _removeAllSchemas(schemas, regex2) {
          for (const keyRef in schemas) {
            const sch = schemas[keyRef];
            if (!regex2 || regex2.test(keyRef)) {
              if (typeof sch == "string") {
                delete schemas[keyRef];
              } else if (sch && !sch.meta) {
                this._cache.delete(sch.schema);
                delete schemas[keyRef];
              }
            }
          }
        }
        _addSchema(schema2, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
          let id2;
          const { schemaId } = this.opts;
          if (typeof schema2 == "object") {
            id2 = schema2[schemaId];
          } else {
            if (this.opts.jtd)
              throw new Error("schema must be object");
            else if (typeof schema2 != "boolean")
              throw new Error("schema must be object or boolean");
          }
          let sch = this._cache.get(schema2);
          if (sch !== void 0)
            return sch;
          baseId = (0, resolve_12.normalizeId)(id2 || baseId);
          const localRefs = resolve_12.getSchemaRefs.call(this, schema2, baseId);
          sch = new compile_12.SchemaEnv({ schema: schema2, schemaId, meta, baseId, localRefs });
          this._cache.set(sch.schema, sch);
          if (addSchema && !baseId.startsWith("#")) {
            if (baseId)
              this._checkUnique(baseId);
            this.refs[baseId] = sch;
          }
          if (validateSchema)
            this.validateSchema(schema2, true);
          return sch;
        }
        _checkUnique(id2) {
          if (this.schemas[id2] || this.refs[id2]) {
            throw new Error(`schema with key or id "${id2}" already exists`);
          }
        }
        _compileSchemaEnv(sch) {
          if (sch.meta)
            this._compileMetaSchema(sch);
          else
            compile_12.compileSchema.call(this, sch);
          if (!sch.validate)
            throw new Error("ajv implementation error");
          return sch.validate;
        }
        _compileMetaSchema(sch) {
          const currentOpts = this.opts;
          this.opts = this._metaOpts;
          try {
            compile_12.compileSchema.call(this, sch);
          } finally {
            this.opts = currentOpts;
          }
        }
      }
      Ajv2.ValidationError = validation_error_12.default;
      Ajv2.MissingRefError = ref_error_12.default;
      exports2.default = Ajv2;
      function checkOptions(checkOpts, options, msg, log = "error") {
        for (const key in checkOpts) {
          const opt = key;
          if (opt in options)
            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
        }
      }
      function getSchEnv(keyRef) {
        keyRef = (0, resolve_12.normalizeId)(keyRef);
        return this.schemas[keyRef] || this.refs[keyRef];
      }
      function addInitialSchemas() {
        const optsSchemas = this.opts.schemas;
        if (!optsSchemas)
          return;
        if (Array.isArray(optsSchemas))
          this.addSchema(optsSchemas);
        else
          for (const key in optsSchemas)
            this.addSchema(optsSchemas[key], key);
      }
      function addInitialFormats() {
        for (const name in this.opts.formats) {
          const format2 = this.opts.formats[name];
          if (format2)
            this.addFormat(name, format2);
        }
      }
      function addInitialKeywords(defs) {
        if (Array.isArray(defs)) {
          this.addVocabulary(defs);
          return;
        }
        this.logger.warn("keywords option as map is deprecated, pass array");
        for (const keyword2 in defs) {
          const def2 = defs[keyword2];
          if (!def2.keyword)
            def2.keyword = keyword2;
          this.addKeyword(def2);
        }
      }
      function getMetaSchemaOptions() {
        const metaOpts = { ...this.opts };
        for (const opt of META_IGNORE_OPTIONS)
          delete metaOpts[opt];
        return metaOpts;
      }
      const noLogs = { log() {
      }, warn() {
      }, error() {
      } };
      function getLogger(logger) {
        if (logger === false)
          return noLogs;
        if (logger === void 0)
          return console;
        if (logger.log && logger.warn && logger.error)
          return logger;
        throw new Error("logger must implement log, warn and error methods");
      }
      const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
      function checkKeyword(keyword2, def2) {
        const { RULES: RULES2 } = this;
        (0, util_12.eachItem)(keyword2, (kwd) => {
          if (RULES2.keywords[kwd])
            throw new Error(`Keyword ${kwd} is already defined`);
          if (!KEYWORD_NAME.test(kwd))
            throw new Error(`Keyword ${kwd} has invalid name`);
        });
        if (!def2)
          return;
        if (def2.$data && !("code" in def2 || "validate" in def2)) {
          throw new Error('$data keyword must have "code" or "validate" function');
        }
      }
      function addRule(keyword2, definition, dataType2) {
        var _a2;
        const post = definition === null || definition === void 0 ? void 0 : definition.post;
        if (dataType2 && post)
          throw new Error('keyword with "post" flag cannot have "type"');
        const { RULES: RULES2 } = this;
        let ruleGroup = post ? RULES2.post : RULES2.rules.find(({ type: t }) => t === dataType2);
        if (!ruleGroup) {
          ruleGroup = { type: dataType2, rules: [] };
          RULES2.rules.push(ruleGroup);
        }
        RULES2.keywords[keyword2] = true;
        if (!definition)
          return;
        const rule = {
          keyword: keyword2,
          definition: {
            ...definition,
            type: (0, dataType_12.getJSONTypes)(definition.type),
            schemaType: (0, dataType_12.getJSONTypes)(definition.schemaType)
          }
        };
        if (definition.before)
          addBeforeRule.call(this, ruleGroup, rule, definition.before);
        else
          ruleGroup.rules.push(rule);
        RULES2.all[keyword2] = rule;
        (_a2 = definition.implements) === null || _a2 === void 0 ? void 0 : _a2.forEach((kwd) => this.addKeyword(kwd));
      }
      function addBeforeRule(ruleGroup, rule, before) {
        const i2 = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
        if (i2 >= 0) {
          ruleGroup.rules.splice(i2, 0, rule);
        } else {
          ruleGroup.rules.push(rule);
          this.logger.warn(`rule ${before} is not defined`);
        }
      }
      function keywordMetaschema(def2) {
        let { metaSchema: metaSchema2 } = def2;
        if (metaSchema2 === void 0)
          return;
        if (def2.$data && this.opts.$data)
          metaSchema2 = schemaOrData(metaSchema2);
        def2.validateSchema = this.compile(metaSchema2, true);
      }
      const $dataRef = {
        $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
      };
      function schemaOrData(schema2) {
        return { anyOf: [schema2, $dataRef] };
      }
    })(core$3);
    var draft7 = {};
    var core$2 = {};
    var id$1 = {};
    Object.defineProperty(id$1, "__esModule", { value: true });
    const def$B = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    id$1.default = def$B;
    var ref = {};
    Object.defineProperty(ref, "__esModule", { value: true });
    ref.callRef = ref.getValidate = void 0;
    const ref_error_1$1 = ref_error;
    const code_1$8 = code$1;
    const codegen_1$p = codegen;
    const names_1$4 = names$2;
    const compile_1$2 = compile$2;
    const util_1$n = util;
    const def$A = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it: it2 } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it2;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1$2.resolveRef.call(self2, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1$1.default(it2.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1$2.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1$p._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1$p.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1$p.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1$p._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    ref.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it: it2 } = cxt;
      const { allErrors, schemaEnv: env, opts } = it2;
      const passCxt = opts.passContext ? names_1$4.default.this : codegen_1$p.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1$p._)`await ${(0, code_1$8.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1$p._)`!(${e} instanceof ${it2.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1$8.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source2) {
        const errs = (0, codegen_1$p._)`${source2}.errors`;
        gen.assign(names_1$4.default.vErrors, (0, codegen_1$p._)`${names_1$4.default.vErrors} === null ? ${errs} : ${names_1$4.default.vErrors}.concat(${errs})`);
        gen.assign(names_1$4.default.errors, (0, codegen_1$p._)`${names_1$4.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source2) {
        var _a2;
        if (!it2.opts.unevaluated)
          return;
        const schEvaluated = (_a2 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a2 === void 0 ? void 0 : _a2.evaluated;
        if (it2.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it2.props = util_1$n.mergeEvaluated.props(gen, schEvaluated.props, it2.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1$p._)`${source2}.evaluated.props`);
            it2.props = util_1$n.mergeEvaluated.props(gen, props, it2.props, codegen_1$p.Name);
          }
        }
        if (it2.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it2.items = util_1$n.mergeEvaluated.items(gen, schEvaluated.items, it2.items);
            }
          } else {
            const items2 = gen.var("items", (0, codegen_1$p._)`${source2}.evaluated.items`);
            it2.items = util_1$n.mergeEvaluated.items(gen, items2, it2.items, codegen_1$p.Name);
          }
        }
      }
    }
    ref.callRef = callRef;
    ref.default = def$A;
    Object.defineProperty(core$2, "__esModule", { value: true });
    const id_1 = id$1;
    const ref_1$2 = ref;
    const core$1 = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1$2.default
    ];
    core$2.default = core$1;
    var validation$2 = {};
    var limitNumber = {};
    Object.defineProperty(limitNumber, "__esModule", { value: true });
    const codegen_1$o = codegen;
    const ops = codegen_1$o.operators;
    const KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    const error$l = {
      message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$o.str)`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
      params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$o._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
    };
    const def$z = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error: error$l,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1$o._)`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    limitNumber.default = def$z;
    var multipleOf = {};
    Object.defineProperty(multipleOf, "__esModule", { value: true });
    const codegen_1$n = codegen;
    const error$k = {
      message: ({ schemaCode }) => (0, codegen_1$n.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1$n._)`{multipleOf: ${schemaCode}}`
    };
    const def$y = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error: error$k,
      code(cxt) {
        const { gen, data, schemaCode, it: it2 } = cxt;
        const prec2 = it2.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec2 ? (0, codegen_1$n._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec2}` : (0, codegen_1$n._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1$n._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    multipleOf.default = def$y;
    var limitLength = {};
    var ucs2length$1 = {};
    Object.defineProperty(ucs2length$1, "__esModule", { value: true });
    function ucs2length(str2) {
      const len = str2.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str2.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str2.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    ucs2length$1.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
    Object.defineProperty(limitLength, "__esModule", { value: true });
    const codegen_1$m = codegen;
    const util_1$m = util;
    const ucs2length_1 = ucs2length$1;
    const error$j = {
      message({ keyword: keyword2, schemaCode }) {
        const comp2 = keyword2 === "maxLength" ? "more" : "fewer";
        return (0, codegen_1$m.str)`must NOT have ${comp2} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1$m._)`{limit: ${schemaCode}}`
    };
    const def$x = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error: error$j,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode, it: it2 } = cxt;
        const op = keyword2 === "maxLength" ? codegen_1$m.operators.GT : codegen_1$m.operators.LT;
        const len = it2.opts.unicode === false ? (0, codegen_1$m._)`${data}.length` : (0, codegen_1$m._)`${(0, util_1$m.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1$m._)`${len} ${op} ${schemaCode}`);
      }
    };
    limitLength.default = def$x;
    var pattern = {};
    Object.defineProperty(pattern, "__esModule", { value: true });
    const code_1$7 = code$1;
    const codegen_1$l = codegen;
    const error$i = {
      message: ({ schemaCode }) => (0, codegen_1$l.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1$l._)`{pattern: ${schemaCode}}`
    };
    const def$w = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error: error$i,
      code(cxt) {
        const { data, $data, schema: schema2, schemaCode, it: it2 } = cxt;
        const u = it2.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1$l._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1$7.usePattern)(cxt, schema2);
        cxt.fail$data((0, codegen_1$l._)`!${regExp}.test(${data})`);
      }
    };
    pattern.default = def$w;
    var limitProperties = {};
    Object.defineProperty(limitProperties, "__esModule", { value: true });
    const codegen_1$k = codegen;
    const error$h = {
      message({ keyword: keyword2, schemaCode }) {
        const comp2 = keyword2 === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1$k.str)`must NOT have ${comp2} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1$k._)`{limit: ${schemaCode}}`
    };
    const def$v = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error: error$h,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode } = cxt;
        const op = keyword2 === "maxProperties" ? codegen_1$k.operators.GT : codegen_1$k.operators.LT;
        cxt.fail$data((0, codegen_1$k._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    limitProperties.default = def$v;
    var required = {};
    Object.defineProperty(required, "__esModule", { value: true });
    const code_1$6 = code$1;
    const codegen_1$j = codegen;
    const util_1$l = util;
    const error$g = {
      message: ({ params: { missingProperty } }) => (0, codegen_1$j.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1$j._)`{missingProperty: ${missingProperty}}`
    };
    const def$u = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error: error$g,
      code(cxt) {
        const { gen, schema: schema2, schemaCode, data, $data, it: it2 } = cxt;
        const { opts } = it2;
        if (!$data && schema2.length === 0)
          return;
        const useLoop = schema2.length >= opts.loopRequired;
        if (it2.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema2) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1$l.checkStrictMode)(it2, msg, it2.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1$j.nil, loopAllRequired);
          } else {
            for (const prop2 of schema2) {
              (0, code_1$6.checkReportMissingProp)(cxt, prop2);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1$6.checkMissingProp)(cxt, schema2, missing));
            (0, code_1$6.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop2) => {
            cxt.setParams({ missingProperty: prop2 });
            gen.if((0, code_1$6.noPropertyInData)(gen, data, prop2, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1$6.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1$j.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1$j.nil);
        }
      }
    };
    required.default = def$u;
    var limitItems = {};
    Object.defineProperty(limitItems, "__esModule", { value: true });
    const codegen_1$i = codegen;
    const error$f = {
      message({ keyword: keyword2, schemaCode }) {
        const comp2 = keyword2 === "maxItems" ? "more" : "fewer";
        return (0, codegen_1$i.str)`must NOT have ${comp2} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1$i._)`{limit: ${schemaCode}}`
    };
    const def$t = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error: error$f,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode } = cxt;
        const op = keyword2 === "maxItems" ? codegen_1$i.operators.GT : codegen_1$i.operators.LT;
        cxt.fail$data((0, codegen_1$i._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    limitItems.default = def$t;
    var uniqueItems = {};
    var equal$1 = {};
    Object.defineProperty(equal$1, "__esModule", { value: true });
    const equal = fastDeepEqual;
    equal.code = 'require("ajv/dist/runtime/equal").default';
    equal$1.default = equal;
    Object.defineProperty(uniqueItems, "__esModule", { value: true });
    const dataType_1 = dataType;
    const codegen_1$h = codegen;
    const util_1$k = util;
    const equal_1$2 = equal$1;
    const error$e = {
      message: ({ params: { i: i2, j } }) => (0, codegen_1$h.str)`must NOT have duplicate items (items ## ${j} and ${i2} are identical)`,
      params: ({ params: { i: i2, j } }) => (0, codegen_1$h._)`{i: ${i2}, j: ${j}}`
    };
    const def$s = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error: error$e,
      code(cxt) {
        const { gen, data, $data, schema: schema2, parentSchema, schemaCode, it: it2 } = cxt;
        if (!$data && !schema2)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1$h._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i2 = gen.let("i", (0, codegen_1$h._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i: i2, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1$h._)`${i2} > 1`, () => (canOptimize() ? loopN : loopN2)(i2, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i2, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it2.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1$h._)`{}`);
          gen.for((0, codegen_1$h._)`;${i2}--;`, () => {
            gen.let(item, (0, codegen_1$h._)`${data}[${i2}]`);
            gen.if(wrongType, (0, codegen_1$h._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1$h._)`typeof ${item} == "string"`, (0, codegen_1$h._)`${item} += "_"`);
            gen.if((0, codegen_1$h._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1$h._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1$h._)`${indices}[${item}] = ${i2}`);
          });
        }
        function loopN2(i2, j) {
          const eql = (0, util_1$k.useFunc)(gen, equal_1$2.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1$h._)`;${i2}--;`, () => gen.for((0, codegen_1$h._)`${j} = ${i2}; ${j}--;`, () => gen.if((0, codegen_1$h._)`${eql}(${data}[${i2}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    uniqueItems.default = def$s;
    var _const = {};
    Object.defineProperty(_const, "__esModule", { value: true });
    const codegen_1$g = codegen;
    const util_1$j = util;
    const equal_1$1 = equal$1;
    const error$d = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1$g._)`{allowedValue: ${schemaCode}}`
    };
    const def$r = {
      keyword: "const",
      $data: true,
      error: error$d,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema: schema2 } = cxt;
        if ($data || schema2 && typeof schema2 == "object") {
          cxt.fail$data((0, codegen_1$g._)`!${(0, util_1$j.useFunc)(gen, equal_1$1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1$g._)`${schema2} !== ${data}`);
        }
      }
    };
    _const.default = def$r;
    var _enum = {};
    Object.defineProperty(_enum, "__esModule", { value: true });
    const codegen_1$f = codegen;
    const util_1$i = util;
    const equal_1 = equal$1;
    const error$c = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1$f._)`{allowedValues: ${schemaCode}}`
    };
    const def$q = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error: error$c,
      code(cxt) {
        const { gen, data, $data, schema: schema2, schemaCode, it: it2 } = cxt;
        if (!$data && schema2.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema2.length >= it2.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1$i.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema2))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1$f.or)(...schema2.map((_x, i2) => equalCode(vSchema, i2)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1$f._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i2) {
          const sch = schema2[i2];
          return typeof sch === "object" && sch !== null ? (0, codegen_1$f._)`${getEql()}(${data}, ${vSchema}[${i2}])` : (0, codegen_1$f._)`${data} === ${sch}`;
        }
      }
    };
    _enum.default = def$q;
    Object.defineProperty(validation$2, "__esModule", { value: true });
    const limitNumber_1 = limitNumber;
    const multipleOf_1 = multipleOf;
    const limitLength_1 = limitLength;
    const pattern_1 = pattern;
    const limitProperties_1 = limitProperties;
    const required_1 = required;
    const limitItems_1 = limitItems;
    const uniqueItems_1 = uniqueItems;
    const const_1 = _const;
    const enum_1 = _enum;
    const validation$1 = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    validation$2.default = validation$1;
    var applicator$1 = {};
    var additionalItems = {};
    Object.defineProperty(additionalItems, "__esModule", { value: true });
    additionalItems.validateAdditionalItems = void 0;
    const codegen_1$e = codegen;
    const util_1$h = util;
    const error$b = {
      message: ({ params: { len } }) => (0, codegen_1$e.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1$e._)`{limit: ${len}}`
    };
    const def$p = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error: error$b,
      code(cxt) {
        const { parentSchema, it: it2 } = cxt;
        const { items: items2 } = parentSchema;
        if (!Array.isArray(items2)) {
          (0, util_1$h.checkStrictMode)(it2, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items2);
      }
    };
    function validateAdditionalItems(cxt, items2) {
      const { gen, schema: schema2, data, keyword: keyword2, it: it2 } = cxt;
      it2.items = true;
      const len = gen.const("len", (0, codegen_1$e._)`${data}.length`);
      if (schema2 === false) {
        cxt.setParams({ len: items2.length });
        cxt.pass((0, codegen_1$e._)`${len} <= ${items2.length}`);
      } else if (typeof schema2 == "object" && !(0, util_1$h.alwaysValidSchema)(it2, schema2)) {
        const valid = gen.var("valid", (0, codegen_1$e._)`${len} <= ${items2.length}`);
        gen.if((0, codegen_1$e.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items2.length, len, (i2) => {
          cxt.subschema({ keyword: keyword2, dataProp: i2, dataPropType: util_1$h.Type.Num }, valid);
          if (!it2.allErrors)
            gen.if((0, codegen_1$e.not)(valid), () => gen.break());
        });
      }
    }
    additionalItems.validateAdditionalItems = validateAdditionalItems;
    additionalItems.default = def$p;
    var prefixItems = {};
    var items = {};
    Object.defineProperty(items, "__esModule", { value: true });
    items.validateTuple = void 0;
    const codegen_1$d = codegen;
    const util_1$g = util;
    const code_1$5 = code$1;
    const def$o = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema: schema2, it: it2 } = cxt;
        if (Array.isArray(schema2))
          return validateTuple(cxt, "additionalItems", schema2);
        it2.items = true;
        if ((0, util_1$g.alwaysValidSchema)(it2, schema2))
          return;
        cxt.ok((0, code_1$5.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword: keyword2, it: it2 } = cxt;
      checkStrictTuple(parentSchema);
      if (it2.opts.unevaluated && schArr.length && it2.items !== true) {
        it2.items = util_1$g.mergeEvaluated.items(gen, schArr.length, it2.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1$d._)`${data}.length`);
      schArr.forEach((sch, i2) => {
        if ((0, util_1$g.alwaysValidSchema)(it2, sch))
          return;
        gen.if((0, codegen_1$d._)`${len} > ${i2}`, () => cxt.subschema({
          keyword: keyword2,
          schemaProp: i2,
          dataProp: i2
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it2;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1$g.checkStrictMode)(it2, msg, opts.strictTuples);
        }
      }
    }
    items.validateTuple = validateTuple;
    items.default = def$o;
    Object.defineProperty(prefixItems, "__esModule", { value: true });
    const items_1$1 = items;
    const def$n = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1$1.validateTuple)(cxt, "items")
    };
    prefixItems.default = def$n;
    var items2020 = {};
    Object.defineProperty(items2020, "__esModule", { value: true });
    const codegen_1$c = codegen;
    const util_1$f = util;
    const code_1$4 = code$1;
    const additionalItems_1$1 = additionalItems;
    const error$a = {
      message: ({ params: { len } }) => (0, codegen_1$c.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1$c._)`{limit: ${len}}`
    };
    const def$m = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error: error$a,
      code(cxt) {
        const { schema: schema2, parentSchema, it: it2 } = cxt;
        const { prefixItems: prefixItems2 } = parentSchema;
        it2.items = true;
        if ((0, util_1$f.alwaysValidSchema)(it2, schema2))
          return;
        if (prefixItems2)
          (0, additionalItems_1$1.validateAdditionalItems)(cxt, prefixItems2);
        else
          cxt.ok((0, code_1$4.validateArray)(cxt));
      }
    };
    items2020.default = def$m;
    var contains = {};
    Object.defineProperty(contains, "__esModule", { value: true });
    const codegen_1$b = codegen;
    const util_1$e = util;
    const error$9 = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$b.str)`must contain at least ${min} valid item(s)` : (0, codegen_1$b.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$b._)`{minContains: ${min}}` : (0, codegen_1$b._)`{minContains: ${min}, maxContains: ${max}}`
    };
    const def$l = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error: error$9,
      code(cxt) {
        const { gen, schema: schema2, parentSchema, data, it: it2 } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it2.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1$b._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1$e.checkStrictMode)(it2, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1$e.checkStrictMode)(it2, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1$e.alwaysValidSchema)(it2, schema2)) {
          let cond = (0, codegen_1$b._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1$b._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it2.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1$b._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block2) {
          gen.forRange("i", 0, len, (i2) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i2,
              dataPropType: util_1$e.Type.Num,
              compositeRule: true
            }, _valid);
            block2();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1$b._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1$b._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1$b._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1$b._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    contains.default = def$l;
    var dependencies = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.validateSchemaDeps = exports2.validatePropertyDeps = exports2.error = void 0;
      const codegen_12 = codegen;
      const util_12 = util;
      const code_12 = code$1;
      exports2.error = {
        message: ({ params: { property, depsCount, deps } }) => {
          const property_ies = depsCount === 1 ? "property" : "properties";
          return (0, codegen_12.str)`must have ${property_ies} ${deps} when property ${property} is present`;
        },
        params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_12._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
        // TODO change to reference
      };
      const def2 = {
        keyword: "dependencies",
        type: "object",
        schemaType: "object",
        error: exports2.error,
        code(cxt) {
          const [propDeps, schDeps] = splitDependencies(cxt);
          validatePropertyDeps(cxt, propDeps);
          validateSchemaDeps(cxt, schDeps);
        }
      };
      function splitDependencies({ schema: schema2 }) {
        const propertyDeps = {};
        const schemaDeps = {};
        for (const key in schema2) {
          if (key === "__proto__")
            continue;
          const deps = Array.isArray(schema2[key]) ? propertyDeps : schemaDeps;
          deps[key] = schema2[key];
        }
        return [propertyDeps, schemaDeps];
      }
      function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
        const { gen, data, it: it2 } = cxt;
        if (Object.keys(propertyDeps).length === 0)
          return;
        const missing = gen.let("missing");
        for (const prop2 in propertyDeps) {
          const deps = propertyDeps[prop2];
          if (deps.length === 0)
            continue;
          const hasProperty = (0, code_12.propertyInData)(gen, data, prop2, it2.opts.ownProperties);
          cxt.setParams({
            property: prop2,
            depsCount: deps.length,
            deps: deps.join(", ")
          });
          if (it2.allErrors) {
            gen.if(hasProperty, () => {
              for (const depProp of deps) {
                (0, code_12.checkReportMissingProp)(cxt, depProp);
              }
            });
          } else {
            gen.if((0, codegen_12._)`${hasProperty} && (${(0, code_12.checkMissingProp)(cxt, deps, missing)})`);
            (0, code_12.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
      }
      exports2.validatePropertyDeps = validatePropertyDeps;
      function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
        const { gen, data, keyword: keyword2, it: it2 } = cxt;
        const valid = gen.name("valid");
        for (const prop2 in schemaDeps) {
          if ((0, util_12.alwaysValidSchema)(it2, schemaDeps[prop2]))
            continue;
          gen.if(
            (0, code_12.propertyInData)(gen, data, prop2, it2.opts.ownProperties),
            () => {
              const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop2 }, valid);
              cxt.mergeValidEvaluated(schCxt, valid);
            },
            () => gen.var(valid, true)
            // TODO var
          );
          cxt.ok(valid);
        }
      }
      exports2.validateSchemaDeps = validateSchemaDeps;
      exports2.default = def2;
    })(dependencies);
    var propertyNames = {};
    Object.defineProperty(propertyNames, "__esModule", { value: true });
    const codegen_1$a = codegen;
    const util_1$d = util;
    const error$8 = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1$a._)`{propertyName: ${params.propertyName}}`
    };
    const def$k = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error: error$8,
      code(cxt) {
        const { gen, schema: schema2, data, it: it2 } = cxt;
        if ((0, util_1$d.alwaysValidSchema)(it2, schema2))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1$a.not)(valid), () => {
            cxt.error(true);
            if (!it2.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    propertyNames.default = def$k;
    var additionalProperties = {};
    Object.defineProperty(additionalProperties, "__esModule", { value: true });
    const code_1$3 = code$1;
    const codegen_1$9 = codegen;
    const names_1$3 = names$2;
    const util_1$c = util;
    const error$7 = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1$9._)`{additionalProperty: ${params.additionalProperty}}`
    };
    const def$j = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error: error$7,
      code(cxt) {
        const { gen, schema: schema2, parentSchema, data, errsCount, it: it2 } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it2;
        it2.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1$c.alwaysValidSchema)(it2, schema2))
          return;
        const props = (0, code_1$3.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1$3.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1$9._)`${errsCount} === ${names_1$3.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1$c.schemaRefOrVal)(it2, parentSchema.properties, "properties");
            definedProp = (0, code_1$3.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1$9.or)(...props.map((p2) => (0, codegen_1$9._)`${key} === ${p2}`));
          } else {
            definedProp = codegen_1$9.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1$9.or)(definedProp, ...patProps.map((p2) => (0, codegen_1$9._)`${(0, code_1$3.usePattern)(cxt, p2)}.test(${key})`));
          }
          return (0, codegen_1$9.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1$9._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema2 === false) {
            deleteAdditional(key);
            return;
          }
          if (schema2 === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema2 == "object" && !(0, util_1$c.alwaysValidSchema)(it2, schema2)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1$9.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1$9.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors2) {
          const subschema2 = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1$c.Type.Str
          };
          if (errors2 === false) {
            Object.assign(subschema2, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema2, valid);
        }
      }
    };
    additionalProperties.default = def$j;
    var properties$8 = {};
    Object.defineProperty(properties$8, "__esModule", { value: true });
    const validate_1 = validate;
    const code_1$2 = code$1;
    const util_1$b = util;
    const additionalProperties_1$1 = additionalProperties;
    const def$i = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema: schema2, parentSchema, data, it: it2 } = cxt;
        if (it2.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1$1.default.code(new validate_1.KeywordCxt(it2, additionalProperties_1$1.default, "additionalProperties"));
        }
        const allProps = (0, code_1$2.allSchemaProperties)(schema2);
        for (const prop2 of allProps) {
          it2.definedProperties.add(prop2);
        }
        if (it2.opts.unevaluated && allProps.length && it2.props !== true) {
          it2.props = util_1$b.mergeEvaluated.props(gen, (0, util_1$b.toHash)(allProps), it2.props);
        }
        const properties2 = allProps.filter((p2) => !(0, util_1$b.alwaysValidSchema)(it2, schema2[p2]));
        if (properties2.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop2 of properties2) {
          if (hasDefault(prop2)) {
            applyPropertySchema(prop2);
          } else {
            gen.if((0, code_1$2.propertyInData)(gen, data, prop2, it2.opts.ownProperties));
            applyPropertySchema(prop2);
            if (!it2.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop2);
          cxt.ok(valid);
        }
        function hasDefault(prop2) {
          return it2.opts.useDefaults && !it2.compositeRule && schema2[prop2].default !== void 0;
        }
        function applyPropertySchema(prop2) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop2,
            dataProp: prop2
          }, valid);
        }
      }
    };
    properties$8.default = def$i;
    var patternProperties = {};
    Object.defineProperty(patternProperties, "__esModule", { value: true });
    const code_1$1 = code$1;
    const codegen_1$8 = codegen;
    const util_1$a = util;
    const util_2 = util;
    const def$h = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema: schema2, data, parentSchema, it: it2 } = cxt;
        const { opts } = it2;
        const patterns = (0, code_1$1.allSchemaProperties)(schema2);
        const alwaysValidPatterns = patterns.filter((p2) => (0, util_1$a.alwaysValidSchema)(it2, schema2[p2]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it2.opts.unevaluated || it2.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it2.props !== true && !(it2.props instanceof codegen_1$8.Name)) {
          it2.props = (0, util_2.evaluatedPropsToName)(gen, it2.props);
        }
        const { props } = it2;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it2.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop2 in checkProperties) {
            if (new RegExp(pat).test(prop2)) {
              (0, util_1$a.checkStrictMode)(it2, `property ${prop2} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1$8._)`${(0, code_1$1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it2.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1$8._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it2.allErrors) {
                gen.if((0, codegen_1$8.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    patternProperties.default = def$h;
    var not$1 = {};
    Object.defineProperty(not$1, "__esModule", { value: true });
    const util_1$9 = util;
    const def$g = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema: schema2, it: it2 } = cxt;
        if ((0, util_1$9.alwaysValidSchema)(it2, schema2)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    not$1.default = def$g;
    var anyOf = {};
    Object.defineProperty(anyOf, "__esModule", { value: true });
    const code_1 = code$1;
    const def$f = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    anyOf.default = def$f;
    var oneOf = {};
    Object.defineProperty(oneOf, "__esModule", { value: true });
    const codegen_1$7 = codegen;
    const util_1$8 = util;
    const error$6 = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1$7._)`{passingSchemas: ${params.passing}}`
    };
    const def$e = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error: error$6,
      code(cxt) {
        const { gen, schema: schema2, parentSchema, it: it2 } = cxt;
        if (!Array.isArray(schema2))
          throw new Error("ajv implementation error");
        if (it2.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema2;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i2) => {
            let schCxt;
            if ((0, util_1$8.alwaysValidSchema)(it2, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i2,
                compositeRule: true
              }, schValid);
            }
            if (i2 > 0) {
              gen.if((0, codegen_1$7._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1$7._)`[${passing}, ${i2}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i2);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1$7.Name);
            });
          });
        }
      }
    };
    oneOf.default = def$e;
    var allOf$1 = {};
    Object.defineProperty(allOf$1, "__esModule", { value: true });
    const util_1$7 = util;
    const def$d = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema: schema2, it: it2 } = cxt;
        if (!Array.isArray(schema2))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema2.forEach((sch, i2) => {
          if ((0, util_1$7.alwaysValidSchema)(it2, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i2 }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    allOf$1.default = def$d;
    var _if = {};
    Object.defineProperty(_if, "__esModule", { value: true });
    const codegen_1$6 = codegen;
    const util_1$6 = util;
    const error$5 = {
      message: ({ params }) => (0, codegen_1$6.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1$6._)`{failingKeyword: ${params.ifClause}}`
    };
    const def$c = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error: error$5,
      code(cxt) {
        const { gen, parentSchema, it: it2 } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1$6.checkStrictMode)(it2, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it2, "then");
        const hasElse = hasSchema(it2, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1$6.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword2, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1$6._)`${keyword2}`);
            else
              cxt.setParams({ ifClause: keyword2 });
          };
        }
      }
    };
    function hasSchema(it2, keyword2) {
      const schema2 = it2.schema[keyword2];
      return schema2 !== void 0 && !(0, util_1$6.alwaysValidSchema)(it2, schema2);
    }
    _if.default = def$c;
    var thenElse = {};
    Object.defineProperty(thenElse, "__esModule", { value: true });
    const util_1$5 = util;
    const def$b = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword: keyword2, parentSchema, it: it2 }) {
        if (parentSchema.if === void 0)
          (0, util_1$5.checkStrictMode)(it2, `"${keyword2}" without "if" is ignored`);
      }
    };
    thenElse.default = def$b;
    Object.defineProperty(applicator$1, "__esModule", { value: true });
    const additionalItems_1 = additionalItems;
    const prefixItems_1 = prefixItems;
    const items_1 = items;
    const items2020_1 = items2020;
    const contains_1 = contains;
    const dependencies_1$2 = dependencies;
    const propertyNames_1 = propertyNames;
    const additionalProperties_1 = additionalProperties;
    const properties_1 = properties$8;
    const patternProperties_1 = patternProperties;
    const not_1 = not$1;
    const anyOf_1 = anyOf;
    const oneOf_1 = oneOf;
    const allOf_1 = allOf$1;
    const if_1 = _if;
    const thenElse_1 = thenElse;
    function getApplicator(draft2020 = false) {
      const applicator2 = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1$2.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator2.push(prefixItems_1.default, items2020_1.default);
      else
        applicator2.push(additionalItems_1.default, items_1.default);
      applicator2.push(contains_1.default);
      return applicator2;
    }
    applicator$1.default = getApplicator;
    var format$4 = {};
    var format$3 = {};
    Object.defineProperty(format$3, "__esModule", { value: true });
    const codegen_1$5 = codegen;
    const error$4 = {
      message: ({ schemaCode }) => (0, codegen_1$5.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1$5._)`{format: ${schemaCode}}`
    };
    const def$a = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error: error$4,
      code(cxt, ruleType) {
        const { gen, data, $data, schema: schema2, schemaCode, it: it2 } = cxt;
        const { opts, errSchemaPath, schemaEnv, self: self2 } = it2;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1$5._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format2 = gen.let("format");
          gen.if((0, codegen_1$5._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1$5._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1$5._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1$5._)`"string"`).assign(format2, fDef));
          cxt.fail$data((0, codegen_1$5.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1$5.nil;
            return (0, codegen_1$5._)`${schemaCode} && !${format2}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1$5._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1$5._)`${format2}(${data})`;
            const validData = (0, codegen_1$5._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
            return (0, codegen_1$5._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self2.formats[schema2];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format2, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema2}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code2 = fmtDef instanceof RegExp ? (0, codegen_1$5.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1$5._)`${opts.code.formats}${(0, codegen_1$5.getProperty)(schema2)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema2, ref: fmtDef, code: code2 });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1$5._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1$5._)`await ${fmtRef}(${data})`;
            }
            return typeof format2 == "function" ? (0, codegen_1$5._)`${fmtRef}(${data})` : (0, codegen_1$5._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    format$3.default = def$a;
    Object.defineProperty(format$4, "__esModule", { value: true });
    const format_1$1 = format$3;
    const format$2 = [format_1$1.default];
    format$4.default = format$2;
    var metadata$1 = {};
    Object.defineProperty(metadata$1, "__esModule", { value: true });
    metadata$1.contentVocabulary = metadata$1.metadataVocabulary = void 0;
    metadata$1.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    metadata$1.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
    Object.defineProperty(draft7, "__esModule", { value: true });
    const core_1 = core$2;
    const validation_1 = validation$2;
    const applicator_1 = applicator$1;
    const format_1 = format$4;
    const metadata_1 = metadata$1;
    const draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    draft7.default = draft7Vocabularies;
    var discriminator = {};
    var types = {};
    Object.defineProperty(types, "__esModule", { value: true });
    types.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (types.DiscrError = DiscrError = {}));
    Object.defineProperty(discriminator, "__esModule", { value: true });
    const codegen_1$4 = codegen;
    const types_1 = types;
    const compile_1$1 = compile$2;
    const ref_error_1 = ref_error;
    const util_1$4 = util;
    const error$3 = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1$4._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    const def$9 = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error: error$3,
      code(cxt) {
        const { gen, data, schema: schema2, parentSchema, it: it2 } = cxt;
        const { oneOf: oneOf2 } = parentSchema;
        if (!it2.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema2.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema2.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf2)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1$4._)`${data}${(0, codegen_1$4.getProperty)(tagName)}`);
        gen.if((0, codegen_1$4._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1$4._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1$4.Name);
          return _valid;
        }
        function getMapping() {
          var _a2;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i2 = 0; i2 < oneOf2.length; i2++) {
            let sch = oneOf2[i2];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1$4.schemaHasRulesButRef)(sch, it2.self.RULES)) {
              const ref2 = sch.$ref;
              sch = compile_1$1.resolveRef.call(it2.self, it2.schemaEnv.root, it2.baseId, ref2);
              if (sch instanceof compile_1$1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it2.opts.uriResolver, it2.baseId, ref2);
            }
            const propSch = (_a2 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a2 === void 0 ? void 0 : _a2[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i2);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required: required2 }) {
            return Array.isArray(required2) && required2.includes(tagName);
          }
          function addMappings(sch, i2) {
            if (sch.const) {
              addMapping(sch.const, i2);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i2);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i2) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i2;
          }
        }
      }
    };
    discriminator.default = def$9;
    const $schema$7 = "http://json-schema.org/draft-07/schema#";
    const $id$7 = "http://json-schema.org/draft-07/schema#";
    const title$7 = "Core schema meta-schema";
    const definitions = {
      schemaArray: {
        type: "array",
        minItems: 1,
        items: {
          $ref: "#"
        }
      },
      nonNegativeInteger: {
        type: "integer",
        minimum: 0
      },
      nonNegativeIntegerDefault0: {
        allOf: [
          {
            $ref: "#/definitions/nonNegativeInteger"
          },
          {
            "default": 0
          }
        ]
      },
      simpleTypes: {
        "enum": [
          "array",
          "boolean",
          "integer",
          "null",
          "number",
          "object",
          "string"
        ]
      },
      stringArray: {
        type: "array",
        items: {
          type: "string"
        },
        uniqueItems: true,
        "default": []
      }
    };
    const type$7 = [
      "object",
      "boolean"
    ];
    const properties$7 = {
      $id: {
        type: "string",
        format: "uri-reference"
      },
      $schema: {
        type: "string",
        format: "uri"
      },
      $ref: {
        type: "string",
        format: "uri-reference"
      },
      $comment: {
        type: "string"
      },
      title: {
        type: "string"
      },
      description: {
        type: "string"
      },
      "default": true,
      readOnly: {
        type: "boolean",
        "default": false
      },
      examples: {
        type: "array",
        items: true
      },
      multipleOf: {
        type: "number",
        exclusiveMinimum: 0
      },
      maximum: {
        type: "number"
      },
      exclusiveMaximum: {
        type: "number"
      },
      minimum: {
        type: "number"
      },
      exclusiveMinimum: {
        type: "number"
      },
      maxLength: {
        $ref: "#/definitions/nonNegativeInteger"
      },
      minLength: {
        $ref: "#/definitions/nonNegativeIntegerDefault0"
      },
      pattern: {
        type: "string",
        format: "regex"
      },
      additionalItems: {
        $ref: "#"
      },
      items: {
        anyOf: [
          {
            $ref: "#"
          },
          {
            $ref: "#/definitions/schemaArray"
          }
        ],
        "default": true
      },
      maxItems: {
        $ref: "#/definitions/nonNegativeInteger"
      },
      minItems: {
        $ref: "#/definitions/nonNegativeIntegerDefault0"
      },
      uniqueItems: {
        type: "boolean",
        "default": false
      },
      contains: {
        $ref: "#"
      },
      maxProperties: {
        $ref: "#/definitions/nonNegativeInteger"
      },
      minProperties: {
        $ref: "#/definitions/nonNegativeIntegerDefault0"
      },
      required: {
        $ref: "#/definitions/stringArray"
      },
      additionalProperties: {
        $ref: "#"
      },
      definitions: {
        type: "object",
        additionalProperties: {
          $ref: "#"
        },
        "default": {}
      },
      properties: {
        type: "object",
        additionalProperties: {
          $ref: "#"
        },
        "default": {}
      },
      patternProperties: {
        type: "object",
        additionalProperties: {
          $ref: "#"
        },
        propertyNames: {
          format: "regex"
        },
        "default": {}
      },
      dependencies: {
        type: "object",
        additionalProperties: {
          anyOf: [
            {
              $ref: "#"
            },
            {
              $ref: "#/definitions/stringArray"
            }
          ]
        }
      },
      propertyNames: {
        $ref: "#"
      },
      "const": true,
      "enum": {
        type: "array",
        items: true,
        minItems: 1,
        uniqueItems: true
      },
      type: {
        anyOf: [
          {
            $ref: "#/definitions/simpleTypes"
          },
          {
            type: "array",
            items: {
              $ref: "#/definitions/simpleTypes"
            },
            minItems: 1,
            uniqueItems: true
          }
        ]
      },
      format: {
        type: "string"
      },
      contentMediaType: {
        type: "string"
      },
      contentEncoding: {
        type: "string"
      },
      "if": {
        $ref: "#"
      },
      then: {
        $ref: "#"
      },
      "else": {
        $ref: "#"
      },
      allOf: {
        $ref: "#/definitions/schemaArray"
      },
      anyOf: {
        $ref: "#/definitions/schemaArray"
      },
      oneOf: {
        $ref: "#/definitions/schemaArray"
      },
      not: {
        $ref: "#"
      }
    };
    const require$$3$1 = {
      $schema: $schema$7,
      $id: $id$7,
      title: title$7,
      definitions,
      type: type$7,
      properties: properties$7,
      "default": true
    };
    (function(module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MissingRefError = exports2.ValidationError = exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = exports2.Ajv = void 0;
      const core_12 = core$3;
      const draft7_1 = draft7;
      const discriminator_1 = discriminator;
      const draft7MetaSchema = require$$3$1;
      const META_SUPPORT_DATA2 = ["/properties"];
      const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
      class Ajv2 extends core_12.default {
        _addVocabularies() {
          super._addVocabularies();
          draft7_1.default.forEach((v) => this.addVocabulary(v));
          if (this.opts.discriminator)
            this.addKeyword(discriminator_1.default);
        }
        _addDefaultMetaSchema() {
          super._addDefaultMetaSchema();
          if (!this.opts.meta)
            return;
          const metaSchema2 = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA2) : draft7MetaSchema;
          this.addMetaSchema(metaSchema2, META_SCHEMA_ID, false);
          this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
        }
        defaultMeta() {
          return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
        }
      }
      exports2.Ajv = Ajv2;
      module2.exports = exports2 = Ajv2;
      module2.exports.Ajv = Ajv2;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = Ajv2;
      var validate_12 = validate;
      Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
        return validate_12.KeywordCxt;
      } });
      var codegen_12 = codegen;
      Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
        return codegen_12._;
      } });
      Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
        return codegen_12.str;
      } });
      Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
        return codegen_12.stringify;
      } });
      Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
        return codegen_12.nil;
      } });
      Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
        return codegen_12.Name;
      } });
      Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
        return codegen_12.CodeGen;
      } });
      var validation_error_12 = validation_error;
      Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
        return validation_error_12.default;
      } });
      var ref_error_12 = ref_error;
      Object.defineProperty(exports2, "MissingRefError", { enumerable: true, get: function() {
        return ref_error_12.default;
      } });
    })(ajv$1, ajv$1.exports);
    var ajvExports = ajv$1.exports;
    const Ajv$2 = /* @__PURE__ */ getDefaultExportFromCjs(ajvExports);
    function urlToPublicAsset(filePath) {
      let base2 = "/everest-admin-panel/pr-181";
      if (!base2.endsWith("/")) {
        base2 += "/";
      }
      if (!filePath.startsWith("/")) {
        return base2 + filePath;
      } else {
        return base2 + filePath.slice(1);
      }
    }
    const _withScopeId = (n) => (pushScopeId("data-v-a578a337"), n = n(), popScopeId(), n);
    const _hoisted_1$7 = { class: "btn-container" };
    const _hoisted_2$2 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", null, "Upload Config", -1));
    const _hoisted_3$1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", null, "Create Config", -1));
    const _hoisted_4 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", null, "Abort", -1));
    const _hoisted_5 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", null, "Create Config", -1));
    const _sfc_main$G = /* @__PURE__ */ defineComponent$1({
      __name: "CreateConfig",
      emits: ["createConfig"],
      setup(__props, { emit: __emit }) {
        const evbcStore2 = useEvbcStore();
        const state = ref$1(
          0
          /* DEFAULT */
        );
        const configName = ref$1("");
        const configNameValid = computed(() => validateConfigName() === true);
        const emit2 = __emit;
        const { available_configs } = storeToRefs(evbcStore2);
        const configContent = ref$1(null);
        const errors2 = ref$1(null);
        const showErrorDialog = computed(() => !!errors2.value);
        function onAcceptBtnClick() {
          if (validateConfigName() === true) {
            emit2("createConfig", configName.value, configContent.value ?? void 0);
            resetDialog();
          }
        }
        function resetDialog() {
          state.value = 0;
          configName.value = "";
          configContent.value = null;
          errors2.value = null;
        }
        function uploadConfigPrompt() {
          const input = document.createElement("input");
          input.type = "file";
          input.accept = ".json,.yaml,.yml";
          input.click();
          input.onchange = (e) => {
            var _a2;
            const file = (_a2 = e.target.files) == null ? void 0 : _a2[0];
            if (file) {
              const reader = new FileReader();
              reader.onload = async (e2) => {
                var _a3;
                const parseResult = await parseConfig((_a3 = e2.target) == null ? void 0 : _a3.result);
                if (!parseResult.errors) {
                  configContent.value = parseResult.config;
                  configName.value = file.name.replace(/\.[^.]+$/, "");
                  state.value = 1;
                } else {
                  errors2.value = parseResult.errors;
                }
              };
              reader.readAsText(file);
            }
          };
        }
        function validateConfigName() {
          if (configName.value.trim().length === 0) {
            return "Please enter a name";
          } else if (/.*(\.json|\.ya?ml)$/.test(configName.value)) {
            return "The name must not contain the file extension";
          } else if (!/^[a-zA-Z0-9-_]+$/.test(configName.value)) {
            return "The name must only contain letters, numbers, dashes and underscores";
          } else if (Object.keys(available_configs.value).includes(configName.value.trim())) {
            return "The name must be unique";
          } else {
            return true;
          }
        }
        async function validateConfigContent(content2) {
          const ajv2 = new Ajv$2();
          const schema2 = await getConfigJsonSchema();
          const validate2 = ajv2.compile(schema2);
          const valid = validate2(content2);
          if (valid) {
            return true;
          } else {
            return JSON.stringify(validate2.errors, null, 2);
          }
        }
        async function getConfigJsonSchema() {
          const response = await fetch(urlToPublicAsset("schemas/config.json"));
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return await response.json();
        }
        async function parseConfig(content2) {
          try {
            const config2 = jsYaml.load(content2);
            const validationResult = await validateConfigContent(config2);
            if (validationResult === true) {
              return { errors: null, config: config2 };
            } else {
              return { errors: validationResult, config: null };
            }
          } catch (e) {
            return { errors: e.toString(), config: null };
          }
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock(Fragment, null, [
            createBaseVNode("div", _hoisted_1$7, [
              state.value == 0 ? (openBlock(), createBlock(VTooltip, {
                key: 0,
                location: "right",
                "open-delay": "500"
              }, {
                activator: withCtx(({ props }) => [
                  createVNode(VBtn, mergeProps({
                    color: "default",
                    variant: "flat",
                    density: "compact",
                    icon: "mdi-upload",
                    "data-cy": "upload-config-btn"
                  }, props, {
                    onClick: _cache[0] || (_cache[0] = ($event) => uploadConfigPrompt())
                  }), null, 16)
                ]),
                default: withCtx(() => [
                  _hoisted_2$2
                ]),
                _: 1
              })) : createCommentVNode("", true),
              state.value == 0 ? (openBlock(), createBlock(VTooltip, {
                key: 1,
                location: "right",
                "open-delay": "500"
              }, {
                activator: withCtx(({ props }) => [
                  createVNode(VBtn, mergeProps({
                    color: "default",
                    variant: "flat",
                    density: "compact",
                    icon: "mdi-plus",
                    "data-cy": "plus-create-config-btn"
                  }, props, {
                    onClick: _cache[1] || (_cache[1] = ($event) => state.value = 1)
                  }), null, 16)
                ]),
                default: withCtx(() => [
                  _hoisted_3$1
                ]),
                _: 1
              })) : createCommentVNode("", true),
              state.value == 1 ? (openBlock(), createBlock(VTooltip, {
                key: 2,
                location: "right",
                "open-delay": "500"
              }, {
                activator: withCtx(({ props }) => [
                  createVNode(VBtn, mergeProps({
                    color: "default",
                    variant: "flat",
                    density: "compact",
                    "data-cy": "abort-create-config-btn",
                    icon: "mdi-close"
                  }, props, {
                    onClick: _cache[2] || (_cache[2] = ($event) => resetDialog())
                  }), null, 16)
                ]),
                default: withCtx(() => [
                  _hoisted_4
                ]),
                _: 1
              })) : createCommentVNode("", true),
              state.value == 1 ? (openBlock(), createBlock(VTooltip, {
                key: 3,
                location: "right",
                "open-delay": "500"
              }, {
                activator: withCtx(({ props }) => [
                  createVNode(VBtn, mergeProps({
                    color: "default",
                    variant: "flat",
                    density: "compact",
                    icon: "mdi-check",
                    "data-cy": "accept-create-config-btn"
                  }, props, {
                    disabled: !configNameValid.value,
                    onClick: _cache[3] || (_cache[3] = ($event) => onAcceptBtnClick())
                  }), null, 16, ["disabled"])
                ]),
                default: withCtx(() => [
                  _hoisted_5
                ]),
                _: 1
              })) : createCommentVNode("", true)
            ]),
            state.value === 1 ? (openBlock(), createBlock(VTextField, {
              key: 0,
              density: "compact",
              modelValue: configName.value,
              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => configName.value = $event),
              "data-cy": "config-name-input",
              placeholder: "config name",
              rules: [validateConfigName]
            }, null, 8, ["modelValue", "rules"])) : createCommentVNode("", true),
            createVNode(VDialog, {
              modelValue: showErrorDialog.value,
              "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => showErrorDialog.value = $event),
              "onClick:outside": _cache[7] || (_cache[7] = ($event) => resetDialog())
            }, {
              default: withCtx(() => [
                createVNode(VCard, { color: "danger" }, {
                  default: withCtx(() => [
                    createVNode(VCardTitle, null, {
                      default: withCtx(() => [
                        createTextVNode("Couldn't load config")
                      ]),
                      _: 1
                    }),
                    createVNode(VCardText, null, {
                      default: withCtx(() => [
                        createBaseVNode("pre", null, [
                          createBaseVNode("code", null, toDisplayString(errors2.value), 1)
                        ])
                      ]),
                      _: 1
                    }),
                    createVNode(VCardActions, null, {
                      default: withCtx(() => [
                        createVNode(VBtn, {
                          color: "primary",
                          onClick: _cache[5] || (_cache[5] = ($event) => resetDialog())
                        }, {
                          default: withCtx(() => [
                            createTextVNode("OK")
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["modelValue"])
          ], 64);
        };
      }
    });
    const CreateConfig = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["__scopeId", "data-v-a578a337"]]);
    let evbcStore;
    let evbc;
    let notyf;
    const _sfc_main$F = /* @__PURE__ */ defineComponent$1({
      data: () => {
        return {
          show_dialog: false,
          config_to_load: null,
          search: "",
          expansionPanelState: ["configs"]
        };
      },
      created() {
        evbcStore = useEvbcStore();
        evbc = inject$1("evbc");
        notyf = inject$1("notyf");
      },
      components: { CreateConfig, EvDialog },
      computed: {
        current_config() {
          return evbcStore.current_config;
        },
        show_search() {
          return !evbcStore.get_selected_terminal();
        },
        filtered_module_list() {
          const selectedTerminal = evbcStore.get_selected_terminal();
          if (selectedTerminal) {
            return Object.entries(evbc.everest_definitions.modules).filter(([, value]) => {
              if (selectedTerminal.type === "requirement") {
                return value.provides && Object.values(value.provides).some((e) => e.interface === selectedTerminal.interface);
              } else {
                return value.requires && Object.values(value.requires).some((e) => e.interface === selectedTerminal.interface);
              }
            }).map(([key, value]) => ({
              type: key,
              description: value.description
            }));
          } else {
            return Object.entries(evbc.everest_definitions.modules).filter(([key, value]) => {
              return !this.search || this.search.trim() === "" || key.toLowerCase().includes(this.search.toLowerCase()) || value.description.toLowerCase().includes(this.search.toLowerCase());
            }).map(([key, value]) => ({
              type: key,
              description: value.description
            }));
          }
        },
        config_list() {
          return Object.entries(evbcStore.available_configs).map(([key]) => key);
        }
      },
      methods: {
        add_module_to_config(type2) {
          let added_module_id;
          if (evbcStore.current_config) {
            added_module_id = evbcStore.current_config.add_new_module_instance(type2);
          } else {
            throw new Error("No config loaded");
          }
          if (evbcStore.get_selected_terminal()) {
            const selectedTerminal = evbcStore.get_selected_terminal();
            const addedModuleInstance = evbcStore.current_config.get_module_instance(added_module_id);
            const terminals = Object.values(addedModuleInstance.view_config.terminals).flat();
            let terminalToClick;
            if (selectedTerminal.type === "requirement") {
              terminalToClick = terminals.find((t) => t.interface === selectedTerminal.interface && t.type === "provide");
            } else {
              terminalToClick = terminals.find((t) => t.interface === selectedTerminal.interface && t.type === "requirement");
            }
            evbcStore.get_config_context().clicked_terminal(terminalToClick, added_module_id);
          }
        },
        create_config(name, content2) {
          const new_config = evbc.create_config_model(name, content2);
          evbcStore.setOpenedConfig(new_config);
          this.expansionPanelState = ["modules"];
        },
        load_config_if_empty(name) {
          if (!this.current_config) {
            this.load_config(name);
            return;
          }
          this.config_to_load = name;
          this.show_dialog = true;
        },
        load_config(name) {
          if (!name)
            return;
          this.show_dialog = false;
          const new_config = evbc.load_config(name);
          evbcStore.setOpenedConfig(new_config);
          this.expansionPanelState = ["modules"];
        },
        restart_modules() {
          evbc._cxn.rpc_issuer.restart_modules().then(() => {
            notyf.success("Issued restart modules command");
          });
        },
        close_dialog() {
          this.show_dialog = false;
        }
      }
    });
    const VExpansionPanelSymbol = Symbol.for("vuetify:v-expansion-panel");
    const makeVExpansionPanelTextProps = propsFactory({
      ...makeComponentProps(),
      ...makeLazyProps()
    }, "VExpansionPanelText");
    const VExpansionPanelText = genericComponent()({
      name: "VExpansionPanelText",
      props: makeVExpansionPanelTextProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const expansionPanel = inject$1(VExpansionPanelSymbol);
        if (!expansionPanel)
          throw new Error("[Vuetify] v-expansion-panel-text needs to be placed inside v-expansion-panel");
        const {
          hasContent,
          onAfterLeave
        } = useLazy(props, expansionPanel.isSelected);
        useRender(() => createVNode(VExpandTransition, {
          "onAfterLeave": onAfterLeave
        }, {
          default: () => {
            var _a2;
            return [withDirectives(createVNode("div", {
              "class": ["v-expansion-panel-text", props.class],
              "style": props.style
            }, [slots.default && hasContent.value && createVNode("div", {
              "class": "v-expansion-panel-text__wrapper"
            }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)])]), [[vShow, expansionPanel.isSelected.value]])];
          }
        }));
        return {};
      }
    });
    const makeVExpansionPanelTitleProps = propsFactory({
      color: String,
      expandIcon: {
        type: IconValue,
        default: "$expand"
      },
      collapseIcon: {
        type: IconValue,
        default: "$collapse"
      },
      hideActions: Boolean,
      focusable: Boolean,
      static: Boolean,
      ripple: {
        type: [Boolean, Object],
        default: false
      },
      readonly: Boolean,
      ...makeComponentProps()
    }, "VExpansionPanelTitle");
    const VExpansionPanelTitle = genericComponent()({
      name: "VExpansionPanelTitle",
      directives: {
        Ripple
      },
      props: makeVExpansionPanelTitleProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const expansionPanel = inject$1(VExpansionPanelSymbol);
        if (!expansionPanel)
          throw new Error("[Vuetify] v-expansion-panel-title needs to be placed inside v-expansion-panel");
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(props, "color");
        const slotProps = computed(() => ({
          collapseIcon: props.collapseIcon,
          disabled: expansionPanel.disabled.value,
          expanded: expansionPanel.isSelected.value,
          expandIcon: props.expandIcon,
          readonly: props.readonly
        }));
        const icon = computed(() => expansionPanel.isSelected.value ? props.collapseIcon : props.expandIcon);
        useRender(() => {
          var _a2;
          return withDirectives(createVNode("button", {
            "class": ["v-expansion-panel-title", {
              "v-expansion-panel-title--active": expansionPanel.isSelected.value,
              "v-expansion-panel-title--focusable": props.focusable,
              "v-expansion-panel-title--static": props.static
            }, backgroundColorClasses.value, props.class],
            "style": [backgroundColorStyles.value, props.style],
            "type": "button",
            "tabindex": expansionPanel.disabled.value ? -1 : void 0,
            "disabled": expansionPanel.disabled.value,
            "aria-expanded": expansionPanel.isSelected.value,
            "onClick": !props.readonly ? expansionPanel.toggle : void 0
          }, [createVNode("span", {
            "class": "v-expansion-panel-title__overlay"
          }, null), (_a2 = slots.default) == null ? void 0 : _a2.call(slots, slotProps.value), !props.hideActions && createVNode(VDefaultsProvider, {
            "defaults": {
              VIcon: {
                icon: icon.value
              }
            }
          }, {
            default: () => {
              var _a3;
              return [createVNode("span", {
                "class": "v-expansion-panel-title__icon"
              }, [((_a3 = slots.actions) == null ? void 0 : _a3.call(slots, slotProps.value)) ?? createVNode(VIcon, null, null)])];
            }
          })]), [[resolveDirective("ripple"), props.ripple]]);
        });
        return {};
      }
    });
    const makeVExpansionPanelProps = propsFactory({
      title: String,
      text: String,
      bgColor: String,
      ...makeElevationProps(),
      ...makeGroupItemProps(),
      ...makeRoundedProps(),
      ...makeTagProps(),
      ...makeVExpansionPanelTitleProps(),
      ...makeVExpansionPanelTextProps()
    }, "VExpansionPanel");
    const VExpansionPanel = genericComponent()({
      name: "VExpansionPanel",
      props: makeVExpansionPanelProps(),
      emits: {
        "group:selected": (val) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const groupItem = useGroupItem(props, VExpansionPanelSymbol);
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(props, "bgColor");
        const {
          elevationClasses
        } = useElevation(props);
        const {
          roundedClasses
        } = useRounded(props);
        const isDisabled = computed(() => (groupItem == null ? void 0 : groupItem.disabled.value) || props.disabled);
        const selectedIndices = computed(() => groupItem.group.items.value.reduce((arr, item, index) => {
          if (groupItem.group.selected.value.includes(item.id))
            arr.push(index);
          return arr;
        }, []));
        const isBeforeSelected = computed(() => {
          const index = groupItem.group.items.value.findIndex((item) => item.id === groupItem.id);
          return !groupItem.isSelected.value && selectedIndices.value.some((selectedIndex) => selectedIndex - index === 1);
        });
        const isAfterSelected = computed(() => {
          const index = groupItem.group.items.value.findIndex((item) => item.id === groupItem.id);
          return !groupItem.isSelected.value && selectedIndices.value.some((selectedIndex) => selectedIndex - index === -1);
        });
        provide(VExpansionPanelSymbol, groupItem);
        useRender(() => {
          const hasText = !!(slots.text || props.text);
          const hasTitle = !!(slots.title || props.title);
          const expansionPanelTitleProps = VExpansionPanelTitle.filterProps(props);
          const expansionPanelTextProps = VExpansionPanelText.filterProps(props);
          return createVNode(props.tag, {
            "class": ["v-expansion-panel", {
              "v-expansion-panel--active": groupItem.isSelected.value,
              "v-expansion-panel--before-active": isBeforeSelected.value,
              "v-expansion-panel--after-active": isAfterSelected.value,
              "v-expansion-panel--disabled": isDisabled.value
            }, roundedClasses.value, backgroundColorClasses.value, props.class],
            "style": [backgroundColorStyles.value, props.style]
          }, {
            default: () => [createVNode("div", {
              "class": ["v-expansion-panel__shadow", ...elevationClasses.value]
            }, null), createVNode(VDefaultsProvider, {
              "defaults": {
                VExpansionPanelTitle: {
                  ...expansionPanelTitleProps
                },
                VExpansionPanelText: {
                  ...expansionPanelTextProps
                }
              }
            }, {
              default: () => {
                var _a2;
                return [hasTitle && createVNode(VExpansionPanelTitle, {
                  "key": "title"
                }, {
                  default: () => [slots.title ? slots.title() : props.title]
                }), hasText && createVNode(VExpansionPanelText, {
                  "key": "text"
                }, {
                  default: () => [slots.text ? slots.text() : props.text]
                }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots)];
              }
            })]
          });
        });
        return {
          groupItem
        };
      }
    });
    const allowedVariants = ["default", "accordion", "inset", "popout"];
    const makeVExpansionPanelsProps = propsFactory({
      flat: Boolean,
      ...makeGroupProps(),
      ...pick(makeVExpansionPanelProps(), ["bgColor", "collapseIcon", "color", "eager", "elevation", "expandIcon", "focusable", "hideActions", "readonly", "ripple", "rounded", "tile", "static"]),
      ...makeThemeProps(),
      ...makeComponentProps(),
      ...makeTagProps(),
      variant: {
        type: String,
        default: "default",
        validator: (v) => allowedVariants.includes(v)
      }
    }, "VExpansionPanels");
    const VExpansionPanels = genericComponent()({
      name: "VExpansionPanels",
      props: makeVExpansionPanelsProps(),
      emits: {
        "update:modelValue": (val) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          next: next2,
          prev
        } = useGroup(props, VExpansionPanelSymbol);
        const {
          themeClasses
        } = provideTheme(props);
        const variantClass = computed(() => props.variant && `v-expansion-panels--variant-${props.variant}`);
        provideDefaults({
          VExpansionPanel: {
            bgColor: toRef(props, "bgColor"),
            collapseIcon: toRef(props, "collapseIcon"),
            color: toRef(props, "color"),
            eager: toRef(props, "eager"),
            elevation: toRef(props, "elevation"),
            expandIcon: toRef(props, "expandIcon"),
            focusable: toRef(props, "focusable"),
            hideActions: toRef(props, "hideActions"),
            readonly: toRef(props, "readonly"),
            ripple: toRef(props, "ripple"),
            rounded: toRef(props, "rounded"),
            static: toRef(props, "static")
          }
        });
        useRender(() => createVNode(props.tag, {
          "class": ["v-expansion-panels", {
            "v-expansion-panels--flat": props.flat,
            "v-expansion-panels--tile": props.tile
          }, themeClasses.value, variantClass.value, props.class],
          "style": props.style
        }, {
          default: () => {
            var _a2;
            return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
              prev,
              next: next2
            })];
          }
        }));
        return {
          next: next2,
          prev
        };
      }
    });
    function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_create_config = resolveComponent("create-config");
      const _component_ev_dialog = resolveComponent("ev-dialog");
      return openBlock(), createBlock(VExpansionPanels, {
        class: "ma-0",
        modelValue: _ctx.expansionPanelState,
        "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.expansionPanelState = $event)
      }, {
        default: withCtx(() => [
          createVNode(VExpansionPanel, {
            "data-cy": "modules-expansion-panel",
            value: "modules",
            disabled: !_ctx.current_config
          }, {
            default: withCtx(() => [
              createVNode(VExpansionPanelTitle, null, {
                default: withCtx(() => [
                  createTextVNode(" Available modules")
                ]),
                _: 1
              }),
              createVNode(VExpansionPanelText, null, {
                default: withCtx(() => [
                  _ctx.show_search ? (openBlock(), createBlock(VTextField, {
                    key: 0,
                    modelValue: _ctx.search,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.search = $event),
                    "hide-details": "",
                    label: "Search",
                    density: "compact",
                    variant: "outlined",
                    "data-cy": "modules-search",
                    clearable: ""
                  }, null, 8, ["modelValue"])) : createCommentVNode("", true),
                  createVNode(VList, { class: "ma-0" }, {
                    default: withCtx(() => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filtered_module_list, (module2) => {
                        return openBlock(), createBlock(VTooltip, {
                          location: "right",
                          key: module2.type,
                          "open-delay": "500"
                        }, {
                          activator: withCtx(({ props }) => [
                            createVNode(VListItem, mergeProps({ ref_for: true }, props, {
                              title: module2.type,
                              onClick: withModifiers(($event) => _ctx.add_module_to_config(module2.type), ["stop"]),
                              "data-cy": "module-list-item"
                            }), {
                              append: withCtx(() => [
                                createVNode(VIcon, null, {
                                  default: withCtx(() => [
                                    createTextVNode("mdi-plus")
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 2
                            }, 1040, ["title", "onClick"])
                          ]),
                          default: withCtx(() => [
                            createBaseVNode("span", null, toDisplayString(`${module2.type}: ${module2.description}`), 1)
                          ]),
                          _: 2
                        }, 1024);
                      }), 128))
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["disabled"]),
          createVNode(VExpansionPanel, { value: "configs" }, {
            default: withCtx(() => [
              createVNode(VExpansionPanelTitle, { "data-cy": "configs-expansion-panel" }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(_ctx.config_list.length == 0 ? "No configs available" : "Available configs"), 1)
                ]),
                _: 1
              }),
              createVNode(VExpansionPanelText, null, {
                default: withCtx(() => [
                  createVNode(_component_create_config, { onCreateConfig: _ctx.create_config }, null, 8, ["onCreateConfig"]),
                  createVNode(VList, { class: "ma-0" }, {
                    default: withCtx(() => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.config_list, (config2) => {
                        return openBlock(), createBlock(VTooltip, {
                          location: "right",
                          key: config2,
                          "open-delay": "500"
                        }, {
                          activator: withCtx(({ props }) => [
                            createVNode(VListItem, mergeProps({
                              title: config2,
                              ref_for: true
                            }, props, {
                              onClick: ($event) => _ctx.load_config_if_empty(config2),
                              "data-cy": "config-list-item"
                            }), {
                              append: withCtx(() => [
                                createVNode(VIcon, null, {
                                  default: withCtx(() => [
                                    createTextVNode("mdi-file-document-arrow-right")
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 2
                            }, 1040, ["title", "onClick"])
                          ]),
                          default: withCtx(() => [
                            createBaseVNode("span", null, toDisplayString(config2), 1)
                          ]),
                          _: 2
                        }, 1024);
                      }), 128))
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              createVNode(_component_ev_dialog, {
                show_dialog: _ctx.show_dialog,
                title: "Warning",
                text: "Do you want to discard the current config and load the new one?",
                accept_text: "Load config",
                deny_text: "Don't load config",
                onAccept: _cache[1] || (_cache[1] = ($event) => _ctx.load_config(_ctx.config_to_load)),
                onDeny: _cache[2] || (_cache[2] = ($event) => _ctx.close_dialog())
              }, null, 8, ["show_dialog"])
            ]),
            _: 1
          }),
          createVNode(VExpansionPanel, { value: "commands" }, {
            default: withCtx(() => [
              createVNode(VExpansionPanelTitle, null, {
                default: withCtx(() => [
                  createTextVNode(" Issue commands")
                ]),
                _: 1
              }),
              createVNode(VExpansionPanelText, null, {
                default: withCtx(() => [
                  createVNode(VList, null, {
                    default: withCtx(() => [
                      createVNode(VListItem, {
                        onClick: _cache[3] || (_cache[3] = ($event) => _ctx.restart_modules()),
                        title: "Restart modules"
                      }, {
                        append: withCtx(() => [
                          createVNode(VIcon, null, {
                            default: withCtx(() => [
                              createTextVNode("mdi-run")
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["modelValue"]);
    }
    const EvModuleList = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$2]]);
    var _2019 = { exports: {} };
    var dynamic$1 = {};
    var dynamicAnchor$1 = {};
    Object.defineProperty(dynamicAnchor$1, "__esModule", { value: true });
    dynamicAnchor$1.dynamicAnchor = void 0;
    const codegen_1$3 = codegen;
    const names_1$2 = names$2;
    const compile_1 = compile$2;
    const ref_1$1 = ref;
    const def$8 = {
      keyword: "$dynamicAnchor",
      schemaType: "string",
      code: (cxt) => dynamicAnchor(cxt, cxt.schema)
    };
    function dynamicAnchor(cxt, anchor) {
      const { gen, it: it2 } = cxt;
      it2.schemaEnv.root.dynamicAnchors[anchor] = true;
      const v = (0, codegen_1$3._)`${names_1$2.default.dynamicAnchors}${(0, codegen_1$3.getProperty)(anchor)}`;
      const validate2 = it2.errSchemaPath === "#" ? it2.validateName : _getValidate(cxt);
      gen.if((0, codegen_1$3._)`!${v}`, () => gen.assign(v, validate2));
    }
    dynamicAnchor$1.dynamicAnchor = dynamicAnchor;
    function _getValidate(cxt) {
      const { schemaEnv, schema: schema2, self: self2 } = cxt.it;
      const { root, baseId, localRefs, meta } = schemaEnv.root;
      const { schemaId } = self2.opts;
      const sch = new compile_1.SchemaEnv({ schema: schema2, schemaId, root, baseId, localRefs, meta });
      compile_1.compileSchema.call(self2, sch);
      return (0, ref_1$1.getValidate)(cxt, sch);
    }
    dynamicAnchor$1.default = def$8;
    var dynamicRef$1 = {};
    Object.defineProperty(dynamicRef$1, "__esModule", { value: true });
    dynamicRef$1.dynamicRef = void 0;
    const codegen_1$2 = codegen;
    const names_1$1 = names$2;
    const ref_1 = ref;
    const def$7 = {
      keyword: "$dynamicRef",
      schemaType: "string",
      code: (cxt) => dynamicRef(cxt, cxt.schema)
    };
    function dynamicRef(cxt, ref2) {
      const { gen, keyword: keyword2, it: it2 } = cxt;
      if (ref2[0] !== "#")
        throw new Error(`"${keyword2}" only supports hash fragment reference`);
      const anchor = ref2.slice(1);
      if (it2.allErrors) {
        _dynamicRef();
      } else {
        const valid = gen.let("valid", false);
        _dynamicRef(valid);
        cxt.ok(valid);
      }
      function _dynamicRef(valid) {
        if (it2.schemaEnv.root.dynamicAnchors[anchor]) {
          const v = gen.let("_v", (0, codegen_1$2._)`${names_1$1.default.dynamicAnchors}${(0, codegen_1$2.getProperty)(anchor)}`);
          gen.if(v, _callRef(v, valid), _callRef(it2.validateName, valid));
        } else {
          _callRef(it2.validateName, valid)();
        }
      }
      function _callRef(validate2, valid) {
        return valid ? () => gen.block(() => {
          (0, ref_1.callRef)(cxt, validate2);
          gen.let(valid, true);
        }) : () => (0, ref_1.callRef)(cxt, validate2);
      }
    }
    dynamicRef$1.dynamicRef = dynamicRef;
    dynamicRef$1.default = def$7;
    var recursiveAnchor = {};
    Object.defineProperty(recursiveAnchor, "__esModule", { value: true });
    const dynamicAnchor_1$1 = dynamicAnchor$1;
    const util_1$3 = util;
    const def$6 = {
      keyword: "$recursiveAnchor",
      schemaType: "boolean",
      code(cxt) {
        if (cxt.schema)
          (0, dynamicAnchor_1$1.dynamicAnchor)(cxt, "");
        else
          (0, util_1$3.checkStrictMode)(cxt.it, "$recursiveAnchor: false is ignored");
      }
    };
    recursiveAnchor.default = def$6;
    var recursiveRef = {};
    Object.defineProperty(recursiveRef, "__esModule", { value: true });
    const dynamicRef_1$1 = dynamicRef$1;
    const def$5 = {
      keyword: "$recursiveRef",
      schemaType: "string",
      code: (cxt) => (0, dynamicRef_1$1.dynamicRef)(cxt, cxt.schema)
    };
    recursiveRef.default = def$5;
    Object.defineProperty(dynamic$1, "__esModule", { value: true });
    const dynamicAnchor_1 = dynamicAnchor$1;
    const dynamicRef_1 = dynamicRef$1;
    const recursiveAnchor_1 = recursiveAnchor;
    const recursiveRef_1 = recursiveRef;
    const dynamic = [dynamicAnchor_1.default, dynamicRef_1.default, recursiveAnchor_1.default, recursiveRef_1.default];
    dynamic$1.default = dynamic;
    var next$1 = {};
    var dependentRequired = {};
    Object.defineProperty(dependentRequired, "__esModule", { value: true });
    const dependencies_1$1 = dependencies;
    const def$4 = {
      keyword: "dependentRequired",
      type: "object",
      schemaType: "object",
      error: dependencies_1$1.error,
      code: (cxt) => (0, dependencies_1$1.validatePropertyDeps)(cxt)
    };
    dependentRequired.default = def$4;
    var dependentSchemas = {};
    Object.defineProperty(dependentSchemas, "__esModule", { value: true });
    const dependencies_1 = dependencies;
    const def$3 = {
      keyword: "dependentSchemas",
      type: "object",
      schemaType: "object",
      code: (cxt) => (0, dependencies_1.validateSchemaDeps)(cxt)
    };
    dependentSchemas.default = def$3;
    var limitContains = {};
    Object.defineProperty(limitContains, "__esModule", { value: true });
    const util_1$2 = util;
    const def$2 = {
      keyword: ["maxContains", "minContains"],
      type: "array",
      schemaType: "number",
      code({ keyword: keyword2, parentSchema, it: it2 }) {
        if (parentSchema.contains === void 0) {
          (0, util_1$2.checkStrictMode)(it2, `"${keyword2}" without "contains" is ignored`);
        }
      }
    };
    limitContains.default = def$2;
    Object.defineProperty(next$1, "__esModule", { value: true });
    const dependentRequired_1 = dependentRequired;
    const dependentSchemas_1 = dependentSchemas;
    const limitContains_1 = limitContains;
    const next = [dependentRequired_1.default, dependentSchemas_1.default, limitContains_1.default];
    next$1.default = next;
    var unevaluated$1 = {};
    var unevaluatedProperties = {};
    Object.defineProperty(unevaluatedProperties, "__esModule", { value: true });
    const codegen_1$1 = codegen;
    const util_1$1 = util;
    const names_1 = names$2;
    const error$2 = {
      message: "must NOT have unevaluated properties",
      params: ({ params }) => (0, codegen_1$1._)`{unevaluatedProperty: ${params.unevaluatedProperty}}`
    };
    const def$1 = {
      keyword: "unevaluatedProperties",
      type: "object",
      schemaType: ["boolean", "object"],
      trackErrors: true,
      error: error$2,
      code(cxt) {
        const { gen, schema: schema2, data, errsCount, it: it2 } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, props } = it2;
        if (props instanceof codegen_1$1.Name) {
          gen.if((0, codegen_1$1._)`${props} !== true`, () => gen.forIn("key", data, (key) => gen.if(unevaluatedDynamic(props, key), () => unevaluatedPropCode(key))));
        } else if (props !== true) {
          gen.forIn("key", data, (key) => props === void 0 ? unevaluatedPropCode(key) : gen.if(unevaluatedStatic(props, key), () => unevaluatedPropCode(key)));
        }
        it2.props = true;
        cxt.ok((0, codegen_1$1._)`${errsCount} === ${names_1.default.errors}`);
        function unevaluatedPropCode(key) {
          if (schema2 === false) {
            cxt.setParams({ unevaluatedProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (!(0, util_1$1.alwaysValidSchema)(it2, schema2)) {
            const valid = gen.name("valid");
            cxt.subschema({
              keyword: "unevaluatedProperties",
              dataProp: key,
              dataPropType: util_1$1.Type.Str
            }, valid);
            if (!allErrors)
              gen.if((0, codegen_1$1.not)(valid), () => gen.break());
          }
        }
        function unevaluatedDynamic(evaluatedProps, key) {
          return (0, codegen_1$1._)`!${evaluatedProps} || !${evaluatedProps}[${key}]`;
        }
        function unevaluatedStatic(evaluatedProps, key) {
          const ps = [];
          for (const p2 in evaluatedProps) {
            if (evaluatedProps[p2] === true)
              ps.push((0, codegen_1$1._)`${key} !== ${p2}`);
          }
          return (0, codegen_1$1.and)(...ps);
        }
      }
    };
    unevaluatedProperties.default = def$1;
    var unevaluatedItems = {};
    Object.defineProperty(unevaluatedItems, "__esModule", { value: true });
    const codegen_1 = codegen;
    const util_1 = util;
    const error$1 = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    const def = {
      keyword: "unevaluatedItems",
      type: "array",
      schemaType: ["boolean", "object"],
      error: error$1,
      code(cxt) {
        const { gen, schema: schema2, data, it: it2 } = cxt;
        const items2 = it2.items || 0;
        if (items2 === true)
          return;
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        if (schema2 === false) {
          cxt.setParams({ len: items2 });
          cxt.fail((0, codegen_1._)`${len} > ${items2}`);
        } else if (typeof schema2 == "object" && !(0, util_1.alwaysValidSchema)(it2, schema2)) {
          const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items2}`);
          gen.if((0, codegen_1.not)(valid), () => validateItems(valid, items2));
          cxt.ok(valid);
        }
        it2.items = true;
        function validateItems(valid, from) {
          gen.forRange("i", from, len, (i2) => {
            cxt.subschema({ keyword: "unevaluatedItems", dataProp: i2, dataPropType: util_1.Type.Num }, valid);
            if (!it2.allErrors)
              gen.if((0, codegen_1.not)(valid), () => gen.break());
          });
        }
      }
    };
    unevaluatedItems.default = def;
    Object.defineProperty(unevaluated$1, "__esModule", { value: true });
    const unevaluatedProperties_1 = unevaluatedProperties;
    const unevaluatedItems_1 = unevaluatedItems;
    const unevaluated = [unevaluatedProperties_1.default, unevaluatedItems_1.default];
    unevaluated$1.default = unevaluated;
    var jsonSchema201909 = {};
    const $schema$6 = "https://json-schema.org/draft/2019-09/schema";
    const $id$6 = "https://json-schema.org/draft/2019-09/schema";
    const $vocabulary$6 = {
      "https://json-schema.org/draft/2019-09/vocab/core": true,
      "https://json-schema.org/draft/2019-09/vocab/applicator": true,
      "https://json-schema.org/draft/2019-09/vocab/validation": true,
      "https://json-schema.org/draft/2019-09/vocab/meta-data": true,
      "https://json-schema.org/draft/2019-09/vocab/format": false,
      "https://json-schema.org/draft/2019-09/vocab/content": true
    };
    const $recursiveAnchor$6 = true;
    const title$6 = "Core and Validation specifications meta-schema";
    const allOf = [
      {
        $ref: "meta/core"
      },
      {
        $ref: "meta/applicator"
      },
      {
        $ref: "meta/validation"
      },
      {
        $ref: "meta/meta-data"
      },
      {
        $ref: "meta/format"
      },
      {
        $ref: "meta/content"
      }
    ];
    const type$6 = [
      "object",
      "boolean"
    ];
    const properties$6 = {
      definitions: {
        $comment: "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",
        type: "object",
        additionalProperties: {
          $recursiveRef: "#"
        },
        "default": {}
      },
      dependencies: {
        $comment: '"dependencies" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to "dependentSchemas" and "dependentRequired"',
        type: "object",
        additionalProperties: {
          anyOf: [
            {
              $recursiveRef: "#"
            },
            {
              $ref: "meta/validation#/$defs/stringArray"
            }
          ]
        }
      }
    };
    const require$$0$1 = {
      $schema: $schema$6,
      $id: $id$6,
      $vocabulary: $vocabulary$6,
      $recursiveAnchor: $recursiveAnchor$6,
      title: title$6,
      allOf,
      type: type$6,
      properties: properties$6
    };
    const $schema$5 = "https://json-schema.org/draft/2019-09/schema";
    const $id$5 = "https://json-schema.org/draft/2019-09/meta/applicator";
    const $vocabulary$5 = {
      "https://json-schema.org/draft/2019-09/vocab/applicator": true
    };
    const $recursiveAnchor$5 = true;
    const title$5 = "Applicator vocabulary meta-schema";
    const type$5 = [
      "object",
      "boolean"
    ];
    const properties$5 = {
      additionalItems: {
        $recursiveRef: "#"
      },
      unevaluatedItems: {
        $recursiveRef: "#"
      },
      items: {
        anyOf: [
          {
            $recursiveRef: "#"
          },
          {
            $ref: "#/$defs/schemaArray"
          }
        ]
      },
      contains: {
        $recursiveRef: "#"
      },
      additionalProperties: {
        $recursiveRef: "#"
      },
      unevaluatedProperties: {
        $recursiveRef: "#"
      },
      properties: {
        type: "object",
        additionalProperties: {
          $recursiveRef: "#"
        },
        "default": {}
      },
      patternProperties: {
        type: "object",
        additionalProperties: {
          $recursiveRef: "#"
        },
        propertyNames: {
          format: "regex"
        },
        "default": {}
      },
      dependentSchemas: {
        type: "object",
        additionalProperties: {
          $recursiveRef: "#"
        }
      },
      propertyNames: {
        $recursiveRef: "#"
      },
      "if": {
        $recursiveRef: "#"
      },
      then: {
        $recursiveRef: "#"
      },
      "else": {
        $recursiveRef: "#"
      },
      allOf: {
        $ref: "#/$defs/schemaArray"
      },
      anyOf: {
        $ref: "#/$defs/schemaArray"
      },
      oneOf: {
        $ref: "#/$defs/schemaArray"
      },
      not: {
        $recursiveRef: "#"
      }
    };
    const $defs$1 = {
      schemaArray: {
        type: "array",
        minItems: 1,
        items: {
          $recursiveRef: "#"
        }
      }
    };
    const require$$1 = {
      $schema: $schema$5,
      $id: $id$5,
      $vocabulary: $vocabulary$5,
      $recursiveAnchor: $recursiveAnchor$5,
      title: title$5,
      type: type$5,
      properties: properties$5,
      $defs: $defs$1
    };
    const $schema$4 = "https://json-schema.org/draft/2019-09/schema";
    const $id$4 = "https://json-schema.org/draft/2019-09/meta/content";
    const $vocabulary$4 = {
      "https://json-schema.org/draft/2019-09/vocab/content": true
    };
    const $recursiveAnchor$4 = true;
    const title$4 = "Content vocabulary meta-schema";
    const type$4 = [
      "object",
      "boolean"
    ];
    const properties$4 = {
      contentMediaType: {
        type: "string"
      },
      contentEncoding: {
        type: "string"
      },
      contentSchema: {
        $recursiveRef: "#"
      }
    };
    const require$$2 = {
      $schema: $schema$4,
      $id: $id$4,
      $vocabulary: $vocabulary$4,
      $recursiveAnchor: $recursiveAnchor$4,
      title: title$4,
      type: type$4,
      properties: properties$4
    };
    const $schema$3 = "https://json-schema.org/draft/2019-09/schema";
    const $id$3 = "https://json-schema.org/draft/2019-09/meta/core";
    const $vocabulary$3 = {
      "https://json-schema.org/draft/2019-09/vocab/core": true
    };
    const $recursiveAnchor$3 = true;
    const title$3 = "Core vocabulary meta-schema";
    const type$3 = [
      "object",
      "boolean"
    ];
    const properties$3 = {
      $id: {
        type: "string",
        format: "uri-reference",
        $comment: "Non-empty fragments not allowed.",
        pattern: "^[^#]*#?$"
      },
      $schema: {
        type: "string",
        format: "uri"
      },
      $anchor: {
        type: "string",
        pattern: "^[A-Za-z][-A-Za-z0-9.:_]*$"
      },
      $ref: {
        type: "string",
        format: "uri-reference"
      },
      $recursiveRef: {
        type: "string",
        format: "uri-reference"
      },
      $recursiveAnchor: {
        type: "boolean",
        "default": false
      },
      $vocabulary: {
        type: "object",
        propertyNames: {
          type: "string",
          format: "uri"
        },
        additionalProperties: {
          type: "boolean"
        }
      },
      $comment: {
        type: "string"
      },
      $defs: {
        type: "object",
        additionalProperties: {
          $recursiveRef: "#"
        },
        "default": {}
      }
    };
    const require$$3 = {
      $schema: $schema$3,
      $id: $id$3,
      $vocabulary: $vocabulary$3,
      $recursiveAnchor: $recursiveAnchor$3,
      title: title$3,
      type: type$3,
      properties: properties$3
    };
    const $schema$2 = "https://json-schema.org/draft/2019-09/schema";
    const $id$2 = "https://json-schema.org/draft/2019-09/meta/format";
    const $vocabulary$2 = {
      "https://json-schema.org/draft/2019-09/vocab/format": true
    };
    const $recursiveAnchor$2 = true;
    const title$2 = "Format vocabulary meta-schema";
    const type$2 = [
      "object",
      "boolean"
    ];
    const properties$2 = {
      format: {
        type: "string"
      }
    };
    const require$$4 = {
      $schema: $schema$2,
      $id: $id$2,
      $vocabulary: $vocabulary$2,
      $recursiveAnchor: $recursiveAnchor$2,
      title: title$2,
      type: type$2,
      properties: properties$2
    };
    const $schema$1 = "https://json-schema.org/draft/2019-09/schema";
    const $id$1 = "https://json-schema.org/draft/2019-09/meta/meta-data";
    const $vocabulary$1 = {
      "https://json-schema.org/draft/2019-09/vocab/meta-data": true
    };
    const $recursiveAnchor$1 = true;
    const title$1 = "Meta-data vocabulary meta-schema";
    const type$1 = [
      "object",
      "boolean"
    ];
    const properties$1 = {
      title: {
        type: "string"
      },
      description: {
        type: "string"
      },
      "default": true,
      deprecated: {
        type: "boolean",
        "default": false
      },
      readOnly: {
        type: "boolean",
        "default": false
      },
      writeOnly: {
        type: "boolean",
        "default": false
      },
      examples: {
        type: "array",
        items: true
      }
    };
    const require$$5 = {
      $schema: $schema$1,
      $id: $id$1,
      $vocabulary: $vocabulary$1,
      $recursiveAnchor: $recursiveAnchor$1,
      title: title$1,
      type: type$1,
      properties: properties$1
    };
    const $schema = "https://json-schema.org/draft/2019-09/schema";
    const $id = "https://json-schema.org/draft/2019-09/meta/validation";
    const $vocabulary = {
      "https://json-schema.org/draft/2019-09/vocab/validation": true
    };
    const $recursiveAnchor = true;
    const title = "Validation vocabulary meta-schema";
    const type = [
      "object",
      "boolean"
    ];
    const properties = {
      multipleOf: {
        type: "number",
        exclusiveMinimum: 0
      },
      maximum: {
        type: "number"
      },
      exclusiveMaximum: {
        type: "number"
      },
      minimum: {
        type: "number"
      },
      exclusiveMinimum: {
        type: "number"
      },
      maxLength: {
        $ref: "#/$defs/nonNegativeInteger"
      },
      minLength: {
        $ref: "#/$defs/nonNegativeIntegerDefault0"
      },
      pattern: {
        type: "string",
        format: "regex"
      },
      maxItems: {
        $ref: "#/$defs/nonNegativeInteger"
      },
      minItems: {
        $ref: "#/$defs/nonNegativeIntegerDefault0"
      },
      uniqueItems: {
        type: "boolean",
        "default": false
      },
      maxContains: {
        $ref: "#/$defs/nonNegativeInteger"
      },
      minContains: {
        $ref: "#/$defs/nonNegativeInteger",
        "default": 1
      },
      maxProperties: {
        $ref: "#/$defs/nonNegativeInteger"
      },
      minProperties: {
        $ref: "#/$defs/nonNegativeIntegerDefault0"
      },
      required: {
        $ref: "#/$defs/stringArray"
      },
      dependentRequired: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/stringArray"
        }
      },
      "const": true,
      "enum": {
        type: "array",
        items: true
      },
      type: {
        anyOf: [
          {
            $ref: "#/$defs/simpleTypes"
          },
          {
            type: "array",
            items: {
              $ref: "#/$defs/simpleTypes"
            },
            minItems: 1,
            uniqueItems: true
          }
        ]
      }
    };
    const $defs = {
      nonNegativeInteger: {
        type: "integer",
        minimum: 0
      },
      nonNegativeIntegerDefault0: {
        $ref: "#/$defs/nonNegativeInteger",
        "default": 0
      },
      simpleTypes: {
        "enum": [
          "array",
          "boolean",
          "integer",
          "null",
          "number",
          "object",
          "string"
        ]
      },
      stringArray: {
        type: "array",
        items: {
          type: "string"
        },
        uniqueItems: true,
        "default": []
      }
    };
    const require$$6 = {
      $schema,
      $id,
      $vocabulary,
      $recursiveAnchor,
      title,
      type,
      properties,
      $defs
    };
    Object.defineProperty(jsonSchema201909, "__esModule", { value: true });
    const metaSchema = require$$0$1;
    const applicator = require$$1;
    const content = require$$2;
    const core = require$$3;
    const format$1 = require$$4;
    const metadata = require$$5;
    const validation = require$$6;
    const META_SUPPORT_DATA = ["/properties"];
    function addMetaSchema2019($data) {
      [
        metaSchema,
        applicator,
        content,
        core,
        with$data(this, format$1),
        metadata,
        with$data(this, validation)
      ].forEach((sch) => this.addMetaSchema(sch, void 0, false));
      return this;
      function with$data(ajv2, sch) {
        return $data ? ajv2.$dataMetaSchema(sch, META_SUPPORT_DATA) : sch;
      }
    }
    jsonSchema201909.default = addMetaSchema2019;
    (function(module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MissingRefError = exports2.ValidationError = exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = exports2.Ajv2019 = void 0;
      const core_12 = core$3;
      const draft7_1 = draft7;
      const dynamic_1 = dynamic$1;
      const next_1 = next$1;
      const unevaluated_1 = unevaluated$1;
      const discriminator_1 = discriminator;
      const json_schema_2019_09_1 = jsonSchema201909;
      const META_SCHEMA_ID = "https://json-schema.org/draft/2019-09/schema";
      class Ajv2019 extends core_12.default {
        constructor(opts = {}) {
          super({
            ...opts,
            dynamicRef: true,
            next: true,
            unevaluated: true
          });
        }
        _addVocabularies() {
          super._addVocabularies();
          this.addVocabulary(dynamic_1.default);
          draft7_1.default.forEach((v) => this.addVocabulary(v));
          this.addVocabulary(next_1.default);
          this.addVocabulary(unevaluated_1.default);
          if (this.opts.discriminator)
            this.addKeyword(discriminator_1.default);
        }
        _addDefaultMetaSchema() {
          super._addDefaultMetaSchema();
          const { $data, meta } = this.opts;
          if (!meta)
            return;
          json_schema_2019_09_1.default.call(this, $data);
          this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
        }
        defaultMeta() {
          return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
        }
      }
      exports2.Ajv2019 = Ajv2019;
      module2.exports = exports2 = Ajv2019;
      module2.exports.Ajv2019 = Ajv2019;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = Ajv2019;
      var validate_12 = validate;
      Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
        return validate_12.KeywordCxt;
      } });
      var codegen_12 = codegen;
      Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
        return codegen_12._;
      } });
      Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
        return codegen_12.str;
      } });
      Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
        return codegen_12.stringify;
      } });
      Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
        return codegen_12.nil;
      } });
      Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
        return codegen_12.Name;
      } });
      Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
        return codegen_12.CodeGen;
      } });
      var validation_error_12 = validation_error;
      Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
        return validation_error_12.default;
      } });
      var ref_error_12 = ref_error;
      Object.defineProperty(exports2, "MissingRefError", { enumerable: true, get: function() {
        return ref_error_12.default;
      } });
    })(_2019, _2019.exports);
    var _2019Exports = _2019.exports;
    const ajvModule = /* @__PURE__ */ getDefaultExportFromCjs(_2019Exports);
    var dist$1 = { exports: {} };
    var formats = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.formatNames = exports2.fastFormats = exports2.fullFormats = void 0;
      function fmtDef(validate2, compare) {
        return { validate: validate2, compare };
      }
      exports2.fullFormats = {
        // date: http://tools.ietf.org/html/rfc3339#section-5.6
        date: fmtDef(date2, compareDate),
        // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
        time: fmtDef(time, compareTime),
        "date-time": fmtDef(date_time, compareDateTime),
        // duration: https://tools.ietf.org/html/rfc3339#appendix-A
        duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
        uri: uri2,
        "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
        // uri-template: https://tools.ietf.org/html/rfc6570
        "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
        // For the source: https://gist.github.com/dperini/729294
        // For test cases: https://mathiasbynens.be/demo/url-regex
        url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
        email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
        hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
        // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
        ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
        regex: regex2,
        // uuid: http://tools.ietf.org/html/rfc4122
        uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
        // JSON-pointer: https://tools.ietf.org/html/rfc6901
        // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
        "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
        "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
        // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
        "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
        // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
        // byte: https://github.com/miguelmota/is-base64
        byte,
        // signed 32 bit integer
        int32: { type: "number", validate: validateInt32 },
        // signed 64 bit integer
        int64: { type: "number", validate: validateInt64 },
        // C-type float
        float: { type: "number", validate: validateNumber },
        // C-type double
        double: { type: "number", validate: validateNumber },
        // hint to the UI to hide input strings
        password: true,
        // unchecked string payload
        binary: true
      };
      exports2.fastFormats = {
        ...exports2.fullFormats,
        date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
        time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
        "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
        // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
        uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
        "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
        // email (sources from jsen validator):
        // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
        // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
        email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
      };
      exports2.formatNames = Object.keys(exports2.fullFormats);
      function isLeapYear(year) {
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
      }
      const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
      const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function date2(str2) {
        const matches = DATE.exec(str2);
        if (!matches)
          return false;
        const year = +matches[1];
        const month = +matches[2];
        const day = +matches[3];
        return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
      }
      function compareDate(d1, d2) {
        if (!(d1 && d2))
          return void 0;
        if (d1 > d2)
          return 1;
        if (d1 < d2)
          return -1;
        return 0;
      }
      const TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
      function time(str2, withTimeZone) {
        const matches = TIME.exec(str2);
        if (!matches)
          return false;
        const hour = +matches[1];
        const minute = +matches[2];
        const second = +matches[3];
        const timeZone = matches[5];
        return (hour <= 23 && minute <= 59 && second <= 59 || hour === 23 && minute === 59 && second === 60) && (!withTimeZone || timeZone !== "");
      }
      function compareTime(t1, t2) {
        if (!(t1 && t2))
          return void 0;
        const a1 = TIME.exec(t1);
        const a2 = TIME.exec(t2);
        if (!(a1 && a2))
          return void 0;
        t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
        t2 = a2[1] + a2[2] + a2[3] + (a2[4] || "");
        if (t1 > t2)
          return 1;
        if (t1 < t2)
          return -1;
        return 0;
      }
      const DATE_TIME_SEPARATOR = /t|\s/i;
      function date_time(str2) {
        const dateTime = str2.split(DATE_TIME_SEPARATOR);
        return dateTime.length === 2 && date2(dateTime[0]) && time(dateTime[1], true);
      }
      function compareDateTime(dt1, dt2) {
        if (!(dt1 && dt2))
          return void 0;
        const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
        const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
        const res = compareDate(d1, d2);
        if (res === void 0)
          return void 0;
        return res || compareTime(t1, t2);
      }
      const NOT_URI_FRAGMENT = /\/|:/;
      const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
      function uri2(str2) {
        return NOT_URI_FRAGMENT.test(str2) && URI.test(str2);
      }
      const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
      function byte(str2) {
        BYTE.lastIndex = 0;
        return BYTE.test(str2);
      }
      const MIN_INT32 = -(2 ** 31);
      const MAX_INT32 = 2 ** 31 - 1;
      function validateInt32(value) {
        return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
      }
      function validateInt64(value) {
        return Number.isInteger(value);
      }
      function validateNumber() {
        return true;
      }
      const Z_ANCHOR = /[^\\]\\Z/;
      function regex2(str2) {
        if (Z_ANCHOR.test(str2))
          return false;
        try {
          new RegExp(str2);
          return true;
        } catch (e) {
          return false;
        }
      }
    })(formats);
    var limit = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.formatLimitDefinition = void 0;
      const ajv_1 = ajvExports;
      const codegen_12 = codegen;
      const ops2 = codegen_12.operators;
      const KWDs2 = {
        formatMaximum: { okStr: "<=", ok: ops2.LTE, fail: ops2.GT },
        formatMinimum: { okStr: ">=", ok: ops2.GTE, fail: ops2.LT },
        formatExclusiveMaximum: { okStr: "<", ok: ops2.LT, fail: ops2.GTE },
        formatExclusiveMinimum: { okStr: ">", ok: ops2.GT, fail: ops2.LTE }
      };
      const error2 = {
        message: ({ keyword: keyword2, schemaCode }) => codegen_12.str`should be ${KWDs2[keyword2].okStr} ${schemaCode}`,
        params: ({ keyword: keyword2, schemaCode }) => codegen_12._`{comparison: ${KWDs2[keyword2].okStr}, limit: ${schemaCode}}`
      };
      exports2.formatLimitDefinition = {
        keyword: Object.keys(KWDs2),
        type: "string",
        schemaType: "string",
        $data: true,
        error: error2,
        code(cxt) {
          const { gen, data, schemaCode, keyword: keyword2, it: it2 } = cxt;
          const { opts, self: self2 } = it2;
          if (!opts.validateFormats)
            return;
          const fCxt = new ajv_1.KeywordCxt(it2, self2.RULES.all.format.definition, "format");
          if (fCxt.$data)
            validate$DataFormat();
          else
            validateFormat();
          function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
              ref: self2.formats,
              code: opts.code.formats
            });
            const fmt = gen.const("fmt", codegen_12._`${fmts}[${fCxt.schemaCode}]`);
            cxt.fail$data(codegen_12.or(codegen_12._`typeof ${fmt} != "object"`, codegen_12._`${fmt} instanceof RegExp`, codegen_12._`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
          }
          function validateFormat() {
            const format2 = fCxt.schema;
            const fmtDef = self2.formats[format2];
            if (!fmtDef || fmtDef === true)
              return;
            if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
              throw new Error(`"${keyword2}": format "${format2}" does not define "compare" function`);
            }
            const fmt = gen.scopeValue("formats", {
              key: format2,
              ref: fmtDef,
              code: opts.code.formats ? codegen_12._`${opts.code.formats}${codegen_12.getProperty(format2)}` : void 0
            });
            cxt.fail$data(compareCode(fmt));
          }
          function compareCode(fmt) {
            return codegen_12._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs2[keyword2].fail} 0`;
          }
        },
        dependencies: ["format"]
      };
      const formatLimitPlugin = (ajv2) => {
        ajv2.addKeyword(exports2.formatLimitDefinition);
        return ajv2;
      };
      exports2.default = formatLimitPlugin;
    })(limit);
    (function(module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      const formats_1 = formats;
      const limit_1 = limit;
      const codegen_12 = codegen;
      const fullName = new codegen_12.Name("fullFormats");
      const fastName = new codegen_12.Name("fastFormats");
      const formatsPlugin = (ajv2, opts = { keywords: true }) => {
        if (Array.isArray(opts)) {
          addFormats2(ajv2, opts, formats_1.fullFormats, fullName);
          return ajv2;
        }
        const [formats2, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
        const list2 = opts.formats || formats_1.formatNames;
        addFormats2(ajv2, list2, formats2, exportName);
        if (opts.keywords)
          limit_1.default(ajv2);
        return ajv2;
      };
      formatsPlugin.get = (name, mode = "full") => {
        const formats2 = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
        const f = formats2[name];
        if (!f)
          throw new Error(`Unknown format "${name}"`);
        return f;
      };
      function addFormats2(ajv2, list2, fs, exportName) {
        var _a2;
        var _b;
        (_a2 = (_b = ajv2.opts.code).formats) !== null && _a2 !== void 0 ? _a2 : _b.formats = codegen_12._`require("ajv-formats/dist/formats").${exportName}`;
        for (const f of list2)
          ajv2.addFormat(f, fs[f]);
      }
      module2.exports = exports2 = formatsPlugin;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = formatsPlugin;
    })(dist$1, dist$1.exports);
    var distExports$1 = dist$1.exports;
    const addFormats = /* @__PURE__ */ getDefaultExportFromCjs(distExports$1);
    var dist = { exports: {} };
    (function(module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      const ajv_1 = ajvExports;
      const codegen_12 = codegen;
      const code_12 = code$2;
      const validate_12 = validate;
      const errors_12 = errors$1;
      const names_12 = names$2;
      const keyword2 = "errorMessage";
      const used = new ajv_1.Name("emUsed");
      const KEYWORD_PROPERTY_PARAMS = {
        required: "missingProperty",
        dependencies: "property",
        dependentRequired: "property"
      };
      const INTERPOLATION = /\$\{[^}]+\}/;
      const INTERPOLATION_REPLACE = /\$\{([^}]+)\}/g;
      const EMPTY_STR = /^""\s*\+\s*|\s*\+\s*""$/g;
      function errorMessage(options) {
        return {
          keyword: keyword2,
          schemaType: ["string", "object"],
          post: true,
          code(cxt) {
            const { gen, data, schema: schema2, schemaValue, it: it2 } = cxt;
            if (it2.createErrors === false)
              return;
            const sch = schema2;
            const instancePath = codegen_12.strConcat(names_12.default.instancePath, it2.errorPath);
            gen.if(ajv_1._`${names_12.default.errors} > 0`, () => {
              if (typeof sch == "object") {
                const [kwdPropErrors, kwdErrors] = keywordErrorsConfig(sch);
                if (kwdErrors)
                  processKeywordErrors(kwdErrors);
                if (kwdPropErrors)
                  processKeywordPropErrors(kwdPropErrors);
                processChildErrors(childErrorsConfig(sch));
              }
              const schMessage = typeof sch == "string" ? sch : sch._;
              if (schMessage)
                processAllErrors(schMessage);
              if (!options.keepErrors)
                removeUsedErrors();
            });
            function childErrorsConfig({ properties: properties2, items: items2 }) {
              const errors2 = {};
              if (properties2) {
                errors2.props = {};
                for (const p2 in properties2)
                  errors2.props[p2] = [];
              }
              if (items2) {
                errors2.items = {};
                for (let i2 = 0; i2 < items2.length; i2++)
                  errors2.items[i2] = [];
              }
              return errors2;
            }
            function keywordErrorsConfig(emSchema) {
              let propErrors;
              let errors2;
              for (const k in emSchema) {
                if (k === "properties" || k === "items")
                  continue;
                const kwdSch = emSchema[k];
                if (typeof kwdSch == "object") {
                  propErrors || (propErrors = {});
                  const errMap = propErrors[k] = {};
                  for (const p2 in kwdSch)
                    errMap[p2] = [];
                } else {
                  errors2 || (errors2 = {});
                  errors2[k] = [];
                }
              }
              return [propErrors, errors2];
            }
            function processKeywordErrors(kwdErrors) {
              const kwdErrs = gen.const("emErrors", ajv_1.stringify(kwdErrors));
              const templates = gen.const("templates", getTemplatesCode(kwdErrors, schema2));
              gen.forOf("err", names_12.default.vErrors, (err) => gen.if(matchKeywordError(err, kwdErrs), () => gen.code(ajv_1._`${kwdErrs}[${err}.keyword].push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
              const { singleError } = options;
              if (singleError) {
                const message = gen.let("message", ajv_1._`""`);
                const paramsErrors = gen.let("paramsErrors", ajv_1._`[]`);
                loopErrors((key) => {
                  gen.if(message, () => gen.code(ajv_1._`${message} += ${typeof singleError == "string" ? singleError : ";"}`));
                  gen.code(ajv_1._`${message} += ${errMessage(key)}`);
                  gen.assign(paramsErrors, ajv_1._`${paramsErrors}.concat(${kwdErrs}[${key}])`);
                });
                errors_12.reportError(cxt, { message, params: ajv_1._`{errors: ${paramsErrors}}` });
              } else {
                loopErrors((key) => errors_12.reportError(cxt, {
                  message: errMessage(key),
                  params: ajv_1._`{errors: ${kwdErrs}[${key}]}`
                }));
              }
              function loopErrors(body) {
                gen.forIn("key", kwdErrs, (key) => gen.if(ajv_1._`${kwdErrs}[${key}].length`, () => body(key)));
              }
              function errMessage(key) {
                return ajv_1._`${key} in ${templates} ? ${templates}[${key}]() : ${schemaValue}[${key}]`;
              }
            }
            function processKeywordPropErrors(kwdPropErrors) {
              const kwdErrs = gen.const("emErrors", ajv_1.stringify(kwdPropErrors));
              const templatesCode = [];
              for (const k in kwdPropErrors) {
                templatesCode.push([
                  k,
                  getTemplatesCode(kwdPropErrors[k], schema2[k])
                ]);
              }
              const templates = gen.const("templates", gen.object(...templatesCode));
              const kwdPropParams = gen.scopeValue("obj", {
                ref: KEYWORD_PROPERTY_PARAMS,
                code: ajv_1.stringify(KEYWORD_PROPERTY_PARAMS)
              });
              const propParam = gen.let("emPropParams");
              const paramsErrors = gen.let("emParamsErrors");
              gen.forOf("err", names_12.default.vErrors, (err) => gen.if(matchKeywordError(err, kwdErrs), () => {
                gen.assign(propParam, ajv_1._`${kwdPropParams}[${err}.keyword]`);
                gen.assign(paramsErrors, ajv_1._`${kwdErrs}[${err}.keyword][${err}.params[${propParam}]]`);
                gen.if(paramsErrors, () => gen.code(ajv_1._`${paramsErrors}.push(${err})`).assign(ajv_1._`${err}.${used}`, true));
              }));
              gen.forIn("key", kwdErrs, (key) => gen.forIn("keyProp", ajv_1._`${kwdErrs}[${key}]`, (keyProp) => {
                gen.assign(paramsErrors, ajv_1._`${kwdErrs}[${key}][${keyProp}]`);
                gen.if(ajv_1._`${paramsErrors}.length`, () => {
                  const tmpl = gen.const("tmpl", ajv_1._`${templates}[${key}] && ${templates}[${key}][${keyProp}]`);
                  errors_12.reportError(cxt, {
                    message: ajv_1._`${tmpl} ? ${tmpl}() : ${schemaValue}[${key}][${keyProp}]`,
                    params: ajv_1._`{errors: ${paramsErrors}}`
                  });
                });
              }));
            }
            function processChildErrors(childErrors) {
              const { props, items: items2 } = childErrors;
              if (!props && !items2)
                return;
              const isObj = ajv_1._`typeof ${data} == "object"`;
              const isArr = ajv_1._`Array.isArray(${data})`;
              const childErrs = gen.let("emErrors");
              let childKwd;
              let childProp;
              const templates = gen.let("templates");
              if (props && items2) {
                childKwd = gen.let("emChildKwd");
                gen.if(isObj);
                gen.if(isArr, () => {
                  init(items2, schema2.items);
                  gen.assign(childKwd, ajv_1.str`items`);
                }, () => {
                  init(props, schema2.properties);
                  gen.assign(childKwd, ajv_1.str`properties`);
                });
                childProp = ajv_1._`[${childKwd}]`;
              } else if (items2) {
                gen.if(isArr);
                init(items2, schema2.items);
                childProp = ajv_1._`.items`;
              } else if (props) {
                gen.if(codegen_12.and(isObj, codegen_12.not(isArr)));
                init(props, schema2.properties);
                childProp = ajv_1._`.properties`;
              }
              gen.forOf("err", names_12.default.vErrors, (err) => ifMatchesChildError(err, childErrs, (child) => gen.code(ajv_1._`${childErrs}[${child}].push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
              gen.forIn("key", childErrs, (key) => gen.if(ajv_1._`${childErrs}[${key}].length`, () => {
                errors_12.reportError(cxt, {
                  message: ajv_1._`${key} in ${templates} ? ${templates}[${key}]() : ${schemaValue}${childProp}[${key}]`,
                  params: ajv_1._`{errors: ${childErrs}[${key}]}`
                });
                gen.assign(ajv_1._`${names_12.default.vErrors}[${names_12.default.errors}-1].instancePath`, ajv_1._`${instancePath} + "/" + ${key}.replace(/~/g, "~0").replace(/\\//g, "~1")`);
              }));
              gen.endIf();
              function init(children, msgs) {
                gen.assign(childErrs, ajv_1.stringify(children));
                gen.assign(templates, getTemplatesCode(children, msgs));
              }
            }
            function processAllErrors(schMessage) {
              const errs = gen.const("emErrs", ajv_1._`[]`);
              gen.forOf("err", names_12.default.vErrors, (err) => gen.if(matchAnyError(err), () => gen.code(ajv_1._`${errs}.push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
              gen.if(ajv_1._`${errs}.length`, () => errors_12.reportError(cxt, {
                message: templateExpr(schMessage),
                params: ajv_1._`{errors: ${errs}}`
              }));
            }
            function removeUsedErrors() {
              const errs = gen.const("emErrs", ajv_1._`[]`);
              gen.forOf("err", names_12.default.vErrors, (err) => gen.if(ajv_1._`!${err}.${used}`, () => gen.code(ajv_1._`${errs}.push(${err})`)));
              gen.assign(names_12.default.vErrors, errs).assign(names_12.default.errors, ajv_1._`${errs}.length`);
            }
            function matchKeywordError(err, kwdErrs) {
              return codegen_12.and(
                ajv_1._`${err}.keyword !== ${keyword2}`,
                ajv_1._`!${err}.${used}`,
                ajv_1._`${err}.instancePath === ${instancePath}`,
                ajv_1._`${err}.keyword in ${kwdErrs}`,
                // TODO match the end of the string?
                ajv_1._`${err}.schemaPath.indexOf(${it2.errSchemaPath}) === 0`,
                ajv_1._`/^\\/[^\\/]*$/.test(${err}.schemaPath.slice(${it2.errSchemaPath.length}))`
              );
            }
            function ifMatchesChildError(err, childErrs, thenBody) {
              gen.if(codegen_12.and(ajv_1._`${err}.keyword !== ${keyword2}`, ajv_1._`!${err}.${used}`, ajv_1._`${err}.instancePath.indexOf(${instancePath}) === 0`), () => {
                const childRegex = gen.scopeValue("pattern", {
                  ref: /^\/([^/]*)(?:\/|$)/,
                  code: ajv_1._`new RegExp("^\\\/([^/]*)(?:\\\/|$)")`
                });
                const matches = gen.const("emMatches", ajv_1._`${childRegex}.exec(${err}.instancePath.slice(${instancePath}.length))`);
                const child = gen.const("emChild", ajv_1._`${matches} && ${matches}[1].replace(/~1/g, "/").replace(/~0/g, "~")`);
                gen.if(ajv_1._`${child} !== undefined && ${child} in ${childErrs}`, () => thenBody(child));
              });
            }
            function matchAnyError(err) {
              return codegen_12.and(ajv_1._`${err}.keyword !== ${keyword2}`, ajv_1._`!${err}.${used}`, codegen_12.or(ajv_1._`${err}.instancePath === ${instancePath}`, codegen_12.and(ajv_1._`${err}.instancePath.indexOf(${instancePath}) === 0`, ajv_1._`${err}.instancePath[${instancePath}.length] === "/"`)), ajv_1._`${err}.schemaPath.indexOf(${it2.errSchemaPath}) === 0`, ajv_1._`${err}.schemaPath[${it2.errSchemaPath}.length] === "/"`);
            }
            function getTemplatesCode(keys2, msgs) {
              const templatesCode = [];
              for (const k in keys2) {
                const msg = msgs[k];
                if (INTERPOLATION.test(msg))
                  templatesCode.push([k, templateFunc(msg)]);
              }
              return gen.object(...templatesCode);
            }
            function templateExpr(msg) {
              if (!INTERPOLATION.test(msg))
                return ajv_1.stringify(msg);
              return new code_12._Code(code_12.safeStringify(msg).replace(INTERPOLATION_REPLACE, (_s, ptr) => `" + JSON.stringify(${validate_12.getData(ptr, it2)}) + "`).replace(EMPTY_STR, ""));
            }
            function templateFunc(msg) {
              return ajv_1._`function(){return ${templateExpr(msg)}}`;
            }
          },
          metaSchema: {
            anyOf: [
              { type: "string" },
              {
                type: "object",
                properties: {
                  properties: { $ref: "#/$defs/stringMap" },
                  items: { $ref: "#/$defs/stringList" },
                  required: { $ref: "#/$defs/stringOrMap" },
                  dependencies: { $ref: "#/$defs/stringOrMap" }
                },
                additionalProperties: { type: "string" }
              }
            ],
            $defs: {
              stringMap: {
                type: "object",
                additionalProperties: { type: "string" }
              },
              stringOrMap: {
                anyOf: [{ type: "string" }, { $ref: "#/$defs/stringMap" }]
              },
              stringList: { type: "array", items: { type: "string" } }
            }
          }
        };
      }
      const ajvErrors2 = (ajv2, options = {}) => {
        if (!ajv2.opts.allErrors)
          throw new Error("ajv-errors: Ajv option allErrors must be true");
        if (ajv2.opts.jsPropertySyntax) {
          throw new Error("ajv-errors: ajv option jsPropertySyntax is not supported");
        }
        return ajv2.addKeyword(errorMessage(options));
      };
      exports2.default = ajvErrors2;
      module2.exports = ajvErrors2;
      module2.exports.default = ajvErrors2;
    })(dist, dist.exports);
    var distExports = dist.exports;
    const ajvErrors = /* @__PURE__ */ getDefaultExportFromCjs(distExports);
    var en$1 = function localize_en(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "additionalProperties":
            out = "must NOT have additional properties";
            break;
          case "anyOf":
            out = 'must match a schema in "anyOf"';
            break;
          case "const":
            out = "must be equal to constant";
            break;
          case "contains":
            out = "must contain a valid item";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "must have propert";
            if (n == 1) {
              out += "y";
            } else {
              out += "ies";
            }
            out += " " + e.params.deps + " when property " + e.params.property + " is present";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = 'must pass "' + e.keyword + '" keyword validation';
            }
            break;
          case "enum":
            out = "must be equal to one of the allowed values";
            break;
          case "false schema":
            out = "boolean schema is false";
            break;
          case "format":
            out = 'must match format "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "must be " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "must be " + cond;
            break;
          case "if":
            out = 'must match "' + e.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "must be " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "must NOT be longer than " + n + " character";
            if (n != 1) {
              out += "s";
            }
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "must NOT have more than " + n + " propert";
            if (n == 1) {
              out += "y";
            } else {
              out += "ies";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "must be " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "must NOT have less than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "must NOT be shorter than " + n + " character";
            if (n != 1) {
              out += "s";
            }
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "must NOT have less than " + n + " propert";
            if (n == 1) {
              out += "y";
            } else {
              out += "ies";
            }
            break;
          case "multipleOf":
            out = "must be a multiple of " + e.params.multipleOf;
            break;
          case "not":
            out = 'must NOT be valid according to schema in "not"';
            break;
          case "oneOf":
            out = 'must match exactly one schema in "oneOf"';
            break;
          case "pattern":
            out = 'must match pattern "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'must have property matching pattern "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "property name is invalid";
            break;
          case "required":
            out = "must have required property " + e.params.missingProperty;
            break;
          case "type":
            out = "must be " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "must NOT have duplicate items (items ## " + e.params.j + " and " + e.params.i + " are identical)";
            break;
          default:
            out = 'must pass "' + e.keyword + '" keyword validation';
        }
        e.message = out;
      }
    };
    var ar = function localize_ar(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += " يجب أن لا يحوي أكثر من " + n + " عنصر";
            break;
          case "additionalProperties":
            out = "يجب أن لا يحوي خصائص إضافية";
            break;
          case "anyOf":
            out = 'يجب أن يوافق أحد المخططات الموجودة في "anyOf"';
            break;
          case "const":
            out = "يجب أن يكون ثابتاً";
            break;
          case "contains":
            out = "يجب أن يحوي عنصرا صحيح";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += " يجب أن يحوي الخصائص " + e.params.deps + " عندما تكون الخاصية " + e.params.property + " موجودة";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = 'يجب أن تمرر كلمة التحقق المفتاحية "' + e.keyword + '"';
            }
            break;
          case "enum":
            out = "قيمة هذا الحقل يجب أن تكون مساوية لأحد القيم المعرفة مسبقاً";
            break;
          case "false schema":
            out = "المخطط المنطقي غير صحيح";
            break;
          case "format":
            out = 'يجب أن يوافق الصيغة "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += " يجب أن يكون " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += " يجب أن يكون " + cond;
            break;
          case "if":
            out = 'يجب أن توافق المخطط "' + e.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += " يجب أن يكون " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += " يجب أن لا يحوي أكثر من " + n + " عنصر";
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += " يجب أن لا يحوي أكثر من " + n + " محرف";
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += " يجب أن لا يحوي أكثر من " + n + " خصائص";
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += " يجب أن يكون " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += " يجب أن لا يحوي أقل من " + n + " عنصر";
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += " يجب أن لا يحوي أقل من " + n + " محرف";
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += " يجب أن لا يحوي أقل من " + n + " خصائص";
            break;
          case "multipleOf":
            out = " يجب أن يحوي أكثر من " + e.params.multipleOf;
            break;
          case "not":
            out = 'يجب أن يكون غير صحيح وفقاً للمخطط "not"';
            break;
          case "oneOf":
            out = 'يجب أن يوافق مخطط واحد فقط موجود في "oneOf"';
            break;
          case "pattern":
            out = 'يجب أن يوافق النمط "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'يجب أن يحوي خاصية توافق النمط "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "اسم الخاصية غير صالح";
            break;
          case "required":
            out = "هذا الحقل إلزامي";
            break;
          case "type":
            out = "قيمة هذا الحقل غير صالحة";
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "يجب أن لا يحوي عناصر مكررة (العنصر ## " + e.params.j + " و " + e.params.i + " متطابقة)";
            break;
          default:
            out = 'يجب أن تمرر كلمة التحقق المفتاحية "' + e.keyword + '"';
        }
        e.message = out;
      }
    };
    var ca = function localize_ca(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "no ha de tenir més de " + n + " element";
            if (n != 1) {
              out += "s";
            }
            break;
          case "additionalProperties":
            out = "no ha de tenir propietats addicionals";
            break;
          case "anyOf":
            out = 'ha de coincidir amb algun esquema definit a "anyOf"';
            break;
          case "const":
            out = "ha de ser igual a la constant";
            break;
          case "contains":
            out = "ha de contenir un ítem vàlid";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "ha de contenir la propietat";
            if (n != 1) {
              out += "s";
            }
            out += " " + e.params.deps + " quan la propietat " + e.params.property + " és present";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = 'ha de passar la validació de la clau "' + e.keyword + '"';
            }
            break;
          case "enum":
            out = "ha de ser igual a un dels valors predefinits";
            break;
          case "false schema":
            out = "l’esquema és fals";
            break;
          case "format":
            out = 'ha de coincidir amb el format "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "ha de ser " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "ha de ser " + cond;
            break;
          case "if":
            out = 'ha de correspondre’s amb l’esquema "' + e.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "ha de ser " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "no ha de tenir més de " + n + " ítem";
            if (n != 1) {
              out += "s";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "no pot contenir més de " + n + " caràcter";
            if (n != 1) {
              out += "s";
            }
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "no pot contenir més de " + n + " propietat";
            if (n != 1) {
              out += "s";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "ha de ser " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "no ha de tenir menys de " + n + " ítem";
            if (n != 1) {
              out += "s";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "no pot contenir menys de " + n + " caràcter";
            if (n != 1) {
              out += "s";
            }
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "no pot contenir menys de " + n + " propietat";
            if (n != 1) {
              out += "s";
            }
            break;
          case "multipleOf":
            out = "ha de ser múltiple de " + e.params.multipleOf;
            break;
          case "not":
            out = 'no ha de ser vàlid d’acord amb l’esquema definit a "not"';
            break;
          case "oneOf":
            out = 'ha de coincidir només amb un esquema definit a "oneOf"';
            break;
          case "pattern":
            out = 'ha de coincidir amb el patró "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'la propietat ha de coincidir amb el patró "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "la propietat no és vàlida";
            break;
          case "required":
            out = "ha de tenir la propietat requerida " + e.params.missingProperty;
            break;
          case "type":
            out = "ha de ser del tipus " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "no ha de tenir ítems duplicats (els ítems ## " + e.params.j + " i " + e.params.i + " són idèntics)";
            break;
          default:
            out = 'ha de passar la validació de la clau "' + e.keyword + '"';
        }
        e.message = out;
      }
    };
    var cs = function localize_cs(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "nemůže mít víc, než " + n + " prv";
            if (n >= 2 && n <= 4) {
              out += "ky";
            } else if (n != 1) {
              out += "ek";
            } else {
              out += "ků";
            }
            break;
          case "additionalProperties":
            out = "nemůže mít další položky";
            break;
          case "anyOf":
            out = 'musí vyhovět alespoň jednomu schématu v "anyOf"';
            break;
          case "const":
            out = "musí být roven konstantě";
            break;
          case "contains":
            out = "musí obsahovat prvek odpovídající schématu";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "musí mít polož";
            if (n >= 2 && n <= 4) {
              out += "ky";
            } else if (n != 1) {
              out += "ek";
            } else {
              out += "ka";
            }
            out += ": " + e.params.deps + ", pokud obsahuje " + e.params.property;
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = 'musí vyhovět "' + e.keyword + '" validaci';
            }
            break;
          case "enum":
            out = "musí být rovno jedné hodnotě z výčtu";
            break;
          case "false schema":
            out = "schéma je false";
            break;
          case "format":
            out = 'musí být ve formátu "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "musí být " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "musí být " + cond;
            break;
          case "if":
            out = 'musí vyhovět "' + e.params.failingKeyword + '" schématu';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "musí být " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "nesmí obsahovat víc než " + n + " prv";
            if (n >= 2 && n <= 4) {
              out += "ky";
            } else if (n != 1) {
              out += "ek";
            } else {
              out += "ků";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "nesmí být delší než " + n + " zna";
            if (n >= 2 && n <= 4) {
              out += "ky";
            } else if (n != 1) {
              out += "k";
            } else {
              out += "ků";
            }
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "nesmí mít víc než " + n + " polož";
            if (n >= 2 && n <= 4) {
              out += "ky";
            } else if (n != 1) {
              out += "ek";
            } else {
              out += "ka";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "musí být " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "nesmí obsahovat méně než " + n + " prv";
            if (n >= 2 && n <= 4) {
              out += "ky";
            } else if (n != 1) {
              out += "ek";
            } else {
              out += "ků";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "nesmí být kratší než " + n + " zna";
            if (n >= 2 && n <= 4) {
              out += "ky";
            } else if (n != 1) {
              out += "k";
            } else {
              out += "ků";
            }
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "nesmí mít méně než " + n + " polož";
            if (n >= 2 && n <= 4) {
              out += "ky";
            } else if (n != 1) {
              out += "ek";
            } else {
              out += "ka";
            }
            break;
          case "multipleOf":
            out = "musí být násobkem " + e.params.multipleOf;
            break;
          case "not":
            out = 'nesmí vyhovět schématu v "not"';
            break;
          case "oneOf":
            out = 'musí vyhovět právě jednomu schématu v "oneOf"';
            break;
          case "pattern":
            out = 'musí vyhovět regulárnímu výrazu "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'musí obsahovat položku vyhovující regulárnímu výrazu "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "název položky není platný";
            break;
          case "required":
            out = "musí obsahovat požadovanou položku " + e.params.missingProperty;
            break;
          case "type":
            out = "musí být " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "nesmí obsahovat duplicitní prvky (prvky ## " + e.params.j + " a " + e.params.i + " jsou identické)";
            break;
          default:
            out = 'musí vyhovět "' + e.keyword + '" validaci';
        }
        e.message = out;
      }
    };
    var de = function localize_de(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "darf nicht mehr als " + n + " Element";
            if (n != 1) {
              out += "e";
            }
            out += " enthalten";
            break;
          case "additionalProperties":
            out = "darf keine zusätzlichen Attribute haben";
            break;
          case "anyOf":
            out = 'muss einem der Schemata in "anyOf" entsprechen';
            break;
          case "const":
            out = "muss gleich der Konstanten sein";
            break;
          case "contains":
            out = "muss ein valides Element enthalten";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "muss Attribut";
            if (n != 1) {
              out += "e";
            }
            out += " " + e.params.deps + " aufweisen, wenn Attribut " + e.params.property + " gesetzt ist";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'der Tag "' + e.params.tag + '" muss eine Zeichenkette sein';
                break;
              case "mapping":
                out = 'der Wert vom Tag "' + e.params.tag + '" muss im oneOf enthalten sein';
                break;
              default:
                out = 'muss die Validierung "' + e.keyword + '" bestehen';
            }
            break;
          case "enum":
            out = "muss einem der vorgegebenen Werte entsprechen";
            break;
          case "false schema":
            out = "boolesches Schema ist falsch";
            break;
          case "format":
            out = 'muss diesem Format entsprechen: "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "muss " + cond + " sein";
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "muss " + cond + " sein";
            break;
          case "if":
            out = 'muss dem Schema "' + e.params.failingKeyword + '" entsprechen';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "muss " + cond + " sein";
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "darf nicht mehr als " + n + " Element";
            if (n != 1) {
              out += "e";
            }
            out += " haben";
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "darf nicht länger als " + n + " Zeichen sein";
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "darf nicht mehr als " + n + " Attribut";
            if (n != 1) {
              out += "e";
            }
            out += " haben";
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "muss " + cond + " sein";
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "darf nicht weniger als " + n + " Element";
            if (n != 1) {
              out += "e";
            }
            out += " haben";
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "darf nicht kürzer als " + n + " Zeichen sein";
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "darf nicht weniger als " + n + " Attribut";
            if (n != 1) {
              out += "e";
            }
            out += " haben";
            break;
          case "multipleOf":
            out = "muss ein Vielfaches von " + e.params.multipleOf + " sein";
            break;
          case "not":
            out = 'muss dem in "not" angegebenen Schema widersprechen';
            break;
          case "oneOf":
            out = 'muss genau einem der Schemata in "oneOf" entsprechen';
            break;
          case "pattern":
            out = 'muss diesem Muster entsprechen: "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'muss ein Attribut nach folgendem Muster haben "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "Attributname ist ungültig";
            break;
          case "required":
            out = "muss das erforderliche Attribut " + e.params.missingProperty + " enthalten";
            break;
          case "type":
            out = "muss sein: " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "darf nicht mehr als " + n + " Element";
            if (n != 1) {
              out += "e";
            }
            out += " haben";
            break;
          case "unevaluatedProperties":
            out = "darf keine unausgewerteten Attribute haben";
            break;
          case "uniqueItems":
            out = "darf keine Duplikate enthalten (Elemente #" + e.params.j + " und #" + e.params.i + " sind gleich)";
            break;
          default:
            out = 'muss die Validierung "' + e.keyword + '" bestehen';
        }
        e.message = out;
      }
    };
    var es = function localize_es(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "no debe tener más de " + n + " elemento";
            if (n != 1) {
              out += "s";
            }
            break;
          case "additionalProperties":
            out = "no debe tener propiedades adicionales";
            break;
          case "anyOf":
            out = 'debe coincidir con algún esquema en "anyOf"';
            break;
          case "const":
            out = "debe ser igual a la constante";
            break;
          case "contains":
            out = "debe contener un elemento válido";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "debe contener la";
            if (n != 1) {
              out += "s";
            }
            out += " propiedad";
            if (n != 1) {
              out += "es";
            }
            out += " " + e.params.deps + " cuando la propiedad " + e.params.property + " se encuentra presente";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = 'debe pasar la validación de palabra clave "' + e.keyword + '"';
            }
            break;
          case "enum":
            out = "deber ser igual a uno de los valores predefinidos";
            break;
          case "false schema":
            out = "el esquema és falso";
            break;
          case "format":
            out = 'debe coincidir con el formato "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "debe ser " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "debe ser " + cond;
            break;
          case "if":
            out = 'debe corresponderse con el esquema "' + e.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "debe ser " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "no debe contener más de " + n + " elemento";
            if (n != 1) {
              out += "s";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "no debe contener más de " + n + " caracter";
            if (n != 1) {
              out += "es";
            }
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "no debe contener más de " + n + " propiedad";
            if (n != 1) {
              out += "es";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "debe ser " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "no debe contener menos de " + n + " elemento";
            if (n != 1) {
              out += "s";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "no debe contener menos de " + n + " caracter";
            if (n != 1) {
              out += "es";
            }
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "no debe contener menos de " + n + " propiedad";
            if (n != 1) {
              out += "es";
            }
            break;
          case "multipleOf":
            out = "debe ser múltiplo de " + e.params.multipleOf;
            break;
          case "not":
            out = 'no debe ser válido según el esquema en "not"';
            break;
          case "oneOf":
            out = 'debe coincidir con un solo esquema en "oneOf"';
            break;
          case "pattern":
            out = 'debe coincidir con el patron "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'la propiedad debe coincidir con el patrón "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "la propiedad no és válida";
            break;
          case "required":
            out = "debe tener la propiedad requerida " + e.params.missingProperty;
            break;
          case "type":
            out = "debe ser " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "no debe contener elementos duplicados, (los elementos ## " + e.params.j + " y " + e.params.i + " son idénticos)";
            break;
          default:
            out = 'debe pasar la validación de palabra clave "' + e.keyword + '"';
        }
        e.message = out;
      }
    };
    var fi = function localize_fi(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "saa sisältää enintään " + n;
            if (n == 1) {
              out += ":n elementin";
            } else {
              out += " elementtiä";
            }
            break;
          case "additionalProperties":
            out = "ei saa sisältää ylimääräisiä ominaisuuksia";
            break;
          case "anyOf":
            out = 'täytyy vastata "anyOf" skeemaa';
            break;
          case "const":
            out = "täytyy olla yhtä kuin vakio";
            break;
          case "contains":
            out = "täytyy sisältää kelvollinen elementti";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "täytyy sisältää " + e.params.deps + " ominaisuu";
            if (n == 1) {
              out += "s";
            } else {
              out += "det";
            }
            out += " kun " + e.params.property + "-ominaisuus on läsnä";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tunniste "' + e.params.tag + '" täytyy olla merkkijono';
                break;
              case "mapping":
                out = 'tunnisteen "' + e.params.tag + '" arvon muoto pitää olla oneOf';
                break;
              default:
                out = 'täytyy läpäistä "' + e.keyword + '" avainsanatarkistus';
            }
            break;
          case "enum":
            out = "täytyy olla yhtä kuin jokin sallituista arvoista";
            break;
          case "false schema":
            out = "boolean skeema on väärä";
            break;
          case "format":
            out = 'täytyy vastata muotoa "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "täytyy olla " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "täytyy olla " + cond;
            break;
          case "if":
            out = 'täytyy vastata "' + e.params.failingKeyword + '" skeemaa';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "täytyy olla " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "tulee sisältää enintään " + n + " ";
            if (n == 1) {
              out += "elementti";
            } else {
              out += "elementtiä";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "ei saa olla pidempi kuin " + n + " merkki";
            if (n != 1) {
              out += "ä";
            }
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "tulee sisältää enintään " + n + " ";
            if (n == 1) {
              out += "ominaisuus";
            } else {
              out += "ominaisuutta";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "täytyy olla " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "tulee sisältää vähintään " + n + " ";
            if (n == 1) {
              out += "elementti";
            } else {
              out += "elementtiä";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "ei saa olla lyhyempi kuin " + n + " merkki";
            if (n != 1) {
              out += "ä";
            }
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "tulee sisältää vähintään " + n + " ";
            if (n == 1) {
              out += "ominaisuus";
            } else {
              out += "ominaisuutta";
            }
            break;
          case "multipleOf":
            out = "täytyy olla moninkertainen: " + e.params.multipleOf;
            break;
          case "not":
            out = 'ei saa olla hyväksytty skeeman "not" mukaan';
            break;
          case "oneOf":
            out = 'täytyy vastata täsmälleen yhtä "oneOf" -kohdassa määriteltyä skeemaa';
            break;
          case "pattern":
            out = 'täytyy vastata muotoa "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'täytyy sisältää ominaisuus joka vastaa kaavaa "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "ominaisuuden nimi on virheellinen";
            break;
          case "required":
            out = "täytyy sisältää vaadittu ominaisuus " + e.params.missingProperty;
            break;
          case "type":
            out = "";
            var t = e.params.type;
            out += "täytyy olla ";
            if (t == "number") {
              out += "numero";
            } else if (t == "integer") {
              out += "kokonaisluku";
            } else if (t == "string") {
              out += "merkkijono";
            } else if (t == "boolean") {
              out += "boolean";
            } else {
              out += t;
            }
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "ei saa olla enemmän kuin " + n + " elementti";
            if (n != 1) {
              out += "ä";
            }
            break;
          case "unevaluatedProperties":
            out = "ei saa sisältää arvioimattomia ominaisuuksia";
            break;
          case "uniqueItems":
            out = "ei saa sisältää duplikaatteja (elementit ## " + e.params.j + " ja " + e.params.i + " ovat identtiset)";
            break;
          default:
            out = 'täytyy läpäistä "' + e.keyword + '" avainsanatarkistus';
        }
        e.message = out;
      }
    };
    var fr$1 = function localize_fr(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "ne doit pas contenir plus de " + n + " élémént";
            if (n != 1) {
              out += "s";
            }
            break;
          case "additionalProperties":
            out = "ne doit pas contenir de propriétés additionnelles";
            break;
          case "anyOf":
            out = 'doit correspondre à un schéma de "anyOf"';
            break;
          case "const":
            out = "doit être égal à la constante";
            break;
          case "contains":
            out = "doit contenir un élément valide";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "doit avoir la propriété " + e.params.deps + " quand la propriété " + e.params.property + " est présente";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = 'doit être valide selon le critère "' + e.keyword + '"';
            }
            break;
          case "enum":
            out = "doit être égal à une des valeurs prédéfinies";
            break;
          case "false schema":
            out = 'le schema est "false"';
            break;
          case "format":
            out = 'doit correspondre au format "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "doit être " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "doit être " + cond;
            break;
          case "if":
            out = 'doit correspondre au schéma "' + e.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "doit être " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "ne doit pas contenir plus de " + n + " élément";
            if (n != 1) {
              out += "s";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "ne doit pas dépasser " + n + " caractère";
            if (n != 1) {
              out += "s";
            }
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "ne doit pas contenir plus de " + n + " propriété";
            if (n != 1) {
              out += "s";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "doit être " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "ne doit pas contenir moins de " + n + " élément";
            if (n != 1) {
              out += "s";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "ne doit pas faire moins de " + n + " caractère";
            if (n != 1) {
              out += "s";
            }
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "ne doit pas contenir moins de " + n + " propriété";
            if (n != 1) {
              out += "s";
            }
            break;
          case "multipleOf":
            out = "doit être un multiple de " + e.params.multipleOf;
            break;
          case "not":
            out = 'est invalide selon le schéma "not"';
            break;
          case "oneOf":
            out = 'doit correspondre à exactement un schéma de "oneOf"';
            break;
          case "pattern":
            out = 'doit correspondre au format "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'la propriété doit correspondre au format "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "le nom de propriété est invalide";
            break;
          case "required":
            out = "requiert la propriété " + e.params.missingProperty;
            break;
          case "type":
            out = "doit être de type " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "ne doit pas contenir de doublons (les éléments ## " + e.params.j + " et " + e.params.i + " sont identiques)";
            break;
          default:
            out = 'doit être valide selon le critère "' + e.keyword + '"';
        }
        e.message = out;
      }
    };
    var hu = function localize_hu(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "nem lehet több, mint " + n + " eleme";
            break;
          case "additionalProperties":
            out = "nem lehetnek további elemei";
            break;
          case "anyOf":
            out = 'meg kell feleljen legalább egy "anyOf" alaknak';
            break;
          case "const":
            out = "must be equal to constant";
            break;
          case "contains":
            out = "must contain a valid item";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "-nak kell legyen";
            if (n > 1) {
              out += "ek";
            }
            out += " a következő tulajdonsága";
            if (n != 1) {
              out += "i";
            }
            out += ": " + e.params.deps + ", ha van " + e.params.property + " tulajdonsága";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = 'must pass "' + e.keyword + '" keyword validation';
            }
            break;
          case "enum":
            out = "egyenlő kell legyen valamely előre meghatározott értékkel";
            break;
          case "false schema":
            out = "boolean schema is false";
            break;
          case "format":
            out = 'meg kell feleljen a következő formátumnak: "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "must be " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "must be " + cond;
            break;
          case "if":
            out = 'must match "' + e.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "kell legyen " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "nem lehet több, mint " + n + " eleme";
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "nem lehet hosszabb, mint " + n + " szimbólum";
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "nem lehet több, mint " + n + " tulajdonsága";
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "kell legyen " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "nem lehet kevesebb, mint " + n + " eleme";
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "nem lehet rövidebb, mint " + n + " szimbólum";
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "nem lehet kevesebb, mint " + n + " tulajdonsága";
            break;
          case "multipleOf":
            out = "a többszöröse kell legyen a következő számnak: " + e.params.multipleOf;
            break;
          case "not":
            out = 'nem lehet érvényes a "not" alaknak megfelelően';
            break;
          case "oneOf":
            out = 'meg kell feleljen pontosan egy "oneOf" alaknak';
            break;
          case "pattern":
            out = 'meg kell feleljen a következő mintának: "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'must have property matching pattern "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "property name is invalid";
            break;
          case "required":
            out = "kell legyen " + e.params.missingProperty + " tulajdonsága";
            break;
          case "type":
            out = "" + e.params.type + " kell legyen";
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "nem lehetnek azonos elemei (" + e.params.j + " és " + e.params.i + " elemek azonosak)";
            break;
          default:
            out = 'must pass "' + e.keyword + '" keyword validation';
        }
        e.message = out;
      }
    };
    var id = function localize_id(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += " tidak boleh memiliki lebih dari " + n + " item";
            break;
          case "additionalProperties":
            out = "tidak boleh memiliki properti tambahan";
            break;
          case "anyOf":
            out = 'harus cocok dengan beberapa skema pada "anyOf"';
            break;
          case "const":
            out = "harus sama dengan konstan";
            break;
          case "contains":
            out = "harus berisi item yang valid";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += " harus memiliki properti " + e.params.deps + " ketika properti " + e.params.property + " hadir";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = 'harus lulus validasi kata kunci "' + e.keyword + '"';
            }
            break;
          case "enum":
            out = "harus sama dengan salah satu dari nilai yang telah ditentukan";
            break;
          case "false schema":
            out = "skema boolean salah";
            break;
          case "format":
            out = 'harus cocok dengan format "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "harus " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "harus " + cond;
            break;
          case "if":
            out = 'harus cocok dengan skema "' + e.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "harus " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += " tidak boleh memiliki lebih dari " + n + " item";
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += " tidak boleh lebih dari " + n + " karakter";
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += " tidak boleh memiliki lebih dari " + n + " properti";
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "harus " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += " tidak boleh kurang dari " + n + " item";
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += " tidak boleh lebih pendek dari " + n + " karakter";
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += " tidak boleh kurang dari " + n + " properti";
            break;
          case "multipleOf":
            out = "harus merupakan kelipatan dari " + e.params.multipleOf;
            break;
          case "not":
            out = 'tidak boleh valid sesuai dengan skema pada "not"';
            break;
          case "oneOf":
            out = 'harus sama persis dengan satu skema pada "oneOf"';
            break;
          case "pattern":
            out = 'harus cocok dengan pola "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'harus memiliki pola pencocokan properti "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "nama properti tidak valid";
            break;
          case "required":
            out = "harus memiliki properti " + e.params.missingProperty;
            break;
          case "type":
            out = "harus berupa " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "tidak boleh memiliki item duplikat (item ## " + e.params.j + " dan " + e.params.i + " identik)";
            break;
          default:
            out = 'harus lulus validasi kata kunci "' + e.keyword + '"';
        }
        e.message = out;
      }
    };
    var it$1 = function localize_it(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "non dovrebbe avere più di " + n + " element";
            if (n == 1) {
              out += "o";
            } else {
              out += "i";
            }
            break;
          case "additionalProperties":
            out = "non deve avere attributi aggiuntivi";
            break;
          case "anyOf":
            out = 'deve corrispondere ad uno degli schema in "anyOf"';
            break;
          case "const":
            out = "deve essere uguale alla costante";
            break;
          case "contains":
            out = "deve contentere un elemento valido";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "dovrebbe avere ";
            if (n == 1) {
              out += "l'";
            } else {
              out += "gli ";
            }
            out += "attribut";
            if (n == 1) {
              out += "o";
            } else {
              out += "i";
            }
            out += " " + e.params.deps + " quando l'attributo " + e.params.property + " è presente";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'il tag "' + e.params.tag + '" deve essere di tipo stringa';
                break;
              case "mapping":
                out = 'il valore del tag "' + e.params.tag + '" deve essere nei oneOf';
                break;
              default:
                out = 'deve essere valido secondo il criterio "' + e.keyword + '"';
            }
            break;
          case "enum":
            out = "deve essere uguale ad uno dei valori consentiti";
            break;
          case "false schema":
            out = "lo schema booleano è falso";
            break;
          case "format":
            out = 'deve corrispondere al formato "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "deve essere " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "deve essere " + cond;
            break;
          case "if":
            out = 'deve corrispondere allo schema "' + e.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "deve essere " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "non deve avere più di " + n + " element";
            if (n == 1) {
              out += "o";
            } else {
              out += "i";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "non deve essere più lungo di " + n + " caratter";
            if (n == 1) {
              out += "e";
            } else {
              out += "i";
            }
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "non deve avere più di " + n + " attribut";
            if (n == 1) {
              out += "o";
            } else {
              out += "i";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "deve essere " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "non deve avere meno di " + n + " element";
            if (n == 1) {
              out += "o";
            } else {
              out += "i";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "non deve essere meno lungo di " + n + " caratter";
            if (n == 1) {
              out += "e";
            } else {
              out += "i";
            }
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "non deve avere meno di " + n + " attribut";
            if (n == 1) {
              out += "o";
            } else {
              out += "i";
            }
            break;
          case "multipleOf":
            out = "deve essere un multiplo di " + e.params.multipleOf;
            break;
          case "not":
            out = 'non deve essere valido in base allo schema di "non"';
            break;
          case "oneOf":
            out = 'deve corrispondere esattamente ad uno degli schema in "oneOf"';
            break;
          case "pattern":
            out = 'deve corrispondere al formato "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'deve avere un attributo che corrisponda al formato "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "il nome dell'attritbuto non è valido";
            break;
          case "required":
            out = "deve avere l'attributo obbligatorio " + e.params.missingProperty;
            break;
          case "type":
            out = "deve essere di tipo " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "non deve avere più di " + n + " elementi";
            if (n == 1) {
              out += "o";
            } else {
              out += "i";
            }
            break;
          case "unevaluatedProperties":
            out = "non deve avere attributi non valutati";
            break;
          case "uniqueItems":
            out = "non deve avere duplicati (gli elementi ## " + e.params.j + " e " + e.params.i + " sono uguali)";
            break;
          default:
            out = 'deve essere valido secondo il criterio "' + e.keyword + '"';
        }
        e.message = out;
      }
    };
    var ja = function localize_ja(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "は" + n + "以上あってはいけない";
            break;
          case "additionalProperties":
            out = "追加してはいけない";
            break;
          case "anyOf":
            out = '"anyOf"のスキーマとマッチしなくてはいけない';
            break;
          case "const":
            out = "must be equal to constant";
            break;
          case "contains":
            out = "must contain a valid item";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "" + e.params.property + "がある場合、";
            var n = e.params.depsCount;
            out += "は" + e.params.deps + "をつけなければいけない";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = 'must pass "' + e.keyword + '" keyword validation';
            }
            break;
          case "enum":
            out = "事前に定義された値のいずれかに等しくなければいけない";
            break;
          case "false schema":
            out = "boolean schema is false";
            break;
          case "format":
            out = '"' + e.params.format + '"形式に揃えなければいけない';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "must be " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "must be " + cond;
            break;
          case "if":
            out = 'must match "' + e.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += cond + "でなければいけない";
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "は" + n + "個以上であってはいけない";
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "は" + n + "文字以上であってはいけない";
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "は" + n + "個以上のプロパティを有してはいけない";
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += cond + "でなければいけない";
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "は" + n + "個以下であってはいけない";
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "は" + n + "文字以下であってはいけない";
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "は" + n + "個以下のプロパティを有してはいけない";
            break;
          case "multipleOf":
            out = "" + e.params.multipleOf + "の倍数でなければいけない";
            break;
          case "not":
            out = '"not"のスキーマに従って有効としてはいけない';
            break;
          case "oneOf":
            out = '"oneOf"のスキーマと完全に一致しなくてはいけない';
            break;
          case "pattern":
            out = '"' + e.params.pattern + '"のパターンと一致しなければいけない';
            break;
          case "patternRequired":
            out = 'must have property matching pattern "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "property name is invalid";
            break;
          case "required":
            out = "必要なプロパティ" + e.params.missingProperty + "がなければいけない";
            break;
          case "type":
            out = "" + e.params.type + "でなければいけない";
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "重複するアイテムがあってはいけない（" + e.params.j + "と" + e.params.i + "は同じである）";
            break;
          default:
            out = 'must pass "' + e.keyword + '" keyword validation';
        }
        e.message = out;
      }
    };
    var ko = function localize_ko(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += " 항목은 아이템을 " + n + "개 이상 가질 수 없습니다";
            break;
          case "additionalProperties":
            out = "추가적인 속성은 허용되지 않습니다";
            break;
          case "anyOf":
            out = '"anyOf"의 스키마와 일치해야 합니다';
            break;
          case "const":
            out = "상수와 같아야합니다";
            break;
          case "contains":
            out = "올바른 아이템을 포함해야 합니다";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += e.params.property + "속성이 있는 경우, " + e.params.deps + " 속성이 있어야합니다";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = '"' + e.params.tag + '"태그는 반드시 문자열이여야 합니다';
                break;
              case "mapping":
                out = '"' + e.params.tag + '"태그의 값은 반드시 oneOf에 있어야 합니다';
                break;
              default:
                out = '"' + e.keyword + '"키워드 검사를 통과해야 합니다';
            }
            break;
          case "enum":
            out = "미리 정의된 값중 하나여야 합니다";
            break;
          case "false schema":
            out = "boolean 스키마는 올바르지 않습니다";
            break;
          case "format":
            out = '"' + e.params.format + '" 포맷과 일치해야 합니다';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += " " + cond + " 이여야 합니다";
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += " " + cond + " 이여야 합니다";
            break;
          case "if":
            out = '"' + e.params.failingKeyword + '" 스키마와 일치해야 합니다';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += " " + cond + " 이여야 합니다";
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "아이템이 최대 " + n + "개이여야 합니다";
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "최대 " + n + "글자여야 합니다";
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "속성은 최대 " + n + "개 이내여야 합니다";
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += " " + cond + " 이여야 합니다";
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "아이템이 최소 " + n + "개이여야 합니다";
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "최소 " + n + "글자여야 합니다";
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "속성은 최소 " + n + "개 이상이여야 합니다";
            break;
          case "multipleOf":
            out = "" + e.params.multipleOf + "의 배수여야 합니다";
            break;
          case "not":
            out = '"not"스키마에 따라 유효하지 않아야 합니다';
            break;
          case "oneOf":
            out = '"oneOf" 스키마중 하나와 정확하게 일치해야 합니다';
            break;
          case "pattern":
            out = '"' + e.params.pattern + '"패턴과 일치해야 합니다';
            break;
          case "patternRequired":
            out = '"' + e.params.missingPattern + '"패턴과 일치하는 속성을 가져야 합니다';
            break;
          case "propertyNames":
            out = "속성명이 올바르지 않습니다";
            break;
          case "required":
            out = "" + e.params.missingProperty + " 속성은 필수입니다";
            break;
          case "type":
            out = "" + e.params.type + "이여야 합니다";
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "항목이 " + n + "개 아이템을 초과하면 안됩니다";
            break;
          case "unevaluatedProperties":
            out = "평가되지 않은 속성이 없어야합니다.";
            break;
          case "uniqueItems":
            out = "중복 아이템이 없어야 합니다 (아이템" + e.params.j + "과 아이템" + e.params.i + "가 동일합니다)";
            break;
          default:
            out = '"' + e.keyword + '"키워드 검사를 통과해야 합니다';
        }
        e.message = out;
      }
    };
    var nb = function localize_nb(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "kan ikke ha mer enn " + n + " element";
            if (n != 1) {
              out += "er";
            }
            break;
          case "additionalProperties":
            out = "kan ikke ha flere egenskaper";
            break;
          case "anyOf":
            out = 'må samsvare med et schema i "anyOf"';
            break;
          case "const":
            out = "må være lik konstanten";
            break;
          case "contains":
            out = "må inneholde et gyldig element";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "må ha egenskapen";
            if (n != 1) {
              out += "e";
            }
            out += " " + e.params.deps + " når egenskapen " + e.params.property + " er angitt";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = "må samsvare med valideringen for " + e.keyword;
            }
            break;
          case "enum":
            out = "må være lik en av de forhåndsdefinerte verdiene";
            break;
          case "false schema":
            out = "boolsk schema er usannt";
            break;
          case "format":
            out = 'må stemme overens med formatet "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "må være " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "må være " + cond;
            break;
          case "if":
            out = 'must match "' + e.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "må være " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "kan ikke ha fler enn " + n + " element";
            if (n != 1) {
              out += "er";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "kan ikke være lengre enn " + n + " tegn";
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "kan ikke ha mer enn " + n + " egenskap";
            if (n != 1) {
              out += "er";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "må være " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "kan ikke ha færre enn " + n + " element";
            if (n != 1) {
              out += "er";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "kan ikke være kortere enn " + n + " tegn";
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "kan ikke ha mindre enn " + n + " egenskap";
            if (n != 1) {
              out += "er";
            }
            break;
          case "multipleOf":
            out = "må være et multiplum av " + e.params.multipleOf;
            break;
          case "not":
            out = 'kan ikke samsvare med schema i "not"';
            break;
          case "oneOf":
            out = 'må samsvare med nøyaktig ett schema i "oneOf"';
            break;
          case "pattern":
            out = 'må samsvare med mønsteret "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'må ha en egenskap som samsvarer med mønsteret "' + e.params.missingPattern;
            break;
          case "propertyNames":
            out = "egenskapen med navnet '";
            e.params.propertyNameout += "' er ugyldig";
            break;
          case "required":
            out = "må ha den påkrevde egenskapen " + e.params.missingProperty;
            break;
          case "type":
            out = "";
            var t = e.params.type;
            out += "må være ";
            if (t == "number") {
              out += "et tall";
            } else if (t == "integer") {
              out += "et heltall";
            } else if (t == "string") {
              out += "en streng";
            } else if (t == "boolean") {
              out += "ja eller nei";
            } else {
              out += t;
            }
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "kan ikke ha duplikate elemeneter (elementene ## " + e.params.j + " og " + e.params.i + " er identiske)";
            break;
          default:
            out = "må samsvare med valideringen for " + e.keyword;
        }
        e.message = out;
      }
    };
    var nl$1 = function localize_nl(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "mag niet meer dan " + n + " item";
            if (n != 1) {
              out += "s";
            }
            out += " bevatten";
            break;
          case "additionalProperties":
            out = "mag geen extra eigenschappen bevatten";
            break;
          case "anyOf":
            out = 'moet overeenkomen met een schema in "anyOf"';
            break;
          case "const":
            out = "moet gelijk zijn aan constante";
            break;
          case "contains":
            out = "moet een geldig item bevatten";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "moet de eigenschap";
            if (n != 1) {
              out += "pen";
            }
            out += " " + e.params.deps + " bevatten als " + e.params.property + " is gedefinieerd";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" moet een tekenreeks zijn';
                break;
              case "mapping":
                out = 'de waarde van het veld "' + e.params.tag + '" moet voorkomen in de oneOf';
                break;
              default:
                out = 'moet sleutelwoord validatie "' + e.keyword + '" doorstaan';
            }
            break;
          case "enum":
            out = "moet overeenkomen met één van de voorgedefinieerde waarden";
            break;
          case "false schema":
            out = "boolean schema is fout";
            break;
          case "format":
            out = 'moet overeenkomen met het volgende formaat: "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "moet " + cond + " zijn";
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "moet " + cond + " zijn";
            break;
          case "if":
            out = 'moet overeenkomen met "' + e.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "moet " + cond + " zijn";
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "mag niet meer dan " + n + " item";
            if (n != 1) {
              out += "s";
            }
            out += " bevatten";
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "mag niet langer dan " + n + " karakter";
            if (n != 1) {
              out += "s";
            }
            out += " zijn";
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "mag niet meer dan " + n + " eigenschap";
            if (n != 1) {
              out += "pen";
            }
            out += " bevatten";
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "moet " + cond + " zijn";
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "mag niet minder dan " + n + " item";
            if (n != 1) {
              out += "s";
            }
            out += " bevatten";
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "mag niet korter dan " + n + " karakter";
            if (n != 1) {
              out += "s";
            }
            out += " zijn";
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "mag niet minder dan " + n + " eigenschap";
            if (n != 1) {
              out += "pen";
            }
            out += " bevatten";
            break;
          case "multipleOf":
            out = "moet een veelvoud van " + e.params.multipleOf + " zijn";
            break;
          case "not":
            out = 'mag niet overeenkomen met een schema in "not"';
            break;
          case "oneOf":
            out = 'moet overeenkomen met één schema in "oneOf"';
            break;
          case "pattern":
            out = 'moet overeenkomen met het volgende patroon: "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'moet een eigenschap bevatten die overeenkomt met het pattroon: "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "eigenschapnaam is ongeldig";
            break;
          case "required":
            out = "moet de eigenschap " + e.params.missingProperty + " bevatten";
            break;
          case "type":
            out = "";
            var t = e.params.type;
            out += "moet een ";
            if (t == "number") {
              out += "nummer";
            } else if (t == "integer") {
              out += "geheel getal";
            } else if (t == "string") {
              out += "tekenreeks";
            } else if (t == "boolean") {
              out += "ja of nee waarde";
            }
            out += " (" + t + ") bevatten";
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "mag niet meer dan " + n + " item";
            if (n != 1) {
              out += "s";
            }
            out += " bevatten";
            break;
          case "unevaluatedProperties":
            out = "mag geen ongecontroleerde eigenschappen bevatten";
            break;
          case "uniqueItems":
            out = "mag geen gedupliceerde items bevatten (items ## " + e.params.j + " en " + e.params.i + " zijn identiek)";
            break;
          default:
            out = 'moet sleutelwoord validatie "' + e.keyword + '" doorstaan';
        }
        e.message = out;
      }
    };
    var pl = function localize_pl(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "nie powinien mieć więcej niż " + n + " element";
            if (n == 1) {
              out += "u";
            } else {
              out += "ów";
            }
            break;
          case "additionalProperties":
            out = "nie powinien zawierać dodatkowych pól";
            break;
          case "anyOf":
            out = 'powinien pasować do wzoru z sekcji "anyOf"';
            break;
          case "const":
            out = "powinien być równy stałej";
            break;
          case "contains":
            out = "must contain a valid item";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "powinien zawierać pol";
            if (n == 1) {
              out += "e";
            } else {
              out += "a";
            }
            out += " " + e.params.deps + " kiedy pole " + e.params.property + " jest obecne";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = 'powinien przejść walidację "' + e.keyword + '"';
            }
            break;
          case "enum":
            out = "powinien być równy jednej z predefiniowanych wartości";
            break;
          case "false schema":
            out = "boolean schema is false";
            break;
          case "format":
            out = 'powinien zgadzać się z formatem "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "powinien być " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "powinien być " + cond;
            break;
          case "if":
            out = 'must match "' + e.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "powinien być " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "nie powinien mieć więcej niż " + n + " element";
            if (n == 1) {
              out += "u";
            } else {
              out += "ów";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "nie powinien być dłuższy niż " + n + " znak";
            if (n != 1) {
              out += "ów";
            }
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "nie powinien zawierać więcej niż " + n + " ";
            if (n == 1) {
              out += "pole";
            } else {
              out += "pól";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "powinien być " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "nie powinien mieć mniej niż " + n + " element";
            if (n == 1) {
              out += "u";
            } else {
              out += "ów";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "nie powinien być krótszy niż " + n + " znak";
            if (n != 1) {
              out += "ów";
            }
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "nie powinien zawierać mniej niż " + n + " ";
            if (n == 1) {
              out += "pole";
            } else {
              out += "pól";
            }
            break;
          case "multipleOf":
            out = "powinien być wielokrotnością " + e.params.multipleOf;
            break;
          case "not":
            out = 'nie powinien pasować do wzoru z sekcji "not"';
            break;
          case "oneOf":
            out = 'powinien pasować do jednego wzoru z sekcji "oneOf"';
            break;
          case "pattern":
            out = 'powinien zgadzać się ze wzorem "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'powinien mieć pole pasujące do wzorca "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "property name is invalid";
            break;
          case "required":
            out = "powinien zawierać wymagane pole " + e.params.missingProperty;
            break;
          case "type":
            out = "powinien być " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "nie powinien zawierać elementów które się powtarzają (elementy " + e.params.j + " i " + e.params.i + " są identyczne)";
            break;
          default:
            out = 'powinien przejść walidację "' + e.keyword + '"';
        }
        e.message = out;
      }
    };
    var ptBR = function localize_pt_BR(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "não são permitidos itens adicionais (mais do que " + n + ")";
            break;
          case "additionalProperties":
            out = "não são permitidas propriedades adicionais";
            break;
          case "anyOf":
            out = 'os dados não correspondem a nenhum schema de "anyOf"';
            break;
          case "const":
            out = "deve ser igual à constante";
            break;
          case "contains":
            out = "deve conter um item válido";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += " deve ter propriedade";
            if (n != 1) {
              out += "s";
            }
            out += " " + e.params.deps + " quando a propriedade " + e.params.property + " estiver presente";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'a tag "' + e.params.tag + '" deve ser uma string';
                break;
              case "mapping":
                out = 'o valor da tag "' + e.params.tag + '" deve estar no oneOf';
                break;
              default:
                out = 'deve passar a validação da keyword "' + e.keyword + '"';
            }
            break;
          case "enum":
            out = "deve ser igual a um dos valores permitidos";
            break;
          case "false schema":
            out = 'o schema booleano é "false"';
            break;
          case "format":
            out = 'deve corresponder ao formato "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "deve ser " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "deve ser " + cond;
            break;
          case "if":
            out = 'deve corresponder ao schema "' + e.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "deve ser " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "não deve ter mais que " + n + " elemento";
            if (n != 1) {
              out += "s";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "não deve ser maior que " + n + " caracter";
            if (n != 1) {
              out += "es";
            }
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "não deve ter mais que " + n + " propriedade";
            if (n != 1) {
              out += "s";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "deve ser " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "não deve ter menos que " + n + " elemento";
            if (n != 1) {
              out += "s";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "não deve ser mais curta que " + n + " caracter";
            if (n != 1) {
              out += "es";
            }
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "não deve ter menos que " + n + " propriedade";
            if (n != 1) {
              out += "s";
            }
            break;
          case "multipleOf":
            out = "deve ser múltiplo de " + e.params.multipleOf;
            break;
          case "not":
            out = 'não deve ser valido segundo o schema em "not"';
            break;
          case "oneOf":
            out = 'deve corresponder exatamente com um schema em "oneOf"';
            break;
          case "pattern":
            out = 'deve corresponder ao padrão "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'deve ter a propriedade correspondente ao padrão "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "o nome da propriedade é inválido";
            break;
          case "required":
            out = "deve ter a propriedade obrigatória " + e.params.missingProperty;
            break;
          case "type":
            out = "";
            var t = e.params.type;
            out += "deve ser ";
            if (t == "number") {
              out += "um número";
            } else if (t == "integer") {
              out += "um número inteiro";
            } else if (t == "string") {
              out += "um texto";
            } else if (t == "boolean") {
              out += "um booleano";
            } else {
              out += t;
            }
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "não pode possuir mais que " + n + " ";
            if (n == 1) {
              out += "item";
            } else {
              out += "itens";
            }
            break;
          case "unevaluatedProperties":
            out = "não pode possuir propridades não avaliadas";
            break;
          case "uniqueItems":
            out = "não deve ter itens duplicados (os itens ## " + e.params.j + " e " + e.params.i + " são idênticos)";
            break;
          default:
            out = 'deve passar a validação da keyword "' + e.keyword + '"';
        }
        e.message = out;
      }
    };
    var ru = function localize_ru(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "должно иметь не более, чем " + n + " элемент";
            if (n >= 2 && n <= 4) {
              out += "а";
            } else if (n != 1) {
              out += "ов";
            }
            break;
          case "additionalProperties":
            out = "не должно иметь дополнительных полей";
            break;
          case "anyOf":
            out = 'должно соответствовать одной их схем в "anyOf"';
            break;
          case "const":
            out = "должно быть равно заданному значению";
            break;
          case "contains":
            out = "должно содержать значение соответствующее схеме";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "должно иметь пол";
            if (n == 1) {
              out += "е";
            } else {
              out += "я";
            }
            out += " " + e.params.deps + ", когда присутствует поле " + e.params.property;
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'поле "' + e.params.tag + '" должно быть строкой';
                break;
              case "mapping":
                out = 'значение поля "' + e.params.tag + '" должно быть в одной из oneOf схем ';
                break;
              default:
                out = 'должно соответствовать правилу "' + e.keyword + '"';
            }
            break;
          case "enum":
            out = "должно быть равно одному из разрешенных значений";
            break;
          case "false schema":
            out = "схема равна false";
            break;
          case "format":
            out = 'должно соответствовать формату "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "должно быть " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "должно быть " + cond;
            break;
          case "if":
            out = 'должно соответствовать схемe "' + e.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "должно быть " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "должно иметь не более, чем " + n + " элемент";
            if (n >= 2 && n <= 4) {
              out += "а";
            } else if (n != 1) {
              out += "ов";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "должно быть не длиннее, чем " + n + " символ";
            if (n >= 2 && n <= 4) {
              out += "а";
            } else if (n != 1) {
              out += "ов";
            }
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "должно иметь не более, чем " + n + " пол";
            if (n == 1) {
              out += "е";
            } else if (n >= 2 && n <= 4) {
              out += "я";
            } else {
              out += "ей";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "должно быть " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "должно иметь не менее, чем " + n + " элемент";
            if (n >= 2 && n <= 4) {
              out += "а";
            } else if (n != 1) {
              out += "ов";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "должно быть не короче, чем " + n + " символ";
            if (n >= 2 && n <= 4) {
              out += "а";
            } else if (n != 1) {
              out += "ов";
            }
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "должно иметь не менее, чем " + n + " пол";
            if (n == 1) {
              out += "е";
            } else if (n >= 2 && n <= 4) {
              out += "я";
            } else {
              out += "ей";
            }
            break;
          case "multipleOf":
            out = "должно быть кратным " + e.params.multipleOf;
            break;
          case "not":
            out = 'должно не соответствовать схеме в "not"';
            break;
          case "oneOf":
            out = 'должно соответствовать в точности одной схемe в "oneOf"';
            break;
          case "pattern":
            out = 'должно соответствовать образцу "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'должно иметь поле, соответствующее образцу "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "имя поля не соответствует схеме";
            break;
          case "required":
            out = "должно иметь обязательное поле " + e.params.missingProperty;
            break;
          case "type":
            out = "должно быть " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "должно иметь не более, чем " + n + " элемент";
            if (n >= 2 && n <= 4) {
              out += "а";
            } else if (n != 1) {
              out += "ов";
            }
            break;
          case "unevaluatedProperties":
            out = "не должно иметь непроверенных полей";
            break;
          case "uniqueItems":
            out = "не должно иметь повторяющихся элементов (элементы " + e.params.j + " и " + e.params.i + " идентичны)";
            break;
          default:
            out = 'должно соответствовать правилу "' + e.keyword + '"';
        }
        e.message = out;
      }
    };
    var sk = function localize_sk(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "nemôže obsahovať viac, než " + n + " prv";
            if (n == 1) {
              out += "ok";
            } else {
              out += "kov";
            }
            break;
          case "additionalProperties":
            out = "nemôže obsahovať ďalšie položky";
            break;
          case "anyOf":
            out = 'musí splňovať aspoň jednu zo schém v "anyOf"';
            break;
          case "const":
            out = "musí byť konštanta";
            break;
          case "contains":
            out = "musí obsahovať prvok zodpovedajúci schéme";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += " musí obsahovať polož";
            if (n >= 2 && n <= 4) {
              out += "ky";
            } else if (n != 1) {
              out += "iek";
            } else {
              out += "ka";
            }
            out += ": " + e.params.deps + ", ak obsahuje " + e.params.property;
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = 'musí splniť "' + e.keyword + '" validáciu';
            }
            break;
          case "enum":
            out = "musí byť jedna z definovaných hodnôt";
            break;
          case "false schema":
            out = "schéma je false";
            break;
          case "format":
            out = 'musí obsahovať formát "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "musí byť " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "musí byť " + cond;
            break;
          case "if":
            out = 'must match "' + e.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "musí byť " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "nesmie obsahovať viac než " + n + " prv";
            if (n == 1) {
              out += "ok";
            } else {
              out += "kov";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "nesmie byť dlhší než " + n + " znak";
            if (n != 1) {
              out += "ov";
            }
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "nesmie obsahovať viac než " + n + " polož";
            if (n >= 2 && n <= 4) {
              out += "ky";
            } else if (n != 1) {
              out += "iek";
            } else {
              out += "ka";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "musí byť " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "nesmie obsahovať menej než " + n + " prv";
            if (n == 1) {
              out += "ok";
            } else {
              out += "kov";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "nesmie byť kratší než " + n + " znak";
            if (n != 1) {
              out += "ov";
            }
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "nesmie obsahovať menej než " + n + " polož";
            if (n >= 2 && n <= 4) {
              out += "ky";
            } else if (n != 1) {
              out += "iek";
            } else {
              out += "ka";
            }
            break;
          case "multipleOf":
            out = "musí byť násobkom " + e.params.multipleOf;
            break;
          case "not":
            out = 'nesmie splňovať schému v "not"';
            break;
          case "oneOf":
            out = 'musí splňovať práve jednu schému v "oneOf"';
            break;
          case "pattern":
            out = 'musí splňovať regulárny výraz "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'musí obsahovať položku splňjúcu regulárny výraz "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "názov položky nezodpovedá schéme";
            break;
          case "required":
            out = "musí obsahovať požadovanú položku " + e.params.missingProperty;
            break;
          case "type":
            out = "musí byť " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "nesmie obsahovať duplicitné prvky (prvky ## " + e.params.j + " a " + e.params.i + " sú rovnaké)";
            break;
          default:
            out = 'musí splniť "' + e.keyword + '" validáciu';
        }
        e.message = out;
      }
    };
    var sv = function localize_sv(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "borde ha fler än " + n + " sak";
            if (n != 1) {
              out += "er";
            }
            break;
          case "additionalProperties":
            out = "borde inte ha fler egenskaper";
            break;
          case "anyOf":
            out = 'borde matcha något schema i "anyOf"';
            break;
          case "const":
            out = "bör vara en konstant";
            break;
          case "contains":
            out = "bör innehålla ett giltigt objekt";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "borde ha egenskap";
            if (n != 1) {
              out += "er";
            }
            out += " " + e.params.deps + " när egenskap " + e.params.property + " finns tillgängligt";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" must be string';
                break;
              case "mapping":
                out = 'value of tag "' + e.params.tag + '" must be in oneOf';
                break;
              default:
                out = 'bör passera "' + e.keyword + '" nyckelord validering';
            }
            break;
          case "enum":
            out = "borde vara ekvivalent med en av dess fördefinierade värden";
            break;
          case "false schema":
            out = "boolean schema är falskt";
            break;
          case "format":
            out = 'borde matcha formatet "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "bör vara " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "bör vara " + cond;
            break;
          case "if":
            out = 'must match "' + e.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "borde vara " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "borde inte ha fler än " + n + " sak";
            if (n != 1) {
              out += "er";
            }
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "borde inte vara längre än " + n + " tecken";
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "borde inte ha fler än " + n + " egenskap";
            if (n != 1) {
              out += "er";
            }
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "borde vara " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "borde inte ha färre än " + n + " sak";
            if (n != 1) {
              out += "er";
            }
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "borde inte vara kortare än " + n + " tecken";
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "borde inte ha färre än " + n + " egenskap";
            if (n != 1) {
              out += "er";
            }
            break;
          case "multipleOf":
            out = "borde vara en multipel av " + e.params.multipleOf;
            break;
          case "not":
            out = 'borde inte vara giltigt enligt schema i "not"';
            break;
          case "oneOf":
            out = 'borde matcha exakt ett schema i "oneOf"';
            break;
          case "pattern":
            out = 'borde matcha mönstret "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'bör ha en egenskap som matchar mönstret "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "egenskap med namnet är inte giltig";
            break;
          case "required":
            out = "borde ha den nödvändiga egenskapen " + e.params.missingProperty;
            break;
          case "type":
            out = "borde vara " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "must NOT have more than " + n + " item";
            if (n != 1) {
              out += "s";
            }
            break;
          case "unevaluatedProperties":
            out = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            out = "borde inte ha duplicerade saker (sakerna ## " + e.params.j + " och " + e.params.i + " är identiska)";
            break;
          default:
            out = 'bör passera "' + e.keyword + '" nyckelord validering';
        }
        e.message = out;
      }
    };
    var th = function localize_th(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "ต้องมีสมาชิกไม่เกิน " + n + " ตัว";
            break;
          case "additionalProperties":
            out = "ต้องไม่มี property อื่นๆ นอกเหนีอจากที่กำหนดไว้";
            break;
          case "anyOf":
            out = 'ต้องตรงกับหนึ่งใน schema ที่กำหนดไว้ใน "anyOf"';
            break;
          case "const":
            out = "ต้องเท่ากับค่าคงที่";
            break;
          case "contains":
            out = "ต้องมีสมาชิกที่ผ่านเงื่อนไขอยู่";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "เมื่อมี property " + e.params.property + " แล้วจะต้องมี property " + e.params.deps + " ด้วย";
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = 'tag "' + e.params.tag + '" ต้องเป็น string';
                break;
              case "mapping":
                out = 'ต้องมีค่าของ tag "' + e.params.tag + '" ใน oneOf';
                break;
              default:
                out = 'ต้องผ่านคีย์เวิร์ด "' + e.keyword + '"';
            }
            break;
          case "enum":
            out = "ต้องตรงกับหนึ่งในค่าที่กำหนดไว้";
            break;
          case "false schema":
            out = "schema เป็น false";
            break;
          case "format":
            out = 'ต้องเป็นรูปแบบ "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "ต้อง " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "ต้อง " + cond;
            break;
          case "if":
            out = 'ต้องตรงกับ schema "' + e.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "ต้อง " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "ต้องมีสมาชิกไม่เกิน " + n;
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "ต้องยาวไม่เกิน " + n + " ตัวอักษร";
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "ต้องมี property ไม่เกิน " + n + " ตัว";
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "ต้อง " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "ควรมีสมาชิกไม่น้อยกว่า " + n;
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "ต้องมีอย่างน้อย " + n + " ตัวอักษร";
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "ต้องมี property อย่างน้อย " + n + " ตัว";
            break;
          case "multipleOf":
            out = "ต้องเป็นเลขที่หาร " + e.params.multipleOf + " ลงตัว";
            break;
          case "not":
            out = 'ต้องไม่ผ่าน schema ที่กำหนดไว้ใน "not"';
            break;
          case "oneOf":
            out = 'ต้องตรงกับ schema ตัวเดียวใน "oneOf" เท่านั้น';
            break;
          case "pattern":
            out = 'ต้องตรงตาม pattern "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = 'ต้องมี property ที่มีชื่อตรงตาม pattern "' + e.params.missingPattern + '"';
            break;
          case "propertyNames":
            out = "ชื่อ property ไม่ถูกต้อง";
            break;
          case "required":
            out = "ต้องมี property " + e.params.missingProperty + " ด้วย";
            break;
          case "type":
            out = "ต้องเป็น " + e.params.type;
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += "ต้องมีไม่เกิน " + n + " ตัว";
            break;
          case "unevaluatedProperties":
            out = "ต้องไม่มี property ที่ยังไม่ได้ผ่านการตรวจสอบเงื่อนไขใดๆ";
            break;
          case "uniqueItems":
            out = "ต้องมีสมาชิกไม่ซ้ำักัน (ลำดับที่ " + e.params.j + " กับ " + e.params.i + " ซ้ำกัน)";
            break;
          default:
            out = 'ต้องผ่านคีย์เวิร์ด "' + e.keyword + '"';
        }
        e.message = out;
      }
    };
    var zh = function localize_zh(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "不允许超过" + n + "个元素";
            break;
          case "additionalProperties":
            out = "不允许有额外的属性";
            break;
          case "anyOf":
            out = "数据应为 anyOf 所指定的其中一个";
            break;
          case "const":
            out = "应当等于常量";
            break;
          case "contains":
            out = "应当包含一个有效项";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "应当拥有属性" + e.params.property + "的依赖属性" + e.params.deps;
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = '标签 "' + e.params.tag + '" 的类型必须为字符串';
                break;
              case "mapping":
                out = '标签 "' + e.params.tag + '" 的值必须在 oneOf 之中';
                break;
              default:
                out = '应当通过 "' + e.keyword + ' 关键词校验"';
            }
            break;
          case "enum":
            out = "应当是预设定的枚举值之一";
            break;
          case "false schema":
            out = "布尔模式出错";
            break;
          case "format":
            out = '应当匹配格式 "' + e.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "应当是 " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "应当是 " + cond;
            break;
          case "if":
            out = '应当匹配模式 "' + e.params.failingKeyword + '" ';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "应当为 " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "不应多于 " + n + " 个项";
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "不应多于 " + n + " 个字符";
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "不应有多于 " + n + " 个属性";
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "应当为 " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "不应少于 " + n + " 个项";
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "不应少于 " + n + " 个字符";
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "不应有少于 " + n + " 个属性";
            break;
          case "multipleOf":
            out = "应当是 " + e.params.multipleOf + " 的整数倍";
            break;
          case "not":
            out = '不应当匹配 "not" schema';
            break;
          case "oneOf":
            out = '只能匹配一个 "oneOf" 中的 schema';
            break;
          case "pattern":
            out = '应当匹配模式 "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = "应当有属性匹配模式 " + e.params.missingPattern;
            break;
          case "propertyNames":
            out = "属性名 无效";
            break;
          case "required":
            out = "应当有必需属性 " + e.params.missingProperty;
            break;
          case "type":
            out = "应当是 " + e.params.type + " 类型";
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += " 不允许有超过 " + n + " 个元素";
            break;
          case "unevaluatedProperties":
            out = "不允许存在未求值的属性";
            break;
          case "uniqueItems":
            out = "不应当含有重复项 (第 " + e.params.j + " 项与第 " + e.params.i + " 项是重复的)";
            break;
          default:
            out = '应当通过 "' + e.keyword + ' 关键词校验"';
        }
        e.message = out;
      }
    };
    var zhTW = function localize_zh_TW(errors2) {
      if (!(errors2 && errors2.length))
        return;
      for (const e of errors2) {
        let out;
        switch (e.keyword) {
          case "additionalItems":
          case "items":
            out = "";
            var n = e.params.limit;
            out += "不可以超過" + n + "個元素";
            break;
          case "additionalProperties":
            out = "不可以有額外的屬性";
            break;
          case "anyOf":
            out = "不符合 anyOf 指定的模式";
            break;
          case "const":
            out = "應該等於常數";
            break;
          case "contains":
            out = "應該包含一個有效元素";
            break;
          case "dependencies":
          case "dependentRequired":
            out = "";
            var n = e.params.depsCount;
            out += "應該要有屬性" + e.params.property + "的依賴屬性" + e.params.deps;
            break;
          case "discriminator":
            switch (e.params.error) {
              case "tag":
                out = '標籤 "' + e.params.tag + '" 的類型必須是字串';
                break;
              case "mapping":
                out = '標籤 "' + e.params.tag + '" 必須在 oneOf 其中之一';
                break;
              default:
                out = '應該通過 "' + e.keyword + ' 關鍵詞檢驗"';
            }
            break;
          case "enum":
            out = "應該要在預設的值之中";
            break;
          case "false schema":
            out = "布林模式不正確";
            break;
          case "format":
            out = "應該要符合" + e.params.format + "格式";
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "應該是 " + cond;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "應該是 " + cond;
            break;
          case "if":
            out = '應該符合 "' + e.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "應該要 " + cond;
            break;
          case "maxItems":
            out = "";
            var n = e.params.limit;
            out += "不應該多於 " + n + " 個";
            break;
          case "maxLength":
            out = "";
            var n = e.params.limit;
            out += "不應該多於 " + n + " 個字元";
            break;
          case "maxProperties":
            out = "";
            var n = e.params.limit;
            out += "不應該多於 " + n + " 個屬性";
            break;
          case "minimum":
          case "exclusiveMinimum":
            out = "";
            var cond = e.params.comparison + " " + e.params.limit;
            out += "應該要 " + cond;
            break;
          case "minItems":
            out = "";
            var n = e.params.limit;
            out += "不應該少於 " + n + " 個";
            break;
          case "minLength":
            out = "";
            var n = e.params.limit;
            out += "不應該少於 " + n + " 個字元";
            break;
          case "minProperties":
            out = "";
            var n = e.params.limit;
            out += "不應該少於 " + n + " 個屬性";
            break;
          case "multipleOf":
            out = "應該是 " + e.params.multipleOf + " 的整數倍";
            break;
          case "not":
            out = '不應該符合 "not" schema';
            break;
          case "oneOf":
            out = '只能符合一個 "oneOf" 中的 schema';
            break;
          case "pattern":
            out = '應該符合模式 "' + e.params.pattern + '"';
            break;
          case "patternRequired":
            out = "應該有屬性對應模式 " + e.params.missingPattern;
            break;
          case "propertyNames":
            out = "属性名 無效";
            break;
          case "required":
            out = "應該有必須屬性 " + e.params.missingProperty;
            break;
          case "type":
            out = "應該是 " + e.params.type + " 類型";
            break;
          case "unevaluatedItems":
            out = "";
            var n = e.params.len;
            out += " 的元素不可以超過 " + n + " 個";
            break;
          case "unevaluatedProperties":
            out = "不應該有未驗證的屬性";
            break;
          case "uniqueItems":
            out = "不應該有重複項目 (第 " + e.params.j + " 項和第 " + e.params.i + " 項是重複的)";
            break;
          default:
            out = '應該通過 "' + e.keyword + ' 關鍵詞檢驗"';
        }
        e.message = out;
      }
    };
    var localize = {
      en: en$1,
      ar,
      ca,
      cs,
      de,
      es,
      fi,
      fr: fr$1,
      hu,
      id,
      it: it$1,
      ja,
      ko,
      nb,
      nl: nl$1,
      pl,
      "pt-BR": ptBR,
      ru,
      sk,
      sv,
      th,
      zh,
      "zh-TW": zhTW
    };
    const ajvLocalizeModule = /* @__PURE__ */ getDefaultExportFromCjs(localize);
    var utils$1 = {};
    const Aacute = "Á";
    const aacute = "á";
    const Abreve = "Ă";
    const abreve = "ă";
    const ac = "∾";
    const acd = "∿";
    const acE = "∾̳";
    const Acirc = "Â";
    const acirc = "â";
    const acute = "´";
    const Acy = "А";
    const acy = "а";
    const AElig = "Æ";
    const aelig = "æ";
    const af = "⁡";
    const Afr = "𝔄";
    const afr = "𝔞";
    const Agrave = "À";
    const agrave = "à";
    const alefsym = "ℵ";
    const aleph = "ℵ";
    const Alpha = "Α";
    const alpha = "α";
    const Amacr = "Ā";
    const amacr = "ā";
    const amalg = "⨿";
    const amp = "&";
    const AMP = "&";
    const andand = "⩕";
    const And = "⩓";
    const and = "∧";
    const andd = "⩜";
    const andslope = "⩘";
    const andv = "⩚";
    const ang = "∠";
    const ange = "⦤";
    const angle = "∠";
    const angmsdaa = "⦨";
    const angmsdab = "⦩";
    const angmsdac = "⦪";
    const angmsdad = "⦫";
    const angmsdae = "⦬";
    const angmsdaf = "⦭";
    const angmsdag = "⦮";
    const angmsdah = "⦯";
    const angmsd = "∡";
    const angrt = "∟";
    const angrtvb = "⊾";
    const angrtvbd = "⦝";
    const angsph = "∢";
    const angst = "Å";
    const angzarr = "⍼";
    const Aogon = "Ą";
    const aogon = "ą";
    const Aopf = "𝔸";
    const aopf = "𝕒";
    const apacir = "⩯";
    const ap = "≈";
    const apE = "⩰";
    const ape = "≊";
    const apid = "≋";
    const apos = "'";
    const ApplyFunction = "⁡";
    const approx = "≈";
    const approxeq = "≊";
    const Aring = "Å";
    const aring = "å";
    const Ascr = "𝒜";
    const ascr = "𝒶";
    const Assign = "≔";
    const ast = "*";
    const asymp = "≈";
    const asympeq = "≍";
    const Atilde = "Ã";
    const atilde = "ã";
    const Auml = "Ä";
    const auml = "ä";
    const awconint = "∳";
    const awint = "⨑";
    const backcong = "≌";
    const backepsilon = "϶";
    const backprime = "‵";
    const backsim = "∽";
    const backsimeq = "⋍";
    const Backslash = "∖";
    const Barv = "⫧";
    const barvee = "⊽";
    const barwed = "⌅";
    const Barwed = "⌆";
    const barwedge = "⌅";
    const bbrk = "⎵";
    const bbrktbrk = "⎶";
    const bcong = "≌";
    const Bcy = "Б";
    const bcy = "б";
    const bdquo = "„";
    const becaus = "∵";
    const because = "∵";
    const Because = "∵";
    const bemptyv = "⦰";
    const bepsi = "϶";
    const bernou = "ℬ";
    const Bernoullis = "ℬ";
    const Beta = "Β";
    const beta = "β";
    const beth = "ℶ";
    const between = "≬";
    const Bfr = "𝔅";
    const bfr = "𝔟";
    const bigcap = "⋂";
    const bigcirc = "◯";
    const bigcup = "⋃";
    const bigodot = "⨀";
    const bigoplus = "⨁";
    const bigotimes = "⨂";
    const bigsqcup = "⨆";
    const bigstar = "★";
    const bigtriangledown = "▽";
    const bigtriangleup = "△";
    const biguplus = "⨄";
    const bigvee = "⋁";
    const bigwedge = "⋀";
    const bkarow = "⤍";
    const blacklozenge = "⧫";
    const blacksquare = "▪";
    const blacktriangle = "▴";
    const blacktriangledown = "▾";
    const blacktriangleleft = "◂";
    const blacktriangleright = "▸";
    const blank = "␣";
    const blk12 = "▒";
    const blk14 = "░";
    const blk34 = "▓";
    const block$1 = "█";
    const bne = "=⃥";
    const bnequiv = "≡⃥";
    const bNot = "⫭";
    const bnot = "⌐";
    const Bopf = "𝔹";
    const bopf = "𝕓";
    const bot = "⊥";
    const bottom = "⊥";
    const bowtie = "⋈";
    const boxbox = "⧉";
    const boxdl = "┐";
    const boxdL = "╕";
    const boxDl = "╖";
    const boxDL = "╗";
    const boxdr = "┌";
    const boxdR = "╒";
    const boxDr = "╓";
    const boxDR = "╔";
    const boxh = "─";
    const boxH = "═";
    const boxhd = "┬";
    const boxHd = "╤";
    const boxhD = "╥";
    const boxHD = "╦";
    const boxhu = "┴";
    const boxHu = "╧";
    const boxhU = "╨";
    const boxHU = "╩";
    const boxminus = "⊟";
    const boxplus = "⊞";
    const boxtimes = "⊠";
    const boxul = "┘";
    const boxuL = "╛";
    const boxUl = "╜";
    const boxUL = "╝";
    const boxur = "└";
    const boxuR = "╘";
    const boxUr = "╙";
    const boxUR = "╚";
    const boxv = "│";
    const boxV = "║";
    const boxvh = "┼";
    const boxvH = "╪";
    const boxVh = "╫";
    const boxVH = "╬";
    const boxvl = "┤";
    const boxvL = "╡";
    const boxVl = "╢";
    const boxVL = "╣";
    const boxvr = "├";
    const boxvR = "╞";
    const boxVr = "╟";
    const boxVR = "╠";
    const bprime = "‵";
    const breve = "˘";
    const Breve = "˘";
    const brvbar = "¦";
    const bscr = "𝒷";
    const Bscr = "ℬ";
    const bsemi = "⁏";
    const bsim = "∽";
    const bsime = "⋍";
    const bsolb = "⧅";
    const bsol = "\\";
    const bsolhsub = "⟈";
    const bull = "•";
    const bullet = "•";
    const bump = "≎";
    const bumpE = "⪮";
    const bumpe = "≏";
    const Bumpeq = "≎";
    const bumpeq = "≏";
    const Cacute = "Ć";
    const cacute = "ć";
    const capand = "⩄";
    const capbrcup = "⩉";
    const capcap = "⩋";
    const cap = "∩";
    const Cap = "⋒";
    const capcup = "⩇";
    const capdot = "⩀";
    const CapitalDifferentialD = "ⅅ";
    const caps = "∩︀";
    const caret = "⁁";
    const caron = "ˇ";
    const Cayleys = "ℭ";
    const ccaps = "⩍";
    const Ccaron = "Č";
    const ccaron = "č";
    const Ccedil = "Ç";
    const ccedil = "ç";
    const Ccirc = "Ĉ";
    const ccirc = "ĉ";
    const Cconint = "∰";
    const ccups = "⩌";
    const ccupssm = "⩐";
    const Cdot = "Ċ";
    const cdot = "ċ";
    const cedil = "¸";
    const Cedilla = "¸";
    const cemptyv = "⦲";
    const cent = "¢";
    const centerdot = "·";
    const CenterDot = "·";
    const cfr = "𝔠";
    const Cfr = "ℭ";
    const CHcy = "Ч";
    const chcy = "ч";
    const check = "✓";
    const checkmark = "✓";
    const Chi = "Χ";
    const chi = "χ";
    const circ = "ˆ";
    const circeq = "≗";
    const circlearrowleft = "↺";
    const circlearrowright = "↻";
    const circledast = "⊛";
    const circledcirc = "⊚";
    const circleddash = "⊝";
    const CircleDot = "⊙";
    const circledR = "®";
    const circledS = "Ⓢ";
    const CircleMinus = "⊖";
    const CirclePlus = "⊕";
    const CircleTimes = "⊗";
    const cir = "○";
    const cirE = "⧃";
    const cire = "≗";
    const cirfnint = "⨐";
    const cirmid = "⫯";
    const cirscir = "⧂";
    const ClockwiseContourIntegral = "∲";
    const CloseCurlyDoubleQuote = "”";
    const CloseCurlyQuote = "’";
    const clubs = "♣";
    const clubsuit = "♣";
    const colon = ":";
    const Colon = "∷";
    const Colone = "⩴";
    const colone = "≔";
    const coloneq = "≔";
    const comma = ",";
    const commat = "@";
    const comp = "∁";
    const compfn = "∘";
    const complement = "∁";
    const complexes = "ℂ";
    const cong = "≅";
    const congdot = "⩭";
    const Congruent = "≡";
    const conint = "∮";
    const Conint = "∯";
    const ContourIntegral = "∮";
    const copf = "𝕔";
    const Copf = "ℂ";
    const coprod = "∐";
    const Coproduct = "∐";
    const copy = "©";
    const COPY = "©";
    const copysr = "℗";
    const CounterClockwiseContourIntegral = "∳";
    const crarr = "↵";
    const cross = "✗";
    const Cross = "⨯";
    const Cscr = "𝒞";
    const cscr = "𝒸";
    const csub = "⫏";
    const csube = "⫑";
    const csup = "⫐";
    const csupe = "⫒";
    const ctdot = "⋯";
    const cudarrl = "⤸";
    const cudarrr = "⤵";
    const cuepr = "⋞";
    const cuesc = "⋟";
    const cularr = "↶";
    const cularrp = "⤽";
    const cupbrcap = "⩈";
    const cupcap = "⩆";
    const CupCap = "≍";
    const cup = "∪";
    const Cup = "⋓";
    const cupcup = "⩊";
    const cupdot = "⊍";
    const cupor = "⩅";
    const cups = "∪︀";
    const curarr = "↷";
    const curarrm = "⤼";
    const curlyeqprec = "⋞";
    const curlyeqsucc = "⋟";
    const curlyvee = "⋎";
    const curlywedge = "⋏";
    const curren = "¤";
    const curvearrowleft = "↶";
    const curvearrowright = "↷";
    const cuvee = "⋎";
    const cuwed = "⋏";
    const cwconint = "∲";
    const cwint = "∱";
    const cylcty = "⌭";
    const dagger = "†";
    const Dagger = "‡";
    const daleth = "ℸ";
    const darr = "↓";
    const Darr = "↡";
    const dArr = "⇓";
    const dash = "‐";
    const Dashv = "⫤";
    const dashv = "⊣";
    const dbkarow = "⤏";
    const dblac = "˝";
    const Dcaron = "Ď";
    const dcaron = "ď";
    const Dcy = "Д";
    const dcy = "д";
    const ddagger = "‡";
    const ddarr = "⇊";
    const DD = "ⅅ";
    const dd = "ⅆ";
    const DDotrahd = "⤑";
    const ddotseq = "⩷";
    const deg = "°";
    const Del = "∇";
    const Delta = "Δ";
    const delta = "δ";
    const demptyv = "⦱";
    const dfisht = "⥿";
    const Dfr = "𝔇";
    const dfr = "𝔡";
    const dHar = "⥥";
    const dharl = "⇃";
    const dharr = "⇂";
    const DiacriticalAcute = "´";
    const DiacriticalDot = "˙";
    const DiacriticalDoubleAcute = "˝";
    const DiacriticalGrave = "`";
    const DiacriticalTilde = "˜";
    const diam = "⋄";
    const diamond = "⋄";
    const Diamond = "⋄";
    const diamondsuit = "♦";
    const diams = "♦";
    const die$1 = "¨";
    const DifferentialD = "ⅆ";
    const digamma = "ϝ";
    const disin = "⋲";
    const div = "÷";
    const divide = "÷";
    const divideontimes = "⋇";
    const divonx = "⋇";
    const DJcy = "Ђ";
    const djcy = "ђ";
    const dlcorn = "⌞";
    const dlcrop = "⌍";
    const dollar = "$";
    const Dopf = "𝔻";
    const dopf = "𝕕";
    const Dot = "¨";
    const dot = "˙";
    const DotDot = "⃜";
    const doteq = "≐";
    const doteqdot = "≑";
    const DotEqual = "≐";
    const dotminus = "∸";
    const dotplus = "∔";
    const dotsquare = "⊡";
    const doublebarwedge = "⌆";
    const DoubleContourIntegral = "∯";
    const DoubleDot = "¨";
    const DoubleDownArrow = "⇓";
    const DoubleLeftArrow = "⇐";
    const DoubleLeftRightArrow = "⇔";
    const DoubleLeftTee = "⫤";
    const DoubleLongLeftArrow = "⟸";
    const DoubleLongLeftRightArrow = "⟺";
    const DoubleLongRightArrow = "⟹";
    const DoubleRightArrow = "⇒";
    const DoubleRightTee = "⊨";
    const DoubleUpArrow = "⇑";
    const DoubleUpDownArrow = "⇕";
    const DoubleVerticalBar = "∥";
    const DownArrowBar = "⤓";
    const downarrow = "↓";
    const DownArrow = "↓";
    const Downarrow = "⇓";
    const DownArrowUpArrow = "⇵";
    const DownBreve = "̑";
    const downdownarrows = "⇊";
    const downharpoonleft = "⇃";
    const downharpoonright = "⇂";
    const DownLeftRightVector = "⥐";
    const DownLeftTeeVector = "⥞";
    const DownLeftVectorBar = "⥖";
    const DownLeftVector = "↽";
    const DownRightTeeVector = "⥟";
    const DownRightVectorBar = "⥗";
    const DownRightVector = "⇁";
    const DownTeeArrow = "↧";
    const DownTee = "⊤";
    const drbkarow = "⤐";
    const drcorn = "⌟";
    const drcrop = "⌌";
    const Dscr = "𝒟";
    const dscr = "𝒹";
    const DScy = "Ѕ";
    const dscy = "ѕ";
    const dsol = "⧶";
    const Dstrok = "Đ";
    const dstrok = "đ";
    const dtdot = "⋱";
    const dtri = "▿";
    const dtrif = "▾";
    const duarr = "⇵";
    const duhar = "⥯";
    const dwangle = "⦦";
    const DZcy = "Џ";
    const dzcy = "џ";
    const dzigrarr = "⟿";
    const Eacute = "É";
    const eacute = "é";
    const easter = "⩮";
    const Ecaron = "Ě";
    const ecaron = "ě";
    const Ecirc = "Ê";
    const ecirc = "ê";
    const ecir = "≖";
    const ecolon = "≕";
    const Ecy = "Э";
    const ecy = "э";
    const eDDot = "⩷";
    const Edot = "Ė";
    const edot = "ė";
    const eDot = "≑";
    const ee = "ⅇ";
    const efDot = "≒";
    const Efr = "𝔈";
    const efr = "𝔢";
    const eg = "⪚";
    const Egrave = "È";
    const egrave = "è";
    const egs = "⪖";
    const egsdot = "⪘";
    const el = "⪙";
    const Element$1 = "∈";
    const elinters = "⏧";
    const ell = "ℓ";
    const els = "⪕";
    const elsdot = "⪗";
    const Emacr = "Ē";
    const emacr = "ē";
    const empty = "∅";
    const emptyset = "∅";
    const EmptySmallSquare = "◻";
    const emptyv = "∅";
    const EmptyVerySmallSquare = "▫";
    const emsp13 = " ";
    const emsp14 = " ";
    const emsp = " ";
    const ENG = "Ŋ";
    const eng = "ŋ";
    const ensp = " ";
    const Eogon = "Ę";
    const eogon = "ę";
    const Eopf = "𝔼";
    const eopf = "𝕖";
    const epar = "⋕";
    const eparsl = "⧣";
    const eplus = "⩱";
    const epsi = "ε";
    const Epsilon = "Ε";
    const epsilon = "ε";
    const epsiv = "ϵ";
    const eqcirc = "≖";
    const eqcolon = "≕";
    const eqsim = "≂";
    const eqslantgtr = "⪖";
    const eqslantless = "⪕";
    const Equal = "⩵";
    const equals = "=";
    const EqualTilde = "≂";
    const equest = "≟";
    const Equilibrium = "⇌";
    const equiv = "≡";
    const equivDD = "⩸";
    const eqvparsl = "⧥";
    const erarr = "⥱";
    const erDot = "≓";
    const escr = "ℯ";
    const Escr = "ℰ";
    const esdot = "≐";
    const Esim = "⩳";
    const esim = "≂";
    const Eta = "Η";
    const eta = "η";
    const ETH = "Ð";
    const eth = "ð";
    const Euml = "Ë";
    const euml = "ë";
    const euro = "€";
    const excl = "!";
    const exist = "∃";
    const Exists = "∃";
    const expectation = "ℰ";
    const exponentiale = "ⅇ";
    const ExponentialE = "ⅇ";
    const fallingdotseq = "≒";
    const Fcy = "Ф";
    const fcy = "ф";
    const female = "♀";
    const ffilig = "ﬃ";
    const fflig = "ﬀ";
    const ffllig = "ﬄ";
    const Ffr = "𝔉";
    const ffr = "𝔣";
    const filig = "ﬁ";
    const FilledSmallSquare = "◼";
    const FilledVerySmallSquare = "▪";
    const fjlig = "fj";
    const flat = "♭";
    const fllig = "ﬂ";
    const fltns = "▱";
    const fnof = "ƒ";
    const Fopf = "𝔽";
    const fopf = "𝕗";
    const forall = "∀";
    const ForAll = "∀";
    const fork = "⋔";
    const forkv = "⫙";
    const Fouriertrf = "ℱ";
    const fpartint = "⨍";
    const frac12 = "½";
    const frac13 = "⅓";
    const frac14 = "¼";
    const frac15 = "⅕";
    const frac16 = "⅙";
    const frac18 = "⅛";
    const frac23 = "⅔";
    const frac25 = "⅖";
    const frac34 = "¾";
    const frac35 = "⅗";
    const frac38 = "⅜";
    const frac45 = "⅘";
    const frac56 = "⅚";
    const frac58 = "⅝";
    const frac78 = "⅞";
    const frasl = "⁄";
    const frown = "⌢";
    const fscr = "𝒻";
    const Fscr = "ℱ";
    const gacute = "ǵ";
    const Gamma = "Γ";
    const gamma = "γ";
    const Gammad = "Ϝ";
    const gammad = "ϝ";
    const gap = "⪆";
    const Gbreve = "Ğ";
    const gbreve = "ğ";
    const Gcedil = "Ģ";
    const Gcirc = "Ĝ";
    const gcirc = "ĝ";
    const Gcy = "Г";
    const gcy = "г";
    const Gdot = "Ġ";
    const gdot = "ġ";
    const ge = "≥";
    const gE = "≧";
    const gEl = "⪌";
    const gel = "⋛";
    const geq = "≥";
    const geqq = "≧";
    const geqslant = "⩾";
    const gescc = "⪩";
    const ges = "⩾";
    const gesdot = "⪀";
    const gesdoto = "⪂";
    const gesdotol = "⪄";
    const gesl = "⋛︀";
    const gesles = "⪔";
    const Gfr = "𝔊";
    const gfr = "𝔤";
    const gg = "≫";
    const Gg = "⋙";
    const ggg = "⋙";
    const gimel = "ℷ";
    const GJcy = "Ѓ";
    const gjcy = "ѓ";
    const gla = "⪥";
    const gl = "≷";
    const glE = "⪒";
    const glj = "⪤";
    const gnap = "⪊";
    const gnapprox = "⪊";
    const gne = "⪈";
    const gnE = "≩";
    const gneq = "⪈";
    const gneqq = "≩";
    const gnsim = "⋧";
    const Gopf = "𝔾";
    const gopf = "𝕘";
    const grave = "`";
    const GreaterEqual = "≥";
    const GreaterEqualLess = "⋛";
    const GreaterFullEqual = "≧";
    const GreaterGreater = "⪢";
    const GreaterLess = "≷";
    const GreaterSlantEqual = "⩾";
    const GreaterTilde = "≳";
    const Gscr = "𝒢";
    const gscr = "ℊ";
    const gsim = "≳";
    const gsime = "⪎";
    const gsiml = "⪐";
    const gtcc = "⪧";
    const gtcir = "⩺";
    const gt = ">";
    const GT = ">";
    const Gt = "≫";
    const gtdot = "⋗";
    const gtlPar = "⦕";
    const gtquest = "⩼";
    const gtrapprox = "⪆";
    const gtrarr = "⥸";
    const gtrdot = "⋗";
    const gtreqless = "⋛";
    const gtreqqless = "⪌";
    const gtrless = "≷";
    const gtrsim = "≳";
    const gvertneqq = "≩︀";
    const gvnE = "≩︀";
    const Hacek = "ˇ";
    const hairsp = " ";
    const half = "½";
    const hamilt = "ℋ";
    const HARDcy = "Ъ";
    const hardcy = "ъ";
    const harrcir = "⥈";
    const harr = "↔";
    const hArr = "⇔";
    const harrw = "↭";
    const Hat = "^";
    const hbar = "ℏ";
    const Hcirc = "Ĥ";
    const hcirc = "ĥ";
    const hearts = "♥";
    const heartsuit = "♥";
    const hellip = "…";
    const hercon = "⊹";
    const hfr = "𝔥";
    const Hfr = "ℌ";
    const HilbertSpace = "ℋ";
    const hksearow = "⤥";
    const hkswarow = "⤦";
    const hoarr = "⇿";
    const homtht = "∻";
    const hookleftarrow = "↩";
    const hookrightarrow = "↪";
    const hopf = "𝕙";
    const Hopf = "ℍ";
    const horbar = "―";
    const HorizontalLine = "─";
    const hscr = "𝒽";
    const Hscr = "ℋ";
    const hslash = "ℏ";
    const Hstrok = "Ħ";
    const hstrok = "ħ";
    const HumpDownHump = "≎";
    const HumpEqual = "≏";
    const hybull = "⁃";
    const hyphen = "‐";
    const Iacute = "Í";
    const iacute = "í";
    const ic = "⁣";
    const Icirc = "Î";
    const icirc = "î";
    const Icy = "И";
    const icy = "и";
    const Idot = "İ";
    const IEcy = "Е";
    const iecy = "е";
    const iexcl = "¡";
    const iff = "⇔";
    const ifr = "𝔦";
    const Ifr = "ℑ";
    const Igrave = "Ì";
    const igrave = "ì";
    const ii = "ⅈ";
    const iiiint = "⨌";
    const iiint = "∭";
    const iinfin = "⧜";
    const iiota = "℩";
    const IJlig = "Ĳ";
    const ijlig = "ĳ";
    const Imacr = "Ī";
    const imacr = "ī";
    const image$1 = "ℑ";
    const ImaginaryI = "ⅈ";
    const imagline = "ℐ";
    const imagpart = "ℑ";
    const imath = "ı";
    const Im = "ℑ";
    const imof = "⊷";
    const imped = "Ƶ";
    const Implies = "⇒";
    const incare = "℅";
    const infin = "∞";
    const infintie = "⧝";
    const inodot = "ı";
    const intcal = "⊺";
    const int = "∫";
    const Int = "∬";
    const integers = "ℤ";
    const Integral = "∫";
    const intercal = "⊺";
    const Intersection = "⋂";
    const intlarhk = "⨗";
    const intprod = "⨼";
    const InvisibleComma = "⁣";
    const InvisibleTimes = "⁢";
    const IOcy = "Ё";
    const iocy = "ё";
    const Iogon = "Į";
    const iogon = "į";
    const Iopf = "𝕀";
    const iopf = "𝕚";
    const Iota = "Ι";
    const iota = "ι";
    const iprod = "⨼";
    const iquest = "¿";
    const iscr = "𝒾";
    const Iscr = "ℐ";
    const isin = "∈";
    const isindot = "⋵";
    const isinE = "⋹";
    const isins = "⋴";
    const isinsv = "⋳";
    const isinv = "∈";
    const it = "⁢";
    const Itilde = "Ĩ";
    const itilde = "ĩ";
    const Iukcy = "І";
    const iukcy = "і";
    const Iuml = "Ï";
    const iuml = "ï";
    const Jcirc = "Ĵ";
    const jcirc = "ĵ";
    const Jcy = "Й";
    const jcy = "й";
    const Jfr = "𝔍";
    const jfr = "𝔧";
    const jmath = "ȷ";
    const Jopf = "𝕁";
    const jopf = "𝕛";
    const Jscr = "𝒥";
    const jscr = "𝒿";
    const Jsercy = "Ј";
    const jsercy = "ј";
    const Jukcy = "Є";
    const jukcy = "є";
    const Kappa = "Κ";
    const kappa = "κ";
    const kappav = "ϰ";
    const Kcedil = "Ķ";
    const kcedil = "ķ";
    const Kcy = "К";
    const kcy = "к";
    const Kfr = "𝔎";
    const kfr = "𝔨";
    const kgreen = "ĸ";
    const KHcy = "Х";
    const khcy = "х";
    const KJcy = "Ќ";
    const kjcy = "ќ";
    const Kopf = "𝕂";
    const kopf = "𝕜";
    const Kscr = "𝒦";
    const kscr = "𝓀";
    const lAarr = "⇚";
    const Lacute = "Ĺ";
    const lacute = "ĺ";
    const laemptyv = "⦴";
    const lagran = "ℒ";
    const Lambda = "Λ";
    const lambda = "λ";
    const lang = "⟨";
    const Lang = "⟪";
    const langd = "⦑";
    const langle = "⟨";
    const lap = "⪅";
    const Laplacetrf = "ℒ";
    const laquo = "«";
    const larrb = "⇤";
    const larrbfs = "⤟";
    const larr = "←";
    const Larr = "↞";
    const lArr = "⇐";
    const larrfs = "⤝";
    const larrhk = "↩";
    const larrlp = "↫";
    const larrpl = "⤹";
    const larrsim = "⥳";
    const larrtl = "↢";
    const latail = "⤙";
    const lAtail = "⤛";
    const lat = "⪫";
    const late = "⪭";
    const lates = "⪭︀";
    const lbarr = "⤌";
    const lBarr = "⤎";
    const lbbrk = "❲";
    const lbrace = "{";
    const lbrack = "[";
    const lbrke = "⦋";
    const lbrksld = "⦏";
    const lbrkslu = "⦍";
    const Lcaron = "Ľ";
    const lcaron = "ľ";
    const Lcedil = "Ļ";
    const lcedil = "ļ";
    const lceil = "⌈";
    const lcub = "{";
    const Lcy = "Л";
    const lcy = "л";
    const ldca = "⤶";
    const ldquo = "“";
    const ldquor = "„";
    const ldrdhar = "⥧";
    const ldrushar = "⥋";
    const ldsh = "↲";
    const le = "≤";
    const lE = "≦";
    const LeftAngleBracket = "⟨";
    const LeftArrowBar = "⇤";
    const leftarrow = "←";
    const LeftArrow = "←";
    const Leftarrow = "⇐";
    const LeftArrowRightArrow = "⇆";
    const leftarrowtail = "↢";
    const LeftCeiling = "⌈";
    const LeftDoubleBracket = "⟦";
    const LeftDownTeeVector = "⥡";
    const LeftDownVectorBar = "⥙";
    const LeftDownVector = "⇃";
    const LeftFloor = "⌊";
    const leftharpoondown = "↽";
    const leftharpoonup = "↼";
    const leftleftarrows = "⇇";
    const leftrightarrow = "↔";
    const LeftRightArrow = "↔";
    const Leftrightarrow = "⇔";
    const leftrightarrows = "⇆";
    const leftrightharpoons = "⇋";
    const leftrightsquigarrow = "↭";
    const LeftRightVector = "⥎";
    const LeftTeeArrow = "↤";
    const LeftTee = "⊣";
    const LeftTeeVector = "⥚";
    const leftthreetimes = "⋋";
    const LeftTriangleBar = "⧏";
    const LeftTriangle = "⊲";
    const LeftTriangleEqual = "⊴";
    const LeftUpDownVector = "⥑";
    const LeftUpTeeVector = "⥠";
    const LeftUpVectorBar = "⥘";
    const LeftUpVector = "↿";
    const LeftVectorBar = "⥒";
    const LeftVector = "↼";
    const lEg = "⪋";
    const leg = "⋚";
    const leq = "≤";
    const leqq = "≦";
    const leqslant = "⩽";
    const lescc = "⪨";
    const les = "⩽";
    const lesdot = "⩿";
    const lesdoto = "⪁";
    const lesdotor = "⪃";
    const lesg = "⋚︀";
    const lesges = "⪓";
    const lessapprox = "⪅";
    const lessdot = "⋖";
    const lesseqgtr = "⋚";
    const lesseqqgtr = "⪋";
    const LessEqualGreater = "⋚";
    const LessFullEqual = "≦";
    const LessGreater = "≶";
    const lessgtr = "≶";
    const LessLess = "⪡";
    const lesssim = "≲";
    const LessSlantEqual = "⩽";
    const LessTilde = "≲";
    const lfisht = "⥼";
    const lfloor = "⌊";
    const Lfr = "𝔏";
    const lfr = "𝔩";
    const lg = "≶";
    const lgE = "⪑";
    const lHar = "⥢";
    const lhard = "↽";
    const lharu = "↼";
    const lharul = "⥪";
    const lhblk = "▄";
    const LJcy = "Љ";
    const ljcy = "љ";
    const llarr = "⇇";
    const ll = "≪";
    const Ll = "⋘";
    const llcorner = "⌞";
    const Lleftarrow = "⇚";
    const llhard = "⥫";
    const lltri = "◺";
    const Lmidot = "Ŀ";
    const lmidot = "ŀ";
    const lmoustache = "⎰";
    const lmoust = "⎰";
    const lnap = "⪉";
    const lnapprox = "⪉";
    const lne = "⪇";
    const lnE = "≨";
    const lneq = "⪇";
    const lneqq = "≨";
    const lnsim = "⋦";
    const loang = "⟬";
    const loarr = "⇽";
    const lobrk = "⟦";
    const longleftarrow = "⟵";
    const LongLeftArrow = "⟵";
    const Longleftarrow = "⟸";
    const longleftrightarrow = "⟷";
    const LongLeftRightArrow = "⟷";
    const Longleftrightarrow = "⟺";
    const longmapsto = "⟼";
    const longrightarrow = "⟶";
    const LongRightArrow = "⟶";
    const Longrightarrow = "⟹";
    const looparrowleft = "↫";
    const looparrowright = "↬";
    const lopar = "⦅";
    const Lopf = "𝕃";
    const lopf = "𝕝";
    const loplus = "⨭";
    const lotimes = "⨴";
    const lowast = "∗";
    const lowbar = "_";
    const LowerLeftArrow = "↙";
    const LowerRightArrow = "↘";
    const loz = "◊";
    const lozenge = "◊";
    const lozf = "⧫";
    const lpar = "(";
    const lparlt = "⦓";
    const lrarr = "⇆";
    const lrcorner = "⌟";
    const lrhar = "⇋";
    const lrhard = "⥭";
    const lrm = "‎";
    const lrtri = "⊿";
    const lsaquo = "‹";
    const lscr = "𝓁";
    const Lscr = "ℒ";
    const lsh = "↰";
    const Lsh = "↰";
    const lsim = "≲";
    const lsime = "⪍";
    const lsimg = "⪏";
    const lsqb = "[";
    const lsquo = "‘";
    const lsquor = "‚";
    const Lstrok = "Ł";
    const lstrok = "ł";
    const ltcc = "⪦";
    const ltcir = "⩹";
    const lt = "<";
    const LT = "<";
    const Lt = "≪";
    const ltdot = "⋖";
    const lthree = "⋋";
    const ltimes = "⋉";
    const ltlarr = "⥶";
    const ltquest = "⩻";
    const ltri = "◃";
    const ltrie = "⊴";
    const ltrif = "◂";
    const ltrPar = "⦖";
    const lurdshar = "⥊";
    const luruhar = "⥦";
    const lvertneqq = "≨︀";
    const lvnE = "≨︀";
    const macr = "¯";
    const male = "♂";
    const malt = "✠";
    const maltese = "✠";
    const map$1 = "↦";
    const mapsto = "↦";
    const mapstodown = "↧";
    const mapstoleft = "↤";
    const mapstoup = "↥";
    const marker = "▮";
    const mcomma = "⨩";
    const Mcy = "М";
    const mcy = "м";
    const mdash = "—";
    const mDDot = "∺";
    const measuredangle = "∡";
    const MediumSpace = " ";
    const Mellintrf = "ℳ";
    const Mfr = "𝔐";
    const mfr = "𝔪";
    const mho = "℧";
    const micro = "µ";
    const midast = "*";
    const midcir = "⫰";
    const mid = "∣";
    const middot = "·";
    const minusb = "⊟";
    const minus = "−";
    const minusd = "∸";
    const minusdu = "⨪";
    const MinusPlus = "∓";
    const mlcp = "⫛";
    const mldr = "…";
    const mnplus = "∓";
    const models = "⊧";
    const Mopf = "𝕄";
    const mopf = "𝕞";
    const mp = "∓";
    const mscr = "𝓂";
    const Mscr = "ℳ";
    const mstpos = "∾";
    const Mu = "Μ";
    const mu = "μ";
    const multimap = "⊸";
    const mumap = "⊸";
    const nabla = "∇";
    const Nacute = "Ń";
    const nacute = "ń";
    const nang = "∠⃒";
    const nap = "≉";
    const napE = "⩰̸";
    const napid = "≋̸";
    const napos = "ŉ";
    const napprox = "≉";
    const natural = "♮";
    const naturals = "ℕ";
    const natur = "♮";
    const nbsp = " ";
    const nbump = "≎̸";
    const nbumpe = "≏̸";
    const ncap = "⩃";
    const Ncaron = "Ň";
    const ncaron = "ň";
    const Ncedil = "Ņ";
    const ncedil = "ņ";
    const ncong = "≇";
    const ncongdot = "⩭̸";
    const ncup = "⩂";
    const Ncy = "Н";
    const ncy = "н";
    const ndash = "–";
    const nearhk = "⤤";
    const nearr = "↗";
    const neArr = "⇗";
    const nearrow = "↗";
    const ne = "≠";
    const nedot = "≐̸";
    const NegativeMediumSpace = "​";
    const NegativeThickSpace = "​";
    const NegativeThinSpace = "​";
    const NegativeVeryThinSpace = "​";
    const nequiv = "≢";
    const nesear = "⤨";
    const nesim = "≂̸";
    const NestedGreaterGreater = "≫";
    const NestedLessLess = "≪";
    const NewLine = "\n";
    const nexist = "∄";
    const nexists = "∄";
    const Nfr = "𝔑";
    const nfr = "𝔫";
    const ngE = "≧̸";
    const nge = "≱";
    const ngeq = "≱";
    const ngeqq = "≧̸";
    const ngeqslant = "⩾̸";
    const nges = "⩾̸";
    const nGg = "⋙̸";
    const ngsim = "≵";
    const nGt = "≫⃒";
    const ngt = "≯";
    const ngtr = "≯";
    const nGtv = "≫̸";
    const nharr = "↮";
    const nhArr = "⇎";
    const nhpar = "⫲";
    const ni = "∋";
    const nis = "⋼";
    const nisd = "⋺";
    const niv = "∋";
    const NJcy = "Њ";
    const njcy = "њ";
    const nlarr = "↚";
    const nlArr = "⇍";
    const nldr = "‥";
    const nlE = "≦̸";
    const nle = "≰";
    const nleftarrow = "↚";
    const nLeftarrow = "⇍";
    const nleftrightarrow = "↮";
    const nLeftrightarrow = "⇎";
    const nleq = "≰";
    const nleqq = "≦̸";
    const nleqslant = "⩽̸";
    const nles = "⩽̸";
    const nless = "≮";
    const nLl = "⋘̸";
    const nlsim = "≴";
    const nLt = "≪⃒";
    const nlt = "≮";
    const nltri = "⋪";
    const nltrie = "⋬";
    const nLtv = "≪̸";
    const nmid = "∤";
    const NoBreak = "⁠";
    const NonBreakingSpace = " ";
    const nopf = "𝕟";
    const Nopf = "ℕ";
    const Not = "⫬";
    const not = "¬";
    const NotCongruent = "≢";
    const NotCupCap = "≭";
    const NotDoubleVerticalBar = "∦";
    const NotElement = "∉";
    const NotEqual = "≠";
    const NotEqualTilde = "≂̸";
    const NotExists = "∄";
    const NotGreater = "≯";
    const NotGreaterEqual = "≱";
    const NotGreaterFullEqual = "≧̸";
    const NotGreaterGreater = "≫̸";
    const NotGreaterLess = "≹";
    const NotGreaterSlantEqual = "⩾̸";
    const NotGreaterTilde = "≵";
    const NotHumpDownHump = "≎̸";
    const NotHumpEqual = "≏̸";
    const notin = "∉";
    const notindot = "⋵̸";
    const notinE = "⋹̸";
    const notinva = "∉";
    const notinvb = "⋷";
    const notinvc = "⋶";
    const NotLeftTriangleBar = "⧏̸";
    const NotLeftTriangle = "⋪";
    const NotLeftTriangleEqual = "⋬";
    const NotLess = "≮";
    const NotLessEqual = "≰";
    const NotLessGreater = "≸";
    const NotLessLess = "≪̸";
    const NotLessSlantEqual = "⩽̸";
    const NotLessTilde = "≴";
    const NotNestedGreaterGreater = "⪢̸";
    const NotNestedLessLess = "⪡̸";
    const notni = "∌";
    const notniva = "∌";
    const notnivb = "⋾";
    const notnivc = "⋽";
    const NotPrecedes = "⊀";
    const NotPrecedesEqual = "⪯̸";
    const NotPrecedesSlantEqual = "⋠";
    const NotReverseElement = "∌";
    const NotRightTriangleBar = "⧐̸";
    const NotRightTriangle = "⋫";
    const NotRightTriangleEqual = "⋭";
    const NotSquareSubset = "⊏̸";
    const NotSquareSubsetEqual = "⋢";
    const NotSquareSuperset = "⊐̸";
    const NotSquareSupersetEqual = "⋣";
    const NotSubset = "⊂⃒";
    const NotSubsetEqual = "⊈";
    const NotSucceeds = "⊁";
    const NotSucceedsEqual = "⪰̸";
    const NotSucceedsSlantEqual = "⋡";
    const NotSucceedsTilde = "≿̸";
    const NotSuperset = "⊃⃒";
    const NotSupersetEqual = "⊉";
    const NotTilde = "≁";
    const NotTildeEqual = "≄";
    const NotTildeFullEqual = "≇";
    const NotTildeTilde = "≉";
    const NotVerticalBar = "∤";
    const nparallel = "∦";
    const npar = "∦";
    const nparsl = "⫽⃥";
    const npart = "∂̸";
    const npolint = "⨔";
    const npr = "⊀";
    const nprcue = "⋠";
    const nprec = "⊀";
    const npreceq = "⪯̸";
    const npre = "⪯̸";
    const nrarrc = "⤳̸";
    const nrarr = "↛";
    const nrArr = "⇏";
    const nrarrw = "↝̸";
    const nrightarrow = "↛";
    const nRightarrow = "⇏";
    const nrtri = "⋫";
    const nrtrie = "⋭";
    const nsc = "⊁";
    const nsccue = "⋡";
    const nsce = "⪰̸";
    const Nscr = "𝒩";
    const nscr = "𝓃";
    const nshortmid = "∤";
    const nshortparallel = "∦";
    const nsim = "≁";
    const nsime = "≄";
    const nsimeq = "≄";
    const nsmid = "∤";
    const nspar = "∦";
    const nsqsube = "⋢";
    const nsqsupe = "⋣";
    const nsub = "⊄";
    const nsubE = "⫅̸";
    const nsube = "⊈";
    const nsubset = "⊂⃒";
    const nsubseteq = "⊈";
    const nsubseteqq = "⫅̸";
    const nsucc = "⊁";
    const nsucceq = "⪰̸";
    const nsup = "⊅";
    const nsupE = "⫆̸";
    const nsupe = "⊉";
    const nsupset = "⊃⃒";
    const nsupseteq = "⊉";
    const nsupseteqq = "⫆̸";
    const ntgl = "≹";
    const Ntilde = "Ñ";
    const ntilde = "ñ";
    const ntlg = "≸";
    const ntriangleleft = "⋪";
    const ntrianglelefteq = "⋬";
    const ntriangleright = "⋫";
    const ntrianglerighteq = "⋭";
    const Nu = "Ν";
    const nu = "ν";
    const num = "#";
    const numero = "№";
    const numsp = " ";
    const nvap = "≍⃒";
    const nvdash = "⊬";
    const nvDash = "⊭";
    const nVdash = "⊮";
    const nVDash = "⊯";
    const nvge = "≥⃒";
    const nvgt = ">⃒";
    const nvHarr = "⤄";
    const nvinfin = "⧞";
    const nvlArr = "⤂";
    const nvle = "≤⃒";
    const nvlt = "<⃒";
    const nvltrie = "⊴⃒";
    const nvrArr = "⤃";
    const nvrtrie = "⊵⃒";
    const nvsim = "∼⃒";
    const nwarhk = "⤣";
    const nwarr = "↖";
    const nwArr = "⇖";
    const nwarrow = "↖";
    const nwnear = "⤧";
    const Oacute = "Ó";
    const oacute = "ó";
    const oast = "⊛";
    const Ocirc = "Ô";
    const ocirc = "ô";
    const ocir = "⊚";
    const Ocy = "О";
    const ocy = "о";
    const odash = "⊝";
    const Odblac = "Ő";
    const odblac = "ő";
    const odiv = "⨸";
    const odot = "⊙";
    const odsold = "⦼";
    const OElig = "Œ";
    const oelig = "œ";
    const ofcir = "⦿";
    const Ofr = "𝔒";
    const ofr = "𝔬";
    const ogon = "˛";
    const Ograve = "Ò";
    const ograve = "ò";
    const ogt = "⧁";
    const ohbar = "⦵";
    const ohm = "Ω";
    const oint = "∮";
    const olarr = "↺";
    const olcir = "⦾";
    const olcross = "⦻";
    const oline = "‾";
    const olt = "⧀";
    const Omacr = "Ō";
    const omacr = "ō";
    const Omega = "Ω";
    const omega = "ω";
    const Omicron = "Ο";
    const omicron = "ο";
    const omid = "⦶";
    const ominus = "⊖";
    const Oopf = "𝕆";
    const oopf = "𝕠";
    const opar = "⦷";
    const OpenCurlyDoubleQuote = "“";
    const OpenCurlyQuote = "‘";
    const operp = "⦹";
    const oplus = "⊕";
    const orarr = "↻";
    const Or = "⩔";
    const or = "∨";
    const ord = "⩝";
    const order = "ℴ";
    const orderof = "ℴ";
    const ordf = "ª";
    const ordm = "º";
    const origof = "⊶";
    const oror = "⩖";
    const orslope = "⩗";
    const orv = "⩛";
    const oS = "Ⓢ";
    const Oscr = "𝒪";
    const oscr = "ℴ";
    const Oslash = "Ø";
    const oslash = "ø";
    const osol = "⊘";
    const Otilde = "Õ";
    const otilde = "õ";
    const otimesas = "⨶";
    const Otimes = "⨷";
    const otimes = "⊗";
    const Ouml = "Ö";
    const ouml = "ö";
    const ovbar = "⌽";
    const OverBar = "‾";
    const OverBrace = "⏞";
    const OverBracket = "⎴";
    const OverParenthesis = "⏜";
    const para = "¶";
    const parallel = "∥";
    const par = "∥";
    const parsim = "⫳";
    const parsl = "⫽";
    const part = "∂";
    const PartialD = "∂";
    const Pcy = "П";
    const pcy = "п";
    const percnt = "%";
    const period = ".";
    const permil = "‰";
    const perp = "⊥";
    const pertenk = "‱";
    const Pfr = "𝔓";
    const pfr = "𝔭";
    const Phi = "Φ";
    const phi = "φ";
    const phiv = "ϕ";
    const phmmat = "ℳ";
    const phone = "☎";
    const Pi = "Π";
    const pi = "π";
    const pitchfork = "⋔";
    const piv = "ϖ";
    const planck = "ℏ";
    const planckh = "ℎ";
    const plankv = "ℏ";
    const plusacir = "⨣";
    const plusb = "⊞";
    const pluscir = "⨢";
    const plus = "+";
    const plusdo = "∔";
    const plusdu = "⨥";
    const pluse = "⩲";
    const PlusMinus = "±";
    const plusmn = "±";
    const plussim = "⨦";
    const plustwo = "⨧";
    const pm = "±";
    const Poincareplane = "ℌ";
    const pointint = "⨕";
    const popf = "𝕡";
    const Popf = "ℙ";
    const pound = "£";
    const prap = "⪷";
    const Pr = "⪻";
    const pr = "≺";
    const prcue = "≼";
    const precapprox = "⪷";
    const prec = "≺";
    const preccurlyeq = "≼";
    const Precedes = "≺";
    const PrecedesEqual = "⪯";
    const PrecedesSlantEqual = "≼";
    const PrecedesTilde = "≾";
    const preceq = "⪯";
    const precnapprox = "⪹";
    const precneqq = "⪵";
    const precnsim = "⋨";
    const pre = "⪯";
    const prE = "⪳";
    const precsim = "≾";
    const prime = "′";
    const Prime = "″";
    const primes = "ℙ";
    const prnap = "⪹";
    const prnE = "⪵";
    const prnsim = "⋨";
    const prod = "∏";
    const Product = "∏";
    const profalar = "⌮";
    const profline = "⌒";
    const profsurf = "⌓";
    const prop = "∝";
    const Proportional = "∝";
    const Proportion = "∷";
    const propto = "∝";
    const prsim = "≾";
    const prurel = "⊰";
    const Pscr = "𝒫";
    const pscr = "𝓅";
    const Psi = "Ψ";
    const psi = "ψ";
    const puncsp = " ";
    const Qfr = "𝔔";
    const qfr = "𝔮";
    const qint = "⨌";
    const qopf = "𝕢";
    const Qopf = "ℚ";
    const qprime = "⁗";
    const Qscr = "𝒬";
    const qscr = "𝓆";
    const quaternions = "ℍ";
    const quatint = "⨖";
    const quest = "?";
    const questeq = "≟";
    const quot = '"';
    const QUOT = '"';
    const rAarr = "⇛";
    const race = "∽̱";
    const Racute = "Ŕ";
    const racute = "ŕ";
    const radic = "√";
    const raemptyv = "⦳";
    const rang = "⟩";
    const Rang = "⟫";
    const rangd = "⦒";
    const range = "⦥";
    const rangle = "⟩";
    const raquo = "»";
    const rarrap = "⥵";
    const rarrb = "⇥";
    const rarrbfs = "⤠";
    const rarrc = "⤳";
    const rarr = "→";
    const Rarr = "↠";
    const rArr = "⇒";
    const rarrfs = "⤞";
    const rarrhk = "↪";
    const rarrlp = "↬";
    const rarrpl = "⥅";
    const rarrsim = "⥴";
    const Rarrtl = "⤖";
    const rarrtl = "↣";
    const rarrw = "↝";
    const ratail = "⤚";
    const rAtail = "⤜";
    const ratio = "∶";
    const rationals = "ℚ";
    const rbarr = "⤍";
    const rBarr = "⤏";
    const RBarr = "⤐";
    const rbbrk = "❳";
    const rbrace = "}";
    const rbrack = "]";
    const rbrke = "⦌";
    const rbrksld = "⦎";
    const rbrkslu = "⦐";
    const Rcaron = "Ř";
    const rcaron = "ř";
    const Rcedil = "Ŗ";
    const rcedil = "ŗ";
    const rceil = "⌉";
    const rcub = "}";
    const Rcy = "Р";
    const rcy = "р";
    const rdca = "⤷";
    const rdldhar = "⥩";
    const rdquo = "”";
    const rdquor = "”";
    const rdsh = "↳";
    const real = "ℜ";
    const realine = "ℛ";
    const realpart = "ℜ";
    const reals = "ℝ";
    const Re = "ℜ";
    const rect = "▭";
    const reg = "®";
    const REG = "®";
    const ReverseElement = "∋";
    const ReverseEquilibrium = "⇋";
    const ReverseUpEquilibrium = "⥯";
    const rfisht = "⥽";
    const rfloor = "⌋";
    const rfr = "𝔯";
    const Rfr = "ℜ";
    const rHar = "⥤";
    const rhard = "⇁";
    const rharu = "⇀";
    const rharul = "⥬";
    const Rho = "Ρ";
    const rho = "ρ";
    const rhov = "ϱ";
    const RightAngleBracket = "⟩";
    const RightArrowBar = "⇥";
    const rightarrow = "→";
    const RightArrow = "→";
    const Rightarrow = "⇒";
    const RightArrowLeftArrow = "⇄";
    const rightarrowtail = "↣";
    const RightCeiling = "⌉";
    const RightDoubleBracket = "⟧";
    const RightDownTeeVector = "⥝";
    const RightDownVectorBar = "⥕";
    const RightDownVector = "⇂";
    const RightFloor = "⌋";
    const rightharpoondown = "⇁";
    const rightharpoonup = "⇀";
    const rightleftarrows = "⇄";
    const rightleftharpoons = "⇌";
    const rightrightarrows = "⇉";
    const rightsquigarrow = "↝";
    const RightTeeArrow = "↦";
    const RightTee = "⊢";
    const RightTeeVector = "⥛";
    const rightthreetimes = "⋌";
    const RightTriangleBar = "⧐";
    const RightTriangle = "⊳";
    const RightTriangleEqual = "⊵";
    const RightUpDownVector = "⥏";
    const RightUpTeeVector = "⥜";
    const RightUpVectorBar = "⥔";
    const RightUpVector = "↾";
    const RightVectorBar = "⥓";
    const RightVector = "⇀";
    const ring = "˚";
    const risingdotseq = "≓";
    const rlarr = "⇄";
    const rlhar = "⇌";
    const rlm = "‏";
    const rmoustache = "⎱";
    const rmoust = "⎱";
    const rnmid = "⫮";
    const roang = "⟭";
    const roarr = "⇾";
    const robrk = "⟧";
    const ropar = "⦆";
    const ropf = "𝕣";
    const Ropf = "ℝ";
    const roplus = "⨮";
    const rotimes = "⨵";
    const RoundImplies = "⥰";
    const rpar = ")";
    const rpargt = "⦔";
    const rppolint = "⨒";
    const rrarr = "⇉";
    const Rrightarrow = "⇛";
    const rsaquo = "›";
    const rscr = "𝓇";
    const Rscr = "ℛ";
    const rsh = "↱";
    const Rsh = "↱";
    const rsqb = "]";
    const rsquo = "’";
    const rsquor = "’";
    const rthree = "⋌";
    const rtimes = "⋊";
    const rtri = "▹";
    const rtrie = "⊵";
    const rtrif = "▸";
    const rtriltri = "⧎";
    const RuleDelayed = "⧴";
    const ruluhar = "⥨";
    const rx = "℞";
    const Sacute = "Ś";
    const sacute = "ś";
    const sbquo = "‚";
    const scap = "⪸";
    const Scaron = "Š";
    const scaron = "š";
    const Sc = "⪼";
    const sc = "≻";
    const sccue = "≽";
    const sce = "⪰";
    const scE = "⪴";
    const Scedil = "Ş";
    const scedil = "ş";
    const Scirc = "Ŝ";
    const scirc = "ŝ";
    const scnap = "⪺";
    const scnE = "⪶";
    const scnsim = "⋩";
    const scpolint = "⨓";
    const scsim = "≿";
    const Scy = "С";
    const scy = "с";
    const sdotb = "⊡";
    const sdot = "⋅";
    const sdote = "⩦";
    const searhk = "⤥";
    const searr = "↘";
    const seArr = "⇘";
    const searrow = "↘";
    const sect = "§";
    const semi = ";";
    const seswar = "⤩";
    const setminus = "∖";
    const setmn = "∖";
    const sext = "✶";
    const Sfr = "𝔖";
    const sfr = "𝔰";
    const sfrown = "⌢";
    const sharp = "♯";
    const SHCHcy = "Щ";
    const shchcy = "щ";
    const SHcy = "Ш";
    const shcy = "ш";
    const ShortDownArrow = "↓";
    const ShortLeftArrow = "←";
    const shortmid = "∣";
    const shortparallel = "∥";
    const ShortRightArrow = "→";
    const ShortUpArrow = "↑";
    const shy = "­";
    const Sigma = "Σ";
    const sigma = "σ";
    const sigmaf = "ς";
    const sigmav = "ς";
    const sim = "∼";
    const simdot = "⩪";
    const sime = "≃";
    const simeq = "≃";
    const simg = "⪞";
    const simgE = "⪠";
    const siml = "⪝";
    const simlE = "⪟";
    const simne = "≆";
    const simplus = "⨤";
    const simrarr = "⥲";
    const slarr = "←";
    const SmallCircle = "∘";
    const smallsetminus = "∖";
    const smashp = "⨳";
    const smeparsl = "⧤";
    const smid = "∣";
    const smile = "⌣";
    const smt = "⪪";
    const smte = "⪬";
    const smtes = "⪬︀";
    const SOFTcy = "Ь";
    const softcy = "ь";
    const solbar = "⌿";
    const solb = "⧄";
    const sol = "/";
    const Sopf = "𝕊";
    const sopf = "𝕤";
    const spades = "♠";
    const spadesuit = "♠";
    const spar = "∥";
    const sqcap = "⊓";
    const sqcaps = "⊓︀";
    const sqcup = "⊔";
    const sqcups = "⊔︀";
    const Sqrt = "√";
    const sqsub = "⊏";
    const sqsube = "⊑";
    const sqsubset = "⊏";
    const sqsubseteq = "⊑";
    const sqsup = "⊐";
    const sqsupe = "⊒";
    const sqsupset = "⊐";
    const sqsupseteq = "⊒";
    const square = "□";
    const Square = "□";
    const SquareIntersection = "⊓";
    const SquareSubset = "⊏";
    const SquareSubsetEqual = "⊑";
    const SquareSuperset = "⊐";
    const SquareSupersetEqual = "⊒";
    const SquareUnion = "⊔";
    const squarf = "▪";
    const squ = "□";
    const squf = "▪";
    const srarr = "→";
    const Sscr = "𝒮";
    const sscr = "𝓈";
    const ssetmn = "∖";
    const ssmile = "⌣";
    const sstarf = "⋆";
    const Star = "⋆";
    const star = "☆";
    const starf = "★";
    const straightepsilon = "ϵ";
    const straightphi = "ϕ";
    const strns = "¯";
    const sub = "⊂";
    const Sub = "⋐";
    const subdot = "⪽";
    const subE = "⫅";
    const sube = "⊆";
    const subedot = "⫃";
    const submult = "⫁";
    const subnE = "⫋";
    const subne = "⊊";
    const subplus = "⪿";
    const subrarr = "⥹";
    const subset = "⊂";
    const Subset = "⋐";
    const subseteq = "⊆";
    const subseteqq = "⫅";
    const SubsetEqual = "⊆";
    const subsetneq = "⊊";
    const subsetneqq = "⫋";
    const subsim = "⫇";
    const subsub = "⫕";
    const subsup = "⫓";
    const succapprox = "⪸";
    const succ = "≻";
    const succcurlyeq = "≽";
    const Succeeds = "≻";
    const SucceedsEqual = "⪰";
    const SucceedsSlantEqual = "≽";
    const SucceedsTilde = "≿";
    const succeq = "⪰";
    const succnapprox = "⪺";
    const succneqq = "⪶";
    const succnsim = "⋩";
    const succsim = "≿";
    const SuchThat = "∋";
    const sum = "∑";
    const Sum = "∑";
    const sung = "♪";
    const sup1 = "¹";
    const sup2 = "²";
    const sup3 = "³";
    const sup = "⊃";
    const Sup = "⋑";
    const supdot = "⪾";
    const supdsub = "⫘";
    const supE = "⫆";
    const supe = "⊇";
    const supedot = "⫄";
    const Superset = "⊃";
    const SupersetEqual = "⊇";
    const suphsol = "⟉";
    const suphsub = "⫗";
    const suplarr = "⥻";
    const supmult = "⫂";
    const supnE = "⫌";
    const supne = "⊋";
    const supplus = "⫀";
    const supset = "⊃";
    const Supset = "⋑";
    const supseteq = "⊇";
    const supseteqq = "⫆";
    const supsetneq = "⊋";
    const supsetneqq = "⫌";
    const supsim = "⫈";
    const supsub = "⫔";
    const supsup = "⫖";
    const swarhk = "⤦";
    const swarr = "↙";
    const swArr = "⇙";
    const swarrow = "↙";
    const swnwar = "⤪";
    const szlig = "ß";
    const Tab = "	";
    const target = "⌖";
    const Tau = "Τ";
    const tau = "τ";
    const tbrk = "⎴";
    const Tcaron = "Ť";
    const tcaron = "ť";
    const Tcedil = "Ţ";
    const tcedil = "ţ";
    const Tcy = "Т";
    const tcy = "т";
    const tdot = "⃛";
    const telrec = "⌕";
    const Tfr = "𝔗";
    const tfr = "𝔱";
    const there4 = "∴";
    const therefore = "∴";
    const Therefore = "∴";
    const Theta = "Θ";
    const theta = "θ";
    const thetasym = "ϑ";
    const thetav = "ϑ";
    const thickapprox = "≈";
    const thicksim = "∼";
    const ThickSpace = "  ";
    const ThinSpace = " ";
    const thinsp = " ";
    const thkap = "≈";
    const thksim = "∼";
    const THORN = "Þ";
    const thorn = "þ";
    const tilde = "˜";
    const Tilde = "∼";
    const TildeEqual = "≃";
    const TildeFullEqual = "≅";
    const TildeTilde = "≈";
    const timesbar = "⨱";
    const timesb = "⊠";
    const times = "×";
    const timesd = "⨰";
    const tint = "∭";
    const toea = "⤨";
    const topbot = "⌶";
    const topcir = "⫱";
    const top = "⊤";
    const Topf = "𝕋";
    const topf = "𝕥";
    const topfork = "⫚";
    const tosa = "⤩";
    const tprime = "‴";
    const trade = "™";
    const TRADE = "™";
    const triangle = "▵";
    const triangledown = "▿";
    const triangleleft = "◃";
    const trianglelefteq = "⊴";
    const triangleq = "≜";
    const triangleright = "▹";
    const trianglerighteq = "⊵";
    const tridot = "◬";
    const trie = "≜";
    const triminus = "⨺";
    const TripleDot = "⃛";
    const triplus = "⨹";
    const trisb = "⧍";
    const tritime = "⨻";
    const trpezium = "⏢";
    const Tscr = "𝒯";
    const tscr = "𝓉";
    const TScy = "Ц";
    const tscy = "ц";
    const TSHcy = "Ћ";
    const tshcy = "ћ";
    const Tstrok = "Ŧ";
    const tstrok = "ŧ";
    const twixt = "≬";
    const twoheadleftarrow = "↞";
    const twoheadrightarrow = "↠";
    const Uacute = "Ú";
    const uacute = "ú";
    const uarr = "↑";
    const Uarr = "↟";
    const uArr = "⇑";
    const Uarrocir = "⥉";
    const Ubrcy = "Ў";
    const ubrcy = "ў";
    const Ubreve = "Ŭ";
    const ubreve = "ŭ";
    const Ucirc = "Û";
    const ucirc = "û";
    const Ucy = "У";
    const ucy = "у";
    const udarr = "⇅";
    const Udblac = "Ű";
    const udblac = "ű";
    const udhar = "⥮";
    const ufisht = "⥾";
    const Ufr = "𝔘";
    const ufr = "𝔲";
    const Ugrave = "Ù";
    const ugrave = "ù";
    const uHar = "⥣";
    const uharl = "↿";
    const uharr = "↾";
    const uhblk = "▀";
    const ulcorn = "⌜";
    const ulcorner = "⌜";
    const ulcrop = "⌏";
    const ultri = "◸";
    const Umacr = "Ū";
    const umacr = "ū";
    const uml = "¨";
    const UnderBar = "_";
    const UnderBrace = "⏟";
    const UnderBracket = "⎵";
    const UnderParenthesis = "⏝";
    const Union = "⋃";
    const UnionPlus = "⊎";
    const Uogon = "Ų";
    const uogon = "ų";
    const Uopf = "𝕌";
    const uopf = "𝕦";
    const UpArrowBar = "⤒";
    const uparrow = "↑";
    const UpArrow = "↑";
    const Uparrow = "⇑";
    const UpArrowDownArrow = "⇅";
    const updownarrow = "↕";
    const UpDownArrow = "↕";
    const Updownarrow = "⇕";
    const UpEquilibrium = "⥮";
    const upharpoonleft = "↿";
    const upharpoonright = "↾";
    const uplus = "⊎";
    const UpperLeftArrow = "↖";
    const UpperRightArrow = "↗";
    const upsi = "υ";
    const Upsi = "ϒ";
    const upsih = "ϒ";
    const Upsilon = "Υ";
    const upsilon = "υ";
    const UpTeeArrow = "↥";
    const UpTee = "⊥";
    const upuparrows = "⇈";
    const urcorn = "⌝";
    const urcorner = "⌝";
    const urcrop = "⌎";
    const Uring = "Ů";
    const uring = "ů";
    const urtri = "◹";
    const Uscr = "𝒰";
    const uscr = "𝓊";
    const utdot = "⋰";
    const Utilde = "Ũ";
    const utilde = "ũ";
    const utri = "▵";
    const utrif = "▴";
    const uuarr = "⇈";
    const Uuml = "Ü";
    const uuml = "ü";
    const uwangle = "⦧";
    const vangrt = "⦜";
    const varepsilon = "ϵ";
    const varkappa = "ϰ";
    const varnothing = "∅";
    const varphi = "ϕ";
    const varpi = "ϖ";
    const varpropto = "∝";
    const varr = "↕";
    const vArr = "⇕";
    const varrho = "ϱ";
    const varsigma = "ς";
    const varsubsetneq = "⊊︀";
    const varsubsetneqq = "⫋︀";
    const varsupsetneq = "⊋︀";
    const varsupsetneqq = "⫌︀";
    const vartheta = "ϑ";
    const vartriangleleft = "⊲";
    const vartriangleright = "⊳";
    const vBar = "⫨";
    const Vbar = "⫫";
    const vBarv = "⫩";
    const Vcy = "В";
    const vcy = "в";
    const vdash = "⊢";
    const vDash = "⊨";
    const Vdash = "⊩";
    const VDash = "⊫";
    const Vdashl = "⫦";
    const veebar = "⊻";
    const vee = "∨";
    const Vee = "⋁";
    const veeeq = "≚";
    const vellip = "⋮";
    const verbar = "|";
    const Verbar = "‖";
    const vert = "|";
    const Vert = "‖";
    const VerticalBar = "∣";
    const VerticalLine = "|";
    const VerticalSeparator = "❘";
    const VerticalTilde = "≀";
    const VeryThinSpace = " ";
    const Vfr = "𝔙";
    const vfr = "𝔳";
    const vltri = "⊲";
    const vnsub = "⊂⃒";
    const vnsup = "⊃⃒";
    const Vopf = "𝕍";
    const vopf = "𝕧";
    const vprop = "∝";
    const vrtri = "⊳";
    const Vscr = "𝒱";
    const vscr = "𝓋";
    const vsubnE = "⫋︀";
    const vsubne = "⊊︀";
    const vsupnE = "⫌︀";
    const vsupne = "⊋︀";
    const Vvdash = "⊪";
    const vzigzag = "⦚";
    const Wcirc = "Ŵ";
    const wcirc = "ŵ";
    const wedbar = "⩟";
    const wedge = "∧";
    const Wedge = "⋀";
    const wedgeq = "≙";
    const weierp = "℘";
    const Wfr = "𝔚";
    const wfr = "𝔴";
    const Wopf = "𝕎";
    const wopf = "𝕨";
    const wp = "℘";
    const wr = "≀";
    const wreath = "≀";
    const Wscr = "𝒲";
    const wscr = "𝓌";
    const xcap = "⋂";
    const xcirc = "◯";
    const xcup = "⋃";
    const xdtri = "▽";
    const Xfr = "𝔛";
    const xfr = "𝔵";
    const xharr = "⟷";
    const xhArr = "⟺";
    const Xi = "Ξ";
    const xi = "ξ";
    const xlarr = "⟵";
    const xlArr = "⟸";
    const xmap = "⟼";
    const xnis = "⋻";
    const xodot = "⨀";
    const Xopf = "𝕏";
    const xopf = "𝕩";
    const xoplus = "⨁";
    const xotime = "⨂";
    const xrarr = "⟶";
    const xrArr = "⟹";
    const Xscr = "𝒳";
    const xscr = "𝓍";
    const xsqcup = "⨆";
    const xuplus = "⨄";
    const xutri = "△";
    const xvee = "⋁";
    const xwedge = "⋀";
    const Yacute = "Ý";
    const yacute = "ý";
    const YAcy = "Я";
    const yacy = "я";
    const Ycirc = "Ŷ";
    const ycirc = "ŷ";
    const Ycy = "Ы";
    const ycy = "ы";
    const yen = "¥";
    const Yfr = "𝔜";
    const yfr = "𝔶";
    const YIcy = "Ї";
    const yicy = "ї";
    const Yopf = "𝕐";
    const yopf = "𝕪";
    const Yscr = "𝒴";
    const yscr = "𝓎";
    const YUcy = "Ю";
    const yucy = "ю";
    const yuml = "ÿ";
    const Yuml = "Ÿ";
    const Zacute = "Ź";
    const zacute = "ź";
    const Zcaron = "Ž";
    const zcaron = "ž";
    const Zcy = "З";
    const zcy = "з";
    const Zdot = "Ż";
    const zdot = "ż";
    const zeetrf = "ℨ";
    const ZeroWidthSpace = "​";
    const Zeta = "Ζ";
    const zeta = "ζ";
    const zfr = "𝔷";
    const Zfr = "ℨ";
    const ZHcy = "Ж";
    const zhcy = "ж";
    const zigrarr = "⇝";
    const zopf = "𝕫";
    const Zopf = "ℤ";
    const Zscr = "𝒵";
    const zscr = "𝓏";
    const zwj = "‍";
    const zwnj = "‌";
    const require$$0 = {
      Aacute,
      aacute,
      Abreve,
      abreve,
      ac,
      acd,
      acE,
      Acirc,
      acirc,
      acute,
      Acy,
      acy,
      AElig,
      aelig,
      af,
      Afr,
      afr,
      Agrave,
      agrave,
      alefsym,
      aleph,
      Alpha,
      alpha,
      Amacr,
      amacr,
      amalg,
      amp,
      AMP,
      andand,
      And,
      and,
      andd,
      andslope,
      andv,
      ang,
      ange,
      angle,
      angmsdaa,
      angmsdab,
      angmsdac,
      angmsdad,
      angmsdae,
      angmsdaf,
      angmsdag,
      angmsdah,
      angmsd,
      angrt,
      angrtvb,
      angrtvbd,
      angsph,
      angst,
      angzarr,
      Aogon,
      aogon,
      Aopf,
      aopf,
      apacir,
      ap,
      apE,
      ape,
      apid,
      apos,
      ApplyFunction,
      approx,
      approxeq,
      Aring,
      aring,
      Ascr,
      ascr,
      Assign,
      ast,
      asymp,
      asympeq,
      Atilde,
      atilde,
      Auml,
      auml,
      awconint,
      awint,
      backcong,
      backepsilon,
      backprime,
      backsim,
      backsimeq,
      Backslash,
      Barv,
      barvee,
      barwed,
      Barwed,
      barwedge,
      bbrk,
      bbrktbrk,
      bcong,
      Bcy,
      bcy,
      bdquo,
      becaus,
      because,
      Because,
      bemptyv,
      bepsi,
      bernou,
      Bernoullis,
      Beta,
      beta,
      beth,
      between,
      Bfr,
      bfr,
      bigcap,
      bigcirc,
      bigcup,
      bigodot,
      bigoplus,
      bigotimes,
      bigsqcup,
      bigstar,
      bigtriangledown,
      bigtriangleup,
      biguplus,
      bigvee,
      bigwedge,
      bkarow,
      blacklozenge,
      blacksquare,
      blacktriangle,
      blacktriangledown,
      blacktriangleleft,
      blacktriangleright,
      blank,
      blk12,
      blk14,
      blk34,
      block: block$1,
      bne,
      bnequiv,
      bNot,
      bnot,
      Bopf,
      bopf,
      bot,
      bottom,
      bowtie,
      boxbox,
      boxdl,
      boxdL,
      boxDl,
      boxDL,
      boxdr,
      boxdR,
      boxDr,
      boxDR,
      boxh,
      boxH,
      boxhd,
      boxHd,
      boxhD,
      boxHD,
      boxhu,
      boxHu,
      boxhU,
      boxHU,
      boxminus,
      boxplus,
      boxtimes,
      boxul,
      boxuL,
      boxUl,
      boxUL,
      boxur,
      boxuR,
      boxUr,
      boxUR,
      boxv,
      boxV,
      boxvh,
      boxvH,
      boxVh,
      boxVH,
      boxvl,
      boxvL,
      boxVl,
      boxVL,
      boxvr,
      boxvR,
      boxVr,
      boxVR,
      bprime,
      breve,
      Breve,
      brvbar,
      bscr,
      Bscr,
      bsemi,
      bsim,
      bsime,
      bsolb,
      bsol,
      bsolhsub,
      bull,
      bullet,
      bump,
      bumpE,
      bumpe,
      Bumpeq,
      bumpeq,
      Cacute,
      cacute,
      capand,
      capbrcup,
      capcap,
      cap,
      Cap,
      capcup,
      capdot,
      CapitalDifferentialD,
      caps,
      caret,
      caron,
      Cayleys,
      ccaps,
      Ccaron,
      ccaron,
      Ccedil,
      ccedil,
      Ccirc,
      ccirc,
      Cconint,
      ccups,
      ccupssm,
      Cdot,
      cdot,
      cedil,
      Cedilla,
      cemptyv,
      cent,
      centerdot,
      CenterDot,
      cfr,
      Cfr,
      CHcy,
      chcy,
      check,
      checkmark,
      Chi,
      chi,
      circ,
      circeq,
      circlearrowleft,
      circlearrowright,
      circledast,
      circledcirc,
      circleddash,
      CircleDot,
      circledR,
      circledS,
      CircleMinus,
      CirclePlus,
      CircleTimes,
      cir,
      cirE,
      cire,
      cirfnint,
      cirmid,
      cirscir,
      ClockwiseContourIntegral,
      CloseCurlyDoubleQuote,
      CloseCurlyQuote,
      clubs,
      clubsuit,
      colon,
      Colon,
      Colone,
      colone,
      coloneq,
      comma,
      commat,
      comp,
      compfn,
      complement,
      complexes,
      cong,
      congdot,
      Congruent,
      conint,
      Conint,
      ContourIntegral,
      copf,
      Copf,
      coprod,
      Coproduct,
      copy,
      COPY,
      copysr,
      CounterClockwiseContourIntegral,
      crarr,
      cross,
      Cross,
      Cscr,
      cscr,
      csub,
      csube,
      csup,
      csupe,
      ctdot,
      cudarrl,
      cudarrr,
      cuepr,
      cuesc,
      cularr,
      cularrp,
      cupbrcap,
      cupcap,
      CupCap,
      cup,
      Cup,
      cupcup,
      cupdot,
      cupor,
      cups,
      curarr,
      curarrm,
      curlyeqprec,
      curlyeqsucc,
      curlyvee,
      curlywedge,
      curren,
      curvearrowleft,
      curvearrowright,
      cuvee,
      cuwed,
      cwconint,
      cwint,
      cylcty,
      dagger,
      Dagger,
      daleth,
      darr,
      Darr,
      dArr,
      dash,
      Dashv,
      dashv,
      dbkarow,
      dblac,
      Dcaron,
      dcaron,
      Dcy,
      dcy,
      ddagger,
      ddarr,
      DD,
      dd,
      DDotrahd,
      ddotseq,
      deg,
      Del,
      Delta,
      delta,
      demptyv,
      dfisht,
      Dfr,
      dfr,
      dHar,
      dharl,
      dharr,
      DiacriticalAcute,
      DiacriticalDot,
      DiacriticalDoubleAcute,
      DiacriticalGrave,
      DiacriticalTilde,
      diam,
      diamond,
      Diamond,
      diamondsuit,
      diams,
      die: die$1,
      DifferentialD,
      digamma,
      disin,
      div,
      divide,
      divideontimes,
      divonx,
      DJcy,
      djcy,
      dlcorn,
      dlcrop,
      dollar,
      Dopf,
      dopf,
      Dot,
      dot,
      DotDot,
      doteq,
      doteqdot,
      DotEqual,
      dotminus,
      dotplus,
      dotsquare,
      doublebarwedge,
      DoubleContourIntegral,
      DoubleDot,
      DoubleDownArrow,
      DoubleLeftArrow,
      DoubleLeftRightArrow,
      DoubleLeftTee,
      DoubleLongLeftArrow,
      DoubleLongLeftRightArrow,
      DoubleLongRightArrow,
      DoubleRightArrow,
      DoubleRightTee,
      DoubleUpArrow,
      DoubleUpDownArrow,
      DoubleVerticalBar,
      DownArrowBar,
      downarrow,
      DownArrow,
      Downarrow,
      DownArrowUpArrow,
      DownBreve,
      downdownarrows,
      downharpoonleft,
      downharpoonright,
      DownLeftRightVector,
      DownLeftTeeVector,
      DownLeftVectorBar,
      DownLeftVector,
      DownRightTeeVector,
      DownRightVectorBar,
      DownRightVector,
      DownTeeArrow,
      DownTee,
      drbkarow,
      drcorn,
      drcrop,
      Dscr,
      dscr,
      DScy,
      dscy,
      dsol,
      Dstrok,
      dstrok,
      dtdot,
      dtri,
      dtrif,
      duarr,
      duhar,
      dwangle,
      DZcy,
      dzcy,
      dzigrarr,
      Eacute,
      eacute,
      easter,
      Ecaron,
      ecaron,
      Ecirc,
      ecirc,
      ecir,
      ecolon,
      Ecy,
      ecy,
      eDDot,
      Edot,
      edot,
      eDot,
      ee,
      efDot,
      Efr,
      efr,
      eg,
      Egrave,
      egrave,
      egs,
      egsdot,
      el,
      Element: Element$1,
      elinters,
      ell,
      els,
      elsdot,
      Emacr,
      emacr,
      empty,
      emptyset,
      EmptySmallSquare,
      emptyv,
      EmptyVerySmallSquare,
      emsp13,
      emsp14,
      emsp,
      ENG,
      eng,
      ensp,
      Eogon,
      eogon,
      Eopf,
      eopf,
      epar,
      eparsl,
      eplus,
      epsi,
      Epsilon,
      epsilon,
      epsiv,
      eqcirc,
      eqcolon,
      eqsim,
      eqslantgtr,
      eqslantless,
      Equal,
      equals,
      EqualTilde,
      equest,
      Equilibrium,
      equiv,
      equivDD,
      eqvparsl,
      erarr,
      erDot,
      escr,
      Escr,
      esdot,
      Esim,
      esim,
      Eta,
      eta,
      ETH,
      eth,
      Euml,
      euml,
      euro,
      excl,
      exist,
      Exists,
      expectation,
      exponentiale,
      ExponentialE,
      fallingdotseq,
      Fcy,
      fcy,
      female,
      ffilig,
      fflig,
      ffllig,
      Ffr,
      ffr,
      filig,
      FilledSmallSquare,
      FilledVerySmallSquare,
      fjlig,
      flat,
      fllig,
      fltns,
      fnof,
      Fopf,
      fopf,
      forall,
      ForAll,
      fork,
      forkv,
      Fouriertrf,
      fpartint,
      frac12,
      frac13,
      frac14,
      frac15,
      frac16,
      frac18,
      frac23,
      frac25,
      frac34,
      frac35,
      frac38,
      frac45,
      frac56,
      frac58,
      frac78,
      frasl,
      frown,
      fscr,
      Fscr,
      gacute,
      Gamma,
      gamma,
      Gammad,
      gammad,
      gap,
      Gbreve,
      gbreve,
      Gcedil,
      Gcirc,
      gcirc,
      Gcy,
      gcy,
      Gdot,
      gdot,
      ge,
      gE,
      gEl,
      gel,
      geq,
      geqq,
      geqslant,
      gescc,
      ges,
      gesdot,
      gesdoto,
      gesdotol,
      gesl,
      gesles,
      Gfr,
      gfr,
      gg,
      Gg,
      ggg,
      gimel,
      GJcy,
      gjcy,
      gla,
      gl,
      glE,
      glj,
      gnap,
      gnapprox,
      gne,
      gnE,
      gneq,
      gneqq,
      gnsim,
      Gopf,
      gopf,
      grave,
      GreaterEqual,
      GreaterEqualLess,
      GreaterFullEqual,
      GreaterGreater,
      GreaterLess,
      GreaterSlantEqual,
      GreaterTilde,
      Gscr,
      gscr,
      gsim,
      gsime,
      gsiml,
      gtcc,
      gtcir,
      gt,
      GT,
      Gt,
      gtdot,
      gtlPar,
      gtquest,
      gtrapprox,
      gtrarr,
      gtrdot,
      gtreqless,
      gtreqqless,
      gtrless,
      gtrsim,
      gvertneqq,
      gvnE,
      Hacek,
      hairsp,
      half,
      hamilt,
      HARDcy,
      hardcy,
      harrcir,
      harr,
      hArr,
      harrw,
      Hat,
      hbar,
      Hcirc,
      hcirc,
      hearts,
      heartsuit,
      hellip,
      hercon,
      hfr,
      Hfr,
      HilbertSpace,
      hksearow,
      hkswarow,
      hoarr,
      homtht,
      hookleftarrow,
      hookrightarrow,
      hopf,
      Hopf,
      horbar,
      HorizontalLine,
      hscr,
      Hscr,
      hslash,
      Hstrok,
      hstrok,
      HumpDownHump,
      HumpEqual,
      hybull,
      hyphen,
      Iacute,
      iacute,
      ic,
      Icirc,
      icirc,
      Icy,
      icy,
      Idot,
      IEcy,
      iecy,
      iexcl,
      iff,
      ifr,
      Ifr,
      Igrave,
      igrave,
      ii,
      iiiint,
      iiint,
      iinfin,
      iiota,
      IJlig,
      ijlig,
      Imacr,
      imacr,
      image: image$1,
      ImaginaryI,
      imagline,
      imagpart,
      imath,
      Im,
      imof,
      imped,
      Implies,
      incare,
      "in": "∈",
      infin,
      infintie,
      inodot,
      intcal,
      int,
      Int,
      integers,
      Integral,
      intercal,
      Intersection,
      intlarhk,
      intprod,
      InvisibleComma,
      InvisibleTimes,
      IOcy,
      iocy,
      Iogon,
      iogon,
      Iopf,
      iopf,
      Iota,
      iota,
      iprod,
      iquest,
      iscr,
      Iscr,
      isin,
      isindot,
      isinE,
      isins,
      isinsv,
      isinv,
      it,
      Itilde,
      itilde,
      Iukcy,
      iukcy,
      Iuml,
      iuml,
      Jcirc,
      jcirc,
      Jcy,
      jcy,
      Jfr,
      jfr,
      jmath,
      Jopf,
      jopf,
      Jscr,
      jscr,
      Jsercy,
      jsercy,
      Jukcy,
      jukcy,
      Kappa,
      kappa,
      kappav,
      Kcedil,
      kcedil,
      Kcy,
      kcy,
      Kfr,
      kfr,
      kgreen,
      KHcy,
      khcy,
      KJcy,
      kjcy,
      Kopf,
      kopf,
      Kscr,
      kscr,
      lAarr,
      Lacute,
      lacute,
      laemptyv,
      lagran,
      Lambda,
      lambda,
      lang,
      Lang,
      langd,
      langle,
      lap,
      Laplacetrf,
      laquo,
      larrb,
      larrbfs,
      larr,
      Larr,
      lArr,
      larrfs,
      larrhk,
      larrlp,
      larrpl,
      larrsim,
      larrtl,
      latail,
      lAtail,
      lat,
      late,
      lates,
      lbarr,
      lBarr,
      lbbrk,
      lbrace,
      lbrack,
      lbrke,
      lbrksld,
      lbrkslu,
      Lcaron,
      lcaron,
      Lcedil,
      lcedil,
      lceil,
      lcub,
      Lcy,
      lcy,
      ldca,
      ldquo,
      ldquor,
      ldrdhar,
      ldrushar,
      ldsh,
      le,
      lE,
      LeftAngleBracket,
      LeftArrowBar,
      leftarrow,
      LeftArrow,
      Leftarrow,
      LeftArrowRightArrow,
      leftarrowtail,
      LeftCeiling,
      LeftDoubleBracket,
      LeftDownTeeVector,
      LeftDownVectorBar,
      LeftDownVector,
      LeftFloor,
      leftharpoondown,
      leftharpoonup,
      leftleftarrows,
      leftrightarrow,
      LeftRightArrow,
      Leftrightarrow,
      leftrightarrows,
      leftrightharpoons,
      leftrightsquigarrow,
      LeftRightVector,
      LeftTeeArrow,
      LeftTee,
      LeftTeeVector,
      leftthreetimes,
      LeftTriangleBar,
      LeftTriangle,
      LeftTriangleEqual,
      LeftUpDownVector,
      LeftUpTeeVector,
      LeftUpVectorBar,
      LeftUpVector,
      LeftVectorBar,
      LeftVector,
      lEg,
      leg,
      leq,
      leqq,
      leqslant,
      lescc,
      les,
      lesdot,
      lesdoto,
      lesdotor,
      lesg,
      lesges,
      lessapprox,
      lessdot,
      lesseqgtr,
      lesseqqgtr,
      LessEqualGreater,
      LessFullEqual,
      LessGreater,
      lessgtr,
      LessLess,
      lesssim,
      LessSlantEqual,
      LessTilde,
      lfisht,
      lfloor,
      Lfr,
      lfr,
      lg,
      lgE,
      lHar,
      lhard,
      lharu,
      lharul,
      lhblk,
      LJcy,
      ljcy,
      llarr,
      ll,
      Ll,
      llcorner,
      Lleftarrow,
      llhard,
      lltri,
      Lmidot,
      lmidot,
      lmoustache,
      lmoust,
      lnap,
      lnapprox,
      lne,
      lnE,
      lneq,
      lneqq,
      lnsim,
      loang,
      loarr,
      lobrk,
      longleftarrow,
      LongLeftArrow,
      Longleftarrow,
      longleftrightarrow,
      LongLeftRightArrow,
      Longleftrightarrow,
      longmapsto,
      longrightarrow,
      LongRightArrow,
      Longrightarrow,
      looparrowleft,
      looparrowright,
      lopar,
      Lopf,
      lopf,
      loplus,
      lotimes,
      lowast,
      lowbar,
      LowerLeftArrow,
      LowerRightArrow,
      loz,
      lozenge,
      lozf,
      lpar,
      lparlt,
      lrarr,
      lrcorner,
      lrhar,
      lrhard,
      lrm,
      lrtri,
      lsaquo,
      lscr,
      Lscr,
      lsh,
      Lsh,
      lsim,
      lsime,
      lsimg,
      lsqb,
      lsquo,
      lsquor,
      Lstrok,
      lstrok,
      ltcc,
      ltcir,
      lt,
      LT,
      Lt,
      ltdot,
      lthree,
      ltimes,
      ltlarr,
      ltquest,
      ltri,
      ltrie,
      ltrif,
      ltrPar,
      lurdshar,
      luruhar,
      lvertneqq,
      lvnE,
      macr,
      male,
      malt,
      maltese,
      "Map": "⤅",
      map: map$1,
      mapsto,
      mapstodown,
      mapstoleft,
      mapstoup,
      marker,
      mcomma,
      Mcy,
      mcy,
      mdash,
      mDDot,
      measuredangle,
      MediumSpace,
      Mellintrf,
      Mfr,
      mfr,
      mho,
      micro,
      midast,
      midcir,
      mid,
      middot,
      minusb,
      minus,
      minusd,
      minusdu,
      MinusPlus,
      mlcp,
      mldr,
      mnplus,
      models,
      Mopf,
      mopf,
      mp,
      mscr,
      Mscr,
      mstpos,
      Mu,
      mu,
      multimap,
      mumap,
      nabla,
      Nacute,
      nacute,
      nang,
      nap,
      napE,
      napid,
      napos,
      napprox,
      natural,
      naturals,
      natur,
      nbsp,
      nbump,
      nbumpe,
      ncap,
      Ncaron,
      ncaron,
      Ncedil,
      ncedil,
      ncong,
      ncongdot,
      ncup,
      Ncy,
      ncy,
      ndash,
      nearhk,
      nearr,
      neArr,
      nearrow,
      ne,
      nedot,
      NegativeMediumSpace,
      NegativeThickSpace,
      NegativeThinSpace,
      NegativeVeryThinSpace,
      nequiv,
      nesear,
      nesim,
      NestedGreaterGreater,
      NestedLessLess,
      NewLine,
      nexist,
      nexists,
      Nfr,
      nfr,
      ngE,
      nge,
      ngeq,
      ngeqq,
      ngeqslant,
      nges,
      nGg,
      ngsim,
      nGt,
      ngt,
      ngtr,
      nGtv,
      nharr,
      nhArr,
      nhpar,
      ni,
      nis,
      nisd,
      niv,
      NJcy,
      njcy,
      nlarr,
      nlArr,
      nldr,
      nlE,
      nle,
      nleftarrow,
      nLeftarrow,
      nleftrightarrow,
      nLeftrightarrow,
      nleq,
      nleqq,
      nleqslant,
      nles,
      nless,
      nLl,
      nlsim,
      nLt,
      nlt,
      nltri,
      nltrie,
      nLtv,
      nmid,
      NoBreak,
      NonBreakingSpace,
      nopf,
      Nopf,
      Not,
      not,
      NotCongruent,
      NotCupCap,
      NotDoubleVerticalBar,
      NotElement,
      NotEqual,
      NotEqualTilde,
      NotExists,
      NotGreater,
      NotGreaterEqual,
      NotGreaterFullEqual,
      NotGreaterGreater,
      NotGreaterLess,
      NotGreaterSlantEqual,
      NotGreaterTilde,
      NotHumpDownHump,
      NotHumpEqual,
      notin,
      notindot,
      notinE,
      notinva,
      notinvb,
      notinvc,
      NotLeftTriangleBar,
      NotLeftTriangle,
      NotLeftTriangleEqual,
      NotLess,
      NotLessEqual,
      NotLessGreater,
      NotLessLess,
      NotLessSlantEqual,
      NotLessTilde,
      NotNestedGreaterGreater,
      NotNestedLessLess,
      notni,
      notniva,
      notnivb,
      notnivc,
      NotPrecedes,
      NotPrecedesEqual,
      NotPrecedesSlantEqual,
      NotReverseElement,
      NotRightTriangleBar,
      NotRightTriangle,
      NotRightTriangleEqual,
      NotSquareSubset,
      NotSquareSubsetEqual,
      NotSquareSuperset,
      NotSquareSupersetEqual,
      NotSubset,
      NotSubsetEqual,
      NotSucceeds,
      NotSucceedsEqual,
      NotSucceedsSlantEqual,
      NotSucceedsTilde,
      NotSuperset,
      NotSupersetEqual,
      NotTilde,
      NotTildeEqual,
      NotTildeFullEqual,
      NotTildeTilde,
      NotVerticalBar,
      nparallel,
      npar,
      nparsl,
      npart,
      npolint,
      npr,
      nprcue,
      nprec,
      npreceq,
      npre,
      nrarrc,
      nrarr,
      nrArr,
      nrarrw,
      nrightarrow,
      nRightarrow,
      nrtri,
      nrtrie,
      nsc,
      nsccue,
      nsce,
      Nscr,
      nscr,
      nshortmid,
      nshortparallel,
      nsim,
      nsime,
      nsimeq,
      nsmid,
      nspar,
      nsqsube,
      nsqsupe,
      nsub,
      nsubE,
      nsube,
      nsubset,
      nsubseteq,
      nsubseteqq,
      nsucc,
      nsucceq,
      nsup,
      nsupE,
      nsupe,
      nsupset,
      nsupseteq,
      nsupseteqq,
      ntgl,
      Ntilde,
      ntilde,
      ntlg,
      ntriangleleft,
      ntrianglelefteq,
      ntriangleright,
      ntrianglerighteq,
      Nu,
      nu,
      num,
      numero,
      numsp,
      nvap,
      nvdash,
      nvDash,
      nVdash,
      nVDash,
      nvge,
      nvgt,
      nvHarr,
      nvinfin,
      nvlArr,
      nvle,
      nvlt,
      nvltrie,
      nvrArr,
      nvrtrie,
      nvsim,
      nwarhk,
      nwarr,
      nwArr,
      nwarrow,
      nwnear,
      Oacute,
      oacute,
      oast,
      Ocirc,
      ocirc,
      ocir,
      Ocy,
      ocy,
      odash,
      Odblac,
      odblac,
      odiv,
      odot,
      odsold,
      OElig,
      oelig,
      ofcir,
      Ofr,
      ofr,
      ogon,
      Ograve,
      ograve,
      ogt,
      ohbar,
      ohm,
      oint,
      olarr,
      olcir,
      olcross,
      oline,
      olt,
      Omacr,
      omacr,
      Omega,
      omega,
      Omicron,
      omicron,
      omid,
      ominus,
      Oopf,
      oopf,
      opar,
      OpenCurlyDoubleQuote,
      OpenCurlyQuote,
      operp,
      oplus,
      orarr,
      Or,
      or,
      ord,
      order,
      orderof,
      ordf,
      ordm,
      origof,
      oror,
      orslope,
      orv,
      oS,
      Oscr,
      oscr,
      Oslash,
      oslash,
      osol,
      Otilde,
      otilde,
      otimesas,
      Otimes,
      otimes,
      Ouml,
      ouml,
      ovbar,
      OverBar,
      OverBrace,
      OverBracket,
      OverParenthesis,
      para,
      parallel,
      par,
      parsim,
      parsl,
      part,
      PartialD,
      Pcy,
      pcy,
      percnt,
      period,
      permil,
      perp,
      pertenk,
      Pfr,
      pfr,
      Phi,
      phi,
      phiv,
      phmmat,
      phone,
      Pi,
      pi,
      pitchfork,
      piv,
      planck,
      planckh,
      plankv,
      plusacir,
      plusb,
      pluscir,
      plus,
      plusdo,
      plusdu,
      pluse,
      PlusMinus,
      plusmn,
      plussim,
      plustwo,
      pm,
      Poincareplane,
      pointint,
      popf,
      Popf,
      pound,
      prap,
      Pr,
      pr,
      prcue,
      precapprox,
      prec,
      preccurlyeq,
      Precedes,
      PrecedesEqual,
      PrecedesSlantEqual,
      PrecedesTilde,
      preceq,
      precnapprox,
      precneqq,
      precnsim,
      pre,
      prE,
      precsim,
      prime,
      Prime,
      primes,
      prnap,
      prnE,
      prnsim,
      prod,
      Product,
      profalar,
      profline,
      profsurf,
      prop,
      Proportional,
      Proportion,
      propto,
      prsim,
      prurel,
      Pscr,
      pscr,
      Psi,
      psi,
      puncsp,
      Qfr,
      qfr,
      qint,
      qopf,
      Qopf,
      qprime,
      Qscr,
      qscr,
      quaternions,
      quatint,
      quest,
      questeq,
      quot,
      QUOT,
      rAarr,
      race,
      Racute,
      racute,
      radic,
      raemptyv,
      rang,
      Rang,
      rangd,
      range,
      rangle,
      raquo,
      rarrap,
      rarrb,
      rarrbfs,
      rarrc,
      rarr,
      Rarr,
      rArr,
      rarrfs,
      rarrhk,
      rarrlp,
      rarrpl,
      rarrsim,
      Rarrtl,
      rarrtl,
      rarrw,
      ratail,
      rAtail,
      ratio,
      rationals,
      rbarr,
      rBarr,
      RBarr,
      rbbrk,
      rbrace,
      rbrack,
      rbrke,
      rbrksld,
      rbrkslu,
      Rcaron,
      rcaron,
      Rcedil,
      rcedil,
      rceil,
      rcub,
      Rcy,
      rcy,
      rdca,
      rdldhar,
      rdquo,
      rdquor,
      rdsh,
      real,
      realine,
      realpart,
      reals,
      Re,
      rect,
      reg,
      REG,
      ReverseElement,
      ReverseEquilibrium,
      ReverseUpEquilibrium,
      rfisht,
      rfloor,
      rfr,
      Rfr,
      rHar,
      rhard,
      rharu,
      rharul,
      Rho,
      rho,
      rhov,
      RightAngleBracket,
      RightArrowBar,
      rightarrow,
      RightArrow,
      Rightarrow,
      RightArrowLeftArrow,
      rightarrowtail,
      RightCeiling,
      RightDoubleBracket,
      RightDownTeeVector,
      RightDownVectorBar,
      RightDownVector,
      RightFloor,
      rightharpoondown,
      rightharpoonup,
      rightleftarrows,
      rightleftharpoons,
      rightrightarrows,
      rightsquigarrow,
      RightTeeArrow,
      RightTee,
      RightTeeVector,
      rightthreetimes,
      RightTriangleBar,
      RightTriangle,
      RightTriangleEqual,
      RightUpDownVector,
      RightUpTeeVector,
      RightUpVectorBar,
      RightUpVector,
      RightVectorBar,
      RightVector,
      ring,
      risingdotseq,
      rlarr,
      rlhar,
      rlm,
      rmoustache,
      rmoust,
      rnmid,
      roang,
      roarr,
      robrk,
      ropar,
      ropf,
      Ropf,
      roplus,
      rotimes,
      RoundImplies,
      rpar,
      rpargt,
      rppolint,
      rrarr,
      Rrightarrow,
      rsaquo,
      rscr,
      Rscr,
      rsh,
      Rsh,
      rsqb,
      rsquo,
      rsquor,
      rthree,
      rtimes,
      rtri,
      rtrie,
      rtrif,
      rtriltri,
      RuleDelayed,
      ruluhar,
      rx,
      Sacute,
      sacute,
      sbquo,
      scap,
      Scaron,
      scaron,
      Sc,
      sc,
      sccue,
      sce,
      scE,
      Scedil,
      scedil,
      Scirc,
      scirc,
      scnap,
      scnE,
      scnsim,
      scpolint,
      scsim,
      Scy,
      scy,
      sdotb,
      sdot,
      sdote,
      searhk,
      searr,
      seArr,
      searrow,
      sect,
      semi,
      seswar,
      setminus,
      setmn,
      sext,
      Sfr,
      sfr,
      sfrown,
      sharp,
      SHCHcy,
      shchcy,
      SHcy,
      shcy,
      ShortDownArrow,
      ShortLeftArrow,
      shortmid,
      shortparallel,
      ShortRightArrow,
      ShortUpArrow,
      shy,
      Sigma,
      sigma,
      sigmaf,
      sigmav,
      sim,
      simdot,
      sime,
      simeq,
      simg,
      simgE,
      siml,
      simlE,
      simne,
      simplus,
      simrarr,
      slarr,
      SmallCircle,
      smallsetminus,
      smashp,
      smeparsl,
      smid,
      smile,
      smt,
      smte,
      smtes,
      SOFTcy,
      softcy,
      solbar,
      solb,
      sol,
      Sopf,
      sopf,
      spades,
      spadesuit,
      spar,
      sqcap,
      sqcaps,
      sqcup,
      sqcups,
      Sqrt,
      sqsub,
      sqsube,
      sqsubset,
      sqsubseteq,
      sqsup,
      sqsupe,
      sqsupset,
      sqsupseteq,
      square,
      Square,
      SquareIntersection,
      SquareSubset,
      SquareSubsetEqual,
      SquareSuperset,
      SquareSupersetEqual,
      SquareUnion,
      squarf,
      squ,
      squf,
      srarr,
      Sscr,
      sscr,
      ssetmn,
      ssmile,
      sstarf,
      Star,
      star,
      starf,
      straightepsilon,
      straightphi,
      strns,
      sub,
      Sub,
      subdot,
      subE,
      sube,
      subedot,
      submult,
      subnE,
      subne,
      subplus,
      subrarr,
      subset,
      Subset,
      subseteq,
      subseteqq,
      SubsetEqual,
      subsetneq,
      subsetneqq,
      subsim,
      subsub,
      subsup,
      succapprox,
      succ,
      succcurlyeq,
      Succeeds,
      SucceedsEqual,
      SucceedsSlantEqual,
      SucceedsTilde,
      succeq,
      succnapprox,
      succneqq,
      succnsim,
      succsim,
      SuchThat,
      sum,
      Sum,
      sung,
      sup1,
      sup2,
      sup3,
      sup,
      Sup,
      supdot,
      supdsub,
      supE,
      supe,
      supedot,
      Superset,
      SupersetEqual,
      suphsol,
      suphsub,
      suplarr,
      supmult,
      supnE,
      supne,
      supplus,
      supset,
      Supset,
      supseteq,
      supseteqq,
      supsetneq,
      supsetneqq,
      supsim,
      supsub,
      supsup,
      swarhk,
      swarr,
      swArr,
      swarrow,
      swnwar,
      szlig,
      Tab,
      target,
      Tau,
      tau,
      tbrk,
      Tcaron,
      tcaron,
      Tcedil,
      tcedil,
      Tcy,
      tcy,
      tdot,
      telrec,
      Tfr,
      tfr,
      there4,
      therefore,
      Therefore,
      Theta,
      theta,
      thetasym,
      thetav,
      thickapprox,
      thicksim,
      ThickSpace,
      ThinSpace,
      thinsp,
      thkap,
      thksim,
      THORN,
      thorn,
      tilde,
      Tilde,
      TildeEqual,
      TildeFullEqual,
      TildeTilde,
      timesbar,
      timesb,
      times,
      timesd,
      tint,
      toea,
      topbot,
      topcir,
      top,
      Topf,
      topf,
      topfork,
      tosa,
      tprime,
      trade,
      TRADE,
      triangle,
      triangledown,
      triangleleft,
      trianglelefteq,
      triangleq,
      triangleright,
      trianglerighteq,
      tridot,
      trie,
      triminus,
      TripleDot,
      triplus,
      trisb,
      tritime,
      trpezium,
      Tscr,
      tscr,
      TScy,
      tscy,
      TSHcy,
      tshcy,
      Tstrok,
      tstrok,
      twixt,
      twoheadleftarrow,
      twoheadrightarrow,
      Uacute,
      uacute,
      uarr,
      Uarr,
      uArr,
      Uarrocir,
      Ubrcy,
      ubrcy,
      Ubreve,
      ubreve,
      Ucirc,
      ucirc,
      Ucy,
      ucy,
      udarr,
      Udblac,
      udblac,
      udhar,
      ufisht,
      Ufr,
      ufr,
      Ugrave,
      ugrave,
      uHar,
      uharl,
      uharr,
      uhblk,
      ulcorn,
      ulcorner,
      ulcrop,
      ultri,
      Umacr,
      umacr,
      uml,
      UnderBar,
      UnderBrace,
      UnderBracket,
      UnderParenthesis,
      Union,
      UnionPlus,
      Uogon,
      uogon,
      Uopf,
      uopf,
      UpArrowBar,
      uparrow,
      UpArrow,
      Uparrow,
      UpArrowDownArrow,
      updownarrow,
      UpDownArrow,
      Updownarrow,
      UpEquilibrium,
      upharpoonleft,
      upharpoonright,
      uplus,
      UpperLeftArrow,
      UpperRightArrow,
      upsi,
      Upsi,
      upsih,
      Upsilon,
      upsilon,
      UpTeeArrow,
      UpTee,
      upuparrows,
      urcorn,
      urcorner,
      urcrop,
      Uring,
      uring,
      urtri,
      Uscr,
      uscr,
      utdot,
      Utilde,
      utilde,
      utri,
      utrif,
      uuarr,
      Uuml,
      uuml,
      uwangle,
      vangrt,
      varepsilon,
      varkappa,
      varnothing,
      varphi,
      varpi,
      varpropto,
      varr,
      vArr,
      varrho,
      varsigma,
      varsubsetneq,
      varsubsetneqq,
      varsupsetneq,
      varsupsetneqq,
      vartheta,
      vartriangleleft,
      vartriangleright,
      vBar,
      Vbar,
      vBarv,
      Vcy,
      vcy,
      vdash,
      vDash,
      Vdash,
      VDash,
      Vdashl,
      veebar,
      vee,
      Vee,
      veeeq,
      vellip,
      verbar,
      Verbar,
      vert,
      Vert,
      VerticalBar,
      VerticalLine,
      VerticalSeparator,
      VerticalTilde,
      VeryThinSpace,
      Vfr,
      vfr,
      vltri,
      vnsub,
      vnsup,
      Vopf,
      vopf,
      vprop,
      vrtri,
      Vscr,
      vscr,
      vsubnE,
      vsubne,
      vsupnE,
      vsupne,
      Vvdash,
      vzigzag,
      Wcirc,
      wcirc,
      wedbar,
      wedge,
      Wedge,
      wedgeq,
      weierp,
      Wfr,
      wfr,
      Wopf,
      wopf,
      wp,
      wr,
      wreath,
      Wscr,
      wscr,
      xcap,
      xcirc,
      xcup,
      xdtri,
      Xfr,
      xfr,
      xharr,
      xhArr,
      Xi,
      xi,
      xlarr,
      xlArr,
      xmap,
      xnis,
      xodot,
      Xopf,
      xopf,
      xoplus,
      xotime,
      xrarr,
      xrArr,
      Xscr,
      xscr,
      xsqcup,
      xuplus,
      xutri,
      xvee,
      xwedge,
      Yacute,
      yacute,
      YAcy,
      yacy,
      Ycirc,
      ycirc,
      Ycy,
      ycy,
      yen,
      Yfr,
      yfr,
      YIcy,
      yicy,
      Yopf,
      yopf,
      Yscr,
      yscr,
      YUcy,
      yucy,
      yuml,
      Yuml,
      Zacute,
      zacute,
      Zcaron,
      zcaron,
      Zcy,
      zcy,
      Zdot,
      zdot,
      zeetrf,
      ZeroWidthSpace,
      Zeta,
      zeta,
      zfr,
      Zfr,
      ZHcy,
      zhcy,
      zigrarr,
      zopf,
      Zopf,
      Zscr,
      zscr,
      zwj,
      zwnj
    };
    var entities$1 = require$$0;
    var regex$4 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
    var mdurl$1 = {};
    var encodeCache = {};
    function getEncodeCache(exclude) {
      var i2, ch, cache2 = encodeCache[exclude];
      if (cache2) {
        return cache2;
      }
      cache2 = encodeCache[exclude] = [];
      for (i2 = 0; i2 < 128; i2++) {
        ch = String.fromCharCode(i2);
        if (/^[0-9a-z]$/i.test(ch)) {
          cache2.push(ch);
        } else {
          cache2.push("%" + ("0" + i2.toString(16).toUpperCase()).slice(-2));
        }
      }
      for (i2 = 0; i2 < exclude.length; i2++) {
        cache2[exclude.charCodeAt(i2)] = exclude[i2];
      }
      return cache2;
    }
    function encode$1(string, exclude, keepEscaped) {
      var i2, l, code2, nextCode, cache2, result = "";
      if (typeof exclude !== "string") {
        keepEscaped = exclude;
        exclude = encode$1.defaultChars;
      }
      if (typeof keepEscaped === "undefined") {
        keepEscaped = true;
      }
      cache2 = getEncodeCache(exclude);
      for (i2 = 0, l = string.length; i2 < l; i2++) {
        code2 = string.charCodeAt(i2);
        if (keepEscaped && code2 === 37 && i2 + 2 < l) {
          if (/^[0-9a-f]{2}$/i.test(string.slice(i2 + 1, i2 + 3))) {
            result += string.slice(i2, i2 + 3);
            i2 += 2;
            continue;
          }
        }
        if (code2 < 128) {
          result += cache2[code2];
          continue;
        }
        if (code2 >= 55296 && code2 <= 57343) {
          if (code2 >= 55296 && code2 <= 56319 && i2 + 1 < l) {
            nextCode = string.charCodeAt(i2 + 1);
            if (nextCode >= 56320 && nextCode <= 57343) {
              result += encodeURIComponent(string[i2] + string[i2 + 1]);
              i2++;
              continue;
            }
          }
          result += "%EF%BF%BD";
          continue;
        }
        result += encodeURIComponent(string[i2]);
      }
      return result;
    }
    encode$1.defaultChars = ";/?:@&=+$,-_.!~*'()#";
    encode$1.componentChars = "-_.!~*'()";
    var encode_1 = encode$1;
    var decodeCache = {};
    function getDecodeCache(exclude) {
      var i2, ch, cache2 = decodeCache[exclude];
      if (cache2) {
        return cache2;
      }
      cache2 = decodeCache[exclude] = [];
      for (i2 = 0; i2 < 128; i2++) {
        ch = String.fromCharCode(i2);
        cache2.push(ch);
      }
      for (i2 = 0; i2 < exclude.length; i2++) {
        ch = exclude.charCodeAt(i2);
        cache2[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
      }
      return cache2;
    }
    function decode$1(string, exclude) {
      var cache2;
      if (typeof exclude !== "string") {
        exclude = decode$1.defaultChars;
      }
      cache2 = getDecodeCache(exclude);
      return string.replace(/(%[a-f0-9]{2})+/gi, function(seq2) {
        var i2, l, b1, b2, b3, b4, chr, result = "";
        for (i2 = 0, l = seq2.length; i2 < l; i2 += 3) {
          b1 = parseInt(seq2.slice(i2 + 1, i2 + 3), 16);
          if (b1 < 128) {
            result += cache2[b1];
            continue;
          }
          if ((b1 & 224) === 192 && i2 + 3 < l) {
            b2 = parseInt(seq2.slice(i2 + 4, i2 + 6), 16);
            if ((b2 & 192) === 128) {
              chr = b1 << 6 & 1984 | b2 & 63;
              if (chr < 128) {
                result += "��";
              } else {
                result += String.fromCharCode(chr);
              }
              i2 += 3;
              continue;
            }
          }
          if ((b1 & 240) === 224 && i2 + 6 < l) {
            b2 = parseInt(seq2.slice(i2 + 4, i2 + 6), 16);
            b3 = parseInt(seq2.slice(i2 + 7, i2 + 9), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128) {
              chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
              if (chr < 2048 || chr >= 55296 && chr <= 57343) {
                result += "���";
              } else {
                result += String.fromCharCode(chr);
              }
              i2 += 6;
              continue;
            }
          }
          if ((b1 & 248) === 240 && i2 + 9 < l) {
            b2 = parseInt(seq2.slice(i2 + 4, i2 + 6), 16);
            b3 = parseInt(seq2.slice(i2 + 7, i2 + 9), 16);
            b4 = parseInt(seq2.slice(i2 + 10, i2 + 12), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
              chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
              if (chr < 65536 || chr > 1114111) {
                result += "����";
              } else {
                chr -= 65536;
                result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
              }
              i2 += 9;
              continue;
            }
          }
          result += "�";
        }
        return result;
      });
    }
    decode$1.defaultChars = ";/?:@&=+$,#";
    decode$1.componentChars = "";
    var decode_1 = decode$1;
    var format = function format2(url) {
      var result = "";
      result += url.protocol || "";
      result += url.slashes ? "//" : "";
      result += url.auth ? url.auth + "@" : "";
      if (url.hostname && url.hostname.indexOf(":") !== -1) {
        result += "[" + url.hostname + "]";
      } else {
        result += url.hostname || "";
      }
      result += url.port ? ":" + url.port : "";
      result += url.pathname || "";
      result += url.search || "";
      result += url.hash || "";
      return result;
    };
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.pathname = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    }, slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    function urlParse(url, slashesDenoteHost) {
      if (url && url instanceof Url) {
        return url;
      }
      var u = new Url();
      u.parse(url, slashesDenoteHost);
      return u;
    }
    Url.prototype.parse = function(url, slashesDenoteHost) {
      var i2, l, lowerProto, hec, slashes, rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        lowerProto = proto.toLowerCase();
        this.protocol = proto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (i2 = 0; i2 < hostEndingChars.length; i2++) {
          hec = rest.indexOf(hostEndingChars[i2]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = auth;
        }
        hostEnd = -1;
        for (i2 = 0; i2 < nonHostChars.length; i2++) {
          hec = rest.indexOf(nonHostChars[i2]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        if (rest[hostEnd - 1] === ":") {
          hostEnd--;
        }
        var host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost(host);
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (i2 = 0, l = hostparts.length; i2 < l; i2++) {
            var part2 = hostparts[i2];
            if (!part2) {
              continue;
            }
            if (!part2.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j = 0, k = part2.length; j < k; j++) {
                if (part2.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part2[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i2);
                var notHost = hostparts.slice(i2 + 1);
                var bit = part2.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        }
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        rest = rest.slice(0, qm);
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "";
      }
      return this;
    };
    Url.prototype.parseHost = function(host) {
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    var parse = urlParse;
    mdurl$1.encode = encode_1;
    mdurl$1.decode = decode_1;
    mdurl$1.format = format;
    mdurl$1.parse = parse;
    var uc_micro = {};
    var regex$3;
    var hasRequiredRegex$3;
    function requireRegex$3() {
      if (hasRequiredRegex$3)
        return regex$3;
      hasRequiredRegex$3 = 1;
      regex$3 = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      return regex$3;
    }
    var regex$2;
    var hasRequiredRegex$2;
    function requireRegex$2() {
      if (hasRequiredRegex$2)
        return regex$2;
      hasRequiredRegex$2 = 1;
      regex$2 = /[\0-\x1F\x7F-\x9F]/;
      return regex$2;
    }
    var regex$1;
    var hasRequiredRegex$1;
    function requireRegex$1() {
      if (hasRequiredRegex$1)
        return regex$1;
      hasRequiredRegex$1 = 1;
      regex$1 = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
      return regex$1;
    }
    var regex;
    var hasRequiredRegex;
    function requireRegex() {
      if (hasRequiredRegex)
        return regex;
      hasRequiredRegex = 1;
      regex = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
      return regex;
    }
    var hasRequiredUc_micro;
    function requireUc_micro() {
      if (hasRequiredUc_micro)
        return uc_micro;
      hasRequiredUc_micro = 1;
      uc_micro.Any = requireRegex$3();
      uc_micro.Cc = requireRegex$2();
      uc_micro.Cf = requireRegex$1();
      uc_micro.P = regex$4;
      uc_micro.Z = requireRegex();
      return uc_micro;
    }
    (function(exports2) {
      function _class2(obj) {
        return Object.prototype.toString.call(obj);
      }
      function isString2(obj) {
        return _class2(obj) === "[object String]";
      }
      var _hasOwnProperty2 = Object.prototype.hasOwnProperty;
      function has2(object, key) {
        return _hasOwnProperty2.call(object, key);
      }
      function assign2(obj) {
        var sources = Array.prototype.slice.call(arguments, 1);
        sources.forEach(function(source2) {
          if (!source2) {
            return;
          }
          if (typeof source2 !== "object") {
            throw new TypeError(source2 + "must be object");
          }
          Object.keys(source2).forEach(function(key) {
            obj[key] = source2[key];
          });
        });
        return obj;
      }
      function arrayReplaceAt2(src, pos, newElements) {
        return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
      }
      function isValidEntityCode2(c) {
        if (c >= 55296 && c <= 57343) {
          return false;
        }
        if (c >= 64976 && c <= 65007) {
          return false;
        }
        if ((c & 65535) === 65535 || (c & 65535) === 65534) {
          return false;
        }
        if (c >= 0 && c <= 8) {
          return false;
        }
        if (c === 11) {
          return false;
        }
        if (c >= 14 && c <= 31) {
          return false;
        }
        if (c >= 127 && c <= 159) {
          return false;
        }
        if (c > 1114111) {
          return false;
        }
        return true;
      }
      function fromCodePoint2(c) {
        if (c > 65535) {
          c -= 65536;
          var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);
          return String.fromCharCode(surrogate1, surrogate2);
        }
        return String.fromCharCode(c);
      }
      var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
      var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
      var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
      var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
      var entities2 = entities$1;
      function replaceEntityPattern(match, name) {
        var code2;
        if (has2(entities2, name)) {
          return entities2[name];
        }
        if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {
          code2 = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
          if (isValidEntityCode2(code2)) {
            return fromCodePoint2(code2);
          }
        }
        return match;
      }
      function unescapeMd(str2) {
        if (str2.indexOf("\\") < 0) {
          return str2;
        }
        return str2.replace(UNESCAPE_MD_RE, "$1");
      }
      function unescapeAll2(str2) {
        if (str2.indexOf("\\") < 0 && str2.indexOf("&") < 0) {
          return str2;
        }
        return str2.replace(UNESCAPE_ALL_RE, function(match, escaped, entity2) {
          if (escaped) {
            return escaped;
          }
          return replaceEntityPattern(match, entity2);
        });
      }
      var HTML_ESCAPE_TEST_RE = /[&<>"]/;
      var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
      var HTML_REPLACEMENTS = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;"
      };
      function replaceUnsafeChar(ch) {
        return HTML_REPLACEMENTS[ch];
      }
      function escapeHtml2(str2) {
        if (HTML_ESCAPE_TEST_RE.test(str2)) {
          return str2.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
        }
        return str2;
      }
      var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
      function escapeRE2(str2) {
        return str2.replace(REGEXP_ESCAPE_RE, "\\$&");
      }
      function isSpace2(code2) {
        switch (code2) {
          case 9:
          case 32:
            return true;
        }
        return false;
      }
      function isWhiteSpace2(code2) {
        if (code2 >= 8192 && code2 <= 8202) {
          return true;
        }
        switch (code2) {
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 32:
          case 160:
          case 5760:
          case 8239:
          case 8287:
          case 12288:
            return true;
        }
        return false;
      }
      var UNICODE_PUNCT_RE = regex$4;
      function isPunctChar2(ch) {
        return UNICODE_PUNCT_RE.test(ch);
      }
      function isMdAsciiPunct2(ch) {
        switch (ch) {
          case 33:
          case 34:
          case 35:
          case 36:
          case 37:
          case 38:
          case 39:
          case 40:
          case 41:
          case 42:
          case 43:
          case 44:
          case 45:
          case 46:
          case 47:
          case 58:
          case 59:
          case 60:
          case 61:
          case 62:
          case 63:
          case 64:
          case 91:
          case 92:
          case 93:
          case 94:
          case 95:
          case 96:
          case 123:
          case 124:
          case 125:
          case 126:
            return true;
          default:
            return false;
        }
      }
      function normalizeReference2(str2) {
        str2 = str2.trim().replace(/\s+/g, " ");
        if ("ẞ".toLowerCase() === "Ṿ") {
          str2 = str2.replace(/ẞ/g, "ß");
        }
        return str2.toLowerCase().toUpperCase();
      }
      exports2.lib = {};
      exports2.lib.mdurl = mdurl$1;
      exports2.lib.ucmicro = requireUc_micro();
      exports2.assign = assign2;
      exports2.isString = isString2;
      exports2.has = has2;
      exports2.unescapeMd = unescapeMd;
      exports2.unescapeAll = unescapeAll2;
      exports2.isValidEntityCode = isValidEntityCode2;
      exports2.fromCodePoint = fromCodePoint2;
      exports2.escapeHtml = escapeHtml2;
      exports2.arrayReplaceAt = arrayReplaceAt2;
      exports2.isSpace = isSpace2;
      exports2.isWhiteSpace = isWhiteSpace2;
      exports2.isMdAsciiPunct = isMdAsciiPunct2;
      exports2.isPunctChar = isPunctChar2;
      exports2.escapeRE = escapeRE2;
      exports2.normalizeReference = normalizeReference2;
    })(utils$1);
    var helpers$1 = {};
    var parse_link_label = function parseLinkLabel(state, start, disableNested) {
      var level, found, marker2, prevPos, labelEnd = -1, max = state.posMax, oldPos = state.pos;
      state.pos = start + 1;
      level = 1;
      while (state.pos < max) {
        marker2 = state.src.charCodeAt(state.pos);
        if (marker2 === 93) {
          level--;
          if (level === 0) {
            found = true;
            break;
          }
        }
        prevPos = state.pos;
        state.md.inline.skipToken(state);
        if (marker2 === 91) {
          if (prevPos === state.pos - 1) {
            level++;
          } else if (disableNested) {
            state.pos = oldPos;
            return -1;
          }
        }
      }
      if (found) {
        labelEnd = state.pos;
      }
      state.pos = oldPos;
      return labelEnd;
    };
    var unescapeAll$2 = utils$1.unescapeAll;
    var parse_link_destination = function parseLinkDestination(str2, start, max) {
      var code2, level, pos = start, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (str2.charCodeAt(pos) === 60) {
        pos++;
        while (pos < max) {
          code2 = str2.charCodeAt(pos);
          if (code2 === 10) {
            return result;
          }
          if (code2 === 60) {
            return result;
          }
          if (code2 === 62) {
            result.pos = pos + 1;
            result.str = unescapeAll$2(str2.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
          if (code2 === 92 && pos + 1 < max) {
            pos += 2;
            continue;
          }
          pos++;
        }
        return result;
      }
      level = 0;
      while (pos < max) {
        code2 = str2.charCodeAt(pos);
        if (code2 === 32) {
          break;
        }
        if (code2 < 32 || code2 === 127) {
          break;
        }
        if (code2 === 92 && pos + 1 < max) {
          if (str2.charCodeAt(pos + 1) === 32) {
            break;
          }
          pos += 2;
          continue;
        }
        if (code2 === 40) {
          level++;
          if (level > 32) {
            return result;
          }
        }
        if (code2 === 41) {
          if (level === 0) {
            break;
          }
          level--;
        }
        pos++;
      }
      if (start === pos) {
        return result;
      }
      if (level !== 0) {
        return result;
      }
      result.str = unescapeAll$2(str2.slice(start, pos));
      result.pos = pos;
      result.ok = true;
      return result;
    };
    var unescapeAll$1 = utils$1.unescapeAll;
    var parse_link_title = function parseLinkTitle(str2, start, max) {
      var code2, marker2, lines = 0, pos = start, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (pos >= max) {
        return result;
      }
      marker2 = str2.charCodeAt(pos);
      if (marker2 !== 34 && marker2 !== 39 && marker2 !== 40) {
        return result;
      }
      pos++;
      if (marker2 === 40) {
        marker2 = 41;
      }
      while (pos < max) {
        code2 = str2.charCodeAt(pos);
        if (code2 === marker2) {
          result.pos = pos + 1;
          result.lines = lines;
          result.str = unescapeAll$1(str2.slice(start + 1, pos));
          result.ok = true;
          return result;
        } else if (code2 === 40 && marker2 === 41) {
          return result;
        } else if (code2 === 10) {
          lines++;
        } else if (code2 === 92 && pos + 1 < max) {
          pos++;
          if (str2.charCodeAt(pos) === 10) {
            lines++;
          }
        }
        pos++;
      }
      return result;
    };
    helpers$1.parseLinkLabel = parse_link_label;
    helpers$1.parseLinkDestination = parse_link_destination;
    helpers$1.parseLinkTitle = parse_link_title;
    var assign$1 = utils$1.assign;
    var unescapeAll = utils$1.unescapeAll;
    var escapeHtml = utils$1.escapeHtml;
    var default_rules = {};
    default_rules.code_inline = function(tokens, idx, options, env, slf) {
      var token2 = tokens[idx];
      return "<code" + slf.renderAttrs(token2) + ">" + escapeHtml(token2.content) + "</code>";
    };
    default_rules.code_block = function(tokens, idx, options, env, slf) {
      var token2 = tokens[idx];
      return "<pre" + slf.renderAttrs(token2) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
    };
    default_rules.fence = function(tokens, idx, options, env, slf) {
      var token2 = tokens[idx], info = token2.info ? unescapeAll(token2.info).trim() : "", langName = "", langAttrs = "", highlighted, i2, arr, tmpAttrs, tmpToken;
      if (info) {
        arr = info.split(/(\s+)/g);
        langName = arr[0];
        langAttrs = arr.slice(2).join("");
      }
      if (options.highlight) {
        highlighted = options.highlight(token2.content, langName, langAttrs) || escapeHtml(token2.content);
      } else {
        highlighted = escapeHtml(token2.content);
      }
      if (highlighted.indexOf("<pre") === 0) {
        return highlighted + "\n";
      }
      if (info) {
        i2 = token2.attrIndex("class");
        tmpAttrs = token2.attrs ? token2.attrs.slice() : [];
        if (i2 < 0) {
          tmpAttrs.push(["class", options.langPrefix + langName]);
        } else {
          tmpAttrs[i2] = tmpAttrs[i2].slice();
          tmpAttrs[i2][1] += " " + options.langPrefix + langName;
        }
        tmpToken = {
          attrs: tmpAttrs
        };
        return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
      }
      return "<pre><code" + slf.renderAttrs(token2) + ">" + highlighted + "</code></pre>\n";
    };
    default_rules.image = function(tokens, idx, options, env, slf) {
      var token2 = tokens[idx];
      token2.attrs[token2.attrIndex("alt")][1] = slf.renderInlineAsText(token2.children, options, env);
      return slf.renderToken(tokens, idx, options);
    };
    default_rules.hardbreak = function(tokens, idx, options) {
      return options.xhtmlOut ? "<br />\n" : "<br>\n";
    };
    default_rules.softbreak = function(tokens, idx, options) {
      return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
    };
    default_rules.text = function(tokens, idx) {
      return escapeHtml(tokens[idx].content);
    };
    default_rules.html_block = function(tokens, idx) {
      return tokens[idx].content;
    };
    default_rules.html_inline = function(tokens, idx) {
      return tokens[idx].content;
    };
    function Renderer$1() {
      this.rules = assign$1({}, default_rules);
    }
    Renderer$1.prototype.renderAttrs = function renderAttrs(token2) {
      var i2, l, result;
      if (!token2.attrs) {
        return "";
      }
      result = "";
      for (i2 = 0, l = token2.attrs.length; i2 < l; i2++) {
        result += " " + escapeHtml(token2.attrs[i2][0]) + '="' + escapeHtml(token2.attrs[i2][1]) + '"';
      }
      return result;
    };
    Renderer$1.prototype.renderToken = function renderToken(tokens, idx, options) {
      var nextToken, result = "", needLf = false, token2 = tokens[idx];
      if (token2.hidden) {
        return "";
      }
      if (token2.block && token2.nesting !== -1 && idx && tokens[idx - 1].hidden) {
        result += "\n";
      }
      result += (token2.nesting === -1 ? "</" : "<") + token2.tag;
      result += this.renderAttrs(token2);
      if (token2.nesting === 0 && options.xhtmlOut) {
        result += " /";
      }
      if (token2.block) {
        needLf = true;
        if (token2.nesting === 1) {
          if (idx + 1 < tokens.length) {
            nextToken = tokens[idx + 1];
            if (nextToken.type === "inline" || nextToken.hidden) {
              needLf = false;
            } else if (nextToken.nesting === -1 && nextToken.tag === token2.tag) {
              needLf = false;
            }
          }
        }
      }
      result += needLf ? ">\n" : ">";
      return result;
    };
    Renderer$1.prototype.renderInline = function(tokens, options, env) {
      var type2, result = "", rules2 = this.rules;
      for (var i2 = 0, len = tokens.length; i2 < len; i2++) {
        type2 = tokens[i2].type;
        if (typeof rules2[type2] !== "undefined") {
          result += rules2[type2](tokens, i2, options, env, this);
        } else {
          result += this.renderToken(tokens, i2, options);
        }
      }
      return result;
    };
    Renderer$1.prototype.renderInlineAsText = function(tokens, options, env) {
      var result = "";
      for (var i2 = 0, len = tokens.length; i2 < len; i2++) {
        if (tokens[i2].type === "text") {
          result += tokens[i2].content;
        } else if (tokens[i2].type === "image") {
          result += this.renderInlineAsText(tokens[i2].children, options, env);
        } else if (tokens[i2].type === "softbreak") {
          result += "\n";
        }
      }
      return result;
    };
    Renderer$1.prototype.render = function(tokens, options, env) {
      var i2, len, type2, result = "", rules2 = this.rules;
      for (i2 = 0, len = tokens.length; i2 < len; i2++) {
        type2 = tokens[i2].type;
        if (type2 === "inline") {
          result += this.renderInline(tokens[i2].children, options, env);
        } else if (typeof rules2[type2] !== "undefined") {
          result += rules2[type2](tokens, i2, options, env, this);
        } else {
          result += this.renderToken(tokens, i2, options, env);
        }
      }
      return result;
    };
    var renderer = Renderer$1;
    function Ruler$3() {
      this.__rules__ = [];
      this.__cache__ = null;
    }
    Ruler$3.prototype.__find__ = function(name) {
      for (var i2 = 0; i2 < this.__rules__.length; i2++) {
        if (this.__rules__[i2].name === name) {
          return i2;
        }
      }
      return -1;
    };
    Ruler$3.prototype.__compile__ = function() {
      var self2 = this;
      var chains = [""];
      self2.__rules__.forEach(function(rule) {
        if (!rule.enabled) {
          return;
        }
        rule.alt.forEach(function(altName) {
          if (chains.indexOf(altName) < 0) {
            chains.push(altName);
          }
        });
      });
      self2.__cache__ = {};
      chains.forEach(function(chain) {
        self2.__cache__[chain] = [];
        self2.__rules__.forEach(function(rule) {
          if (!rule.enabled) {
            return;
          }
          if (chain && rule.alt.indexOf(chain) < 0) {
            return;
          }
          self2.__cache__[chain].push(rule.fn);
        });
      });
    };
    Ruler$3.prototype.at = function(name, fn, options) {
      var index = this.__find__(name);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + name);
      }
      this.__rules__[index].fn = fn;
      this.__rules__[index].alt = opt.alt || [];
      this.__cache__ = null;
    };
    Ruler$3.prototype.before = function(beforeName, ruleName, fn, options) {
      var index = this.__find__(beforeName);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + beforeName);
      }
      this.__rules__.splice(index, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler$3.prototype.after = function(afterName, ruleName, fn, options) {
      var index = this.__find__(afterName);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + afterName);
      }
      this.__rules__.splice(index + 1, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler$3.prototype.push = function(ruleName, fn, options) {
      var opt = options || {};
      this.__rules__.push({
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler$3.prototype.enable = function(list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      var result = [];
      list2.forEach(function(name) {
        var idx = this.__find__(name);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name);
        }
        this.__rules__[idx].enabled = true;
        result.push(name);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler$3.prototype.enableOnly = function(list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      this.__rules__.forEach(function(rule) {
        rule.enabled = false;
      });
      this.enable(list2, ignoreInvalid);
    };
    Ruler$3.prototype.disable = function(list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      var result = [];
      list2.forEach(function(name) {
        var idx = this.__find__(name);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name);
        }
        this.__rules__[idx].enabled = false;
        result.push(name);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler$3.prototype.getRules = function(chainName) {
      if (this.__cache__ === null) {
        this.__compile__();
      }
      return this.__cache__[chainName] || [];
    };
    var ruler = Ruler$3;
    var NEWLINES_RE = /\r\n?|\n/g;
    var NULL_RE = /\0/g;
    var normalize = function normalize2(state) {
      var str2;
      str2 = state.src.replace(NEWLINES_RE, "\n");
      str2 = str2.replace(NULL_RE, "�");
      state.src = str2;
    };
    var block = function block2(state) {
      var token2;
      if (state.inlineMode) {
        token2 = new state.Token("inline", "", 0);
        token2.content = state.src;
        token2.map = [0, 1];
        token2.children = [];
        state.tokens.push(token2);
      } else {
        state.md.block.parse(state.src, state.md, state.env, state.tokens);
      }
    };
    var inline = function inline2(state) {
      var tokens = state.tokens, tok, i2, l;
      for (i2 = 0, l = tokens.length; i2 < l; i2++) {
        tok = tokens[i2];
        if (tok.type === "inline") {
          state.md.inline.parse(tok.content, state.md, state.env, tok.children);
        }
      }
    };
    var arrayReplaceAt = utils$1.arrayReplaceAt;
    function isLinkOpen$1(str2) {
      return /^<a[>\s]/i.test(str2);
    }
    function isLinkClose$1(str2) {
      return /^<\/a\s*>/i.test(str2);
    }
    var linkify$1 = function linkify2(state) {
      var i2, j, l, tokens, token2, currentToken, nodes, ln, text2, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;
      if (!state.md.options.linkify) {
        return;
      }
      for (j = 0, l = blockTokens.length; j < l; j++) {
        if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
          continue;
        }
        tokens = blockTokens[j].children;
        htmlLinkLevel = 0;
        for (i2 = tokens.length - 1; i2 >= 0; i2--) {
          currentToken = tokens[i2];
          if (currentToken.type === "link_close") {
            i2--;
            while (tokens[i2].level !== currentToken.level && tokens[i2].type !== "link_open") {
              i2--;
            }
            continue;
          }
          if (currentToken.type === "html_inline") {
            if (isLinkOpen$1(currentToken.content) && htmlLinkLevel > 0) {
              htmlLinkLevel--;
            }
            if (isLinkClose$1(currentToken.content)) {
              htmlLinkLevel++;
            }
          }
          if (htmlLinkLevel > 0) {
            continue;
          }
          if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
            text2 = currentToken.content;
            links = state.md.linkify.match(text2);
            nodes = [];
            level = currentToken.level;
            lastPos = 0;
            if (links.length > 0 && links[0].index === 0 && i2 > 0 && tokens[i2 - 1].type === "text_special") {
              links = links.slice(1);
            }
            for (ln = 0; ln < links.length; ln++) {
              url = links[ln].url;
              fullUrl = state.md.normalizeLink(url);
              if (!state.md.validateLink(fullUrl)) {
                continue;
              }
              urlText = links[ln].text;
              if (!links[ln].schema) {
                urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
              } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
                urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
              } else {
                urlText = state.md.normalizeLinkText(urlText);
              }
              pos = links[ln].index;
              if (pos > lastPos) {
                token2 = new state.Token("text", "", 0);
                token2.content = text2.slice(lastPos, pos);
                token2.level = level;
                nodes.push(token2);
              }
              token2 = new state.Token("link_open", "a", 1);
              token2.attrs = [["href", fullUrl]];
              token2.level = level++;
              token2.markup = "linkify";
              token2.info = "auto";
              nodes.push(token2);
              token2 = new state.Token("text", "", 0);
              token2.content = urlText;
              token2.level = level;
              nodes.push(token2);
              token2 = new state.Token("link_close", "a", -1);
              token2.level = --level;
              token2.markup = "linkify";
              token2.info = "auto";
              nodes.push(token2);
              lastPos = links[ln].lastIndex;
            }
            if (lastPos < text2.length) {
              token2 = new state.Token("text", "", 0);
              token2.content = text2.slice(lastPos);
              token2.level = level;
              nodes.push(token2);
            }
            blockTokens[j].children = tokens = arrayReplaceAt(tokens, i2, nodes);
          }
        }
      }
    };
    var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
    var SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
    var SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
    var SCOPED_ABBR = {
      c: "©",
      r: "®",
      tm: "™"
    };
    function replaceFn(match, name) {
      return SCOPED_ABBR[name.toLowerCase()];
    }
    function replace_scoped(inlineTokens) {
      var i2, token2, inside_autolink = 0;
      for (i2 = inlineTokens.length - 1; i2 >= 0; i2--) {
        token2 = inlineTokens[i2];
        if (token2.type === "text" && !inside_autolink) {
          token2.content = token2.content.replace(SCOPED_ABBR_RE, replaceFn);
        }
        if (token2.type === "link_open" && token2.info === "auto") {
          inside_autolink--;
        }
        if (token2.type === "link_close" && token2.info === "auto") {
          inside_autolink++;
        }
      }
    }
    function replace_rare(inlineTokens) {
      var i2, token2, inside_autolink = 0;
      for (i2 = inlineTokens.length - 1; i2 >= 0; i2--) {
        token2 = inlineTokens[i2];
        if (token2.type === "text" && !inside_autolink) {
          if (RARE_RE.test(token2.content)) {
            token2.content = token2.content.replace(/\+-/g, "±").replace(/\.{2,}/g, "…").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1—").replace(/(^|\s)--(?=\s|$)/mg, "$1–").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1–");
          }
        }
        if (token2.type === "link_open" && token2.info === "auto") {
          inside_autolink--;
        }
        if (token2.type === "link_close" && token2.info === "auto") {
          inside_autolink++;
        }
      }
    }
    var replacements = function replace2(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline") {
          continue;
        }
        if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
          replace_scoped(state.tokens[blkIdx].children);
        }
        if (RARE_RE.test(state.tokens[blkIdx].content)) {
          replace_rare(state.tokens[blkIdx].children);
        }
      }
    };
    var isWhiteSpace$1 = utils$1.isWhiteSpace;
    var isPunctChar$1 = utils$1.isPunctChar;
    var isMdAsciiPunct$1 = utils$1.isMdAsciiPunct;
    var QUOTE_TEST_RE = /['"]/;
    var QUOTE_RE = /['"]/g;
    var APOSTROPHE = "’";
    function replaceAt(str2, index, ch) {
      return str2.slice(0, index) + ch + str2.slice(index + 1);
    }
    function process_inlines(tokens, state) {
      var i2, token2, text2, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack2, openQuote, closeQuote;
      stack2 = [];
      for (i2 = 0; i2 < tokens.length; i2++) {
        token2 = tokens[i2];
        thisLevel = tokens[i2].level;
        for (j = stack2.length - 1; j >= 0; j--) {
          if (stack2[j].level <= thisLevel) {
            break;
          }
        }
        stack2.length = j + 1;
        if (token2.type !== "text") {
          continue;
        }
        text2 = token2.content;
        pos = 0;
        max = text2.length;
        OUTER:
          while (pos < max) {
            QUOTE_RE.lastIndex = pos;
            t = QUOTE_RE.exec(text2);
            if (!t) {
              break;
            }
            canOpen = canClose = true;
            pos = t.index + 1;
            isSingle = t[0] === "'";
            lastChar = 32;
            if (t.index - 1 >= 0) {
              lastChar = text2.charCodeAt(t.index - 1);
            } else {
              for (j = i2 - 1; j >= 0; j--) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
                break;
              }
            }
            nextChar = 32;
            if (pos < max) {
              nextChar = text2.charCodeAt(pos);
            } else {
              for (j = i2 + 1; j < tokens.length; j++) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                nextChar = tokens[j].content.charCodeAt(0);
                break;
              }
            }
            isLastPunctChar = isMdAsciiPunct$1(lastChar) || isPunctChar$1(String.fromCharCode(lastChar));
            isNextPunctChar = isMdAsciiPunct$1(nextChar) || isPunctChar$1(String.fromCharCode(nextChar));
            isLastWhiteSpace = isWhiteSpace$1(lastChar);
            isNextWhiteSpace = isWhiteSpace$1(nextChar);
            if (isNextWhiteSpace) {
              canOpen = false;
            } else if (isNextPunctChar) {
              if (!(isLastWhiteSpace || isLastPunctChar)) {
                canOpen = false;
              }
            }
            if (isLastWhiteSpace) {
              canClose = false;
            } else if (isLastPunctChar) {
              if (!(isNextWhiteSpace || isNextPunctChar)) {
                canClose = false;
              }
            }
            if (nextChar === 34 && t[0] === '"') {
              if (lastChar >= 48 && lastChar <= 57) {
                canClose = canOpen = false;
              }
            }
            if (canOpen && canClose) {
              canOpen = isLastPunctChar;
              canClose = isNextPunctChar;
            }
            if (!canOpen && !canClose) {
              if (isSingle) {
                token2.content = replaceAt(token2.content, t.index, APOSTROPHE);
              }
              continue;
            }
            if (canClose) {
              for (j = stack2.length - 1; j >= 0; j--) {
                item = stack2[j];
                if (stack2[j].level < thisLevel) {
                  break;
                }
                if (item.single === isSingle && stack2[j].level === thisLevel) {
                  item = stack2[j];
                  if (isSingle) {
                    openQuote = state.md.options.quotes[2];
                    closeQuote = state.md.options.quotes[3];
                  } else {
                    openQuote = state.md.options.quotes[0];
                    closeQuote = state.md.options.quotes[1];
                  }
                  token2.content = replaceAt(token2.content, t.index, closeQuote);
                  tokens[item.token].content = replaceAt(
                    tokens[item.token].content,
                    item.pos,
                    openQuote
                  );
                  pos += closeQuote.length - 1;
                  if (item.token === i2) {
                    pos += openQuote.length - 1;
                  }
                  text2 = token2.content;
                  max = text2.length;
                  stack2.length = j;
                  continue OUTER;
                }
              }
            }
            if (canOpen) {
              stack2.push({
                token: i2,
                pos: t.index,
                single: isSingle,
                level: thisLevel
              });
            } else if (canClose && isSingle) {
              token2.content = replaceAt(token2.content, t.index, APOSTROPHE);
            }
          }
      }
    }
    var smartquotes = function smartquotes2(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
          continue;
        }
        process_inlines(state.tokens[blkIdx].children, state);
      }
    };
    var text_join = function text_join2(state) {
      var j, l, tokens, curr, max, last, blockTokens = state.tokens;
      for (j = 0, l = blockTokens.length; j < l; j++) {
        if (blockTokens[j].type !== "inline")
          continue;
        tokens = blockTokens[j].children;
        max = tokens.length;
        for (curr = 0; curr < max; curr++) {
          if (tokens[curr].type === "text_special") {
            tokens[curr].type = "text";
          }
        }
        for (curr = last = 0; curr < max; curr++) {
          if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
            tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
          } else {
            if (curr !== last) {
              tokens[last] = tokens[curr];
            }
            last++;
          }
        }
        if (curr !== last) {
          tokens.length = last;
        }
      }
    };
    function Token$3(type2, tag, nesting) {
      this.type = type2;
      this.tag = tag;
      this.attrs = null;
      this.map = null;
      this.nesting = nesting;
      this.level = 0;
      this.children = null;
      this.content = "";
      this.markup = "";
      this.info = "";
      this.meta = null;
      this.block = false;
      this.hidden = false;
    }
    Token$3.prototype.attrIndex = function attrIndex(name) {
      var attrs, i2, len;
      if (!this.attrs) {
        return -1;
      }
      attrs = this.attrs;
      for (i2 = 0, len = attrs.length; i2 < len; i2++) {
        if (attrs[i2][0] === name) {
          return i2;
        }
      }
      return -1;
    };
    Token$3.prototype.attrPush = function attrPush(attrData) {
      if (this.attrs) {
        this.attrs.push(attrData);
      } else {
        this.attrs = [attrData];
      }
    };
    Token$3.prototype.attrSet = function attrSet(name, value) {
      var idx = this.attrIndex(name), attrData = [name, value];
      if (idx < 0) {
        this.attrPush(attrData);
      } else {
        this.attrs[idx] = attrData;
      }
    };
    Token$3.prototype.attrGet = function attrGet(name) {
      var idx = this.attrIndex(name), value = null;
      if (idx >= 0) {
        value = this.attrs[idx][1];
      }
      return value;
    };
    Token$3.prototype.attrJoin = function attrJoin(name, value) {
      var idx = this.attrIndex(name);
      if (idx < 0) {
        this.attrPush([name, value]);
      } else {
        this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
      }
    };
    var token = Token$3;
    var Token$2 = token;
    function StateCore(src, md, env) {
      this.src = src;
      this.env = env;
      this.tokens = [];
      this.inlineMode = false;
      this.md = md;
    }
    StateCore.prototype.Token = Token$2;
    var state_core = StateCore;
    var Ruler$2 = ruler;
    var _rules$2 = [
      ["normalize", normalize],
      ["block", block],
      ["inline", inline],
      ["linkify", linkify$1],
      ["replacements", replacements],
      ["smartquotes", smartquotes],
      // `text_join` finds `text_special` tokens (for escape sequences)
      // and joins them with the rest of the text
      ["text_join", text_join]
    ];
    function Core() {
      this.ruler = new Ruler$2();
      for (var i2 = 0; i2 < _rules$2.length; i2++) {
        this.ruler.push(_rules$2[i2][0], _rules$2[i2][1]);
      }
    }
    Core.prototype.process = function(state) {
      var i2, l, rules2;
      rules2 = this.ruler.getRules("");
      for (i2 = 0, l = rules2.length; i2 < l; i2++) {
        rules2[i2](state);
      }
    };
    Core.prototype.State = state_core;
    var parser_core = Core;
    var isSpace$a = utils$1.isSpace;
    function getLine(state, line) {
      var pos = state.bMarks[line] + state.tShift[line], max = state.eMarks[line];
      return state.src.slice(pos, max);
    }
    function escapedSplit(str2) {
      var result = [], pos = 0, max = str2.length, ch, isEscaped = false, lastPos = 0, current2 = "";
      ch = str2.charCodeAt(pos);
      while (pos < max) {
        if (ch === 124) {
          if (!isEscaped) {
            result.push(current2 + str2.substring(lastPos, pos));
            current2 = "";
            lastPos = pos + 1;
          } else {
            current2 += str2.substring(lastPos, pos - 1);
            lastPos = pos;
          }
        }
        isEscaped = ch === 92;
        pos++;
        ch = str2.charCodeAt(pos);
      }
      result.push(current2 + str2.substring(lastPos));
      return result;
    }
    var table = function table2(state, startLine, endLine, silent) {
      var ch, lineText, pos, i2, l, nextLine, columns, columnCount, token2, aligns, t, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
      if (startLine + 2 > endLine) {
        return false;
      }
      nextLine = startLine + 1;
      if (state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      firstCh = state.src.charCodeAt(pos++);
      if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
        return false;
      }
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      secondCh = state.src.charCodeAt(pos++);
      if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace$a(secondCh)) {
        return false;
      }
      if (firstCh === 45 && isSpace$a(secondCh)) {
        return false;
      }
      while (pos < state.eMarks[nextLine]) {
        ch = state.src.charCodeAt(pos);
        if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace$a(ch)) {
          return false;
        }
        pos++;
      }
      lineText = getLine(state, startLine + 1);
      columns = lineText.split("|");
      aligns = [];
      for (i2 = 0; i2 < columns.length; i2++) {
        t = columns[i2].trim();
        if (!t) {
          if (i2 === 0 || i2 === columns.length - 1) {
            continue;
          } else {
            return false;
          }
        }
        if (!/^:?-+:?$/.test(t)) {
          return false;
        }
        if (t.charCodeAt(t.length - 1) === 58) {
          aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
        } else if (t.charCodeAt(0) === 58) {
          aligns.push("left");
        } else {
          aligns.push("");
        }
      }
      lineText = getLine(state, startLine).trim();
      if (lineText.indexOf("|") === -1) {
        return false;
      }
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      columns = escapedSplit(lineText);
      if (columns.length && columns[0] === "")
        columns.shift();
      if (columns.length && columns[columns.length - 1] === "")
        columns.pop();
      columnCount = columns.length;
      if (columnCount === 0 || columnCount !== aligns.length) {
        return false;
      }
      if (silent) {
        return true;
      }
      oldParentType = state.parentType;
      state.parentType = "table";
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      token2 = state.push("table_open", "table", 1);
      token2.map = tableLines = [startLine, 0];
      token2 = state.push("thead_open", "thead", 1);
      token2.map = [startLine, startLine + 1];
      token2 = state.push("tr_open", "tr", 1);
      token2.map = [startLine, startLine + 1];
      for (i2 = 0; i2 < columns.length; i2++) {
        token2 = state.push("th_open", "th", 1);
        if (aligns[i2]) {
          token2.attrs = [["style", "text-align:" + aligns[i2]]];
        }
        token2 = state.push("inline", "", 0);
        token2.content = columns[i2].trim();
        token2.children = [];
        token2 = state.push("th_close", "th", -1);
      }
      token2 = state.push("tr_close", "tr", -1);
      token2 = state.push("thead_close", "thead", -1);
      for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        terminate = false;
        for (i2 = 0, l = terminatorRules.length; i2 < l; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        lineText = getLine(state, nextLine).trim();
        if (!lineText) {
          break;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        columns = escapedSplit(lineText);
        if (columns.length && columns[0] === "")
          columns.shift();
        if (columns.length && columns[columns.length - 1] === "")
          columns.pop();
        if (nextLine === startLine + 2) {
          token2 = state.push("tbody_open", "tbody", 1);
          token2.map = tbodyLines = [startLine + 2, 0];
        }
        token2 = state.push("tr_open", "tr", 1);
        token2.map = [nextLine, nextLine + 1];
        for (i2 = 0; i2 < columnCount; i2++) {
          token2 = state.push("td_open", "td", 1);
          if (aligns[i2]) {
            token2.attrs = [["style", "text-align:" + aligns[i2]]];
          }
          token2 = state.push("inline", "", 0);
          token2.content = columns[i2] ? columns[i2].trim() : "";
          token2.children = [];
          token2 = state.push("td_close", "td", -1);
        }
        token2 = state.push("tr_close", "tr", -1);
      }
      if (tbodyLines) {
        token2 = state.push("tbody_close", "tbody", -1);
        tbodyLines[1] = nextLine;
      }
      token2 = state.push("table_close", "table", -1);
      tableLines[1] = nextLine;
      state.parentType = oldParentType;
      state.line = nextLine;
      return true;
    };
    var code = function code2(state, startLine, endLine) {
      var nextLine, last, token2;
      if (state.sCount[startLine] - state.blkIndent < 4) {
        return false;
      }
      last = nextLine = startLine + 1;
      while (nextLine < endLine) {
        if (state.isEmpty(nextLine)) {
          nextLine++;
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          nextLine++;
          last = nextLine;
          continue;
        }
        break;
      }
      state.line = last;
      token2 = state.push("code_block", "code", 0);
      token2.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
      token2.map = [startLine, state.line];
      return true;
    };
    var fence = function fence2(state, startLine, endLine, silent) {
      var marker2, len, params, nextLine, mem, token2, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (pos + 3 > max) {
        return false;
      }
      marker2 = state.src.charCodeAt(pos);
      if (marker2 !== 126 && marker2 !== 96) {
        return false;
      }
      mem = pos;
      pos = state.skipChars(pos, marker2);
      len = pos - mem;
      if (len < 3) {
        return false;
      }
      markup = state.src.slice(mem, pos);
      params = state.src.slice(pos, max);
      if (marker2 === 96) {
        if (params.indexOf(String.fromCharCode(marker2)) >= 0) {
          return false;
        }
      }
      if (silent) {
        return true;
      }
      nextLine = startLine;
      for (; ; ) {
        nextLine++;
        if (nextLine >= endLine) {
          break;
        }
        pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos < max && state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.src.charCodeAt(pos) !== marker2) {
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          continue;
        }
        pos = state.skipChars(pos, marker2);
        if (pos - mem < len) {
          continue;
        }
        pos = state.skipSpaces(pos);
        if (pos < max) {
          continue;
        }
        haveEndMarker = true;
        break;
      }
      len = state.sCount[startLine];
      state.line = nextLine + (haveEndMarker ? 1 : 0);
      token2 = state.push("fence", "code", 0);
      token2.info = params;
      token2.content = state.getLines(startLine + 1, nextLine, len, true);
      token2.markup = markup;
      token2.map = [startLine, state.line];
      return true;
    };
    var isSpace$9 = utils$1.isSpace;
    var blockquote = function blockquote2(state, startLine, endLine, silent) {
      var adjustTab, ch, i2, initial, l, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token2, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 62) {
        return false;
      }
      if (silent) {
        return true;
      }
      oldBMarks = [];
      oldBSCount = [];
      oldSCount = [];
      oldTShift = [];
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      oldParentType = state.parentType;
      state.parentType = "blockquote";
      for (nextLine = startLine; nextLine < endLine; nextLine++) {
        isOutdented = state.sCount[nextLine] < state.blkIndent;
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos >= max) {
          break;
        }
        if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
          initial = state.sCount[nextLine] + 1;
          if (state.src.charCodeAt(pos) === 32) {
            pos++;
            initial++;
            adjustTab = false;
            spaceAfterMarker = true;
          } else if (state.src.charCodeAt(pos) === 9) {
            spaceAfterMarker = true;
            if ((state.bsCount[nextLine] + initial) % 4 === 3) {
              pos++;
              initial++;
              adjustTab = false;
            } else {
              adjustTab = true;
            }
          } else {
            spaceAfterMarker = false;
          }
          offset = initial;
          oldBMarks.push(state.bMarks[nextLine]);
          state.bMarks[nextLine] = pos;
          while (pos < max) {
            ch = state.src.charCodeAt(pos);
            if (isSpace$9(ch)) {
              if (ch === 9) {
                offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
              } else {
                offset++;
              }
            } else {
              break;
            }
            pos++;
          }
          lastLineEmpty = pos >= max;
          oldBSCount.push(state.bsCount[nextLine]);
          state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] = offset - initial;
          oldTShift.push(state.tShift[nextLine]);
          state.tShift[nextLine] = pos - state.bMarks[nextLine];
          continue;
        }
        if (lastLineEmpty) {
          break;
        }
        terminate = false;
        for (i2 = 0, l = terminatorRules.length; i2 < l; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          state.lineMax = nextLine;
          if (state.blkIndent !== 0) {
            oldBMarks.push(state.bMarks[nextLine]);
            oldBSCount.push(state.bsCount[nextLine]);
            oldTShift.push(state.tShift[nextLine]);
            oldSCount.push(state.sCount[nextLine]);
            state.sCount[nextLine] -= state.blkIndent;
          }
          break;
        }
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] = -1;
      }
      oldIndent = state.blkIndent;
      state.blkIndent = 0;
      token2 = state.push("blockquote_open", "blockquote", 1);
      token2.markup = ">";
      token2.map = lines = [startLine, 0];
      state.md.block.tokenize(state, startLine, nextLine);
      token2 = state.push("blockquote_close", "blockquote", -1);
      token2.markup = ">";
      state.lineMax = oldLineMax;
      state.parentType = oldParentType;
      lines[1] = state.line;
      for (i2 = 0; i2 < oldTShift.length; i2++) {
        state.bMarks[i2 + startLine] = oldBMarks[i2];
        state.tShift[i2 + startLine] = oldTShift[i2];
        state.sCount[i2 + startLine] = oldSCount[i2];
        state.bsCount[i2 + startLine] = oldBSCount[i2];
      }
      state.blkIndent = oldIndent;
      return true;
    };
    var isSpace$8 = utils$1.isSpace;
    var hr = function hr2(state, startLine, endLine, silent) {
      var marker2, cnt, ch, token2, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      marker2 = state.src.charCodeAt(pos++);
      if (marker2 !== 42 && marker2 !== 45 && marker2 !== 95) {
        return false;
      }
      cnt = 1;
      while (pos < max) {
        ch = state.src.charCodeAt(pos++);
        if (ch !== marker2 && !isSpace$8(ch)) {
          return false;
        }
        if (ch === marker2) {
          cnt++;
        }
      }
      if (cnt < 3) {
        return false;
      }
      if (silent) {
        return true;
      }
      state.line = startLine + 1;
      token2 = state.push("hr", "hr", 0);
      token2.map = [startLine, state.line];
      token2.markup = Array(cnt + 1).join(String.fromCharCode(marker2));
      return true;
    };
    var isSpace$7 = utils$1.isSpace;
    function skipBulletListMarker(state, startLine) {
      var marker2, pos, max, ch;
      pos = state.bMarks[startLine] + state.tShift[startLine];
      max = state.eMarks[startLine];
      marker2 = state.src.charCodeAt(pos++);
      if (marker2 !== 42 && marker2 !== 45 && marker2 !== 43) {
        return -1;
      }
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace$7(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function skipOrderedListMarker(state, startLine) {
      var ch, start = state.bMarks[startLine] + state.tShift[startLine], pos = start, max = state.eMarks[startLine];
      if (pos + 1 >= max) {
        return -1;
      }
      ch = state.src.charCodeAt(pos++);
      if (ch < 48 || ch > 57) {
        return -1;
      }
      for (; ; ) {
        if (pos >= max) {
          return -1;
        }
        ch = state.src.charCodeAt(pos++);
        if (ch >= 48 && ch <= 57) {
          if (pos - start >= 10) {
            return -1;
          }
          continue;
        }
        if (ch === 41 || ch === 46) {
          break;
        }
        return -1;
      }
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace$7(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function markTightParagraphs(state, idx) {
      var i2, l, level = state.level + 2;
      for (i2 = idx + 2, l = state.tokens.length - 2; i2 < l; i2++) {
        if (state.tokens[i2].level === level && state.tokens[i2].type === "paragraph_open") {
          state.tokens[i2 + 2].hidden = true;
          state.tokens[i2].hidden = true;
          i2 += 2;
        }
      }
    }
    var list = function list2(state, startLine, endLine, silent) {
      var ch, contentStart, i2, indent, indentAfterMarker, initial, isOrdered, itemLines, l, listLines, listTokIdx, markerCharCode, markerValue, max, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start, terminate, terminatorRules, token2, nextLine = startLine, isTerminatingParagraph = false, tight = true;
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.listIndent >= 0 && state.sCount[nextLine] - state.listIndent >= 4 && state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      if (silent && state.parentType === "paragraph") {
        if (state.sCount[nextLine] >= state.blkIndent) {
          isTerminatingParagraph = true;
        }
      }
      if ((posAfterMarker = skipOrderedListMarker(state, nextLine)) >= 0) {
        isOrdered = true;
        start = state.bMarks[nextLine] + state.tShift[nextLine];
        markerValue = Number(state.src.slice(start, posAfterMarker - 1));
        if (isTerminatingParagraph && markerValue !== 1)
          return false;
      } else if ((posAfterMarker = skipBulletListMarker(state, nextLine)) >= 0) {
        isOrdered = false;
      } else {
        return false;
      }
      if (isTerminatingParagraph) {
        if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine])
          return false;
      }
      if (silent) {
        return true;
      }
      markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
      listTokIdx = state.tokens.length;
      if (isOrdered) {
        token2 = state.push("ordered_list_open", "ol", 1);
        if (markerValue !== 1) {
          token2.attrs = [["start", markerValue]];
        }
      } else {
        token2 = state.push("bullet_list_open", "ul", 1);
      }
      token2.map = listLines = [nextLine, 0];
      token2.markup = String.fromCharCode(markerCharCode);
      prevEmptyEnd = false;
      terminatorRules = state.md.block.ruler.getRules("list");
      oldParentType = state.parentType;
      state.parentType = "list";
      while (nextLine < endLine) {
        pos = posAfterMarker;
        max = state.eMarks[nextLine];
        initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine]);
        while (pos < max) {
          ch = state.src.charCodeAt(pos);
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[nextLine]) % 4;
          } else if (ch === 32) {
            offset++;
          } else {
            break;
          }
          pos++;
        }
        contentStart = pos;
        if (contentStart >= max) {
          indentAfterMarker = 1;
        } else {
          indentAfterMarker = offset - initial;
        }
        if (indentAfterMarker > 4) {
          indentAfterMarker = 1;
        }
        indent = initial + indentAfterMarker;
        token2 = state.push("list_item_open", "li", 1);
        token2.markup = String.fromCharCode(markerCharCode);
        token2.map = itemLines = [nextLine, 0];
        if (isOrdered) {
          token2.info = state.src.slice(start, posAfterMarker - 1);
        }
        oldTight = state.tight;
        oldTShift = state.tShift[nextLine];
        oldSCount = state.sCount[nextLine];
        oldListIndent = state.listIndent;
        state.listIndent = state.blkIndent;
        state.blkIndent = indent;
        state.tight = true;
        state.tShift[nextLine] = contentStart - state.bMarks[nextLine];
        state.sCount[nextLine] = offset;
        if (contentStart >= max && state.isEmpty(nextLine + 1)) {
          state.line = Math.min(state.line + 2, endLine);
        } else {
          state.md.block.tokenize(state, nextLine, endLine, true);
        }
        if (!state.tight || prevEmptyEnd) {
          tight = false;
        }
        prevEmptyEnd = state.line - nextLine > 1 && state.isEmpty(state.line - 1);
        state.blkIndent = state.listIndent;
        state.listIndent = oldListIndent;
        state.tShift[nextLine] = oldTShift;
        state.sCount[nextLine] = oldSCount;
        state.tight = oldTight;
        token2 = state.push("list_item_close", "li", -1);
        token2.markup = String.fromCharCode(markerCharCode);
        nextLine = state.line;
        itemLines[1] = nextLine;
        if (nextLine >= endLine) {
          break;
        }
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        terminate = false;
        for (i2 = 0, l = terminatorRules.length; i2 < l; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        if (isOrdered) {
          posAfterMarker = skipOrderedListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
          start = state.bMarks[nextLine] + state.tShift[nextLine];
        } else {
          posAfterMarker = skipBulletListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
        }
        if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
          break;
        }
      }
      if (isOrdered) {
        token2 = state.push("ordered_list_close", "ol", -1);
      } else {
        token2 = state.push("bullet_list_close", "ul", -1);
      }
      token2.markup = String.fromCharCode(markerCharCode);
      listLines[1] = nextLine;
      state.line = nextLine;
      state.parentType = oldParentType;
      if (tight) {
        markTightParagraphs(state, listTokIdx);
      }
      return true;
    };
    var normalizeReference$2 = utils$1.normalizeReference;
    var isSpace$6 = utils$1.isSpace;
    var reference = function reference2(state, startLine, _endLine, silent) {
      var ch, destEndPos, destEndLineNo, endLine, href, i2, l, label, labelEnd, oldParentType, res, start, str2, terminate, terminatorRules, title2, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine], nextLine = startLine + 1;
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 91) {
        return false;
      }
      while (++pos < max) {
        if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
          if (pos + 1 === max) {
            return false;
          }
          if (state.src.charCodeAt(pos + 1) !== 58) {
            return false;
          }
          break;
        }
      }
      endLine = state.lineMax;
      terminatorRules = state.md.block.ruler.getRules("reference");
      oldParentType = state.parentType;
      state.parentType = "reference";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i2 = 0, l = terminatorRules.length; i2 < l; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      str2 = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      max = str2.length;
      for (pos = 1; pos < max; pos++) {
        ch = str2.charCodeAt(pos);
        if (ch === 91) {
          return false;
        } else if (ch === 93) {
          labelEnd = pos;
          break;
        } else if (ch === 10) {
          lines++;
        } else if (ch === 92) {
          pos++;
          if (pos < max && str2.charCodeAt(pos) === 10) {
            lines++;
          }
        }
      }
      if (labelEnd < 0 || str2.charCodeAt(labelEnd + 1) !== 58) {
        return false;
      }
      for (pos = labelEnd + 2; pos < max; pos++) {
        ch = str2.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace$6(ch))
          ;
        else {
          break;
        }
      }
      res = state.md.helpers.parseLinkDestination(str2, pos, max);
      if (!res.ok) {
        return false;
      }
      href = state.md.normalizeLink(res.str);
      if (!state.md.validateLink(href)) {
        return false;
      }
      pos = res.pos;
      lines += res.lines;
      destEndPos = pos;
      destEndLineNo = lines;
      start = pos;
      for (; pos < max; pos++) {
        ch = str2.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace$6(ch))
          ;
        else {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(str2, pos, max);
      if (pos < max && start !== pos && res.ok) {
        title2 = res.str;
        pos = res.pos;
        lines += res.lines;
      } else {
        title2 = "";
        pos = destEndPos;
        lines = destEndLineNo;
      }
      while (pos < max) {
        ch = str2.charCodeAt(pos);
        if (!isSpace$6(ch)) {
          break;
        }
        pos++;
      }
      if (pos < max && str2.charCodeAt(pos) !== 10) {
        if (title2) {
          title2 = "";
          pos = destEndPos;
          lines = destEndLineNo;
          while (pos < max) {
            ch = str2.charCodeAt(pos);
            if (!isSpace$6(ch)) {
              break;
            }
            pos++;
          }
        }
      }
      if (pos < max && str2.charCodeAt(pos) !== 10) {
        return false;
      }
      label = normalizeReference$2(str2.slice(1, labelEnd));
      if (!label) {
        return false;
      }
      if (silent) {
        return true;
      }
      if (typeof state.env.references === "undefined") {
        state.env.references = {};
      }
      if (typeof state.env.references[label] === "undefined") {
        state.env.references[label] = { title: title2, href };
      }
      state.parentType = oldParentType;
      state.line = startLine + lines + 1;
      return true;
    };
    var html_blocks = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "section",
      "source",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul"
    ];
    var html_re = {};
    var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
    var unquoted = "[^\"'=<>`\\x00-\\x20]+";
    var single_quoted = "'[^']*'";
    var double_quoted = '"[^"]*"';
    var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
    var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
    var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
    var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
    var comment = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
    var processing = "<[?][\\s\\S]*?[?]>";
    var declaration = "<![A-Z]+\\s+[^>]*>";
    var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
    var HTML_TAG_RE$1 = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
    var HTML_OPEN_CLOSE_TAG_RE$1 = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
    html_re.HTML_TAG_RE = HTML_TAG_RE$1;
    html_re.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE$1;
    var block_names = html_blocks;
    var HTML_OPEN_CLOSE_TAG_RE = html_re.HTML_OPEN_CLOSE_TAG_RE;
    var HTML_SEQUENCES = [
      [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
      [/^<!--/, /-->/, true],
      [/^<\?/, /\?>/, true],
      [/^<![A-Z]/, />/, true],
      [/^<!\[CDATA\[/, /\]\]>/, true],
      [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
      [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
    ];
    var html_block = function html_block2(state, startLine, endLine, silent) {
      var i2, nextLine, token2, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (!state.md.options.html) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      lineText = state.src.slice(pos, max);
      for (i2 = 0; i2 < HTML_SEQUENCES.length; i2++) {
        if (HTML_SEQUENCES[i2][0].test(lineText)) {
          break;
        }
      }
      if (i2 === HTML_SEQUENCES.length) {
        return false;
      }
      if (silent) {
        return HTML_SEQUENCES[i2][2];
      }
      nextLine = startLine + 1;
      if (!HTML_SEQUENCES[i2][1].test(lineText)) {
        for (; nextLine < endLine; nextLine++) {
          if (state.sCount[nextLine] < state.blkIndent) {
            break;
          }
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          lineText = state.src.slice(pos, max);
          if (HTML_SEQUENCES[i2][1].test(lineText)) {
            if (lineText.length !== 0) {
              nextLine++;
            }
            break;
          }
        }
      }
      state.line = nextLine;
      token2 = state.push("html_block", "", 0);
      token2.map = [startLine, nextLine];
      token2.content = state.getLines(startLine, nextLine, state.blkIndent, true);
      return true;
    };
    var isSpace$5 = utils$1.isSpace;
    var heading = function heading2(state, startLine, endLine, silent) {
      var ch, level, tmp, token2, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      ch = state.src.charCodeAt(pos);
      if (ch !== 35 || pos >= max) {
        return false;
      }
      level = 1;
      ch = state.src.charCodeAt(++pos);
      while (ch === 35 && pos < max && level <= 6) {
        level++;
        ch = state.src.charCodeAt(++pos);
      }
      if (level > 6 || pos < max && !isSpace$5(ch)) {
        return false;
      }
      if (silent) {
        return true;
      }
      max = state.skipSpacesBack(max, pos);
      tmp = state.skipCharsBack(max, 35, pos);
      if (tmp > pos && isSpace$5(state.src.charCodeAt(tmp - 1))) {
        max = tmp;
      }
      state.line = startLine + 1;
      token2 = state.push("heading_open", "h" + String(level), 1);
      token2.markup = "########".slice(0, level);
      token2.map = [startLine, state.line];
      token2 = state.push("inline", "", 0);
      token2.content = state.src.slice(pos, max).trim();
      token2.map = [startLine, state.line];
      token2.children = [];
      token2 = state.push("heading_close", "h" + String(level), -1);
      token2.markup = "########".slice(0, level);
      return true;
    };
    var lheading = function lheading2(state, startLine, endLine) {
      var content2, terminate, i2, l, token2, pos, max, level, marker2, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules("paragraph");
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] >= state.blkIndent) {
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          if (pos < max) {
            marker2 = state.src.charCodeAt(pos);
            if (marker2 === 45 || marker2 === 61) {
              pos = state.skipChars(pos, marker2);
              pos = state.skipSpaces(pos);
              if (pos >= max) {
                level = marker2 === 61 ? 1 : 2;
                break;
              }
            }
          }
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i2 = 0, l = terminatorRules.length; i2 < l; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      if (!level) {
        return false;
      }
      content2 = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine + 1;
      token2 = state.push("heading_open", "h" + String(level), 1);
      token2.markup = String.fromCharCode(marker2);
      token2.map = [startLine, state.line];
      token2 = state.push("inline", "", 0);
      token2.content = content2;
      token2.map = [startLine, state.line - 1];
      token2.children = [];
      token2 = state.push("heading_close", "h" + String(level), -1);
      token2.markup = String.fromCharCode(marker2);
      state.parentType = oldParentType;
      return true;
    };
    var paragraph = function paragraph2(state, startLine, endLine) {
      var content2, terminate, i2, l, token2, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph");
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i2 = 0, l = terminatorRules.length; i2 < l; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      content2 = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine;
      token2 = state.push("paragraph_open", "p", 1);
      token2.map = [startLine, state.line];
      token2 = state.push("inline", "", 0);
      token2.content = content2;
      token2.map = [startLine, state.line];
      token2.children = [];
      token2 = state.push("paragraph_close", "p", -1);
      state.parentType = oldParentType;
      return true;
    };
    var Token$1 = token;
    var isSpace$4 = utils$1.isSpace;
    function StateBlock(src, md, env, tokens) {
      var ch, s, start, pos, len, indent, offset, indent_found;
      this.src = src;
      this.md = md;
      this.env = env;
      this.tokens = tokens;
      this.bMarks = [];
      this.eMarks = [];
      this.tShift = [];
      this.sCount = [];
      this.bsCount = [];
      this.blkIndent = 0;
      this.line = 0;
      this.lineMax = 0;
      this.tight = false;
      this.ddIndent = -1;
      this.listIndent = -1;
      this.parentType = "root";
      this.level = 0;
      this.result = "";
      s = this.src;
      indent_found = false;
      for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
        ch = s.charCodeAt(pos);
        if (!indent_found) {
          if (isSpace$4(ch)) {
            indent++;
            if (ch === 9) {
              offset += 4 - offset % 4;
            } else {
              offset++;
            }
            continue;
          } else {
            indent_found = true;
          }
        }
        if (ch === 10 || pos === len - 1) {
          if (ch !== 10) {
            pos++;
          }
          this.bMarks.push(start);
          this.eMarks.push(pos);
          this.tShift.push(indent);
          this.sCount.push(offset);
          this.bsCount.push(0);
          indent_found = false;
          indent = 0;
          offset = 0;
          start = pos + 1;
        }
      }
      this.bMarks.push(s.length);
      this.eMarks.push(s.length);
      this.tShift.push(0);
      this.sCount.push(0);
      this.bsCount.push(0);
      this.lineMax = this.bMarks.length - 1;
    }
    StateBlock.prototype.push = function(type2, tag, nesting) {
      var token2 = new Token$1(type2, tag, nesting);
      token2.block = true;
      if (nesting < 0)
        this.level--;
      token2.level = this.level;
      if (nesting > 0)
        this.level++;
      this.tokens.push(token2);
      return token2;
    };
    StateBlock.prototype.isEmpty = function isEmpty(line) {
      return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
    };
    StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
      for (var max = this.lineMax; from < max; from++) {
        if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
          break;
        }
      }
      return from;
    };
    StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
      var ch;
      for (var max = this.src.length; pos < max; pos++) {
        ch = this.src.charCodeAt(pos);
        if (!isSpace$4(ch)) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (!isSpace$4(this.src.charCodeAt(--pos))) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipChars = function skipChars(pos, code2) {
      for (var max = this.src.length; pos < max; pos++) {
        if (this.src.charCodeAt(pos) !== code2) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (code2 !== this.src.charCodeAt(--pos)) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
      var i2, lineIndent, ch, first, last, queue2, lineStart, line = begin;
      if (begin >= end) {
        return "";
      }
      queue2 = new Array(end - begin);
      for (i2 = 0; line < end; line++, i2++) {
        lineIndent = 0;
        lineStart = first = this.bMarks[line];
        if (line + 1 < end || keepLastLF) {
          last = this.eMarks[line] + 1;
        } else {
          last = this.eMarks[line];
        }
        while (first < last && lineIndent < indent) {
          ch = this.src.charCodeAt(first);
          if (isSpace$4(ch)) {
            if (ch === 9) {
              lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
            } else {
              lineIndent++;
            }
          } else if (first - lineStart < this.tShift[line]) {
            lineIndent++;
          } else {
            break;
          }
          first++;
        }
        if (lineIndent > indent) {
          queue2[i2] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
        } else {
          queue2[i2] = this.src.slice(first, last);
        }
      }
      return queue2.join("");
    };
    StateBlock.prototype.Token = Token$1;
    var state_block = StateBlock;
    var Ruler$1 = ruler;
    var _rules$1 = [
      // First 2 params - rule name & source. Secondary array - list of rules,
      // which can be terminated by this one.
      ["table", table, ["paragraph", "reference"]],
      ["code", code],
      ["fence", fence, ["paragraph", "reference", "blockquote", "list"]],
      ["blockquote", blockquote, ["paragraph", "reference", "blockquote", "list"]],
      ["hr", hr, ["paragraph", "reference", "blockquote", "list"]],
      ["list", list, ["paragraph", "reference", "blockquote"]],
      ["reference", reference],
      ["html_block", html_block, ["paragraph", "reference", "blockquote"]],
      ["heading", heading, ["paragraph", "reference", "blockquote"]],
      ["lheading", lheading],
      ["paragraph", paragraph]
    ];
    function ParserBlock$1() {
      this.ruler = new Ruler$1();
      for (var i2 = 0; i2 < _rules$1.length; i2++) {
        this.ruler.push(_rules$1[i2][0], _rules$1[i2][1], { alt: (_rules$1[i2][2] || []).slice() });
      }
    }
    ParserBlock$1.prototype.tokenize = function(state, startLine, endLine) {
      var ok, i2, prevLine, rules2 = this.ruler.getRules(""), len = rules2.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
      while (line < endLine) {
        state.line = line = state.skipEmptyLines(line);
        if (line >= endLine) {
          break;
        }
        if (state.sCount[line] < state.blkIndent) {
          break;
        }
        if (state.level >= maxNesting) {
          state.line = endLine;
          break;
        }
        prevLine = state.line;
        for (i2 = 0; i2 < len; i2++) {
          ok = rules2[i2](state, line, endLine, false);
          if (ok) {
            if (prevLine >= state.line) {
              throw new Error("block rule didn't increment state.line");
            }
            break;
          }
        }
        if (!ok)
          throw new Error("none of the block rules matched");
        state.tight = !hasEmptyLines;
        if (state.isEmpty(state.line - 1)) {
          hasEmptyLines = true;
        }
        line = state.line;
        if (line < endLine && state.isEmpty(line)) {
          hasEmptyLines = true;
          line++;
          state.line = line;
        }
      }
    };
    ParserBlock$1.prototype.parse = function(src, md, env, outTokens) {
      var state;
      if (!src) {
        return;
      }
      state = new this.State(src, md, env, outTokens);
      this.tokenize(state, state.line, state.lineMax);
    };
    ParserBlock$1.prototype.State = state_block;
    var parser_block = ParserBlock$1;
    function isTerminatorChar(ch) {
      switch (ch) {
        case 10:
        case 33:
        case 35:
        case 36:
        case 37:
        case 38:
        case 42:
        case 43:
        case 45:
        case 58:
        case 60:
        case 61:
        case 62:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    var text = function text2(state, silent) {
      var pos = state.pos;
      while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
        pos++;
      }
      if (pos === state.pos) {
        return false;
      }
      if (!silent) {
        state.pending += state.src.slice(state.pos, pos);
      }
      state.pos = pos;
      return true;
    };
    var SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
    var linkify = function linkify2(state, silent) {
      var pos, max, match, proto, link2, url, fullUrl, token2;
      if (!state.md.options.linkify)
        return false;
      if (state.linkLevel > 0)
        return false;
      pos = state.pos;
      max = state.posMax;
      if (pos + 3 > max)
        return false;
      if (state.src.charCodeAt(pos) !== 58)
        return false;
      if (state.src.charCodeAt(pos + 1) !== 47)
        return false;
      if (state.src.charCodeAt(pos + 2) !== 47)
        return false;
      match = state.pending.match(SCHEME_RE);
      if (!match)
        return false;
      proto = match[1];
      link2 = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length));
      if (!link2)
        return false;
      url = link2.url;
      if (url.length <= proto.length)
        return false;
      url = url.replace(/\*+$/, "");
      fullUrl = state.md.normalizeLink(url);
      if (!state.md.validateLink(fullUrl))
        return false;
      if (!silent) {
        state.pending = state.pending.slice(0, -proto.length);
        token2 = state.push("link_open", "a", 1);
        token2.attrs = [["href", fullUrl]];
        token2.markup = "linkify";
        token2.info = "auto";
        token2 = state.push("text", "", 0);
        token2.content = state.md.normalizeLinkText(url);
        token2 = state.push("link_close", "a", -1);
        token2.markup = "linkify";
        token2.info = "auto";
      }
      state.pos += url.length - proto.length;
      return true;
    };
    var isSpace$3 = utils$1.isSpace;
    var newline = function newline2(state, silent) {
      var pmax, max, ws2, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 10) {
        return false;
      }
      pmax = state.pending.length - 1;
      max = state.posMax;
      if (!silent) {
        if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
          if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
            ws2 = pmax - 1;
            while (ws2 >= 1 && state.pending.charCodeAt(ws2 - 1) === 32)
              ws2--;
            state.pending = state.pending.slice(0, ws2);
            state.push("hardbreak", "br", 0);
          } else {
            state.pending = state.pending.slice(0, -1);
            state.push("softbreak", "br", 0);
          }
        } else {
          state.push("softbreak", "br", 0);
        }
      }
      pos++;
      while (pos < max && isSpace$3(state.src.charCodeAt(pos))) {
        pos++;
      }
      state.pos = pos;
      return true;
    };
    var isSpace$2 = utils$1.isSpace;
    var ESCAPED = [];
    for (var i = 0; i < 256; i++) {
      ESCAPED.push(0);
    }
    "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
      ESCAPED[ch.charCodeAt(0)] = 1;
    });
    var _escape = function escape2(state, silent) {
      var ch1, ch2, origStr, escapedStr, token2, pos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(pos) !== 92)
        return false;
      pos++;
      if (pos >= max)
        return false;
      ch1 = state.src.charCodeAt(pos);
      if (ch1 === 10) {
        if (!silent) {
          state.push("hardbreak", "br", 0);
        }
        pos++;
        while (pos < max) {
          ch1 = state.src.charCodeAt(pos);
          if (!isSpace$2(ch1))
            break;
          pos++;
        }
        state.pos = pos;
        return true;
      }
      escapedStr = state.src[pos];
      if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max) {
        ch2 = state.src.charCodeAt(pos + 1);
        if (ch2 >= 56320 && ch2 <= 57343) {
          escapedStr += state.src[pos + 1];
          pos++;
        }
      }
      origStr = "\\" + escapedStr;
      if (!silent) {
        token2 = state.push("text_special", "", 0);
        if (ch1 < 256 && ESCAPED[ch1] !== 0) {
          token2.content = escapedStr;
        } else {
          token2.content = origStr;
        }
        token2.markup = origStr;
        token2.info = "escape";
      }
      state.pos = pos + 1;
      return true;
    };
    var backticks = function backtick(state, silent) {
      var start, max, marker2, token2, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch = state.src.charCodeAt(pos);
      if (ch !== 96) {
        return false;
      }
      start = pos;
      pos++;
      max = state.posMax;
      while (pos < max && state.src.charCodeAt(pos) === 96) {
        pos++;
      }
      marker2 = state.src.slice(start, pos);
      openerLength = marker2.length;
      if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
        if (!silent)
          state.pending += marker2;
        state.pos += openerLength;
        return true;
      }
      matchEnd = pos;
      while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
        matchEnd = matchStart + 1;
        while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
          matchEnd++;
        }
        closerLength = matchEnd - matchStart;
        if (closerLength === openerLength) {
          if (!silent) {
            token2 = state.push("code_inline", "code", 0);
            token2.markup = marker2;
            token2.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
          }
          state.pos = matchEnd;
          return true;
        }
        state.backticks[closerLength] = matchStart;
      }
      state.backticksScanned = true;
      if (!silent)
        state.pending += marker2;
      state.pos += openerLength;
      return true;
    };
    var strikethrough = {};
    strikethrough.tokenize = function strikethrough2(state, silent) {
      var i2, scanned, token2, len, ch, start = state.pos, marker2 = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker2 !== 126) {
        return false;
      }
      scanned = state.scanDelims(state.pos, true);
      len = scanned.length;
      ch = String.fromCharCode(marker2);
      if (len < 2) {
        return false;
      }
      if (len % 2) {
        token2 = state.push("text", "", 0);
        token2.content = ch;
        len--;
      }
      for (i2 = 0; i2 < len; i2 += 2) {
        token2 = state.push("text", "", 0);
        token2.content = ch + ch;
        state.delimiters.push({
          marker: marker2,
          length: 0,
          // disable "rule of 3" length checks meant for emphasis
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess$1(state, delimiters) {
      var i2, j, startDelim, endDelim, token2, loneMarkers = [], max = delimiters.length;
      for (i2 = 0; i2 < max; i2++) {
        startDelim = delimiters[i2];
        if (startDelim.marker !== 126) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        token2 = state.tokens[startDelim.token];
        token2.type = "s_open";
        token2.tag = "s";
        token2.nesting = 1;
        token2.markup = "~~";
        token2.content = "";
        token2 = state.tokens[endDelim.token];
        token2.type = "s_close";
        token2.tag = "s";
        token2.nesting = -1;
        token2.markup = "~~";
        token2.content = "";
        if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
          loneMarkers.push(endDelim.token - 1);
        }
      }
      while (loneMarkers.length) {
        i2 = loneMarkers.pop();
        j = i2 + 1;
        while (j < state.tokens.length && state.tokens[j].type === "s_close") {
          j++;
        }
        j--;
        if (i2 !== j) {
          token2 = state.tokens[j];
          state.tokens[j] = state.tokens[i2];
          state.tokens[i2] = token2;
        }
      }
    }
    strikethrough.postProcess = function strikethrough2(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      postProcess$1(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess$1(state, tokens_meta[curr].delimiters);
        }
      }
    };
    var emphasis = {};
    emphasis.tokenize = function emphasis2(state, silent) {
      var i2, scanned, token2, start = state.pos, marker2 = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker2 !== 95 && marker2 !== 42) {
        return false;
      }
      scanned = state.scanDelims(state.pos, marker2 === 42);
      for (i2 = 0; i2 < scanned.length; i2++) {
        token2 = state.push("text", "", 0);
        token2.content = String.fromCharCode(marker2);
        state.delimiters.push({
          // Char code of the starting marker (number).
          //
          marker: marker2,
          // Total length of these series of delimiters.
          //
          length: scanned.length,
          // A position of the token this delimiter corresponds to.
          //
          token: state.tokens.length - 1,
          // If this delimiter is matched as a valid opener, `end` will be
          // equal to its position, otherwise it's `-1`.
          //
          end: -1,
          // Boolean flags that determine if this delimiter could open or close
          // an emphasis.
          //
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i2, startDelim, endDelim, token2, ch, isStrong, max = delimiters.length;
      for (i2 = max - 1; i2 >= 0; i2--) {
        startDelim = delimiters[i2];
        if (startDelim.marker !== 95 && startDelim.marker !== 42) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        isStrong = i2 > 0 && delimiters[i2 - 1].end === startDelim.end + 1 && // check that first two markers match and adjacent
        delimiters[i2 - 1].marker === startDelim.marker && delimiters[i2 - 1].token === startDelim.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
        delimiters[startDelim.end + 1].token === endDelim.token + 1;
        ch = String.fromCharCode(startDelim.marker);
        token2 = state.tokens[startDelim.token];
        token2.type = isStrong ? "strong_open" : "em_open";
        token2.tag = isStrong ? "strong" : "em";
        token2.nesting = 1;
        token2.markup = isStrong ? ch + ch : ch;
        token2.content = "";
        token2 = state.tokens[endDelim.token];
        token2.type = isStrong ? "strong_close" : "em_close";
        token2.tag = isStrong ? "strong" : "em";
        token2.nesting = -1;
        token2.markup = isStrong ? ch + ch : ch;
        token2.content = "";
        if (isStrong) {
          state.tokens[delimiters[i2 - 1].token].content = "";
          state.tokens[delimiters[startDelim.end + 1].token].content = "";
          i2--;
        }
      }
    }
    emphasis.postProcess = function emphasis2(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
    var normalizeReference$1 = utils$1.normalizeReference;
    var isSpace$1 = utils$1.isSpace;
    var link = function link2(state, silent) {
      var attrs, code2, label, labelEnd, labelStart, pos, res, ref2, token2, href = "", title2 = "", oldPos = state.pos, max = state.posMax, start = state.pos, parseReference = true;
      if (state.src.charCodeAt(state.pos) !== 91) {
        return false;
      }
      labelStart = state.pos + 1;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        parseReference = false;
        pos++;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace$1(code2) && code2 !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
          start = pos;
          for (; pos < max; pos++) {
            code2 = state.src.charCodeAt(pos);
            if (!isSpace$1(code2) && code2 !== 10) {
              break;
            }
          }
          res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
          if (pos < max && start !== pos && res.ok) {
            title2 = res.str;
            pos = res.pos;
            for (; pos < max; pos++) {
              code2 = state.src.charCodeAt(pos);
              if (!isSpace$1(code2) && code2 !== 10) {
                break;
              }
            }
          }
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          parseReference = true;
        }
        pos++;
      }
      if (parseReference) {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref2 = state.env.references[normalizeReference$1(label)];
        if (!ref2) {
          state.pos = oldPos;
          return false;
        }
        href = ref2.href;
        title2 = ref2.title;
      }
      if (!silent) {
        state.pos = labelStart;
        state.posMax = labelEnd;
        token2 = state.push("link_open", "a", 1);
        token2.attrs = attrs = [["href", href]];
        if (title2) {
          attrs.push(["title", title2]);
        }
        state.linkLevel++;
        state.md.inline.tokenize(state);
        state.linkLevel--;
        token2 = state.push("link_close", "a", -1);
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    };
    var normalizeReference = utils$1.normalizeReference;
    var isSpace = utils$1.isSpace;
    var image = function image2(state, silent) {
      var attrs, code2, content2, label, labelEnd, labelStart, pos, ref2, res, title2, token2, tokens, start, href = "", oldPos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(state.pos) !== 33) {
        return false;
      }
      if (state.src.charCodeAt(state.pos + 1) !== 91) {
        return false;
      }
      labelStart = state.pos + 2;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        pos++;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
        }
        start = pos;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          title2 = res.str;
          pos = res.pos;
          for (; pos < max; pos++) {
            code2 = state.src.charCodeAt(pos);
            if (!isSpace(code2) && code2 !== 10) {
              break;
            }
          }
        } else {
          title2 = "";
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          state.pos = oldPos;
          return false;
        }
        pos++;
      } else {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref2 = state.env.references[normalizeReference(label)];
        if (!ref2) {
          state.pos = oldPos;
          return false;
        }
        href = ref2.href;
        title2 = ref2.title;
      }
      if (!silent) {
        content2 = state.src.slice(labelStart, labelEnd);
        state.md.inline.parse(
          content2,
          state.md,
          state.env,
          tokens = []
        );
        token2 = state.push("image", "img", 0);
        token2.attrs = attrs = [["src", href], ["alt", ""]];
        token2.children = tokens;
        token2.content = content2;
        if (title2) {
          attrs.push(["title", title2]);
        }
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    };
    var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
    var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
    var autolink = function autolink2(state, silent) {
      var url, fullUrl, token2, ch, start, max, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      start = state.pos;
      max = state.posMax;
      for (; ; ) {
        if (++pos >= max)
          return false;
        ch = state.src.charCodeAt(pos);
        if (ch === 60)
          return false;
        if (ch === 62)
          break;
      }
      url = state.src.slice(start + 1, pos);
      if (AUTOLINK_RE.test(url)) {
        fullUrl = state.md.normalizeLink(url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token2 = state.push("link_open", "a", 1);
          token2.attrs = [["href", fullUrl]];
          token2.markup = "autolink";
          token2.info = "auto";
          token2 = state.push("text", "", 0);
          token2.content = state.md.normalizeLinkText(url);
          token2 = state.push("link_close", "a", -1);
          token2.markup = "autolink";
          token2.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      if (EMAIL_RE.test(url)) {
        fullUrl = state.md.normalizeLink("mailto:" + url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token2 = state.push("link_open", "a", 1);
          token2.attrs = [["href", fullUrl]];
          token2.markup = "autolink";
          token2.info = "auto";
          token2 = state.push("text", "", 0);
          token2.content = state.md.normalizeLinkText(url);
          token2 = state.push("link_close", "a", -1);
          token2.markup = "autolink";
          token2.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      return false;
    };
    var HTML_TAG_RE = html_re.HTML_TAG_RE;
    function isLinkOpen(str2) {
      return /^<a[>\s]/i.test(str2);
    }
    function isLinkClose(str2) {
      return /^<\/a\s*>/i.test(str2);
    }
    function isLetter(ch) {
      var lc = ch | 32;
      return lc >= 97 && lc <= 122;
    }
    var html_inline = function html_inline2(state, silent) {
      var ch, match, max, token2, pos = state.pos;
      if (!state.md.options.html) {
        return false;
      }
      max = state.posMax;
      if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
        return false;
      }
      ch = state.src.charCodeAt(pos + 1);
      if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
        return false;
      }
      match = state.src.slice(pos).match(HTML_TAG_RE);
      if (!match) {
        return false;
      }
      if (!silent) {
        token2 = state.push("html_inline", "", 0);
        token2.content = match[0];
        if (isLinkOpen(token2.content))
          state.linkLevel++;
        if (isLinkClose(token2.content))
          state.linkLevel--;
      }
      state.pos += match[0].length;
      return true;
    };
    var entities = entities$1;
    var has$1 = utils$1.has;
    var isValidEntityCode = utils$1.isValidEntityCode;
    var fromCodePoint = utils$1.fromCodePoint;
    var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
    var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
    var entity = function entity2(state, silent) {
      var ch, code2, match, token2, pos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(pos) !== 38)
        return false;
      if (pos + 1 >= max)
        return false;
      ch = state.src.charCodeAt(pos + 1);
      if (ch === 35) {
        match = state.src.slice(pos).match(DIGITAL_RE);
        if (match) {
          if (!silent) {
            code2 = match[1][0].toLowerCase() === "x" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            token2 = state.push("text_special", "", 0);
            token2.content = isValidEntityCode(code2) ? fromCodePoint(code2) : fromCodePoint(65533);
            token2.markup = match[0];
            token2.info = "entity";
          }
          state.pos += match[0].length;
          return true;
        }
      } else {
        match = state.src.slice(pos).match(NAMED_RE);
        if (match) {
          if (has$1(entities, match[1])) {
            if (!silent) {
              token2 = state.push("text_special", "", 0);
              token2.content = entities[match[1]];
              token2.markup = match[0];
              token2.info = "entity";
            }
            state.pos += match[0].length;
            return true;
          }
        }
      }
      return false;
    };
    function processDelimiters(delimiters) {
      var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max = delimiters.length;
      if (!max)
        return;
      var headerIdx = 0;
      var lastTokenIdx = -2;
      var jumps = [];
      for (closerIdx = 0; closerIdx < max; closerIdx++) {
        closer = delimiters[closerIdx];
        jumps.push(0);
        if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
          headerIdx = closerIdx;
        }
        lastTokenIdx = closer.token;
        closer.length = closer.length || 0;
        if (!closer.close)
          continue;
        if (!openersBottom.hasOwnProperty(closer.marker)) {
          openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
        }
        minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
        openerIdx = headerIdx - jumps[headerIdx] - 1;
        newMinOpenerIdx = openerIdx;
        for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
          opener = delimiters[openerIdx];
          if (opener.marker !== closer.marker)
            continue;
          if (opener.open && opener.end < 0) {
            isOddMatch = false;
            if (opener.close || closer.open) {
              if ((opener.length + closer.length) % 3 === 0) {
                if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                  isOddMatch = true;
                }
              }
            }
            if (!isOddMatch) {
              lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
              jumps[closerIdx] = closerIdx - openerIdx + lastJump;
              jumps[openerIdx] = lastJump;
              closer.open = false;
              opener.end = closerIdx;
              opener.close = false;
              newMinOpenerIdx = -1;
              lastTokenIdx = -2;
              break;
            }
          }
        }
        if (newMinOpenerIdx !== -1) {
          openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
        }
      }
    }
    var balance_pairs = function link_pairs(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      processDelimiters(state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          processDelimiters(tokens_meta[curr].delimiters);
        }
      }
    };
    var fragments_join = function fragments_join2(state) {
      var curr, last, level = 0, tokens = state.tokens, max = state.tokens.length;
      for (curr = last = 0; curr < max; curr++) {
        if (tokens[curr].nesting < 0)
          level--;
        tokens[curr].level = level;
        if (tokens[curr].nesting > 0)
          level++;
        if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
          tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
        } else {
          if (curr !== last) {
            tokens[last] = tokens[curr];
          }
          last++;
        }
      }
      if (curr !== last) {
        tokens.length = last;
      }
    };
    var Token = token;
    var isWhiteSpace = utils$1.isWhiteSpace;
    var isPunctChar = utils$1.isPunctChar;
    var isMdAsciiPunct = utils$1.isMdAsciiPunct;
    function StateInline(src, md, env, outTokens) {
      this.src = src;
      this.env = env;
      this.md = md;
      this.tokens = outTokens;
      this.tokens_meta = Array(outTokens.length);
      this.pos = 0;
      this.posMax = this.src.length;
      this.level = 0;
      this.pending = "";
      this.pendingLevel = 0;
      this.cache = {};
      this.delimiters = [];
      this._prev_delimiters = [];
      this.backticks = {};
      this.backticksScanned = false;
      this.linkLevel = 0;
    }
    StateInline.prototype.pushPending = function() {
      var token2 = new Token("text", "", 0);
      token2.content = this.pending;
      token2.level = this.pendingLevel;
      this.tokens.push(token2);
      this.pending = "";
      return token2;
    };
    StateInline.prototype.push = function(type2, tag, nesting) {
      if (this.pending) {
        this.pushPending();
      }
      var token2 = new Token(type2, tag, nesting);
      var token_meta = null;
      if (nesting < 0) {
        this.level--;
        this.delimiters = this._prev_delimiters.pop();
      }
      token2.level = this.level;
      if (nesting > 0) {
        this.level++;
        this._prev_delimiters.push(this.delimiters);
        this.delimiters = [];
        token_meta = { delimiters: this.delimiters };
      }
      this.pendingLevel = this.level;
      this.tokens.push(token2);
      this.tokens_meta.push(token_meta);
      return token2;
    };
    StateInline.prototype.scanDelims = function(start, canSplitWord) {
      var pos = start, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max = this.posMax, marker2 = this.src.charCodeAt(start);
      lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
      while (pos < max && this.src.charCodeAt(pos) === marker2) {
        pos++;
      }
      count = pos - start;
      nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);
      if (isNextWhiteSpace) {
        left_flanking = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          left_flanking = false;
        }
      }
      if (isLastWhiteSpace) {
        right_flanking = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          right_flanking = false;
        }
      }
      if (!canSplitWord) {
        can_open = left_flanking && (!right_flanking || isLastPunctChar);
        can_close = right_flanking && (!left_flanking || isNextPunctChar);
      } else {
        can_open = left_flanking;
        can_close = right_flanking;
      }
      return {
        can_open,
        can_close,
        length: count
      };
    };
    StateInline.prototype.Token = Token;
    var state_inline = StateInline;
    var Ruler = ruler;
    var _rules = [
      ["text", text],
      ["linkify", linkify],
      ["newline", newline],
      ["escape", _escape],
      ["backticks", backticks],
      ["strikethrough", strikethrough.tokenize],
      ["emphasis", emphasis.tokenize],
      ["link", link],
      ["image", image],
      ["autolink", autolink],
      ["html_inline", html_inline],
      ["entity", entity]
    ];
    var _rules2 = [
      ["balance_pairs", balance_pairs],
      ["strikethrough", strikethrough.postProcess],
      ["emphasis", emphasis.postProcess],
      // rules for pairs separate '**' into its own text tokens, which may be left unused,
      // rule below merges unused segments back with the rest of the text
      ["fragments_join", fragments_join]
    ];
    function ParserInline$1() {
      var i2;
      this.ruler = new Ruler();
      for (i2 = 0; i2 < _rules.length; i2++) {
        this.ruler.push(_rules[i2][0], _rules[i2][1]);
      }
      this.ruler2 = new Ruler();
      for (i2 = 0; i2 < _rules2.length; i2++) {
        this.ruler2.push(_rules2[i2][0], _rules2[i2][1]);
      }
    }
    ParserInline$1.prototype.skipToken = function(state) {
      var ok, i2, pos = state.pos, rules2 = this.ruler.getRules(""), len = rules2.length, maxNesting = state.md.options.maxNesting, cache2 = state.cache;
      if (typeof cache2[pos] !== "undefined") {
        state.pos = cache2[pos];
        return;
      }
      if (state.level < maxNesting) {
        for (i2 = 0; i2 < len; i2++) {
          state.level++;
          ok = rules2[i2](state, true);
          state.level--;
          if (ok) {
            if (pos >= state.pos) {
              throw new Error("inline rule didn't increment state.pos");
            }
            break;
          }
        }
      } else {
        state.pos = state.posMax;
      }
      if (!ok) {
        state.pos++;
      }
      cache2[pos] = state.pos;
    };
    ParserInline$1.prototype.tokenize = function(state) {
      var ok, i2, prevPos, rules2 = this.ruler.getRules(""), len = rules2.length, end = state.posMax, maxNesting = state.md.options.maxNesting;
      while (state.pos < end) {
        prevPos = state.pos;
        if (state.level < maxNesting) {
          for (i2 = 0; i2 < len; i2++) {
            ok = rules2[i2](state, false);
            if (ok) {
              if (prevPos >= state.pos) {
                throw new Error("inline rule didn't increment state.pos");
              }
              break;
            }
          }
        }
        if (ok) {
          if (state.pos >= end) {
            break;
          }
          continue;
        }
        state.pending += state.src[state.pos++];
      }
      if (state.pending) {
        state.pushPending();
      }
    };
    ParserInline$1.prototype.parse = function(str2, md, env, outTokens) {
      var i2, rules2, len;
      var state = new this.State(str2, md, env, outTokens);
      this.tokenize(state);
      rules2 = this.ruler2.getRules("");
      len = rules2.length;
      for (i2 = 0; i2 < len; i2++) {
        rules2[i2](state);
      }
    };
    ParserInline$1.prototype.State = state_inline;
    var parser_inline = ParserInline$1;
    var re;
    var hasRequiredRe;
    function requireRe() {
      if (hasRequiredRe)
        return re;
      hasRequiredRe = 1;
      re = function(opts) {
        var re2 = {};
        opts = opts || {};
        re2.src_Any = requireRegex$3().source;
        re2.src_Cc = requireRegex$2().source;
        re2.src_Z = requireRegex().source;
        re2.src_P = regex$4.source;
        re2.src_ZPCc = [re2.src_Z, re2.src_P, re2.src_Cc].join("|");
        re2.src_ZCc = [re2.src_Z, re2.src_Cc].join("|");
        var text_separators = "[><｜]";
        re2.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re2.src_ZPCc + ")" + re2.src_Any + ")";
        re2.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
        re2.src_auth = "(?:(?:(?!" + re2.src_ZCc + "|[@/\\[\\]()]).)+@)?";
        re2.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
        re2.src_host_terminator = "(?=$|" + text_separators + "|" + re2.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re2.src_ZPCc + "))";
        re2.src_path = "(?:[/?#](?:(?!" + re2.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re2.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re2.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re2.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re2.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re2.src_ZCc + "|[']).)+\\'|\\'(?=" + re2.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re2.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re2.src_ZCc + "|$)|;(?!" + re2.src_ZCc + "|$)|\\!+(?!" + re2.src_ZCc + "|[!]|$)|\\?(?!" + re2.src_ZCc + "|[?]|$))+|\\/)?";
        re2.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
        re2.src_xn = "xn--[a-z0-9\\-]{1,59}";
        re2.src_domain_root = // Allow letters & digits (http://test1)
        "(?:" + re2.src_xn + "|" + re2.src_pseudo_letter + "{1,63})";
        re2.src_domain = "(?:" + re2.src_xn + "|(?:" + re2.src_pseudo_letter + ")|(?:" + re2.src_pseudo_letter + "(?:-|" + re2.src_pseudo_letter + "){0,61}" + re2.src_pseudo_letter + "))";
        re2.src_host = "(?:(?:(?:(?:" + re2.src_domain + ")\\.)*" + re2.src_domain + "))";
        re2.tpl_host_fuzzy = "(?:" + re2.src_ip4 + "|(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%)))";
        re2.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%))";
        re2.src_host_strict = re2.src_host + re2.src_host_terminator;
        re2.tpl_host_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_host_terminator;
        re2.src_host_port_strict = re2.src_host + re2.src_port + re2.src_host_terminator;
        re2.tpl_host_port_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_port + re2.src_host_terminator;
        re2.tpl_host_port_no_ip_fuzzy_strict = re2.tpl_host_no_ip_fuzzy + re2.src_port + re2.src_host_terminator;
        re2.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re2.src_ZPCc + "|>|$))";
        re2.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re2.src_ZCc + ")(" + re2.src_email_name + "@" + re2.tpl_host_fuzzy_strict + ")";
        re2.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
        // but can start with > (markdown blockquote)
        "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + re2.src_ZPCc + "))((?![$+<=>^`|｜])" + re2.tpl_host_port_fuzzy_strict + re2.src_path + ")";
        re2.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
        // but can start with > (markdown blockquote)
        "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + re2.src_ZPCc + "))((?![$+<=>^`|｜])" + re2.tpl_host_port_no_ip_fuzzy_strict + re2.src_path + ")";
        return re2;
      };
      return re;
    }
    function assign(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source2) {
        if (!source2) {
          return;
        }
        Object.keys(source2).forEach(function(key) {
          obj[key] = source2[key];
        });
      });
      return obj;
    }
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class(obj) === "[object String]";
    }
    function isObject(obj) {
      return _class(obj) === "[object Object]";
    }
    function isRegExp(obj) {
      return _class(obj) === "[object RegExp]";
    }
    function isFunction(obj) {
      return _class(obj) === "[object Function]";
    }
    function escapeRE(str2) {
      return str2.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
    }
    var defaultOptions$1 = {
      fuzzyLink: true,
      fuzzyEmail: true,
      fuzzyIP: false
    };
    function isOptionsObj(obj) {
      return Object.keys(obj || {}).reduce(function(acc, k) {
        return acc || defaultOptions$1.hasOwnProperty(k);
      }, false);
    }
    var defaultSchemas = {
      "http:": {
        validate: function(text2, pos, self2) {
          var tail = text2.slice(pos);
          if (!self2.re.http) {
            self2.re.http = new RegExp(
              "^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path,
              "i"
            );
          }
          if (self2.re.http.test(tail)) {
            return tail.match(self2.re.http)[0].length;
          }
          return 0;
        }
      },
      "https:": "http:",
      "ftp:": "http:",
      "//": {
        validate: function(text2, pos, self2) {
          var tail = text2.slice(pos);
          if (!self2.re.no_http) {
            self2.re.no_http = new RegExp(
              "^" + self2.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
              // with code comments
              "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path,
              "i"
            );
          }
          if (self2.re.no_http.test(tail)) {
            if (pos >= 3 && text2[pos - 3] === ":") {
              return 0;
            }
            if (pos >= 3 && text2[pos - 3] === "/") {
              return 0;
            }
            return tail.match(self2.re.no_http)[0].length;
          }
          return 0;
        }
      },
      "mailto:": {
        validate: function(text2, pos, self2) {
          var tail = text2.slice(pos);
          if (!self2.re.mailto) {
            self2.re.mailto = new RegExp(
              "^" + self2.re.src_email_name + "@" + self2.re.src_host_strict,
              "i"
            );
          }
          if (self2.re.mailto.test(tail)) {
            return tail.match(self2.re.mailto)[0].length;
          }
          return 0;
        }
      }
    };
    var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
    var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");
    function resetScanCache(self2) {
      self2.__index__ = -1;
      self2.__text_cache__ = "";
    }
    function createValidator(re2) {
      return function(text2, pos) {
        var tail = text2.slice(pos);
        if (re2.test(tail)) {
          return tail.match(re2)[0].length;
        }
        return 0;
      };
    }
    function createNormalizer() {
      return function(match, self2) {
        self2.normalize(match);
      };
    }
    function compile$1(self2) {
      var re2 = self2.re = requireRe()(self2.__opts__);
      var tlds = self2.__tlds__.slice();
      self2.onCompile();
      if (!self2.__tlds_replaced__) {
        tlds.push(tlds_2ch_src_re);
      }
      tlds.push(re2.src_xn);
      re2.src_tlds = tlds.join("|");
      function untpl(tpl) {
        return tpl.replace("%TLDS%", re2.src_tlds);
      }
      re2.email_fuzzy = RegExp(untpl(re2.tpl_email_fuzzy), "i");
      re2.link_fuzzy = RegExp(untpl(re2.tpl_link_fuzzy), "i");
      re2.link_no_ip_fuzzy = RegExp(untpl(re2.tpl_link_no_ip_fuzzy), "i");
      re2.host_fuzzy_test = RegExp(untpl(re2.tpl_host_fuzzy_test), "i");
      var aliases2 = [];
      self2.__compiled__ = {};
      function schemaError(name, val) {
        throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
      }
      Object.keys(self2.__schemas__).forEach(function(name) {
        var val = self2.__schemas__[name];
        if (val === null) {
          return;
        }
        var compiled = { validate: null, link: null };
        self2.__compiled__[name] = compiled;
        if (isObject(val)) {
          if (isRegExp(val.validate)) {
            compiled.validate = createValidator(val.validate);
          } else if (isFunction(val.validate)) {
            compiled.validate = val.validate;
          } else {
            schemaError(name, val);
          }
          if (isFunction(val.normalize)) {
            compiled.normalize = val.normalize;
          } else if (!val.normalize) {
            compiled.normalize = createNormalizer();
          } else {
            schemaError(name, val);
          }
          return;
        }
        if (isString(val)) {
          aliases2.push(name);
          return;
        }
        schemaError(name, val);
      });
      aliases2.forEach(function(alias) {
        if (!self2.__compiled__[self2.__schemas__[alias]]) {
          return;
        }
        self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
        self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
      });
      self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
      var slist = Object.keys(self2.__compiled__).filter(function(name) {
        return name.length > 0 && self2.__compiled__[name];
      }).map(escapeRE).join("|");
      self2.re.schema_test = RegExp("(^|(?!_)(?:[><｜]|" + re2.src_ZPCc + "))(" + slist + ")", "i");
      self2.re.schema_search = RegExp("(^|(?!_)(?:[><｜]|" + re2.src_ZPCc + "))(" + slist + ")", "ig");
      self2.re.schema_at_start = RegExp("^" + self2.re.schema_search.source, "i");
      self2.re.pretest = RegExp(
        "(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@",
        "i"
      );
      resetScanCache(self2);
    }
    function Match(self2, shift) {
      var start = self2.__index__, end = self2.__last_index__, text2 = self2.__text_cache__.slice(start, end);
      this.schema = self2.__schema__.toLowerCase();
      this.index = start + shift;
      this.lastIndex = end + shift;
      this.raw = text2;
      this.text = text2;
      this.url = text2;
    }
    function createMatch(self2, shift) {
      var match = new Match(self2, shift);
      self2.__compiled__[match.schema].normalize(match, self2);
      return match;
    }
    function LinkifyIt$1(schemas, options) {
      if (!(this instanceof LinkifyIt$1)) {
        return new LinkifyIt$1(schemas, options);
      }
      if (!options) {
        if (isOptionsObj(schemas)) {
          options = schemas;
          schemas = {};
        }
      }
      this.__opts__ = assign({}, defaultOptions$1, options);
      this.__index__ = -1;
      this.__last_index__ = -1;
      this.__schema__ = "";
      this.__text_cache__ = "";
      this.__schemas__ = assign({}, defaultSchemas, schemas);
      this.__compiled__ = {};
      this.__tlds__ = tlds_default;
      this.__tlds_replaced__ = false;
      this.re = {};
      compile$1(this);
    }
    LinkifyIt$1.prototype.add = function add2(schema2, definition) {
      this.__schemas__[schema2] = definition;
      compile$1(this);
      return this;
    };
    LinkifyIt$1.prototype.set = function set2(options) {
      this.__opts__ = assign(this.__opts__, options);
      return this;
    };
    LinkifyIt$1.prototype.test = function test(text2) {
      this.__text_cache__ = text2;
      this.__index__ = -1;
      if (!text2.length) {
        return false;
      }
      var m, ml, me, len, shift, next2, re2, tld_pos, at_pos;
      if (this.re.schema_test.test(text2)) {
        re2 = this.re.schema_search;
        re2.lastIndex = 0;
        while ((m = re2.exec(text2)) !== null) {
          len = this.testSchemaAt(text2, m[2], re2.lastIndex);
          if (len) {
            this.__schema__ = m[2];
            this.__index__ = m.index + m[1].length;
            this.__last_index__ = m.index + m[0].length + len;
            break;
          }
        }
      }
      if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
        tld_pos = text2.search(this.re.host_fuzzy_test);
        if (tld_pos >= 0) {
          if (this.__index__ < 0 || tld_pos < this.__index__) {
            if ((ml = text2.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
              shift = ml.index + ml[1].length;
              if (this.__index__ < 0 || shift < this.__index__) {
                this.__schema__ = "";
                this.__index__ = shift;
                this.__last_index__ = ml.index + ml[0].length;
              }
            }
          }
        }
      }
      if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
        at_pos = text2.indexOf("@");
        if (at_pos >= 0) {
          if ((me = text2.match(this.re.email_fuzzy)) !== null) {
            shift = me.index + me[1].length;
            next2 = me.index + me[0].length;
            if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next2 > this.__last_index__) {
              this.__schema__ = "mailto:";
              this.__index__ = shift;
              this.__last_index__ = next2;
            }
          }
        }
      }
      return this.__index__ >= 0;
    };
    LinkifyIt$1.prototype.pretest = function pretest(text2) {
      return this.re.pretest.test(text2);
    };
    LinkifyIt$1.prototype.testSchemaAt = function testSchemaAt(text2, schema2, pos) {
      if (!this.__compiled__[schema2.toLowerCase()]) {
        return 0;
      }
      return this.__compiled__[schema2.toLowerCase()].validate(text2, pos, this);
    };
    LinkifyIt$1.prototype.match = function match(text2) {
      var shift = 0, result = [];
      if (this.__index__ >= 0 && this.__text_cache__ === text2) {
        result.push(createMatch(this, shift));
        shift = this.__last_index__;
      }
      var tail = shift ? text2.slice(shift) : text2;
      while (this.test(tail)) {
        result.push(createMatch(this, shift));
        tail = tail.slice(this.__last_index__);
        shift += this.__last_index__;
      }
      if (result.length) {
        return result;
      }
      return null;
    };
    LinkifyIt$1.prototype.matchAtStart = function matchAtStart(text2) {
      this.__text_cache__ = text2;
      this.__index__ = -1;
      if (!text2.length)
        return null;
      var m = this.re.schema_at_start.exec(text2);
      if (!m)
        return null;
      var len = this.testSchemaAt(text2, m[2], m[0].length);
      if (!len)
        return null;
      this.__schema__ = m[2];
      this.__index__ = m.index + m[1].length;
      this.__last_index__ = m.index + m[0].length + len;
      return createMatch(this, 0);
    };
    LinkifyIt$1.prototype.tlds = function tlds(list2, keepOld) {
      list2 = Array.isArray(list2) ? list2 : [list2];
      if (!keepOld) {
        this.__tlds__ = list2.slice();
        this.__tlds_replaced__ = true;
        compile$1(this);
        return this;
      }
      this.__tlds__ = this.__tlds__.concat(list2).sort().filter(function(el2, idx, arr) {
        return el2 !== arr[idx - 1];
      }).reverse();
      compile$1(this);
      return this;
    };
    LinkifyIt$1.prototype.normalize = function normalize2(match) {
      if (!match.schema) {
        match.url = "http://" + match.url;
      }
      if (match.schema === "mailto:" && !/^mailto:/i.test(match.url)) {
        match.url = "mailto:" + match.url;
      }
    };
    LinkifyIt$1.prototype.onCompile = function onCompile() {
    };
    var linkifyIt = LinkifyIt$1;
    const maxInt = 2147483647;
    const base = 36;
    const tMin = 1;
    const tMax = 26;
    const skew = 38;
    const damp = 700;
    const initialBias = 72;
    const initialN = 128;
    const delimiter = "-";
    const regexPunycode = /^xn--/;
    const regexNonASCII = /[^\0-\x7F]/;
    const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    const errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    const baseMinusTMin = base - tMin;
    const floor = Math.floor;
    const stringFromCharCode = String.fromCharCode;
    function error(type2) {
      throw new RangeError(errors[type2]);
    }
    function map(array, callback) {
      const result = [];
      let length = array.length;
      while (length--) {
        result[length] = callback(array[length]);
      }
      return result;
    }
    function mapDomain(domain, callback) {
      const parts = domain.split("@");
      let result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        domain = parts[1];
      }
      domain = domain.replace(regexSeparators, ".");
      const labels = domain.split(".");
      const encoded = map(labels, callback).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      const output = [];
      let counter = 0;
      const length = string.length;
      while (counter < length) {
        const value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          const extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    const ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
    const basicToDigit = function(codePoint) {
      if (codePoint >= 48 && codePoint < 58) {
        return 26 + (codePoint - 48);
      }
      if (codePoint >= 65 && codePoint < 91) {
        return codePoint - 65;
      }
      if (codePoint >= 97 && codePoint < 123) {
        return codePoint - 97;
      }
      return base;
    };
    const digitToBasic = function(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    const adapt = function(delta2, numPoints, firstTime) {
      let k = 0;
      delta2 = firstTime ? floor(delta2 / damp) : delta2 >> 1;
      delta2 += floor(delta2 / numPoints);
      for (; delta2 > baseMinusTMin * tMax >> 1; k += base) {
        delta2 = floor(delta2 / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta2 / (delta2 + skew));
    };
    const decode = function(input) {
      const output = [];
      const inputLength = input.length;
      let i2 = 0;
      let n = initialN;
      let bias = initialBias;
      let basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (let j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        const oldi = i2;
        for (let w = 1, k = base; ; k += base) {
          if (index >= inputLength) {
            error("invalid-input");
          }
          const digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base) {
            error("invalid-input");
          }
          if (digit > floor((maxInt - i2) / w)) {
            error("overflow");
          }
          i2 += digit * w;
          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          const baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error("overflow");
          }
          w *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt(i2 - oldi, out, oldi == 0);
        if (floor(i2 / out) > maxInt - n) {
          error("overflow");
        }
        n += floor(i2 / out);
        i2 %= out;
        output.splice(i2++, 0, n);
      }
      return String.fromCodePoint(...output);
    };
    const encode = function(input) {
      const output = [];
      input = ucs2decode(input);
      const inputLength = input.length;
      let n = initialN;
      let delta2 = 0;
      let bias = initialBias;
      for (const currentValue of input) {
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      const basicLength = output.length;
      let handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        let m = maxInt;
        for (const currentValue of input) {
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta2) / handledCPCountPlusOne)) {
          error("overflow");
        }
        delta2 += (m - n) * handledCPCountPlusOne;
        n = m;
        for (const currentValue of input) {
          if (currentValue < n && ++delta2 > maxInt) {
            error("overflow");
          }
          if (currentValue === n) {
            let q = delta2;
            for (let k = base; ; k += base) {
              const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t) {
                break;
              }
              const qMinusT = q - t;
              const baseMinusT = base - t;
              output.push(
                stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
              );
              q = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta2, handledCPCountPlusOne, handledCPCount === basicLength);
            delta2 = 0;
            ++handledCPCount;
          }
        }
        ++delta2;
        ++n;
      }
      return output.join("");
    };
    const toUnicode = function(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    const toASCII = function(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    const punycode$1 = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      "version": "2.3.1",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode,
      "encode": encode,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    const punycode_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      decode,
      default: punycode$1,
      encode,
      toASCII,
      toUnicode,
      ucs2decode,
      ucs2encode
    }, Symbol.toStringTag, { value: "Module" }));
    const require$$8 = /* @__PURE__ */ getAugmentedNamespace(punycode_es6);
    var _default = {
      options: {
        html: false,
        // Enable HTML tags in source
        xhtmlOut: false,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
        // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
        quotes: "“”‘’",
        /* “”‘’ */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 100
        // Internal protection, recursion limit
      },
      components: {
        core: {},
        block: {},
        inline: {}
      }
    };
    var zero = {
      options: {
        html: false,
        // Enable HTML tags in source
        xhtmlOut: false,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
        // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
        quotes: "“”‘’",
        /* “”‘’ */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 20
        // Internal protection, recursion limit
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline",
            "text_join"
          ]
        },
        block: {
          rules: [
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "text"
          ],
          rules2: [
            "balance_pairs",
            "fragments_join"
          ]
        }
      }
    };
    var commonmark = {
      options: {
        html: true,
        // Enable HTML tags in source
        xhtmlOut: true,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
        // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
        quotes: "“”‘’",
        /* “”‘’ */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 20
        // Internal protection, recursion limit
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline",
            "text_join"
          ]
        },
        block: {
          rules: [
            "blockquote",
            "code",
            "fence",
            "heading",
            "hr",
            "html_block",
            "lheading",
            "list",
            "reference",
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "autolink",
            "backticks",
            "emphasis",
            "entity",
            "escape",
            "html_inline",
            "image",
            "link",
            "newline",
            "text"
          ],
          rules2: [
            "balance_pairs",
            "emphasis",
            "fragments_join"
          ]
        }
      }
    };
    var utils = utils$1;
    var helpers = helpers$1;
    var Renderer = renderer;
    var ParserCore = parser_core;
    var ParserBlock = parser_block;
    var ParserInline = parser_inline;
    var LinkifyIt = linkifyIt;
    var mdurl = mdurl$1;
    var punycode = require$$8;
    var config = {
      default: _default,
      zero,
      commonmark
    };
    var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
    var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
    function validateLink(url) {
      var str2 = url.trim().toLowerCase();
      return BAD_PROTO_RE.test(str2) ? GOOD_DATA_RE.test(str2) ? true : false : true;
    }
    var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
    function normalizeLink(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toASCII(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.encode(mdurl.format(parsed));
    }
    function normalizeLinkText(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toUnicode(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
    }
    function MarkdownIt$1(presetName, options) {
      if (!(this instanceof MarkdownIt$1)) {
        return new MarkdownIt$1(presetName, options);
      }
      if (!options) {
        if (!utils.isString(presetName)) {
          options = presetName || {};
          presetName = "default";
        }
      }
      this.inline = new ParserInline();
      this.block = new ParserBlock();
      this.core = new ParserCore();
      this.renderer = new Renderer();
      this.linkify = new LinkifyIt();
      this.validateLink = validateLink;
      this.normalizeLink = normalizeLink;
      this.normalizeLinkText = normalizeLinkText;
      this.utils = utils;
      this.helpers = utils.assign({}, helpers);
      this.options = {};
      this.configure(presetName);
      if (options) {
        this.set(options);
      }
    }
    MarkdownIt$1.prototype.set = function(options) {
      utils.assign(this.options, options);
      return this;
    };
    MarkdownIt$1.prototype.configure = function(presets) {
      var self2 = this, presetName;
      if (utils.isString(presets)) {
        presetName = presets;
        presets = config[presetName];
        if (!presets) {
          throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
        }
      }
      if (!presets) {
        throw new Error("Wrong `markdown-it` preset, can't be empty");
      }
      if (presets.options) {
        self2.set(presets.options);
      }
      if (presets.components) {
        Object.keys(presets.components).forEach(function(name) {
          if (presets.components[name].rules) {
            self2[name].ruler.enableOnly(presets.components[name].rules);
          }
          if (presets.components[name].rules2) {
            self2[name].ruler2.enableOnly(presets.components[name].rules2);
          }
        });
      }
      return this;
    };
    MarkdownIt$1.prototype.enable = function(list2, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.enable(list2, true));
      }, this);
      result = result.concat(this.inline.ruler2.enable(list2, true));
      var missed = list2.filter(function(name) {
        return result.indexOf(name) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt$1.prototype.disable = function(list2, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.disable(list2, true));
      }, this);
      result = result.concat(this.inline.ruler2.disable(list2, true));
      var missed = list2.filter(function(name) {
        return result.indexOf(name) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt$1.prototype.use = function(plugin) {
      var args = [this].concat(Array.prototype.slice.call(arguments, 1));
      plugin.apply(plugin, args);
      return this;
    };
    MarkdownIt$1.prototype.parse = function(src, env) {
      if (typeof src !== "string") {
        throw new Error("Input data should be a String");
      }
      var state = new this.core.State(src, this, env);
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt$1.prototype.render = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parse(src, env), this.options, env);
    };
    MarkdownIt$1.prototype.parseInline = function(src, env) {
      var state = new this.core.State(src, this, env);
      state.inlineMode = true;
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt$1.prototype.renderInline = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parseInline(src, env), this.options, env);
    };
    var lib = MarkdownIt$1;
    var markdownIt = lib;
    const MarkdownIt = /* @__PURE__ */ getDefaultExportFromCjs(markdownIt);
    var NOTHING = Symbol.for("immer-nothing");
    var DRAFTABLE = Symbol.for("immer-draftable");
    var DRAFT_STATE = Symbol.for("immer-state");
    function die(error2, ...args) {
      throw new Error(
        `[Immer] minified error nr: ${error2}. Full error at: https://bit.ly/3cXEKWf`
      );
    }
    var getPrototypeOf = Object.getPrototypeOf;
    function isDraft(value) {
      return !!value && !!value[DRAFT_STATE];
    }
    function isDraftable(value) {
      var _a2;
      if (!value)
        return false;
      return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_a2 = value.constructor) == null ? void 0 : _a2[DRAFTABLE]) || isMap(value) || isSet(value);
    }
    var objectCtorString = Object.prototype.constructor.toString();
    function isPlainObject(value) {
      if (!value || typeof value !== "object")
        return false;
      const proto = getPrototypeOf(value);
      if (proto === null) {
        return true;
      }
      const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
      if (Ctor === Object)
        return true;
      return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
    }
    function each(obj, iter) {
      if (getArchtype(obj) === 0) {
        Object.entries(obj).forEach(([key, value]) => {
          iter(key, value, obj);
        });
      } else {
        obj.forEach((entry, index) => iter(index, entry, obj));
      }
    }
    function getArchtype(thing) {
      const state = thing[DRAFT_STATE];
      return state ? state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
    }
    function has(thing, prop2) {
      return getArchtype(thing) === 2 ? thing.has(prop2) : Object.prototype.hasOwnProperty.call(thing, prop2);
    }
    function set(thing, propOrOldValue, value) {
      const t = getArchtype(thing);
      if (t === 2)
        thing.set(propOrOldValue, value);
      else if (t === 3) {
        thing.add(value);
      } else
        thing[propOrOldValue] = value;
    }
    function is(x2, y) {
      if (x2 === y) {
        return x2 !== 0 || 1 / x2 === 1 / y;
      } else {
        return x2 !== x2 && y !== y;
      }
    }
    function isMap(target2) {
      return target2 instanceof Map;
    }
    function isSet(target2) {
      return target2 instanceof Set;
    }
    function latest(state) {
      return state.copy_ || state.base_;
    }
    function shallowCopy(base2, strict) {
      if (isMap(base2)) {
        return new Map(base2);
      }
      if (isSet(base2)) {
        return new Set(base2);
      }
      if (Array.isArray(base2))
        return Array.prototype.slice.call(base2);
      if (!strict && isPlainObject(base2)) {
        if (!getPrototypeOf(base2)) {
          const obj = /* @__PURE__ */ Object.create(null);
          return Object.assign(obj, base2);
        }
        return { ...base2 };
      }
      const descriptors = Object.getOwnPropertyDescriptors(base2);
      delete descriptors[DRAFT_STATE];
      let keys2 = Reflect.ownKeys(descriptors);
      for (let i2 = 0; i2 < keys2.length; i2++) {
        const key = keys2[i2];
        const desc = descriptors[key];
        if (desc.writable === false) {
          desc.writable = true;
          desc.configurable = true;
        }
        if (desc.get || desc.set)
          descriptors[key] = {
            configurable: true,
            writable: true,
            // could live with !!desc.set as well here...
            enumerable: desc.enumerable,
            value: base2[key]
          };
      }
      return Object.create(getPrototypeOf(base2), descriptors);
    }
    function freeze(obj, deep = false) {
      if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
        return obj;
      if (getArchtype(obj) > 1) {
        obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
      }
      Object.freeze(obj);
      if (deep)
        each(obj, (_key, value) => freeze(value, true));
      return obj;
    }
    function dontMutateFrozenCollections() {
      die(2);
    }
    function isFrozen(obj) {
      return Object.isFrozen(obj);
    }
    var plugins = {};
    function getPlugin(pluginKey) {
      const plugin = plugins[pluginKey];
      if (!plugin) {
        die(0, pluginKey);
      }
      return plugin;
    }
    var currentScope;
    function getCurrentScope() {
      return currentScope;
    }
    function createScope(parent_, immer_) {
      return {
        drafts_: [],
        parent_,
        immer_,
        // Whenever the modified draft contains a draft from another scope, we
        // need to prevent auto-freezing so the unowned draft can be finalized.
        canAutoFreeze_: true,
        unfinalizedDrafts_: 0
      };
    }
    function usePatchesInScope(scope2, patchListener) {
      if (patchListener) {
        getPlugin("Patches");
        scope2.patches_ = [];
        scope2.inversePatches_ = [];
        scope2.patchListener_ = patchListener;
      }
    }
    function revokeScope(scope2) {
      leaveScope(scope2);
      scope2.drafts_.forEach(revokeDraft);
      scope2.drafts_ = null;
    }
    function leaveScope(scope2) {
      if (scope2 === currentScope) {
        currentScope = scope2.parent_;
      }
    }
    function enterScope(immer2) {
      return currentScope = createScope(currentScope, immer2);
    }
    function revokeDraft(draft) {
      const state = draft[DRAFT_STATE];
      if (state.type_ === 0 || state.type_ === 1)
        state.revoke_();
      else
        state.revoked_ = true;
    }
    function processResult(result, scope2) {
      scope2.unfinalizedDrafts_ = scope2.drafts_.length;
      const baseDraft = scope2.drafts_[0];
      const isReplaced = result !== void 0 && result !== baseDraft;
      if (isReplaced) {
        if (baseDraft[DRAFT_STATE].modified_) {
          revokeScope(scope2);
          die(4);
        }
        if (isDraftable(result)) {
          result = finalize(scope2, result);
          if (!scope2.parent_)
            maybeFreeze(scope2, result);
        }
        if (scope2.patches_) {
          getPlugin("Patches").generateReplacementPatches_(
            baseDraft[DRAFT_STATE].base_,
            result,
            scope2.patches_,
            scope2.inversePatches_
          );
        }
      } else {
        result = finalize(scope2, baseDraft, []);
      }
      revokeScope(scope2);
      if (scope2.patches_) {
        scope2.patchListener_(scope2.patches_, scope2.inversePatches_);
      }
      return result !== NOTHING ? result : void 0;
    }
    function finalize(rootScope, value, path) {
      if (isFrozen(value))
        return value;
      const state = value[DRAFT_STATE];
      if (!state) {
        each(
          value,
          (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path)
        );
        return value;
      }
      if (state.scope_ !== rootScope)
        return value;
      if (!state.modified_) {
        maybeFreeze(rootScope, state.base_, true);
        return state.base_;
      }
      if (!state.finalized_) {
        state.finalized_ = true;
        state.scope_.unfinalizedDrafts_--;
        const result = state.copy_;
        let resultEach = result;
        let isSet2 = false;
        if (state.type_ === 3) {
          resultEach = new Set(result);
          result.clear();
          isSet2 = true;
        }
        each(
          resultEach,
          (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2)
        );
        maybeFreeze(rootScope, result, false);
        if (path && rootScope.patches_) {
          getPlugin("Patches").generatePatches_(
            state,
            path,
            rootScope.patches_,
            rootScope.inversePatches_
          );
        }
      }
      return state.copy_;
    }
    function finalizeProperty(rootScope, parentState, targetObject, prop2, childValue, rootPath, targetIsSet) {
      if (isDraft(childValue)) {
        const path = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
        !has(parentState.assigned_, prop2) ? rootPath.concat(prop2) : void 0;
        const res = finalize(rootScope, childValue, path);
        set(targetObject, prop2, res);
        if (isDraft(res)) {
          rootScope.canAutoFreeze_ = false;
        } else
          return;
      } else if (targetIsSet) {
        targetObject.add(childValue);
      }
      if (isDraftable(childValue) && !isFrozen(childValue)) {
        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
          return;
        }
        finalize(rootScope, childValue);
        if (!parentState || !parentState.scope_.parent_)
          maybeFreeze(rootScope, childValue);
      }
    }
    function maybeFreeze(scope2, value, deep = false) {
      if (!scope2.parent_ && scope2.immer_.autoFreeze_ && scope2.canAutoFreeze_) {
        freeze(value, deep);
      }
    }
    function createProxyProxy(base2, parent) {
      const isArray2 = Array.isArray(base2);
      const state = {
        type_: isArray2 ? 1 : 0,
        // Track which produce call this is associated with.
        scope_: parent ? parent.scope_ : getCurrentScope(),
        // True for both shallow and deep changes.
        modified_: false,
        // Used during finalization.
        finalized_: false,
        // Track which properties have been assigned (true) or deleted (false).
        assigned_: {},
        // The parent draft state.
        parent_: parent,
        // The base state.
        base_: base2,
        // The base proxy.
        draft_: null,
        // set below
        // The base copy with any updated values.
        copy_: null,
        // Called by the `produce` function.
        revoke_: null,
        isManual_: false
      };
      let target2 = state;
      let traps = objectTraps;
      if (isArray2) {
        target2 = [state];
        traps = arrayTraps;
      }
      const { revoke, proxy } = Proxy.revocable(target2, traps);
      state.draft_ = proxy;
      state.revoke_ = revoke;
      return proxy;
    }
    var objectTraps = {
      get(state, prop2) {
        if (prop2 === DRAFT_STATE)
          return state;
        const source2 = latest(state);
        if (!has(source2, prop2)) {
          return readPropFromProto(state, source2, prop2);
        }
        const value = source2[prop2];
        if (state.finalized_ || !isDraftable(value)) {
          return value;
        }
        if (value === peek(state.base_, prop2)) {
          prepareCopy(state);
          return state.copy_[prop2] = createProxy(value, state);
        }
        return value;
      },
      has(state, prop2) {
        return prop2 in latest(state);
      },
      ownKeys(state) {
        return Reflect.ownKeys(latest(state));
      },
      set(state, prop2, value) {
        const desc = getDescriptorFromProto(latest(state), prop2);
        if (desc == null ? void 0 : desc.set) {
          desc.set.call(state.draft_, value);
          return true;
        }
        if (!state.modified_) {
          const current2 = peek(latest(state), prop2);
          const currentState = current2 == null ? void 0 : current2[DRAFT_STATE];
          if (currentState && currentState.base_ === value) {
            state.copy_[prop2] = value;
            state.assigned_[prop2] = false;
            return true;
          }
          if (is(value, current2) && (value !== void 0 || has(state.base_, prop2)))
            return true;
          prepareCopy(state);
          markChanged(state);
        }
        if (state.copy_[prop2] === value && // special case: handle new props with value 'undefined'
        (value !== void 0 || prop2 in state.copy_) || // special case: NaN
        Number.isNaN(value) && Number.isNaN(state.copy_[prop2]))
          return true;
        state.copy_[prop2] = value;
        state.assigned_[prop2] = true;
        return true;
      },
      deleteProperty(state, prop2) {
        if (peek(state.base_, prop2) !== void 0 || prop2 in state.base_) {
          state.assigned_[prop2] = false;
          prepareCopy(state);
          markChanged(state);
        } else {
          delete state.assigned_[prop2];
        }
        if (state.copy_) {
          delete state.copy_[prop2];
        }
        return true;
      },
      // Note: We never coerce `desc.value` into an Immer draft, because we can't make
      // the same guarantee in ES5 mode.
      getOwnPropertyDescriptor(state, prop2) {
        const owner = latest(state);
        const desc = Reflect.getOwnPropertyDescriptor(owner, prop2);
        if (!desc)
          return desc;
        return {
          writable: true,
          configurable: state.type_ !== 1 || prop2 !== "length",
          enumerable: desc.enumerable,
          value: owner[prop2]
        };
      },
      defineProperty() {
        die(11);
      },
      getPrototypeOf(state) {
        return getPrototypeOf(state.base_);
      },
      setPrototypeOf() {
        die(12);
      }
    };
    var arrayTraps = {};
    each(objectTraps, (key, fn) => {
      arrayTraps[key] = function() {
        arguments[0] = arguments[0][0];
        return fn.apply(this, arguments);
      };
    });
    arrayTraps.deleteProperty = function(state, prop2) {
      return arrayTraps.set.call(this, state, prop2, void 0);
    };
    arrayTraps.set = function(state, prop2, value) {
      return objectTraps.set.call(this, state[0], prop2, value, state[0]);
    };
    function peek(draft, prop2) {
      const state = draft[DRAFT_STATE];
      const source2 = state ? latest(state) : draft;
      return source2[prop2];
    }
    function readPropFromProto(state, source2, prop2) {
      var _a2;
      const desc = getDescriptorFromProto(source2, prop2);
      return desc ? `value` in desc ? desc.value : (
        // This is a very special case, if the prop is a getter defined by the
        // prototype, we should invoke it with the draft as context!
        (_a2 = desc.get) == null ? void 0 : _a2.call(state.draft_)
      ) : void 0;
    }
    function getDescriptorFromProto(source2, prop2) {
      if (!(prop2 in source2))
        return void 0;
      let proto = getPrototypeOf(source2);
      while (proto) {
        const desc = Object.getOwnPropertyDescriptor(proto, prop2);
        if (desc)
          return desc;
        proto = getPrototypeOf(proto);
      }
      return void 0;
    }
    function markChanged(state) {
      if (!state.modified_) {
        state.modified_ = true;
        if (state.parent_) {
          markChanged(state.parent_);
        }
      }
    }
    function prepareCopy(state) {
      if (!state.copy_) {
        state.copy_ = shallowCopy(
          state.base_,
          state.scope_.immer_.useStrictShallowCopy_
        );
      }
    }
    var Immer2 = class {
      constructor(config2) {
        this.autoFreeze_ = true;
        this.useStrictShallowCopy_ = false;
        this.produce = (base2, recipe, patchListener) => {
          if (typeof base2 === "function" && typeof recipe !== "function") {
            const defaultBase = recipe;
            recipe = base2;
            const self2 = this;
            return function curriedProduce(base22 = defaultBase, ...args) {
              return self2.produce(base22, (draft) => recipe.call(this, draft, ...args));
            };
          }
          if (typeof recipe !== "function")
            die(6);
          if (patchListener !== void 0 && typeof patchListener !== "function")
            die(7);
          let result;
          if (isDraftable(base2)) {
            const scope2 = enterScope(this);
            const proxy = createProxy(base2, void 0);
            let hasError = true;
            try {
              result = recipe(proxy);
              hasError = false;
            } finally {
              if (hasError)
                revokeScope(scope2);
              else
                leaveScope(scope2);
            }
            usePatchesInScope(scope2, patchListener);
            return processResult(result, scope2);
          } else if (!base2 || typeof base2 !== "object") {
            result = recipe(base2);
            if (result === void 0)
              result = base2;
            if (result === NOTHING)
              result = void 0;
            if (this.autoFreeze_)
              freeze(result, true);
            if (patchListener) {
              const p2 = [];
              const ip = [];
              getPlugin("Patches").generateReplacementPatches_(base2, result, p2, ip);
              patchListener(p2, ip);
            }
            return result;
          } else
            die(1, base2);
        };
        this.produceWithPatches = (base2, recipe) => {
          if (typeof base2 === "function") {
            return (state, ...args) => this.produceWithPatches(state, (draft) => base2(draft, ...args));
          }
          let patches, inversePatches;
          const result = this.produce(base2, recipe, (p2, ip) => {
            patches = p2;
            inversePatches = ip;
          });
          return [result, patches, inversePatches];
        };
        if (typeof (config2 == null ? void 0 : config2.autoFreeze) === "boolean")
          this.setAutoFreeze(config2.autoFreeze);
        if (typeof (config2 == null ? void 0 : config2.useStrictShallowCopy) === "boolean")
          this.setUseStrictShallowCopy(config2.useStrictShallowCopy);
      }
      createDraft(base2) {
        if (!isDraftable(base2))
          die(8);
        if (isDraft(base2))
          base2 = current(base2);
        const scope2 = enterScope(this);
        const proxy = createProxy(base2, void 0);
        proxy[DRAFT_STATE].isManual_ = true;
        leaveScope(scope2);
        return proxy;
      }
      finishDraft(draft, patchListener) {
        const state = draft && draft[DRAFT_STATE];
        if (!state || !state.isManual_)
          die(9);
        const { scope_: scope2 } = state;
        usePatchesInScope(scope2, patchListener);
        return processResult(void 0, scope2);
      }
      /**
       * Pass true to automatically freeze all copies created by Immer.
       *
       * By default, auto-freezing is enabled.
       */
      setAutoFreeze(value) {
        this.autoFreeze_ = value;
      }
      /**
       * Pass true to enable strict shallow copy.
       *
       * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
       */
      setUseStrictShallowCopy(value) {
        this.useStrictShallowCopy_ = value;
      }
      applyPatches(base2, patches) {
        let i2;
        for (i2 = patches.length - 1; i2 >= 0; i2--) {
          const patch = patches[i2];
          if (patch.path.length === 0 && patch.op === "replace") {
            base2 = patch.value;
            break;
          }
        }
        if (i2 > -1) {
          patches = patches.slice(i2 + 1);
        }
        const applyPatchesImpl = getPlugin("Patches").applyPatches_;
        if (isDraft(base2)) {
          return applyPatchesImpl(base2, patches);
        }
        return this.produce(
          base2,
          (draft) => applyPatchesImpl(draft, patches)
        );
      }
    };
    function createProxy(value, parent) {
      const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
      const scope2 = parent ? parent.scope_ : getCurrentScope();
      scope2.drafts_.push(draft);
      return draft;
    }
    function current(value) {
      if (!isDraft(value))
        die(10, value);
      return currentImpl(value);
    }
    function currentImpl(value) {
      if (!isDraftable(value) || isFrozen(value))
        return value;
      const state = value[DRAFT_STATE];
      let copy2;
      if (state) {
        if (!state.modified_)
          return state.base_;
        state.finalized_ = true;
        copy2 = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
      } else {
        copy2 = shallowCopy(value, true);
      }
      each(copy2, (key, childValue) => {
        set(copy2, key, currentImpl(childValue));
      });
      if (state) {
        state.finalized_ = false;
      }
      return copy2;
    }
    var immer = new Immer2();
    var produce = immer.produce;
    immer.produceWithPatches.bind(
      immer
    );
    var setAutoFreeze = immer.setAutoFreeze.bind(immer);
    immer.setUseStrictShallowCopy.bind(immer);
    immer.applyPatches.bind(immer);
    immer.createDraft.bind(immer);
    immer.finishDraft.bind(immer);
    const en = {
      errorOneOf: "chose one",
      errorRequired: "required information",
      addItem: "Add item",
      delete: "Delete",
      edit: "Edit",
      close: "Close",
      duplicate: "Duplicate",
      sort: "Sort",
      up: "Move up",
      down: "Move down",
      showHelp: "Show a help message",
      mdeLink1: "[Link title",
      mdeLink2: "](link url)",
      mdeImg1: "![](",
      mdeImg2: "image url)",
      mdeTable1: "",
      mdeTable2: "\n\n| Column 1 | Column 2 | ColoColumnnne 3 |\n| -------- | -------- | -------- |\n| Text     | Text     | Text     |\n\n",
      bold: "Bold",
      italic: "Italic",
      heading: "Title",
      quote: "Quote",
      unorderedList: "Unordered list",
      orderedList: "Ordered list",
      createLink: "Create a link",
      insertImage: "Insert an image",
      createTable: "Create a table",
      preview: "Aperçu du rendu",
      mdeGuide: "Documentation de la syntaxe",
      undo: "Undo",
      redo: "Redo"
    };
    const fr = {
      errorOneOf: "choisissez une valeur",
      errorRequired: "information obligatoire",
      addItem: "Ajouter un élément",
      delete: "Supprimer",
      edit: "Éditer",
      close: "Fermer",
      duplicate: "Dupliquer",
      sort: "Trier",
      up: "Décaler vers le haut",
      down: "Décaler vers le bas",
      showHelp: "Afficher un message d'aide",
      mdeLink1: "[titre du lien",
      mdeLink2: "](adresse du lien)",
      mdeImg1: "![](",
      mdeImg2: "adresse de l'image)",
      mdeTable1: "",
      mdeTable2: "\n\n| Colonne 1 | Colonne 2 | Colonne 3 |\n| -------- | -------- | -------- |\n| Texte     | Texte     | Texte     |\n\n",
      bold: "Gras",
      italic: "Italique",
      heading: "Titre",
      quote: "Citation",
      unorderedList: "Liste à puce",
      orderedList: "Liste numérotée",
      createLink: "Créer un lien",
      insertImage: "Insérer une image",
      createTable: "Créer un tableau",
      preview: "Preview",
      mdeGuide: "Syntax documentation",
      undo: "Défaire",
      redo: "Refaire"
    };
    const nl = {
      errorOneOf: "Kies er een",
      errorRequired: "benodigde informatie",
      addItem: "Item toevoegen",
      delete: "Verwijderen",
      edit: "Bewerken",
      close: "Sluiten",
      duplicate: "Verveelvoudigen",
      sort: "Sorteren",
      up: "Omhoog verplaatsen",
      down: "Omlaag verplaatsen",
      showHelp: "Toon helpbericht",
      mdeLink1: "[Link titel",
      mdeLink2: "](link url)",
      mdeImg1: "![](",
      mdeImg2: "afbeelding url)",
      mdeTable1: "",
      mdeTable2: "\n\n| Kolom 1  | Kolom 2  | Kolom 3  |\n| -------- | -------- | -------- |\n| Tekst    | Tekst    | Tekst    |\n\n",
      bold: "Vet",
      italic: "Cursief",
      heading: "Titel",
      quote: "Citaat",
      unorderedList: "Ongeordende lijst",
      orderedList: "Geordende lijst",
      createLink: "Maak een koppeling",
      insertImage: "Afbeelding invoegen",
      createTable: "Tabel aanmaken",
      preview: "Voorbeeld",
      mdeGuide: "Documentatie over syntaxis",
      undo: "Ongedaan maken",
      redo: "Opnieuw"
    };
    const i18n = {
      en,
      fr,
      nl
    };
    const schema$1 = {
      "$id": "https://json-layout.github.io/layout-keyword",
      "$defs": {
        "layout-keyword": {
          "title": "layout keyword",
          "errorMessage": {
            "anyOf": "layout keyword must be a string with a valid component name, or a more complete object definition, or an array of children, or a switch structure"
          },
          "anyOf": [
            {
              "$ref": "#/$defs/comp-name"
            },
            {
              "$ref": "#/$defs/partial-children"
            },
            {
              "$ref": "#/$defs/partial-comp-object"
            },
            {
              "$ref": "#/$defs/partial-switch"
            }
          ]
        },
        "partial-switch": {
          "type": "object",
          "required": [
            "switch"
          ],
          "additionalProperties": false,
          "properties": {
            "switch": {
              "type": "array",
              "items": {
                "$ref": "#/$defs/partial-comp-object"
              }
            }
          }
        },
        "partial-comp-object": {
          "title": "partial comp object",
          "type": "object",
          "properties": {
            "comp": {
              "$ref": "#/$defs/comp-name"
            },
            "help": {
              "type": "string"
            },
            "children": {
              "$ref": "#/$defs/partial-children"
            },
            "label": {
              "type": "string"
            },
            "title": {
              "type": [
                "string",
                "null"
              ]
            },
            "subtitle": {
              "type": [
                "string",
                "null"
              ]
            },
            "step": {
              "type": "number"
            },
            "if": {
              "$ref": "#/$defs/partial-expression"
            },
            "items": {
              "type": "array",
              "items": {
                "$ref": "#/$defs/partial-select-item"
              }
            },
            "getItems": {
              "$ref": "#/$defs/partial-get-items"
            },
            "listEditMode": {
              "type": "string",
              "enum": [
                "inline",
                "inline-single",
                "menu",
                "dialog"
              ]
            },
            "listActions": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "add",
                  "edit",
                  "delete",
                  "sort",
                  "duplicate"
                ]
              }
            },
            "cols": {
              "$ref": "#/$defs/partial-cols"
            },
            "props": {
              "type": "object"
            },
            "getProps": {
              "$ref": "#/$defs/partial-expression"
            },
            "slots": {
              "type": "object",
              "patternProperties": {
                ".*": {
                  "$ref": "#/$defs/partial-slot"
                }
              }
            },
            "options": {
              "type": "object"
            },
            "getOptions": {
              "$ref": "#/$defs/partial-expression"
            },
            "messages": {
              "type": "object"
            },
            "defaultData": {},
            "getDefaultData": {
              "$ref": "#/$defs/partial-expression"
            },
            "constData": {},
            "getConstData": {
              "$ref": "#/$defs/partial-expression"
            },
            "transformData": {
              "$ref": "#/$defs/partial-expression"
            },
            "autofocus": {
              "type": "boolean"
            },
            "separator": {
              "type": "string"
            }
          }
        },
        "comp-name": {
          "title": "component name",
          "type": "string"
        },
        "partial-child-ref": {
          "type": "object",
          "required": [
            "key"
          ],
          "additionalProperties": false,
          "properties": {
            "key": {
              "type": [
                "string",
                "integer"
              ]
            },
            "cols": {
              "$ref": "#/$defs/partial-cols"
            }
          }
        },
        "partial-child-composite": {
          "type": "object",
          "required": [
            "children"
          ],
          "properties": {
            "comp": {
              "type": "string"
            },
            "title": {
              "type": [
                "string",
                "null"
              ]
            },
            "subtitle": {
              "type": [
                "string",
                "null"
              ]
            },
            "children": {
              "$ref": "#/$defs/partial-children"
            },
            "cols": {
              "$ref": "#/$defs/partial-cols"
            }
          }
        },
        "partial-child": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/$defs/partial-child-ref"
            },
            {
              "$ref": "#/$defs/partial-child-composite"
            }
          ]
        },
        "partial-children": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/partial-child"
          }
        },
        "partial-expression": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/$defs/partial-expression-obj"
            }
          ]
        },
        "partial-expression-obj": {
          "type": "object",
          "required": [
            "expr"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "js-fn",
                "js-eval",
                "js-tpl"
              ]
            },
            "expr": {
              "type": "string"
            }
          }
        },
        "partial-select-item": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "object",
              "properties": {
                "key": {
                  "type": "string"
                },
                "title": {
                  "type": "string"
                },
                "value": {}
              }
            }
          ]
        },
        "partial-get-items": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/$defs/partial-get-items-obj"
            }
          ]
        },
        "partial-get-items-obj": {
          "type": "object",
          "allOf": [
            {
              "properties": {
                "itemTitle": {
                  "$ref": "#/$defs/partial-expression"
                },
                "itemKey": {
                  "$ref": "#/$defs/partial-expression"
                },
                "itemValue": {
                  "$ref": "#/$defs/partial-expression"
                },
                "itemIcon": {
                  "$ref": "#/$defs/partial-expression"
                },
                "itemsResults": {
                  "$ref": "#/$defs/partial-expression"
                }
              }
            },
            {
              "anyOf": [
                {
                  "type": "object"
                },
                {
                  "$ref": "#/$defs/partial-expression-obj"
                },
                {
                  "$ref": "#/$defs/partial-get-items-fetch"
                }
              ]
            }
          ]
        },
        "partial-get-items-fetch": {
          "type": "object",
          "required": [
            "url"
          ],
          "properties": {
            "url": {
              "$ref": "#/$defs/partial-expression"
            }
          }
        },
        "partial-cols": {
          "oneOf": [
            {
              "$ref": "#/$defs/partial-cols-number"
            },
            {
              "$ref": "#/$defs/partial-cols-obj"
            }
          ]
        },
        "partial-cols-obj": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "xs": {
              "$ref": "#/$defs/partial-cols-number"
            },
            "sm": {
              "$ref": "#/$defs/partial-cols-number"
            },
            "md": {
              "$ref": "#/$defs/partial-cols-number"
            },
            "lg": {
              "$ref": "#/$defs/partial-cols-number"
            },
            "xl": {
              "$ref": "#/$defs/partial-cols-number"
            },
            "xxl": {
              "$ref": "#/$defs/partial-cols-number"
            }
          }
        },
        "partial-cols-number": {
          "type": "integer",
          "minimum": 0,
          "maximum": 12
        },
        "partial-slot": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/$defs/partial-slot-text"
            },
            {
              "$ref": "#/$defs/partial-slot-markdown"
            },
            {
              "$ref": "#/$defs/partial-slot-name"
            }
          ]
        },
        "partial-slot-text": {
          "type": "object",
          "additionalProperties": false,
          "required": [
            "text"
          ],
          "properties": {
            "text": {
              "type": "string"
            }
          }
        },
        "partial-slot-markdown": {
          "type": "object",
          "additionalProperties": false,
          "required": [
            "markdown"
          ],
          "properties": {
            "markdown": {
              "type": "string"
            }
          }
        },
        "partial-slot-name": {
          "type": "object",
          "additionalProperties": false,
          "required": [
            "name"
          ],
          "properties": {
            "name": {
              "type": "string"
            }
          }
        }
      }
    };
    const schema = {
      "$id": "https://json-layout.github.io/normalized-layout-keyword",
      "$defs": {
        "normalized-layout": {
          "title": "normalized layout",
          "type": "object",
          "unevaluatedProperties": false,
          "oneOf": [
            {
              "$ref": "#/$defs/switch-struct"
            },
            {
              "$ref": "#/$defs/base-comp-object"
            }
          ]
        },
        "switch-struct": {
          "type": "object",
          "required": [
            "switch"
          ],
          "additionalProperties": false,
          "properties": {
            "switch": {
              "type": "array",
              "items": {
                "$ref": "#/$defs/base-comp-object"
              }
            }
          }
        },
        "base-comp-object": {
          "type": "object",
          "required": [
            "comp"
          ],
          "properties": {
            "comp": {
              "type": "string"
            },
            "if": {
              "$ref": "#/$defs/expression"
            },
            "options": {
              "$ref": "#/$defs/state-node-options-base"
            },
            "getOptions": {
              "$ref": "#/$defs/expression"
            },
            "defaultData": {},
            "getDefaultData": {
              "$ref": "#/$defs/expression"
            },
            "constData": {},
            "getConstData": {
              "$ref": "#/$defs/expression"
            },
            "transformData": {
              "$ref": "#/$defs/expression"
            },
            "nullable": {
              "type": "boolean"
            },
            "help": {
              "type": "string"
            },
            "cols": {
              "$ref": "#/$defs/cols-obj"
            },
            "props": {
              "$ref": "#/$defs/state-node-props-lib"
            },
            "getProps": {
              "$ref": "#/$defs/expression"
            },
            "slots": {
              "type": "object",
              "allOf": [
                {
                  "$ref": "#/$defs/state-node-slots-lib"
                },
                {
                  "properties": {
                    "before": {
                      "$ref": "#/$defs/slot"
                    },
                    "after": {
                      "$ref": "#/$defs/slot"
                    },
                    "component": {
                      "$ref": "#/$defs/slot"
                    }
                  }
                }
              ]
            }
          }
        },
        "composite-comp-object": {
          "allOf": [
            {
              "$ref": "#/$defs/base-comp-object"
            },
            {
              "type": "object",
              "required": [
                "children",
                "comp"
              ],
              "properties": {
                "comp": {
                  "type": "string"
                },
                "title": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "subtitle": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "children": {
                  "$ref": "#/$defs/children"
                }
              }
            }
          ]
        },
        "simple-comp-object": {
          "allOf": [
            {
              "$ref": "#/$defs/base-comp-object"
            },
            {
              "type": "object",
              "required": [
                "comp"
              ],
              "properties": {
                "comp": {
                  "type": "string"
                },
                "label": {
                  "type": "string"
                }
              }
            }
          ]
        },
        "focusable-comp-object": {
          "allOf": [
            {
              "$ref": "#/$defs/base-comp-object"
            },
            {
              "type": "object",
              "required": [
                "comp"
              ],
              "properties": {
                "comp": {
                  "type": "string"
                },
                "label": {
                  "type": "string"
                },
                "autofocus": {
                  "type": "boolean"
                }
              }
            }
          ]
        },
        "items-based-comp-object": {
          "allOf": [
            {
              "$ref": "#/$defs/base-comp-object"
            },
            {
              "type": "object",
              "required": [
                "comp"
              ],
              "properties": {
                "comp": {
                  "type": "string"
                },
                "items": {
                  "$ref": "#/$defs/select-items"
                },
                "getItems": {
                  "$ref": "#/$defs/get-items"
                },
                "multiple": {
                  "type": "boolean"
                },
                "separator": {
                  "type": "string"
                }
              }
            }
          ]
        },
        "multiple-compat-comp-object": {
          "allOf": [
            {
              "$ref": "#/$defs/base-comp-object"
            },
            {
              "type": "object",
              "required": [
                "comp"
              ],
              "properties": {
                "comp": {
                  "type": "string"
                },
                "multiple": {
                  "type": "boolean"
                }
              }
            }
          ]
        },
        "child-ref": {
          "type": "object",
          "required": [
            "key"
          ],
          "additionalProperties": false,
          "properties": {
            "key": {
              "type": [
                "string",
                "integer"
              ]
            },
            "cols": {
              "$ref": "#/$defs/cols-obj"
            }
          }
        },
        "child-composite": {
          "type": "object",
          "required": [
            "key",
            "children"
          ],
          "properties": {
            "key": {
              "type": [
                "string",
                "integer"
              ]
            },
            "cols": {
              "$ref": "#/$defs/cols-obj"
            },
            "comp": {
              "type": "string"
            },
            "title": {
              "type": [
                "string",
                "null"
              ]
            },
            "subtitle": {
              "type": [
                "string",
                "null"
              ]
            },
            "children": {
              "$ref": "#/$defs/children"
            }
          }
        },
        "child": {
          "title": "Child",
          "type": "object",
          "oneOf": [
            {
              "$ref": "#/$defs/child-ref"
            },
            {
              "$ref": "#/$defs/child-composite"
            }
          ]
        },
        "children": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/child"
          }
        },
        "select-items": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/select-item"
          }
        },
        "select-item": {
          "type": "object",
          "required": [
            "title",
            "key",
            "value"
          ],
          "properties": {
            "title": {
              "type": "string"
            },
            "key": {
              "type": "string"
            },
            "value": {},
            "icon": {
              "type": "string"
            }
          }
        },
        "get-items": {
          "type": "object",
          "allOf": [
            {
              "properties": {
                "returnObjects": {
                  "type": "boolean",
                  "readOnly": true
                },
                "itemsResults": {
                  "$ref": "#/$defs/expression"
                },
                "itemTitle": {
                  "$ref": "#/$defs/expression"
                },
                "itemKey": {
                  "$ref": "#/$defs/expression"
                },
                "itemValue": {
                  "$ref": "#/$defs/expression"
                },
                "itemIcon": {
                  "$ref": "#/$defs/expression"
                },
                "immutable": {
                  "type": "boolean"
                }
              }
            },
            {
              "oneOf": [
                {
                  "$ref": "#/$defs/expression"
                },
                {
                  "$ref": "#/$defs/get-items-fetch"
                }
              ]
            }
          ]
        },
        "get-items-fetch": {
          "type": "object",
          "required": [
            "url"
          ],
          "properties": {
            "url": {
              "$ref": "#/$defs/expression"
            },
            "qSearchParam": {
              "type": "string"
            },
            "searchParams": {
              "type": "object",
              "patternProperties": {
                ".*": {
                  "$ref": "#/$defs/expression"
                }
              }
            }
          }
        },
        "expression": {
          "type": "object",
          "required": [
            "type",
            "expr",
            "pure",
            "dataAlias"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "js-fn",
                "js-eval",
                "js-tpl"
              ]
            },
            "expr": {
              "type": "string"
            },
            "pure": {
              "type": "boolean"
            },
            "dataAlias": {
              "type": "string"
            },
            "ref": {
              "type": "integer",
              "readOnly": true
            }
          }
        },
        "cols-obj": {
          "type": "object",
          "additionalProperties": false,
          "required": [
            "xs"
          ],
          "properties": {
            "xs": {
              "$ref": "#/$defs/cols",
              "default": 12
            },
            "sm": {
              "$ref": "#/$defs/cols"
            },
            "md": {
              "$ref": "#/$defs/cols"
            },
            "lg": {
              "$ref": "#/$defs/cols"
            },
            "xl": {
              "$ref": "#/$defs/cols"
            },
            "xxl": {
              "$ref": "#/$defs/cols"
            }
          }
        },
        "cols": {
          "type": "integer",
          "minimum": 0,
          "maximum": 12
        },
        "slot": {
          "oneOf": [
            {
              "type": "object",
              "additionalProperties": false,
              "required": [
                "text"
              ],
              "properties": {
                "text": {
                  "type": "string"
                }
              }
            },
            {
              "type": "object",
              "additionalProperties": false,
              "required": [
                "markdown"
              ],
              "properties": {
                "markdown": {
                  "type": "string"
                }
              }
            },
            {
              "type": "object",
              "additionalProperties": false,
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "type": "string"
                }
              }
            }
          ]
        },
        "state-node-options-base": {
          "type": "object",
          "allOf": [
            {
              "$ref": "#/$defs/state-node-options-base-lib"
            },
            {
              "properties": {
                "readOnly": {
                  "type": "boolean",
                  "default": false
                },
                "summary": {
                  "type": "boolean",
                  "default": false
                },
                "titleDepth": {
                  "type": "integer",
                  "minimum": 1,
                  "maximum": 6,
                  "default": 2
                },
                "density": {
                  "type": "string",
                  "enum": [
                    "default",
                    "comfortable",
                    "compact"
                  ],
                  "default": "default"
                },
                "indent": {
                  "type": [
                    "boolean",
                    "integer"
                  ]
                },
                "removeAdditional": {
                  "description": "true is the same as 'unknown', false is the same as 'none'",
                  "default": "error",
                  "oneOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "string",
                      "enum": [
                        "unknown",
                        "error",
                        "none"
                      ]
                    }
                  ]
                },
                "validateOn": {
                  "type": "string",
                  "enum": [
                    "input",
                    "blur",
                    "submit"
                  ],
                  "default": "input"
                },
                "updateOn": {
                  "type": "string",
                  "enum": [
                    "input",
                    "blur"
                  ],
                  "default": "input"
                },
                "debounceInputMs": {
                  "type": "integer",
                  "minimum": 0,
                  "default": 300
                },
                "initialValidation": {
                  "type": "string",
                  "enum": [
                    "never",
                    "always",
                    "withData"
                  ],
                  "default": "withData"
                },
                "defaultOn": {
                  "type": "string",
                  "enum": [
                    "missing",
                    "empty",
                    "never"
                  ],
                  "default": "empty"
                },
                "autofocus": {
                  "type": "boolean",
                  "default": false
                },
                "readOnlyPropertiesMode": {
                  "type": "string",
                  "enum": [
                    "remove",
                    "hide",
                    "show"
                  ],
                  "default": "show"
                }
              }
            }
          ]
        },
        "state-node-options-base-lib": {
          "type": "object",
          "patternProperties": {
            ".*": {}
          }
        },
        "state-node-props-lib": {
          "type": "object",
          "patternProperties": {
            ".*": {}
          }
        },
        "state-node-slots-lib": {
          "type": "object",
          "patternProperties": {
            ".*": {
              "$ref": "#/$defs/slot"
            }
          }
        }
      }
    };
    const standardComponents = [
      {
        name: "none"
      },
      {
        name: "section",
        composite: true
      },
      {
        name: "tabs",
        composite: true
      },
      {
        name: "vertical-tabs",
        composite: true
      },
      {
        name: "expansion-panels",
        composite: true
      },
      {
        name: "stepper",
        composite: true
      },
      {
        name: "card",
        composite: true
      },
      {
        name: "list",
        schema: {
          required: ["listEditMode", "listActions"],
          properties: {
            title: { type: "string" },
            listEditMode: { type: "string", enum: ["inline", "inline-single", "menu", "dialog"] },
            listActions: { type: "array", items: { type: "string", enum: ["add", "edit", "delete", "sort", "duplicate"] } },
            itemTitle: { $ref: "https://json-layout.github.io/normalized-layout-keyword#/$defs/expression" },
            itemSubtitle: { $ref: "https://json-layout.github.io/normalized-layout-keyword#/$defs/expression" },
            indexed: { type: "array", items: { type: "string" } },
            messages: {
              type: "object",
              additionalProperties: false,
              properties: {
                addItem: { type: "string" },
                delete: { type: "string" },
                edit: { type: "string" },
                duplicate: { type: "string" },
                sort: { type: "string" }
              }
            }
          }
        }
      },
      {
        name: "text-field",
        shouldDebounce: true,
        focusable: true,
        emitsBlur: true
      },
      {
        name: "textarea",
        shouldDebounce: true,
        focusable: true,
        emitsBlur: true
      },
      {
        name: "number-field",
        shouldDebounce: true,
        focusable: true,
        emitsBlur: true,
        schema: {
          properties: {
            step: { type: "number" },
            min: { type: "number" },
            max: { type: "number" }
          }
        }
      },
      {
        name: "checkbox"
      },
      {
        name: "switch"
      },
      {
        name: "slider",
        schema: {
          properties: {
            step: { type: "number" },
            min: { type: "number" },
            max: { type: "number" }
          }
        }
      },
      {
        name: "date-picker",
        schema: {
          properties: {
            min: { type: "string", format: "date" },
            max: { type: "string", format: "date" },
            format: { type: "string", enum: ["date", "date-time"], default: "date" }
          }
        }
      },
      {
        name: "date-time-picker",
        schema: {
          properties: {
            min: { type: "string", format: "date-time" },
            max: { type: "string", format: "date-time" }
          }
        }
      },
      {
        name: "time-picker",
        schema: {
          properties: {
            min: { type: "string", format: "time" },
            max: { type: "string", format: "time" }
          }
        }
      },
      {
        name: "color-picker"
      },
      {
        name: "select",
        focusable: true,
        itemsBased: true,
        multipleCompat: true
      },
      {
        name: "autocomplete",
        focusable: true,
        itemsBased: true,
        multipleCompat: true
      },
      {
        name: "combobox",
        focusable: true,
        itemsBased: true,
        multipleCompat: true
      },
      {
        name: "number-combobox",
        focusable: true,
        itemsBased: true,
        multipleCompat: true,
        schema: {
          properties: {
            step: { type: "number" },
            min: { type: "number" },
            max: { type: "number" }
          }
        }
      },
      {
        name: "checkbox-group",
        itemsBased: true,
        multipleCompat: true
      },
      {
        name: "switch-group",
        itemsBased: true,
        multipleCompat: true
      },
      {
        name: "radio-group",
        itemsBased: true
      },
      {
        name: "file-input",
        focusable: true,
        multipleCompat: true,
        schema: {
          properties: {
            accept: { type: "string" }
          }
        }
      },
      {
        name: "one-of-select",
        schema: {
          properties: {
            emptyData: { type: "boolean" }
          }
        }
      }
    ];
    function getComponentSchema(component) {
      const schema2 = {
        type: "object",
        title: component.name,
        $id: `https://json-layout.github.io/component/${component.name}#`,
        unevaluatedProperties: false,
        allOf: [
          { properties: { comp: { const: component.name } } },
          { $ref: "https://json-layout.github.io/normalized-layout-keyword#/$defs/base-comp-object" }
        ]
      };
      if (component.composite) {
        schema2.allOf.push({ $ref: "https://json-layout.github.io/normalized-layout-keyword#/$defs/composite-comp-object" });
      } else {
        schema2.allOf.push({ $ref: "https://json-layout.github.io/normalized-layout-keyword#/$defs/simple-comp-object" });
      }
      if (component.focusable) {
        schema2.allOf.push({ $ref: "https://json-layout.github.io/normalized-layout-keyword#/$defs/focusable-comp-object" });
      }
      if (component.itemsBased) {
        schema2.allOf.push({ $ref: "https://json-layout.github.io/normalized-layout-keyword#/$defs/items-based-comp-object" });
      }
      if (component.multipleCompat) {
        schema2.allOf.push({ $ref: "https://json-layout.github.io/normalized-layout-keyword#/$defs/multiple-compat-comp-object" });
      }
      if (component.schema) {
        schema2.allOf.push(component.schema);
      }
      return schema2;
    }
    const Ajv$1 = (
      /** @type {typeof ajvModule.default} */
      ajvModule
    );
    const ajv = new Ajv$1({
      code: {
        source: true,
        esm: true
        // optimize: true
      },
      discriminator: true,
      allowMatchingProperties: true,
      allowUnionTypes: true,
      allErrors: true
    });
    addFormats.default(ajv);
    ajvErrors.default(ajv);
    ajv.addSchema(schema$1);
    ajv.addSchema(schema);
    const componentsValidateCache = {};
    function getComponentValidate(component) {
      if (componentsValidateCache[component.name])
        return componentsValidateCache[component.name];
      const schema2 = getComponentSchema(component);
      componentsValidateCache[component.name] = ajv.compile(schema2);
      return componentsValidateCache[component.name];
    }
    const validateLayoutKeyword = (
      /** @type {any} */
      ajv.getSchema(schema$1.$id)
    );
    function isComponentName(layoutKeyword) {
      return typeof layoutKeyword === "string";
    }
    function isPartialSwitch(layoutKeyword) {
      return typeof layoutKeyword === "object" && "switch" in layoutKeyword;
    }
    function isPartialChildren(layoutKeyword) {
      return Array.isArray(layoutKeyword);
    }
    function isPartialChildComposite(partialChild) {
      return typeof partialChild !== "string" && "children" in partialChild;
    }
    function isPartialCompObject(layoutKeyword) {
      return typeof layoutKeyword === "object" && !Array.isArray(layoutKeyword);
    }
    function isPartialGetItemsExpr(getItems) {
      return typeof getItems === "string" || !!getItems.expr;
    }
    function isPartialGetItemsObj(getItems) {
      return typeof getItems === "object";
    }
    function isPartialGetItemsFetch(getItems) {
      return typeof getItems === "object" && !!getItems.url;
    }
    function isPartialSlotMarkdown(partialSlot) {
      return typeof partialSlot == "object" && !!/** @type {PartialSlotMarkdown} */
      partialSlot.markdown;
    }
    const validateNormalizedLayout = (
      /** @type {any} */
      ajv.getSchema(schema.$id)
    );
    function isSwitchStruct(layout) {
      return typeof layout === "object" && "switch" in layout;
    }
    function isCompObject(layout) {
      return !isSwitchStruct(layout);
    }
    function childIsCompObject(child) {
      return "comp" in child;
    }
    function isCompositeLayout(layout, components) {
      var _a2;
      return !!((_a2 = components[layout.comp]) == null ? void 0 : _a2.composite);
    }
    function isListLayout(layout) {
      return layout.comp === "list";
    }
    function isFocusableLayout(layout, components) {
      var _a2;
      return !!((_a2 = components[layout.comp]) == null ? void 0 : _a2.focusable);
    }
    function isItemsLayout(layout, components) {
      var _a2;
      return !!((_a2 = components[layout.comp]) == null ? void 0 : _a2.itemsBased);
    }
    function isGetItemsExpression(getItems) {
      return !!getItems.expr;
    }
    function isGetItemsFetch(getItems) {
      return !!getItems.url;
    }
    function isTextSlot(slot) {
      return !!slot.text;
    }
    function isMarkdownSlot(slot) {
      return !!slot.markdown;
    }
    function isNameSlot(slot) {
      return !!slot.name;
    }
    function getDefaultChildren(schemaFragment, type2) {
      var _a2, _b;
      const children = [];
      if (type2 === "object") {
        for (const key of Object.keys(schemaFragment)) {
          if (key === "properties") {
            for (const key2 of Object.keys(schemaFragment.properties ?? {})) {
              children.push({ key: key2 });
              if (((_a2 = schemaFragment.dependencies) == null ? void 0 : _a2[key2]) && !Array.isArray(schemaFragment.dependencies[key2])) {
                children.push({ key: `$deps-${key2}` });
              }
              if (schemaFragment.dependentSchemas && schemaFragment.dependentSchemas[key2]) {
                children.push({ key: `$deps-${key2}` });
              }
            }
          }
          if (key === "patternProperties") {
            children.push({ key: "$patternProperties" });
          }
          if (key === "allOf") {
            if ((_b = schemaFragment.allOf) == null ? void 0 : _b.length) {
              for (let i2 = 0; i2 < schemaFragment.allOf.length; i2++) {
                children.push({ key: `$allOf-${i2}` });
              }
            }
          }
          if (key === "oneOf") {
            children.push({ key: "$oneOf" });
          }
          if (key === "then" && schemaFragment.if) {
            children.push({ key: "$then" });
          }
          if (key === "else" && schemaFragment.if) {
            children.push({ key: "$else" });
          }
        }
      }
      if (type2 === "array" && Array.isArray(schemaFragment.items)) {
        for (let i2 = 0; i2 < schemaFragment.items.length; i2++) {
          children.push({ key: i2 });
        }
      }
      return children;
    }
    function getChildren(defaultChildren, partialChildren) {
      if (!partialChildren)
        return defaultChildren;
      let compI = 0;
      return partialChildren.map((partialChild) => {
        if (typeof partialChild === "string") {
          const matchingDefaultChild = defaultChildren.find((c) => c.key === partialChild);
          if (!matchingDefaultChild)
            throw new Error(`unknown child "${partialChild}"`);
          return matchingDefaultChild;
        } else {
          if (typeof partialChild.cols === "number")
            partialChild.cols = { sm: partialChild.cols };
          if (typeof partialChild.cols === "object" && partialChild.cols.xs === void 0)
            partialChild.cols.xs = 12;
          if (partialChild.key) {
            const matchingDefaultChild = defaultChildren.find((c) => c.key === partialChild.key);
            if (!matchingDefaultChild)
              throw new Error(`unknown child "${partialChild.key}"`);
            return (
              /** @type {Child} */
              partialChild
            );
          } else {
            const child = partialChild;
            if (isPartialChildComposite(child)) {
              if (!child.comp)
                child.comp = "section";
              child.children = getChildren(defaultChildren, child.children);
            }
            if (!("key" in partialChild)) {
              child.key = `$comp-${compI}`;
              compI++;
            }
            return (
              /** @type {Child} */
              child
            );
          }
        }
      });
    }
    function getDefaultComp(partial, schemaFragment, type2, schemaChild) {
      const hasSimpleType = type2 && ["string", "integer", "number"].includes(type2);
      if (schemaChild === "oneOf")
        return "one-of-select";
      if (schemaChild === "patternProperties")
        return "list";
      if (hasSimpleType && schemaFragment.enum)
        return schemaFragment.enum.length > 20 ? "autocomplete" : "select";
      if (hasSimpleType && schemaFragment.oneOf)
        return schemaFragment.oneOf.length > 20 ? "autocomplete" : "select";
      if (hasSimpleType && schemaFragment.examples)
        return type2 === "string" ? "combobox" : "number-combobox";
      if (hasSimpleType && schemaFragment.anyOf && schemaFragment.anyOf.length && Object.keys(schemaFragment.anyOf[schemaFragment.anyOf.length - 1]).length === 0) {
        return type2 === "string" ? "combobox" : "number-combobox";
      }
      if (type2 === "string" && partial.separator)
        return "combobox";
      if (partial.items)
        return partial.items.length > 20 ? "autocomplete" : "select";
      if (partial.getItems) {
        if (isPartialGetItemsFetch(partial.getItems)) {
          if (partial.getItems.qSearchParam)
            return "autocomplete";
          if (typeof partial.getItems.url === "string" && partial.getItems.url.includes("{q}"))
            return "autocomplete";
          if (typeof partial.getItems.url === "object" && typeof partial.getItems.url.expr === "string" && partial.getItems.url.expr.includes("{q}"))
            return "autocomplete";
        }
        return "select";
      }
      if (type2 === "array" && schemaFragment.items) {
        const hasSimpleTypeItems = ["string", "integer", "number"].includes(schemaFragment.items.type);
        if (hasSimpleTypeItems && (schemaFragment.items.enum || schemaFragment.items.oneOf)) {
          return (schemaFragment.items.enum || schemaFragment.items.oneOf).length > 20 ? "autocomplete" : "select";
        }
        if (hasSimpleTypeItems && schemaFragment.items.examples) {
          return schemaFragment.items.type === "string" ? "combobox" : "number-combobox";
        }
        if (hasSimpleTypeItems && schemaFragment.items.anyOf && schemaFragment.items.anyOf.length && Object.keys(schemaFragment.items.anyOf[schemaFragment.items.anyOf.length - 1]).length === 0) {
          return schemaFragment.items.type === "string" ? "combobox" : "number-combobox";
        }
        if (hasSimpleTypeItems && !schemaFragment.items.layout && !["date", "date-time", "time"].includes(schemaFragment.items.format)) {
          return schemaFragment.items.type === "string" ? "combobox" : "number-combobox";
        }
      }
      if (type2 === "object")
        return "section";
      if (type2 === "array") {
        if (Array.isArray(schemaFragment.items))
          return "section";
        else
          return "list";
      }
      if (type2 === "string") {
        if (schemaFragment.format === "date")
          return "date-picker";
        if (schemaFragment.format === "date-time")
          return "date-time-picker";
        if (schemaFragment.format === "time")
          return "time-picker";
        return "text-field";
      }
      if (type2 === "integer" || type2 === "number")
        return "number-field";
      if (type2 === "boolean")
        return "checkbox";
      throw new Error("failed to calculate default component for schema fragment");
    }
    function getPartialCompObject(layoutKeyword) {
      if (isPartialCompObject(layoutKeyword))
        return { ...layoutKeyword };
      else if (isComponentName(layoutKeyword))
        return { comp: layoutKeyword };
      else if (isPartialChildren(layoutKeyword))
        return { children: layoutKeyword };
      return {};
    }
    function looksPure(expression) {
      const expr = typeof expression === "string" ? expression : expression.expr;
      return !expr.includes("rootData.") && !expr.includes("rootData[") && !expr.includes("parent.data") && !expr.includes("parent.parent");
    }
    function normalizeExpression(expression, defaultType = "js-eval", defaultDataAlias = "value") {
      const defaultPure = looksPure(expression);
      if (typeof expression === "string")
        return { type: defaultType, expr: expression, pure: defaultPure, dataAlias: defaultDataAlias };
      else
        return { pure: defaultPure, type: defaultType, dataAlias: defaultDataAlias, ...expression };
    }
    function getItemsFromSchema(schemaFragment) {
      if (!schemaFragment)
        return null;
      const { type: type2 } = getSchemaFragmentType(schemaFragment);
      const hasSimpleType = type2 && ["string", "integer", "number"].includes(type2);
      if (schemaFragment.enum && hasSimpleType) {
        return schemaFragment.enum.map((value) => ({ key: value + "", title: value + "", value }));
      }
      if (schemaFragment.examples && hasSimpleType) {
        return schemaFragment.examples.map((value) => ({ key: value + "", title: value + "", value }));
      }
      if (schemaFragment.anyOf && hasSimpleType && schemaFragment.anyOf.length && Object.keys(schemaFragment.anyOf[schemaFragment.anyOf.length - 1]).length === 0) {
        const nonEmptyAnyOf = schemaFragment.anyOf.slice(0, -1);
        if (!nonEmptyAnyOf.find((oneOfItem) => !("const" in oneOfItem))) {
          return nonEmptyAnyOf.map((anyOfItem) => ({
            ...anyOfItem,
            key: anyOfItem.const + "",
            title: (anyOfItem.title ?? anyOfItem.const) + "",
            value: anyOfItem.const
          }));
        }
      }
      if (schemaFragment.oneOf && hasSimpleType && !schemaFragment.oneOf.find((oneOfItem) => !("const" in oneOfItem))) {
        return schemaFragment.oneOf.map((oneOfItem) => ({
          ...oneOfItem,
          key: oneOfItem.const + "",
          title: (oneOfItem.title ?? oneOfItem.const) + "",
          value: oneOfItem.const
        }));
      }
      return null;
    }
    const getSchemaFragmentType = (schemaFragment) => {
      if (Array.isArray(schemaFragment.type) && schemaFragment.type.length === 2 && schemaFragment.type.includes("null")) {
        const type2 = schemaFragment.type.find((t) => t !== "null");
        return { type: type2, nullable: true };
      }
      if (!schemaFragment.type && (schemaFragment.properties || schemaFragment.patternProperties)) {
        return { type: "object", nullable: false };
      }
      if (!schemaFragment.type) {
        const combinationTypes = [];
        for (const combinationKey of ["allOf", "anyOf", "oneOf"]) {
          if (schemaFragment[combinationKey]) {
            for (const subSchema of schemaFragment[combinationKey]) {
              const { type: subType } = getSchemaFragmentType(subSchema);
              if (subType && !combinationTypes.includes(subType))
                combinationTypes.push(subType);
            }
          }
        }
        if (combinationTypes.length === 1)
          return { type: combinationTypes[0], nullable: false };
      }
      return { type: schemaFragment.type, nullable: false };
    };
    function getCompObject$1(key, layoutKeyword, schemaFragment, type2, nullable, schemaPath, components, markdown, optionsKeys, schemaChild) {
      if ("const" in schemaFragment)
        return { comp: "none" };
      if (!type2)
        return { comp: "none" };
      const partial = getPartialCompObject(layoutKeyword);
      if (type2 === "array" && !schemaFragment.items && partial.comp !== "file-input") {
        return { comp: "none" };
      }
      if (!partial.comp) {
        partial.comp = getDefaultComp(partial, schemaFragment, type2, schemaChild);
      }
      const component = components[partial.comp];
      if (!component) {
        throw new Error(`unknown component "${partial.comp}"`);
      }
      if (partial.comp === "none")
        return { comp: "none" };
      if (nullable)
        partial.nullable = nullable;
      if (component.composite) {
        const children = getChildren(getDefaultChildren(schemaFragment, type2), partial.children);
        partial.children = children;
        if (!("title" in partial)) {
          if (children.length === 1 && children[0].key === "$patternProperties")
            ;
          else {
            partial.title = schemaFragment.title ?? null;
          }
        }
      } else if (partial.comp === "list") {
        if (schemaChild === "patternProperties") {
          if (!("title" in partial)) {
            const children = getChildren(getDefaultChildren(schemaFragment, type2), partial.children);
            if (children.length === 1 && children[0].key === "$patternProperties") {
              partial.title = schemaFragment.title ?? null;
            }
          }
          let hasObjectChild = false;
          for (const patternSchema of Object.values(schemaFragment.patternProperties ?? {})) {
            const { type: patternType } = getSchemaFragmentType(patternSchema);
            if (patternType === "object")
              hasObjectChild = true;
          }
          partial.listEditMode = partial.listEditMode ?? (hasObjectChild ? "inline-single" : "inline");
          partial.listActions = partial.listActions ?? ["add", "edit", "delete"];
          partial.indexed = Object.keys(schemaFragment.patternProperties ?? {});
        } else {
          if (!("title" in partial))
            partial.title = schemaFragment.title ?? "" + key;
          const { type: itemsType } = getSchemaFragmentType(schemaFragment.items);
          partial.listEditMode = partial.listEditMode ?? (itemsType === "object" ? "inline-single" : "inline");
          partial.listActions = partial.listActions ?? ["add", "edit", "delete", "duplicate", "sort"];
        }
      } else {
        if (!("label" in partial) && !schemaChild) {
          partial.label = schemaFragment.title ?? "" + key;
        }
      }
      if (component.itemsBased && !partial.items) {
        let items2;
        if (type2 === "array") {
          items2 = getItemsFromSchema(schemaFragment.items);
        } else {
          items2 = getItemsFromSchema(schemaFragment);
        }
        if (items2) {
          if (partial.getItems && isPartialGetItemsObj(partial.getItems)) {
            partial.getItems.expr = JSON.stringify(items2);
            partial.getItems.immutable = true;
          } else {
            partial.getItems = { expr: JSON.stringify(items2), immutable: true };
          }
        }
      }
      if (component.multipleCompat) {
        if (type2 === "array" || partial.separator) {
          partial.multiple = true;
        }
      }
      if (partial.comp === "date-picker") {
        if (schemaFragment.format === "date")
          partial.format = "date";
        if (schemaFragment.format === "date-time")
          partial.format = "date-time";
      }
      if (["date-picker", "date-time-picker", "time-picker"].includes(partial.comp)) {
        if ("formatMinimum" in schemaFragment)
          partial.min = partial.min ?? schemaFragment.formatMinimum;
        if ("formatMaximum" in schemaFragment)
          partial.max = partial.max ?? schemaFragment.formatMaximum;
      }
      if (["number-field", "slider"].includes(partial.comp)) {
        if (type2 === "integer")
          partial.step = partial.step ?? 1;
        if ("minimum" in schemaFragment)
          partial.min = partial.min ?? schemaFragment.minimum;
        if ("maximum" in schemaFragment)
          partial.max = partial.max ?? schemaFragment.maximum;
      }
      if (partial.if)
        partial.if = normalizeExpression(partial.if);
      if (!partial.defaultData && schemaFragment.type === "string" && schemaPath.split("#").pop() === "") {
        partial.defaultData = "";
      }
      for (const optionKey of optionsKeys) {
        if (optionKey in partial) {
          partial.options = partial.options ?? {};
          partial.options[optionKey] = partial[optionKey];
          delete partial[optionKey];
        }
      }
      if (schemaFragment.readOnly) {
        partial.options = partial.options ?? {};
        if (!("readOnly" in partial.options))
          partial.options.readOnly = true;
      }
      if (partial.getOptions !== void 0)
        partial.getOptions = normalizeExpression(partial.getOptions);
      if (partial.getDefaultData !== void 0)
        partial.getDefaultData = normalizeExpression(partial.getDefaultData);
      if (partial.getConstData !== void 0)
        partial.getConstData = normalizeExpression(partial.getConstData);
      if (partial.transformData !== void 0)
        partial.transformData = normalizeExpression(partial.transformData);
      if (partial.getProps !== void 0)
        partial.getProps = normalizeExpression(partial.getProps);
      if (partial.getItems && isPartialGetItemsExpr(partial.getItems))
        partial.getItems = normalizeExpression(partial.getItems);
      if (partial.getItems && isPartialGetItemsObj(partial.getItems)) {
        if (type2 === "object")
          partial.getItems.returnObjects = true;
        if (type2 === "array") {
          const { type: itemsType } = getSchemaFragmentType(schemaFragment.items);
          if (itemsType === "object")
            partial.getItems.returnObjects = true;
        }
        if (partial.getItems.itemTitle)
          partial.getItems.itemTitle = normalizeExpression(partial.getItems.itemTitle, "js-eval", "item");
        if (partial.getItems.itemKey)
          partial.getItems.itemKey = normalizeExpression(partial.getItems.itemKey, "js-eval", "item");
        if (partial.getItems.itemValue)
          partial.getItems.itemValue = normalizeExpression(partial.getItems.itemValue, "js-eval", "item");
        if (partial.getItems.itemIcon)
          partial.getItems.itemIcon = normalizeExpression(partial.getItems.itemIcon, "js-eval", "item");
        if (partial.getItems.itemsResults)
          partial.getItems.itemsResults = normalizeExpression(partial.getItems.itemsResults, "js-eval", "body");
      }
      if (partial.getItems && isPartialGetItemsFetch(partial.getItems)) {
        partial.getItems.url = normalizeExpression(partial.getItems.url, "js-tpl");
      }
      if (partial.items) {
        partial.items = partial.items.map((item) => {
          if (["string", "integer", "number"].includes(typeof item)) {
            return { title: item + "", key: item + "", value: item };
          } else if (typeof item === "object") {
            return {
              key: (item.key ?? item.value) + "",
              title: (item.title ?? item.key ?? item.value) + "",
              value: item.value ?? item.key
            };
          } else {
            throw new Error(`bad item for select: ${JSON.stringify(item)}`);
          }
        });
      }
      if (!partial.comp && (partial.items ?? partial.getItems)) {
        partial.comp = "select";
      }
      if (partial.comp === "date-picker" && schemaFragment.format === "date-time") {
        partial.format = "date-time";
      }
      if (partial.slots) {
        for (const [name, slot] of Object.entries(partial.slots)) {
          if (typeof slot === "string") {
            if (["before", "after"].includes(name)) {
              partial.slots[name] = { markdown: slot };
            } else {
              partial.slots[name] = { name: slot };
            }
          }
          const slotObj = partial.slots[name];
          if (isPartialSlotMarkdown(slotObj)) {
            slotObj.markdown = markdown(slotObj.markdown).trim();
          }
        }
      }
      if (schemaFragment.description) {
        if (component.composite && !!partial.title) {
          if (partial.subtitle === void 0) {
            partial.subtitle = schemaFragment.description;
          }
        } else if (partial.help === void 0 && schemaChild !== "oneOf") {
          partial.help = schemaFragment.description;
        }
      }
      if (partial.help)
        partial.help = markdown(partial.help).trim();
      if (partial.subtitle)
        partial.subtitle = markdown(partial.subtitle).trim();
      if (typeof partial.cols === "number")
        partial.cols = { xs: partial.cols };
      if (typeof partial.cols === "object" && partial.cols.xs === void 0)
        partial.cols.xs = 12;
      const validateComponent = getComponentValidate(component);
      if (!validateComponent(partial)) {
        const error2 = new Error(`component "${component.name}" validation errors`);
        error2.cause = lighterValidationErrors(validateComponent.errors);
        throw error2;
      }
      return (
        /** @type {BaseCompObject} */
        partial
      );
    }
    function getNormalizedLayout(key, layoutKeyword, schemaFragment, type2, nullable, schemaPath, components, markdown, optionsKeys, schemaChild) {
      if (isPartialSwitch(layoutKeyword)) {
        const normalizedSwitchCases = [];
        const switchCases = [...layoutKeyword.switch];
        if (!switchCases.find((s) => !s.if)) {
          switchCases.push({});
        }
        for (let i2 = 0; i2 < switchCases.length; i2++) {
          const switchCase = switchCases[i2];
          const compObjectResult = getCompObject$1(key, switchCase, schemaFragment, type2, nullable, schemaPath, components, markdown, optionsKeys, schemaChild);
          normalizedSwitchCases.push(compObjectResult);
        }
        return { switch: normalizedSwitchCases };
      } else {
        return getCompObject$1(key, layoutKeyword, schemaFragment, type2, nullable, schemaPath, components, markdown, optionsKeys, schemaChild);
      }
    }
    function matchValidationError(error2, fn) {
      if (error2.keyword === "errorMessage") {
        error2 = error2.params.errors[0];
      }
      return fn(error2);
    }
    function lighterValidationErrors(errors2) {
      if (!errors2)
        return [];
      const compositeErrors = errors2.filter((e) => matchValidationError(e, (e2) => e2.keyword === "anyOf" || e2.keyword === "oneOf"));
      for (const compositeError of compositeErrors) {
        const explicitError = errors2.find((e) => matchValidationError(e, (e2) => e2.instancePath === compositeError.instancePath && e2.keyword !== "type"));
        if (explicitError) {
          errors2 = errors2.filter((e) => matchValidationError(e, (e2) => e2.instancePath !== compositeError.instancePath || e2.keyword !== "type"));
        }
      }
      const messages = [];
      for (const error2 of errors2) {
        let message = error2.message ?? error2.keyword;
        if (error2.params)
          message += " " + JSON.stringify(error2.params);
        messages.push(message);
      }
      return messages;
    }
    const defaultOptionsKeys = ["readOnly", "summary", "titleDepth", "density", "removeAdditional", "validateOn", "updateOne", "debounceInputMs", "initialValidation", "defaultOn", "readOnlyPropertiesMode"];
    function normalizeValidLayoutFragment(key, schemaFragment, type2, nullable, schemaPath, components, markdown, optionsKeys, schemaChild) {
      optionsKeys = optionsKeys ? optionsKeys.concat(defaultOptionsKeys) : defaultOptionsKeys;
      let layoutKeyword;
      if (schemaChild === "oneOf") {
        layoutKeyword = schemaFragment.oneOfLayout ?? {};
      } else if (schemaChild === "patternProperties") {
        layoutKeyword = schemaFragment.patternPropertiesLayout ?? {};
      } else {
        layoutKeyword = schemaFragment.layout ?? {};
      }
      if (!validateLayoutKeyword(layoutKeyword)) {
        const error2 = new Error("layout keyword validation errors at path");
        error2.cause = lighterValidationErrors(validateLayoutKeyword.errors);
        throw error2;
      }
      const normalizedLayout = getNormalizedLayout(key, layoutKeyword, schemaFragment, type2, nullable, schemaPath, components, markdown, optionsKeys, schemaChild);
      if (!validateNormalizedLayout(normalizedLayout)) {
        const error2 = new Error("normalized layout validation errors at path");
        error2.cause = lighterValidationErrors(validateNormalizedLayout.errors);
        throw error2;
      }
      return normalizedLayout;
    }
    function normalizeLayoutFragment(key, schemaFragment, schemaPath, components, markdown = (src) => src, optionsKeys, schemaChild, knownType, knownNullable) {
      const { type: type2, nullable } = knownType ? { type: knownType, nullable: knownNullable ?? false } : getSchemaFragmentType(schemaFragment);
      const errors2 = [];
      try {
        const layout = normalizeValidLayoutFragment(key, schemaFragment, type2, nullable, schemaPath, components, markdown, optionsKeys, schemaChild);
        return { layout, errors: errors2 };
      } catch (err) {
        try {
          errors2.push(err.message);
          if (err.cause && Array.isArray(err.cause))
            errors2.push(...err.cause);
          errors2.push("failed to normalize layout, use default component");
          const layout = normalizeValidLayoutFragment(key, { ...schemaFragment, layout: {} }, type2, nullable, schemaPath, components, markdown, optionsKeys, schemaChild);
          return { layout, errors: errors2 };
        } catch (err2) {
          errors2.push(err2.message);
          if (err2.cause && Array.isArray(err2.cause))
            errors2.push(...err2.cause);
          errors2.push("failed to produce default layout, hide this fragment");
          return { layout: { comp: "none" }, errors: errors2 };
        }
      }
    }
    function copyBuffer(cur) {
      if (cur instanceof Buffer) {
        return Buffer.from(cur);
      }
      return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
    }
    function rfdc() {
      return clone2;
      function cloneArray(a, fn) {
        const keys2 = Object.keys(a);
        const a2 = new Array(keys2.length);
        for (let i2 = 0; i2 < keys2.length; i2++) {
          const k = keys2[i2];
          const cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur instanceof Date) {
            a2[k] = new Date(cur);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            a2[k] = fn(cur);
          }
        }
        return a2;
      }
      function clone2(o2) {
        if (typeof o2 !== "object" || o2 === null)
          return o2;
        if (o2 instanceof Date)
          return new Date(o2);
        if (Array.isArray(o2))
          return cloneArray(o2, clone2);
        if (o2 instanceof Map)
          return new Map(cloneArray(Array.from(o2), clone2));
        if (o2 instanceof Set)
          return new Set(cloneArray(Array.from(o2), clone2));
        const o22 = {};
        for (const k in o2) {
          if (Object.hasOwnProperty.call(o2, k) === false)
            continue;
          const cur = o2[k];
          if (typeof cur !== "object" || cur === null) {
            o22[k] = cur;
          } else if (cur instanceof Date) {
            o22[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o22[k] = new Map(cloneArray(Array.from(cur), clone2));
          } else if (cur instanceof Set) {
            o22[k] = new Set(cloneArray(Array.from(cur), clone2));
          } else if (ArrayBuffer.isView(cur)) {
            o22[k] = copyBuffer(cur);
          } else {
            o22[k] = clone2(cur);
          }
        }
        return o22;
      }
    }
    const clone$1 = rfdc();
    const prepareGetJSONRef = (schemas, ajv2) => {
      return (sourceSchemaId, ref2) => {
        var _a2;
        const fullRef = ajv2.opts.uriResolver.resolve(sourceSchemaId, ref2);
        const [schemaId, pointer] = fullRef.split("#");
        schemas[schemaId] = schemas[schemaId] ?? ((_a2 = ajv2.getSchema(schemaId)) == null ? void 0 : _a2.schema);
        if (!schemas[schemaId])
          throw new Error(`reference not found ${schemaId}`);
        const pointerParts = pointer.split("/").filter((p2) => !!p2);
        const { value: fragment } = pointerParts.reduce((a, pointerPart) => {
          a.path.push(pointerPart);
          if (!(pointerPart in a.value))
            throw new Error(`reference not found ${schemaId}#${a.path.join("/")}`);
          a.value = a.value[pointerPart];
          return a;
        }, { path: (
          /** @type {string[]} */
          []
        ), value: schemas[schemaId] });
        return [fragment, schemaId, fullRef];
      };
    };
    function resolveLocaleRefs(schema2, ajv2, locale = "en") {
      if (!schema2.$id)
        throw new Error("missing schema id");
      const getJSONRef = prepareGetJSONRef({ [schema2.$id]: schema2 }, ajv2);
      const recursed = [];
      recurseResolveLocale(schema2, schema2.$id, getJSONRef, locale, recursed);
      return getJSONRef;
    }
    const recurseResolveLocale = (schemaFragment, schemaId, getJSONRef, locale, recursed) => {
      if (recursed.includes(schemaFragment))
        return;
      recursed.push(schemaFragment);
      for (const key of Object.keys(schemaFragment)) {
        if (schemaFragment[key] && typeof schemaFragment[key] === "object") {
          if ("$ref" in schemaFragment[key]) {
            const ref2 = schemaFragment[key].$ref.replace("~$locale~", locale);
            const refDefaultLocale = schemaFragment[key].$ref.replace("~$locale~", "en");
            let refFragment, refSchemaId;
            try {
              [refFragment, refSchemaId] = getJSONRef(schemaId, ref2);
              schemaFragment[key].$ref = ref2;
            } catch (err) {
              [refFragment, refSchemaId] = getJSONRef(schemaId, refDefaultLocale);
              schemaFragment[key].$ref = refDefaultLocale;
            }
            if (typeof refFragment === "string") {
              schemaFragment[key] = refFragment;
            } else {
              recurseResolveLocale(refFragment, refSchemaId, getJSONRef, locale, recursed);
            }
          } else {
            recurseResolveLocale(schemaFragment[key], schemaId, getJSONRef, locale, recursed);
          }
        }
      }
    };
    function partialResolveRefs(schema2, schemaId, getJSONRef) {
      let clonedSchema = null;
      if (schema2.items && schema2.items.$ref) {
        const [refFragment] = getJSONRef(schemaId, schema2.items.$ref);
        clonedSchema = clonedSchema ?? clone$1(schema2);
        clonedSchema.items = { ...refFragment, ...schema2.items };
      }
      if (schema2.properties) {
        for (const key in schema2.properties) {
          if (schema2.properties[key].$ref) {
            const [refFragment] = getJSONRef(schemaId, schema2.properties[key].$ref);
            clonedSchema = clonedSchema ?? clone$1(schema2);
            clonedSchema.properties[key] = { ...refFragment, ...schema2.properties[key] };
          }
        }
      }
      if (schema2.oneOf) {
        for (let i2 = 0; i2 < schema2.oneOf.length; i2++) {
          if (schema2.oneOf[i2].$ref) {
            const [refFragment] = getJSONRef(schemaId, schema2.oneOf[i2].$ref);
            clonedSchema = clonedSchema ?? clone$1(schema2);
            clonedSchema.oneOf[i2] = { ...refFragment, ...schema2.oneOf[i2] };
          }
        }
      }
      if (schema2.anyOf) {
        for (let i2 = 0; i2 < schema2.anyOf.length; i2++) {
          if (schema2.anyOf[i2].$ref) {
            const [refFragment] = getJSONRef(schemaId, schema2.anyOf[i2].$ref);
            clonedSchema = clonedSchema ?? clone$1(schema2);
            clonedSchema.anyOf[i2] = { ...refFragment, ...schema2.anyOf[i2] };
          }
        }
      }
      if (schema2.allOf) {
        for (let i2 = 0; i2 < schema2.allOf.length; i2++) {
          if (schema2.allOf[i2].$ref) {
            const [refFragment] = getJSONRef(schemaId, schema2.allOf[i2].$ref);
            clonedSchema = clonedSchema ?? clone$1(schema2);
            clonedSchema.allOf[i2] = { ...refFragment, ...schema2.allOf[i2] };
          }
        }
      }
      return clonedSchema ?? schema2;
    }
    function makeSkeletonNode(rawSchema, sourceSchemaId, options, getJSONRef, skeletonTrees, skeletonNodes, validates, validationErrors, normalizedLayouts, expressions, key, pointer, required2, condition, dependent, knownType) {
      var _a2, _b, _c, _d, _e, _f, _g, _h;
      let schemaId = sourceSchemaId;
      let schema2 = rawSchema;
      let refPointer = pointer;
      let refFragment;
      rawSchema.__pointer = pointer;
      if (schema2.$ref) {
        [refFragment, schemaId, refPointer] = getJSONRef(sourceSchemaId, schema2.$ref);
        refFragment.__pointer = refPointer;
        schema2 = { ...rawSchema, ...refFragment };
        delete schema2.$ref;
      }
      const resolvedSchema = partialResolveRefs(schema2, schemaId, getJSONRef);
      let { type: type2, nullable } = getSchemaFragmentType(resolvedSchema);
      if (knownType)
        type2 = knownType;
      rawSchema.errorMessage = rawSchema.errorMessage ?? {};
      if (!normalizedLayouts[pointer]) {
        const normalizationResult = normalizeLayoutFragment(
          key,
          /** @type {import('@json-layout/vocabulary').SchemaFragment} */
          resolvedSchema,
          pointer,
          options.components,
          options.markdown,
          options.optionsKeys,
          void 0,
          type2,
          nullable
        );
        normalizedLayouts[pointer] = normalizationResult.layout;
        if (normalizationResult.errors.length) {
          validationErrors[pointer.replace("_jl#", "/")] = normalizationResult.errors;
        }
      }
      const normalizedLayout = normalizedLayouts[pointer];
      let pure = !dependent;
      const pushExpression = (expressions2, expression) => {
        if (!expression.pure)
          pure = false;
        const index = expressions2.findIndex((e) => e.type === expression.type && e.expr === expression.expr);
        if (index !== -1) {
          expression.ref = index;
        } else {
          expression.ref = expressions2.length;
          expressions2.push(expression);
        }
      };
      const compObjects = isSwitchStruct(normalizedLayout) ? normalizedLayout.switch : [normalizedLayout];
      for (const compObject of compObjects) {
        if (compObject.if)
          pushExpression(expressions, compObject.if);
        if (schema2.const !== void 0 && compObject.constData === void 0)
          compObject.constData = schema2.const;
        if (compObject.constData !== void 0 && !compObject.getConstData)
          compObject.getConstData = { type: "js-eval", expr: "layout.constData", pure: true, dataAlias: "value" };
        if (compObject.getConstData)
          pushExpression(expressions, compObject.getConstData);
        let defaultData;
        if ("default" in schema2)
          defaultData = schema2.default;
        else if (required2) {
          if (nullable)
            defaultData = null;
          else if (type2 === "object" && isCompositeLayout(compObject, options.components))
            defaultData = {};
          else if (type2 === "array")
            defaultData = [];
        }
        if (defaultData !== void 0 && compObject.defaultData === void 0)
          compObject.defaultData = defaultData;
        if (compObject.defaultData !== void 0 && !compObject.getDefaultData)
          compObject.getDefaultData = { type: "js-eval", expr: "layout.defaultData", pure: true, dataAlias: "value" };
        if (compObject.getDefaultData)
          pushExpression(expressions, compObject.getDefaultData);
        if (compObject.options !== void 0 && !compObject.getOptions)
          compObject.getOptions = { type: "js-eval", expr: "layout.options", pure: true, dataAlias: "value" };
        if (compObject.getOptions)
          pushExpression(expressions, compObject.getOptions);
        if (compObject.props !== void 0 && !compObject.getProps)
          compObject.getProps = { type: "js-eval", expr: "layout.props", pure: true, dataAlias: "value" };
        if (compObject.getProps)
          pushExpression(expressions, compObject.getProps);
        if (compObject.transformData)
          pushExpression(expressions, compObject.transformData);
        if (isItemsLayout(compObject, options.components) && compObject.getItems) {
          if (isGetItemsExpression(compObject.getItems))
            pushExpression(expressions, compObject.getItems);
          if (isGetItemsFetch(compObject.getItems))
            pushExpression(expressions, compObject.getItems.url);
          if (compObject.getItems.itemTitle)
            pushExpression(expressions, compObject.getItems.itemTitle);
          if (compObject.getItems.itemKey)
            pushExpression(expressions, compObject.getItems.itemKey);
          if (compObject.getItems.itemValue)
            pushExpression(expressions, compObject.getItems.itemValue);
          if (compObject.getItems.itemIcon)
            pushExpression(expressions, compObject.getItems.itemIcon);
          if (compObject.getItems.itemsResults)
            pushExpression(expressions, compObject.getItems.itemsResults);
        }
      }
      const node = {
        key: key ?? "",
        pointer,
        refPointer,
        pure,
        propertyKeys: [],
        roPropertyKeys: [],
        nullable,
        required: required2 && !nullable
      };
      if (condition) {
        if (isSwitchStruct(normalizedLayout))
          throw new Error("Switch struct not allowed in conditional schema");
        node.condition = { type: "js-eval", expr: condition, pure: true, dataAlias: "value" };
        pushExpression(expressions, node.condition);
      }
      if (schema2.oneOf) {
        rawSchema.errorMessage.oneOf = options.messages.errorOneOf;
      }
      if (type2 === "object") {
        if (schema2.properties) {
          node.children = node.children ?? [];
          for (const propertyKey of Object.keys(schema2.properties)) {
            node.propertyKeys.push(propertyKey);
            if (schema2.properties[propertyKey].readOnly)
              node.roPropertyKeys.push(propertyKey);
            const dependent2 = schema2.dependentRequired && Object.values(schema2.dependentRequired).some((dependentProperties) => dependentProperties.includes(propertyKey));
            const childPointer = `${refPointer}/properties/${propertyKey}`;
            if (!skeletonNodes[childPointer]) {
              skeletonNodes[childPointer] = "recursing";
              skeletonNodes[childPointer] = makeSkeletonNode(
                schema2.properties[propertyKey],
                schemaId,
                options,
                getJSONRef,
                skeletonTrees,
                skeletonNodes,
                validates,
                validationErrors,
                normalizedLayouts,
                expressions,
                propertyKey,
                childPointer,
                (_a2 = schema2.required) == null ? void 0 : _a2.includes(propertyKey),
                void 0,
                dependent2
              );
            }
            node.children.push(childPointer);
            if (((_b = schema2.dependentSchemas) == null ? void 0 : _b[propertyKey]) || ((_c = schema2.dependencies) == null ? void 0 : _c[propertyKey]) && !Array.isArray(schema2.dependencies[propertyKey])) {
              const dependentSchema = ((_d = schema2.dependentSchemas) == null ? void 0 : _d[propertyKey]) ?? schema2.dependencies[propertyKey];
              const dependentPointer = ((_e = schema2.dependentSchemas) == null ? void 0 : _e[propertyKey]) ? `${refPointer}/dependentSchemas/${propertyKey}` : `${refPointer}/dependencies/${propertyKey}`;
              if (!skeletonNodes[dependentPointer]) {
                skeletonNodes[dependentPointer] = "recursing";
                skeletonNodes[dependentPointer] = makeSkeletonNode(
                  dependentSchema,
                  schemaId,
                  options,
                  getJSONRef,
                  skeletonTrees,
                  skeletonNodes,
                  validates,
                  validationErrors,
                  normalizedLayouts,
                  expressions,
                  `$deps-${propertyKey}`,
                  dependentPointer,
                  false,
                  `data["${propertyKey}"] !== undefined`,
                  void 0,
                  "object"
                );
              }
              node.children.push(dependentPointer);
            }
          }
        }
        if (schema2.allOf) {
          for (let i2 = 0; i2 < schema2.allOf.length; i2++) {
            const childPointer = `${refPointer}/allOf/${i2}`;
            if (!skeletonNodes[childPointer]) {
              skeletonNodes[childPointer] = "recursing";
              skeletonNodes[childPointer] = makeSkeletonNode(
                schema2.allOf[i2],
                schemaId,
                options,
                getJSONRef,
                skeletonTrees,
                skeletonNodes,
                validates,
                validationErrors,
                normalizedLayouts,
                expressions,
                `$allOf-${i2}`,
                childPointer,
                false,
                void 0,
                void 0,
                "object"
              );
            }
            node.propertyKeys = node.propertyKeys.concat(skeletonNodes[childPointer].propertyKeys);
            node.roPropertyKeys = node.roPropertyKeys.concat(skeletonNodes[childPointer].roPropertyKeys);
            node.children = node.children ?? [];
            node.children.push(childPointer);
          }
        }
        if (schema2.oneOf) {
          const oneOfPointer = `${pointer}/oneOf`;
          if (!normalizedLayouts[oneOfPointer]) {
            const normalizationResult = normalizeLayoutFragment(
              "",
              schema2,
              oneOfPointer,
              options.components,
              options.markdown,
              options.optionsKeys,
              "oneOf",
              type2,
              nullable
            );
            normalizedLayouts[oneOfPointer] = normalizationResult.layout;
            if (normalizationResult.errors.length) {
              validationErrors[oneOfPointer.replace("_jl#", "/")] = normalizationResult.errors;
            }
          }
          const childrenTrees = [];
          for (let i2 = 0; i2 < schema2.oneOf.length; i2++) {
            if (!schema2.oneOf[i2].type)
              schema2.oneOf[i2].type = type2;
            const title2 = schema2.oneOf[i2].title ?? `option ${i2}`;
            delete schema2.oneOf[i2].title;
            const childTreePointer = `${oneOfPointer}/${i2}`;
            if (!skeletonTrees[childTreePointer]) {
              skeletonTrees[childTreePointer] = "recursing";
              skeletonTrees[childTreePointer] = makeSkeletonTree(
                schema2.oneOf[i2],
                schemaId,
                options,
                getJSONRef,
                skeletonTrees,
                skeletonNodes,
                validates,
                validationErrors,
                normalizedLayouts,
                expressions,
                childTreePointer,
                title2
              );
            }
            childrenTrees.push(childTreePointer);
          }
          if (!skeletonNodes[oneOfPointer]) {
            skeletonNodes[oneOfPointer] = {
              key: "$oneOf",
              pointer: oneOfPointer,
              refPointer: oneOfPointer,
              childrenTrees,
              pure: !childrenTrees.some((childTree) => {
                var _a3;
                return !skeletonNodes[(_a3 = skeletonTrees[childTree]) == null ? void 0 : _a3.root].pure;
              }),
              propertyKeys: [],
              roPropertyKeys: []
            };
          }
          node.children = node.children ?? [];
          node.children.push(oneOfPointer);
        }
        if (schema2.patternProperties) {
          const patternPropertiesPointer = `${pointer}/patternProperties`;
          if (!normalizedLayouts[patternPropertiesPointer]) {
            const normalizationResult = normalizeLayoutFragment(
              "",
              schema2,
              patternPropertiesPointer,
              options.components,
              options.markdown,
              options.optionsKeys,
              "patternProperties",
              type2,
              nullable
            );
            normalizedLayouts[patternPropertiesPointer] = normalizationResult.layout;
            if (normalizationResult.errors.length) {
              validationErrors[patternPropertiesPointer.replace("_jl#", "/")] = normalizationResult.errors;
            }
          }
          const childrenTrees = [];
          for (const pattern2 of Object.keys(schema2.patternProperties)) {
            const childTreePointer = `${patternPropertiesPointer}/${pattern2}`;
            if (!skeletonTrees[childTreePointer]) {
              skeletonTrees[childTreePointer] = "recursing";
              skeletonTrees[childTreePointer] = makeSkeletonTree(
                schema2.patternProperties[pattern2],
                schemaId,
                options,
                getJSONRef,
                skeletonTrees,
                skeletonNodes,
                validates,
                validationErrors,
                normalizedLayouts,
                expressions,
                childTreePointer,
                "pattern " + pattern2
              );
              const childLayout = normalizedLayouts[skeletonNodes[skeletonTrees[childTreePointer].root].pointer];
              if (isSwitchStruct(childLayout)) {
                for (const switchCase of childLayout.switch) {
                  switchCase.nullable = true;
                }
              } else {
                childLayout.nullable = true;
              }
            }
            childrenTrees.push(childTreePointer);
          }
          if (!skeletonNodes[patternPropertiesPointer]) {
            skeletonNodes[patternPropertiesPointer] = {
              key: "$patternProperties",
              pointer: patternPropertiesPointer,
              refPointer: patternPropertiesPointer,
              childrenTrees,
              pure: !childrenTrees.some((childTree) => {
                var _a3;
                return !skeletonNodes[(_a3 = skeletonTrees[childTree]) == null ? void 0 : _a3.root].pure;
              }),
              propertyKeys: [],
              roPropertyKeys: []
            };
          }
          node.children = node.children ?? [];
          node.children.push(patternPropertiesPointer);
        }
        if (schema2.if) {
          validates.push(`${pointer}/if`);
          if (schema2.then) {
            const childPointer = `${refPointer}/then`;
            if (!skeletonNodes[childPointer]) {
              skeletonNodes[childPointer] = "recursing";
              skeletonNodes[childPointer] = makeSkeletonNode(
                schema2.then,
                schemaId,
                options,
                getJSONRef,
                skeletonTrees,
                skeletonNodes,
                validates,
                validationErrors,
                normalizedLayouts,
                expressions,
                "$then",
                childPointer,
                false,
                `validates["${pointer}/if"](data)`,
                void 0,
                "object"
              );
            }
            node.children = node.children ?? [];
            node.children.push(childPointer);
          }
          if (schema2.else) {
            const childPointer = `${refPointer}/else`;
            if (!skeletonNodes[childPointer]) {
              skeletonNodes[childPointer] = "recursing";
              skeletonNodes[childPointer] = makeSkeletonNode(
                schema2.else,
                schemaId,
                options,
                getJSONRef,
                skeletonTrees,
                skeletonNodes,
                validates,
                validationErrors,
                normalizedLayouts,
                expressions,
                "$else",
                childPointer,
                false,
                `!validates["${pointer}/if"](data)`,
                void 0,
                "object"
              );
            }
            node.children = node.children ?? [];
            node.children.push(childPointer);
          }
        }
        for (const propertyKey of node.propertyKeys) {
          if ((_f = schema2 == null ? void 0 : schema2.required) == null ? void 0 : _f.includes(propertyKey)) {
            rawSchema.errorMessage.required = rawSchema.errorMessage.required ?? {};
            rawSchema.errorMessage.required[propertyKey] = options.messages.errorRequired;
          }
          if (schema2.dependentRequired && Object.keys(schema2.dependentRequired).includes(propertyKey)) {
            rawSchema.errorMessage.dependentRequired = options.messages.errorRequired;
          }
        }
      }
      if (type2 === "array" && schema2.items) {
        if (Array.isArray(schema2.items)) {
          node.children = node.children ?? [];
          for (let i2 = 0; i2 < schema2.items.length; i2++) {
            const itemSchema = schema2.items[i2];
            const childPointer = `${refPointer}/items/${i2}`;
            if (!skeletonNodes[childPointer]) {
              skeletonNodes[childPointer] = "recursing";
              skeletonNodes[childPointer] = makeSkeletonNode(
                itemSchema,
                schemaId,
                options,
                getJSONRef,
                skeletonTrees,
                skeletonNodes,
                validates,
                validationErrors,
                normalizedLayouts,
                expressions,
                i2,
                childPointer,
                true
              );
            }
            node.children.push(childPointer);
          }
        } else {
          const childTreePointer = `${pointer}/items`;
          if (!skeletonTrees[childTreePointer]) {
            skeletonTrees[childTreePointer] = "recursing";
            skeletonTrees[childTreePointer] = makeSkeletonTree(
              schema2.items,
              schemaId,
              options,
              getJSONRef,
              skeletonTrees,
              skeletonNodes,
              validates,
              validationErrors,
              normalizedLayouts,
              expressions,
              childTreePointer,
              schema2.items.title
            );
          }
          node.childrenTrees = [childTreePointer];
          const childLayout = normalizedLayouts[skeletonNodes[skeletonTrees[childTreePointer].root].pointer];
          if (isSwitchStruct(childLayout)) {
            for (const switchCase of childLayout.switch) {
              switchCase.nullable = true;
            }
          } else {
            childLayout.nullable = true;
          }
        }
      }
      for (const childPointer of node.children || []) {
        const child = skeletonNodes[childPointer];
        if (!child.pure)
          node.pure = false;
      }
      for (const childTree of node.childrenTrees || []) {
        if (!((_h = skeletonNodes[(_g = skeletonTrees[childTree]) == null ? void 0 : _g.root]) == null ? void 0 : _h.pure))
          node.pure = false;
      }
      return node;
    }
    function makeSkeletonTree(schema2, schemaId, options, getJSONRef, skeletonTrees, skeletonNodes, validates, validationErrors, normalizedLayouts, expressions, pointer, title2) {
      if (!skeletonNodes[pointer]) {
        skeletonNodes[pointer] = "recursing";
        skeletonNodes[pointer] = makeSkeletonNode(
          schema2,
          schemaId,
          options,
          getJSONRef,
          skeletonTrees,
          skeletonNodes,
          validates,
          validationErrors,
          normalizedLayouts,
          expressions,
          "",
          pointer,
          true
        );
        validates.push(pointer);
      }
      return { title: title2, root: pointer };
    }
    function shallowProduceArray(previousArray = [], newArray = []) {
      if (!previousArray || !newArray || previousArray.length !== newArray.length)
        return newArray;
      for (let i2 = 0; i2 < previousArray.length; i2++) {
        if (previousArray[i2] !== newArray[i2])
          return newArray;
      }
      return previousArray;
    }
    function shallowProduceObject(previousObj = {}, newObj = {}) {
      if (!previousObj || !newObj)
        return newObj;
      const previousKeys = Object.keys(previousObj);
      const newKeys = Object.keys(newObj);
      if (previousKeys.length !== newKeys.length)
        return newObj;
      for (const key of previousKeys) {
        if (previousObj[key] !== newObj[key])
          return newObj;
      }
      return previousObj;
    }
    function shallowEqualArray(a1 = [], a2 = []) {
      if (!a1 || !a2)
        return a1 === a2;
      if (a1.length !== a2.length)
        return false;
      for (let i2 = 0; i2 < a1.length; i2++) {
        if (a1[i2] !== a2[i2])
          return false;
      }
      return true;
    }
    const Ajv = (
      /** @type {typeof ajvModule.default} */
      ajvModule
    );
    const ajvLocalize = (
      /** @type {typeof ajvLocalizeModule.default} */
      ajvLocalizeModule
    );
    const produceCompileOptions = produce((draft, newOptions) => {
      for (const key of ["ajv", "ajvOptions", "code", "markdown", "markdownItOptions", "locale", "messages", "optionsKeys", "components"]) {
        if (key in newOptions) {
          if (key === "components" && shallowEqualArray(Object.keys(draft.components ?? []), Object.keys(newOptions.components ?? []))) {
            continue;
          }
          draft[key] = newOptions[key];
        } else {
          delete draft[key];
        }
      }
    });
    const fillOptions$1 = (partialOptions) => {
      let ajv2 = partialOptions.ajv;
      if (!ajv2) {
        const ajvOpts = { allErrors: true, strict: false, verbose: true };
        if (partialOptions.ajvOptions)
          Object.assign(ajvOpts, partialOptions.ajvOptions);
        if (partialOptions.code)
          ajvOpts.code = { source: true, esm: true, lines: true };
        const newAjv = new Ajv(ajvOpts);
        addFormats.default(newAjv);
        ajvErrors.default(newAjv);
        ajv2 = newAjv;
      }
      ajv2.addKeyword("layout");
      let markdown = partialOptions.markdown;
      if (!markdown) {
        const markdownIt2 = new MarkdownIt(partialOptions.markdownItOptions ?? {});
        markdown = markdownIt2.render.bind(markdownIt2);
      }
      const locale = partialOptions.locale || "en";
      const messages = { ...i18n[locale] || i18n.en };
      if (partialOptions.messages)
        Object.assign(messages, partialOptions.messages);
      const components = standardComponents.reduce(
        (acc, component) => {
          acc[component.name] = component;
          return acc;
        },
        /** @type {Record<string, import('@json-layout/vocabulary').ComponentInfo>} */
        {}
      );
      if (partialOptions.components) {
        for (const componentName of Object.keys(partialOptions.components)) {
          components[componentName] = { ...partialOptions.components[componentName], name: componentName };
        }
        Object.assign(components, partialOptions.components);
      }
      return {
        ajv: ajv2,
        code: false,
        markdown,
        optionsKeys: [],
        ...partialOptions,
        locale,
        messages,
        components
      };
    };
    function compile(_schema, partialOptions = {}) {
      const options = fillOptions$1(partialOptions);
      const schema2 = (
        /** @type {import('ajv').SchemaObject} */
        clone$1(_schema)
      );
      schema2.$id = schema2.$id ?? "_jl";
      const getJSONRef = resolveLocaleRefs(schema2, options.ajv, options.locale);
      const validatePointers = [];
      const normalizedLayouts = {};
      const expressionsDefinitions = [];
      const validationErrors = {};
      const skeletonTrees = {};
      const skeletonNodes = {};
      const mainTreePointer = `${schema2.$id}#`;
      skeletonTrees[mainTreePointer] = "recursing";
      skeletonTrees[mainTreePointer] = makeSkeletonTree(
        schema2,
        schema2.$id,
        options,
        getJSONRef,
        skeletonTrees,
        skeletonNodes,
        validatePointers,
        validationErrors,
        normalizedLayouts,
        expressionsDefinitions,
        mainTreePointer,
        "main"
      );
      options.ajv.addSchema(schema2);
      const uriResolver = options.ajv.opts.uriResolver;
      const validates = {};
      for (const pointer of validatePointers) {
        const fullPointer = uriResolver.resolve(schema2.$id, pointer);
        validates[pointer] = options.ajv.compile({ $ref: fullPointer });
      }
      const expressions = [];
      for (const expression of expressionsDefinitions) {
        const expressionsParams = expression.pure ? ["data", expression.dataAlias, "options", "context", "display", "layout", "validates"] : ["data", expression.dataAlias, "options", "context", "display", "layout", "validates", "rootData", "parent"];
        if (expression.type === "js-fn") {
          expressions.push(
            /** @type {CompiledExpression} */
            new Function(...expressionsParams, expression.expr)
          );
        }
        if (expression.type === "js-eval") {
          expressions.push(
            /** @type {CompiledExpression} */
            new Function(...expressionsParams, "return (" + expression.expr + ")")
          );
        }
        if (expression.type === "js-tpl") {
          expressions.push(
            /** @type {CompiledExpression} */
            new Function(...expressionsParams, "return `" + expression.expr + "`")
          );
        }
      }
      if (Object.keys(validationErrors).length) {
        console.error("JSON layout encountered some validation errors:", validationErrors);
      }
      return {
        options,
        schema: schema2,
        mainTree: mainTreePointer,
        skeletonTrees,
        skeletonNodes,
        validates,
        validationErrors,
        normalizedLayouts,
        expressions,
        locale: options.locale,
        messages: options.messages,
        components: options.components,
        // @ts-ignore
        localizeErrors: ajvLocalize[options.locale] || ajvLocalize.en
      };
    }
    var browser = { exports: {} };
    var ms;
    var hasRequiredMs;
    function requireMs() {
      if (hasRequiredMs)
        return ms;
      hasRequiredMs = 1;
      var s = 1e3;
      var m = s * 60;
      var h2 = m * 60;
      var d = h2 * 24;
      var w = d * 7;
      var y = d * 365.25;
      ms = function(val, options) {
        options = options || {};
        var type2 = typeof val;
        if (type2 === "string" && val.length > 0) {
          return parse2(val);
        } else if (type2 === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
        );
      };
      function parse2(str2) {
        str2 = String(str2);
        if (str2.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str2
        );
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type2 = (match[2] || "ms").toLowerCase();
        switch (type2) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h2;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return void 0;
        }
      }
      function fmtShort(ms2) {
        var msAbs = Math.abs(ms2);
        if (msAbs >= d) {
          return Math.round(ms2 / d) + "d";
        }
        if (msAbs >= h2) {
          return Math.round(ms2 / h2) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms2 / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms2 / s) + "s";
        }
        return ms2 + "ms";
      }
      function fmtLong(ms2) {
        var msAbs = Math.abs(ms2);
        if (msAbs >= d) {
          return plural(ms2, msAbs, d, "day");
        }
        if (msAbs >= h2) {
          return plural(ms2, msAbs, h2, "hour");
        }
        if (msAbs >= m) {
          return plural(ms2, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms2, msAbs, s, "second");
        }
        return ms2 + " ms";
      }
      function plural(ms2, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
      }
      return ms;
    }
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = requireMs();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i2);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms2 = curr - (prevTime || curr);
          self2.diff = ms2;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend2;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend2(namespace, delimiter2) {
        const newDebug = createDebug(this.namespace + (typeof delimiter2 === "undefined" ? ":" : delimiter2) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i2;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i2 = 0; i2 < len; i2++) {
          if (!split[i2]) {
            continue;
          }
          namespaces = split[i2].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i2;
        let len;
        for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
          if (createDebug.skips[i2].test(name)) {
            return false;
          }
        }
        for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
          if (createDebug.names[i2].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    var common = setup;
    var define_process_env_default = {};
    (function(module2, exports2) {
      exports2.formatArgs = formatArgs;
      exports2.save = save;
      exports2.load = load2;
      exports2.useColors = useColors;
      exports2.storage = localstorage();
      exports2.destroy = /* @__PURE__ */ (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports2.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        let m;
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      exports2.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports2.storage.setItem("debug", namespaces);
          } else {
            exports2.storage.removeItem("debug");
          }
        } catch (error2) {
        }
      }
      function load2() {
        let r2;
        try {
          r2 = exports2.storage.getItem("debug");
        } catch (error2) {
        }
        if (!r2 && typeof process !== "undefined" && "env" in process) {
          r2 = define_process_env_default.DEBUG;
        }
        return r2;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error2) {
        }
      }
      module2.exports = common(exports2);
      const { formatters } = module2.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error2) {
          return "[UnexpectedJSONParseError]: " + error2.message;
        }
      };
    })(browser, browser.exports);
    var browserExports = browser.exports;
    const Debug = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
    const names = ["xs", "sm", "md", "lg", "xl", "xxl"];
    const thresholds = {
      xs: 0,
      sm: 600,
      md: 960,
      lg: 1280,
      xl: 1920,
      xxl: 2560
    };
    class Display {
      /**
       * @param {number} width
       */
      constructor(width) {
        /**
         * @readonly
         * @type {number}
         */
        __publicField(this, "width");
        this.width = width;
      }
      /** @returns {BreakPointName} */
      get name() {
        for (let i2 = 0; i2 < names.length; i2++) {
          if (names[i2 + 1] && this.width < thresholds[names[i2 + 1]])
            return names[i2];
        }
        return "xxl";
      }
      /** @returns {boolean} */
      get xs() {
        return this.width < thresholds.sm;
      }
      /** @returns {boolean} */
      get sm() {
        return this.width >= thresholds.sm && this.width < thresholds.md;
      }
      /** @returns {boolean} */
      get smAndDown() {
        return this.width < thresholds.md;
      }
      /** @returns {boolean} */
      get smAndUp() {
        return this.width >= thresholds.sm;
      }
      /** @returns {boolean} */
      get md() {
        return this.width >= thresholds.md && this.width < thresholds.lg;
      }
      /** @returns {boolean} */
      get mdAndDown() {
        return this.width < thresholds.lg;
      }
      /** @returns {boolean} */
      get mobile() {
        return this.mdAndDown;
      }
      /** @returns {boolean} */
      get mdAndUp() {
        return this.width >= thresholds.md;
      }
      /** @returns {boolean} */
      get lg() {
        return this.width >= thresholds.lg && this.width < thresholds.xl;
      }
      /** @returns {boolean} */
      get lgAndDown() {
        return this.width < thresholds.xl;
      }
      /** @returns {boolean} */
      get lgAndUp() {
        return this.width >= thresholds.lg;
      }
      /** @returns {boolean} */
      get xl() {
        return this.width >= thresholds.xl && this.width < thresholds.xxl;
      }
      /** @returns {boolean} */
      get xlAndDown() {
        return this.width < thresholds.xxl;
      }
      /** @returns {boolean} */
      get xlAndUp() {
        return this.width >= thresholds.xl;
      }
      /** @returns {boolean} */
      get xxl() {
        return this.width >= thresholds.xxl;
      }
    }
    function getChildDisplay(parentDisplay, colsObj) {
      if (!colsObj)
        return [parentDisplay, 12];
      let cols = colsObj.xs;
      if (parentDisplay.smAndUp && colsObj.sm !== void 0)
        cols = colsObj.sm;
      if (parentDisplay.mdAndUp && colsObj.md !== void 0)
        cols = colsObj.md;
      if (parentDisplay.lgAndUp && colsObj.lg !== void 0)
        cols = colsObj.lg;
      if (parentDisplay.xlAndUp && colsObj.xl !== void 0)
        cols = colsObj.xl;
      if (parentDisplay.xxl && colsObj.xxl !== void 0)
        cols = colsObj.xxl;
      const display = cols === 12 ? parentDisplay : new Display(Math.round(parentDisplay.width * (cols / 12)));
      return [display, cols];
    }
    const cache = {};
    function getRegexp(str2) {
      cache[str2] = cache[str2] ?? new RegExp(str2);
      return cache[str2];
    }
    const logStateNode = Debug("jl:state-node");
    const isDataEmpty = (data) => {
      if (data === "" || data === void 0)
        return true;
      if (Array.isArray(data) && !data.length)
        return true;
      if (typeof data === "object" && !Array.isArray(data) && !!data && Object.values(data).findIndex((prop2) => prop2 !== void 0) === -1)
        return true;
      return false;
    };
    const useDefaultData = (data, layout, options) => {
      if (options.defaultOn === "missing" && data === void 0)
        return true;
      if (options.defaultOn === "empty" && isDataEmpty(data))
        return true;
      return false;
    };
    const produceStateNode = produce((draft, key, fullKey, parentFullKey, dataPath, parentDataPath, skeleton, layout, width, cols, data, error2, validated, options, autofocus, props, itemsCacheKey, children) => {
      draft.messages = layout.messages ? produceStateNodeMessages(draft.messages || {}, layout.messages, options) : options.messages;
      draft.key = key;
      draft.fullKey = fullKey;
      draft.parentFullKey = parentFullKey;
      draft.dataPath = dataPath;
      draft.parentDataPath = parentDataPath;
      draft.skeleton = skeleton;
      draft.layout = layout;
      draft.width = width;
      draft.options = options;
      draft.cols = cols;
      draft.data = data;
      draft.error = error2;
      draft.itemsCacheKey = itemsCacheKey;
      draft.childError = children && children.findIndex((c) => c.error || c.childError) !== -1;
      draft.validated = validated;
      if (autofocus) {
        draft.autofocus = true;
        delete draft.autofocusChild;
      } else {
        delete draft.autofocus;
        const autofocusChild = children == null ? void 0 : children.find((c) => c.autofocus);
        if (autofocusChild)
          draft.autofocusChild = autofocusChild.key;
        else
          delete draft.autofocusChild;
      }
      draft.props = props;
      draft.children = children;
    });
    const produceStateNodeMessages = produce((draft, layoutMessages, options) => {
      Object.assign(draft, options.messages, layoutMessages);
    });
    const produceStateNodeDataChildrenArray = produce((draft, children) => {
      for (const child of children) {
        const key = (
          /** @type {number} */
          child.key
        );
        if (child.data === void 0)
          delete draft[key];
        else
          draft[key] = child.data;
      }
      while (draft.length && draft[draft.length - 1] === void 0) {
        draft.pop();
      }
    });
    const produceStateNodeDataArray = produce((draft, parentDataPath, additionalPropertiesErrors, propertyKeys, removePropertyKeys) => {
      for (let i2 = 0; i2 < draft.length; i2++) {
        if (!(draft[i2] instanceof File)) {
          draft[i2] = produceStateNodeData(draft[i2], parentDataPath + "/" + i2, void 0, additionalPropertiesErrors, propertyKeys, removePropertyKeys);
        }
      }
    });
    const produceStateNodeData = produce((draft, parentDataPath, children, additionalPropertiesErrors, propertyKeys, removePropertyKeys) => {
      if (propertyKeys && (propertyKeys.length || (children == null ? void 0 : children.length))) {
        for (const key of Object.keys(draft)) {
          if (!propertyKeys.includes(key))
            delete draft[key];
        }
      }
      if (removePropertyKeys) {
        for (const key of removePropertyKeys) {
          delete draft[key];
        }
      }
      if (children) {
        for (const child of children) {
          if (parentDataPath === child.dataPath) {
            if (child.data === void 0)
              continue;
            Object.assign(draft, child.data);
          } else {
            if (child.data === void 0)
              delete draft[child.key];
            else
              draft[child.key] = child.data;
          }
        }
      }
      if (additionalPropertiesErrors) {
        for (const error2 of additionalPropertiesErrors) {
          if (error2.instancePath !== parentDataPath)
            continue;
          if (error2.keyword === "additionalProperties") {
            delete draft[error2.params.additionalProperty];
          }
          if (error2.keyword === "unevaluatedProperties") {
            delete draft[error2.params.unevaluatedProperty];
          }
        }
      }
    });
    const producePatternPropertiesData = produce((draft, parentData, propertyKeys, patterns) => {
      for (const key of Object.keys(parentData)) {
        if (propertyKeys.includes(key))
          continue;
        if (!patterns.some((p2) => !!key.match(getRegexp(p2))))
          continue;
        draft[key] = parentData[key];
      }
      for (const key of Object.keys(draft)) {
        if (!(key in parentData))
          delete draft[key];
      }
    });
    const produceNodeOptions = produce((draft, parentNodeOptions, nodeOptions = {}) => {
      for (const key in parentNodeOptions) {
        draft[key] = nodeOptions[key] ?? parentNodeOptions[key];
      }
      for (const key in nodeOptions) {
        draft[key] = nodeOptions[key];
      }
      for (const key in draft) {
        if (!(key in parentNodeOptions) && !(key in nodeOptions)) {
          delete draft[key];
        }
      }
    });
    const produceReadonlyArrayItemOptions = produce((draft) => {
      draft.readOnly = true;
      draft.summary = true;
    });
    const produceCompositeChildrenOptions = produce((draft, section) => {
      if (section.title && draft.titleDepth < 6)
        draft.titleDepth += 1;
    });
    const matchError = (error2, skeleton, dataPath, parentDataPath) => {
      var _a2, _b, _c;
      const originalError = ((_b = (_a2 = error2.params) == null ? void 0 : _a2.errors) == null ? void 0 : _b[0]) ?? error2;
      if (parentDataPath === originalError.instancePath && ((_c = originalError.params) == null ? void 0 : _c.missingProperty) === skeleton.key)
        return true;
      if (originalError.instancePath === dataPath && (originalError.schemaPath === skeleton.pointer || originalError.schemaPath === skeleton.refPointer))
        return true;
      return false;
    };
    const matchChildError = (error2, skeleton, dataPath, parentDataPath) => {
      var _a2, _b;
      const originalError = ((_b = (_a2 = error2.params) == null ? void 0 : _a2.errors) == null ? void 0 : _b[0]) ?? error2;
      if (!(originalError.schemaPath === skeleton.pointer || originalError.schemaPath.startsWith(skeleton.pointer + "/")) && !(originalError.schemaPath === skeleton.refPointer || originalError.schemaPath.startsWith(skeleton.refPointer + "/")))
        return false;
      if (originalError.instancePath.startsWith(dataPath))
        return true;
      return false;
    };
    function evalExpression(expressions, expression, data, options, display, layout, validates, rootData, parentContext) {
      if (expression.ref === void 0)
        throw new Error("expression was not compiled : " + JSON.stringify(expression));
      const compiledExpression = expressions[expression.ref];
      try {
        if (expression.pure) {
          return compiledExpression(data, data, options, options.context, display, layout, validates);
        } else {
          return compiledExpression(data, data, options, options.context, display, layout, validates, rootData, parentContext);
        }
      } catch (err) {
        const info = { expression, data, context: options.context, display };
        info[expression.dataAlias] = data;
        if (!expression.pure) {
          info.rootData = rootData;
          info.parent = parentContext;
        }
        console.warn("json-layout: failed to evaluate expression", err, info);
        throw new Error("json-layout: failed to evaluate expression");
      }
    }
    const getCompObject = (normalizedLayout, options, compiledLayout, display, data, rootData, parentContext) => {
      if (isSwitchStruct(normalizedLayout)) {
        for (const compObject of normalizedLayout.switch) {
          if (!compObject.if || !!evalExpression(compiledLayout.expressions, compObject.if, data, options, display, compObject, compiledLayout.validates, rootData, parentContext)) {
            return compObject;
          }
        }
      } else {
        if (normalizedLayout.if) {
          if (evalExpression(compiledLayout.expressions, normalizedLayout.if, data, options, display, normalizedLayout, compiledLayout.validates, rootData, parentContext)) {
            return normalizedLayout;
          }
        } else {
          return normalizedLayout;
        }
      }
      return { comp: "none" };
    };
    function createStateNode(context, parentOptions, compiledLayout, key, fullKey, parentFullKey, dataPath, parentDataPath, skeleton, childDefinition, parentDisplay, data, parentContext, validationState, reusedNode) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
      logStateNode("createStateNode", fullKey);
      let cacheKey = null;
      if (skeleton.pure && !(reusedNode == null ? void 0 : reusedNode.error) && !(reusedNode == null ? void 0 : reusedNode.childError)) {
        const validatedCacheKey = validationState.validatedForm || validationState.validatedChildren.includes(fullKey);
        cacheKey = [parentOptions, compiledLayout, fullKey, skeleton, childDefinition, parentDisplay.width, validatedCacheKey, context.activatedItems, context.initial, data];
        if (reusedNode && context.cacheKeys[fullKey] && shallowEqualArray(context.cacheKeys[fullKey], cacheKey)) {
          logStateNode("createStateNode cache hit", fullKey);
          if (context._debugCache)
            context._debugCache[fullKey] = (context._debugCache[fullKey] ?? []).concat(["hit"]);
          return reusedNode;
        } else {
          logStateNode("createStateNode cache miss", fullKey);
          if (context._debugCache)
            context._debugCache[fullKey] = (context._debugCache[fullKey] ?? []).concat(["miss"]);
        }
      } else {
        logStateNode("createStateNode cache skip", fullKey);
        if (context._debugCache)
          context._debugCache[fullKey] = (context._debugCache[fullKey] ?? []).concat(["skip"]);
      }
      const normalizedLayout = childDefinition && childIsCompObject(childDefinition) ? childDefinition : compiledLayout.normalizedLayouts[skeleton.pointer];
      const layout = getCompObject(normalizedLayout, parentOptions, compiledLayout, parentDisplay, data, context.rootData, parentContext);
      const [display, cols] = getChildDisplay(parentDisplay, (childDefinition == null ? void 0 : childDefinition.cols) ?? layout.cols);
      const options = layout.getOptions ? produceNodeOptions(
        (reusedNode == null ? void 0 : reusedNode.options) ?? /** @type {import('./types.js').StateNodeOptions} */
        {},
        parentOptions,
        evalExpression(compiledLayout.expressions, layout.getOptions, data, parentOptions, display, layout, compiledLayout.validates, context.rootData, parentContext)
      ) : parentOptions;
      if (context.initial && parentOptions.autofocus && layout.autofocus && layout.comp !== "none") {
        context.autofocusTarget = fullKey;
      }
      let children;
      if (isCompositeLayout(layout, compiledLayout.components)) {
        const objectData = (
          /** @type {Record<string, unknown>} */
          data ?? {}
        );
        const childrenOptions = produceCompositeChildrenOptions(options, layout);
        children = [];
        let focusChild2 = context.autofocusTarget === fullKey;
        for (let i2 = 0; i2 < layout.children.length; i2++) {
          const childLayout = layout.children[i2];
          if (["remove", "hide"].includes(options.readOnlyPropertiesMode) && ((_a2 = skeleton.roPropertyKeys) == null ? void 0 : _a2.includes(
            /** @type {string} */
            childLayout.key
          )))
            continue;
          let childSkeleton = skeleton;
          const childSkeletonKey = (_b = skeleton.children) == null ? void 0 : _b.find((c) => compiledLayout.skeletonNodes[c].key === childLayout.key);
          if (childSkeletonKey !== void 0)
            childSkeleton = compiledLayout.skeletonNodes[childSkeletonKey];
          if (childSkeleton.condition) {
            if (!evalExpression(compiledLayout.expressions, childSkeleton.condition, objectData, parentOptions, display, layout, compiledLayout.validates, context.rootData, parentContext)) {
              continue;
            }
          }
          const isSameDataPath = typeof childLayout.key === "string" && childLayout.key.startsWith("$");
          const childFullKey = `${fullKey}/${childLayout.key}`;
          if (focusChild2)
            context.autofocusTarget = childFullKey;
          let childData = isSameDataPath ? objectData : objectData[childLayout.key];
          if (childLayout.key === "$patternProperties") {
            const childNormalizedLayout = (
              /** @type {import('@json-layout/vocabulary').List} */
              compiledLayout.normalizedLayouts[childSkeleton.pointer]
            );
            childData = producePatternPropertiesData(
              /** @type {Record<string, unknown>} */
              ((_d = (_c = reusedNode == null ? void 0 : reusedNode.children) == null ? void 0 : _c.find((c) => c.key === "$patternProperties")) == null ? void 0 : _d.data) ?? {},
              /** @type {Record<string, unknown>} */
              objectData,
              skeleton.propertyKeys,
              childNormalizedLayout.indexed ?? []
            );
          }
          const child = createStateNode(
            context,
            childrenOptions,
            compiledLayout,
            childLayout.key,
            childFullKey,
            fullKey,
            isSameDataPath ? dataPath : `${dataPath}/${childLayout.key}`,
            dataPath,
            childSkeleton,
            childLayout,
            display,
            childData,
            { parent: parentContext, data: objectData },
            validationState,
            (_e = reusedNode == null ? void 0 : reusedNode.children) == null ? void 0 : _e.find((c) => c.fullKey === childFullKey)
          );
          if (child.autofocus || child.autofocusChild !== void 0)
            focusChild2 = false;
          children.push(child);
        }
      }
      if (key === "$oneOf" && skeleton.childrenTrees) {
        const activeChildTreeIndex = (
          /** @type {number} */
          fullKey in context.activatedItems ? context.activatedItems[fullKey] : (_f = skeleton.childrenTrees) == null ? void 0 : _f.findIndex((childTree) => compiledLayout.validates[compiledLayout.skeletonTrees[childTree].root](data))
        );
        if (activeChildTreeIndex !== -1) {
          context.errors = (_g = context.errors) == null ? void 0 : _g.filter((error3) => {
            var _a3, _b2;
            const originalError = ((_b2 = (_a3 = error3.params) == null ? void 0 : _a3.errors) == null ? void 0 : _b2[0]) ?? error3;
            if (matchError(error3, skeleton, dataPath, parentDataPath))
              return false;
            if (matchChildError(error3, skeleton, dataPath)) {
              if (originalError.schemaPath.startsWith(skeleton.pointer) && !originalError.schemaPath.startsWith(skeleton.pointer + "/" + activeChildTreeIndex))
                return false;
              if (originalError.schemaPath.startsWith(skeleton.refPointer) && !originalError.schemaPath.startsWith(skeleton.refPointer + "/" + activeChildTreeIndex))
                return false;
            }
            return true;
          });
          const activeChildKey = `${fullKey}/${activeChildTreeIndex}`;
          if (context.autofocusTarget === fullKey)
            context.autofocusTarget = activeChildKey;
          const activeChildTree = compiledLayout.skeletonTrees[skeleton.childrenTrees[activeChildTreeIndex]];
          children = [
            createStateNode(
              context,
              options,
              compiledLayout,
              activeChildTreeIndex,
              activeChildKey,
              fullKey,
              dataPath,
              dataPath,
              compiledLayout.skeletonNodes[activeChildTree.root],
              null,
              display,
              data,
              { parent: parentContext, data },
              validationState,
              (_h = reusedNode == null ? void 0 : reusedNode.children) == null ? void 0 : _h[0]
            )
          ];
        }
      }
      if (isListLayout(layout)) {
        if (layout.indexed) {
          const objectData = (
            /** @type {Record<string, unknown>} */
            data ?? []
          );
          const listItemOptions = layout.listEditMode === "inline" ? options : produceReadonlyArrayItemOptions(options);
          children = [];
          let focusChild2 = context.autofocusTarget === fullKey;
          const childrenKeys = Object.keys(objectData);
          for (let i2 = 0; i2 < childrenKeys.length; i2++) {
            const childKey = childrenKeys[i2];
            let valueChildSkeleton = (
              /** @type {import('../index.js').SkeletonNode | null} */
              null
            );
            if (((_i = skeleton == null ? void 0 : skeleton.childrenTrees) == null ? void 0 : _i.length) === 1) {
              valueChildSkeleton = compiledLayout.skeletonNodes[(_j = compiledLayout.skeletonTrees[skeleton == null ? void 0 : skeleton.childrenTrees[0]]) == null ? void 0 : _j.root];
            } else {
              for (let p2 = 0; p2 < layout.indexed.length; p2++) {
                const pattern2 = layout.indexed[p2];
                const childTreeKey = (_k = skeleton == null ? void 0 : skeleton.childrenTrees) == null ? void 0 : _k[p2];
                if (!childTreeKey)
                  throw new Error(`missing skeleton tree for pattern ${pattern2}`);
                if (childKey.match(getRegexp(pattern2))) {
                  valueChildSkeleton = compiledLayout.skeletonNodes[(_l = compiledLayout.skeletonTrees[childTreeKey]) == null ? void 0 : _l.root];
                }
              }
            }
            if (valueChildSkeleton) {
              const childFullKey = `${fullKey}/${childKey}`;
              if (focusChild2)
                context.autofocusTarget = childFullKey;
              const valueChild = createStateNode(
                context,
                layout.listEditMode === "inline-single" && context.activatedItems[fullKey] === i2 ? options : listItemOptions,
                compiledLayout,
                childKey,
                childFullKey,
                fullKey,
                `${dataPath}/${childKey}`,
                dataPath,
                valueChildSkeleton,
                null,
                display,
                objectData[childKey],
                { parent: parentContext, data: objectData },
                validationState,
                (_m = reusedNode == null ? void 0 : reusedNode.children) == null ? void 0 : _m.find((c) => c.key === childKey)
              );
              if (valueChild.autofocus || valueChild.autofocusChild !== void 0)
                focusChild2 = false;
              children.push(valueChild);
            }
          }
        } else {
          const arrayData = (
            /** @type {unknown[]} */
            data ?? []
          );
          const childSkeleton = (
            /** @type {import('../index.js').SkeletonNode} */
            ((_n = skeleton == null ? void 0 : skeleton.childrenTrees) == null ? void 0 : _n[0]) && compiledLayout.skeletonNodes[(_p = compiledLayout.skeletonTrees[(_o = skeleton == null ? void 0 : skeleton.childrenTrees) == null ? void 0 : _o[0]]) == null ? void 0 : _p.root]
          );
          const listItemOptions = layout.listEditMode === "inline" ? options : produceReadonlyArrayItemOptions(options);
          children = [];
          let focusChild2 = context.autofocusTarget === fullKey;
          for (let i2 = 0; i2 < arrayData.length; i2++) {
            const itemData = arrayData[i2];
            const childFullKey = `${fullKey}/${i2}`;
            if (focusChild2)
              context.autofocusTarget = childFullKey;
            const child = createStateNode(
              context,
              layout.listEditMode === "inline-single" && context.activatedItems[fullKey] === i2 ? options : listItemOptions,
              compiledLayout,
              i2,
              childFullKey,
              fullKey,
              `${dataPath}/${i2}`,
              dataPath,
              childSkeleton,
              null,
              display,
              itemData,
              { parent: parentContext, data: arrayData },
              validationState,
              (_q = reusedNode == null ? void 0 : reusedNode.children) == null ? void 0 : _q[i2]
            );
            if (child.autofocus || child.autofocusChild !== void 0)
              focusChild2 = false;
            children.push(child);
          }
        }
      }
      let error2 = (_r = context.errors) == null ? void 0 : _r.find((error3) => matchError(error3, skeleton, dataPath, parentDataPath));
      if (!error2) {
        error2 = (_s = context.errors) == null ? void 0 : _s.findLast((error3) => matchChildError(error3, skeleton, dataPath));
      }
      if (layout.comp !== "none") {
        if (error2) {
          context.errors = (_t = context.errors) == null ? void 0 : _t.filter((error3) => {
            return !matchError(error3, skeleton, dataPath, parentDataPath) && !matchChildError(error3, skeleton, dataPath);
          });
        }
      }
      let nodeData = data;
      if (nodeData === null && !layout.nullable)
        nodeData = void 0;
      const validated = validationState.validatedForm || validationState.validatedChildren.includes(fullKey) || validationState.initialized === false && options.initialValidation === "always" || validationState.initialized === false && options.initialValidation === "withData" && !isDataEmpty(nodeData);
      if (typeof ((_u = children == null ? void 0 : children[0]) == null ? void 0 : _u.key) === "number" && layout.comp !== "one-of-select" && !layout.indexed) {
        nodeData = produceStateNodeDataChildrenArray(
          /** @type {unknown[]} */
          nodeData ?? [],
          children
        );
      } else if (Array.isArray(nodeData)) {
        const itemsSkeletonTree = ((_v = skeleton.childrenTrees) == null ? void 0 : _v[0]) && compiledLayout.skeletonTrees[(_w = skeleton.childrenTrees) == null ? void 0 : _w[0]];
        const itemsSkeletonNode = itemsSkeletonTree && compiledLayout.skeletonNodes[itemsSkeletonTree.root] || null;
        nodeData = produceStateNodeDataArray(
          /** @type {Record<string, unknown>[]} */
          nodeData ?? [],
          dataPath,
          context.additionalPropertiesErrors,
          [true, "unknown"].includes(options.removeAdditional) ? itemsSkeletonNode == null ? void 0 : itemsSkeletonNode.propertyKeys : void 0,
          options.readOnlyPropertiesMode === "remove" ? itemsSkeletonNode == null ? void 0 : itemsSkeletonNode.roPropertyKeys : void 0
        );
      } else if ((typeof nodeData === "object" || nodeData === void 0 && (children == null ? void 0 : children.length)) && !(nodeData instanceof File)) {
        const removeAdditional = [true, "unknown"].includes(options.removeAdditional) || (children == null ? void 0 : children.some((c) => c.key === "$patternProperties"));
        nodeData = produceStateNodeData(
          /** @type {Record<string, unknown>} */
          nodeData ?? {},
          dataPath,
          children,
          context.additionalPropertiesErrors,
          removeAdditional ? skeleton.propertyKeys : void 0,
          options.readOnlyPropertiesMode === "remove" ? skeleton.roPropertyKeys : void 0
        );
      }
      if (nodeData !== data) {
        if (Array.isArray(data) && Array.isArray(nodeData))
          nodeData = shallowProduceArray(data, nodeData);
        else if (typeof data === "object" && typeof nodeData === "object")
          nodeData = shallowProduceObject(data, nodeData);
      }
      if (layout.getConstData) {
        if (!context.rehydrate) {
          nodeData = evalExpression(compiledLayout.expressions, layout.getConstData, nodeData, options, display, layout, compiledLayout.validates, context.rootData, parentContext);
        }
      } else {
        if (layout.getDefaultData && useDefaultData(nodeData, layout, options)) {
          if (!context.rehydrate) {
            const defaultData = evalExpression(compiledLayout.expressions, layout.getDefaultData, nodeData, options, display, layout, compiledLayout.validates, context.rootData, parentContext);
            if (nodeData === void 0 || !isDataEmpty(defaultData)) {
              nodeData = defaultData;
            }
          }
        } else {
          if (isDataEmpty(nodeData)) {
            if (layout.nullable) {
              if (options.defaultOn !== "missing" || nodeData !== void 0) {
                nodeData = null;
              }
            } else if (options.defaultOn !== "missing") {
              nodeData = void 0;
            }
          }
        }
      }
      let props;
      if (layout.getProps) {
        props = evalExpression(compiledLayout.expressions, layout.getProps, nodeData, options, display, layout, compiledLayout.validates, context.rootData, parentContext);
      }
      let itemsCacheKey;
      if (isItemsLayout(layout, compiledLayout.components)) {
        if (layout.items)
          itemsCacheKey = layout.items;
        else if (((_x = layout.getItems) == null ? void 0 : _x.immutable) && (reusedNode == null ? void 0 : reusedNode.itemsCacheKey))
          itemsCacheKey = reusedNode.itemsCacheKey;
        else if (layout.getItems && isGetItemsExpression(layout.getItems)) {
          if (layout.getItems.immutable && (reusedNode == null ? void 0 : reusedNode.itemsCacheKey)) {
            itemsCacheKey = reusedNode.itemsCacheKey;
          } else {
            try {
              itemsCacheKey = evalExpression(compiledLayout.expressions, layout.getItems, nodeData, options, display, layout, compiledLayout.validates, context.rootData, parentContext);
            } catch (err) {
              itemsCacheKey = null;
            }
          }
        } else if (layout.getItems && isGetItemsFetch(layout.getItems)) {
          try {
            itemsCacheKey = evalExpression(compiledLayout.expressions, layout.getItems.url, null, options, display, layout, compiledLayout.validates, context.rootData, parentContext);
          } catch (err) {
            itemsCacheKey = null;
          }
        }
      }
      const autofocus = isFocusableLayout(layout, compiledLayout.components) && !options.readOnly && !options.summary && context.autofocusTarget === fullKey;
      const node = produceStateNode(
        reusedNode ?? /** @type {import('./types.js').StateNode} */
        {},
        key,
        fullKey,
        parentFullKey,
        dataPath,
        parentDataPath,
        skeleton,
        layout,
        display.width,
        cols,
        nodeData,
        error2 == null ? void 0 : error2.message,
        validated,
        options,
        autofocus,
        props,
        itemsCacheKey,
        children && shallowProduceArray(reusedNode == null ? void 0 : reusedNode.children, children)
      );
      if (cacheKey)
        context.cacheKeys[fullKey] = cacheKey;
      return node;
    }
    const producePatchedData = produce((draft, node, data) => {
      if (node.dataPath === node.parentDataPath) {
        Object.assign(draft, data);
        if (node.data && typeof data === "object" && data !== null) {
          for (const key of Object.keys(node.data)) {
            if (!(key in data)) {
              delete draft[key];
            }
          }
        }
      } else {
        draft[node.key] = data;
      }
    });
    const produceStateTree = produce(
      (draft, root, valid) => {
        draft.root = root;
        draft.valid = valid;
      }
    );
    function* traverseNodes(node) {
      yield node;
      if (node.children) {
        for (const child of node.children) {
          yield* traverseNodes(child);
        }
      }
    }
    function createStateTree(context, options, compiledLayout, skeleton, display, data, validationState, reusedStateTree) {
      var _a2, _b;
      const validate2 = compiledLayout.validates[skeleton.root];
      const valid = validate2(data);
      if (validate2.errors) {
        for (const error2 of validate2.errors) {
          if (error2.keyword !== "errorMessage")
            compiledLayout.localizeErrors([error2]);
        }
        context.errors = context.allErrors = validate2.errors;
        if (context.errors.length) {
          for (const error2 of context.errors) {
            const originalError = ((_b = (_a2 = error2.params) == null ? void 0 : _a2.errors) == null ? void 0 : _b[0]) ?? error2;
            if (originalError == null ? void 0 : originalError.parentSchema.__pointer) {
              originalError.schemaPath = originalError == null ? void 0 : originalError.parentSchema.__pointer;
              if (originalError.keyword === "oneOf")
                originalError.schemaPath += "/oneOf";
            }
          }
        }
        if ([true, "error"].includes(options.removeAdditional)) {
          context.additionalPropertiesErrors = validate2.errors.filter((error2) => error2.keyword === "additionalProperties" || error2.keyword === "unevaluatedProperties");
        }
      }
      const root = createStateNode(
        context,
        options,
        compiledLayout,
        "",
        "",
        null,
        "",
        null,
        compiledLayout.skeletonNodes[skeleton.root],
        null,
        display,
        data,
        null,
        validationState,
        reusedStateTree == null ? void 0 : reusedStateTree.root
      );
      context.nodes = [];
      context.files = [];
      for (const node of traverseNodes(root)) {
        context.nodes.push(node);
        if (node.data instanceof File) {
          context.files.push({ dataPath: node.dataPath, file: node.data });
        }
      }
      return produceStateTree(reusedStateTree ?? /** @type {import('./types.js').StateTree} */
      {}, root, valid);
    }
    const isSection = (node) => !!node && node.layout.comp === "section";
    const isItemsNode = (node, components) => !!node && isItemsLayout(node.layout, components);
    const logDataBinding = Debug("jl:data-binding");
    function fillOptions(partialOptions, compiledLayout) {
      const messages = { ...compiledLayout.messages };
      if (partialOptions.messages)
        Object.assign(messages, partialOptions.messages);
      return {
        context: {},
        width: 1e3,
        readOnly: false,
        summary: false,
        density: "default",
        indent: false,
        titleDepth: 2,
        validateOn: "input",
        initialValidation: "withData",
        updateOn: "input",
        debounceInputMs: 300,
        defaultOn: "empty",
        removeAdditional: "error",
        autofocus: false,
        readOnlyPropertiesMode: "show",
        onAutofocus: () => {
        },
        onUpdate: () => {
        },
        onData: () => {
        },
        ...partialOptions,
        messages
      };
    }
    class StatefulLayout {
      /**
       * @param {import("../index.js").CompiledLayout} compiledLayout
       * @param {import("../index.js").SkeletonTree} skeletonTree
       * @param {Partial<StatefulLayoutOptions>} options
       * @param {unknown} [data]
       */
      constructor(compiledLayout, skeletonTree, options, data) {
        /**
         * @private
         * @readonly
         * @type {import('../index.js').CompiledLayout}
         */
        __publicField(this, "_compiledLayout");
        /**
         * @private
         * @type {StateTree}
         */
        // @ts-ignore
        __publicField(this, "_stateTree");
        /**
         * @readonly
         * @type {import('../index.js').SkeletonTree}
         */
        __publicField(this, "skeletonTree");
        /**
         * @private
         * @type {Display}
         */
        // @ts-ignore
        __publicField(this, "_display");
        /**
         * @private
         * @type {import('./types.js').ValidationState}
         */
        // @ts-ignore
        __publicField(this, "_validationState");
        /**
         * @private
         * @type {StatefulLayoutOptions}
         */
        // @ts-ignore
        __publicField(this, "_options");
        /**
         * @private
         * @type {unknown}
         */
        __publicField(this, "_data");
        /**
         * @private
         * @type {unknown}
         */
        __publicField(this, "_previousData");
        /**
         * @private
         * @type {boolean}
         */
        __publicField(this, "_dataWaitingForBlur", false);
        /**
         * @private
         * @type {CreateStateTreeContext}
         */
        // @ts-ignore
        __publicField(this, "_lastCreateStateTreeContext");
        /**
         * @private
         * @type {string | null}
         */
        __publicField(this, "_autofocusTarget");
        /**
         * @private
         * @type {string | null}
         */
        __publicField(this, "_previousAutofocusTarget");
        /**
         * @type {FileRef[]}
         */
        __publicField(this, "files", []);
        /**
         * @private
         * @type {null | [StateNode, unknown, boolean, number | undefined, ReturnType<typeof setTimeout>]}
         */
        __publicField(this, "debouncedInput", null);
        /**
         * @private
         * @type {Record<string, {key: any, appliedQ: boolean, items: import('@json-layout/vocabulary').SelectItems}>}
         */
        __publicField(this, "_itemsCache", {});
        /**
         * @type {Record<string, number>}
         */
        __publicField(this, "activatedItems");
        logDataBinding("create stateful layout", compiledLayout, skeletonTree, options, data);
        this._compiledLayout = compiledLayout;
        this.skeletonTree = skeletonTree;
        this.prepareOptions(options);
        this._autofocusTarget = this.options.autofocus ? "" : null;
        this._previousAutofocusTarget = null;
        this._data = data;
        this._previousData = data;
        this.initValidationState();
        this.activatedItems = {};
        this.updateState();
        this.handleAutofocus();
      }
      get compiledLayout() {
        return this._compiledLayout;
      }
      get stateTree() {
        return this._stateTree;
      }
      get display() {
        return this._display;
      }
      /**
       * @returns {import('./types.js').ValidationState}
       */
      get validationState() {
        return this._validationState;
      }
      /**
       * @private
       * @param {Partial<import('./types.js').ValidationState>} validationState
       */
      set validationState(validationState) {
        this._validationState = {
          initialized: validationState.initialized ?? this._validationState.initialized ?? false,
          validatedForm: validationState.validatedForm ?? this._validationState.validatedForm ?? false,
          validatedChildren: validationState.validatedChildren ?? this._validationState.validatedChildren ?? []
        };
        this.updateState();
      }
      /**
       * @returns {StatefulLayoutOptions}
       */
      get options() {
        return this._options;
      }
      /**
       * @param {Partial<StatefulLayoutOptions>} options
       */
      set options(options) {
        this.prepareOptions(options);
        this.updateState();
      }
      get data() {
        return this._data;
      }
      set data(data) {
        logDataBinding("apply main data setter", data);
        this._data = data;
        this.updateState();
      }
      /**
       * @private
       * @param {Partial<StatefulLayoutOptions>} options
       */
      prepareOptions(options) {
        this._options = fillOptions(options, this.compiledLayout);
        this._display = this._display && this._display.width === this._options.width ? this._display : new Display(this._options.width);
      }
      /**
       * @private
       */
      initValidationState() {
        const initialValidation = this.options.initialValidation === "always";
        this._validationState = {
          initialized: initialValidation,
          validatedForm: initialValidation,
          validatedChildren: []
        };
      }
      /**
       * @private
       */
      updateState() {
        this.createStateTree();
        let nbIter = 0;
        while (this._data !== (this._stateTree.root.data ?? null) || this._autofocusTarget !== this._lastCreateStateTreeContext.autofocusTarget) {
          nbIter += 1;
          if (nbIter > 100) {
            console.error("too many iterations in updateState, the data is probably not stable", this._data, this._stateTree.root.data);
            throw new Error("too many iterations in updateState, the data is probably not stable");
          }
          logDataBinding("hydrating state tree changed the data, do it again", this._data, this._stateTree.root.data);
          this._data = this._stateTree.root.data ?? null;
          this._autofocusTarget = this._lastCreateStateTreeContext.autofocusTarget;
          this.createStateTree(true);
        }
        if (!this._stateTree.valid && !this._stateTree.root.error && !this._stateTree.root.childError) {
          console.error("JSON layout failed to assign validation error to a node", this._lastCreateStateTreeContext.allErrors);
        }
        logDataBinding("emit update event", this._data, this._stateTree);
        this.options.onUpdate(this);
        this.emitData();
      }
      /**
       * @private
       */
      emitData() {
        if (!this._dataWaitingForBlur && this._data !== this._previousData) {
          logDataBinding("emit data event", this._data);
          this.options.onData(this._data);
          this._previousData = this._data;
        }
      }
      /**
       * @private
       * @param {boolean} rehydrate
       */
      createStateTree(rehydrate = false) {
        var _a2, _b;
        const createStateTreeContext = {
          activatedItems: this.activatedItems,
          autofocusTarget: this._autofocusTarget,
          initial: !this._lastCreateStateTreeContext,
          rehydrate,
          cacheKeys: ((_a2 = this._lastCreateStateTreeContext) == null ? void 0 : _a2.cacheKeys) ?? {},
          rootData: this._data,
          files: [],
          nodes: []
        };
        if (this._options._debugCache)
          createStateTreeContext._debugCache = ((_b = this._lastCreateStateTreeContext) == null ? void 0 : _b._debugCache) ?? {};
        this._stateTree = createStateTree(
          createStateTreeContext,
          this._options,
          this._compiledLayout,
          this.skeletonTree,
          this._display,
          this._data,
          this._validationState,
          this._stateTree
        );
        this._lastCreateStateTreeContext = createStateTreeContext;
        if (!this.validationState.initialized) {
          this._validationState = {
            initialized: true,
            validatedForm: this._validationState.validatedForm,
            validatedChildren: createStateTreeContext.nodes.filter((n) => n.validated).map((n) => n.fullKey)
          };
        }
        this.files = shallowProduceArray(this.files, createStateTreeContext.files);
      }
      validate() {
        this.validationState = { validatedForm: true };
      }
      resetValidation() {
        this.initValidationState();
        this.updateState();
      }
      /**
       * @returns {boolean}
       */
      get valid() {
        return this.stateTree.valid;
      }
      /**
       * @returns {string[]}
       */
      get errors() {
        return this._lastCreateStateTreeContext.nodes.filter((n) => !!n.error).map((n) => (
          /** @type {string} */
          n.error
        ));
      }
      /**
       * @returns {boolean}
       */
      get hasHiddenError() {
        return this._lastCreateStateTreeContext.nodes.findIndex((node) => node.error && !node.validated) !== -1;
      }
      /**
       * @private
       * @param {StateNode} node
       * @returns {import('../compile/types.js').ParentContextExpression | null}
       */
      getParentContextExpression(node) {
        const parentNode = this._lastCreateStateTreeContext.nodes.find((n) => n.fullKey === node.parentFullKey);
        if (!parentNode)
          return null;
        return {
          parent: this.getParentContextExpression(parentNode),
          data: parentNode.data
        };
      }
      /**
       * @param {StateNode} node
       * @param {import('@json-layout/vocabulary').Expression} expression
       * @param {any} data
       * @returns {any}
       */
      evalNodeExpression(node, expression, data) {
        return evalExpression(this.compiledLayout.expressions, expression, data, node.options, new Display(node.width), node.layout, this.compiledLayout.validates, this._data, this.getParentContextExpression(node));
      }
      /**
       * @private
       * @param {StateNode} node
       * @param {unknown} data
       * @param {boolean} [validated]
       * @param {number} [activateKey]
       */
      applyInput(node, data, validated, activateKey) {
        logDataBinding("received input event from node", node, data);
        const transformedData = node.layout.transformData && this.evalNodeExpression(node, node.layout.transformData, data);
        if (node.layout.comp === "file-input") {
          if (transformedData) {
            data.toJSON = () => transformedData;
          } else if (data instanceof File) {
            const fileJSON = { name: data.name, size: data.size, type: data.type };
            data.toJSON = () => fileJSON;
          } else if (Array.isArray(data)) {
            for (const file of data) {
              const fileJSON = { name: file.name, size: file.size, type: file.type };
              file.toJSON = () => fileJSON;
            }
          }
        } else if (transformedData) {
          data = transformedData;
        }
        if (validated && !this.validationState.validatedChildren.includes(node.fullKey)) {
          this.validationState = { validatedChildren: this.validationState.validatedChildren.concat([node.fullKey]) };
        }
        if (activateKey !== void 0) {
          this.activatedItems = produce(this.activatedItems, (draft) => {
            draft[node.fullKey] = activateKey;
          });
          this._autofocusTarget = node.fullKey + "/" + activateKey;
        }
        if (node.parentFullKey === null) {
          this._data = data;
          this.updateState();
          return;
        }
        const parentNode = this._lastCreateStateTreeContext.nodes.find((p2) => p2.fullKey === node.parentFullKey);
        if (!parentNode)
          throw new Error(`parent with key "${node.parentFullKey}" not found`);
        const newParentValue = producePatchedData(
          parentNode.data ?? (typeof node.key === "number" ? [] : {}),
          node,
          data === null || data === void 0 ? node.skeleton.nullable ? null : void 0 : data
        );
        this.applyInput(parentNode, newParentValue, validated);
        if (activateKey !== void 0) {
          this.handleAutofocus();
        }
      }
      applyDebouncedInput() {
        if (this.debouncedInput) {
          clearTimeout(this.debouncedInput[3]);
          this.applyInput(this.debouncedInput[0], this.debouncedInput[1], this.debouncedInput[2], this.debouncedInput[3]);
          this.debouncedInput = null;
        }
      }
      /**
       * @param {StateNode} node
       * @param {unknown} data
       * @param {number} [activateKey]
       */
      input(node, data, activateKey) {
        var _a2, _b;
        if (this.debouncedInput) {
          if (this.debouncedInput[0] === node)
            clearTimeout(this.debouncedInput[4]);
          else
            this.applyDebouncedInput();
        }
        const emitsBlur = (_a2 = this.compiledLayout.components[node.layout.comp]) == null ? void 0 : _a2.emitsBlur;
        if (node.options.updateOn === "blur" && emitsBlur) {
          this._dataWaitingForBlur = true;
        }
        const validated = node.options.validateOn === "input" || node.options.validateOn === "blur" && !emitsBlur;
        const shouldDebounce = (_b = this.compiledLayout.components[node.layout.comp]) == null ? void 0 : _b.shouldDebounce;
        if (shouldDebounce && node.options.debounceInputMs) {
          this.debouncedInput = [node, data, validated, activateKey, setTimeout(() => this.applyDebouncedInput(), node.options.debounceInputMs)];
        } else {
          this.applyInput(node, data, validated, activateKey);
        }
      }
      /**
       * @param {StateNode} node
       */
      blur(node) {
        this.applyDebouncedInput();
        logDataBinding("received blur event from node", node);
        if ((node.options.validateOn === "input" || node.options.validateOn === "blur") && !this.validationState.validatedChildren.includes(node.fullKey)) {
          this.validationState = { validatedChildren: this.validationState.validatedChildren.concat([node.fullKey]) };
        }
        if (this._dataWaitingForBlur) {
          this._dataWaitingForBlur = false;
          this.emitData();
        }
      }
      /**
       * @param {StateNode} node
       */
      validateNodeRecurse(node) {
        this.validationState = { validatedChildren: this.validationState.validatedChildren.concat([node.fullKey]) };
        if (node.children) {
          for (const child of node.children) {
            this.validateNodeRecurse(child);
          }
        }
      }
      /**
       * @private
       * @param {StateNode} node
       * @param {string} q
       * @returns {Promise<{appliedQ: boolean, items: import('@json-layout/vocabulary').SelectItems}>}
       */
      async getItemsWithoutCache(node, q = "") {
        var _a2;
        if (!isItemsNode(node, this._compiledLayout.components)) {
          throw new Error("node is not a component with an items list");
        }
        if (node.itemsCacheKey === null)
          return { appliedQ: false, items: [] };
        let appliedQ = false;
        let rawItems;
        if (node.layout.items || node.layout.getItems && isGetItemsExpression(node.layout.getItems)) {
          rawItems = node.itemsCacheKey;
        }
        if (node.layout.getItems && isGetItemsFetch(node.layout.getItems)) {
          const url = new URL(node.itemsCacheKey);
          let qSearchParam = node.layout.getItems.qSearchParam;
          if (!qSearchParam) {
            for (const searchParam of url.searchParams.entries()) {
              if (searchParam[1] === "{q}")
                qSearchParam = searchParam[0];
            }
          }
          if (qSearchParam) {
            appliedQ = true;
            if (q)
              url.searchParams.set(qSearchParam, q);
            else
              url.searchParams.delete(qSearchParam);
          }
          rawItems = await (await fetch(url)).json();
        }
        if (!rawItems) {
          throw new Error(`node ${node.fullKey} is missing items or getItems parameters`);
        }
        if ((_a2 = node.layout.getItems) == null ? void 0 : _a2.itemsResults) {
          rawItems = this.evalNodeExpression(node, node.layout.getItems.itemsResults, rawItems);
        }
        if (!Array.isArray(rawItems))
          throw new Error(`getItems didn't return an array for node ${node.fullKey}, you can define itemsResults to extract the array`);
        const items2 = rawItems.map((rawItem) => {
          return this.prepareSelectItem(node, rawItem);
        });
        return { appliedQ, items: items2 };
      }
      /**
       * @param {StateNode} node
       * @param {string} q
       * @returns {Promise<import('@json-layout/vocabulary').SelectItems>}
       */
      async getItems(node, q = "") {
        let itemsResult;
        if (this._itemsCache[node.fullKey] && this._itemsCache[node.fullKey].key === node.itemsCacheKey && (!q || !this._itemsCache[node.fullKey].appliedQ)) {
          itemsResult = this._itemsCache[node.fullKey];
        } else {
          itemsResult = await this.getItemsWithoutCache(node, q);
          if (!q || !itemsResult.appliedQ) {
            this._itemsCache[node.fullKey] = { key: node.itemsCacheKey, ...itemsResult };
          }
        }
        if (q && !itemsResult.appliedQ)
          return itemsResult.items.filter((item) => item.title.toLowerCase().includes(q.toLowerCase()));
        return itemsResult.items;
      }
      /**
       * @param {StateNode} node
       * @param {any} rawItem
       * @returns {import('@json-layout/vocabulary').SelectItem}
       */
      prepareSelectItem(node, rawItem) {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _i;
        const item = {};
        const layout = node.layout;
        if (typeof rawItem === "object") {
          item.value = ((_a2 = layout.getItems) == null ? void 0 : _a2.itemValue) ? this.evalNodeExpression(node, layout.getItems.itemValue, rawItem) : ((_b = layout.getItems) == null ? void 0 : _b.returnObjects) ? rawItem : rawItem.value;
          item.key = ((_c = layout.getItems) == null ? void 0 : _c.itemKey) ? this.evalNodeExpression(node, layout.getItems.itemKey, rawItem) : rawItem.key;
          item.title = ((_d = layout.getItems) == null ? void 0 : _d.itemTitle) ? this.evalNodeExpression(node, layout.getItems.itemTitle, rawItem) : rawItem.title;
          item.value = item.value ?? item.key;
          item.key = item.key ?? item.value + "";
          item.title = item.title ?? item.key;
          if (!item.icon && rawItem.icon)
            item.icon = rawItem.icon;
        } else {
          item.value = ((_e = layout.getItems) == null ? void 0 : _e.itemValue) ? this.evalNodeExpression(node, layout.getItems.itemValue, rawItem) : rawItem;
          item.key = ((_f = layout.getItems) == null ? void 0 : _f.itemKey) ? this.evalNodeExpression(node, layout.getItems.itemKey, rawItem) : item.value;
          item.title = ((_g = layout.getItems) == null ? void 0 : _g.itemTitle) ? this.evalNodeExpression(node, layout.getItems.itemTitle, rawItem) : item.value;
        }
        if ((_h = layout.getItems) == null ? void 0 : _h.itemIcon)
          item.icon = this.evalNodeExpression(node, (_i = layout.getItems) == null ? void 0 : _i.itemIcon, rawItem);
        return (
          /** @type {import('@json-layout/vocabulary').SelectItem} */
          item
        );
      }
      /**
       * @param {StateNode} node
       * @param {number} key
       */
      activateItem(node, key) {
        var _a2, _b;
        this.activatedItems = produce(this.activatedItems, (draft) => {
          draft[node.fullKey] = key;
        });
        this._autofocusTarget = node.fullKey + "/" + key;
        if (node.key === "$oneOf") {
          if (node.layout.emptyData && node.data && typeof node.data === "object" && ((_a2 = node.children) == null ? void 0 : _a2[0])) {
            const parentNode = this._lastCreateStateTreeContext.nodes.find((p2) => p2.fullKey === node.parentFullKey);
            if (!parentNode)
              throw new Error(`parent with key "${node.parentFullKey}" not found`);
            if (!parentNode.data || typeof parentNode.data !== "object")
              throw new Error(`parent with key "${node.parentFullKey}" is missing data object`);
            const newParentData = { ...parentNode.data };
            for (const propertyKey of (_b = node.children) == null ? void 0 : _b[0].skeleton.propertyKeys) {
              delete newParentData[propertyKey];
            }
            this.input(parentNode, newParentData);
          } else {
            this.input(node, void 0);
          }
        } else {
          this.updateState();
        }
        this.handleAutofocus();
      }
      /**
       * @param {StateNode} node
       */
      deactivateItem(node) {
        this.activatedItems = produce(this.activatedItems, (draft) => {
          for (const key in draft) {
            if (key.startsWith(node.fullKey))
              delete draft[key];
          }
        });
        this.updateState();
      }
      handleAutofocus() {
        const autofocusTarget = this._autofocusTarget;
        if (autofocusTarget !== null && this._autofocusTarget !== this._previousAutofocusTarget) {
          this._previousAutofocusTarget = autofocusTarget;
          setTimeout(() => {
            logDataBinding("emit autofocus event", autofocusTarget);
            this.options.onAutofocus(autofocusTarget);
          });
        }
      }
    }
    const _sfc_main$E = {
      props: {
        layoutSlot: {
          /** @type import('vue').PropType<import('@json-layout/vocabulary').Slot> */
          type: Object,
          required: true
        },
        node: {
          /** @type import('vue').PropType<import('../../types.js').VjsfNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        },
        tag: {
          /** @type import('vue').PropType<string> */
          type: String,
          default: null
        }
      },
      render() {
        const renderTag = this.tag ?? (isTextSlot(this.layoutSlot) ? "p" : "div");
        if (isTextSlot(this.layoutSlot)) {
          return h(renderTag, this.layoutSlot.text);
        }
        if (isMarkdownSlot(this.layoutSlot)) {
          return h(renderTag, { innerHTML: this.layoutSlot.markdown });
        }
        if (isNameSlot(this.layoutSlot)) {
          if (!this.statefulLayout.options.vjsfSlots[this.layoutSlot.name]) {
            console.error(`vjsf: layout references a code slot "${this.layoutSlot.name}" that was not provided.`);
          } else {
            return h(renderTag, this.statefulLayout.options.vjsfSlots[this.layoutSlot.name]({ node: this.node, statefulLayout: this.statefulLayout }));
          }
        }
        return null;
      }
    };
    const _hoisted_1$6 = ["innerHTML"];
    const _sfc_main$D = {
      __name: "help-message",
      props: {
        node: {
          /** @type import('vue').PropType<import('../../types.js').VjsfNode> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        const show = ref$1(false);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(`vjsf-help-message vjsf-help-message-${__props.node.options.density}`)
          }, [
            createVNode(unref(VSlideXReverseTransition), null, {
              default: withCtx(() => [
                withDirectives(createVNode(unref(VAlert), { color: "info" }, {
                  default: withCtx(() => [
                    createBaseVNode("div", {
                      innerHTML: __props.node.layout.help
                    }, null, 8, _hoisted_1$6)
                  ]),
                  _: 1
                }, 512), [
                  [vShow, show.value]
                ])
              ]),
              _: 1
            }),
            createVNode(unref(VBtn), {
              color: "info",
              class: normalizeClass(`vjsf-help-message-toggle vjsf-help-message-toggle-${__props.node.options.density}`),
              icon: show.value ? "mdi-close" : "mdi-information-symbol",
              border: 0,
              elevation: show.value ? 0 : 2,
              density: "compact",
              size: __props.node.options.density === "default" ? 28 : 24,
              title: show.value ? "" : __props.node.messages.showHelp,
              onClick: _cache[0] || (_cache[0] = ($event) => show.value = !show.value)
            }, null, 8, ["class", "icon", "elevation", "size", "title"])
          ], 2);
        };
      }
    };
    const _sfc_main$C = {
      __name: "node",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../types.js').VjsfNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        useDefaults({}, "VjsfNode");
        const props = __props;
        const beforeAfterClasses = {
          compact: "my-1",
          comfortable: "my-2",
          default: "my-3"
        };
        const theme = useTheme();
        const indent = computed(() => {
          if (props.modelValue.parentFullKey === null)
            return 0;
          if (!props.modelValue.options.indent)
            return 0;
          if (props.modelValue.layout.comp !== "section")
            return 0;
          if (!props.modelValue.layout.title)
            return 0;
          if (typeof props.modelValue.options.indent === "number")
            return props.modelValue.options.indent;
          if (props.modelValue.options.density === "compact")
            return 2;
          if (props.modelValue.options.density === "comfortable")
            return 4;
          return 6;
        });
        const nodeClasses = computed(() => {
          let classes = `vjsf-node vjsf-node-${props.modelValue.layout.comp} vjsf-density-${props.modelValue.options.density}`;
          if (props.modelValue.options.readOnly)
            classes += " vjsf-readonly";
          if (props.modelValue.options.summary)
            classes += " vjsf-summary";
          if (theme.current.value.dark)
            classes += " vjsf-dark";
          if (indent.value)
            classes += " ml-" + indent.value;
          return classes;
        });
        if (props.modelValue.layout.comp !== "none" && !props.statefulLayout.options.nodeComponents[props.modelValue.layout.comp]) {
          console.error(`vjsf: missing component to render vjsf node "${props.modelValue.layout.comp}", maybe you forgot to register a component from a plugin ?`);
        }
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(VDefaultsProvider), {
            defaults: { global: { density: props.modelValue.options.density } }
          }, {
            default: withCtx(() => [
              __props.modelValue.layout.comp !== "none" ? (openBlock(), createBlock(unref(VCol), {
                key: 0,
                cols: __props.modelValue.cols,
                class: normalizeClass(nodeClasses.value)
              }, {
                default: withCtx(() => {
                  var _a2, _b, _c, _d, _e, _f;
                  return [
                    ((_a2 = __props.modelValue.layout.slots) == null ? void 0 : _a2.before) ? (openBlock(), createBlock(_sfc_main$E, {
                      key: "before",
                      "layout-slot": (_b = __props.modelValue.layout.slots) == null ? void 0 : _b.before,
                      node: __props.modelValue,
                      "stateful-layout": __props.statefulLayout,
                      class: normalizeClass(beforeAfterClasses[__props.modelValue.options.density])
                    }, null, 8, ["layout-slot", "node", "stateful-layout", "class"])) : createCommentVNode("", true),
                    __props.modelValue.layout.help && !__props.modelValue.options.summary ? (openBlock(), createBlock(_sfc_main$D, {
                      key: 1,
                      node: __props.modelValue
                    }, null, 8, ["node"])) : createCommentVNode("", true),
                    ((_c = __props.modelValue.layout.slots) == null ? void 0 : _c.component) ? (openBlock(), createBlock(_sfc_main$E, {
                      key: "component",
                      "layout-slot": (_d = __props.modelValue.layout.slots) == null ? void 0 : _d.component,
                      node: __props.modelValue,
                      "stateful-layout": __props.statefulLayout
                    }, null, 8, ["layout-slot", "node", "stateful-layout"])) : (openBlock(), createBlock(resolveDynamicComponent(props.statefulLayout.options.nodeComponents[__props.modelValue.layout.comp]), {
                      key: 3,
                      "model-value": __props.modelValue,
                      "stateful-layout": __props.statefulLayout
                    }, null, 8, ["model-value", "stateful-layout"])),
                    ((_e = __props.modelValue.layout.slots) == null ? void 0 : _e.after) ? (openBlock(), createBlock(_sfc_main$E, {
                      key: "after",
                      "layout-slot": (_f = __props.modelValue.layout.slots) == null ? void 0 : _f.after,
                      node: __props.modelValue,
                      "stateful-layout": __props.statefulLayout,
                      class: normalizeClass(beforeAfterClasses[__props.modelValue.options.density])
                    }, null, 8, ["layout-slot", "node", "stateful-layout", "class"])) : createCommentVNode("", true)
                  ];
                }),
                _: 1
              }, 8, ["cols", "class"])) : createCommentVNode("", true)
            ]),
            _: 1
          }, 8, ["defaults"]);
        };
      }
    };
    const _sfc_main$B = {
      __name: "tree",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('@json-layout/core').StateTree> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(VRow), { class: "vjsf-tree" }, {
            default: withCtx(() => [
              createVNode(_sfc_main$C, {
                "stateful-layout": __props.statefulLayout,
                "model-value": (
                  /** @type import('../types.js').VjsfNode */
                  __props.modelValue.root
                )
              }, null, 8, ["stateful-layout", "model-value"])
            ]),
            _: 1
          });
        };
      }
    };
    function tryOnScopeDispose(fn) {
      if (getCurrentScope$1()) {
        onScopeDispose(fn);
        return true;
      }
      return false;
    }
    function toValue(r2) {
      return typeof r2 === "function" ? r2() : unref(r2);
    }
    const isClient = typeof window !== "undefined" && typeof document !== "undefined";
    typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
    function getLifeCycleTarget(target2) {
      return target2 || getCurrentInstance$1();
    }
    function tryOnMounted(fn, sync = true, target2) {
      const instance = getLifeCycleTarget();
      if (instance)
        onMounted(fn, target2);
      else if (sync)
        fn();
      else
        nextTick(fn);
    }
    function unrefElement(elRef) {
      var _a2;
      const plain = toValue(elRef);
      return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
    }
    const defaultWindow = isClient ? window : void 0;
    function useMounted() {
      const isMounted = ref$1(false);
      if (getCurrentInstance$1()) {
        onMounted(() => {
          isMounted.value = true;
        });
      }
      return isMounted;
    }
    function useSupported(callback) {
      const isMounted = useMounted();
      return computed(() => {
        isMounted.value;
        return Boolean(callback());
      });
    }
    function useResizeObserver(target2, callback, options = {}) {
      const { window: window2 = defaultWindow, ...observerOptions } = options;
      let observer;
      const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
      const cleanup = () => {
        if (observer) {
          observer.disconnect();
          observer = void 0;
        }
      };
      const targets = computed(() => Array.isArray(target2) ? target2.map((el2) => unrefElement(el2)) : [unrefElement(target2)]);
      const stopWatch = watch(
        targets,
        (els2) => {
          cleanup();
          if (isSupported.value && window2) {
            observer = new ResizeObserver(callback);
            for (const _el of els2)
              _el && observer.observe(_el, observerOptions);
          }
        },
        { immediate: true, flush: "post", deep: true }
      );
      const stop = () => {
        cleanup();
        stopWatch();
      };
      tryOnScopeDispose(stop);
      return {
        isSupported,
        stop
      };
    }
    function useElementSize(target2, initialSize = { width: 0, height: 0 }, options = {}) {
      const { window: window2 = defaultWindow, box = "content-box" } = options;
      const isSVG = computed(() => {
        var _a2, _b;
        return (_b = (_a2 = unrefElement(target2)) == null ? void 0 : _a2.namespaceURI) == null ? void 0 : _b.includes("svg");
      });
      const width = ref$1(initialSize.width);
      const height = ref$1(initialSize.height);
      const { stop: stop1 } = useResizeObserver(
        target2,
        ([entry]) => {
          const boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
          if (window2 && isSVG.value) {
            const $elem = unrefElement(target2);
            if ($elem) {
              const styles = window2.getComputedStyle($elem);
              width.value = Number.parseFloat(styles.width);
              height.value = Number.parseFloat(styles.height);
            }
          } else {
            if (boxSize) {
              const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];
              width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);
              height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);
            } else {
              width.value = entry.contentRect.width;
              height.value = entry.contentRect.height;
            }
          }
        },
        options
      );
      tryOnMounted(() => {
        const ele = unrefElement(target2);
        if (ele) {
          width.value = "offsetWidth" in ele ? ele.offsetWidth : initialSize.width;
          height.value = "offsetHeight" in ele ? ele.offsetHeight : initialSize.height;
        }
      });
      const stop2 = watch(
        () => unrefElement(target2),
        (ele) => {
          width.value = ele ? initialSize.width : 0;
          height.value = ele ? initialSize.height : 0;
        }
      );
      function stop() {
        stop1();
        stop2();
      }
      return {
        width,
        height,
        stop
      };
    }
    const defaultOptions = {
      nodeComponents: {},
      plugins: [],
      pluginsOptions: {}
    };
    const getFullOptions = (options, form, width, slots, defaultNodeComponents, onData, onUpdate, onAutofocus) => {
      const components = { ...options == null ? void 0 : options.components };
      const nodeComponents = { ...defaultNodeComponents, ...options == null ? void 0 : options.nodeComponents };
      if (options == null ? void 0 : options.plugins) {
        for (const plugin of options.plugins) {
          components[plugin.info.name] = plugin.info;
          nodeComponents[plugin.info.name] = plugin.nodeComponent;
        }
      }
      const fullOptions = {
        ...defaultOptions,
        readOnly: !!(form && (form.isDisabled.value || form.isReadonly.value)),
        ...options,
        onData,
        onUpdate,
        onAutofocus,
        context: (options == null ? void 0 : options.context) ? JSON.parse(JSON.stringify(options.context)) : {},
        width: Math.round(width ?? 0),
        vjsfSlots: { ...slots },
        components,
        nodeComponents
      };
      return (
        /** @type import('../types.js').VjsfOptions */
        fullOptions
      );
    };
    const debug = Debug("vjsf:use-vjsf");
    setAutoFreeze(false);
    const emits = {
      /**
       * @arg {any} data
      */
      "update:modelValue": (data) => true,
      /**
       * @arg {import('../types.js').VjsfStatefulLayout} state
      */
      "update:state": (state) => true
    };
    const useVjsf = (schema2, modelValue, options, nodeComponents, emit2, compile2, precompiledLayout) => {
      const el2 = ref$1(null);
      const { width } = useElementSize(el2);
      const statefulLayout = shallowRef(null);
      const stateTree = shallowRef(null);
      const form = inject$1(Symbol.for("vuetify:form"));
      if (form) {
        form.register({
          id: "vjsf",
          // TODO: a unique random id ?
          validate: () => {
            var _a2, _b;
            (_a2 = statefulLayout.value) == null ? void 0 : _a2.validate();
            return (_b = statefulLayout.value) == null ? void 0 : _b.errors;
          },
          reset: () => {
            var _a2;
            return (_a2 = statefulLayout.value) == null ? void 0 : _a2.resetValidation();
          },
          // TODO: also empty the data ?
          resetValidation: () => {
            var _a2;
            return (_a2 = statefulLayout.value) == null ? void 0 : _a2.resetValidation();
          }
        });
      }
      const slots = useSlots();
      const onStatefulLayoutUpdate = (statefulLayout2) => {
        debug("onStatefulLayoutUpdate", statefulLayout2);
        if (!statefulLayout2)
          return;
        stateTree.value = statefulLayout2.stateTree;
        debug("  -> emit update:state");
        emit2("update:state", statefulLayout2);
        if (form) {
          if (statefulLayout2.valid)
            form.update("vjsf", true, []);
          else if (statefulLayout2.hasHiddenError)
            form.update("vjsf", null, []);
          else
            form.update("vjsf", false, []);
        }
      };
      const onDataUpdate = (data) => {
        debug("onDataUpdate", data);
        debug("  -> emit update:modelValue");
        emit2("update:modelValue", data);
      };
      const onAutofocus = () => {
        if (!el2.value)
          return;
        const autofocusNodeElement = el2.value.querySelector(".vjsf-input--autofocus");
        debug("onAutofocus", autofocusNodeElement);
        if (autofocusNodeElement) {
          const autofocusInputElement = autofocusNodeElement.querySelector("input") ?? autofocusNodeElement.querySelector('textarea:not([style*="display: none"]');
          if (autofocusInputElement)
            autofocusInputElement.focus();
        }
      };
      const fullOptions = computed(() => getFullOptions(options.value, form, width.value, slots, { ...nodeComponents }, onDataUpdate, onStatefulLayoutUpdate, onAutofocus));
      const compileOptions = ref$1({});
      watch(fullOptions, (newOptions) => {
        if (precompiledLayout == null ? void 0 : precompiledLayout.value)
          return;
        const newCompileOptions = produceCompileOptions(compileOptions.value, newOptions);
        if (newCompileOptions !== compileOptions.value) {
          debug("new compileOptions", newCompileOptions);
          compileOptions.value = newCompileOptions;
        }
      }, { immediate: true });
      const compiledLayout = computed(() => {
        if (precompiledLayout == null ? void 0 : precompiledLayout.value)
          return precompiledLayout == null ? void 0 : precompiledLayout.value;
        if (!compile2)
          throw new Error("compile function is not available");
        const compiledLayout2 = compile2(schema2.value, compileOptions.value);
        return compiledLayout2;
      });
      const initStatefulLayout = () => {
        if (!width.value)
          return;
        statefulLayout.value = /** @type {import('../types.js').VjsfStatefulLayout} */
        new StatefulLayout(
          toRaw(compiledLayout.value),
          toRaw(compiledLayout.value.skeletonTrees[compiledLayout.value.mainTree]),
          toRaw(fullOptions.value),
          toRaw(modelValue.value)
        );
      };
      watch(fullOptions, (newOptions) => {
        debug("watch fullOptions", fullOptions);
        if (statefulLayout.value) {
          debug("  -> update statefulLayout options");
          statefulLayout.value.options = toRaw(newOptions);
        } else {
          debug("  -> init statefulLayout");
          initStatefulLayout();
        }
      });
      watch(modelValue, (newData) => {
        const rawData = toRaw(newData);
        if (statefulLayout.value && statefulLayout.value.data !== rawData) {
          debug("modelValue changed from outside", rawData);
          debug("  -> update statefulLayout data");
          statefulLayout.value.data = toRaw(rawData);
        }
      });
      watch(compiledLayout, (newCompiledLayout) => {
        debug("watch compiledLayout", newCompiledLayout);
        debug("  -> init statefulLayout");
        initStatefulLayout();
      });
      return { el: el2, statefulLayout, stateTree };
    };
    const _hoisted_1$5 = ["innerHTML"];
    const _sfc_main$A = {
      __name: "section-header",
      props: {
        node: {
          /** @type import('vue').PropType<import('../../types.js').VjsfNode> */
          type: Object,
          required: true
        },
        hideTitle: {
          type: Boolean,
          default: false
        }
      },
      setup(__props) {
        const props = __props;
        const titleDepthBase = computed(() => {
          if (props.node.options.density === "compact")
            return 6;
          if (props.node.options.density === "comfortable")
            return 7;
          return 8;
        });
        const classes = ["text-h1", "text-h2", "text-h3", "text-h4", "text-h5", "text-h6", "text-subtitle-1", "text-subtitle-2"];
        const titleClass = computed(() => {
          const index = props.node.options.titleDepth;
          if (props.node.options.density === "compact")
            return classes[index + 2];
          if (props.node.options.density === "comfortable")
            return classes[index + 1];
          return classes[index];
        });
        return (_ctx, _cache) => {
          return __props.node.layout.title && !__props.hideTitle || __props.node.layout.subtitle || __props.node.error && __props.node.validated ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(`mb-${titleDepthBase.value - __props.node.options.titleDepth} mt-${titleDepthBase.value - __props.node.options.titleDepth}`)
          }, [
            __props.node.layout.title && !__props.hideTitle ? (openBlock(), createBlock(resolveDynamicComponent(`h${__props.node.options.titleDepth}`), {
              key: 0,
              class: normalizeClass(`${titleClass.value}`)
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(__props.node.layout.title), 1)
              ]),
              _: 1
            }, 8, ["class"])) : createCommentVNode("", true),
            __props.node.layout.subtitle ? (openBlock(), createElementBlock("p", {
              key: 1,
              class: normalizeClass(`text-subtitle mt-${titleDepthBase.value - __props.node.options.titleDepth}`),
              innerHTML: __props.node.layout.subtitle
            }, null, 10, _hoisted_1$5)) : createCommentVNode("", true),
            __props.node.error && __props.node.validated ? (openBlock(), createBlock(unref(VAlert), {
              key: 2,
              type: "error",
              class: normalizeClass(`mt-${titleDepthBase.value - __props.node.options.titleDepth}`)
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(__props.node.error), 1)
              ]),
              _: 1
            }, 8, ["class"])) : createCommentVNode("", true)
          ], 2)) : createCommentVNode("", true);
        };
      }
    };
    const _sfc_main$z = {
      __name: "section",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfSectionNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        useDefaults({}, "VjsfSection");
        return (_ctx, _cache) => {
          var _a2, _b;
          return openBlock(), createElementBlock(Fragment, null, [
            createVNode(_sfc_main$A, { node: __props.modelValue }, null, 8, ["node"]),
            createVNode(unref(VRow), {
              dense: ((_a2 = __props.modelValue.options) == null ? void 0 : _a2.density) === "compact" || ((_b = __props.modelValue.options) == null ? void 0 : _b.density) === "comfortable"
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(__props.modelValue.children, (child) => {
                  return openBlock(), createBlock(_sfc_main$C, {
                    key: child.fullKey,
                    "model-value": (
                      /** @type import('../../types.js').VjsfNode */
                      child
                    ),
                    "stateful-layout": __props.statefulLayout
                  }, null, 8, ["model-value", "stateful-layout"]);
                }), 128))
              ]),
              _: 1
            }, 8, ["dense"])
          ], 64);
        };
      }
    };
    function moveDataItem(data, fromIndex, toIndex) {
      if (fromIndex === toIndex || fromIndex === -1 || toIndex === -1)
        return data;
      if (!Array.isArray(data) && typeof data === "object")
        return moveObjectItem(data, fromIndex, toIndex);
      return moveArrayItem(data, fromIndex, toIndex);
    }
    function moveArrayItem(data, fromIndex, toIndex) {
      if (fromIndex === toIndex || fromIndex === -1 || toIndex === -1)
        return data;
      if (!Array.isArray(data) && typeof data === "object")
        return moveObjectItem(data, fromIndex, toIndex);
      const newArray = [...data];
      const element = newArray[fromIndex];
      newArray.splice(fromIndex, 1);
      newArray.splice(toIndex, 0, element);
      return newArray;
    }
    function moveObjectItem(data, fromIndex, toIndex) {
      if (fromIndex === toIndex || fromIndex === -1 || toIndex === -1)
        return data;
      const newKeys = (
        /** @type {string[] } */
        moveArrayItem(Object.keys(data), fromIndex, toIndex)
      );
      const newData = {};
      for (const key of newKeys) {
        newData[key] = data[key];
      }
      console.log(newData);
      return newData;
    }
    const padTimeComponent = (val) => {
      const s = "" + val;
      return s.length === 1 ? "0" + s : s;
    };
    const getDateTimeWithOffset = (date2) => {
      const offsetMinutes = date2.getTimezoneOffset();
      const offsetAbs = `${padTimeComponent(Math.abs(offsetMinutes / 60))}:${padTimeComponent(Math.abs(offsetMinutes % 60))}`;
      let offset;
      if (offsetMinutes < 0)
        offset = `+${offsetAbs}`;
      else if (offsetMinutes > 0)
        offset = `-${offsetAbs}`;
      else
        offset = "Z";
      return `${date2.getFullYear()}-${padTimeComponent(date2.getMonth() + 1)}-${padTimeComponent(date2.getDate())}T${padTimeComponent(date2.getHours())}:${padTimeComponent(date2.getMinutes())}:${padTimeComponent(date2.getSeconds())}${offset}`;
    };
    const getDateTimeParts = (date2) => {
      return [`${date2.getFullYear()}-${padTimeComponent(date2.getMonth() + 1)}-${padTimeComponent(date2.getDate())}`, `${padTimeComponent(date2.getHours())}:${padTimeComponent(date2.getMinutes())}`];
    };
    const getShortTime = (time) => {
      if (!time)
        return "";
      return time.slice(0, 5);
    };
    const getLongTime = (time) => {
      return time + ":00Z";
    };
    const defaultProps = {
      fieldPropsCompact: {
        hideDetails: "auto"
      },
      fieldPropsReadOnly: { hideDetails: "auto", variant: "plain" },
      fieldPropsSummary: { hideDetails: true }
    };
    function mergePropsLevels(propsLevels) {
      const fullProps = { class: [] };
      for (const propsLevel of propsLevels) {
        if (propsLevel) {
          for (const key of Object.keys(propsLevel)) {
            if (key === "class") {
              if (Array.isArray(propsLevel.class))
                fullProps.class = fullProps.class.concat(propsLevel.class);
              else
                fullProps.class = [propsLevel.class];
            } else {
              fullProps[camelize(key)] = propsLevel[key];
            }
          }
        }
      }
      return fullProps;
    }
    function getInputProps(node, statefulLayout, layoutPropsMap, isMainComp = true) {
      const options = node.options;
      const propsLevels = [];
      if (options.density === "compact")
        propsLevels.push(defaultProps.fieldPropsCompact);
      if (node.options.readOnly)
        propsLevels.push(defaultProps.fieldPropsReadOnly);
      if (isMainComp && node.props)
        propsLevels.push(node.props);
      const fullProps = mergePropsLevels(propsLevels);
      fullProps.label = node.layout.label;
      if (node.error && node.validated) {
        fullProps.errorMessages = node.error;
      }
      fullProps.modelValue = typeof node.data === "string" && node.layout.separator ? node.data.split(
        /** @type {string} */
        node.layout.separator
      ) : node.data;
      if (node.options.readOnly) {
        fullProps.disabled = true;
        fullProps.class.push("vjsf-input--readonly");
      }
      if (node.autofocus) {
        fullProps.class.push("vjsf-input--autofocus");
      }
      if (layoutPropsMap) {
        for (const propMap2 of layoutPropsMap) {
          if (typeof propMap2 === "string")
            fullProps[propMap2] = node.layout[propMap2];
          else
            fullProps[propMap2[0]] = node.layout[propMap2[1]];
        }
      }
      if (isMainComp) {
        fullProps["onUpdate:modelValue"] = (value) => {
          return statefulLayout.input(node, Array.isArray(value) && node.layout.separator ? value.join(
            /** @type {string} */
            node.layout.separator
          ) : value);
        };
        fullProps.onBlur = () => statefulLayout.blur(node);
      }
      return fullProps;
    }
    function getCompProps(node, isMainComp = true) {
      const options = (
        /** @type import('../types.js').VjsfOptions */
        node.options
      );
      const propsLevels = [{ density: options.density }];
      if (isMainComp)
        propsLevels.push(node.layout.props);
      const fullProps = mergePropsLevels(propsLevels);
      return fullProps;
    }
    function getSelectProps(node, statefulLayout) {
      const fullProps = getInputProps(node, statefulLayout, ["multiple"], false);
      if (node.options.readOnly)
        fullProps.menuProps = { modelValue: false };
      fullProps.clearable = fullProps.clearable ?? !node.skeleton.required;
      fullProps.valueComparator = (a, b) => {
        const aKey = typeof a === "object" ? statefulLayout.prepareSelectItem(node, a).key : a;
        const bKey = typeof b === "object" ? statefulLayout.prepareSelectItem(node, b).key : b;
        return aKey === bKey;
      };
      fullProps["onUpdate:modelValue"] = (value) => {
        if (Array.isArray(value) && Array.isArray(node.data)) {
          for (let i2 = 0; i2 < node.data.length; i2++) {
            if (typeof node.data[i2] === "object" && typeof value[i2] === "string") {
              value[i2] = node.data[i2];
            }
          }
        }
        return statefulLayout.input(node, Array.isArray(value) && node.layout.separator ? value.join(
          /** @type {string} */
          node.layout.separator
        ) : value);
      };
      fullProps.onBlur = () => statefulLayout.blur(node);
      return fullProps;
    }
    const _sfc_main$y = /* @__PURE__ */ defineComponent$1({
      props: {
        icon: {
          type: String,
          required: true
        }
      },
      setup(props) {
        const isUrl = computed(() => props.icon.startsWith("http://") || props.icon.startsWith("https://"));
        const isSVG = computed(() => props.icon.startsWith("<?xml") || props.icon.startsWith("<svg"));
        return () => {
          if (isUrl.value) {
            return h("img", { src: props.icon, style: "height:100%;width:100%;" });
          } else if (isSVG.value) {
            return h("div", { innerHTML: props.icon.replace("<svg ", '<svg class="v-icon__svg" '), class: "v-icon" });
          } else {
            return h(VIcon, null, () => props.icon);
          }
        };
      }
    });
    const _sfc_main$x = {
      __name: "select-item",
      props: {
        multiple: {
          type: Boolean,
          default: false
        },
        itemProps: {
          type: Object,
          required: true
        },
        item: {
          /** @type import('vue').PropType<import('@json-layout/vocabulary').SelectItem> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(VListItem), normalizeProps(guardReactiveProps(__props.itemProps)), createSlots({ _: 2 }, [
            __props.item.icon || __props.multiple ? {
              name: "prepend",
              fn: withCtx(({ isSelected }) => [
                __props.multiple ? (openBlock(), createBlock(unref(VCheckboxBtn), {
                  key: __props.item.key,
                  ripple: false,
                  tabindex: "-1",
                  "model-value": isSelected
                }, null, 8, ["model-value"])) : createCommentVNode("", true),
                __props.item.icon ? (openBlock(), createBlock(_sfc_main$y, {
                  key: 1,
                  icon: __props.item.icon
                }, null, 8, ["icon"])) : createCommentVNode("", true)
              ]),
              key: "0"
            } : void 0
          ]), 1040);
        };
      }
    };
    const _hoisted_1$4 = { class: "v-select__selection-text" };
    const _hoisted_2$1 = {
      key: 1,
      class: "v-select__selection-comma"
    };
    const _sfc_main$w = {
      __name: "select-selection",
      props: {
        multiple: {
          type: Boolean,
          default: false
        },
        last: {
          type: Boolean,
          default: false
        },
        item: {
          /** @type import('vue').PropType<import('@json-layout/vocabulary').SelectItem> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("span", _hoisted_1$4, [
            __props.item.icon ? (openBlock(), createBlock(_sfc_main$y, {
              key: 0,
              icon: __props.item.icon
            }, null, 8, ["icon"])) : createCommentVNode("", true),
            createTextVNode(" " + toDisplayString(__props.item.title ?? __props.item.key ?? __props.item.value) + " ", 1),
            __props.multiple && !__props.last ? (openBlock(), createElementBlock("span", _hoisted_2$1, ",")) : createCommentVNode("", true)
          ]);
        };
      }
    };
    function getCompSlots(node, statefulLayout) {
      if (!node.layout.slots)
        return {};
      const slots = {};
      for (const [key, layoutSlot] of Object.entries(node.layout.slots)) {
        slots[key] = () => h(_sfc_main$E, { layoutSlot, node, statefulLayout });
      }
      return slots;
    }
    function getSelectSlots(node, statefulLayout, getItems) {
      const slots = getCompSlots(node, statefulLayout);
      if (!slots.item) {
        slots.item = (context) => h(_sfc_main$x, {
          multiple: node.layout.multiple,
          itemProps: context.props,
          item: context.item.raw
        });
      }
      if (!slots.selection) {
        slots.selection = (context) => h(_sfc_main$w, {
          multiple: node.layout.multiple,
          last: node.layout.multiple && context.index === node.data.length - 1,
          item: getItems.prepareSelectedItem(context.item.raw, context.item.value)
        });
      }
      return slots;
    }
    const _sfc_main$v = /* @__PURE__ */ defineComponent$1({
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfTextFieldNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(props) {
        useDefaults({}, "VjsfTextField");
        const fieldProps = computed(() => getInputProps(props.modelValue, props.statefulLayout, ["placeholder"]));
        const fieldSlots = computed(() => getCompSlots(props.modelValue, props.statefulLayout));
        return () => h(VTextField, fieldProps.value, fieldSlots.value);
      }
    });
    const makeVTextareaProps = propsFactory({
      autoGrow: Boolean,
      autofocus: Boolean,
      counter: [Boolean, Number, String],
      counterValue: Function,
      prefix: String,
      placeholder: String,
      persistentPlaceholder: Boolean,
      persistentCounter: Boolean,
      noResize: Boolean,
      rows: {
        type: [Number, String],
        default: 5,
        validator: (v) => !isNaN(parseFloat(v))
      },
      maxRows: {
        type: [Number, String],
        validator: (v) => !isNaN(parseFloat(v))
      },
      suffix: String,
      modelModifiers: Object,
      ...makeVInputProps(),
      ...makeVFieldProps()
    }, "VTextarea");
    const VTextarea = genericComponent()({
      name: "VTextarea",
      directives: {
        Intersect: Intersect$1
      },
      inheritAttrs: false,
      props: makeVTextareaProps(),
      emits: {
        "click:control": (e) => true,
        "mousedown:control": (e) => true,
        "update:focused": (focused) => true,
        "update:modelValue": (val) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          emit: emit2,
          slots
        } = _ref;
        const model = useProxiedModel(props, "modelValue");
        const {
          isFocused,
          focus,
          blur
        } = useFocus(props);
        const counterValue = computed(() => {
          return typeof props.counterValue === "function" ? props.counterValue(model.value) : (model.value || "").toString().length;
        });
        const max = computed(() => {
          if (attrs.maxlength)
            return attrs.maxlength;
          if (!props.counter || typeof props.counter !== "number" && typeof props.counter !== "string")
            return void 0;
          return props.counter;
        });
        function onIntersect(isIntersecting, entries) {
          var _a2, _b;
          if (!props.autofocus || !isIntersecting)
            return;
          (_b = (_a2 = entries[0].target) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
        }
        const vInputRef = ref$1();
        const vFieldRef = ref$1();
        const controlHeight = shallowRef("");
        const textareaRef = ref$1();
        const isActive = computed(() => props.persistentPlaceholder || isFocused.value || props.active);
        function onFocus() {
          var _a2;
          if (textareaRef.value !== document.activeElement) {
            (_a2 = textareaRef.value) == null ? void 0 : _a2.focus();
          }
          if (!isFocused.value)
            focus();
        }
        function onControlClick(e) {
          onFocus();
          emit2("click:control", e);
        }
        function onControlMousedown(e) {
          emit2("mousedown:control", e);
        }
        function onClear(e) {
          e.stopPropagation();
          onFocus();
          nextTick(() => {
            model.value = "";
            callEvent(props["onClick:clear"], e);
          });
        }
        function onInput(e) {
          var _a2;
          const el2 = e.target;
          model.value = el2.value;
          if ((_a2 = props.modelModifiers) == null ? void 0 : _a2.trim) {
            const caretPosition = [el2.selectionStart, el2.selectionEnd];
            nextTick(() => {
              el2.selectionStart = caretPosition[0];
              el2.selectionEnd = caretPosition[1];
            });
          }
        }
        const sizerRef = ref$1();
        const rows = ref$1(+props.rows);
        const isPlainOrUnderlined = computed(() => ["plain", "underlined"].includes(props.variant));
        watchEffect(() => {
          if (!props.autoGrow)
            rows.value = +props.rows;
        });
        function calculateInputHeight() {
          if (!props.autoGrow)
            return;
          nextTick(() => {
            if (!sizerRef.value || !vFieldRef.value)
              return;
            const style = getComputedStyle(sizerRef.value);
            const fieldStyle = getComputedStyle(vFieldRef.value.$el);
            const padding = parseFloat(style.getPropertyValue("--v-field-padding-top")) + parseFloat(style.getPropertyValue("--v-input-padding-top")) + parseFloat(style.getPropertyValue("--v-field-padding-bottom"));
            const height = sizerRef.value.scrollHeight;
            const lineHeight = parseFloat(style.lineHeight);
            const minHeight = Math.max(parseFloat(props.rows) * lineHeight + padding, parseFloat(fieldStyle.getPropertyValue("--v-input-control-height")));
            const maxHeight = parseFloat(props.maxRows) * lineHeight + padding || Infinity;
            const newHeight = clamp(height ?? 0, minHeight, maxHeight);
            rows.value = Math.floor((newHeight - padding) / lineHeight);
            controlHeight.value = convertToUnit(newHeight);
          });
        }
        onMounted(calculateInputHeight);
        watch(model, calculateInputHeight);
        watch(() => props.rows, calculateInputHeight);
        watch(() => props.maxRows, calculateInputHeight);
        watch(() => props.density, calculateInputHeight);
        let observer;
        watch(sizerRef, (val) => {
          if (val) {
            observer = new ResizeObserver(calculateInputHeight);
            observer.observe(sizerRef.value);
          } else {
            observer == null ? void 0 : observer.disconnect();
          }
        });
        onBeforeUnmount(() => {
          observer == null ? void 0 : observer.disconnect();
        });
        useRender(() => {
          const hasCounter = !!(slots.counter || props.counter || props.counterValue);
          const hasDetails = !!(hasCounter || slots.details);
          const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
          const {
            modelValue: _,
            ...inputProps
          } = VInput.filterProps(props);
          const fieldProps = filterFieldProps(props);
          return createVNode(VInput, mergeProps({
            "ref": vInputRef,
            "modelValue": model.value,
            "onUpdate:modelValue": ($event) => model.value = $event,
            "class": ["v-textarea v-text-field", {
              "v-textarea--prefixed": props.prefix,
              "v-textarea--suffixed": props.suffix,
              "v-text-field--prefixed": props.prefix,
              "v-text-field--suffixed": props.suffix,
              "v-textarea--auto-grow": props.autoGrow,
              "v-textarea--no-resize": props.noResize || props.autoGrow,
              "v-input--plain-underlined": isPlainOrUnderlined.value
            }, props.class],
            "style": props.style
          }, rootAttrs, inputProps, {
            "centerAffix": rows.value === 1 && !isPlainOrUnderlined.value,
            "focused": isFocused.value
          }), {
            ...slots,
            default: (_ref2) => {
              let {
                id: id2,
                isDisabled,
                isDirty,
                isReadonly: isReadonly2,
                isValid: isValid2
              } = _ref2;
              return createVNode(VField, mergeProps({
                "ref": vFieldRef,
                "style": {
                  "--v-textarea-control-height": controlHeight.value
                },
                "onClick": onControlClick,
                "onMousedown": onControlMousedown,
                "onClick:clear": onClear,
                "onClick:prependInner": props["onClick:prependInner"],
                "onClick:appendInner": props["onClick:appendInner"]
              }, fieldProps, {
                "id": id2.value,
                "active": isActive.value || isDirty.value,
                "centerAffix": rows.value === 1 && !isPlainOrUnderlined.value,
                "dirty": isDirty.value || props.dirty,
                "disabled": isDisabled.value,
                "focused": isFocused.value,
                "error": isValid2.value === false
              }), {
                ...slots,
                default: (_ref3) => {
                  let {
                    props: {
                      class: fieldClass,
                      ...slotProps
                    }
                  } = _ref3;
                  return createVNode(Fragment, null, [props.prefix && createVNode("span", {
                    "class": "v-text-field__prefix"
                  }, [props.prefix]), withDirectives(createVNode("textarea", mergeProps({
                    "ref": textareaRef,
                    "class": fieldClass,
                    "value": model.value,
                    "onInput": onInput,
                    "autofocus": props.autofocus,
                    "readonly": isReadonly2.value,
                    "disabled": isDisabled.value,
                    "placeholder": props.placeholder,
                    "rows": props.rows,
                    "name": props.name,
                    "onFocus": onFocus,
                    "onBlur": blur
                  }, slotProps, inputAttrs), null), [[resolveDirective("intersect"), {
                    handler: onIntersect
                  }, null, {
                    once: true
                  }]]), props.autoGrow && withDirectives(createVNode("textarea", {
                    "class": [fieldClass, "v-textarea__sizer"],
                    "id": `${slotProps.id}-sizer`,
                    "onUpdate:modelValue": ($event) => model.value = $event,
                    "ref": sizerRef,
                    "readonly": true,
                    "aria-hidden": "true"
                  }, null), [[vModelText, model.value]]), props.suffix && createVNode("span", {
                    "class": "v-text-field__suffix"
                  }, [props.suffix])]);
                }
              });
            },
            details: hasDetails ? (slotProps) => {
              var _a2;
              return createVNode(Fragment, null, [(_a2 = slots.details) == null ? void 0 : _a2.call(slots, slotProps), hasCounter && createVNode(Fragment, null, [createVNode("span", null, null), createVNode(VCounter, {
                "active": props.persistentCounter || isFocused.value,
                "value": counterValue.value,
                "max": max.value,
                "disabled": props.disabled
              }, slots.counter)])]);
            } : void 0
          });
        });
        return forwardRefs({}, vInputRef, vFieldRef, textareaRef);
      }
    });
    const _sfc_main$u = /* @__PURE__ */ defineComponent$1({
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfTextareaNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(props) {
        useDefaults({}, "VjsfTextArea");
        const textarea = ref$1(null);
        const fieldProps = computed(() => {
          const inputProps = getInputProps(props.modelValue, props.statefulLayout, ["placeholder"]);
          inputProps.ref = textarea;
          if (props.modelValue.options.readOnly && props.modelValue.options.summary)
            inputProps.rows = 3;
          return inputProps;
        });
        const fieldSlots = computed(() => getCompSlots(props.modelValue, props.statefulLayout));
        watch(() => props.modelValue.options.readOnly, (readOnly) => {
          if (readOnly && textarea.value) {
            textarea.value.scrollTop = 0;
          }
        });
        return () => h(VTextarea, fieldProps.value, fieldSlots.value);
      }
    });
    const _sfc_main$t = {
      __name: "checkbox",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfCheckboxNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        useDefaults({}, "VjsfCheckbox");
        const props = __props;
        const fieldProps = computed(() => {
          const inputProps = getInputProps(props.modelValue, props.statefulLayout);
          if (!("hideDetails" in inputProps))
            inputProps.hideDetails = "auto";
          return inputProps;
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(VCheckbox), mergeProps(fieldProps.value, {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = (value) => __props.statefulLayout.input(__props.modelValue, value))
          }), null, 16);
        };
      }
    };
    const makeVSwitchProps = propsFactory({
      indeterminate: Boolean,
      inset: Boolean,
      flat: Boolean,
      loading: {
        type: [Boolean, String],
        default: false
      },
      ...makeVInputProps(),
      ...makeVSelectionControlProps()
    }, "VSwitch");
    const VSwitch = genericComponent()({
      name: "VSwitch",
      inheritAttrs: false,
      props: makeVSwitchProps(),
      emits: {
        "update:focused": (focused) => true,
        "update:modelValue": (value) => true,
        "update:indeterminate": (value) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          slots
        } = _ref;
        const indeterminate = useProxiedModel(props, "indeterminate");
        const model = useProxiedModel(props, "modelValue");
        const {
          loaderClasses
        } = useLoader(props);
        const {
          isFocused,
          focus,
          blur
        } = useFocus(props);
        const control = ref$1();
        const isForcedColorsModeActive = IN_BROWSER && window.matchMedia("(forced-colors: active)").matches;
        const loaderColor = computed(() => {
          return typeof props.loading === "string" && props.loading !== "" ? props.loading : props.color;
        });
        const uid2 = getUid();
        const id2 = computed(() => props.id || `switch-${uid2}`);
        function onChange() {
          if (indeterminate.value) {
            indeterminate.value = false;
          }
        }
        function onTrackClick(e) {
          var _a2, _b;
          e.stopPropagation();
          e.preventDefault();
          (_b = (_a2 = control.value) == null ? void 0 : _a2.input) == null ? void 0 : _b.click();
        }
        useRender(() => {
          const [rootAttrs, controlAttrs] = filterInputAttrs(attrs);
          const inputProps = VInput.filterProps(props);
          const controlProps = VSelectionControl.filterProps(props);
          return createVNode(VInput, mergeProps({
            "class": ["v-switch", {
              "v-switch--flat": props.flat
            }, {
              "v-switch--inset": props.inset
            }, {
              "v-switch--indeterminate": indeterminate.value
            }, loaderClasses.value, props.class]
          }, rootAttrs, inputProps, {
            "modelValue": model.value,
            "onUpdate:modelValue": ($event) => model.value = $event,
            "id": id2.value,
            "focused": isFocused.value,
            "style": props.style
          }), {
            ...slots,
            default: (_ref2) => {
              let {
                id: id3,
                messagesId,
                isDisabled,
                isReadonly: isReadonly2,
                isValid: isValid2
              } = _ref2;
              const slotProps = {
                model,
                isValid: isValid2
              };
              return createVNode(VSelectionControl, mergeProps({
                "ref": control
              }, controlProps, {
                "modelValue": model.value,
                "onUpdate:modelValue": [($event) => model.value = $event, onChange],
                "id": id3.value,
                "aria-describedby": messagesId.value,
                "type": "checkbox",
                "aria-checked": indeterminate.value ? "mixed" : void 0,
                "disabled": isDisabled.value,
                "readonly": isReadonly2.value,
                "onFocus": focus,
                "onBlur": blur
              }, controlAttrs), {
                ...slots,
                default: (_ref3) => {
                  let {
                    backgroundColorClasses,
                    backgroundColorStyles
                  } = _ref3;
                  return createVNode("div", {
                    "class": ["v-switch__track", !isForcedColorsModeActive ? backgroundColorClasses.value : void 0],
                    "style": backgroundColorStyles.value,
                    "onClick": onTrackClick
                  }, [slots["track-true"] && createVNode("div", {
                    "key": "prepend",
                    "class": "v-switch__track-true"
                  }, [slots["track-true"](slotProps)]), slots["track-false"] && createVNode("div", {
                    "key": "append",
                    "class": "v-switch__track-false"
                  }, [slots["track-false"](slotProps)])]);
                },
                input: (_ref4) => {
                  let {
                    inputNode,
                    icon,
                    backgroundColorClasses,
                    backgroundColorStyles
                  } = _ref4;
                  return createVNode(Fragment, null, [inputNode, createVNode("div", {
                    "class": ["v-switch__thumb", {
                      "v-switch__thumb--filled": icon || props.loading
                    }, props.inset || isForcedColorsModeActive ? void 0 : backgroundColorClasses.value],
                    "style": props.inset ? void 0 : backgroundColorStyles.value
                  }, [slots.thumb ? createVNode(VDefaultsProvider, {
                    "defaults": {
                      VIcon: {
                        icon,
                        size: "x-small"
                      }
                    }
                  }, {
                    default: () => [slots.thumb({
                      ...slotProps,
                      icon
                    })]
                  }) : createVNode(VScaleTransition, null, {
                    default: () => [!props.loading ? icon && createVNode(VIcon, {
                      "key": String(icon),
                      "icon": icon,
                      "size": "x-small"
                    }, null) : createVNode(LoaderSlot, {
                      "name": "v-switch",
                      "active": true,
                      "color": isValid2.value === false ? void 0 : loaderColor.value
                    }, {
                      default: (slotProps2) => slots.loader ? slots.loader(slotProps2) : createVNode(VProgressCircular, {
                        "active": slotProps2.isActive,
                        "color": slotProps2.color,
                        "indeterminate": true,
                        "size": "16",
                        "width": "2"
                      }, null)
                    })]
                  })])]);
                }
              });
            }
          });
        });
        return {};
      }
    });
    const _sfc_main$s = {
      __name: "switch",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfSwitchNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        useDefaults({}, "VjsfSwitch");
        const props = __props;
        const fieldProps = computed(() => {
          const inputProps = getInputProps(props.modelValue, props.statefulLayout);
          if (!("hideDetails" in inputProps))
            inputProps.hideDetails = "auto";
          return inputProps;
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(VSwitch), mergeProps(fieldProps.value, {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = (value) => __props.statefulLayout.input(__props.modelValue, value))
          }), null, 16);
        };
      }
    };
    const _sfc_main$r = /* @__PURE__ */ defineComponent$1({
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfNumberFieldNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(props) {
        useDefaults({}, "VjsfNumberField");
        const fieldProps = computed(() => {
          const fieldProps2 = getInputProps(props.modelValue, props.statefulLayout, ["step", "min", "max", "placeholder"]);
          fieldProps2.type = "number";
          fieldProps2["onUpdate:modelValue"] = (value) => props.statefulLayout.input(props.modelValue, value && Number(value));
          return fieldProps2;
        });
        const fieldSlots = computed(() => getCompSlots(props.modelValue, props.statefulLayout));
        return () => h(VTextField, fieldProps.value, fieldSlots.value);
      }
    });
    const VSliderSymbol = Symbol.for("vuetify:v-slider");
    function getOffset(e, el2, direction) {
      const vertical = direction === "vertical";
      const rect2 = el2.getBoundingClientRect();
      const touch = "touches" in e ? e.touches[0] : e;
      return vertical ? touch.clientY - (rect2.top + rect2.height / 2) : touch.clientX - (rect2.left + rect2.width / 2);
    }
    function getPosition(e, position) {
      if ("touches" in e && e.touches.length)
        return e.touches[0][position];
      else if ("changedTouches" in e && e.changedTouches.length)
        return e.changedTouches[0][position];
      else
        return e[position];
    }
    const makeSliderProps = propsFactory({
      disabled: {
        type: Boolean,
        default: null
      },
      error: Boolean,
      readonly: {
        type: Boolean,
        default: null
      },
      max: {
        type: [Number, String],
        default: 100
      },
      min: {
        type: [Number, String],
        default: 0
      },
      step: {
        type: [Number, String],
        default: 0
      },
      thumbColor: String,
      thumbLabel: {
        type: [Boolean, String],
        default: void 0,
        validator: (v) => typeof v === "boolean" || v === "always"
      },
      thumbSize: {
        type: [Number, String],
        default: 20
      },
      showTicks: {
        type: [Boolean, String],
        default: false,
        validator: (v) => typeof v === "boolean" || v === "always"
      },
      ticks: {
        type: [Array, Object]
      },
      tickSize: {
        type: [Number, String],
        default: 2
      },
      color: String,
      trackColor: String,
      trackFillColor: String,
      trackSize: {
        type: [Number, String],
        default: 4
      },
      direction: {
        type: String,
        default: "horizontal",
        validator: (v) => ["vertical", "horizontal"].includes(v)
      },
      reverse: Boolean,
      ...makeRoundedProps(),
      ...makeElevationProps({
        elevation: 2
      }),
      ripple: {
        type: Boolean,
        default: true
      }
    }, "Slider");
    const useSteps = (props) => {
      const min = computed(() => parseFloat(props.min));
      const max = computed(() => parseFloat(props.max));
      const step = computed(() => +props.step > 0 ? parseFloat(props.step) : 0);
      const decimals = computed(() => Math.max(getDecimals(step.value), getDecimals(min.value)));
      function roundValue(value) {
        value = parseFloat(value);
        if (step.value <= 0)
          return value;
        const clamped = clamp(value, min.value, max.value);
        const offset = min.value % step.value;
        const newValue = Math.round((clamped - offset) / step.value) * step.value + offset;
        return parseFloat(Math.min(newValue, max.value).toFixed(decimals.value));
      }
      return {
        min,
        max,
        step,
        decimals,
        roundValue
      };
    };
    const useSlider = (_ref) => {
      let {
        props,
        steps,
        onSliderStart,
        onSliderMove,
        onSliderEnd,
        getActiveThumb
      } = _ref;
      const {
        isRtl
      } = useRtl();
      const isReversed = toRef(props, "reverse");
      const vertical = computed(() => props.direction === "vertical");
      const indexFromEnd = computed(() => vertical.value !== isReversed.value);
      const {
        min,
        max,
        step,
        decimals,
        roundValue
      } = steps;
      const thumbSize = computed(() => parseInt(props.thumbSize, 10));
      const tickSize = computed(() => parseInt(props.tickSize, 10));
      const trackSize = computed(() => parseInt(props.trackSize, 10));
      const numTicks = computed(() => (max.value - min.value) / step.value);
      const disabled = toRef(props, "disabled");
      const thumbColor = computed(() => props.error || props.disabled ? void 0 : props.thumbColor ?? props.color);
      const trackColor = computed(() => props.error || props.disabled ? void 0 : props.trackColor ?? props.color);
      const trackFillColor = computed(() => props.error || props.disabled ? void 0 : props.trackFillColor ?? props.color);
      const mousePressed = shallowRef(false);
      const startOffset = shallowRef(0);
      const trackContainerRef = ref$1();
      const activeThumbRef = ref$1();
      function parseMouseMove(e) {
        var _a2;
        const vertical2 = props.direction === "vertical";
        const start = vertical2 ? "top" : "left";
        const length = vertical2 ? "height" : "width";
        const position2 = vertical2 ? "clientY" : "clientX";
        const {
          [start]: trackStart,
          [length]: trackLength
        } = (_a2 = trackContainerRef.value) == null ? void 0 : _a2.$el.getBoundingClientRect();
        const clickOffset = getPosition(e, position2);
        let clickPos = Math.min(Math.max((clickOffset - trackStart - startOffset.value) / trackLength, 0), 1) || 0;
        if (vertical2 ? indexFromEnd.value : indexFromEnd.value !== isRtl.value)
          clickPos = 1 - clickPos;
        return roundValue(min.value + clickPos * (max.value - min.value));
      }
      const handleStop = (e) => {
        onSliderEnd({
          value: parseMouseMove(e)
        });
        mousePressed.value = false;
        startOffset.value = 0;
      };
      const handleStart = (e) => {
        activeThumbRef.value = getActiveThumb(e);
        if (!activeThumbRef.value)
          return;
        activeThumbRef.value.focus();
        mousePressed.value = true;
        if (activeThumbRef.value.contains(e.target)) {
          startOffset.value = getOffset(e, activeThumbRef.value, props.direction);
        } else {
          startOffset.value = 0;
          onSliderMove({
            value: parseMouseMove(e)
          });
        }
        onSliderStart({
          value: parseMouseMove(e)
        });
      };
      const moveListenerOptions = {
        passive: true,
        capture: true
      };
      function onMouseMove(e) {
        onSliderMove({
          value: parseMouseMove(e)
        });
      }
      function onSliderMouseUp(e) {
        e.stopPropagation();
        e.preventDefault();
        handleStop(e);
        window.removeEventListener("mousemove", onMouseMove, moveListenerOptions);
        window.removeEventListener("mouseup", onSliderMouseUp);
      }
      function onSliderTouchend(e) {
        var _a2;
        handleStop(e);
        window.removeEventListener("touchmove", onMouseMove, moveListenerOptions);
        (_a2 = e.target) == null ? void 0 : _a2.removeEventListener("touchend", onSliderTouchend);
      }
      function onSliderTouchstart(e) {
        var _a2;
        handleStart(e);
        window.addEventListener("touchmove", onMouseMove, moveListenerOptions);
        (_a2 = e.target) == null ? void 0 : _a2.addEventListener("touchend", onSliderTouchend, {
          passive: false
        });
      }
      function onSliderMousedown(e) {
        e.preventDefault();
        handleStart(e);
        window.addEventListener("mousemove", onMouseMove, moveListenerOptions);
        window.addEventListener("mouseup", onSliderMouseUp, {
          passive: false
        });
      }
      const position = (val) => {
        const percentage = (val - min.value) / (max.value - min.value) * 100;
        return clamp(isNaN(percentage) ? 0 : percentage, 0, 100);
      };
      const showTicks = toRef(props, "showTicks");
      const parsedTicks = computed(() => {
        if (!showTicks.value)
          return [];
        if (!props.ticks) {
          return numTicks.value !== Infinity ? createRange(numTicks.value + 1).map((t) => {
            const value = min.value + t * step.value;
            return {
              value,
              position: position(value)
            };
          }) : [];
        }
        if (Array.isArray(props.ticks))
          return props.ticks.map((t) => ({
            value: t,
            position: position(t),
            label: t.toString()
          }));
        return Object.keys(props.ticks).map((key) => ({
          value: parseFloat(key),
          position: position(parseFloat(key)),
          label: props.ticks[key]
        }));
      });
      const hasLabels = computed(() => parsedTicks.value.some((_ref2) => {
        let {
          label
        } = _ref2;
        return !!label;
      }));
      const data = {
        activeThumbRef,
        color: toRef(props, "color"),
        decimals,
        disabled,
        direction: toRef(props, "direction"),
        elevation: toRef(props, "elevation"),
        hasLabels,
        isReversed,
        indexFromEnd,
        min,
        max,
        mousePressed,
        numTicks,
        onSliderMousedown,
        onSliderTouchstart,
        parsedTicks,
        parseMouseMove,
        position,
        readonly: toRef(props, "readonly"),
        rounded: toRef(props, "rounded"),
        roundValue,
        showTicks,
        startOffset,
        step,
        thumbSize,
        thumbColor,
        thumbLabel: toRef(props, "thumbLabel"),
        ticks: toRef(props, "ticks"),
        tickSize,
        trackColor,
        trackContainerRef,
        trackFillColor,
        trackSize,
        vertical
      };
      provide(VSliderSymbol, data);
      return data;
    };
    const makeVSliderThumbProps = propsFactory({
      focused: Boolean,
      max: {
        type: Number,
        required: true
      },
      min: {
        type: Number,
        required: true
      },
      modelValue: {
        type: Number,
        required: true
      },
      position: {
        type: Number,
        required: true
      },
      ripple: {
        type: [Boolean, Object],
        default: true
      },
      name: String,
      ...makeComponentProps()
    }, "VSliderThumb");
    const VSliderThumb = genericComponent()({
      name: "VSliderThumb",
      directives: {
        Ripple
      },
      props: makeVSliderThumbProps(),
      emits: {
        "update:modelValue": (v) => true
      },
      setup(props, _ref) {
        let {
          slots,
          emit: emit2
        } = _ref;
        const slider = inject$1(VSliderSymbol);
        const {
          isRtl,
          rtlClasses
        } = useRtl();
        if (!slider)
          throw new Error("[Vuetify] v-slider-thumb must be used inside v-slider or v-range-slider");
        const {
          thumbColor,
          step,
          disabled,
          thumbSize,
          thumbLabel,
          direction,
          isReversed,
          vertical,
          readonly: readonly2,
          elevation,
          mousePressed,
          decimals,
          indexFromEnd
        } = slider;
        const elevationProps = computed(() => !disabled.value ? elevation.value : void 0);
        const {
          elevationClasses
        } = useElevation(elevationProps);
        const {
          textColorClasses,
          textColorStyles
        } = useTextColor(thumbColor);
        const {
          pageup,
          pagedown,
          end,
          home,
          left,
          right,
          down,
          up
        } = keyValues;
        const relevantKeys = [pageup, pagedown, end, home, left, right, down, up];
        const multipliers = computed(() => {
          if (step.value)
            return [1, 2, 3];
          else
            return [1, 5, 10];
        });
        function parseKeydown(e, value) {
          if (!relevantKeys.includes(e.key))
            return;
          e.preventDefault();
          const _step = step.value || 0.1;
          const steps = (props.max - props.min) / _step;
          if ([left, right, down, up].includes(e.key)) {
            const increase = vertical.value ? [isRtl.value ? left : right, isReversed.value ? down : up] : indexFromEnd.value !== isRtl.value ? [left, up] : [right, up];
            const direction2 = increase.includes(e.key) ? 1 : -1;
            const multiplier = e.shiftKey ? 2 : e.ctrlKey ? 1 : 0;
            value = value + direction2 * _step * multipliers.value[multiplier];
          } else if (e.key === home) {
            value = props.min;
          } else if (e.key === end) {
            value = props.max;
          } else {
            const direction2 = e.key === pagedown ? 1 : -1;
            value = value - direction2 * _step * (steps > 100 ? steps / 10 : 10);
          }
          return Math.max(props.min, Math.min(props.max, value));
        }
        function onKeydown(e) {
          const newValue = parseKeydown(e, props.modelValue);
          newValue != null && emit2("update:modelValue", newValue);
        }
        useRender(() => {
          const positionPercentage = convertToUnit(indexFromEnd.value ? 100 - props.position : props.position, "%");
          return createVNode("div", {
            "class": ["v-slider-thumb", {
              "v-slider-thumb--focused": props.focused,
              "v-slider-thumb--pressed": props.focused && mousePressed.value
            }, props.class, rtlClasses.value],
            "style": [{
              "--v-slider-thumb-position": positionPercentage,
              "--v-slider-thumb-size": convertToUnit(thumbSize.value)
            }, props.style],
            "role": "slider",
            "tabindex": disabled.value ? -1 : 0,
            "aria-label": props.name,
            "aria-valuemin": props.min,
            "aria-valuemax": props.max,
            "aria-valuenow": props.modelValue,
            "aria-readonly": !!readonly2.value,
            "aria-orientation": direction.value,
            "onKeydown": !readonly2.value ? onKeydown : void 0
          }, [createVNode("div", {
            "class": ["v-slider-thumb__surface", textColorClasses.value, elevationClasses.value],
            "style": {
              ...textColorStyles.value
            }
          }, null), withDirectives(createVNode("div", {
            "class": ["v-slider-thumb__ripple", textColorClasses.value],
            "style": textColorStyles.value
          }, null), [[resolveDirective("ripple"), props.ripple, null, {
            circle: true,
            center: true
          }]]), createVNode(VScaleTransition, {
            "origin": "bottom center"
          }, {
            default: () => {
              var _a2;
              return [withDirectives(createVNode("div", {
                "class": "v-slider-thumb__label-container"
              }, [createVNode("div", {
                "class": ["v-slider-thumb__label"]
              }, [createVNode("div", null, [((_a2 = slots["thumb-label"]) == null ? void 0 : _a2.call(slots, {
                modelValue: props.modelValue
              })) ?? props.modelValue.toFixed(step.value ? decimals.value : 1)])])]), [[vShow, thumbLabel.value && props.focused || thumbLabel.value === "always"]])];
            }
          })]);
        });
        return {};
      }
    });
    const makeVSliderTrackProps = propsFactory({
      start: {
        type: Number,
        required: true
      },
      stop: {
        type: Number,
        required: true
      },
      ...makeComponentProps()
    }, "VSliderTrack");
    const VSliderTrack = genericComponent()({
      name: "VSliderTrack",
      props: makeVSliderTrackProps(),
      emits: {},
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const slider = inject$1(VSliderSymbol);
        if (!slider)
          throw new Error("[Vuetify] v-slider-track must be inside v-slider or v-range-slider");
        const {
          color,
          parsedTicks,
          rounded,
          showTicks,
          tickSize,
          trackColor,
          trackFillColor,
          trackSize,
          vertical,
          min,
          max,
          indexFromEnd
        } = slider;
        const {
          roundedClasses
        } = useRounded(rounded);
        const {
          backgroundColorClasses: trackFillColorClasses,
          backgroundColorStyles: trackFillColorStyles
        } = useBackgroundColor(trackFillColor);
        const {
          backgroundColorClasses: trackColorClasses,
          backgroundColorStyles: trackColorStyles
        } = useBackgroundColor(trackColor);
        const startDir = computed(() => `inset-${vertical.value ? "block" : "inline"}-${indexFromEnd.value ? "end" : "start"}`);
        const endDir = computed(() => vertical.value ? "height" : "width");
        const backgroundStyles = computed(() => {
          return {
            [startDir.value]: "0%",
            [endDir.value]: "100%"
          };
        });
        const trackFillWidth = computed(() => props.stop - props.start);
        const trackFillStyles = computed(() => {
          return {
            [startDir.value]: convertToUnit(props.start, "%"),
            [endDir.value]: convertToUnit(trackFillWidth.value, "%")
          };
        });
        const computedTicks = computed(() => {
          if (!showTicks.value)
            return [];
          const ticks = vertical.value ? parsedTicks.value.slice().reverse() : parsedTicks.value;
          return ticks.map((tick, index) => {
            var _a2;
            const directionValue = tick.value !== min.value && tick.value !== max.value ? convertToUnit(tick.position, "%") : void 0;
            return createVNode("div", {
              "key": tick.value,
              "class": ["v-slider-track__tick", {
                "v-slider-track__tick--filled": tick.position >= props.start && tick.position <= props.stop,
                "v-slider-track__tick--first": tick.value === min.value,
                "v-slider-track__tick--last": tick.value === max.value
              }],
              "style": {
                [startDir.value]: directionValue
              }
            }, [(tick.label || slots["tick-label"]) && createVNode("div", {
              "class": "v-slider-track__tick-label"
            }, [((_a2 = slots["tick-label"]) == null ? void 0 : _a2.call(slots, {
              tick,
              index
            })) ?? tick.label])]);
          });
        });
        useRender(() => {
          return createVNode("div", {
            "class": ["v-slider-track", roundedClasses.value, props.class],
            "style": [{
              "--v-slider-track-size": convertToUnit(trackSize.value),
              "--v-slider-tick-size": convertToUnit(tickSize.value)
            }, props.style]
          }, [createVNode("div", {
            "class": ["v-slider-track__background", trackColorClasses.value, {
              "v-slider-track__background--opacity": !!color.value || !trackFillColor.value
            }],
            "style": {
              ...backgroundStyles.value,
              ...trackColorStyles.value
            }
          }, null), createVNode("div", {
            "class": ["v-slider-track__fill", trackFillColorClasses.value],
            "style": {
              ...trackFillStyles.value,
              ...trackFillColorStyles.value
            }
          }, null), showTicks.value && createVNode("div", {
            "class": ["v-slider-track__ticks", {
              "v-slider-track__ticks--always-show": showTicks.value === "always"
            }]
          }, [computedTicks.value])]);
        });
        return {};
      }
    });
    const makeVSliderProps = propsFactory({
      ...makeFocusProps(),
      ...makeSliderProps(),
      ...makeVInputProps(),
      modelValue: {
        type: [Number, String],
        default: 0
      }
    }, "VSlider");
    const VSlider = genericComponent()({
      name: "VSlider",
      props: makeVSliderProps(),
      emits: {
        "update:focused": (value) => true,
        "update:modelValue": (v) => true,
        start: (value) => true,
        end: (value) => true
      },
      setup(props, _ref) {
        let {
          slots,
          emit: emit2
        } = _ref;
        const thumbContainerRef = ref$1();
        const {
          rtlClasses
        } = useRtl();
        const steps = useSteps(props);
        const model = useProxiedModel(props, "modelValue", void 0, (value) => {
          return steps.roundValue(value == null ? steps.min.value : value);
        });
        const {
          min,
          max,
          mousePressed,
          roundValue,
          onSliderMousedown,
          onSliderTouchstart,
          trackContainerRef,
          position,
          hasLabels,
          readonly: readonly2
        } = useSlider({
          props,
          steps,
          onSliderStart: () => {
            emit2("start", model.value);
          },
          onSliderEnd: (_ref2) => {
            let {
              value
            } = _ref2;
            const roundedValue = roundValue(value);
            model.value = roundedValue;
            emit2("end", roundedValue);
          },
          onSliderMove: (_ref3) => {
            let {
              value
            } = _ref3;
            return model.value = roundValue(value);
          },
          getActiveThumb: () => {
            var _a2;
            return (_a2 = thumbContainerRef.value) == null ? void 0 : _a2.$el;
          }
        });
        const {
          isFocused,
          focus,
          blur
        } = useFocus(props);
        const trackStop = computed(() => position(model.value));
        useRender(() => {
          const inputProps = VInput.filterProps(props);
          const hasPrepend = !!(props.label || slots.label || slots.prepend);
          return createVNode(VInput, mergeProps({
            "class": ["v-slider", {
              "v-slider--has-labels": !!slots["tick-label"] || hasLabels.value,
              "v-slider--focused": isFocused.value,
              "v-slider--pressed": mousePressed.value,
              "v-slider--disabled": props.disabled
            }, rtlClasses.value, props.class],
            "style": props.style
          }, inputProps, {
            "focused": isFocused.value
          }), {
            ...slots,
            prepend: hasPrepend ? (slotProps) => {
              var _a2, _b;
              return createVNode(Fragment, null, [((_a2 = slots.label) == null ? void 0 : _a2.call(slots, slotProps)) ?? (props.label ? createVNode(VLabel, {
                "id": slotProps.id.value,
                "class": "v-slider__label",
                "text": props.label
              }, null) : void 0), (_b = slots.prepend) == null ? void 0 : _b.call(slots, slotProps)]);
            } : void 0,
            default: (_ref4) => {
              let {
                id: id2,
                messagesId
              } = _ref4;
              return createVNode("div", {
                "class": "v-slider__container",
                "onMousedown": !readonly2.value ? onSliderMousedown : void 0,
                "onTouchstartPassive": !readonly2.value ? onSliderTouchstart : void 0
              }, [createVNode("input", {
                "id": id2.value,
                "name": props.name || id2.value,
                "disabled": !!props.disabled,
                "readonly": !!props.readonly,
                "tabindex": "-1",
                "value": model.value
              }, null), createVNode(VSliderTrack, {
                "ref": trackContainerRef,
                "start": 0,
                "stop": trackStop.value
              }, {
                "tick-label": slots["tick-label"]
              }), createVNode(VSliderThumb, {
                "ref": thumbContainerRef,
                "aria-describedby": messagesId.value,
                "focused": isFocused.value,
                "min": min.value,
                "max": max.value,
                "modelValue": model.value,
                "onUpdate:modelValue": (v) => model.value = v,
                "position": trackStop.value,
                "elevation": props.elevation,
                "onFocus": focus,
                "onBlur": blur,
                "ripple": props.ripple,
                "name": props.name
              }, {
                "thumb-label": slots["thumb-label"]
              })]);
            }
          });
        });
        return {};
      }
    });
    const _sfc_main$q = {
      __name: "slider",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfSliderNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        useDefaults({}, "VjsfSlider");
        const props = __props;
        const fieldProps = computed(() => {
          const fieldProps2 = getInputProps(props.modelValue, props.statefulLayout);
          if ("step" in props.modelValue.layout)
            fieldProps2.step = props.modelValue.layout.step;
          fieldProps2.min = props.modelValue.layout.min;
          fieldProps2.max = props.modelValue.layout.max;
          return fieldProps2;
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(VSlider), mergeProps({ type: "number" }, fieldProps.value, {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = (value) => __props.statefulLayout.input(__props.modelValue, value && Number(value)))
          }), null, 16);
        };
      }
    };
    const _sfc_main$p = {
      __name: "text-field-menu",
      props: /* @__PURE__ */ mergeModels({
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        },
        formattedValue: {
          /** @type import('vue').PropType<string | null> */
          type: String,
          default: null
        }
      }, {
        "menuOpened": { type: Boolean, default: false },
        "menuOpenedModifiers": {}
      }),
      emits: ["update:menuOpened"],
      setup(__props) {
        const props = __props;
        const fieldProps = computed(() => {
          const fieldProps2 = getInputProps(props.modelValue, props.statefulLayout, [], false);
          fieldProps2.readonly = true;
          fieldProps2.clearable = fieldProps2.clearable ?? !props.modelValue.skeleton.required;
          fieldProps2["onClick:clear"] = () => {
            props.statefulLayout.input(props.modelValue, null);
          };
          return fieldProps2;
        });
        const menuProps = computed(() => {
          const menuProps2 = getCompProps(props.modelValue);
          menuProps2.closeOnContentClick = false;
          menuProps2.disabled = true;
          return menuProps2;
        });
        const textField = ref$1(null);
        const menuOpened = useModel(__props, "menuOpened");
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock(Fragment, null, [
            createVNode(unref(VTextField), mergeProps({
              ref_key: "textField",
              ref: textField
            }, fieldProps.value, {
              "model-value": __props.formattedValue ?? __props.modelValue.data,
              "onClick:control": _cache[0] || (_cache[0] = (e) => {
                menuOpened.value = !menuOpened.value;
                e.stopPropagation();
              })
            }), {
              "prepend-inner": withCtx(() => [
                renderSlot(_ctx.$slots, "prepend-inner")
              ]),
              _: 3
            }, 16, ["model-value"]),
            textField.value ? (openBlock(), createBlock(unref(VMenu), mergeProps({ key: 0 }, menuProps.value, {
              modelValue: menuOpened.value,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => menuOpened.value = $event),
              class: "vjsf-text-field-menu",
              activator: textField.value
            }), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default", {
                  close: () => menuOpened.value = false
                })
              ]),
              _: 3
            }, 16, ["modelValue", "activator"])) : createCommentVNode("", true)
          ], 64);
        };
      }
    };
    const makeVDatePickerControlsProps = propsFactory({
      active: {
        type: [String, Array],
        default: void 0
      },
      disabled: {
        type: [Boolean, String, Array],
        default: false
      },
      nextIcon: {
        type: IconValue,
        default: "$next"
      },
      prevIcon: {
        type: IconValue,
        default: "$prev"
      },
      modeIcon: {
        type: IconValue,
        default: "$subgroup"
      },
      text: String,
      viewMode: {
        type: String,
        default: "month"
      }
    }, "VDatePickerControls");
    const VDatePickerControls = genericComponent()({
      name: "VDatePickerControls",
      props: makeVDatePickerControlsProps(),
      emits: {
        "click:year": () => true,
        "click:month": () => true,
        "click:prev": () => true,
        "click:next": () => true,
        "click:text": () => true
      },
      setup(props, _ref) {
        let {
          emit: emit2
        } = _ref;
        const disableMonth = computed(() => {
          return Array.isArray(props.disabled) ? props.disabled.includes("text") : !!props.disabled;
        });
        const disableYear = computed(() => {
          return Array.isArray(props.disabled) ? props.disabled.includes("mode") : !!props.disabled;
        });
        const disablePrev = computed(() => {
          return Array.isArray(props.disabled) ? props.disabled.includes("prev") : !!props.disabled;
        });
        const disableNext = computed(() => {
          return Array.isArray(props.disabled) ? props.disabled.includes("next") : !!props.disabled;
        });
        function onClickPrev() {
          emit2("click:prev");
        }
        function onClickNext() {
          emit2("click:next");
        }
        function onClickYear() {
          emit2("click:year");
        }
        function onClickMonth() {
          emit2("click:month");
        }
        useRender(() => {
          return createVNode("div", {
            "class": ["v-date-picker-controls"]
          }, [createVNode(VBtn, {
            "class": "v-date-picker-controls__month-btn",
            "disabled": disableMonth.value,
            "text": props.text,
            "variant": "text",
            "rounded": true,
            "onClick": onClickMonth
          }, null), createVNode(VBtn, {
            "key": "mode-btn",
            "class": "v-date-picker-controls__mode-btn",
            "disabled": disableYear.value,
            "density": "comfortable",
            "icon": props.modeIcon,
            "variant": "text",
            "onClick": onClickYear
          }, null), createVNode(VSpacer, {
            "key": "mode-spacer"
          }, null), createVNode("div", {
            "key": "month-buttons",
            "class": "v-date-picker-controls__month"
          }, [createVNode(VBtn, {
            "disabled": disablePrev.value,
            "icon": props.prevIcon,
            "variant": "text",
            "onClick": onClickPrev
          }, null), createVNode(VBtn, {
            "disabled": disableNext.value,
            "icon": props.nextIcon,
            "variant": "text",
            "onClick": onClickNext
          }, null)])]);
        });
        return {};
      }
    });
    const makeVDatePickerHeaderProps = propsFactory({
      appendIcon: String,
      color: String,
      header: String,
      transition: String,
      onClick: EventProp()
    }, "VDatePickerHeader");
    const VDatePickerHeader = genericComponent()({
      name: "VDatePickerHeader",
      props: makeVDatePickerHeaderProps(),
      emits: {
        click: () => true,
        "click:append": () => true
      },
      setup(props, _ref) {
        let {
          emit: emit2,
          slots
        } = _ref;
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(props, "color");
        function onClick() {
          emit2("click");
        }
        function onClickAppend() {
          emit2("click:append");
        }
        useRender(() => {
          const hasContent = !!(slots.default || props.header);
          const hasAppend = !!(slots.append || props.appendIcon);
          return createVNode("div", {
            "class": ["v-date-picker-header", {
              "v-date-picker-header--clickable": !!props.onClick
            }, backgroundColorClasses.value],
            "style": backgroundColorStyles.value,
            "onClick": onClick
          }, [slots.prepend && createVNode("div", {
            "key": "prepend",
            "class": "v-date-picker-header__prepend"
          }, [slots.prepend()]), hasContent && createVNode(MaybeTransition, {
            "key": "content",
            "name": props.transition
          }, {
            default: () => {
              var _a2;
              return [createVNode("div", {
                "key": props.header,
                "class": "v-date-picker-header__content"
              }, [((_a2 = slots.default) == null ? void 0 : _a2.call(slots)) ?? props.header])];
            }
          }), hasAppend && createVNode("div", {
            "class": "v-date-picker-header__append"
          }, [!slots.append ? createVNode(VBtn, {
            "key": "append-btn",
            "icon": props.appendIcon,
            "variant": "text",
            "onClick": onClickAppend
          }, null) : createVNode(VDefaultsProvider, {
            "key": "append-defaults",
            "disabled": !props.appendIcon,
            "defaults": {
              VBtn: {
                icon: props.appendIcon,
                variant: "text"
              }
            }
          }, {
            default: () => {
              var _a2;
              return [(_a2 = slots.append) == null ? void 0 : _a2.call(slots)];
            }
          })])]);
        });
        return {};
      }
    });
    const makeCalendarProps = propsFactory({
      allowedDates: [Array, Function],
      disabled: Boolean,
      displayValue: null,
      modelValue: Array,
      month: [Number, String],
      max: null,
      min: null,
      showAdjacentMonths: Boolean,
      year: [Number, String],
      weekdays: {
        type: Array,
        default: () => [0, 1, 2, 3, 4, 5, 6]
      },
      weeksInMonth: {
        type: String,
        default: "dynamic"
      },
      firstDayOfWeek: [Number, String]
    }, "calendar");
    function useCalendar(props) {
      const adapter = useDate();
      const model = useProxiedModel(props, "modelValue", [], (v) => wrapInArray(v));
      const displayValue = computed(() => {
        if (props.displayValue)
          return adapter.date(props.displayValue);
        if (model.value.length > 0)
          return adapter.date(model.value[0]);
        if (props.min)
          return adapter.date(props.min);
        if (Array.isArray(props.allowedDates))
          return adapter.date(props.allowedDates[0]);
        return adapter.date();
      });
      const year = useProxiedModel(props, "year", void 0, (v) => {
        const value = v != null ? Number(v) : adapter.getYear(displayValue.value);
        return adapter.startOfYear(adapter.setYear(adapter.date(), value));
      }, (v) => adapter.getYear(v));
      const month = useProxiedModel(props, "month", void 0, (v) => {
        const value = v != null ? Number(v) : adapter.getMonth(displayValue.value);
        const date2 = adapter.setYear(adapter.startOfMonth(adapter.date()), adapter.getYear(year.value));
        return adapter.setMonth(date2, value);
      }, (v) => adapter.getMonth(v));
      const weekDays = computed(() => {
        const firstDayOfWeek = Number(props.firstDayOfWeek ?? 0);
        return props.weekdays.map((day) => (day + firstDayOfWeek) % 7);
      });
      const weeksInMonth = computed(() => {
        const weeks = adapter.getWeekArray(month.value, props.firstDayOfWeek);
        const days = weeks.flat();
        const daysInMonth2 = 6 * 7;
        if (props.weeksInMonth === "static" && days.length < daysInMonth2) {
          const lastDay = days[days.length - 1];
          let week = [];
          for (let day = 1; day <= daysInMonth2 - days.length; day++) {
            week.push(adapter.addDays(lastDay, day));
            if (day % 7 === 0) {
              weeks.push(week);
              week = [];
            }
          }
        }
        return weeks;
      });
      function genDays(days, today) {
        return days.filter((date2) => {
          return weekDays.value.includes(adapter.toJsDate(date2).getDay());
        }).map((date2, index) => {
          const isoDate = adapter.toISO(date2);
          const isAdjacent = !adapter.isSameMonth(date2, month.value);
          const isStart = adapter.isSameDay(date2, adapter.startOfMonth(month.value));
          const isEnd = adapter.isSameDay(date2, adapter.endOfMonth(month.value));
          const isSame = adapter.isSameDay(date2, month.value);
          return {
            date: date2,
            isoDate,
            formatted: adapter.format(date2, "keyboardDate"),
            year: adapter.getYear(date2),
            month: adapter.getMonth(date2),
            isDisabled: isDisabled(date2),
            isWeekStart: index % 7 === 0,
            isWeekEnd: index % 7 === 6,
            isToday: adapter.isSameDay(date2, today),
            isAdjacent,
            isHidden: isAdjacent && !props.showAdjacentMonths,
            isStart,
            isSelected: model.value.some((value) => adapter.isSameDay(date2, value)),
            isEnd,
            isSame,
            localized: adapter.format(date2, "dayOfMonth")
          };
        });
      }
      const daysInWeek = computed(() => {
        const lastDay = adapter.startOfWeek(displayValue.value, props.firstDayOfWeek);
        const week = [];
        for (let day = 0; day <= 6; day++) {
          week.push(adapter.addDays(lastDay, day));
        }
        const today = adapter.date();
        return genDays(week, today);
      });
      const daysInMonth = computed(() => {
        const days = weeksInMonth.value.flat();
        const today = adapter.date();
        return genDays(days, today);
      });
      const weekNumbers = computed(() => {
        return weeksInMonth.value.map((week) => {
          return week.length ? getWeek(adapter, week[0]) : null;
        });
      });
      function isDisabled(value) {
        if (props.disabled)
          return true;
        const date2 = adapter.date(value);
        if (props.min && adapter.isAfter(adapter.date(props.min), date2))
          return true;
        if (props.max && adapter.isAfter(date2, adapter.date(props.max)))
          return true;
        if (Array.isArray(props.allowedDates) && props.allowedDates.length > 0) {
          return !props.allowedDates.some((d) => adapter.isSameDay(adapter.date(d), date2));
        }
        if (typeof props.allowedDates === "function") {
          return !props.allowedDates(date2);
        }
        return false;
      }
      return {
        displayValue,
        daysInMonth,
        daysInWeek,
        genDays,
        model,
        weeksInMonth,
        weekDays,
        weekNumbers
      };
    }
    const makeVDatePickerMonthProps = propsFactory({
      color: String,
      hideWeekdays: Boolean,
      multiple: [Boolean, Number, String],
      showWeek: Boolean,
      transition: {
        type: String,
        default: "picker-transition"
      },
      reverseTransition: {
        type: String,
        default: "picker-reverse-transition"
      },
      ...makeCalendarProps()
    }, "VDatePickerMonth");
    const VDatePickerMonth = genericComponent()({
      name: "VDatePickerMonth",
      props: makeVDatePickerMonthProps(),
      emits: {
        "update:modelValue": (date2) => true,
        "update:month": (date2) => true,
        "update:year": (date2) => true
      },
      setup(props, _ref) {
        let {
          emit: emit2,
          slots
        } = _ref;
        const daysRef = ref$1();
        const {
          daysInMonth,
          model,
          weekNumbers
        } = useCalendar(props);
        const adapter = useDate();
        const rangeStart = shallowRef();
        const rangeStop = shallowRef();
        const isReverse = shallowRef(false);
        const transition = computed(() => {
          return !isReverse.value ? props.transition : props.reverseTransition;
        });
        if (props.multiple === "range" && model.value.length > 0) {
          rangeStart.value = model.value[0];
          if (model.value.length > 1) {
            rangeStop.value = model.value[model.value.length - 1];
          }
        }
        const atMax = computed(() => {
          const max = ["number", "string"].includes(typeof props.multiple) ? Number(props.multiple) : Infinity;
          return model.value.length >= max;
        });
        watch(daysInMonth, (val, oldVal) => {
          if (!oldVal)
            return;
          isReverse.value = adapter.isBefore(val[0].date, oldVal[0].date);
        });
        function onRangeClick(value) {
          const _value = adapter.startOfDay(value);
          if (model.value.length === 0) {
            rangeStart.value = void 0;
          } else if (model.value.length === 1) {
            rangeStart.value = model.value[0];
            rangeStop.value = void 0;
          }
          if (!rangeStart.value) {
            rangeStart.value = _value;
            model.value = [rangeStart.value];
          } else if (!rangeStop.value) {
            if (adapter.isSameDay(_value, rangeStart.value)) {
              rangeStart.value = void 0;
              model.value = [];
              return;
            } else if (adapter.isBefore(_value, rangeStart.value)) {
              rangeStop.value = adapter.endOfDay(rangeStart.value);
              rangeStart.value = _value;
            } else {
              rangeStop.value = adapter.endOfDay(_value);
            }
            const diff = adapter.getDiff(rangeStop.value, rangeStart.value, "days");
            const datesInRange = [rangeStart.value];
            for (let i2 = 1; i2 < diff; i2++) {
              const nextDate = adapter.addDays(rangeStart.value, i2);
              datesInRange.push(nextDate);
            }
            datesInRange.push(rangeStop.value);
            model.value = datesInRange;
          } else {
            rangeStart.value = value;
            rangeStop.value = void 0;
            model.value = [rangeStart.value];
          }
        }
        function onMultipleClick(value) {
          const index = model.value.findIndex((selection) => adapter.isSameDay(selection, value));
          if (index === -1) {
            model.value = [...model.value, value];
          } else {
            const value2 = [...model.value];
            value2.splice(index, 1);
            model.value = value2;
          }
        }
        function onClick(value) {
          if (props.multiple === "range") {
            onRangeClick(value);
          } else if (props.multiple) {
            onMultipleClick(value);
          } else {
            model.value = [value];
          }
        }
        return () => createVNode("div", {
          "class": "v-date-picker-month"
        }, [props.showWeek && createVNode("div", {
          "key": "weeks",
          "class": "v-date-picker-month__weeks"
        }, [!props.hideWeekdays && createVNode("div", {
          "key": "hide-week-days",
          "class": "v-date-picker-month__day"
        }, [createTextVNode(" ")]), weekNumbers.value.map((week) => createVNode("div", {
          "class": ["v-date-picker-month__day", "v-date-picker-month__day--adjacent"]
        }, [week]))]), createVNode(MaybeTransition, {
          "name": transition.value
        }, {
          default: () => {
            var _a2;
            return [createVNode("div", {
              "ref": daysRef,
              "key": (_a2 = daysInMonth.value[0].date) == null ? void 0 : _a2.toString(),
              "class": "v-date-picker-month__days"
            }, [!props.hideWeekdays && adapter.getWeekdays(props.firstDayOfWeek).map((weekDay) => createVNode("div", {
              "class": ["v-date-picker-month__day", "v-date-picker-month__weekday"]
            }, [weekDay])), daysInMonth.value.map((item, i2) => {
              const slotProps = {
                props: {
                  onClick: () => onClick(item.date)
                },
                item,
                i: i2
              };
              if (atMax.value && !item.isSelected) {
                item.isDisabled = true;
              }
              return createVNode("div", {
                "class": ["v-date-picker-month__day", {
                  "v-date-picker-month__day--adjacent": item.isAdjacent,
                  "v-date-picker-month__day--hide-adjacent": item.isHidden,
                  "v-date-picker-month__day--selected": item.isSelected,
                  "v-date-picker-month__day--week-end": item.isWeekEnd,
                  "v-date-picker-month__day--week-start": item.isWeekStart
                }],
                "data-v-date": !item.isDisabled ? item.isoDate : void 0
              }, [(props.showAdjacentMonths || !item.isAdjacent) && createVNode(VDefaultsProvider, {
                "defaults": {
                  VBtn: {
                    class: "v-date-picker-month__day-btn",
                    color: (item.isSelected || item.isToday) && !item.isDisabled ? props.color : void 0,
                    disabled: item.isDisabled,
                    icon: true,
                    ripple: false,
                    text: item.localized,
                    variant: item.isDisabled ? item.isToday ? "outlined" : "text" : item.isToday && !item.isSelected ? "outlined" : "flat",
                    onClick: () => onClick(item.date)
                  }
                }
              }, {
                default: () => {
                  var _a3;
                  return [((_a3 = slots.day) == null ? void 0 : _a3.call(slots, slotProps)) ?? createVNode(VBtn, slotProps.props, null)];
                }
              })]);
            })])];
          }
        })]);
      }
    });
    const makeVDatePickerMonthsProps = propsFactory({
      color: String,
      height: [String, Number],
      min: null,
      max: null,
      modelValue: Number,
      year: Number
    }, "VDatePickerMonths");
    const VDatePickerMonths = genericComponent()({
      name: "VDatePickerMonths",
      props: makeVDatePickerMonthsProps(),
      emits: {
        "update:modelValue": (date2) => true
      },
      setup(props, _ref) {
        let {
          emit: emit2,
          slots
        } = _ref;
        const adapter = useDate();
        const model = useProxiedModel(props, "modelValue");
        const months = computed(() => {
          let date2 = adapter.startOfYear(adapter.date());
          if (props.year) {
            date2 = adapter.setYear(date2, props.year);
          }
          return createRange(12).map((i2) => {
            const text2 = adapter.format(date2, "monthShort");
            const isDisabled = !!(props.min && adapter.isAfter(adapter.startOfMonth(adapter.date(props.min)), date2) || props.max && adapter.isAfter(date2, adapter.startOfMonth(adapter.date(props.max))));
            date2 = adapter.getNextMonth(date2);
            return {
              isDisabled,
              text: text2,
              value: i2
            };
          });
        });
        watchEffect(() => {
          model.value = model.value ?? adapter.getMonth(adapter.date());
        });
        useRender(() => createVNode("div", {
          "class": "v-date-picker-months",
          "style": {
            height: convertToUnit(props.height)
          }
        }, [createVNode("div", {
          "class": "v-date-picker-months__content"
        }, [months.value.map((month, i2) => {
          var _a2;
          const btnProps = {
            active: model.value === i2,
            color: model.value === i2 ? props.color : void 0,
            disabled: month.isDisabled,
            rounded: true,
            text: month.text,
            variant: model.value === month.value ? "flat" : "text",
            onClick: () => onClick(i2)
          };
          function onClick(i3) {
            if (model.value === i3) {
              emit2("update:modelValue", model.value);
              return;
            }
            model.value = i3;
          }
          return ((_a2 = slots.month) == null ? void 0 : _a2.call(slots, {
            month,
            i: i2,
            props: btnProps
          })) ?? createVNode(VBtn, mergeProps({
            "key": "month"
          }, btnProps), null);
        })])]));
        return {};
      }
    });
    const makeVDatePickerYearsProps = propsFactory({
      color: String,
      height: [String, Number],
      min: null,
      max: null,
      modelValue: Number
    }, "VDatePickerYears");
    const VDatePickerYears = genericComponent()({
      name: "VDatePickerYears",
      props: makeVDatePickerYearsProps(),
      emits: {
        "update:modelValue": (year) => true
      },
      setup(props, _ref) {
        let {
          emit: emit2,
          slots
        } = _ref;
        const adapter = useDate();
        const model = useProxiedModel(props, "modelValue");
        const years = computed(() => {
          const year = adapter.getYear(adapter.date());
          let min = year - 100;
          let max = year + 52;
          if (props.min) {
            min = adapter.getYear(adapter.date(props.min));
          }
          if (props.max) {
            max = adapter.getYear(adapter.date(props.max));
          }
          let date2 = adapter.startOfYear(adapter.date());
          date2 = adapter.setYear(date2, min);
          return createRange(max - min + 1, min).map((i2) => {
            const text2 = adapter.format(date2, "year");
            date2 = adapter.setYear(date2, adapter.getYear(date2) + 1);
            return {
              text: text2,
              value: i2
            };
          });
        });
        watchEffect(() => {
          model.value = model.value ?? adapter.getYear(adapter.date());
        });
        const yearRef = templateRef();
        onMounted(async () => {
          var _a2;
          await nextTick();
          (_a2 = yearRef.el) == null ? void 0 : _a2.scrollIntoView({
            block: "center"
          });
        });
        useRender(() => createVNode("div", {
          "class": "v-date-picker-years",
          "style": {
            height: convertToUnit(props.height)
          }
        }, [createVNode("div", {
          "class": "v-date-picker-years__content"
        }, [years.value.map((year, i2) => {
          var _a2;
          const btnProps = {
            ref: model.value === year.value ? yearRef : void 0,
            active: model.value === year.value,
            color: model.value === year.value ? props.color : void 0,
            rounded: true,
            text: year.text,
            variant: model.value === year.value ? "flat" : "text",
            onClick: () => {
              if (model.value === year.value) {
                emit2("update:modelValue", model.value);
                return;
              }
              model.value = year.value;
            }
          };
          return ((_a2 = slots.year) == null ? void 0 : _a2.call(slots, {
            year,
            i: i2,
            props: btnProps
          })) ?? createVNode(VBtn, mergeProps({
            "key": "month"
          }, btnProps), null);
        })])]));
        return {};
      }
    });
    const VPickerTitle = createSimpleFunctional("v-picker-title");
    const makeVPickerProps = propsFactory({
      bgColor: String,
      landscape: Boolean,
      title: String,
      hideHeader: Boolean,
      ...makeVSheetProps()
    }, "VPicker");
    const VPicker = genericComponent()({
      name: "VPicker",
      props: makeVPickerProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(toRef(props, "color"));
        useRender(() => {
          const sheetProps = VSheet.filterProps(props);
          const hasTitle = !!(props.title || slots.title);
          return createVNode(VSheet, mergeProps(sheetProps, {
            "color": props.bgColor,
            "class": ["v-picker", {
              "v-picker--landscape": props.landscape,
              "v-picker--with-actions": !!slots.actions
            }, props.class],
            "style": props.style
          }), {
            default: () => {
              var _a2;
              return [!props.hideHeader && createVNode("div", {
                "key": "header",
                "class": [backgroundColorClasses.value],
                "style": [backgroundColorStyles.value]
              }, [hasTitle && createVNode(VPickerTitle, {
                "key": "picker-title"
              }, {
                default: () => {
                  var _a3;
                  return [((_a3 = slots.title) == null ? void 0 : _a3.call(slots)) ?? props.title];
                }
              }), slots.header && createVNode("div", {
                "class": "v-picker__header"
              }, [slots.header()])]), createVNode("div", {
                "class": "v-picker__body"
              }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), slots.actions && createVNode(VDefaultsProvider, {
                "defaults": {
                  VBtn: {
                    slim: true,
                    variant: "text"
                  }
                }
              }, {
                default: () => [createVNode("div", {
                  "class": "v-picker__actions"
                }, [slots.actions()])]
              })];
            }
          });
        });
        return {};
      }
    });
    const makeVDatePickerProps = propsFactory({
      // TODO: implement in v3.5
      // calendarIcon: {
      //   type: String,
      //   default: '$calendar',
      // },
      // keyboardIcon: {
      //   type: String,
      //   default: '$edit',
      // },
      // inputMode: {
      //   type: String as PropType<'calendar' | 'keyboard'>,
      //   default: 'calendar',
      // },
      // inputText: {
      //   type: String,
      //   default: '$vuetify.datePicker.input.placeholder',
      // },
      // inputPlaceholder: {
      //   type: String,
      //   default: 'dd/mm/yyyy',
      // },
      header: {
        type: String,
        default: "$vuetify.datePicker.header"
      },
      ...makeVDatePickerControlsProps(),
      ...makeVDatePickerMonthProps({
        weeksInMonth: "static"
      }),
      ...omit$1(makeVDatePickerMonthsProps(), ["modelValue"]),
      ...omit$1(makeVDatePickerYearsProps(), ["modelValue"]),
      ...makeVPickerProps({
        title: "$vuetify.datePicker.title"
      }),
      modelValue: null
    }, "VDatePicker");
    const VDatePicker = genericComponent()({
      name: "VDatePicker",
      props: makeVDatePickerProps(),
      emits: {
        "update:modelValue": (date2) => true,
        "update:month": (date2) => true,
        "update:year": (date2) => true,
        // 'update:inputMode': (date: any) => true,
        "update:viewMode": (date2) => true
      },
      setup(props, _ref) {
        let {
          emit: emit2,
          slots
        } = _ref;
        const adapter = useDate();
        const {
          t
        } = useLocale();
        const model = useProxiedModel(props, "modelValue", void 0, (v) => wrapInArray(v), (v) => props.multiple ? v : v[0]);
        const viewMode = useProxiedModel(props, "viewMode");
        const internal = computed(() => {
          var _a2;
          const value = adapter.date((_a2 = model.value) == null ? void 0 : _a2[0]);
          return value && adapter.isValid(value) ? value : adapter.date();
        });
        const month = ref$1(Number(props.month ?? adapter.getMonth(adapter.startOfMonth(internal.value))));
        const year = ref$1(Number(props.year ?? adapter.getYear(adapter.startOfYear(adapter.setMonth(internal.value, month.value)))));
        const isReversing = shallowRef(false);
        const header = computed(() => {
          if (props.multiple && model.value.length > 1) {
            return t("$vuetify.datePicker.itemsSelected", model.value.length);
          }
          return model.value[0] && adapter.isValid(model.value[0]) ? adapter.format(adapter.date(model.value[0]), "normalDateWithWeekday") : t(props.header);
        });
        const text2 = computed(() => {
          let date2 = adapter.date();
          date2 = adapter.setDate(date2, 1);
          date2 = adapter.setMonth(date2, month.value);
          date2 = adapter.setYear(date2, year.value);
          return adapter.format(date2, "monthAndYear");
        });
        const headerTransition = computed(() => `date-picker-header${isReversing.value ? "-reverse" : ""}-transition`);
        const minDate = computed(() => {
          const date2 = adapter.date(props.min);
          return props.min && adapter.isValid(date2) ? date2 : null;
        });
        const maxDate = computed(() => {
          const date2 = adapter.date(props.max);
          return props.max && adapter.isValid(date2) ? date2 : null;
        });
        const disabled = computed(() => {
          if (props.disabled)
            return true;
          const targets = [];
          if (viewMode.value !== "month") {
            targets.push(...["prev", "next"]);
          } else {
            let _date = adapter.date();
            _date = adapter.setYear(_date, year.value);
            _date = adapter.setMonth(_date, month.value);
            if (minDate.value) {
              const date2 = adapter.addDays(adapter.startOfMonth(_date), -1);
              adapter.isAfter(minDate.value, date2) && targets.push("prev");
            }
            if (maxDate.value) {
              const date2 = adapter.addDays(adapter.endOfMonth(_date), 1);
              adapter.isAfter(date2, maxDate.value) && targets.push("next");
            }
          }
          return targets;
        });
        function onClickNext() {
          if (month.value < 11) {
            month.value++;
          } else {
            year.value++;
            month.value = 0;
            onUpdateYear(year.value);
          }
          onUpdateMonth(month.value);
        }
        function onClickPrev() {
          if (month.value > 0) {
            month.value--;
          } else {
            year.value--;
            month.value = 11;
            onUpdateYear(year.value);
          }
          onUpdateMonth(month.value);
        }
        function onClickDate() {
          viewMode.value = "month";
        }
        function onClickMonth() {
          viewMode.value = viewMode.value === "months" ? "month" : "months";
        }
        function onClickYear() {
          viewMode.value = viewMode.value === "year" ? "month" : "year";
        }
        function onUpdateMonth(value) {
          if (viewMode.value === "months")
            onClickMonth();
          emit2("update:month", value);
        }
        function onUpdateYear(value) {
          if (viewMode.value === "year")
            onClickYear();
          emit2("update:year", value);
        }
        watch(model, (val, oldVal) => {
          const arrBefore = wrapInArray(oldVal);
          const arrAfter = wrapInArray(val);
          if (!arrAfter.length)
            return;
          const before = adapter.date(arrBefore[arrBefore.length - 1]);
          const after = adapter.date(arrAfter[arrAfter.length - 1]);
          const newMonth = adapter.getMonth(after);
          const newYear = adapter.getYear(after);
          if (newMonth !== month.value) {
            month.value = newMonth;
            onUpdateMonth(month.value);
          }
          if (newYear !== year.value) {
            year.value = newYear;
            onUpdateYear(year.value);
          }
          isReversing.value = adapter.isBefore(before, after);
        });
        useRender(() => {
          const pickerProps = VPicker.filterProps(props);
          const datePickerControlsProps = VDatePickerControls.filterProps(props);
          const datePickerHeaderProps = VDatePickerHeader.filterProps(props);
          const datePickerMonthProps = VDatePickerMonth.filterProps(props);
          const datePickerMonthsProps = omit$1(VDatePickerMonths.filterProps(props), ["modelValue"]);
          const datePickerYearsProps = omit$1(VDatePickerYears.filterProps(props), ["modelValue"]);
          const headerProps = {
            header: header.value,
            transition: headerTransition.value
          };
          return createVNode(VPicker, mergeProps(pickerProps, {
            "class": ["v-date-picker", `v-date-picker--${viewMode.value}`, {
              "v-date-picker--show-week": props.showWeek
            }, props.class],
            "style": props.style
          }), {
            title: () => {
              var _a2;
              return ((_a2 = slots.title) == null ? void 0 : _a2.call(slots)) ?? createVNode("div", {
                "class": "v-date-picker__title"
              }, [t(props.title)]);
            },
            header: () => slots.header ? createVNode(VDefaultsProvider, {
              "defaults": {
                VDatePickerHeader: {
                  ...headerProps
                }
              }
            }, {
              default: () => {
                var _a2;
                return [(_a2 = slots.header) == null ? void 0 : _a2.call(slots, headerProps)];
              }
            }) : createVNode(VDatePickerHeader, mergeProps({
              "key": "header"
            }, datePickerHeaderProps, headerProps, {
              "onClick": viewMode.value !== "month" ? onClickDate : void 0
            }), {
              ...slots,
              default: void 0
            }),
            default: () => createVNode(Fragment, null, [createVNode(VDatePickerControls, mergeProps(datePickerControlsProps, {
              "disabled": disabled.value,
              "text": text2.value,
              "onClick:next": onClickNext,
              "onClick:prev": onClickPrev,
              "onClick:month": onClickMonth,
              "onClick:year": onClickYear
            }), null), createVNode(VFadeTransition, {
              "hideOnLeave": true
            }, {
              default: () => [viewMode.value === "months" ? createVNode(VDatePickerMonths, mergeProps({
                "key": "date-picker-months"
              }, datePickerMonthsProps, {
                "modelValue": month.value,
                "onUpdate:modelValue": [($event) => month.value = $event, onUpdateMonth],
                "min": minDate.value,
                "max": maxDate.value,
                "year": year.value
              }), null) : viewMode.value === "year" ? createVNode(VDatePickerYears, mergeProps({
                "key": "date-picker-years"
              }, datePickerYearsProps, {
                "modelValue": year.value,
                "onUpdate:modelValue": [($event) => year.value = $event, onUpdateYear],
                "min": minDate.value,
                "max": maxDate.value
              }), null) : createVNode(VDatePickerMonth, mergeProps({
                "key": "date-picker-month"
              }, datePickerMonthProps, {
                "modelValue": model.value,
                "onUpdate:modelValue": ($event) => model.value = $event,
                "month": month.value,
                "onUpdate:month": [($event) => month.value = $event, onUpdateMonth],
                "year": year.value,
                "onUpdate:year": [($event) => year.value = $event, onUpdateYear],
                "min": minDate.value,
                "max": maxDate.value
              }), null)]
            })]),
            actions: slots.actions
          });
        });
        return {};
      }
    });
    const _sfc_main$o = {
      __name: "date-picker",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfDatePickerNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        useDefaults({}, "VjsfDatePicker");
        const props = __props;
        const vDate = useDate();
        const menuOpened = ref$1(false);
        const datePickerProps = computed(() => {
          const datePickerProps2 = getCompProps(props.modelValue, true);
          datePickerProps2.hideActions = true;
          if (props.modelValue.data)
            datePickerProps2.modelValue = new Date(props.modelValue.data);
          datePickerProps2["onUpdate:modelValue"] = (value) => {
            if (!value)
              return;
            if (props.modelValue.layout.format === "date-time") {
              props.statefulLayout.input(props.modelValue, getDateTimeWithOffset(value));
            } else {
              props.statefulLayout.input(props.modelValue, getDateTimeParts(
                /** @type Date */
                /** @type unknown */
                value
              )[0]);
            }
            menuOpened.value = false;
          };
          return datePickerProps2;
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(_sfc_main$p, {
            "menu-opened": menuOpened.value,
            "onUpdate:menuOpened": _cache[0] || (_cache[0] = ($event) => menuOpened.value = $event),
            "model-value": __props.modelValue,
            "stateful-layout": __props.statefulLayout,
            "formatted-value": __props.modelValue.data && unref(vDate).format(__props.modelValue.data, "fullDateWithWeekday")
          }, {
            default: withCtx(() => [
              createVNode(unref(VDatePicker), normalizeProps(guardReactiveProps(datePickerProps.value)), null, 16)
            ]),
            _: 1
          }, 8, ["menu-opened", "model-value", "stateful-layout", "formatted-value"]);
        };
      }
    };
    const makeVTimePickerClockProps = propsFactory({
      allowedValues: Function,
      ampm: Boolean,
      color: String,
      disabled: Boolean,
      displayedValue: null,
      double: Boolean,
      format: {
        type: Function,
        default: (val) => val
      },
      max: {
        type: Number,
        required: true
      },
      min: {
        type: Number,
        required: true
      },
      scrollable: Boolean,
      readonly: Boolean,
      rotate: {
        type: Number,
        default: 0
      },
      step: {
        type: Number,
        default: 1
      },
      modelValue: {
        type: Number
      }
    }, "VTimePickerClock");
    const VTimePickerClock = genericComponent()({
      name: "VTimePickerClock",
      props: makeVTimePickerClockProps(),
      emits: {
        change: (val) => true,
        input: (val) => true
      },
      setup(props, _ref) {
        let {
          emit: emit2
        } = _ref;
        const clockRef = ref$1(null);
        const innerClockRef = ref$1(null);
        const inputValue = ref$1(void 0);
        const isDragging = ref$1(false);
        const valueOnMouseDown = ref$1(null);
        const valueOnMouseUp = ref$1(null);
        const {
          textColorClasses,
          textColorStyles
        } = useTextColor(toRef(props, "color"));
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(toRef(props, "color"));
        const count = computed(() => props.max - props.min + 1);
        const roundCount = computed(() => props.double ? count.value / 2 : count.value);
        const degreesPerUnit = computed(() => 360 / roundCount.value);
        const degrees = computed(() => degreesPerUnit.value * Math.PI / 180);
        const displayedValue = computed(() => props.modelValue == null ? props.min : props.modelValue);
        const innerRadiusScale = computed(() => 0.62);
        const genChildren = computed(() => {
          const children = [];
          for (let value = props.min; value <= props.max; value = value + props.step) {
            children.push(value);
          }
          return children;
        });
        watch(() => props.modelValue, (val) => {
          inputValue.value = val;
        });
        function update(value) {
          if (inputValue.value !== value) {
            inputValue.value = value;
          }
          emit2("input", value);
        }
        function isAllowed(value) {
          return !props.allowedValues || props.allowedValues(value);
        }
        function wheel(e) {
          if (!props.scrollable || props.disabled)
            return;
          e.preventDefault();
          const delta2 = Math.sign(-e.deltaY || 1);
          let value = displayedValue.value;
          do {
            value = value + delta2;
            value = (value - props.min + count.value) % count.value + props.min;
          } while (!isAllowed(value) && value !== displayedValue.value);
          if (value !== props.displayedValue) {
            update(value);
          }
        }
        function isInner(value) {
          return props.double && value - props.min >= roundCount.value;
        }
        function handScale(value) {
          return isInner(value) ? innerRadiusScale.value : 1;
        }
        function getPosition2(value) {
          const rotateRadians = props.rotate * Math.PI / 180;
          return {
            x: Math.sin((value - props.min) * degrees.value + rotateRadians) * handScale(value),
            y: -Math.cos((value - props.min) * degrees.value + rotateRadians) * handScale(value)
          };
        }
        function angleToValue(angle3, insideClick) {
          const value = (Math.round(angle3 / degreesPerUnit.value) + (insideClick ? roundCount.value : 0)) % count.value + props.min;
          if (angle3 < 360 - degreesPerUnit.value / 2)
            return value;
          return insideClick ? props.max - roundCount.value + 1 : props.min;
        }
        function getTransform(i2) {
          const {
            x: x2,
            y
          } = getPosition2(i2);
          return {
            left: `${50 + x2 * 50}%`,
            top: `${50 + y * 50}%`
          };
        }
        function euclidean(p0, p1) {
          const dx = p1.x - p0.x;
          const dy = p1.y - p0.y;
          return Math.sqrt(dx * dx + dy * dy);
        }
        function angle2(center, p1) {
          const value = 2 * Math.atan2(p1.y - center.y - euclidean(center, p1), p1.x - center.x);
          return Math.abs(value * 180 / Math.PI);
        }
        function setMouseDownValue(value) {
          if (valueOnMouseDown.value === null) {
            valueOnMouseDown.value = value;
          }
          valueOnMouseUp.value = value;
          update(value);
        }
        function onDragMove(e) {
          var _a2, _b;
          e.preventDefault();
          if (!isDragging.value && e.type !== "click" || !clockRef.value)
            return;
          const {
            width,
            top: top2,
            left
          } = (_a2 = clockRef.value) == null ? void 0 : _a2.getBoundingClientRect();
          const {
            width: innerWidth
          } = ((_b = innerClockRef.value) == null ? void 0 : _b.getBoundingClientRect()) ?? {
            width: 0
          };
          const {
            clientX,
            clientY
          } = "touches" in e ? e.touches[0] : e;
          const center = {
            x: width / 2,
            y: -width / 2
          };
          const coords = {
            x: clientX - left,
            y: top2 - clientY
          };
          const handAngle = Math.round(angle2(center, coords) - props.rotate + 360) % 360;
          const insideClick = props.double && euclidean(center, coords) < (innerWidth + innerWidth * innerRadiusScale.value) / 4;
          const checksCount = Math.ceil(15 / degreesPerUnit.value);
          let value;
          for (let i2 = 0; i2 < checksCount; i2++) {
            value = angleToValue(handAngle + i2 * degreesPerUnit.value, insideClick);
            if (isAllowed(value))
              return setMouseDownValue(value);
            value = angleToValue(handAngle - i2 * degreesPerUnit.value, insideClick);
            if (isAllowed(value))
              return setMouseDownValue(value);
          }
        }
        function onMouseDown(e) {
          if (props.disabled)
            return;
          e.preventDefault();
          window.addEventListener("mousemove", onDragMove);
          window.addEventListener("touchmove", onDragMove);
          window.addEventListener("mouseup", onMouseUp);
          window.addEventListener("touchend", onMouseUp);
          valueOnMouseDown.value = null;
          valueOnMouseUp.value = null;
          isDragging.value = true;
          onDragMove(e);
        }
        function onMouseUp(e) {
          e.stopPropagation();
          window.removeEventListener("mousemove", onDragMove);
          window.removeEventListener("touchmove", onDragMove);
          window.removeEventListener("mouseup", onMouseUp);
          window.removeEventListener("touchend", onMouseUp);
          isDragging.value = false;
          if (valueOnMouseUp.value !== null && isAllowed(valueOnMouseUp.value)) {
            emit2("change", valueOnMouseUp.value);
          }
        }
        useRender(() => {
          return createVNode("div", {
            "class": [{
              "v-time-picker-clock": true,
              "v-time-picker-clock--indeterminate": props.modelValue == null,
              "v-time-picker-clock--readonly": props.readonly
            }],
            "onMousedown": onMouseDown,
            "onTouchstart": onMouseDown,
            "onWheel": wheel,
            "ref": clockRef
          }, [createVNode("div", {
            "class": "v-time-picker-clock__inner",
            "ref": innerClockRef
          }, [createVNode("div", {
            "class": [{
              "v-time-picker-clock__hand": true,
              "v-time-picker-clock__hand--inner": isInner(props.modelValue)
            }, textColorClasses.value],
            "style": [{
              transform: `rotate(${props.rotate + degreesPerUnit.value * (displayedValue.value - props.min)}deg) scaleY(${handScale(displayedValue.value)})`
            }, textColorStyles.value]
          }, null), genChildren.value.map((value) => {
            const isActive = value === displayedValue.value;
            return createVNode("div", {
              "class": [{
                "v-time-picker-clock__item": true,
                "v-time-picker-clock__item--active": isActive,
                "v-time-picker-clock__item--disabled": props.disabled || !isAllowed(value)
              }, isActive && backgroundColorClasses.value],
              "style": [getTransform(value), isActive && backgroundColorStyles.value]
            }, [createVNode("span", null, [props.format(value)])]);
          })])]);
        });
      }
    });
    const padStart = (string, targetLength, padString) => {
      targetLength = targetLength >> 0;
      string = String(string);
      padString = String(padString);
      if (string.length > targetLength) {
        return String(string);
      }
      targetLength = targetLength - string.length;
      if (targetLength > padString.length) {
        padString += padString.repeat(targetLength / padString.length);
      }
      return padString.slice(0, targetLength) + String(string);
    };
    const pad = function(n) {
      let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
      return padStart(n, length, "0");
    };
    var SelectingTimes = /* @__PURE__ */ function(SelectingTimes2) {
      SelectingTimes2[SelectingTimes2["Hour"] = 1] = "Hour";
      SelectingTimes2[SelectingTimes2["Minute"] = 2] = "Minute";
      SelectingTimes2[SelectingTimes2["Second"] = 3] = "Second";
      return SelectingTimes2;
    }(SelectingTimes || {});
    const makeVTimePickerControlsProps = propsFactory({
      ampm: Boolean,
      ampmInTitle: Boolean,
      ampmReadonly: Boolean,
      color: String,
      disabled: Boolean,
      hour: Number,
      minute: Number,
      second: Number,
      period: String,
      readonly: Boolean,
      useSeconds: Boolean,
      selecting: Number,
      value: Number
    }, "VTimePickerControls");
    const VTimePickerControls = genericComponent()({
      name: "VTimePickerControls",
      props: makeVTimePickerControlsProps(),
      emits: {
        "update:period": (data) => true,
        "update:selecting": (data) => true
      },
      setup(props, _ref) {
        let {
          emit: emit2,
          slots
        } = _ref;
        const {
          t
        } = useLocale();
        useRender(() => {
          let hour = props.hour;
          if (props.ampm) {
            hour = hour ? (hour - 1) % 12 + 1 : 12;
          }
          return createVNode("div", {
            "class": "v-time-picker-controls"
          }, [createVNode("div", {
            "class": {
              "v-time-picker-controls__time": true,
              "v-time-picker-controls__time--with-seconds": props.useSeconds
            }
          }, [createVNode(VBtn, {
            "active": props.selecting === 1,
            "color": props.selecting === 1 ? props.color : void 0,
            "disabled": props.disabled,
            "variant": "tonal",
            "class": {
              "v-time-picker-controls__time__btn": true,
              "v-time-picker-controls__time--with-ampm__btn": props.ampm,
              "v-time-picker-controls__time--with-seconds__btn": props.useSeconds
            },
            "text": props.hour == null ? "--" : pad(`${hour}`),
            "onClick": () => emit2("update:selecting", SelectingTimes.Hour)
          }, null), createVNode("span", {
            "class": ["v-time-picker-controls__time__separator", {
              "v-time-picker-controls--with-seconds__time__separator": props.useSeconds
            }]
          }, [createTextVNode(":")]), createVNode(VBtn, {
            "active": props.selecting === 2,
            "color": props.selecting === 2 ? props.color : void 0,
            "class": {
              "v-time-picker-controls__time__btn": true,
              "v-time-picker-controls__time__btn__active": props.selecting === 2,
              "v-time-picker-controls__time--with-ampm__btn": props.ampm,
              "v-time-picker-controls__time--with-seconds__btn": props.useSeconds
            },
            "disabled": props.disabled,
            "variant": "tonal",
            "text": props.minute == null ? "--" : pad(props.minute),
            "onClick": () => emit2("update:selecting", SelectingTimes.Minute)
          }, null), props.useSeconds && createVNode("span", {
            "class": ["v-time-picker-controls__time__separator", {
              "v-time-picker-controls--with-seconds__time__separator": props.useSeconds
            }],
            "key": "secondsDivider"
          }, [createTextVNode(":")]), props.useSeconds && createVNode(VBtn, {
            "key": "secondsVal",
            "variant": "tonal",
            "onClick": () => emit2("update:selecting", SelectingTimes.Second),
            "class": {
              "v-time-picker-controls__time__btn": true,
              "v-time-picker-controls__time__btn__active": props.selecting === 3,
              "v-time-picker-controls__time--with-seconds__btn": props.useSeconds
            },
            "disabled": props.disabled,
            "text": props.second == null ? "--" : pad(props.second)
          }, null), props.ampm && props.ampmInTitle && createVNode("div", {
            "class": ["v-time-picker-controls__ampm", {
              "v-time-picker-controls__ampm--readonly": props.ampmReadonly
            }]
          }, [createVNode(VBtn, {
            "active": props.period === "am",
            "color": props.period === "am" ? props.color : void 0,
            "class": {
              "v-time-picker-controls__ampm__am": true,
              "v-time-picker-controls__ampm__btn": true,
              "v-time-picker-controls__ampm__btn__active": props.period === "am"
            },
            "disabled": props.disabled,
            "text": t("$vuetify.timePicker.am"),
            "variant": props.disabled && props.period === "am" ? "elevated" : "tonal",
            "onClick": () => props.period !== "am" ? emit2("update:period", "am") : null
          }, null), createVNode(VBtn, {
            "active": props.period === "pm",
            "color": props.period === "pm" ? props.color : void 0,
            "class": {
              "v-time-picker-controls__ampm__pm": true,
              "v-time-picker-controls__ampm__btn": true,
              "v-time-picker-controls__ampm__btn__active": props.period === "pm"
            },
            "disabled": props.disabled,
            "text": t("$vuetify.timePicker.pm"),
            "variant": props.disabled && props.period === "pm" ? "elevated" : "tonal",
            "onClick": () => props.period !== "pm" ? emit2("update:period", "pm") : null
          }, null)])])]);
        });
        return {};
      }
    });
    const rangeHours24 = createRange(24);
    const rangeHours12am = createRange(12);
    const rangeHours12pm = rangeHours12am.map((v) => v + 12);
    const range60 = createRange(60);
    const selectingNames = {
      1: "hour",
      2: "minute",
      3: "second"
    };
    const makeVTimePickerProps = propsFactory({
      allowedHours: [Function, Array],
      allowedMinutes: [Function, Array],
      allowedSeconds: [Function, Array],
      ampmInTitle: Boolean,
      disabled: Boolean,
      format: {
        type: String,
        default: "ampm"
      },
      max: String,
      min: String,
      modelValue: null,
      readonly: Boolean,
      scrollable: Boolean,
      useSeconds: Boolean,
      ...omit$1(makeVPickerProps({
        title: "$vuetify.timePicker.title"
      }), ["landscape"])
    }, "VTimePicker");
    const VTimePicker = genericComponent()({
      name: "VTimePicker",
      props: makeVTimePickerProps(),
      emits: {
        "update:hour": (val) => true,
        "update:minute": (val) => true,
        "update:period": (val) => true,
        "update:second": (val) => true,
        "update:modelValue": (val) => true
      },
      setup(props, _ref) {
        let {
          emit: emit2,
          slots
        } = _ref;
        const {
          t
        } = useLocale();
        const inputHour = ref$1(null);
        const inputMinute = ref$1(null);
        const inputSecond = ref$1(null);
        const lazyInputHour = ref$1(null);
        const lazyInputMinute = ref$1(null);
        const lazyInputSecond = ref$1(null);
        const period2 = ref$1("am");
        const selecting = ref$1(SelectingTimes.Hour);
        const controlsRef = ref$1(null);
        const clockRef = ref$1(null);
        const isAllowedHourCb = computed(() => {
          let cb;
          if (props.allowedHours instanceof Array) {
            cb = (val) => props.allowedHours.includes(val);
          } else {
            cb = props.allowedHours;
          }
          if (!props.min && !props.max)
            return cb;
          const minHour = props.min ? Number(props.min.split(":")[0]) : 0;
          const maxHour = props.max ? Number(props.max.split(":")[0]) : 23;
          return (val) => {
            return val >= minHour * 1 && val <= maxHour * 1 && (!cb || cb(val));
          };
        });
        const isAllowedMinuteCb = computed(() => {
          let cb;
          const isHourAllowed = !isAllowedHourCb.value || inputHour.value === null || isAllowedHourCb.value(inputHour.value);
          if (props.allowedMinutes instanceof Array) {
            cb = (val) => props.allowedMinutes.includes(val);
          } else {
            cb = props.allowedMinutes;
          }
          if (!props.min && !props.max) {
            return isHourAllowed ? cb : () => false;
          }
          const [minHour, minMinute] = props.min ? props.min.split(":").map(Number) : [0, 0];
          const [maxHour, maxMinute] = props.max ? props.max.split(":").map(Number) : [23, 59];
          const minTime = minHour * 60 + minMinute * 1;
          const maxTime = maxHour * 60 + maxMinute * 1;
          return (val) => {
            const time = 60 * inputHour.value + val;
            return time >= minTime && time <= maxTime && isHourAllowed && (!cb || cb(val));
          };
        });
        const isAllowedSecondCb = computed(() => {
          let cb;
          const isHourAllowed = !isAllowedHourCb.value || inputHour.value === null || isAllowedHourCb.value(inputHour.value);
          const isMinuteAllowed = isHourAllowed && (!isAllowedMinuteCb.value || inputMinute.value === null || isAllowedMinuteCb.value(inputMinute.value));
          if (props.allowedSeconds instanceof Array) {
            cb = (val) => props.allowedSeconds.includes(val);
          } else {
            cb = props.allowedSeconds;
          }
          if (!props.min && !props.max) {
            return isMinuteAllowed ? cb : () => false;
          }
          const [minHour, minMinute, minSecond] = props.min ? props.min.split(":").map(Number) : [0, 0, 0];
          const [maxHour, maxMinute, maxSecond] = props.max ? props.max.split(":").map(Number) : [23, 59, 59];
          const minTime = minHour * 3600 + minMinute * 60 + (minSecond || 0) * 1;
          const maxTime = maxHour * 3600 + maxMinute * 60 + (maxSecond || 0) * 1;
          return (val) => {
            const time = 3600 * inputHour.value + 60 * inputMinute.value + val;
            return time >= minTime && time <= maxTime && isMinuteAllowed && (!cb || cb(val));
          };
        });
        const isAmPm = computed(() => {
          return props.format === "ampm";
        });
        watch(() => props.modelValue, (val) => setInputData(val));
        onMounted(() => {
          setInputData(props.modelValue);
        });
        function genValue() {
          if (inputHour.value != null && inputMinute.value != null && (!props.useSeconds || inputSecond.value != null)) {
            return `${pad(inputHour.value)}:${pad(inputMinute.value)}` + (props.useSeconds ? `:${pad(inputSecond.value)}` : "");
          }
          return null;
        }
        function emitValue() {
          const value = genValue();
          if (value !== null)
            emit2("update:modelValue", value);
        }
        function convert24to12(hour) {
          return hour ? (hour - 1) % 12 + 1 : 12;
        }
        function convert12to24(hour, period3) {
          return hour % 12 + (period3 === "pm" ? 12 : 0);
        }
        function setInputData(value) {
          if (value == null || value === "") {
            inputHour.value = null;
            inputMinute.value = null;
            inputSecond.value = null;
          } else if (value instanceof Date) {
            inputHour.value = value.getHours();
            inputMinute.value = value.getMinutes();
            inputSecond.value = value.getSeconds();
          } else {
            const [hour, , minute, , second, period3] = value.trim().toLowerCase().match(/^(\d+):(\d+)(:(\d+))?([ap]m)?$/) || new Array(6);
            inputHour.value = period3 ? convert12to24(parseInt(hour, 10), period3) : parseInt(hour, 10);
            inputMinute.value = parseInt(minute, 10);
            inputSecond.value = parseInt(second || 0, 10);
          }
          period2.value = inputHour.value == null || inputHour.value < 12 ? "am" : "pm";
        }
        function firstAllowed(type2, value) {
          const allowedFn = type2 === "hour" ? isAllowedHourCb.value : type2 === "minute" ? isAllowedMinuteCb.value : isAllowedSecondCb.value;
          if (!allowedFn)
            return value;
          const range2 = type2 === "minute" ? range60 : type2 === "second" ? range60 : isAmPm.value ? value < 12 ? rangeHours12am : rangeHours12pm : rangeHours24;
          const first = range2.find((v) => allowedFn((v + value) % range2.length + range2[0]));
          return ((first || 0) + value) % range2.length + range2[0];
        }
        function setPeriod(val) {
          period2.value = val;
          if (inputHour.value != null) {
            const newHour = inputHour.value + (period2.value === "am" ? -12 : 12);
            inputHour.value = firstAllowed("hour", newHour);
          }
          emit2("update:period", val);
          emitValue();
          return true;
        }
        function onInput(value) {
          if (selecting.value === SelectingTimes.Hour) {
            inputHour.value = isAmPm.value ? convert12to24(value, period2.value) : value;
          } else if (selecting.value === SelectingTimes.Minute) {
            inputMinute.value = value;
          } else {
            inputSecond.value = value;
          }
        }
        function onChange(value) {
          switch (selectingNames[selecting.value]) {
            case "hour":
              emit2("update:hour", value);
              break;
            case "minute":
              emit2("update:minute", value);
              break;
            case "second":
              emit2("update:second", value);
              break;
          }
          const emitChange = selecting.value === (props.useSeconds ? SelectingTimes.Second : SelectingTimes.Minute);
          if (selecting.value === SelectingTimes.Hour) {
            selecting.value = SelectingTimes.Minute;
          } else if (props.useSeconds && selecting.value === SelectingTimes.Minute) {
            selecting.value = SelectingTimes.Second;
          }
          if (inputHour.value === lazyInputHour.value && inputMinute.value === lazyInputMinute.value && (!props.useSeconds || inputSecond.value === lazyInputSecond.value))
            return;
          const time = genValue();
          if (time === null)
            return;
          lazyInputHour.value = inputHour.value;
          lazyInputMinute.value = inputMinute.value;
          props.useSeconds && (lazyInputSecond.value = inputSecond.value);
          emitChange && emitValue();
        }
        useRender(() => {
          const pickerProps = VPicker.filterProps(props);
          const timePickerControlsProps = VTimePickerControls.filterProps(props);
          const timePickerClockProps = VTimePickerClock.filterProps(omit$1(props, ["format", "modelValue", "min", "max"]));
          return createVNode(VPicker, mergeProps(pickerProps, {
            "color": void 0,
            "class": ["v-time-picker", props.class],
            "style": props.style
          }), {
            title: () => {
              var _a2;
              return ((_a2 = slots.title) == null ? void 0 : _a2.call(slots)) ?? createVNode("div", {
                "class": "v-time-picker__title"
              }, [t(props.title)]);
            },
            header: () => createVNode(VTimePickerControls, mergeProps(timePickerControlsProps, {
              "ampm": isAmPm.value || props.ampmInTitle,
              "ampmReadonly": isAmPm.value && !props.ampmInTitle,
              "hour": inputHour.value,
              "minute": inputMinute.value,
              "period": period2.value,
              "second": inputSecond.value,
              "selecting": selecting.value,
              "onUpdate:period": (val) => setPeriod(val),
              "onUpdate:selecting": (value) => selecting.value = value,
              "ref": controlsRef
            }), null),
            default: () => createVNode(VTimePickerClock, mergeProps(timePickerClockProps, {
              "allowedValues": selecting.value === SelectingTimes.Hour ? isAllowedHourCb.value : selecting.value === SelectingTimes.Minute ? isAllowedMinuteCb.value : isAllowedSecondCb.value,
              "double": selecting.value === SelectingTimes.Hour && !isAmPm.value,
              "format": selecting.value === SelectingTimes.Hour ? isAmPm.value ? convert24to12 : (val) => val : (val) => pad(val, 2),
              "max": selecting.value === SelectingTimes.Hour ? isAmPm.value && period2.value === "am" ? 11 : 23 : 59,
              "min": selecting.value === SelectingTimes.Hour && isAmPm.value && period2.value === "pm" ? 12 : 0,
              "size": 20,
              "step": selecting.value === SelectingTimes.Hour ? 1 : 5,
              "modelValue": selecting.value === SelectingTimes.Hour ? inputHour.value : selecting.value === SelectingTimes.Minute ? inputMinute.value : inputSecond.value,
              "onChange": onChange,
              "onInput": onInput,
              "ref": clockRef
            }), null),
            actions: slots.actions
          });
        });
      }
    });
    const _sfc_main$n = {
      __name: "time-picker",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfDatePickerNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        useDefaults({}, "VjsfDatePicker");
        const props = __props;
        const vDate = useDate();
        const timePickerProps = computed(() => {
          const timePickerProps2 = getCompProps(props.modelValue, true);
          timePickerProps2["ampm-in-title"] = true;
          if (props.modelValue.data)
            timePickerProps2.modelValue = getShortTime(props.modelValue.data);
          return timePickerProps2;
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(_sfc_main$p, {
            "model-value": __props.modelValue,
            "stateful-layout": __props.statefulLayout,
            "formatted-value": timePickerProps.value.modelValue && unref(vDate).format("2010-04-13T" + timePickerProps.value.modelValue, "fullTime")
          }, {
            default: withCtx(() => [
              createVNode(unref(VTimePicker), mergeProps(timePickerProps.value, {
                "onUpdate:modelValue": _cache[0] || (_cache[0] = (value) => {
                  __props.statefulLayout.input(__props.modelValue, value && unref(getLongTime)(value));
                })
              }), null, 16)
            ]),
            _: 1
          }, 8, ["model-value", "stateful-layout", "formatted-value"]);
        };
      }
    };
    const _sfc_main$m = {
      __name: "date-time-picker",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfDatePickerNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        useDefaults({}, "VjsfDatePicker");
        const props = __props;
        const vDate = useDate();
        const tab = ref$1("date");
        const menuOpened = ref$1(false);
        watch(menuOpened, () => {
          tab.value = "date";
        });
        const datePickerProps = computed(() => {
          const datePickerProps2 = getCompProps(props.modelValue, false);
          datePickerProps2.hideActions = true;
          if (props.modelValue.data)
            datePickerProps2.modelValue = new Date(props.modelValue.data);
          datePickerProps2["onUpdate:modelValue"] = (value) => {
            if (!value)
              return;
            if (props.modelValue.data) {
              const datePart = value && getDateTimeParts(
                /** @type Date */
                /** @type unknown */
                value
              )[0];
              props.statefulLayout.input(props.modelValue, datePart + props.modelValue.data.slice(10));
            } else {
              props.statefulLayout.input(props.modelValue, getDateTimeWithOffset(value));
            }
            tab.value = "time";
          };
          return datePickerProps2;
        });
        const timePickerProps = computed(() => {
          const timePickerProps2 = getCompProps(props.modelValue, false);
          timePickerProps2["ampm-in-title"] = true;
          if (props.modelValue.data)
            timePickerProps2.modelValue = getShortTime(props.modelValue.data.slice(11));
          timePickerProps2["onUpdate:modelValue"] = (value) => {
            if (!props.modelValue.data)
              return;
            console.log("set time", value, props.modelValue.data.slice(0, 10), props.modelValue.data.slice(15));
            props.statefulLayout.input(props.modelValue, props.modelValue.data.slice(0, 11) + value + props.modelValue.data.slice(16));
          };
          return timePickerProps2;
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(_sfc_main$p, {
            "menu-opened": menuOpened.value,
            "onUpdate:menuOpened": _cache[2] || (_cache[2] = ($event) => menuOpened.value = $event),
            "model-value": __props.modelValue,
            "stateful-layout": __props.statefulLayout,
            "formatted-value": __props.modelValue.data && unref(vDate).format(__props.modelValue.data, "fullDateTime")
          }, {
            default: withCtx(() => [
              createVNode(unref(VSheet), { style: { "width": "328px" } }, {
                default: withCtx(() => [
                  createVNode(unref(VTabs), {
                    modelValue: tab.value,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => tab.value = $event),
                    "align-tabs": "center"
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(VTab), { value: "date" }, {
                        default: withCtx(() => [
                          createVNode(unref(VIcon), null, {
                            default: withCtx(() => [
                              createTextVNode("mdi-calendar")
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      createVNode(unref(VTab), {
                        value: "time",
                        disabled: !__props.modelValue.data
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(VIcon), null, {
                            default: withCtx(() => [
                              createTextVNode("mdi-clock")
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }, 8, ["disabled"])
                    ]),
                    _: 1
                  }, 8, ["modelValue"]),
                  createVNode(unref(VTabsWindow), {
                    modelValue: tab.value,
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => tab.value = $event)
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(VTabsWindowItem), { value: "date" }, {
                        default: withCtx(() => [
                          createVNode(unref(VDatePicker), normalizeProps(guardReactiveProps(datePickerProps.value)), null, 16)
                        ]),
                        _: 1
                      }),
                      createVNode(unref(VTabsWindowItem), { value: "time" }, {
                        default: withCtx(() => [
                          createVNode(unref(VTimePicker), normalizeProps(guardReactiveProps(timePickerProps.value)), null, 16)
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["modelValue"])
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["menu-opened", "model-value", "stateful-layout", "formatted-value"]);
        };
      }
    };
    const makeVColorPickerCanvasProps = propsFactory({
      color: {
        type: Object
      },
      disabled: Boolean,
      dotSize: {
        type: [Number, String],
        default: 10
      },
      height: {
        type: [Number, String],
        default: 150
      },
      width: {
        type: [Number, String],
        default: 300
      },
      ...makeComponentProps()
    }, "VColorPickerCanvas");
    const VColorPickerCanvas = defineComponent({
      name: "VColorPickerCanvas",
      props: makeVColorPickerCanvasProps(),
      emits: {
        "update:color": (color) => true,
        "update:position": (hue) => true
      },
      setup(props, _ref) {
        let {
          emit: emit2
        } = _ref;
        const isInteracting = shallowRef(false);
        const canvasRef = ref$1();
        const canvasWidth = shallowRef(parseFloat(props.width));
        const canvasHeight = shallowRef(parseFloat(props.height));
        const _dotPosition = ref$1({
          x: 0,
          y: 0
        });
        const dotPosition = computed({
          get: () => _dotPosition.value,
          set(val) {
            var _a2, _b;
            if (!canvasRef.value)
              return;
            const {
              x: x2,
              y
            } = val;
            _dotPosition.value = val;
            emit2("update:color", {
              h: ((_a2 = props.color) == null ? void 0 : _a2.h) ?? 0,
              s: clamp(x2, 0, canvasWidth.value) / canvasWidth.value,
              v: 1 - clamp(y, 0, canvasHeight.value) / canvasHeight.value,
              a: ((_b = props.color) == null ? void 0 : _b.a) ?? 1
            });
          }
        });
        const dotStyles = computed(() => {
          const {
            x: x2,
            y
          } = dotPosition.value;
          const radius = parseInt(props.dotSize, 10) / 2;
          return {
            width: convertToUnit(props.dotSize),
            height: convertToUnit(props.dotSize),
            transform: `translate(${convertToUnit(x2 - radius)}, ${convertToUnit(y - radius)})`
          };
        });
        const {
          resizeRef
        } = useResizeObserver$1((entries) => {
          var _a2;
          if (!((_a2 = resizeRef.el) == null ? void 0 : _a2.offsetParent))
            return;
          const {
            width,
            height
          } = entries[0].contentRect;
          canvasWidth.value = width;
          canvasHeight.value = height;
        });
        function updateDotPosition(x2, y, rect2) {
          const {
            left,
            top: top2,
            width,
            height
          } = rect2;
          dotPosition.value = {
            x: clamp(x2 - left, 0, width),
            y: clamp(y - top2, 0, height)
          };
        }
        function handleMouseDown(e) {
          if (e.type === "mousedown") {
            e.preventDefault();
          }
          if (props.disabled)
            return;
          handleMouseMove(e);
          window.addEventListener("mousemove", handleMouseMove);
          window.addEventListener("mouseup", handleMouseUp);
          window.addEventListener("touchmove", handleMouseMove);
          window.addEventListener("touchend", handleMouseUp);
        }
        function handleMouseMove(e) {
          if (props.disabled || !canvasRef.value)
            return;
          isInteracting.value = true;
          const coords = getEventCoordinates(e);
          updateDotPosition(coords.clientX, coords.clientY, canvasRef.value.getBoundingClientRect());
        }
        function handleMouseUp() {
          window.removeEventListener("mousemove", handleMouseMove);
          window.removeEventListener("mouseup", handleMouseUp);
          window.removeEventListener("touchmove", handleMouseMove);
          window.removeEventListener("touchend", handleMouseUp);
        }
        function updateCanvas() {
          var _a2;
          if (!canvasRef.value)
            return;
          const canvas = canvasRef.value;
          const ctx = canvas.getContext("2d");
          if (!ctx)
            return;
          const saturationGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
          saturationGradient.addColorStop(0, "hsla(0, 0%, 100%, 1)");
          saturationGradient.addColorStop(1, `hsla(${((_a2 = props.color) == null ? void 0 : _a2.h) ?? 0}, 100%, 50%, 1)`);
          ctx.fillStyle = saturationGradient;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          const valueGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
          valueGradient.addColorStop(0, "hsla(0, 0%, 0%, 0)");
          valueGradient.addColorStop(1, "hsla(0, 0%, 0%, 1)");
          ctx.fillStyle = valueGradient;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        watch(() => {
          var _a2;
          return (_a2 = props.color) == null ? void 0 : _a2.h;
        }, updateCanvas, {
          immediate: true
        });
        watch(() => [canvasWidth.value, canvasHeight.value], (newVal, oldVal) => {
          updateCanvas();
          _dotPosition.value = {
            x: dotPosition.value.x * newVal[0] / oldVal[0],
            y: dotPosition.value.y * newVal[1] / oldVal[1]
          };
        }, {
          flush: "post"
        });
        watch(() => props.color, () => {
          if (isInteracting.value) {
            isInteracting.value = false;
            return;
          }
          _dotPosition.value = props.color ? {
            x: props.color.s * canvasWidth.value,
            y: (1 - props.color.v) * canvasHeight.value
          } : {
            x: 0,
            y: 0
          };
        }, {
          deep: true,
          immediate: true
        });
        onMounted(() => updateCanvas());
        useRender(() => createVNode("div", {
          "ref": resizeRef,
          "class": ["v-color-picker-canvas", props.class],
          "style": props.style,
          "onMousedown": handleMouseDown,
          "onTouchstartPassive": handleMouseDown
        }, [createVNode("canvas", {
          "ref": canvasRef,
          "width": canvasWidth.value,
          "height": canvasHeight.value
        }, null), props.color && createVNode("div", {
          "class": ["v-color-picker-canvas__dot", {
            "v-color-picker-canvas__dot--disabled": props.disabled
          }],
          "style": dotStyles.value
        }, null)]));
        return {};
      }
    });
    function stripAlpha(color, stripAlpha2) {
      if (stripAlpha2) {
        const {
          a,
          ...rest
        } = color;
        return rest;
      }
      return color;
    }
    function extractColor(color, input) {
      if (input == null || typeof input === "string") {
        const hex2 = HSVtoHex(color);
        if (color.a === 1)
          return hex2.slice(0, 7);
        else
          return hex2;
      }
      if (typeof input === "object") {
        let converted;
        if (has$2(input, ["r", "g", "b"]))
          converted = HSVtoRGB(color);
        else if (has$2(input, ["h", "s", "l"]))
          converted = HSVtoHSL(color);
        else if (has$2(input, ["h", "s", "v"]))
          converted = color;
        return stripAlpha(converted, !has$2(input, ["a"]) && color.a === 1);
      }
      return color;
    }
    const nullColor = {
      h: 0,
      s: 0,
      v: 0,
      a: 1
    };
    const rgba = {
      inputProps: {
        type: "number",
        min: 0
      },
      inputs: [{
        label: "R",
        max: 255,
        step: 1,
        getValue: (c) => Math.round(c.r),
        getColor: (c, v) => ({
          ...c,
          r: Number(v)
        })
      }, {
        label: "G",
        max: 255,
        step: 1,
        getValue: (c) => Math.round(c.g),
        getColor: (c, v) => ({
          ...c,
          g: Number(v)
        })
      }, {
        label: "B",
        max: 255,
        step: 1,
        getValue: (c) => Math.round(c.b),
        getColor: (c, v) => ({
          ...c,
          b: Number(v)
        })
      }, {
        label: "A",
        max: 1,
        step: 0.01,
        getValue: (_ref) => {
          let {
            a
          } = _ref;
          return a != null ? Math.round(a * 100) / 100 : 1;
        },
        getColor: (c, v) => ({
          ...c,
          a: Number(v)
        })
      }],
      to: HSVtoRGB,
      from: RGBtoHSV
    };
    const rgb = {
      ...rgba,
      inputs: (_a = rgba.inputs) == null ? void 0 : _a.slice(0, 3)
    };
    const hsla = {
      inputProps: {
        type: "number",
        min: 0
      },
      inputs: [{
        label: "H",
        max: 360,
        step: 1,
        getValue: (c) => Math.round(c.h),
        getColor: (c, v) => ({
          ...c,
          h: Number(v)
        })
      }, {
        label: "S",
        max: 1,
        step: 0.01,
        getValue: (c) => Math.round(c.s * 100) / 100,
        getColor: (c, v) => ({
          ...c,
          s: Number(v)
        })
      }, {
        label: "L",
        max: 1,
        step: 0.01,
        getValue: (c) => Math.round(c.l * 100) / 100,
        getColor: (c, v) => ({
          ...c,
          l: Number(v)
        })
      }, {
        label: "A",
        max: 1,
        step: 0.01,
        getValue: (_ref2) => {
          let {
            a
          } = _ref2;
          return a != null ? Math.round(a * 100) / 100 : 1;
        },
        getColor: (c, v) => ({
          ...c,
          a: Number(v)
        })
      }],
      to: HSVtoHSL,
      from: HSLtoHSV
    };
    const hsl = {
      ...hsla,
      inputs: hsla.inputs.slice(0, 3)
    };
    const hexa = {
      inputProps: {
        type: "text"
      },
      inputs: [{
        label: "HEXA",
        getValue: (c) => c,
        getColor: (c, v) => v
      }],
      to: HSVtoHex,
      from: HexToHSV
    };
    const hex = {
      ...hexa,
      inputs: [{
        label: "HEX",
        getValue: (c) => c.slice(0, 7),
        getColor: (c, v) => v
      }]
    };
    const modes = {
      rgb,
      rgba,
      hsl,
      hsla,
      hex,
      hexa
    };
    const VColorPickerInput = (_ref) => {
      let {
        label,
        ...rest
      } = _ref;
      return createVNode("div", {
        "class": "v-color-picker-edit__input"
      }, [createVNode("input", rest, null), createVNode("span", null, [label])]);
    };
    const makeVColorPickerEditProps = propsFactory({
      color: Object,
      disabled: Boolean,
      mode: {
        type: String,
        default: "rgba",
        validator: (v) => Object.keys(modes).includes(v)
      },
      modes: {
        type: Array,
        default: () => Object.keys(modes),
        validator: (v) => Array.isArray(v) && v.every((m) => Object.keys(modes).includes(m))
      },
      ...makeComponentProps()
    }, "VColorPickerEdit");
    const VColorPickerEdit = defineComponent({
      name: "VColorPickerEdit",
      props: makeVColorPickerEditProps(),
      emits: {
        "update:color": (color) => true,
        "update:mode": (mode) => true
      },
      setup(props, _ref2) {
        let {
          emit: emit2
        } = _ref2;
        const enabledModes = computed(() => {
          return props.modes.map((key) => ({
            ...modes[key],
            name: key
          }));
        });
        const inputs = computed(() => {
          var _a2;
          const mode = enabledModes.value.find((m) => m.name === props.mode);
          if (!mode)
            return [];
          const color = props.color ? mode.to(props.color) : null;
          return (_a2 = mode.inputs) == null ? void 0 : _a2.map((_ref3) => {
            let {
              getValue,
              getColor,
              ...inputProps
            } = _ref3;
            return {
              ...mode.inputProps,
              ...inputProps,
              disabled: props.disabled,
              value: color && getValue(color),
              onChange: (e) => {
                const target2 = e.target;
                if (!target2)
                  return;
                emit2("update:color", mode.from(getColor(color ?? mode.to(nullColor), target2.value)));
              }
            };
          });
        });
        useRender(() => {
          var _a2;
          return createVNode("div", {
            "class": ["v-color-picker-edit", props.class],
            "style": props.style
          }, [(_a2 = inputs.value) == null ? void 0 : _a2.map((props2) => createVNode(VColorPickerInput, props2, null)), enabledModes.value.length > 1 && createVNode(VBtn, {
            "icon": "$unfold",
            "size": "x-small",
            "variant": "plain",
            "onClick": () => {
              const mi = enabledModes.value.findIndex((m) => m.name === props.mode);
              emit2("update:mode", enabledModes.value[(mi + 1) % enabledModes.value.length].name);
            }
          }, null)]);
        });
        return {};
      }
    });
    const makeVColorPickerPreviewProps = propsFactory({
      color: {
        type: Object
      },
      disabled: Boolean,
      hideAlpha: Boolean,
      ...makeComponentProps()
    }, "VColorPickerPreview");
    const VColorPickerPreview = defineComponent({
      name: "VColorPickerPreview",
      props: makeVColorPickerPreviewProps(),
      emits: {
        "update:color": (color) => true
      },
      setup(props, _ref) {
        let {
          emit: emit2
        } = _ref;
        const abortController = new AbortController();
        onUnmounted(() => abortController.abort());
        async function openEyeDropper() {
          if (!SUPPORTS_EYE_DROPPER)
            return;
          const eyeDropper = new window.EyeDropper();
          try {
            const result = await eyeDropper.open({
              signal: abortController.signal
            });
            const colorHexValue = HexToHSV(result.sRGBHex);
            emit2("update:color", {
              ...props.color ?? nullColor,
              ...colorHexValue
            });
          } catch (e) {
          }
        }
        useRender(() => {
          var _a2, _b;
          return createVNode("div", {
            "class": ["v-color-picker-preview", {
              "v-color-picker-preview--hide-alpha": props.hideAlpha
            }, props.class],
            "style": props.style
          }, [SUPPORTS_EYE_DROPPER && createVNode("div", {
            "class": "v-color-picker-preview__eye-dropper",
            "key": "eyeDropper"
          }, [createVNode(VBtn, {
            "onClick": openEyeDropper,
            "icon": "$eyeDropper",
            "variant": "plain",
            "density": "comfortable"
          }, null)]), createVNode("div", {
            "class": "v-color-picker-preview__dot"
          }, [createVNode("div", {
            "style": {
              background: HSVtoCSS(props.color ?? nullColor)
            }
          }, null)]), createVNode("div", {
            "class": "v-color-picker-preview__sliders"
          }, [createVNode(VSlider, {
            "class": "v-color-picker-preview__track v-color-picker-preview__hue",
            "modelValue": (_a2 = props.color) == null ? void 0 : _a2.h,
            "onUpdate:modelValue": (h2) => emit2("update:color", {
              ...props.color ?? nullColor,
              h: h2
            }),
            "step": 0,
            "min": 0,
            "max": 360,
            "disabled": props.disabled,
            "thumbSize": 14,
            "trackSize": 8,
            "trackFillColor": "white",
            "hideDetails": true
          }, null), !props.hideAlpha && createVNode(VSlider, {
            "class": "v-color-picker-preview__track v-color-picker-preview__alpha",
            "modelValue": ((_b = props.color) == null ? void 0 : _b.a) ?? 1,
            "onUpdate:modelValue": (a) => emit2("update:color", {
              ...props.color ?? nullColor,
              a
            }),
            "step": 1 / 256,
            "min": 0,
            "max": 1,
            "disabled": props.disabled,
            "thumbSize": 14,
            "trackSize": 8,
            "trackFillColor": "white",
            "hideDetails": true
          }, null)])]);
        });
        return {};
      }
    });
    const red = {
      base: "#f44336",
      lighten5: "#ffebee",
      lighten4: "#ffcdd2",
      lighten3: "#ef9a9a",
      lighten2: "#e57373",
      lighten1: "#ef5350",
      darken1: "#e53935",
      darken2: "#d32f2f",
      darken3: "#c62828",
      darken4: "#b71c1c",
      accent1: "#ff8a80",
      accent2: "#ff5252",
      accent3: "#ff1744",
      accent4: "#d50000"
    };
    const pink = {
      base: "#e91e63",
      lighten5: "#fce4ec",
      lighten4: "#f8bbd0",
      lighten3: "#f48fb1",
      lighten2: "#f06292",
      lighten1: "#ec407a",
      darken1: "#d81b60",
      darken2: "#c2185b",
      darken3: "#ad1457",
      darken4: "#880e4f",
      accent1: "#ff80ab",
      accent2: "#ff4081",
      accent3: "#f50057",
      accent4: "#c51162"
    };
    const purple = {
      base: "#9c27b0",
      lighten5: "#f3e5f5",
      lighten4: "#e1bee7",
      lighten3: "#ce93d8",
      lighten2: "#ba68c8",
      lighten1: "#ab47bc",
      darken1: "#8e24aa",
      darken2: "#7b1fa2",
      darken3: "#6a1b9a",
      darken4: "#4a148c",
      accent1: "#ea80fc",
      accent2: "#e040fb",
      accent3: "#d500f9",
      accent4: "#aa00ff"
    };
    const deepPurple = {
      base: "#673ab7",
      lighten5: "#ede7f6",
      lighten4: "#d1c4e9",
      lighten3: "#b39ddb",
      lighten2: "#9575cd",
      lighten1: "#7e57c2",
      darken1: "#5e35b1",
      darken2: "#512da8",
      darken3: "#4527a0",
      darken4: "#311b92",
      accent1: "#b388ff",
      accent2: "#7c4dff",
      accent3: "#651fff",
      accent4: "#6200ea"
    };
    const indigo = {
      base: "#3f51b5",
      lighten5: "#e8eaf6",
      lighten4: "#c5cae9",
      lighten3: "#9fa8da",
      lighten2: "#7986cb",
      lighten1: "#5c6bc0",
      darken1: "#3949ab",
      darken2: "#303f9f",
      darken3: "#283593",
      darken4: "#1a237e",
      accent1: "#8c9eff",
      accent2: "#536dfe",
      accent3: "#3d5afe",
      accent4: "#304ffe"
    };
    const blue = {
      base: "#2196f3",
      lighten5: "#e3f2fd",
      lighten4: "#bbdefb",
      lighten3: "#90caf9",
      lighten2: "#64b5f6",
      lighten1: "#42a5f5",
      darken1: "#1e88e5",
      darken2: "#1976d2",
      darken3: "#1565c0",
      darken4: "#0d47a1",
      accent1: "#82b1ff",
      accent2: "#448aff",
      accent3: "#2979ff",
      accent4: "#2962ff"
    };
    const lightBlue = {
      base: "#03a9f4",
      lighten5: "#e1f5fe",
      lighten4: "#b3e5fc",
      lighten3: "#81d4fa",
      lighten2: "#4fc3f7",
      lighten1: "#29b6f6",
      darken1: "#039be5",
      darken2: "#0288d1",
      darken3: "#0277bd",
      darken4: "#01579b",
      accent1: "#80d8ff",
      accent2: "#40c4ff",
      accent3: "#00b0ff",
      accent4: "#0091ea"
    };
    const cyan = {
      base: "#00bcd4",
      lighten5: "#e0f7fa",
      lighten4: "#b2ebf2",
      lighten3: "#80deea",
      lighten2: "#4dd0e1",
      lighten1: "#26c6da",
      darken1: "#00acc1",
      darken2: "#0097a7",
      darken3: "#00838f",
      darken4: "#006064",
      accent1: "#84ffff",
      accent2: "#18ffff",
      accent3: "#00e5ff",
      accent4: "#00b8d4"
    };
    const teal = {
      base: "#009688",
      lighten5: "#e0f2f1",
      lighten4: "#b2dfdb",
      lighten3: "#80cbc4",
      lighten2: "#4db6ac",
      lighten1: "#26a69a",
      darken1: "#00897b",
      darken2: "#00796b",
      darken3: "#00695c",
      darken4: "#004d40",
      accent1: "#a7ffeb",
      accent2: "#64ffda",
      accent3: "#1de9b6",
      accent4: "#00bfa5"
    };
    const green = {
      base: "#4caf50",
      lighten5: "#e8f5e9",
      lighten4: "#c8e6c9",
      lighten3: "#a5d6a7",
      lighten2: "#81c784",
      lighten1: "#66bb6a",
      darken1: "#43a047",
      darken2: "#388e3c",
      darken3: "#2e7d32",
      darken4: "#1b5e20",
      accent1: "#b9f6ca",
      accent2: "#69f0ae",
      accent3: "#00e676",
      accent4: "#00c853"
    };
    const lightGreen = {
      base: "#8bc34a",
      lighten5: "#f1f8e9",
      lighten4: "#dcedc8",
      lighten3: "#c5e1a5",
      lighten2: "#aed581",
      lighten1: "#9ccc65",
      darken1: "#7cb342",
      darken2: "#689f38",
      darken3: "#558b2f",
      darken4: "#33691e",
      accent1: "#ccff90",
      accent2: "#b2ff59",
      accent3: "#76ff03",
      accent4: "#64dd17"
    };
    const lime = {
      base: "#cddc39",
      lighten5: "#f9fbe7",
      lighten4: "#f0f4c3",
      lighten3: "#e6ee9c",
      lighten2: "#dce775",
      lighten1: "#d4e157",
      darken1: "#c0ca33",
      darken2: "#afb42b",
      darken3: "#9e9d24",
      darken4: "#827717",
      accent1: "#f4ff81",
      accent2: "#eeff41",
      accent3: "#c6ff00",
      accent4: "#aeea00"
    };
    const yellow = {
      base: "#ffeb3b",
      lighten5: "#fffde7",
      lighten4: "#fff9c4",
      lighten3: "#fff59d",
      lighten2: "#fff176",
      lighten1: "#ffee58",
      darken1: "#fdd835",
      darken2: "#fbc02d",
      darken3: "#f9a825",
      darken4: "#f57f17",
      accent1: "#ffff8d",
      accent2: "#ffff00",
      accent3: "#ffea00",
      accent4: "#ffd600"
    };
    const amber = {
      base: "#ffc107",
      lighten5: "#fff8e1",
      lighten4: "#ffecb3",
      lighten3: "#ffe082",
      lighten2: "#ffd54f",
      lighten1: "#ffca28",
      darken1: "#ffb300",
      darken2: "#ffa000",
      darken3: "#ff8f00",
      darken4: "#ff6f00",
      accent1: "#ffe57f",
      accent2: "#ffd740",
      accent3: "#ffc400",
      accent4: "#ffab00"
    };
    const orange = {
      base: "#ff9800",
      lighten5: "#fff3e0",
      lighten4: "#ffe0b2",
      lighten3: "#ffcc80",
      lighten2: "#ffb74d",
      lighten1: "#ffa726",
      darken1: "#fb8c00",
      darken2: "#f57c00",
      darken3: "#ef6c00",
      darken4: "#e65100",
      accent1: "#ffd180",
      accent2: "#ffab40",
      accent3: "#ff9100",
      accent4: "#ff6d00"
    };
    const deepOrange = {
      base: "#ff5722",
      lighten5: "#fbe9e7",
      lighten4: "#ffccbc",
      lighten3: "#ffab91",
      lighten2: "#ff8a65",
      lighten1: "#ff7043",
      darken1: "#f4511e",
      darken2: "#e64a19",
      darken3: "#d84315",
      darken4: "#bf360c",
      accent1: "#ff9e80",
      accent2: "#ff6e40",
      accent3: "#ff3d00",
      accent4: "#dd2c00"
    };
    const brown = {
      base: "#795548",
      lighten5: "#efebe9",
      lighten4: "#d7ccc8",
      lighten3: "#bcaaa4",
      lighten2: "#a1887f",
      lighten1: "#8d6e63",
      darken1: "#6d4c41",
      darken2: "#5d4037",
      darken3: "#4e342e",
      darken4: "#3e2723"
    };
    const blueGrey = {
      base: "#607d8b",
      lighten5: "#eceff1",
      lighten4: "#cfd8dc",
      lighten3: "#b0bec5",
      lighten2: "#90a4ae",
      lighten1: "#78909c",
      darken1: "#546e7a",
      darken2: "#455a64",
      darken3: "#37474f",
      darken4: "#263238"
    };
    const grey = {
      base: "#9e9e9e",
      lighten5: "#fafafa",
      lighten4: "#f5f5f5",
      lighten3: "#eeeeee",
      lighten2: "#e0e0e0",
      lighten1: "#bdbdbd",
      darken1: "#757575",
      darken2: "#616161",
      darken3: "#424242",
      darken4: "#212121"
    };
    const shades = {
      black: "#000000",
      white: "#ffffff",
      transparent: "#ffffff00"
    };
    const colors = {
      red,
      pink,
      purple,
      deepPurple,
      indigo,
      blue,
      lightBlue,
      cyan,
      teal,
      green,
      lightGreen,
      lime,
      yellow,
      amber,
      orange,
      deepOrange,
      brown,
      blueGrey,
      grey,
      shades
    };
    const makeVColorPickerSwatchesProps = propsFactory({
      swatches: {
        type: Array,
        default: () => parseDefaultColors(colors)
      },
      disabled: Boolean,
      color: Object,
      maxHeight: [Number, String],
      ...makeComponentProps()
    }, "VColorPickerSwatches");
    function parseDefaultColors(colors2) {
      return Object.keys(colors2).map((key) => {
        const color = colors2[key];
        return color.base ? [color.base, color.darken4, color.darken3, color.darken2, color.darken1, color.lighten1, color.lighten2, color.lighten3, color.lighten4, color.lighten5] : [color.black, color.white, color.transparent];
      });
    }
    const VColorPickerSwatches = defineComponent({
      name: "VColorPickerSwatches",
      props: makeVColorPickerSwatchesProps(),
      emits: {
        "update:color": (color) => true
      },
      setup(props, _ref) {
        let {
          emit: emit2
        } = _ref;
        useRender(() => createVNode("div", {
          "class": ["v-color-picker-swatches", props.class],
          "style": [{
            maxHeight: convertToUnit(props.maxHeight)
          }, props.style]
        }, [createVNode("div", null, [props.swatches.map((swatch) => createVNode("div", {
          "class": "v-color-picker-swatches__swatch"
        }, [swatch.map((color) => {
          const rgba2 = parseColor(color);
          const hsva = RGBtoHSV(rgba2);
          const background = RGBtoCSS(rgba2);
          return createVNode("div", {
            "class": "v-color-picker-swatches__color",
            "onClick": () => hsva && emit2("update:color", hsva)
          }, [createVNode("div", {
            "style": {
              background
            }
          }, [props.color && deepEqual(props.color, hsva) ? createVNode(VIcon, {
            "size": "x-small",
            "icon": "$success",
            "color": getContrast(color, "#FFFFFF") > 2 ? "white" : "black"
          }, null) : void 0])]);
        })]))])]));
        return {};
      }
    });
    const makeVColorPickerProps = propsFactory({
      canvasHeight: {
        type: [String, Number],
        default: 150
      },
      disabled: Boolean,
      dotSize: {
        type: [Number, String],
        default: 10
      },
      hideCanvas: Boolean,
      hideSliders: Boolean,
      hideInputs: Boolean,
      mode: {
        type: String,
        default: "rgba",
        validator: (v) => Object.keys(modes).includes(v)
      },
      modes: {
        type: Array,
        default: () => Object.keys(modes),
        validator: (v) => Array.isArray(v) && v.every((m) => Object.keys(modes).includes(m))
      },
      showSwatches: Boolean,
      swatches: Array,
      swatchesMaxHeight: {
        type: [Number, String],
        default: 150
      },
      modelValue: {
        type: [Object, String]
      },
      ...omit$1(makeVSheetProps({
        width: 300
      }), ["height", "location", "minHeight", "maxHeight", "minWidth", "maxWidth"])
    }, "VColorPicker");
    const VColorPicker = defineComponent({
      name: "VColorPicker",
      props: makeVColorPickerProps(),
      emits: {
        "update:modelValue": (color) => true,
        "update:mode": (mode) => true
      },
      setup(props) {
        const mode = useProxiedModel(props, "mode");
        const hue = ref$1(null);
        const model = useProxiedModel(props, "modelValue", void 0, (v) => {
          if (v == null || v === "")
            return null;
          let c;
          try {
            c = RGBtoHSV(parseColor(v));
          } catch (err) {
            return null;
          }
          return c;
        }, (v) => {
          if (!v)
            return null;
          return extractColor(v, props.modelValue);
        });
        const currentColor = computed(() => {
          return model.value ? {
            ...model.value,
            h: hue.value ?? model.value.h
          } : null;
        });
        const {
          rtlClasses
        } = useRtl();
        let externalChange = true;
        watch(model, (v) => {
          if (!externalChange) {
            externalChange = true;
            return;
          }
          if (!v)
            return;
          hue.value = v.h;
        }, {
          immediate: true
        });
        const updateColor = (hsva) => {
          externalChange = false;
          hue.value = hsva.h;
          model.value = hsva;
        };
        onMounted(() => {
          if (!props.modes.includes(mode.value))
            mode.value = props.modes[0];
        });
        provideDefaults({
          VSlider: {
            color: void 0,
            trackColor: void 0,
            trackFillColor: void 0
          }
        });
        useRender(() => {
          const sheetProps = VSheet.filterProps(props);
          return createVNode(VSheet, mergeProps({
            "rounded": props.rounded,
            "elevation": props.elevation,
            "theme": props.theme,
            "class": ["v-color-picker", rtlClasses.value, props.class],
            "style": [{
              "--v-color-picker-color-hsv": HSVtoCSS({
                ...currentColor.value ?? nullColor,
                a: 1
              })
            }, props.style]
          }, sheetProps, {
            "maxWidth": props.width
          }), {
            default: () => [!props.hideCanvas && createVNode(VColorPickerCanvas, {
              "key": "canvas",
              "color": currentColor.value,
              "onUpdate:color": updateColor,
              "disabled": props.disabled,
              "dotSize": props.dotSize,
              "width": props.width,
              "height": props.canvasHeight
            }, null), (!props.hideSliders || !props.hideInputs) && createVNode("div", {
              "key": "controls",
              "class": "v-color-picker__controls"
            }, [!props.hideSliders && createVNode(VColorPickerPreview, {
              "key": "preview",
              "color": currentColor.value,
              "onUpdate:color": updateColor,
              "hideAlpha": !mode.value.endsWith("a"),
              "disabled": props.disabled
            }, null), !props.hideInputs && createVNode(VColorPickerEdit, {
              "key": "edit",
              "modes": props.modes,
              "mode": mode.value,
              "onUpdate:mode": (m) => mode.value = m,
              "color": currentColor.value,
              "onUpdate:color": updateColor,
              "disabled": props.disabled
            }, null)]), props.showSwatches && createVNode(VColorPickerSwatches, {
              "key": "swatches",
              "color": currentColor.value,
              "onUpdate:color": updateColor,
              "maxHeight": props.swatchesMaxHeight,
              "swatches": props.swatches,
              "disabled": props.disabled
            }, null)]
          });
        });
        return {};
      }
    });
    const _sfc_main$l = {
      __name: "color-picker",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfColorPickerNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        useDefaults({}, "VjsfColorPicker");
        const props = __props;
        const colorPickerProps = computed(() => {
          const colorPickerProps2 = getCompProps(props.modelValue, true);
          colorPickerProps2.modelValue = props.modelValue.data;
          return colorPickerProps2;
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(_sfc_main$p, {
            "model-value": __props.modelValue,
            "stateful-layout": __props.statefulLayout,
            "formatted-value": __props.modelValue.data
          }, createSlots({
            default: withCtx(() => [
              createVNode(unref(VColorPicker), mergeProps(colorPickerProps.value, {
                "onUpdate:modelValue": _cache[0] || (_cache[0] = (value) => __props.statefulLayout.input(__props.modelValue, value))
              }), null, 16)
            ]),
            _: 2
          }, [
            __props.modelValue.data ? {
              name: "prepend-inner",
              fn: withCtx(() => [
                createBaseVNode("div", {
                  style: normalizeStyle(`height:30px; width: 30px; border-radius: 40px; margin-right:6px; background: ${__props.modelValue.data};`)
                }, null, 4)
              ]),
              key: "0"
            } : void 0
          ]), 1032, ["model-value", "stateful-layout", "formatted-value"]);
        };
      }
    };
    function useGetItems(props) {
      const items2 = shallowRef([]);
      const loading = ref$1(false);
      const search = ref$1("");
      const fetchItems = async () => {
        loading.value = true;
        items2.value = await props.statefulLayout.getItems(props.modelValue, search.value);
        loading.value = false;
      };
      watch(() => props.modelValue.itemsCacheKey, (newValue, oldValue) => {
        if (newValue === oldValue)
          return;
        fetchItems();
      }, { immediate: true });
      watch(search, () => {
        fetchItems();
      });
      const prepareSelectedItem = (selectedItem, itemValue) => {
        let item = selectedItem;
        if (selectedItem === itemValue) {
          try {
            item = props.statefulLayout.prepareSelectItem(props.modelValue, selectedItem);
            if (item.value === void 0)
              item.value = itemValue;
          } catch (e) {
            item = { value: itemValue };
          }
        }
        return item;
      };
      return { items: items2, loading, search, prepareSelectedItem };
    }
    const _sfc_main$k = /* @__PURE__ */ defineComponent$1({
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfSelectNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(props) {
        useDefaults({}, "VjsfSelect");
        const getItems = useGetItems(props);
        const fieldProps = computed(() => {
          const fieldProps2 = getSelectProps(props.modelValue, props.statefulLayout);
          fieldProps2.loading = getItems.loading.value;
          fieldProps2.items = getItems.items.value;
          return fieldProps2;
        });
        return () => h(VSelect, fieldProps.value, getSelectSlots(props.modelValue, props.statefulLayout, getItems));
      }
    });
    const defaultFilter = (value, query, item) => {
      if (value == null || query == null)
        return -1;
      return value.toString().toLocaleLowerCase().indexOf(query.toString().toLocaleLowerCase());
    };
    const makeFilterProps = propsFactory({
      customFilter: Function,
      customKeyFilter: Object,
      filterKeys: [Array, String],
      filterMode: {
        type: String,
        default: "intersection"
      },
      noFilter: Boolean
    }, "filter");
    function filterItems(items2, query, options) {
      var _a2;
      const array = [];
      const filter = (options == null ? void 0 : options.default) ?? defaultFilter;
      const keys2 = (options == null ? void 0 : options.filterKeys) ? wrapInArray(options.filterKeys) : false;
      const customFiltersLength = Object.keys((options == null ? void 0 : options.customKeyFilter) ?? {}).length;
      if (!(items2 == null ? void 0 : items2.length))
        return array;
      loop:
        for (let i2 = 0; i2 < items2.length; i2++) {
          const [item, transformed = item] = wrapInArray(items2[i2]);
          const customMatches = {};
          const defaultMatches = {};
          let match = -1;
          if ((query || customFiltersLength > 0) && !(options == null ? void 0 : options.noFilter)) {
            if (typeof item === "object") {
              const filterKeys = keys2 || Object.keys(transformed);
              for (const key of filterKeys) {
                const value = getPropertyFromItem(transformed, key);
                const keyFilter = (_a2 = options == null ? void 0 : options.customKeyFilter) == null ? void 0 : _a2[key];
                match = keyFilter ? keyFilter(value, query, item) : filter(value, query, item);
                if (match !== -1 && match !== false) {
                  if (keyFilter)
                    customMatches[key] = match;
                  else
                    defaultMatches[key] = match;
                } else if ((options == null ? void 0 : options.filterMode) === "every") {
                  continue loop;
                }
              }
            } else {
              match = filter(item, query, item);
              if (match !== -1 && match !== false) {
                defaultMatches.title = match;
              }
            }
            const defaultMatchesLength = Object.keys(defaultMatches).length;
            const customMatchesLength = Object.keys(customMatches).length;
            if (!defaultMatchesLength && !customMatchesLength)
              continue;
            if ((options == null ? void 0 : options.filterMode) === "union" && customMatchesLength !== customFiltersLength && !defaultMatchesLength)
              continue;
            if ((options == null ? void 0 : options.filterMode) === "intersection" && (customMatchesLength !== customFiltersLength || !defaultMatchesLength))
              continue;
          }
          array.push({
            index: i2,
            matches: {
              ...defaultMatches,
              ...customMatches
            }
          });
        }
      return array;
    }
    function useFilter(props, items2, query, options) {
      const filteredItems = ref$1([]);
      const filteredMatches = ref$1(/* @__PURE__ */ new Map());
      const transformedItems = computed(() => (options == null ? void 0 : options.transform) ? unref(items2).map((item) => [item, options.transform(item)]) : unref(items2));
      watchEffect(() => {
        const _query = typeof query === "function" ? query() : unref(query);
        const strQuery = typeof _query !== "string" && typeof _query !== "number" ? "" : String(_query);
        const results = filterItems(transformedItems.value, strQuery, {
          customKeyFilter: {
            ...props.customKeyFilter,
            ...unref(options == null ? void 0 : options.customKeyFilter)
          },
          default: props.customFilter,
          filterKeys: props.filterKeys,
          filterMode: props.filterMode,
          noFilter: props.noFilter
        });
        const originalItems = unref(items2);
        const _filteredItems = [];
        const _filteredMatches = /* @__PURE__ */ new Map();
        results.forEach((_ref) => {
          let {
            index,
            matches
          } = _ref;
          const item = originalItems[index];
          _filteredItems.push(item);
          _filteredMatches.set(item.value, matches);
        });
        filteredItems.value = _filteredItems;
        filteredMatches.value = _filteredMatches;
      });
      function getMatches(item) {
        return filteredMatches.value.get(item.value);
      }
      return {
        filteredItems,
        filteredMatches,
        getMatches
      };
    }
    function highlightResult$1(text2, matches, length) {
      if (matches == null)
        return text2;
      if (Array.isArray(matches))
        throw new Error("Multiple matches is not implemented");
      return typeof matches === "number" && ~matches ? createVNode(Fragment, null, [createVNode("span", {
        "class": "v-autocomplete__unmask"
      }, [text2.substr(0, matches)]), createVNode("span", {
        "class": "v-autocomplete__mask"
      }, [text2.substr(matches, length)]), createVNode("span", {
        "class": "v-autocomplete__unmask"
      }, [text2.substr(matches + length)])]) : text2;
    }
    const makeVAutocompleteProps = propsFactory({
      autoSelectFirst: {
        type: [Boolean, String]
      },
      clearOnSelect: Boolean,
      search: String,
      ...makeFilterProps({
        filterKeys: ["title"]
      }),
      ...makeSelectProps(),
      ...omit$1(makeVTextFieldProps({
        modelValue: null,
        role: "combobox"
      }), ["validationValue", "dirty", "appendInnerIcon"]),
      ...makeTransitionProps({
        transition: false
      })
    }, "VAutocomplete");
    const VAutocomplete = genericComponent()({
      name: "VAutocomplete",
      props: makeVAutocompleteProps(),
      emits: {
        "update:focused": (focused) => true,
        "update:search": (value) => true,
        "update:modelValue": (value) => true,
        "update:menu": (value) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          t
        } = useLocale();
        const vTextFieldRef = ref$1();
        const isFocused = shallowRef(false);
        const isPristine = shallowRef(true);
        const listHasFocus = shallowRef(false);
        const vMenuRef = ref$1();
        const vVirtualScrollRef = ref$1();
        const _menu = useProxiedModel(props, "menu");
        const menu = computed({
          get: () => _menu.value,
          set: (v) => {
            var _a2;
            if (_menu.value && !v && ((_a2 = vMenuRef.value) == null ? void 0 : _a2.ΨopenChildren))
              return;
            _menu.value = v;
          }
        });
        const selectionIndex = shallowRef(-1);
        const color = computed(() => {
          var _a2;
          return (_a2 = vTextFieldRef.value) == null ? void 0 : _a2.color;
        });
        const label = computed(() => menu.value ? props.closeText : props.openText);
        const {
          items: items2,
          transformIn,
          transformOut
        } = useItems(props);
        const {
          textColorClasses,
          textColorStyles
        } = useTextColor(color);
        const search = useProxiedModel(props, "search", "");
        const model = useProxiedModel(props, "modelValue", [], (v) => transformIn(v === null ? [null] : wrapInArray(v)), (v) => {
          const transformed = transformOut(v);
          return props.multiple ? transformed : transformed[0] ?? null;
        });
        const counterValue = computed(() => {
          return typeof props.counterValue === "function" ? props.counterValue(model.value) : typeof props.counterValue === "number" ? props.counterValue : model.value.length;
        });
        const form = useForm();
        const {
          filteredItems,
          getMatches
        } = useFilter(props, items2, () => isPristine.value ? "" : search.value);
        const displayItems = computed(() => {
          if (props.hideSelected) {
            return filteredItems.value.filter((filteredItem) => !model.value.some((s) => s.value === filteredItem.value));
          }
          return filteredItems.value;
        });
        const hasChips = computed(() => !!(props.chips || slots.chip));
        const hasSelectionSlot = computed(() => hasChips.value || !!slots.selection);
        const selectedValues = computed(() => model.value.map((selection) => selection.props.value));
        const highlightFirst = computed(() => {
          var _a2;
          const selectFirst = props.autoSelectFirst === true || props.autoSelectFirst === "exact" && search.value === ((_a2 = displayItems.value[0]) == null ? void 0 : _a2.title);
          return selectFirst && displayItems.value.length > 0 && !isPristine.value && !listHasFocus.value;
        });
        const menuDisabled = computed(() => props.hideNoData && !displayItems.value.length || props.readonly || (form == null ? void 0 : form.isReadonly.value));
        const listRef = ref$1();
        const {
          onListScroll,
          onListKeydown
        } = useScrolling(listRef, vTextFieldRef);
        function onClear(e) {
          if (props.openOnClear) {
            menu.value = true;
          }
          search.value = "";
        }
        function onMousedownControl() {
          if (menuDisabled.value)
            return;
          menu.value = true;
        }
        function onMousedownMenuIcon(e) {
          if (menuDisabled.value)
            return;
          if (isFocused.value) {
            e.preventDefault();
            e.stopPropagation();
          }
          menu.value = !menu.value;
        }
        function onKeydown(e) {
          var _a2, _b, _c;
          if (props.readonly || (form == null ? void 0 : form.isReadonly.value))
            return;
          const selectionStart = vTextFieldRef.value.selectionStart;
          const length = model.value.length;
          if (selectionIndex.value > -1 || ["Enter", "ArrowDown", "ArrowUp"].includes(e.key)) {
            e.preventDefault();
          }
          if (["Enter", "ArrowDown"].includes(e.key)) {
            menu.value = true;
          }
          if (["Escape"].includes(e.key)) {
            menu.value = false;
          }
          if (highlightFirst.value && ["Enter", "Tab"].includes(e.key) && !model.value.some((_ref2) => {
            let {
              value
            } = _ref2;
            return value === displayItems.value[0].value;
          })) {
            select(displayItems.value[0]);
          }
          if (e.key === "ArrowDown" && highlightFirst.value) {
            (_a2 = listRef.value) == null ? void 0 : _a2.focus("next");
          }
          if (["Backspace", "Delete"].includes(e.key)) {
            if (!props.multiple && hasSelectionSlot.value && model.value.length > 0 && !search.value)
              return select(model.value[0], false);
            if (~selectionIndex.value) {
              const originalSelectionIndex = selectionIndex.value;
              select(model.value[selectionIndex.value], false);
              selectionIndex.value = originalSelectionIndex >= length - 1 ? length - 2 : originalSelectionIndex;
            } else if (e.key === "Backspace" && !search.value) {
              selectionIndex.value = length - 1;
            }
          }
          if (!props.multiple)
            return;
          if (e.key === "ArrowLeft") {
            if (selectionIndex.value < 0 && selectionStart > 0)
              return;
            const prev = selectionIndex.value > -1 ? selectionIndex.value - 1 : length - 1;
            if (model.value[prev]) {
              selectionIndex.value = prev;
            } else {
              selectionIndex.value = -1;
              vTextFieldRef.value.setSelectionRange((_b = search.value) == null ? void 0 : _b.length, (_c = search.value) == null ? void 0 : _c.length);
            }
          }
          if (e.key === "ArrowRight") {
            if (selectionIndex.value < 0)
              return;
            const next2 = selectionIndex.value + 1;
            if (model.value[next2]) {
              selectionIndex.value = next2;
            } else {
              selectionIndex.value = -1;
              vTextFieldRef.value.setSelectionRange(0, 0);
            }
          }
        }
        function onChange(e) {
          if (matchesSelector(vTextFieldRef.value, ":autofill") || matchesSelector(vTextFieldRef.value, ":-webkit-autofill")) {
            const item = items2.value.find((item2) => item2.title === e.target.value);
            if (item) {
              select(item);
            }
          }
        }
        function onAfterLeave() {
          var _a2;
          if (isFocused.value) {
            isPristine.value = true;
            (_a2 = vTextFieldRef.value) == null ? void 0 : _a2.focus();
          }
        }
        function onFocusin(e) {
          isFocused.value = true;
          setTimeout(() => {
            listHasFocus.value = true;
          });
        }
        function onFocusout(e) {
          listHasFocus.value = false;
        }
        function onUpdateModelValue(v) {
          if (v == null || v === "" && !props.multiple && !hasSelectionSlot.value)
            model.value = [];
        }
        const isSelecting = shallowRef(false);
        function select(item) {
          let set2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          if (!item || item.props.disabled)
            return;
          if (props.multiple) {
            const index = model.value.findIndex((selection) => props.valueComparator(selection.value, item.value));
            const add2 = set2 == null ? !~index : set2;
            if (~index) {
              const value = add2 ? [...model.value, item] : [...model.value];
              value.splice(index, 1);
              model.value = value;
            } else if (add2) {
              model.value = [...model.value, item];
            }
            if (props.clearOnSelect) {
              search.value = "";
            }
          } else {
            const add2 = set2 !== false;
            model.value = add2 ? [item] : [];
            search.value = add2 && !hasSelectionSlot.value ? item.title : "";
            nextTick(() => {
              menu.value = false;
              isPristine.value = true;
            });
          }
        }
        watch(isFocused, (val, oldVal) => {
          var _a2;
          if (val === oldVal)
            return;
          if (val) {
            isSelecting.value = true;
            search.value = props.multiple || hasSelectionSlot.value ? "" : String(((_a2 = model.value.at(-1)) == null ? void 0 : _a2.props.title) ?? "");
            isPristine.value = true;
            nextTick(() => isSelecting.value = false);
          } else {
            if (!props.multiple && search.value == null)
              model.value = [];
            menu.value = false;
            if (!model.value.some((_ref3) => {
              let {
                title: title2
              } = _ref3;
              return title2 === search.value;
            }))
              search.value = "";
            selectionIndex.value = -1;
          }
        });
        watch(search, (val) => {
          if (!isFocused.value || isSelecting.value)
            return;
          if (val)
            menu.value = true;
          isPristine.value = !val;
        });
        watch(menu, () => {
          if (!props.hideSelected && menu.value && model.value.length) {
            const index = displayItems.value.findIndex((item) => model.value.some((s) => item.value === s.value));
            IN_BROWSER && window.requestAnimationFrame(() => {
              var _a2;
              index >= 0 && ((_a2 = vVirtualScrollRef.value) == null ? void 0 : _a2.scrollToIndex(index));
            });
          }
        });
        watch(() => props.items, (newVal, oldVal) => {
          if (menu.value)
            return;
          if (isFocused.value && !oldVal.length && newVal.length) {
            menu.value = true;
          }
        });
        useRender(() => {
          const hasList = !!(!props.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
          const isDirty = model.value.length > 0;
          const textFieldProps = VTextField.filterProps(props);
          return createVNode(VTextField, mergeProps({
            "ref": vTextFieldRef
          }, textFieldProps, {
            "modelValue": search.value,
            "onUpdate:modelValue": [($event) => search.value = $event, onUpdateModelValue],
            "focused": isFocused.value,
            "onUpdate:focused": ($event) => isFocused.value = $event,
            "validationValue": model.externalValue,
            "counterValue": counterValue.value,
            "dirty": isDirty,
            "onChange": onChange,
            "class": ["v-autocomplete", `v-autocomplete--${props.multiple ? "multiple" : "single"}`, {
              "v-autocomplete--active-menu": menu.value,
              "v-autocomplete--chips": !!props.chips,
              "v-autocomplete--selection-slot": !!hasSelectionSlot.value,
              "v-autocomplete--selecting-index": selectionIndex.value > -1
            }, props.class],
            "style": props.style,
            "readonly": props.readonly,
            "placeholder": isDirty ? void 0 : props.placeholder,
            "onClick:clear": onClear,
            "onMousedown:control": onMousedownControl,
            "onKeydown": onKeydown
          }), {
            ...slots,
            default: () => createVNode(Fragment, null, [createVNode(VMenu, mergeProps({
              "ref": vMenuRef,
              "modelValue": menu.value,
              "onUpdate:modelValue": ($event) => menu.value = $event,
              "activator": "parent",
              "contentClass": "v-autocomplete__content",
              "disabled": menuDisabled.value,
              "eager": props.eager,
              "maxHeight": 310,
              "openOnClick": false,
              "closeOnContentClick": false,
              "transition": props.transition,
              "onAfterLeave": onAfterLeave
            }, props.menuProps), {
              default: () => [hasList && createVNode(VList, mergeProps({
                "ref": listRef,
                "selected": selectedValues.value,
                "selectStrategy": props.multiple ? "independent" : "single-independent",
                "onMousedown": (e) => e.preventDefault(),
                "onKeydown": onListKeydown,
                "onFocusin": onFocusin,
                "onFocusout": onFocusout,
                "onScrollPassive": onListScroll,
                "tabindex": "-1",
                "aria-live": "polite",
                "color": props.itemColor ?? props.color
              }, props.listProps), {
                default: () => {
                  var _a2, _b, _c;
                  return [(_a2 = slots["prepend-item"]) == null ? void 0 : _a2.call(slots), !displayItems.value.length && !props.hideNoData && (((_b = slots["no-data"]) == null ? void 0 : _b.call(slots)) ?? createVNode(VListItem, {
                    "title": t(props.noDataText)
                  }, null)), createVNode(VVirtualScroll, {
                    "ref": vVirtualScrollRef,
                    "renderless": true,
                    "items": displayItems.value
                  }, {
                    default: (_ref4) => {
                      var _a3;
                      let {
                        item,
                        index,
                        itemRef
                      } = _ref4;
                      const itemProps = mergeProps(item.props, {
                        ref: itemRef,
                        key: index,
                        active: highlightFirst.value && index === 0 ? true : void 0,
                        onClick: () => select(item, null)
                      });
                      return ((_a3 = slots.item) == null ? void 0 : _a3.call(slots, {
                        item,
                        index,
                        props: itemProps
                      })) ?? createVNode(VListItem, mergeProps(itemProps, {
                        "role": "option"
                      }), {
                        prepend: (_ref5) => {
                          let {
                            isSelected
                          } = _ref5;
                          return createVNode(Fragment, null, [props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                            "key": item.value,
                            "modelValue": isSelected,
                            "ripple": false,
                            "tabindex": "-1"
                          }, null) : void 0, item.props.prependAvatar && createVNode(VAvatar, {
                            "image": item.props.prependAvatar
                          }, null), item.props.prependIcon && createVNode(VIcon, {
                            "icon": item.props.prependIcon
                          }, null)]);
                        },
                        title: () => {
                          var _a4, _b2;
                          return isPristine.value ? item.title : highlightResult$1(item.title, (_a4 = getMatches(item)) == null ? void 0 : _a4.title, ((_b2 = search.value) == null ? void 0 : _b2.length) ?? 0);
                        }
                      });
                    }
                  }), (_c = slots["append-item"]) == null ? void 0 : _c.call(slots)];
                }
              })]
            }), model.value.map((item, index) => {
              function onChipClose(e) {
                e.stopPropagation();
                e.preventDefault();
                select(item, false);
              }
              const slotProps = {
                "onClick:close": onChipClose,
                onKeydown(e) {
                  if (e.key !== "Enter" && e.key !== " ")
                    return;
                  e.preventDefault();
                  e.stopPropagation();
                  onChipClose(e);
                },
                onMousedown(e) {
                  e.preventDefault();
                  e.stopPropagation();
                },
                modelValue: true,
                "onUpdate:modelValue": void 0
              };
              const hasSlot = hasChips.value ? !!slots.chip : !!slots.selection;
              const slotContent = hasSlot ? ensureValidVNode(hasChips.value ? slots.chip({
                item,
                index,
                props: slotProps
              }) : slots.selection({
                item,
                index
              })) : void 0;
              if (hasSlot && !slotContent)
                return void 0;
              return createVNode("div", {
                "key": item.value,
                "class": ["v-autocomplete__selection", index === selectionIndex.value && ["v-autocomplete__selection--selected", textColorClasses.value]],
                "style": index === selectionIndex.value ? textColorStyles.value : {}
              }, [hasChips.value ? !slots.chip ? createVNode(VChip, mergeProps({
                "key": "chip",
                "closable": props.closableChips,
                "size": "small",
                "text": item.title,
                "disabled": item.props.disabled
              }, slotProps), null) : createVNode(VDefaultsProvider, {
                "key": "chip-defaults",
                "defaults": {
                  VChip: {
                    closable: props.closableChips,
                    size: "small",
                    text: item.title
                  }
                }
              }, {
                default: () => [slotContent]
              }) : slotContent ?? createVNode("span", {
                "class": "v-autocomplete__selection-text"
              }, [item.title, props.multiple && index < model.value.length - 1 && createVNode("span", {
                "class": "v-autocomplete__selection-comma"
              }, [createTextVNode(",")])])]);
            })]),
            "append-inner": function() {
              var _a2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return createVNode(Fragment, null, [(_a2 = slots["append-inner"]) == null ? void 0 : _a2.call(slots, ...args), props.menuIcon ? createVNode(VIcon, {
                "class": "v-autocomplete__menu-icon",
                "icon": props.menuIcon,
                "onMousedown": onMousedownMenuIcon,
                "onClick": noop$1,
                "aria-label": t(label.value),
                "title": t(label.value),
                "tabindex": "-1"
              }, null) : void 0]);
            }
          });
        });
        return forwardRefs({
          isFocused,
          isPristine,
          menu,
          search,
          filteredItems,
          select
        }, vTextFieldRef);
      }
    });
    const _sfc_main$j = /* @__PURE__ */ defineComponent$1({
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfSelectNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(props) {
        useDefaults({}, "VjsfAutocomplete");
        const getItems = useGetItems(props);
        const fieldProps = computed(() => {
          const fieldProps2 = getSelectProps(props.modelValue, props.statefulLayout);
          fieldProps2.noFilter = true;
          fieldProps2["onUpdate:search"] = (searchValue) => {
            getItems.search.value = searchValue;
          };
          fieldProps2.items = getItems.items.value;
          fieldProps2.loading = getItems.loading.value;
          return fieldProps2;
        });
        return () => h(VAutocomplete, fieldProps.value, getSelectSlots(props.modelValue, props.statefulLayout, getItems));
      }
    });
    const makeVRadioProps = propsFactory({
      ...makeVSelectionControlProps({
        falseIcon: "$radioOff",
        trueIcon: "$radioOn"
      })
    }, "VRadio");
    const VRadio = genericComponent()({
      name: "VRadio",
      props: makeVRadioProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        useRender(() => {
          const controlProps = VSelectionControl.filterProps(props);
          return createVNode(VSelectionControl, mergeProps(controlProps, {
            "class": ["v-radio", props.class],
            "style": props.style,
            "type": "radio"
          }), slots);
        });
        return {};
      }
    });
    const makeVRadioGroupProps = propsFactory({
      height: {
        type: [Number, String],
        default: "auto"
      },
      ...makeVInputProps(),
      ...omit$1(makeSelectionControlGroupProps(), ["multiple"]),
      trueIcon: {
        type: IconValue,
        default: "$radioOn"
      },
      falseIcon: {
        type: IconValue,
        default: "$radioOff"
      },
      type: {
        type: String,
        default: "radio"
      }
    }, "VRadioGroup");
    const VRadioGroup = genericComponent()({
      name: "VRadioGroup",
      inheritAttrs: false,
      props: makeVRadioGroupProps(),
      emits: {
        "update:modelValue": (value) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          slots
        } = _ref;
        const uid2 = getUid();
        const id2 = computed(() => props.id || `radio-group-${uid2}`);
        const model = useProxiedModel(props, "modelValue");
        useRender(() => {
          const [rootAttrs, controlAttrs] = filterInputAttrs(attrs);
          const inputProps = VInput.filterProps(props);
          const controlProps = VSelectionControl.filterProps(props);
          const label = slots.label ? slots.label({
            label: props.label,
            props: {
              for: id2.value
            }
          }) : props.label;
          return createVNode(VInput, mergeProps({
            "class": ["v-radio-group", props.class],
            "style": props.style
          }, rootAttrs, inputProps, {
            "modelValue": model.value,
            "onUpdate:modelValue": ($event) => model.value = $event,
            "id": id2.value
          }), {
            ...slots,
            default: (_ref2) => {
              let {
                id: id3,
                messagesId,
                isDisabled,
                isReadonly: isReadonly2
              } = _ref2;
              return createVNode(Fragment, null, [label && createVNode(VLabel, {
                "id": id3.value
              }, {
                default: () => [label]
              }), createVNode(VSelectionControlGroup, mergeProps(controlProps, {
                "id": id3.value,
                "aria-describedby": messagesId.value,
                "defaultsTarget": "VRadio",
                "trueIcon": props.trueIcon,
                "falseIcon": props.falseIcon,
                "type": props.type,
                "disabled": isDisabled.value,
                "readonly": isReadonly2.value,
                "aria-labelledby": label ? id3.value : void 0,
                "multiple": false
              }, controlAttrs, {
                "modelValue": model.value,
                "onUpdate:modelValue": ($event) => model.value = $event
              }), slots)]);
            }
          });
        });
        return {};
      }
    });
    const rootTypes = {
      actions: "button@2",
      article: "heading, paragraph",
      avatar: "avatar",
      button: "button",
      card: "image, heading",
      "card-avatar": "image, list-item-avatar",
      chip: "chip",
      "date-picker": "list-item, heading, divider, date-picker-options, date-picker-days, actions",
      "date-picker-options": "text, avatar@2",
      "date-picker-days": "avatar@28",
      divider: "divider",
      heading: "heading",
      image: "image",
      "list-item": "text",
      "list-item-avatar": "avatar, text",
      "list-item-two-line": "sentences",
      "list-item-avatar-two-line": "avatar, sentences",
      "list-item-three-line": "paragraph",
      "list-item-avatar-three-line": "avatar, paragraph",
      ossein: "ossein",
      paragraph: "text@3",
      sentences: "text@2",
      subtitle: "text",
      table: "table-heading, table-thead, table-tbody, table-tfoot",
      "table-heading": "chip, text",
      "table-thead": "heading@6",
      "table-tbody": "table-row-divider@6",
      "table-row-divider": "table-row, divider",
      "table-row": "text@6",
      "table-tfoot": "text@2, avatar@2",
      text: "text"
    };
    function genBone(type2) {
      let children = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      return createVNode("div", {
        "class": ["v-skeleton-loader__bone", `v-skeleton-loader__${type2}`]
      }, [children]);
    }
    function genBones(bone) {
      const [type2, length] = bone.split("@");
      return Array.from({
        length
      }).map(() => genStructure(type2));
    }
    function genStructure(type2) {
      let children = [];
      if (!type2)
        return children;
      const bone = rootTypes[type2];
      if (type2 === bone)
        ;
      else if (type2.includes(","))
        return mapBones(type2);
      else if (type2.includes("@"))
        return genBones(type2);
      else if (bone.includes(","))
        children = mapBones(bone);
      else if (bone.includes("@"))
        children = genBones(bone);
      else if (bone)
        children.push(genStructure(bone));
      return [genBone(type2, children)];
    }
    function mapBones(bones) {
      return bones.replace(/\s/g, "").split(",").map(genStructure);
    }
    const makeVSkeletonLoaderProps = propsFactory({
      boilerplate: Boolean,
      color: String,
      loading: Boolean,
      loadingText: {
        type: String,
        default: "$vuetify.loading"
      },
      type: {
        type: [String, Array],
        default: "ossein"
      },
      ...makeDimensionProps(),
      ...makeElevationProps(),
      ...makeThemeProps()
    }, "VSkeletonLoader");
    const VSkeletonLoader = genericComponent()({
      name: "VSkeletonLoader",
      props: makeVSkeletonLoaderProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          backgroundColorClasses,
          backgroundColorStyles
        } = useBackgroundColor(toRef(props, "color"));
        const {
          dimensionStyles
        } = useDimension(props);
        const {
          elevationClasses
        } = useElevation(props);
        const {
          themeClasses
        } = provideTheme(props);
        const {
          t
        } = useLocale();
        const items2 = computed(() => genStructure(wrapInArray(props.type).join(",")));
        useRender(() => {
          var _a2;
          const isLoading = !slots.default || props.loading;
          const loadingProps = props.boilerplate || !isLoading ? {} : {
            ariaLive: "polite",
            ariaLabel: t(props.loadingText),
            role: "alert"
          };
          return createVNode("div", mergeProps({
            "class": ["v-skeleton-loader", {
              "v-skeleton-loader--boilerplate": props.boilerplate
            }, themeClasses.value, backgroundColorClasses.value, elevationClasses.value],
            "style": [backgroundColorStyles.value, isLoading ? dimensionStyles.value : {}]
          }, loadingProps), [isLoading ? items2.value : (_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
        });
        return {};
      }
    });
    const _sfc_main$i = /* @__PURE__ */ defineComponent$1({
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfRadioGroupNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(props) {
        useDefaults({}, "VjsfRadioGroup");
        const getItems = useGetItems(props);
        const fieldProps = computed(() => {
          const fieldProps2 = getInputProps(props.modelValue, props.statefulLayout);
          return fieldProps2;
        });
        const fieldSlots = computed(() => {
          const slots = getCompSlots(props.modelValue, props.statefulLayout);
          const children = [];
          if (getItems.loading.value) {
            children.push(h(VSkeletonLoader, { type: "chip" }));
          } else {
            for (const item of getItems.items.value) {
              children.push(h(VRadio, { label: item.title, value: item.value }));
            }
          }
          slots.default = () => children;
          return slots;
        });
        return () => {
          return h(VRadioGroup, fieldProps.value, fieldSlots.value);
        };
      }
    });
    const _sfc_main$h = /* @__PURE__ */ defineComponent$1({
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfCheckboxGroupNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        },
        type: {
          type: String,
          required: true
        }
      },
      setup(props) {
        const getItems = useGetItems(props);
        const fieldProps = computed(() => {
          const fieldProps2 = getInputProps(props.modelValue, props.statefulLayout);
          fieldProps2.class.push("v-radio-group");
          fieldProps2.class.push("vjsf-selection-group");
          return fieldProps2;
        });
        const fieldSlots = computed(() => {
          const slots = getCompSlots(props.modelValue, props.statefulLayout);
          if (!slots.default) {
            slots.default = () => {
              var _a2;
              const children = [h(VLabel, { text: fieldProps.value.label })];
              if (getItems.loading.value) {
                children.push(h(VSkeletonLoader, { type: "chip" }));
              } else {
                const checkboxes = [];
                for (const item of getItems.items.value) {
                  let modelValue = false;
                  if (props.modelValue.layout.multiple) {
                    modelValue = (_a2 = props.modelValue.data) == null ? void 0 : _a2.includes(item.value);
                  } else {
                    modelValue = props.modelValue.data === item.value;
                  }
                  checkboxes.push(h(props.type === "switch" ? VSwitch : VCheckbox, {
                    label: item.title,
                    hideDetails: true,
                    key: item.key,
                    modelValue,
                    onClick: () => {
                      let newValue;
                      if (props.modelValue.layout.multiple) {
                        newValue = props.modelValue.data ? [...props.modelValue.data] : [];
                        if (newValue.includes(item.value)) {
                          newValue = newValue.filter((v) => v !== item.value);
                        } else {
                          newValue.push(item.value);
                        }
                      } else {
                        if (props.modelValue.data === item.value) {
                          newValue = void 0;
                        } else {
                          newValue = item.value;
                        }
                      }
                      props.statefulLayout.input(props.modelValue, newValue);
                    }
                  }));
                }
                children.push(h("div", { class: "v-selection-control-group" }, checkboxes));
              }
              return children;
            };
          }
          return slots;
        });
        return () => {
          return h(VInput, fieldProps.value, fieldSlots.value);
        };
      }
    });
    const _sfc_main$g = /* @__PURE__ */ defineComponent$1({
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfCheckboxGroupNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(props) {
        useDefaults({}, "VjsfCheckboxGroup");
        return () => {
          return h(_sfc_main$h, {
            modelValue: props.modelValue,
            statefulLayout: props.statefulLayout,
            type: "checkbox"
          });
        };
      }
    });
    const _sfc_main$f = /* @__PURE__ */ defineComponent$1({
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfCheckboxGroupNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(props) {
        useDefaults({}, "VjsfSwitchGroup");
        return () => {
          return h(_sfc_main$h, {
            modelValue: props.modelValue,
            statefulLayout: props.statefulLayout,
            type: "switch"
          });
        };
      }
    });
    const _sfc_main$e = {
      __name: "one-of-select",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfOneOfSelectNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        useDefaults({}, "VjsfOneOfSelect");
        const props = __props;
        const activeChildTree = ref$1(void 0);
        watch(() => props.modelValue, () => {
          var _a2, _b;
          if (((_a2 = props.modelValue.children) == null ? void 0 : _a2.length) === 1) {
            if (typeof props.modelValue.children[0].key === "number") {
              activeChildTree.value = (_b = props.modelValue.skeleton.childrenTrees) == null ? void 0 : _b[props.modelValue.children[0].key];
            }
          } else {
            activeChildTree.value = void 0;
          }
        }, { immediate: true });
        const onChange = (childTree) => {
          if (!props.modelValue.skeleton.childrenTrees)
            return;
          props.statefulLayout.activateItem(props.modelValue, props.modelValue.skeleton.childrenTrees.indexOf(childTree));
        };
        const fieldProps = computed(() => {
          const fieldProps2 = getInputProps(props.modelValue, props.statefulLayout);
          fieldProps2.modelValue = activeChildTree.value;
          fieldProps2["onUpdate:modelValue"] = onChange;
          const items2 = [];
          for (const childTreePointer of props.modelValue.skeleton.childrenTrees || []) {
            const childTree = props.statefulLayout.compiledLayout.skeletonTrees[childTreePointer];
            const childLayout = props.statefulLayout.compiledLayout.normalizedLayouts[childTree.root];
            if (!isCompObject(childLayout) || !childLayout.if || !!props.statefulLayout.evalNodeExpression(props.modelValue, childLayout.if, props.modelValue.data)) {
              items2.push(childTree);
            }
          }
          fieldProps2.items = items2;
          fieldProps2.itemTitle = "title";
          fieldProps2.itemValue = (childTree) => childTree.root;
          return fieldProps2;
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(VRow), null, {
            default: withCtx(() => {
              var _a2, _b, _c;
              return [
                __props.modelValue.skeleton.childrenTrees ? (openBlock(), createBlock(unref(VCol), { key: 0 }, {
                  default: withCtx(() => [
                    createVNode(unref(VSelect), normalizeProps(guardReactiveProps(fieldProps.value)), null, 16)
                  ]),
                  _: 1
                })) : createCommentVNode("", true),
                ((_a2 = __props.modelValue.children) == null ? void 0 : _a2[0]) ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(unref(isSection)((_b = __props.modelValue.children) == null ? void 0 : _b[0]) ? (_c = __props.modelValue.children) == null ? void 0 : _c[0].children : __props.modelValue.children, (grandChild) => {
                  return openBlock(), createBlock(_sfc_main$C, {
                    key: grandChild.fullKey,
                    "model-value": (
                      /** @type import('../../types.js').VjsfNode */
                      grandChild
                    ),
                    "stateful-layout": __props.statefulLayout
                  }, null, 8, ["model-value", "stateful-layout"]);
                }), 128)) : createCommentVNode("", true)
              ];
            }),
            _: 1
          });
        };
      }
    };
    const _hoisted_1$3 = ["innerHTML"];
    const _sfc_main$d = {
      __name: "child-subtitle",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('@json-layout/core').StateNode> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        const { modelValue } = __props;
        const pClass = computed(() => {
          if (modelValue.options.density === "default")
            return "mt-1 mb-5";
          if (modelValue.options.density === "comfortable")
            return "mb-4";
          return "mb-3";
        });
        return (_ctx, _cache) => {
          return unref(isSection)(__props.modelValue) && __props.modelValue.layout.subtitle ? (openBlock(), createElementBlock("p", {
            key: 0,
            class: normalizeClass(`text-subtitle ${pClass.value}`),
            innerHTML: __props.modelValue.layout.subtitle
          }, null, 10, _hoisted_1$3)) : createCommentVNode("", true);
        };
      }
    };
    function useCompDefaultProps(name, localDefaults = null) {
      const defaults2 = inject$1(Symbol.for("vuetify:defaults"));
      if (!defaults2)
        throw new Error("[vjsf] Could not find defaults instance");
      return computed(() => {
        var _a2;
        const componentDefaults = ((_a2 = defaults2.value) == null ? void 0 : _a2[name]) ?? {};
        if (!localDefaults)
          return componentDefaults;
        return { ...componentDefaults, ...localDefaults };
      });
    }
    const _sfc_main$c = {
      __name: "tabs",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfTabsNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        useDefaults({}, "VjsfTabs");
        const vSheetProps = useCompDefaultProps("VjsfTabs-VSheet", { border: true });
        const tab = ref$1(0);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock(Fragment, null, [
            createVNode(_sfc_main$A, { node: __props.modelValue }, null, 8, ["node"]),
            createVNode(unref(VSheet), normalizeProps(guardReactiveProps(unref(vSheetProps))), {
              default: withCtx(() => [
                createVNode(unref(VTabs), {
                  modelValue: tab.value,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => tab.value = $event),
                  direction: "horizontal"
                }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(__props.modelValue.children, (child, i2) => {
                      return openBlock(), createBlock(unref(VTab), {
                        key: child.key,
                        value: i2,
                        color: child.validated && (child.error || child.childError) ? "error" : void 0
                      }, {
                        default: withCtx(() => [
                          child.validated && (child.error || child.childError) ? (openBlock(), createBlock(unref(VIcon), {
                            key: 0,
                            color: "error"
                          }, {
                            default: withCtx(() => [
                              createTextVNode(" mdi-alert ")
                            ]),
                            _: 1
                          })) : createCommentVNode("", true),
                          createTextVNode(" " + toDisplayString(child.layout.title ?? child.layout.label), 1)
                        ]),
                        _: 2
                      }, 1032, ["value", "color"]);
                    }), 128))
                  ]),
                  _: 1
                }, 8, ["modelValue"]),
                createVNode(unref(VWindow), {
                  modelValue: tab.value,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => tab.value = $event)
                }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(__props.modelValue.children, (child, i2) => {
                      return openBlock(), createBlock(unref(VWindowItem), {
                        key: child.key,
                        value: i2
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(VContainer), { fluid: "" }, {
                            default: withCtx(() => {
                              var _a2, _b;
                              return [
                                createVNode(_sfc_main$d, { "model-value": child }, null, 8, ["model-value"]),
                                createVNode(unref(VRow), {
                                  dense: ((_a2 = __props.modelValue.options) == null ? void 0 : _a2.density) === "compact" || ((_b = __props.modelValue.options) == null ? void 0 : _b.density) === "comfortable"
                                }, {
                                  default: withCtx(() => [
                                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(isSection)(child) ? child.children : [child], (grandChild) => {
                                      return openBlock(), createBlock(_sfc_main$C, {
                                        key: grandChild.fullKey,
                                        "model-value": (
                                          /** @type import('../../types.js').VjsfNode */
                                          grandChild
                                        ),
                                        "stateful-layout": __props.statefulLayout
                                      }, null, 8, ["model-value", "stateful-layout"]);
                                    }), 128))
                                  ]),
                                  _: 2
                                }, 1032, ["dense"])
                              ];
                            }),
                            _: 2
                          }, 1024)
                        ]),
                        _: 2
                      }, 1032, ["value"]);
                    }), 128))
                  ]),
                  _: 1
                }, 8, ["modelValue"])
              ]),
              _: 1
            }, 16)
          ], 64);
        };
      }
    };
    const _hoisted_1$2 = { class: "d-flex flex-row" };
    const _sfc_main$b = {
      __name: "vertical-tabs",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfVerticalTabsNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        useDefaults({}, "VjsfVerticalTabs");
        const vSheetProps = useCompDefaultProps("VjsfVerticalTabs-VSheet", { border: true });
        const tab = ref$1(0);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock(Fragment, null, [
            createVNode(_sfc_main$A, { node: __props.modelValue }, null, 8, ["node"]),
            createVNode(unref(VSheet), normalizeProps(guardReactiveProps(unref(vSheetProps))), {
              default: withCtx(() => [
                createBaseVNode("div", _hoisted_1$2, [
                  createVNode(unref(VTabs), {
                    modelValue: tab.value,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => tab.value = $event),
                    direction: "vertical"
                  }, {
                    default: withCtx(() => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(__props.modelValue.children, (child, i2) => {
                        return openBlock(), createBlock(unref(VTab), {
                          key: child.key,
                          value: i2,
                          color: child.validated && (child.error || child.childError) ? "error" : void 0
                        }, {
                          default: withCtx(() => [
                            child.validated && (child.error || child.childError) ? (openBlock(), createBlock(unref(VIcon), {
                              key: 0,
                              color: "error"
                            }, {
                              default: withCtx(() => [
                                createTextVNode(" mdi-alert ")
                              ]),
                              _: 1
                            })) : createCommentVNode("", true),
                            createTextVNode(" " + toDisplayString(child.layout.title ?? child.layout.label), 1)
                          ]),
                          _: 2
                        }, 1032, ["value", "color"]);
                      }), 128))
                    ]),
                    _: 1
                  }, 8, ["modelValue"]),
                  createVNode(unref(VWindow), {
                    modelValue: tab.value,
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => tab.value = $event),
                    class: "flex-fill"
                  }, {
                    default: withCtx(() => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(__props.modelValue.children, (child, i2) => {
                        return openBlock(), createBlock(unref(VWindowItem), {
                          key: child.key,
                          value: i2
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(VContainer), { fluid: "" }, {
                              default: withCtx(() => {
                                var _a2, _b;
                                return [
                                  createVNode(_sfc_main$d, { "model-value": child }, null, 8, ["model-value"]),
                                  createVNode(unref(VRow), {
                                    dense: ((_a2 = __props.modelValue.options) == null ? void 0 : _a2.density) === "compact" || ((_b = __props.modelValue.options) == null ? void 0 : _b.density) === "comfortable"
                                  }, {
                                    default: withCtx(() => [
                                      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(isSection)(child) ? child.children : [child], (grandChild) => {
                                        return openBlock(), createBlock(_sfc_main$C, {
                                          key: grandChild.fullKey,
                                          "model-value": (
                                            /** @type import('../../types.js').VjsfNode */
                                            grandChild
                                          ),
                                          "stateful-layout": __props.statefulLayout
                                        }, null, 8, ["model-value", "stateful-layout"]);
                                      }), 128))
                                    ]),
                                    _: 2
                                  }, 1032, ["dense"])
                                ];
                              }),
                              _: 2
                            }, 1024)
                          ]),
                          _: 2
                        }, 1032, ["value"]);
                      }), 128))
                    ]),
                    _: 1
                  }, 8, ["modelValue"])
                ])
              ]),
              _: 1
            }, 16)
          ], 64);
        };
      }
    };
    function highlightResult(text2, matches, length) {
      if (matches == null)
        return text2;
      if (Array.isArray(matches))
        throw new Error("Multiple matches is not implemented");
      return typeof matches === "number" && ~matches ? createVNode(Fragment, null, [createVNode("span", {
        "class": "v-combobox__unmask"
      }, [text2.substr(0, matches)]), createVNode("span", {
        "class": "v-combobox__mask"
      }, [text2.substr(matches, length)]), createVNode("span", {
        "class": "v-combobox__unmask"
      }, [text2.substr(matches + length)])]) : text2;
    }
    const makeVComboboxProps = propsFactory({
      autoSelectFirst: {
        type: [Boolean, String]
      },
      clearOnSelect: {
        type: Boolean,
        default: true
      },
      delimiters: Array,
      ...makeFilterProps({
        filterKeys: ["title"]
      }),
      ...makeSelectProps({
        hideNoData: true,
        returnObject: true
      }),
      ...omit$1(makeVTextFieldProps({
        modelValue: null,
        role: "combobox"
      }), ["validationValue", "dirty", "appendInnerIcon"]),
      ...makeTransitionProps({
        transition: false
      })
    }, "VCombobox");
    const VCombobox = genericComponent()({
      name: "VCombobox",
      props: makeVComboboxProps(),
      emits: {
        "update:focused": (focused) => true,
        "update:modelValue": (value) => true,
        "update:search": (value) => true,
        "update:menu": (value) => true
      },
      setup(props, _ref) {
        var _a2;
        let {
          emit: emit2,
          slots
        } = _ref;
        const {
          t
        } = useLocale();
        const vTextFieldRef = ref$1();
        const isFocused = shallowRef(false);
        const isPristine = shallowRef(true);
        const listHasFocus = shallowRef(false);
        const vMenuRef = ref$1();
        const vVirtualScrollRef = ref$1();
        const _menu = useProxiedModel(props, "menu");
        const menu = computed({
          get: () => _menu.value,
          set: (v) => {
            var _a3;
            if (_menu.value && !v && ((_a3 = vMenuRef.value) == null ? void 0 : _a3.ΨopenChildren))
              return;
            _menu.value = v;
          }
        });
        const selectionIndex = shallowRef(-1);
        let cleared = false;
        const color = computed(() => {
          var _a3;
          return (_a3 = vTextFieldRef.value) == null ? void 0 : _a3.color;
        });
        const label = computed(() => menu.value ? props.closeText : props.openText);
        const {
          items: items2,
          transformIn,
          transformOut
        } = useItems(props);
        const {
          textColorClasses,
          textColorStyles
        } = useTextColor(color);
        const model = useProxiedModel(props, "modelValue", [], (v) => transformIn(wrapInArray(v)), (v) => {
          const transformed = transformOut(v);
          return props.multiple ? transformed : transformed[0] ?? null;
        });
        const form = useForm();
        const hasChips = computed(() => !!(props.chips || slots.chip));
        const hasSelectionSlot = computed(() => hasChips.value || !!slots.selection);
        const _search = shallowRef(!props.multiple && !hasSelectionSlot.value ? ((_a2 = model.value[0]) == null ? void 0 : _a2.title) ?? "" : "");
        const search = computed({
          get: () => {
            return _search.value;
          },
          set: (val) => {
            var _a3;
            _search.value = val ?? "";
            if (!props.multiple && !hasSelectionSlot.value) {
              model.value = [transformItem$1(props, val)];
            }
            if (val && props.multiple && ((_a3 = props.delimiters) == null ? void 0 : _a3.length)) {
              const values = val.split(new RegExp(`(?:${props.delimiters.join("|")})+`));
              if (values.length > 1) {
                values.forEach((v) => {
                  v = v.trim();
                  if (v)
                    select(transformItem$1(props, v));
                });
                _search.value = "";
              }
            }
            if (!val)
              selectionIndex.value = -1;
            isPristine.value = !val;
          }
        });
        const counterValue = computed(() => {
          return typeof props.counterValue === "function" ? props.counterValue(model.value) : typeof props.counterValue === "number" ? props.counterValue : props.multiple ? model.value.length : search.value.length;
        });
        watch(_search, (value) => {
          if (cleared) {
            nextTick(() => cleared = false);
          } else if (isFocused.value && !menu.value) {
            menu.value = true;
          }
          emit2("update:search", value);
        });
        watch(model, (value) => {
          var _a3;
          if (!props.multiple && !hasSelectionSlot.value) {
            _search.value = ((_a3 = value[0]) == null ? void 0 : _a3.title) ?? "";
          }
        });
        const {
          filteredItems,
          getMatches
        } = useFilter(props, items2, () => isPristine.value ? "" : search.value);
        const displayItems = computed(() => {
          if (props.hideSelected) {
            return filteredItems.value.filter((filteredItem) => !model.value.some((s) => s.value === filteredItem.value));
          }
          return filteredItems.value;
        });
        const selectedValues = computed(() => model.value.map((selection) => selection.value));
        const highlightFirst = computed(() => {
          var _a3;
          const selectFirst = props.autoSelectFirst === true || props.autoSelectFirst === "exact" && search.value === ((_a3 = displayItems.value[0]) == null ? void 0 : _a3.title);
          return selectFirst && displayItems.value.length > 0 && !isPristine.value && !listHasFocus.value;
        });
        const menuDisabled = computed(() => props.hideNoData && !displayItems.value.length || props.readonly || (form == null ? void 0 : form.isReadonly.value));
        const listRef = ref$1();
        const {
          onListScroll,
          onListKeydown
        } = useScrolling(listRef, vTextFieldRef);
        function onClear(e) {
          cleared = true;
          if (props.openOnClear) {
            menu.value = true;
          }
        }
        function onMousedownControl() {
          if (menuDisabled.value)
            return;
          menu.value = true;
        }
        function onMousedownMenuIcon(e) {
          if (menuDisabled.value)
            return;
          if (isFocused.value) {
            e.preventDefault();
            e.stopPropagation();
          }
          menu.value = !menu.value;
        }
        function onKeydown(e) {
          var _a3;
          if (isComposingIgnoreKey(e) || props.readonly || (form == null ? void 0 : form.isReadonly.value))
            return;
          const selectionStart = vTextFieldRef.value.selectionStart;
          const length = model.value.length;
          if (selectionIndex.value > -1 || ["Enter", "ArrowDown", "ArrowUp"].includes(e.key)) {
            e.preventDefault();
          }
          if (["Enter", "ArrowDown"].includes(e.key)) {
            menu.value = true;
          }
          if (["Escape"].includes(e.key)) {
            menu.value = false;
          }
          if (["Enter", "Escape", "Tab"].includes(e.key)) {
            if (highlightFirst.value && ["Enter", "Tab"].includes(e.key) && !model.value.some((_ref2) => {
              let {
                value
              } = _ref2;
              return value === displayItems.value[0].value;
            })) {
              select(filteredItems.value[0]);
            }
            isPristine.value = true;
          }
          if (e.key === "ArrowDown" && highlightFirst.value) {
            (_a3 = listRef.value) == null ? void 0 : _a3.focus("next");
          }
          if (e.key === "Enter" && search.value) {
            select(transformItem$1(props, search.value));
            if (hasSelectionSlot.value)
              _search.value = "";
          }
          if (["Backspace", "Delete"].includes(e.key)) {
            if (!props.multiple && hasSelectionSlot.value && model.value.length > 0 && !search.value)
              return select(model.value[0], false);
            if (~selectionIndex.value) {
              const originalSelectionIndex = selectionIndex.value;
              select(model.value[selectionIndex.value], false);
              selectionIndex.value = originalSelectionIndex >= length - 1 ? length - 2 : originalSelectionIndex;
            } else if (e.key === "Backspace" && !search.value) {
              selectionIndex.value = length - 1;
            }
          }
          if (!props.multiple)
            return;
          if (e.key === "ArrowLeft") {
            if (selectionIndex.value < 0 && selectionStart > 0)
              return;
            const prev = selectionIndex.value > -1 ? selectionIndex.value - 1 : length - 1;
            if (model.value[prev]) {
              selectionIndex.value = prev;
            } else {
              selectionIndex.value = -1;
              vTextFieldRef.value.setSelectionRange(search.value.length, search.value.length);
            }
          }
          if (e.key === "ArrowRight") {
            if (selectionIndex.value < 0)
              return;
            const next2 = selectionIndex.value + 1;
            if (model.value[next2]) {
              selectionIndex.value = next2;
            } else {
              selectionIndex.value = -1;
              vTextFieldRef.value.setSelectionRange(0, 0);
            }
          }
        }
        function onAfterLeave() {
          var _a3;
          if (isFocused.value) {
            isPristine.value = true;
            (_a3 = vTextFieldRef.value) == null ? void 0 : _a3.focus();
          }
        }
        function select(item) {
          let set2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          if (!item || item.props.disabled)
            return;
          if (props.multiple) {
            const index = model.value.findIndex((selection) => props.valueComparator(selection.value, item.value));
            const add2 = set2 == null ? !~index : set2;
            if (~index) {
              const value = add2 ? [...model.value, item] : [...model.value];
              value.splice(index, 1);
              model.value = value;
            } else if (add2) {
              model.value = [...model.value, item];
            }
            if (props.clearOnSelect) {
              search.value = "";
            }
          } else {
            const add2 = set2 !== false;
            model.value = add2 ? [item] : [];
            _search.value = add2 && !hasSelectionSlot.value ? item.title : "";
            nextTick(() => {
              menu.value = false;
              isPristine.value = true;
            });
          }
        }
        function onFocusin(e) {
          isFocused.value = true;
          setTimeout(() => {
            listHasFocus.value = true;
          });
        }
        function onFocusout(e) {
          listHasFocus.value = false;
        }
        function onUpdateModelValue(v) {
          if (v == null || v === "" && !props.multiple && !hasSelectionSlot.value)
            model.value = [];
        }
        watch(isFocused, (val, oldVal) => {
          if (val || val === oldVal)
            return;
          selectionIndex.value = -1;
          menu.value = false;
          if (search.value) {
            if (props.multiple) {
              select(transformItem$1(props, search.value));
              return;
            }
            if (!hasSelectionSlot.value)
              return;
            if (model.value.some((_ref3) => {
              let {
                title: title2
              } = _ref3;
              return title2 === search.value;
            })) {
              _search.value = "";
            } else {
              select(transformItem$1(props, search.value));
            }
          }
        });
        watch(menu, () => {
          if (!props.hideSelected && menu.value && model.value.length) {
            const index = displayItems.value.findIndex((item) => model.value.some((s) => props.valueComparator(s.value, item.value)));
            IN_BROWSER && window.requestAnimationFrame(() => {
              var _a3;
              index >= 0 && ((_a3 = vVirtualScrollRef.value) == null ? void 0 : _a3.scrollToIndex(index));
            });
          }
        });
        watch(() => props.items, (newVal, oldVal) => {
          if (menu.value)
            return;
          if (isFocused.value && !oldVal.length && newVal.length) {
            menu.value = true;
          }
        });
        useRender(() => {
          const hasList = !!(!props.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
          const isDirty = model.value.length > 0;
          const textFieldProps = VTextField.filterProps(props);
          return createVNode(VTextField, mergeProps({
            "ref": vTextFieldRef
          }, textFieldProps, {
            "modelValue": search.value,
            "onUpdate:modelValue": [($event) => search.value = $event, onUpdateModelValue],
            "focused": isFocused.value,
            "onUpdate:focused": ($event) => isFocused.value = $event,
            "validationValue": model.externalValue,
            "counterValue": counterValue.value,
            "dirty": isDirty,
            "class": ["v-combobox", {
              "v-combobox--active-menu": menu.value,
              "v-combobox--chips": !!props.chips,
              "v-combobox--selection-slot": !!hasSelectionSlot.value,
              "v-combobox--selecting-index": selectionIndex.value > -1,
              [`v-combobox--${props.multiple ? "multiple" : "single"}`]: true
            }, props.class],
            "style": props.style,
            "readonly": props.readonly,
            "placeholder": isDirty ? void 0 : props.placeholder,
            "onClick:clear": onClear,
            "onMousedown:control": onMousedownControl,
            "onKeydown": onKeydown
          }), {
            ...slots,
            default: () => createVNode(Fragment, null, [createVNode(VMenu, mergeProps({
              "ref": vMenuRef,
              "modelValue": menu.value,
              "onUpdate:modelValue": ($event) => menu.value = $event,
              "activator": "parent",
              "contentClass": "v-combobox__content",
              "disabled": menuDisabled.value,
              "eager": props.eager,
              "maxHeight": 310,
              "openOnClick": false,
              "closeOnContentClick": false,
              "transition": props.transition,
              "onAfterLeave": onAfterLeave
            }, props.menuProps), {
              default: () => [hasList && createVNode(VList, mergeProps({
                "ref": listRef,
                "selected": selectedValues.value,
                "selectStrategy": props.multiple ? "independent" : "single-independent",
                "onMousedown": (e) => e.preventDefault(),
                "onKeydown": onListKeydown,
                "onFocusin": onFocusin,
                "onFocusout": onFocusout,
                "onScrollPassive": onListScroll,
                "tabindex": "-1",
                "aria-live": "polite",
                "color": props.itemColor ?? props.color
              }, props.listProps), {
                default: () => {
                  var _a3, _b, _c;
                  return [(_a3 = slots["prepend-item"]) == null ? void 0 : _a3.call(slots), !displayItems.value.length && !props.hideNoData && (((_b = slots["no-data"]) == null ? void 0 : _b.call(slots)) ?? createVNode(VListItem, {
                    "title": t(props.noDataText)
                  }, null)), createVNode(VVirtualScroll, {
                    "ref": vVirtualScrollRef,
                    "renderless": true,
                    "items": displayItems.value
                  }, {
                    default: (_ref4) => {
                      var _a4;
                      let {
                        item,
                        index,
                        itemRef
                      } = _ref4;
                      const itemProps = mergeProps(item.props, {
                        ref: itemRef,
                        key: index,
                        active: highlightFirst.value && index === 0 ? true : void 0,
                        onClick: () => select(item, null)
                      });
                      return ((_a4 = slots.item) == null ? void 0 : _a4.call(slots, {
                        item,
                        index,
                        props: itemProps
                      })) ?? createVNode(VListItem, mergeProps(itemProps, {
                        "role": "option"
                      }), {
                        prepend: (_ref5) => {
                          let {
                            isSelected
                          } = _ref5;
                          return createVNode(Fragment, null, [props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                            "key": item.value,
                            "modelValue": isSelected,
                            "ripple": false,
                            "tabindex": "-1"
                          }, null) : void 0, item.props.prependAvatar && createVNode(VAvatar, {
                            "image": item.props.prependAvatar
                          }, null), item.props.prependIcon && createVNode(VIcon, {
                            "icon": item.props.prependIcon
                          }, null)]);
                        },
                        title: () => {
                          var _a5, _b2;
                          return isPristine.value ? item.title : highlightResult(item.title, (_a5 = getMatches(item)) == null ? void 0 : _a5.title, ((_b2 = search.value) == null ? void 0 : _b2.length) ?? 0);
                        }
                      });
                    }
                  }), (_c = slots["append-item"]) == null ? void 0 : _c.call(slots)];
                }
              })]
            }), model.value.map((item, index) => {
              function onChipClose(e) {
                e.stopPropagation();
                e.preventDefault();
                select(item, false);
              }
              const slotProps = {
                "onClick:close": onChipClose,
                onKeydown(e) {
                  if (e.key !== "Enter" && e.key !== " ")
                    return;
                  e.preventDefault();
                  e.stopPropagation();
                  onChipClose(e);
                },
                onMousedown(e) {
                  e.preventDefault();
                  e.stopPropagation();
                },
                modelValue: true,
                "onUpdate:modelValue": void 0
              };
              const hasSlot = hasChips.value ? !!slots.chip : !!slots.selection;
              const slotContent = hasSlot ? ensureValidVNode(hasChips.value ? slots.chip({
                item,
                index,
                props: slotProps
              }) : slots.selection({
                item,
                index
              })) : void 0;
              if (hasSlot && !slotContent)
                return void 0;
              return createVNode("div", {
                "key": item.value,
                "class": ["v-combobox__selection", index === selectionIndex.value && ["v-combobox__selection--selected", textColorClasses.value]],
                "style": index === selectionIndex.value ? textColorStyles.value : {}
              }, [hasChips.value ? !slots.chip ? createVNode(VChip, mergeProps({
                "key": "chip",
                "closable": props.closableChips,
                "size": "small",
                "text": item.title,
                "disabled": item.props.disabled
              }, slotProps), null) : createVNode(VDefaultsProvider, {
                "key": "chip-defaults",
                "defaults": {
                  VChip: {
                    closable: props.closableChips,
                    size: "small",
                    text: item.title
                  }
                }
              }, {
                default: () => [slotContent]
              }) : slotContent ?? createVNode("span", {
                "class": "v-combobox__selection-text"
              }, [item.title, props.multiple && index < model.value.length - 1 && createVNode("span", {
                "class": "v-combobox__selection-comma"
              }, [createTextVNode(",")])])]);
            })]),
            "append-inner": function() {
              var _a3;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return createVNode(Fragment, null, [(_a3 = slots["append-inner"]) == null ? void 0 : _a3.call(slots, ...args), (!props.hideNoData || props.items.length) && props.menuIcon ? createVNode(VIcon, {
                "class": "v-combobox__menu-icon",
                "icon": props.menuIcon,
                "onMousedown": onMousedownMenuIcon,
                "onClick": noop$1,
                "aria-label": t(label.value),
                "title": t(label.value),
                "tabindex": "-1"
              }, null) : void 0]);
            }
          });
        });
        return forwardRefs({
          isFocused,
          isPristine,
          menu,
          search,
          selectionIndex,
          filteredItems,
          select
        }, vTextFieldRef);
      }
    });
    const _sfc_main$a = /* @__PURE__ */ defineComponent$1({
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfComboboxNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(props) {
        useDefaults({}, "VjsfCombobox");
        const items2 = shallowRef(props.modelValue.layout.items ?? []);
        const loading = ref$1(false);
        let lastStateTree = null;
        let lastContext = null;
        const hasItems = computed(() => {
          return !!(props.modelValue.layout.items || props.modelValue.layout.getItems);
        });
        const refresh = async () => {
          if (props.modelValue.layout.items)
            return;
          if (props.statefulLayout.stateTree === lastStateTree && props.statefulLayout.options.context === lastContext)
            return;
          lastStateTree = props.statefulLayout.stateTree;
          lastContext = props.statefulLayout.options.context ?? null;
          if (hasItems.value) {
            loading.value = true;
            items2.value = await props.statefulLayout.getItems(props.modelValue);
            loading.value = false;
          }
        };
        if (!props.modelValue.layout.items) {
          refresh();
        }
        const fieldProps = computed(() => {
          const fieldProps2 = getInputProps(props.modelValue, props.statefulLayout);
          fieldProps2.loading = loading.value;
          fieldProps2.returnObject = false;
          if (hasItems.value)
            fieldProps2.items = items2.value;
          if (props.modelValue.options.readOnly)
            fieldProps2.menuProps = { modelValue: false };
          if (props.modelValue.layout.multiple) {
            fieldProps2.multiple = true;
            fieldProps2.chips = true;
            fieldProps2.closableChips = true;
          }
          fieldProps2["onUpdate:menu"] = () => refresh();
          return fieldProps2;
        });
        const fieldSlots = computed(() => getCompSlots(props.modelValue, props.statefulLayout));
        return () => h(VCombobox, fieldProps.value, fieldSlots.value);
      }
    });
    const _sfc_main$9 = /* @__PURE__ */ defineComponent$1({
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfComboboxNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(props) {
        useDefaults({}, "VjsfNumberCombobox");
        const items2 = shallowRef(props.modelValue.layout.items ?? []);
        const loading = ref$1(false);
        let lastStateTree = null;
        let lastContext = null;
        const hasItems = computed(() => {
          return !!(props.modelValue.layout.items || props.modelValue.layout.getItems);
        });
        const refresh = async () => {
          if (props.modelValue.layout.items)
            return;
          if (props.statefulLayout.stateTree === lastStateTree && props.statefulLayout.options.context === lastContext)
            return;
          lastStateTree = props.statefulLayout.stateTree;
          lastContext = props.statefulLayout.options.context ?? null;
          if (hasItems.value) {
            loading.value = true;
            items2.value = await props.statefulLayout.getItems(props.modelValue);
            loading.value = false;
          }
        };
        if (!props.modelValue.layout.items) {
          refresh();
        }
        const fieldProps = computed(() => {
          const fieldProps2 = getInputProps(props.modelValue, props.statefulLayout, ["step", "min", "max"]);
          fieldProps2.type = "number";
          fieldProps2.loading = loading.value;
          if (hasItems.value)
            fieldProps2.items = items2.value;
          if (props.modelValue.options.readOnly)
            fieldProps2.menuProps = { modelValue: false };
          if (props.modelValue.layout.multiple) {
            fieldProps2.multiple = true;
            fieldProps2.chips = true;
            fieldProps2.closableChips = true;
          }
          fieldProps2["onUpdate:menu"] = () => refresh();
          fieldProps2["onUpdate:modelValue"] = (value) => props.statefulLayout.input(props.modelValue, value && value.map(Number));
          return fieldProps2;
        });
        const fieldSlots = computed(() => getCompSlots(props.modelValue, props.statefulLayout));
        return () => h(VCombobox, fieldProps.value, fieldSlots.value);
      }
    });
    const _sfc_main$8 = {
      __name: "expansion-panels",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfExpansionPanelsNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        useDefaults({}, "VjsfExpansionPanels");
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock(Fragment, null, [
            createVNode(_sfc_main$A, { node: __props.modelValue }, null, 8, ["node"]),
            createVNode(unref(VExpansionPanels), normalizeProps(guardReactiveProps(unref(getCompProps)(__props.modelValue, true))), {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(__props.modelValue.children, (child, i2) => {
                  return openBlock(), createBlock(unref(VExpansionPanel), {
                    key: child.key,
                    value: i2
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(VExpansionPanelTitle), null, {
                        default: withCtx(() => [
                          child.validated && (child.error || child.childError) ? (openBlock(), createBlock(unref(VIcon), {
                            key: 0,
                            color: "error",
                            class: "mr-2"
                          }, {
                            default: withCtx(() => [
                              createTextVNode(" mdi-alert ")
                            ]),
                            _: 1
                          })) : createCommentVNode("", true),
                          createTextVNode(" " + toDisplayString(child.layout.title ?? child.layout.label), 1)
                        ]),
                        _: 2
                      }, 1024),
                      createVNode(unref(VExpansionPanelText), null, {
                        default: withCtx(() => [
                          createVNode(unref(VContainer), { fluid: "" }, {
                            default: withCtx(() => {
                              var _a2, _b;
                              return [
                                createVNode(_sfc_main$d, { "model-value": child }, null, 8, ["model-value"]),
                                createVNode(unref(VRow), {
                                  dense: ((_a2 = __props.modelValue.options) == null ? void 0 : _a2.density) === "compact" || ((_b = __props.modelValue.options) == null ? void 0 : _b.density) === "comfortable"
                                }, {
                                  default: withCtx(() => [
                                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(isSection)(child) ? child.children : [child], (grandChild) => {
                                      return openBlock(), createBlock(_sfc_main$C, {
                                        key: grandChild.fullKey,
                                        "model-value": (
                                          /** @type import('../../types.js').VjsfNode */
                                          grandChild
                                        ),
                                        "stateful-layout": __props.statefulLayout
                                      }, null, 8, ["model-value", "stateful-layout"]);
                                    }), 128))
                                  ]),
                                  _: 2
                                }, 1032, ["dense"])
                              ];
                            }),
                            _: 2
                          }, 1024)
                        ]),
                        _: 2
                      }, 1024)
                    ]),
                    _: 2
                  }, 1032, ["value"]);
                }), 128))
              ]),
              _: 1
            }, 16)
          ], 64);
        };
      }
    };
    const VStepperSymbol = Symbol.for("vuetify:v-stepper");
    const makeVStepperActionsProps = propsFactory({
      color: String,
      disabled: {
        type: [Boolean, String],
        default: false
      },
      prevText: {
        type: String,
        default: "$vuetify.stepper.prev"
      },
      nextText: {
        type: String,
        default: "$vuetify.stepper.next"
      }
    }, "VStepperActions");
    const VStepperActions = genericComponent()({
      name: "VStepperActions",
      props: makeVStepperActionsProps(),
      emits: {
        "click:prev": () => true,
        "click:next": () => true
      },
      setup(props, _ref) {
        let {
          emit: emit2,
          slots
        } = _ref;
        const {
          t
        } = useLocale();
        function onClickPrev() {
          emit2("click:prev");
        }
        function onClickNext() {
          emit2("click:next");
        }
        useRender(() => {
          const prevSlotProps = {
            onClick: onClickPrev
          };
          const nextSlotProps = {
            onClick: onClickNext
          };
          return createVNode("div", {
            "class": "v-stepper-actions"
          }, [createVNode(VDefaultsProvider, {
            "defaults": {
              VBtn: {
                disabled: ["prev", true].includes(props.disabled),
                text: t(props.prevText),
                variant: "text"
              }
            }
          }, {
            default: () => {
              var _a2;
              return [((_a2 = slots.prev) == null ? void 0 : _a2.call(slots, {
                props: prevSlotProps
              })) ?? createVNode(VBtn, prevSlotProps, null)];
            }
          }), createVNode(VDefaultsProvider, {
            "defaults": {
              VBtn: {
                color: props.color,
                disabled: ["next", true].includes(props.disabled),
                text: t(props.nextText),
                variant: "tonal"
              }
            }
          }, {
            default: () => {
              var _a2;
              return [((_a2 = slots.next) == null ? void 0 : _a2.call(slots, {
                props: nextSlotProps
              })) ?? createVNode(VBtn, nextSlotProps, null)];
            }
          })]);
        });
        return {};
      }
    });
    const VStepperHeader = createSimpleFunctional("v-stepper-header");
    const makeStepperItemProps = propsFactory({
      color: String,
      title: String,
      subtitle: String,
      complete: Boolean,
      completeIcon: {
        type: String,
        default: "$complete"
      },
      editable: Boolean,
      editIcon: {
        type: String,
        default: "$edit"
      },
      error: Boolean,
      errorIcon: {
        type: String,
        default: "$error"
      },
      icon: String,
      ripple: {
        type: [Boolean, Object],
        default: true
      },
      rules: {
        type: Array,
        default: () => []
      }
    }, "StepperItem");
    const makeVStepperItemProps = propsFactory({
      ...makeStepperItemProps(),
      ...makeGroupItemProps()
    }, "VStepperItem");
    const VStepperItem = genericComponent()({
      name: "VStepperItem",
      directives: {
        Ripple
      },
      props: makeVStepperItemProps(),
      emits: {
        "group:selected": (val) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const group = useGroupItem(props, VStepperSymbol, true);
        const step = computed(() => (group == null ? void 0 : group.value.value) ?? props.value);
        const isValid2 = computed(() => props.rules.every((handler) => handler() === true));
        const isClickable = computed(() => !props.disabled && props.editable);
        const canEdit = computed(() => !props.disabled && props.editable);
        const hasError = computed(() => props.error || !isValid2.value);
        const hasCompleted = computed(() => props.complete || props.rules.length > 0 && isValid2.value);
        const icon = computed(() => {
          if (hasError.value)
            return props.errorIcon;
          if (hasCompleted.value)
            return props.completeIcon;
          if (group.isSelected.value && props.editable)
            return props.editIcon;
          return props.icon;
        });
        const slotProps = computed(() => ({
          canEdit: canEdit.value,
          hasError: hasError.value,
          hasCompleted: hasCompleted.value,
          title: props.title,
          subtitle: props.subtitle,
          step: step.value,
          value: props.value
        }));
        useRender(() => {
          var _a2, _b, _c;
          const hasColor = (!group || group.isSelected.value || hasCompleted.value || canEdit.value) && !hasError.value && !props.disabled;
          const hasTitle = !!(props.title != null || slots.title);
          const hasSubtitle = !!(props.subtitle != null || slots.subtitle);
          function onClick() {
            group == null ? void 0 : group.toggle();
          }
          return withDirectives(createVNode("button", {
            "class": ["v-stepper-item", {
              "v-stepper-item--complete": hasCompleted.value,
              "v-stepper-item--disabled": props.disabled,
              "v-stepper-item--error": hasError.value
            }, group == null ? void 0 : group.selectedClass.value],
            "disabled": !props.editable,
            "onClick": onClick
          }, [isClickable.value && genOverlays(true, "v-stepper-item"), createVNode(VAvatar, {
            "key": "stepper-avatar",
            "class": "v-stepper-item__avatar",
            "color": hasColor ? props.color : void 0,
            "size": 24
          }, {
            default: () => {
              var _a3;
              return [((_a3 = slots.icon) == null ? void 0 : _a3.call(slots, slotProps.value)) ?? (icon.value ? createVNode(VIcon, {
                "icon": icon.value
              }, null) : step.value)];
            }
          }), createVNode("div", {
            "class": "v-stepper-item__content"
          }, [hasTitle && createVNode("div", {
            "key": "title",
            "class": "v-stepper-item__title"
          }, [((_a2 = slots.title) == null ? void 0 : _a2.call(slots, slotProps.value)) ?? props.title]), hasSubtitle && createVNode("div", {
            "key": "subtitle",
            "class": "v-stepper-item__subtitle"
          }, [((_b = slots.subtitle) == null ? void 0 : _b.call(slots, slotProps.value)) ?? props.subtitle]), (_c = slots.default) == null ? void 0 : _c.call(slots, slotProps.value)])]), [[resolveDirective("ripple"), props.ripple && props.editable, null]]);
        });
        return {};
      }
    });
    const makeVStepperWindowProps = propsFactory({
      ...omit$1(makeVWindowProps(), ["continuous", "nextIcon", "prevIcon", "showArrows", "touch", "mandatory"])
    }, "VStepperWindow");
    const VStepperWindow = genericComponent()({
      name: "VStepperWindow",
      props: makeVStepperWindowProps(),
      emits: {
        "update:modelValue": (v) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const group = inject$1(VStepperSymbol, null);
        const _model = useProxiedModel(props, "modelValue");
        const model = computed({
          get() {
            var _a2;
            if (_model.value != null || !group)
              return _model.value;
            return (_a2 = group.items.value.find((item) => group.selected.value.includes(item.id))) == null ? void 0 : _a2.value;
          },
          set(val) {
            _model.value = val;
          }
        });
        useRender(() => {
          const windowProps = VWindow.filterProps(props);
          return createVNode(VWindow, mergeProps({
            "_as": "VStepperWindow"
          }, windowProps, {
            "modelValue": model.value,
            "onUpdate:modelValue": ($event) => model.value = $event,
            "class": ["v-stepper-window", props.class],
            "style": props.style,
            "mandatory": false,
            "touch": false
          }), slots);
        });
        return {};
      }
    });
    const makeVStepperWindowItemProps = propsFactory({
      ...makeVWindowItemProps()
    }, "VStepperWindowItem");
    const VStepperWindowItem = genericComponent()({
      name: "VStepperWindowItem",
      props: makeVStepperWindowItemProps(),
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        useRender(() => {
          const windowItemProps = VWindowItem.filterProps(props);
          return createVNode(VWindowItem, mergeProps({
            "_as": "VStepperWindowItem"
          }, windowItemProps, {
            "class": ["v-stepper-window-item", props.class],
            "style": props.style
          }), slots);
        });
        return {};
      }
    });
    const makeStepperProps = propsFactory({
      altLabels: Boolean,
      bgColor: String,
      completeIcon: String,
      editIcon: String,
      editable: Boolean,
      errorIcon: String,
      hideActions: Boolean,
      items: {
        type: Array,
        default: () => []
      },
      itemTitle: {
        type: String,
        default: "title"
      },
      itemValue: {
        type: String,
        default: "value"
      },
      nonLinear: Boolean,
      flat: Boolean,
      ...makeDisplayProps()
    }, "Stepper");
    const makeVStepperProps = propsFactory({
      ...makeStepperProps(),
      ...makeGroupProps({
        mandatory: "force",
        selectedClass: "v-stepper-item--selected"
      }),
      ...makeVSheetProps(),
      ...only(makeVStepperActionsProps(), ["prevText", "nextText"])
    }, "VStepper");
    const VStepper = genericComponent()({
      name: "VStepper",
      props: makeVStepperProps(),
      emits: {
        "update:modelValue": (v) => true
      },
      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const {
          items: _items,
          next: next2,
          prev,
          selected
        } = useGroup(props, VStepperSymbol);
        const {
          displayClasses,
          mobile
        } = useDisplay(props);
        const {
          completeIcon,
          editIcon,
          errorIcon,
          color,
          editable,
          prevText,
          nextText
        } = toRefs(props);
        const items2 = computed(() => props.items.map((item, index) => {
          const title2 = getPropertyFromItem(item, props.itemTitle, item);
          const value = getPropertyFromItem(item, props.itemValue, index + 1);
          return {
            title: title2,
            value,
            raw: item
          };
        }));
        const activeIndex = computed(() => {
          return _items.value.findIndex((item) => selected.value.includes(item.id));
        });
        const disabled = computed(() => {
          if (props.disabled)
            return props.disabled;
          if (activeIndex.value === 0)
            return "prev";
          if (activeIndex.value === _items.value.length - 1)
            return "next";
          return false;
        });
        provideDefaults({
          VStepperItem: {
            editable,
            errorIcon,
            completeIcon,
            editIcon,
            prevText,
            nextText
          },
          VStepperActions: {
            color,
            disabled,
            prevText,
            nextText
          }
        });
        useRender(() => {
          const sheetProps = VSheet.filterProps(props);
          const hasHeader = !!(slots.header || props.items.length);
          const hasWindow = props.items.length > 0;
          const hasActions = !props.hideActions && !!(hasWindow || slots.actions);
          return createVNode(VSheet, mergeProps(sheetProps, {
            "color": props.bgColor,
            "class": ["v-stepper", {
              "v-stepper--alt-labels": props.altLabels,
              "v-stepper--flat": props.flat,
              "v-stepper--non-linear": props.nonLinear,
              "v-stepper--mobile": mobile.value
            }, displayClasses.value, props.class],
            "style": props.style
          }), {
            default: () => {
              var _a2, _b;
              return [hasHeader && createVNode(VStepperHeader, {
                "key": "stepper-header"
              }, {
                default: () => [items2.value.map((_ref2, index) => {
                  let {
                    raw,
                    ...item
                  } = _ref2;
                  return createVNode(Fragment, null, [!!index && createVNode(VDivider, null, null), createVNode(VStepperItem, item, {
                    default: slots[`header-item.${item.value}`] ?? slots.header,
                    icon: slots.icon,
                    title: slots.title,
                    subtitle: slots.subtitle
                  })]);
                })]
              }), hasWindow && createVNode(VStepperWindow, {
                "key": "stepper-window"
              }, {
                default: () => [items2.value.map((item) => createVNode(VStepperWindowItem, {
                  "value": item.value
                }, {
                  default: () => {
                    var _a3, _b2;
                    return ((_a3 = slots[`item.${item.value}`]) == null ? void 0 : _a3.call(slots, item)) ?? ((_b2 = slots.item) == null ? void 0 : _b2.call(slots, item));
                  }
                }))]
              }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
                prev,
                next: next2
              }), hasActions && (((_b = slots.actions) == null ? void 0 : _b.call(slots, {
                next: next2,
                prev
              })) ?? createVNode(VStepperActions, {
                "key": "stepper-actions",
                "onClick:prev": prev,
                "onClick:next": next2
              }, slots))];
            }
          });
        });
        return {
          prev,
          next: next2
        };
      }
    });
    const _sfc_main$7 = {
      __name: "stepper",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStepperNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        useDefaults({}, "VjsfStepper");
        const props = __props;
        const step = ref$1(0);
        const firstErrorIndex = computed(() => {
          const index = props.modelValue.children.findIndex((child) => child.validated && !!(child.error || child.childError));
          return index === -1 ? props.modelValue.children.length : index;
        });
        const goNext = () => {
          const child = props.modelValue.children[step.value];
          props.statefulLayout.validateNodeRecurse(child);
          if (!(child.error || child.childError))
            step.value++;
        };
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock(Fragment, null, [
            createVNode(_sfc_main$A, { node: __props.modelValue }, null, 8, ["node"]),
            createVNode(unref(VStepper), {
              modelValue: step.value,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => step.value = $event)
            }, {
              default: withCtx(() => [
                createVNode(unref(VStepperHeader), null, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(__props.modelValue.children, (child, i2) => {
                      return openBlock(), createElementBlock(Fragment, {
                        key: child.key
                      }, [
                        createVNode(unref(VStepperItem), {
                          value: i2,
                          title: (
                            /** @type {string | undefined} */
                            child.layout.title ?? child.layout.label
                          ),
                          error: child.validated && !!(child.error || child.childError),
                          complete: child.validated && !(child.error || child.childError),
                          editable: i2 <= firstErrorIndex.value
                        }, null, 8, ["value", "title", "error", "complete", "editable"]),
                        createVNode(unref(VDivider))
                      ], 64);
                    }), 128))
                  ]),
                  _: 1
                }),
                createVNode(unref(VStepperWindow), null, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(__props.modelValue.children, (child) => {
                      return openBlock(), createBlock(unref(VStepperWindowItem), {
                        key: child.key
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(VContainer), {
                            fluid: "",
                            class: "pa-0"
                          }, {
                            default: withCtx(() => {
                              var _a2, _b;
                              return [
                                createVNode(_sfc_main$d, { "model-value": child }, null, 8, ["model-value"]),
                                createVNode(unref(VRow), {
                                  dense: ((_a2 = __props.modelValue.options) == null ? void 0 : _a2.density) === "compact" || ((_b = __props.modelValue.options) == null ? void 0 : _b.density) === "comfortable"
                                }, {
                                  default: withCtx(() => [
                                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(isSection)(child) ? child.children : [child], (grandChild) => {
                                      return openBlock(), createBlock(_sfc_main$C, {
                                        key: grandChild.fullKey,
                                        "model-value": (
                                          /** @type import('../../types.js').VjsfNode */
                                          grandChild
                                        ),
                                        "stateful-layout": __props.statefulLayout
                                      }, null, 8, ["model-value", "stateful-layout"]);
                                    }), 128))
                                  ]),
                                  _: 2
                                }, 1032, ["dense"])
                              ];
                            }),
                            _: 2
                          }, 1024)
                        ]),
                        _: 2
                      }, 1024);
                    }), 128))
                  ]),
                  _: 1
                }),
                createVNode(unref(VStepperActions), null, {
                  prev: withCtx(() => [
                    step.value > 0 ? (openBlock(), createBlock(unref(VBtn), {
                      key: 0,
                      variant: "text",
                      onClick: _cache[0] || (_cache[0] = ($event) => step.value--)
                    }, {
                      default: withCtx(() => [
                        createTextVNode(" Back ")
                      ]),
                      _: 1
                    })) : createCommentVNode("", true)
                  ]),
                  next: withCtx(() => [
                    createVNode(unref(VSpacer)),
                    step.value < __props.modelValue.children.length - 1 ? (openBlock(), createBlock(unref(VBtn), {
                      key: 0,
                      variant: "flat",
                      color: "primary",
                      onClick: goNext
                    }, {
                      default: withCtx(() => [
                        createTextVNode(" Next ")
                      ]),
                      _: 1
                    })) : createCommentVNode("", true)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["modelValue"])
          ], 64);
        };
      }
    };
    const makeVFormProps = propsFactory({
      ...makeComponentProps(),
      ...makeFormProps()
    }, "VForm");
    const VForm = genericComponent()({
      name: "VForm",
      props: makeVFormProps(),
      emits: {
        "update:modelValue": (val) => true,
        submit: (e) => true
      },
      setup(props, _ref) {
        let {
          slots,
          emit: emit2
        } = _ref;
        const form = createForm(props);
        const formRef = ref$1();
        function onReset(e) {
          e.preventDefault();
          form.reset();
        }
        function onSubmit(_e) {
          const e = _e;
          const ready = form.validate();
          e.then = ready.then.bind(ready);
          e.catch = ready.catch.bind(ready);
          e.finally = ready.finally.bind(ready);
          emit2("submit", e);
          if (!e.defaultPrevented) {
            ready.then((_ref2) => {
              var _a2;
              let {
                valid
              } = _ref2;
              if (valid) {
                (_a2 = formRef.value) == null ? void 0 : _a2.submit();
              }
            });
          }
          e.preventDefault();
        }
        useRender(() => {
          var _a2;
          return createVNode("form", {
            "ref": formRef,
            "class": ["v-form", props.class],
            "style": props.style,
            "novalidate": true,
            "onReset": onReset,
            "onSubmit": onSubmit
          }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, form)]);
        });
        return forwardRefs(form, formRef);
      }
    });
    function useDnd(array, callback) {
      const activeDnd = computed(() => {
        if (!("draggable" in document.createElement("div")))
          return false;
        if (window.matchMedia("(pointer: coarse)").matches)
          return false;
        return true;
      });
      const sortableArray = shallowRef(array);
      const hovered = ref$1(-1);
      const draggable = ref$1(-1);
      const dragging = ref$1(-1);
      hovered.value = 1;
      const itemBind = (itemIndex) => ({
        // hover the item
        onMouseenter: () => {
          hovered.value = itemIndex;
        },
        onMouseleave: () => {
          hovered.value = -1;
        },
        // drag the item
        onDragstart: () => {
          dragging.value = itemIndex;
        },
        onDragover: () => {
          sortableArray.value = moveArrayItem(sortableArray.value, dragging.value, itemIndex);
          dragging.value = itemIndex;
        },
        onDragend: () => {
          hovered.value = itemIndex;
          dragging.value = -1;
          callback();
        }
      });
      const handleBind = (itemIndex) => ({
        // hover the handle
        onMouseover() {
          draggable.value = itemIndex;
        },
        onMouseout() {
          draggable.value = -1;
        }
      });
      return {
        activeDnd,
        sortableArray,
        hovered,
        draggable,
        dragging,
        itemBind,
        handleBind
      };
    }
    const _hoisted_1$1 = { class: "vjsf-list-item-actions-wrapper" };
    const _sfc_main$6 = {
      __name: "list",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfListNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        useDefaults({}, "VjsfList");
        const vSheetProps = useCompDefaultProps("VjsfList-VSheet", { border: true });
        const props = __props;
        const theme = useTheme();
        const { activeDnd, sortableArray, draggable, hovered, dragging, itemBind, handleBind } = useDnd(props.modelValue.children, () => {
          const newData = props.modelValue.layout.indexed ? sortableArray.value.reduce(
            (a, child) => {
              a[child.key] = child.data;
              return a;
            },
            /** @type {Record<string, any>} */
            {}
          ) : sortableArray.value.map((child) => child.data);
          console.log(newData);
          props.statefulLayout.input(props.modelValue, newData);
        });
        watch(() => props.modelValue.children, (array) => {
          sortableArray.value = array;
        });
        const editedItem = computed(() => {
          return props.statefulLayout.activatedItems[props.modelValue.fullKey];
        });
        const menuOpened = ref$1(-1);
        const activeItem = computed(() => {
          if (props.modelValue.layout.listActions.includes("edit") && props.modelValue.layout.listEditMode === "inline-single" && editedItem.value !== void 0) {
            return editedItem.value;
          }
          if (dragging.value !== -1)
            return -1;
          if (menuOpened.value !== -1)
            return menuOpened.value;
          return hovered.value;
        });
        const buttonDensity = computed(() => {
          if (props.modelValue.options.density === "default")
            return "comfortable";
          return props.modelValue.options.density;
        });
        const pushEmptyItem = () => {
          const newData = (props.modelValue.data ?? []).concat([void 0]);
          props.statefulLayout.input(props.modelValue, newData);
          if (props.modelValue.layout.listEditMode === "inline-single") {
            props.statefulLayout.activateItem(props.modelValue, newData.length - 1);
          }
        };
        const newKey = ref$1("");
        const newKeyForm = ref$1(null);
        const pushEmptyIndexedItem = () => {
          var _a2;
          if (!newKey.value)
            return;
          if (!newKeyForm.value)
            return;
          if (!newKeyForm.value.isValid)
            return;
          const newData = { ...props.modelValue.data ?? {}, [newKey.value]: null };
          props.statefulLayout.input(props.modelValue, newData);
          if (props.modelValue.layout.listEditMode === "inline-single") {
            props.statefulLayout.activateItem(props.modelValue, Object.keys(newData).length - 1);
          }
          newKey.value = "";
          (_a2 = newKeyForm.value) == null ? void 0 : _a2.reset();
        };
        const deleteItem = (childIndex) => {
          if (props.modelValue.layout.indexed) {
            const oldData = (
              /** @type {Record<string, any>} */
              props.modelValue.data
            );
            const keys2 = Object.keys(props.modelValue.data);
            const newData = {};
            for (let i2 = 0; i2 < keys2.length; i2++) {
              if (i2 !== childIndex)
                newData[keys2[i2]] = oldData[keys2[i2]];
            }
            props.statefulLayout.input(props.modelValue, newData);
          } else {
            const newData = [...props.modelValue.data.slice(0, childIndex), ...props.modelValue.data.slice(childIndex + 1)];
            props.statefulLayout.input(props.modelValue, newData);
          }
          menuOpened.value = -1;
        };
        const duplicateItem = (child, childIndex) => {
          const newData = [...props.modelValue.data.slice(0, childIndex), clone$1(child.data), ...props.modelValue.data.slice(childIndex)];
          props.statefulLayout.input(props.modelValue, newData);
          if (props.modelValue.layout.listEditMode === "inline-single") {
            props.statefulLayout.activateItem(props.modelValue, childIndex + 1);
          }
          menuOpened.value = -1;
        };
        const itemBorderColor = computed(() => (child, childIndex) => {
          if (editedItem.value === childIndex)
            return theme.current.value.colors.primary;
          if (child.validated && (child.error || child.childError))
            return theme.current.value.colors.error;
          if (props.modelValue.options.readOnly)
            return "transparent";
          if (activeItem.value === childIndex)
            return theme.current.value.colors.primary;
          return "transparent";
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(VSheet), normalizeProps(guardReactiveProps(unref(vSheetProps))), {
            default: withCtx(() => [
              createVNode(unref(VList), { class: "py-0" }, {
                default: withCtx(() => [
                  __props.modelValue.layout.title ? (openBlock(), createBlock(unref(VListSubheader), { key: 0 }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(__props.modelValue.layout.title), 1)
                    ]),
                    _: 1
                  })) : createCommentVNode("", true),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(sortableArray), (child, childIndex) => {
                    return openBlock(), createElementBlock(Fragment, {
                      key: props.modelValue.children.findIndex((c) => c === child)
                    }, [
                      createVNode(unref(VListItem), mergeProps({ ref_for: true }, unref(itemBind)(childIndex), {
                        draggable: unref(draggable) === childIndex,
                        variant: "flat",
                        style: `border: 1px solid ${itemBorderColor.value(child, childIndex)}`,
                        class: "pa-1 vjsf-list-item"
                      }), createSlots({
                        default: withCtx(() => [
                          __props.modelValue.layout.indexed ? (openBlock(), createBlock(unref(VListItemTitle), {
                            key: 0,
                            class: "pl-4 pt-2"
                          }, {
                            default: withCtx(() => [
                              createTextVNode(toDisplayString(child.key), 1)
                            ]),
                            _: 2
                          }, 1024)) : createCommentVNode("", true),
                          createVNode(unref(VRow), { class: "ma-0" }, {
                            default: withCtx(() => [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(isSection)(child) ? child.children : [child], (grandChild) => {
                                return openBlock(), createBlock(_sfc_main$C, {
                                  key: grandChild.fullKey,
                                  "model-value": (
                                    /** @type import('../../types.js').VjsfNode */
                                    grandChild
                                  ),
                                  "stateful-layout": __props.statefulLayout
                                }, null, 8, ["model-value", "stateful-layout"]);
                              }), 128))
                            ]),
                            _: 2
                          }, 1024)
                        ]),
                        _: 2
                      }, [
                        !__props.modelValue.options.readOnly && __props.modelValue.layout.listActions.length ? {
                          name: "append",
                          fn: withCtx(() => [
                            createBaseVNode("div", _hoisted_1$1, [
                              activeItem.value !== childIndex ? (openBlock(), createBlock(unref(VListItemAction), { key: 0 }, {
                                default: withCtx(() => [
                                  createVNode(unref(VBtn), {
                                    style: { "visibility": "hidden" },
                                    variant: "text",
                                    density: buttonDensity.value,
                                    icon: "mdi-pencil"
                                  }, null, 8, ["density"])
                                ]),
                                _: 1
                              })) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                                __props.modelValue.layout.listActions.includes("edit") && __props.modelValue.layout.listEditMode === "inline-single" ? (openBlock(), createBlock(unref(VListItemAction), { key: 0 }, {
                                  default: withCtx(() => [
                                    editedItem.value !== childIndex ? (openBlock(), createBlock(unref(VBtn), {
                                      key: 0,
                                      title: __props.modelValue.messages.edit,
                                      icon: "mdi-pencil",
                                      variant: "text",
                                      color: "primary",
                                      density: buttonDensity.value,
                                      onClick: ($event) => __props.statefulLayout.activateItem(__props.modelValue, childIndex)
                                    }, null, 8, ["title", "density", "onClick"])) : (openBlock(), createBlock(unref(VBtn), {
                                      key: 1,
                                      title: __props.modelValue.messages.close,
                                      icon: "mdi-close",
                                      variant: "flat",
                                      color: "primary",
                                      density: buttonDensity.value,
                                      onClick: _cache[0] || (_cache[0] = ($event) => __props.statefulLayout.deactivateItem(__props.modelValue))
                                    }, null, 8, ["title", "density"]))
                                  ]),
                                  _: 2
                                }, 1024)) : createCommentVNode("", true),
                                editedItem.value === void 0 && __props.modelValue.layout.listActions.includes("sort") && unref(activeDnd) ? (openBlock(), createBlock(unref(VListItemAction), { key: 1 }, {
                                  default: withCtx(() => [
                                    createVNode(unref(VBtn), mergeProps({
                                      title: __props.modelValue.messages.sort,
                                      icon: "mdi-arrow-up-down",
                                      variant: "plain",
                                      density: buttonDensity.value,
                                      ref_for: true
                                    }, unref(handleBind)(childIndex)), null, 16, ["title", "density"])
                                  ]),
                                  _: 2
                                }, 1024)) : createCommentVNode("", true),
                                editedItem.value === void 0 && (__props.modelValue.layout.listActions.includes("delete") || __props.modelValue.layout.listActions.includes("duplicate") || __props.modelValue.layout.listActions.includes("sort")) ? (openBlock(), createBlock(unref(VListItemAction), { key: 2 }, {
                                  default: withCtx(() => [
                                    createVNode(unref(VMenu), {
                                      location: "bottom end",
                                      "onUpdate:modelValue": (value) => {
                                        menuOpened.value = value ? childIndex : -1;
                                      }
                                    }, {
                                      activator: withCtx(({ props: activatorProps }) => [
                                        createVNode(unref(VBtn), mergeProps({ ref_for: true }, activatorProps, {
                                          icon: "mdi-dots-vertical",
                                          variant: "plain",
                                          slim: "",
                                          density: buttonDensity.value
                                        }), null, 16, ["density"])
                                      ]),
                                      default: withCtx(() => [
                                        createVNode(unref(VList), null, {
                                          default: withCtx(() => [
                                            __props.modelValue.layout.listActions.includes("delete") ? (openBlock(), createBlock(unref(VListItem), {
                                              key: 0,
                                              "base-color": "warning",
                                              onClick: ($event) => deleteItem(childIndex)
                                            }, {
                                              prepend: withCtx(() => [
                                                createVNode(unref(VIcon), { icon: "mdi-delete" })
                                              ]),
                                              default: withCtx(() => [
                                                createTextVNode(" " + toDisplayString(__props.modelValue.messages.delete), 1)
                                              ]),
                                              _: 2
                                            }, 1032, ["onClick"])) : createCommentVNode("", true),
                                            __props.modelValue.layout.listActions.includes("duplicate") ? (openBlock(), createBlock(unref(VListItem), {
                                              key: 1,
                                              onClick: ($event) => duplicateItem(child, childIndex)
                                            }, {
                                              prepend: withCtx(() => [
                                                createVNode(unref(VIcon), { icon: "mdi-content-duplicate" })
                                              ]),
                                              default: withCtx(() => [
                                                createTextVNode(" " + toDisplayString(__props.modelValue.messages.duplicate), 1)
                                              ]),
                                              _: 2
                                            }, 1032, ["onClick"])) : createCommentVNode("", true),
                                            __props.modelValue.layout.listActions.includes("sort") ? (openBlock(), createBlock(unref(VListItem), {
                                              key: 2,
                                              onClick: ($event) => __props.statefulLayout.input(__props.modelValue, unref(moveDataItem)(__props.modelValue.data, childIndex, childIndex - 1))
                                            }, {
                                              prepend: withCtx(() => [
                                                createVNode(unref(VIcon), { icon: "mdi-arrow-up" })
                                              ]),
                                              default: withCtx(() => [
                                                createTextVNode(" " + toDisplayString(__props.modelValue.messages.up), 1)
                                              ]),
                                              _: 2
                                            }, 1032, ["onClick"])) : createCommentVNode("", true),
                                            __props.modelValue.layout.listActions.includes("sort") ? (openBlock(), createBlock(unref(VListItem), {
                                              key: 3,
                                              onClick: ($event) => __props.statefulLayout.input(__props.modelValue, unref(moveDataItem)(__props.modelValue.data, childIndex, childIndex + 1))
                                            }, {
                                              prepend: withCtx(() => [
                                                createVNode(unref(VIcon), { icon: "mdi-arrow-down" })
                                              ]),
                                              default: withCtx(() => [
                                                createTextVNode(" " + toDisplayString(__props.modelValue.messages.down), 1)
                                              ]),
                                              _: 2
                                            }, 1032, ["onClick"])) : createCommentVNode("", true)
                                          ]),
                                          _: 2
                                        }, 1024)
                                      ]),
                                      _: 2
                                    }, 1032, ["onUpdate:modelValue"])
                                  ]),
                                  _: 2
                                }, 1024)) : createCommentVNode("", true)
                              ], 64))
                            ])
                          ]),
                          key: "0"
                        } : void 0
                      ]), 1040, ["draggable", "style"]),
                      childIndex < __props.modelValue.children.length - 1 ? (openBlock(), createBlock(unref(VDivider), { key: 0 })) : createCommentVNode("", true)
                    ], 64);
                  }), 128)),
                  !__props.modelValue.options.readOnly && __props.modelValue.layout.listActions.includes("add") ? (openBlock(), createBlock(unref(VListItem), {
                    key: 1,
                    class: "py-2"
                  }, {
                    default: withCtx(() => [
                      __props.modelValue.layout.indexed ? (openBlock(), createBlock(unref(VForm), {
                        key: 0,
                        ref_key: "newKeyForm",
                        ref: newKeyForm,
                        style: { "max-width": "250px" },
                        onSubmit: _cache[2] || (_cache[2] = withModifiers(() => {
                        }, ["prevent"]))
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(VTextField), {
                            modelValue: newKey.value,
                            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => newKey.value = $event),
                            variant: "outlined",
                            placeholder: __props.modelValue.messages.addItem,
                            "hide-details": "",
                            rules: [(v) => !__props.modelValue.children.some((c) => c.key === v), (v) => {
                              var _a2;
                              return !v || ((_a2 = __props.modelValue.layout.indexed) == null ? void 0 : _a2.some((pattern2) => v.match(unref(getRegexp)(pattern2))));
                            }],
                            onKeypress: withKeys(pushEmptyIndexedItem, ["enter"])
                          }, {
                            append: withCtx(() => [
                              createVNode(unref(VIcon), {
                                color: "primary",
                                size: "large",
                                onClick: pushEmptyIndexedItem
                              }, {
                                default: withCtx(() => [
                                  createTextVNode(" mdi-plus ")
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          }, 8, ["modelValue", "placeholder", "rules"])
                        ]),
                        _: 1
                      }, 512)) : (openBlock(), createBlock(unref(VBtn), {
                        key: 1,
                        color: "primary",
                        onClick: pushEmptyItem
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(__props.modelValue.messages.addItem), 1)
                        ]),
                        _: 1
                      }))
                    ]),
                    _: 1
                  })) : createCommentVNode("", true)
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 16);
        };
      }
    };
    const makeVFileInputProps = propsFactory({
      chips: Boolean,
      counter: Boolean,
      counterSizeString: {
        type: String,
        default: "$vuetify.fileInput.counterSize"
      },
      counterString: {
        type: String,
        default: "$vuetify.fileInput.counter"
      },
      hideInput: Boolean,
      multiple: Boolean,
      showSize: {
        type: [Boolean, Number, String],
        default: false,
        validator: (v) => {
          return typeof v === "boolean" || [1e3, 1024].includes(Number(v));
        }
      },
      ...makeVInputProps({
        prependIcon: "$file"
      }),
      modelValue: {
        type: [Array, Object],
        default: (props) => props.multiple ? [] : null,
        validator: (val) => {
          return wrapInArray(val).every((v) => v != null && typeof v === "object");
        }
      },
      ...makeVFieldProps({
        clearable: true
      })
    }, "VFileInput");
    const VFileInput = genericComponent()({
      name: "VFileInput",
      inheritAttrs: false,
      props: makeVFileInputProps(),
      emits: {
        "click:control": (e) => true,
        "mousedown:control": (e) => true,
        "update:focused": (focused) => true,
        "update:modelValue": (files) => true
      },
      setup(props, _ref) {
        let {
          attrs,
          emit: emit2,
          slots
        } = _ref;
        const {
          t
        } = useLocale();
        const model = useProxiedModel(props, "modelValue", props.modelValue, (val) => wrapInArray(val), (val) => props.multiple || Array.isArray(props.modelValue) ? val : val[0] ?? null);
        const {
          isFocused,
          focus,
          blur
        } = useFocus(props);
        const base2 = computed(() => typeof props.showSize !== "boolean" ? props.showSize : void 0);
        const totalBytes = computed(() => (model.value ?? []).reduce((bytes, _ref2) => {
          let {
            size: size2 = 0
          } = _ref2;
          return bytes + size2;
        }, 0));
        const totalBytesReadable = computed(() => humanReadableFileSize(totalBytes.value, base2.value));
        const fileNames = computed(() => (model.value ?? []).map((file) => {
          const {
            name = "",
            size: size2 = 0
          } = file;
          return !props.showSize ? name : `${name} (${humanReadableFileSize(size2, base2.value)})`;
        }));
        const counterValue = computed(() => {
          var _a2;
          const fileCount = ((_a2 = model.value) == null ? void 0 : _a2.length) ?? 0;
          if (props.showSize)
            return t(props.counterSizeString, fileCount, totalBytesReadable.value);
          else
            return t(props.counterString, fileCount);
        });
        const vInputRef = ref$1();
        const vFieldRef = ref$1();
        const inputRef = ref$1();
        const isActive = computed(() => isFocused.value || props.active);
        const isPlainOrUnderlined = computed(() => ["plain", "underlined"].includes(props.variant));
        function onFocus() {
          var _a2;
          if (inputRef.value !== document.activeElement) {
            (_a2 = inputRef.value) == null ? void 0 : _a2.focus();
          }
          if (!isFocused.value)
            focus();
        }
        function onClickPrepend(e) {
          var _a2;
          (_a2 = inputRef.value) == null ? void 0 : _a2.click();
        }
        function onControlMousedown(e) {
          emit2("mousedown:control", e);
        }
        function onControlClick(e) {
          var _a2;
          (_a2 = inputRef.value) == null ? void 0 : _a2.click();
          emit2("click:control", e);
        }
        function onClear(e) {
          e.stopPropagation();
          onFocus();
          nextTick(() => {
            model.value = [];
            callEvent(props["onClick:clear"], e);
          });
        }
        watch(model, (newValue) => {
          const hasModelReset = !Array.isArray(newValue) || !newValue.length;
          if (hasModelReset && inputRef.value) {
            inputRef.value.value = "";
          }
        });
        useRender(() => {
          const hasCounter = !!(slots.counter || props.counter);
          const hasDetails = !!(hasCounter || slots.details);
          const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
          const {
            modelValue: _,
            ...inputProps
          } = VInput.filterProps(props);
          const fieldProps = filterFieldProps(props);
          return createVNode(VInput, mergeProps({
            "ref": vInputRef,
            "modelValue": model.value,
            "onUpdate:modelValue": ($event) => model.value = $event,
            "class": ["v-file-input", {
              "v-file-input--chips": !!props.chips,
              "v-file-input--hide": props.hideInput,
              "v-input--plain-underlined": isPlainOrUnderlined.value
            }, props.class],
            "style": props.style,
            "onClick:prepend": onClickPrepend
          }, rootAttrs, inputProps, {
            "centerAffix": !isPlainOrUnderlined.value,
            "focused": isFocused.value
          }), {
            ...slots,
            default: (_ref3) => {
              let {
                id: id2,
                isDisabled,
                isDirty,
                isReadonly: isReadonly2,
                isValid: isValid2
              } = _ref3;
              return createVNode(VField, mergeProps({
                "ref": vFieldRef,
                "prepend-icon": props.prependIcon,
                "onMousedown": onControlMousedown,
                "onClick": onControlClick,
                "onClick:clear": onClear,
                "onClick:prependInner": props["onClick:prependInner"],
                "onClick:appendInner": props["onClick:appendInner"]
              }, fieldProps, {
                "id": id2.value,
                "active": isActive.value || isDirty.value,
                "dirty": isDirty.value || props.dirty,
                "disabled": isDisabled.value,
                "focused": isFocused.value,
                "error": isValid2.value === false
              }), {
                ...slots,
                default: (_ref4) => {
                  var _a2;
                  let {
                    props: {
                      class: fieldClass,
                      ...slotProps
                    }
                  } = _ref4;
                  return createVNode(Fragment, null, [createVNode("input", mergeProps({
                    "ref": inputRef,
                    "type": "file",
                    "readonly": isReadonly2.value,
                    "disabled": isDisabled.value,
                    "multiple": props.multiple,
                    "name": props.name,
                    "onClick": (e) => {
                      e.stopPropagation();
                      if (isReadonly2.value)
                        e.preventDefault();
                      onFocus();
                    },
                    "onChange": (e) => {
                      if (!e.target)
                        return;
                      const target2 = e.target;
                      model.value = [...target2.files ?? []];
                    },
                    "onFocus": onFocus,
                    "onBlur": blur
                  }, slotProps, inputAttrs), null), createVNode("div", {
                    "class": fieldClass
                  }, [!!((_a2 = model.value) == null ? void 0 : _a2.length) && !props.hideInput && (slots.selection ? slots.selection({
                    fileNames: fileNames.value,
                    totalBytes: totalBytes.value,
                    totalBytesReadable: totalBytesReadable.value
                  }) : props.chips ? fileNames.value.map((text2) => createVNode(VChip, {
                    "key": text2,
                    "size": "small",
                    "text": text2
                  }, null)) : fileNames.value.join(", "))])]);
                }
              });
            },
            details: hasDetails ? (slotProps) => {
              var _a2, _b;
              return createVNode(Fragment, null, [(_a2 = slots.details) == null ? void 0 : _a2.call(slots, slotProps), hasCounter && createVNode(Fragment, null, [createVNode("span", null, null), createVNode(VCounter, {
                "active": !!((_b = model.value) == null ? void 0 : _b.length),
                "value": counterValue.value,
                "disabled": props.disabled
              }, slots.counter)])]);
            } : void 0
          });
        });
        return forwardRefs({}, vInputRef, vFieldRef, inputRef);
      }
    });
    const _sfc_main$5 = /* @__PURE__ */ defineComponent$1({
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfFileInputNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(props) {
        useDefaults({}, "VjsfFileInput");
        const fieldProps = computed(() => {
          const fieldProps2 = getInputProps(props.modelValue, props.statefulLayout, ["placeholder", "accept"]);
          if (props.modelValue.layout.multiple) {
            fieldProps2.multiple = true;
          } else {
            fieldProps2.modelValue = props.modelValue.data ? [props.modelValue.data] : props.modelValue.data;
            fieldProps2["onUpdate:modelValue"] = (value) => props.statefulLayout.input(props.modelValue, Array.isArray(value) ? value[0] : value);
          }
          return fieldProps2;
        });
        const fieldSlots = computed(() => getCompSlots(props.modelValue, props.statefulLayout));
        return () => h(VFileInput, fieldProps.value, fieldSlots.value);
      }
    });
    const _sfc_main$4 = {
      __name: "card",
      props: {
        modelValue: {
          /** @type import('vue').PropType<import('../../types.js').VjsfCardNode> */
          type: Object,
          required: true
        },
        statefulLayout: {
          /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
          type: Object,
          required: true
        }
      },
      setup(__props) {
        useDefaults({}, "VjsfCard");
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(VCard), {
            title: __props.modelValue.layout.title ?? ""
          }, {
            default: withCtx(() => [
              createVNode(unref(VContainer), { fluid: "" }, {
                default: withCtx(() => {
                  var _a2, _b;
                  return [
                    createVNode(_sfc_main$A, {
                      node: __props.modelValue,
                      "hide-title": ""
                    }, null, 8, ["node"]),
                    createVNode(unref(VRow), {
                      dense: ((_a2 = __props.modelValue.options) == null ? void 0 : _a2.density) === "compact" || ((_b = __props.modelValue.options) == null ? void 0 : _b.density) === "comfortable"
                    }, {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(__props.modelValue.children, (child) => {
                          return openBlock(), createBlock(_sfc_main$C, {
                            key: child.fullKey,
                            "model-value": (
                              /** @type import('../../types.js').VjsfNode */
                              child
                            ),
                            "stateful-layout": __props.statefulLayout
                          }, null, 8, ["model-value", "stateful-layout"]);
                        }), 128))
                      ]),
                      _: 1
                    }, 8, ["dense"])
                  ];
                }),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["title"]);
        };
      }
    };
    const _sfc_main$3 = {
      __name: "vjsf",
      props: {
        schema: {
          type: Object,
          required: true
        },
        precompiledLayout: {
          /** @type import('vue').PropType<import('@json-layout/core').CompiledLayout> */
          type: Object,
          default: null
        },
        modelValue: {
          type: null,
          default: null
        },
        options: {
          /** @type import('vue').PropType<import('../types.js').PartialVjsfOptions | null> */
          type: Object,
          default: null
        }
      },
      emits,
      setup(__props, { emit: __emit }) {
        const nodeComponents = {
          section: _sfc_main$z,
          "text-field": _sfc_main$v,
          textarea: _sfc_main$u,
          checkbox: _sfc_main$t,
          switch: _sfc_main$s,
          "number-field": _sfc_main$r,
          slider: _sfc_main$q,
          "date-picker": _sfc_main$o,
          "time-picker": _sfc_main$n,
          "date-time-picker": _sfc_main$m,
          "color-picker": _sfc_main$l,
          select: _sfc_main$k,
          autocomplete: _sfc_main$j,
          "radio-group": _sfc_main$i,
          "checkbox-group": _sfc_main$g,
          "switch-group": _sfc_main$f,
          "one-of-select": _sfc_main$e,
          tabs: _sfc_main$c,
          "vertical-tabs": _sfc_main$b,
          "expansion-panels": _sfc_main$8,
          stepper: _sfc_main$7,
          list: _sfc_main$6,
          combobox: _sfc_main$a,
          "number-combobox": _sfc_main$9,
          "file-input": _sfc_main$5,
          card: _sfc_main$4
        };
        const props = __props;
        const emit2 = __emit;
        const { el: el2, statefulLayout, stateTree } = useVjsf(
          computed(() => props.schema),
          computed(() => props.modelValue),
          computed(() => props.options),
          nodeComponents,
          emit2,
          compile,
          computed(() => props.precompiledLayout)
        );
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref_key: "el",
            ref: el2,
            class: "vjsf"
          }, [
            unref(statefulLayout) && unref(stateTree) ? (openBlock(), createBlock(_sfc_main$B, {
              key: 0,
              "model-value": unref(stateTree),
              "stateful-layout": unref(statefulLayout)
            }, null, 8, ["model-value", "stateful-layout"])) : createCommentVNode("", true)
          ], 512);
        };
      }
    };
    const _sfc_main$2 = /* @__PURE__ */ defineComponent$1({
      __name: "IconButtonWithTooltip",
      props: {
        title: {},
        icon: {},
        variant: {},
        density: {}
      },
      emits: ["click"],
      setup(__props, { emit: __emit }) {
        const props = __props;
        const emit2 = __emit;
        return (_ctx, _cache) => {
          return openBlock(), createBlock(VTooltip, { location: "bottom" }, {
            activator: withCtx(({ props: props2 }) => [
              createVNode(VBtn, mergeProps(props2, {
                icon: _ctx.icon,
                class: "icon-right",
                onClick: _cache[0] || (_cache[0] = ($event) => emit2("click")),
                variant: _ctx.variant,
                density: _ctx.density
              }), null, 16, ["icon", "variant", "density"])
            ]),
            default: withCtx(() => [
              createBaseVNode("span", null, toDisplayString(props.title), 1)
            ]),
            _: 1
          });
        };
      }
    });
    const IconButtonWithTooltip = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-6395d6b5"]]);
    const _sfc_main$1 = /* @__PURE__ */ defineComponent$1({
      components: {
        Vjsf: _sfc_main$3,
        IconButtonWithTooltip
      },
      setup() {
        const evbcStore2 = useEvbcStore();
        const { current_config } = storeToRefs(evbcStore2);
        const module_node = computed(() => {
          const instance_id = evbcStore2.get_selected_module_instance();
          if (instance_id === null) {
            return null;
          }
          const instance = current_config.value.get_module_instance(instance_id);
          return {
            instance_id,
            instance
          };
        });
        const terminal = computed(() => {
          return evbcStore2.get_selected_terminal();
        });
        const connection = computed(() => {
          const connection_id = evbcStore2.get_selected_connection();
          if (connection_id === null) {
            return null;
          }
          const cxn = current_config.value.get_connection(connection_id);
          const requiring_module = current_config.value.get_module_instance(cxn.requiring_instance_id);
          const implementing_module = current_config.value.get_module_instance(cxn.providing_instance_id);
          return {
            from: {
              type: implementing_module.type,
              id: implementing_module.id,
              name: cxn.providing_impl_name
            },
            to: {
              type: requiring_module.type,
              id: requiring_module.id,
              name: cxn.requirement_name
            },
            id: connection_id
          };
        });
        const context = computed(() => {
          return evbcStore2.config_context;
        });
        const moduleIDRules = computed(() => {
          return [
            (v) => {
              const instance_id = module_node.value.instance_id;
              const result = current_config.value.update_module_id(instance_id, v);
              return result || "This module id is not available";
            }
          ];
        });
        function delete_connection(id2) {
          current_config.value.delete_connection(id2);
        }
        function delete_module_instance(id2) {
          current_config.value.delete_module_instance(id2);
        }
        return {
          module_node,
          terminal,
          current_config,
          connection,
          context,
          moduleIDRules,
          delete_connection,
          delete_module_instance
        };
      }
    });
    const _hoisted_1 = { class: "font-weight-bold" };
    const _hoisted_2 = /* @__PURE__ */ createBaseVNode("p", { class: "font-weight-bold" }, "Module configuration", -1);
    const _hoisted_3 = /* @__PURE__ */ createBaseVNode("p", { class: "font-weight-bold" }, "Implementation configurations", -1);
    function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_icon_button_with_tooltip = resolveComponent("icon-button-with-tooltip");
      const _component_vjsf = resolveComponent("vjsf");
      return _ctx.module_node ? (openBlock(), createBlock(VCard, {
        key: 0,
        title: "Module instance information"
      }, {
        append: withCtx(() => [
          createVNode(_component_icon_button_with_tooltip, {
            icon: "mdi-close",
            title: "Discard selection",
            variant: "text",
            density: "compact",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.context.unselect())
          })
        ]),
        default: withCtx(() => [
          createVNode(VCardText, null, {
            default: withCtx(() => {
              var _a2, _b;
              return [
                createBaseVNode("p", _hoisted_1, "Module type: " + toDisplayString((_b = (_a2 = _ctx.module_node) == null ? void 0 : _a2.instance) == null ? void 0 : _b.type), 1),
                createVNode(VForm, {
                  onSubmit: _cache[1] || (_cache[1] = withModifiers(() => {
                  }, ["prevent"]))
                }, {
                  default: withCtx(() => {
                    var _a3;
                    return [
                      createVNode(VTextField, {
                        "model-value": (_a3 = _ctx.module_node) == null ? void 0 : _a3.instance.id,
                        label: "Module ID",
                        rules: _ctx.moduleIDRules
                      }, null, 8, ["model-value", "rules"])
                    ];
                  }),
                  _: 1
                }),
                createVNode(VForm, {
                  onSubmit: _cache[2] || (_cache[2] = withModifiers(() => {
                  }, ["prevent"]))
                }, {
                  default: withCtx(() => [
                    _ctx.module_node.instance.module_config ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      createVNode(VDivider),
                      _hoisted_2,
                      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.module_node.instance.module_config, (item, index) => {
                        return openBlock(), createBlock(_component_vjsf, {
                          key: index,
                          modelValue: item.model,
                          "onUpdate:modelValue": ($event) => item.model = $event,
                          schema: item.schema
                        }, null, 8, ["modelValue", "onUpdate:modelValue", "schema"]);
                      }), 128))
                    ], 64)) : createCommentVNode("", true),
                    _ctx.module_node.instance.implementation_config ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createVNode(VDivider),
                      _hoisted_3,
                      createVNode(VExpansionPanels, null, {
                        default: withCtx(() => [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.module_node.instance.implementation_config, (impl_config, id2) => {
                            return openBlock(), createBlock(VExpansionPanel, { key: id2 }, {
                              default: withCtx(() => [
                                createVNode(VExpansionPanelTitle, null, {
                                  default: withCtx(() => [
                                    createTextVNode(toDisplayString(id2), 1)
                                  ]),
                                  _: 2
                                }, 1024),
                                createVNode(VExpansionPanelText, null, {
                                  default: withCtx(() => [
                                    (openBlock(true), createElementBlock(Fragment, null, renderList(impl_config, (item, index) => {
                                      return openBlock(), createBlock(_component_vjsf, {
                                        key: index,
                                        modelValue: item.model,
                                        "onUpdate:modelValue": ($event) => item.model = $event,
                                        schema: item.schema
                                      }, null, 8, ["modelValue", "onUpdate:modelValue", "schema"]);
                                    }), 128))
                                  ]),
                                  _: 2
                                }, 1024)
                              ]),
                              _: 2
                            }, 1024);
                          }), 128))
                        ]),
                        _: 1
                      })
                    ], 64)) : createCommentVNode("", true)
                  ]),
                  _: 1
                })
              ];
            }),
            _: 1
          }),
          createVNode(VCardActions, null, {
            default: withCtx(() => [
              createVNode(_component_icon_button_with_tooltip, {
                icon: "mdi-delete",
                title: "Delete instance",
                onClick: _cache[3] || (_cache[3] = ($event) => _ctx.delete_module_instance(_ctx.module_node.instance_id))
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      })) : _ctx.connection ? (openBlock(), createBlock(VCard, { key: 1 }, {
        default: withCtx(() => [
          createVNode(VCardTitle, null, {
            default: withCtx(() => [
              createTextVNode(" Connection "),
              createVNode(_component_icon_button_with_tooltip, {
                icon: "mdi-close",
                title: "Discard selection",
                variant: "text",
                density: "compact",
                onClick: _cache[4] || (_cache[4] = ($event) => _ctx.context.unselect())
              })
            ]),
            _: 1
          }),
          createVNode(VCardText, null, {
            default: withCtx(() => [
              createTextVNode(" The requirement "),
              createBaseVNode("code", null, toDisplayString(_ctx.connection.to.name), 1),
              createTextVNode(" of "),
              createBaseVNode("code", null, toDisplayString(_ctx.connection.to.id), 1),
              createTextVNode(" is fulfilled by implementation "),
              createBaseVNode("code", null, toDisplayString(_ctx.connection.from.name), 1),
              createTextVNode(" of "),
              createBaseVNode("code", null, toDisplayString(_ctx.connection.from.id), 1)
            ]),
            _: 1
          }),
          createVNode(VCardActions, null, {
            default: withCtx(() => [
              createVNode(_component_icon_button_with_tooltip, {
                icon: "mdi-delete",
                title: "Delete connection",
                onClick: _cache[5] || (_cache[5] = ($event) => _ctx.delete_connection(_ctx.connection.id))
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      })) : _ctx.terminal ? (openBlock(), createBlock(VCard, { key: 2 }, {
        default: withCtx(() => [
          createVNode(VCardTitle, null, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.terminal.type === "provide" ? "Implementation" : "Requirement") + ": ", 1),
              createBaseVNode("code", null, toDisplayString(_ctx.terminal.id), 1),
              createVNode(_component_icon_button_with_tooltip, {
                icon: "mdi-close",
                title: "Discard selection",
                variant: "text",
                density: "compact",
                onClick: _cache[6] || (_cache[6] = ($event) => _ctx.context.unselect())
              })
            ]),
            _: 1
          }),
          createVNode(VCardText, null, {
            default: withCtx(() => [
              createTextVNode(" Interface type: "),
              createBaseVNode("code", null, toDisplayString(_ctx.terminal.interface), 1)
            ]),
            _: 1
          })
        ]),
        _: 1
      })) : createCommentVNode("", true);
    }
    const EvModuleInfo = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
    const M = {
      name: "splitpanes",
      emits: ["ready", "resize", "resized", "pane-click", "pane-maximize", "pane-add", "pane-remove", "splitter-click"],
      props: {
        horizontal: { type: Boolean },
        pushOtherPanes: { type: Boolean, default: true },
        dblClickSplitter: { type: Boolean, default: true },
        rtl: { type: Boolean, default: false },
        firstSplitter: { type: Boolean }
      },
      provide() {
        return {
          requestUpdate: this.requestUpdate,
          onPaneAdd: this.onPaneAdd,
          onPaneRemove: this.onPaneRemove,
          onPaneClick: this.onPaneClick
        };
      },
      data: () => ({
        container: null,
        ready: false,
        panes: [],
        touch: {
          mouseDown: false,
          dragging: false,
          activeSplitter: null
        },
        splitterTaps: {
          splitter: null,
          timeoutId: null
        }
      }),
      computed: {
        panesCount() {
          return this.panes.length;
        },
        indexedPanes() {
          return this.panes.reduce((e, i2) => (e[i2.id] = i2) && e, {});
        }
      },
      methods: {
        updatePaneComponents() {
          this.panes.forEach((e) => {
            e.update && e.update({
              [this.horizontal ? "height" : "width"]: `${this.indexedPanes[e.id].size}%`
            });
          });
        },
        bindEvents() {
          document.addEventListener("mousemove", this.onMouseMove, { passive: false }), document.addEventListener("mouseup", this.onMouseUp), "ontouchstart" in window && (document.addEventListener("touchmove", this.onMouseMove, { passive: false }), document.addEventListener("touchend", this.onMouseUp));
        },
        unbindEvents() {
          document.removeEventListener("mousemove", this.onMouseMove, { passive: false }), document.removeEventListener("mouseup", this.onMouseUp), "ontouchstart" in window && (document.removeEventListener("touchmove", this.onMouseMove, { passive: false }), document.removeEventListener("touchend", this.onMouseUp));
        },
        onMouseDown(e, i2) {
          this.bindEvents(), this.touch.mouseDown = true, this.touch.activeSplitter = i2;
        },
        onMouseMove(e) {
          this.touch.mouseDown && (e.preventDefault(), this.touch.dragging = true, this.calculatePanesSize(this.getCurrentMouseDrag(e)), this.$emit("resize", this.panes.map((i2) => ({ min: i2.min, max: i2.max, size: i2.size }))));
        },
        onMouseUp() {
          this.touch.dragging && this.$emit("resized", this.panes.map((e) => ({ min: e.min, max: e.max, size: e.size }))), this.touch.mouseDown = false, setTimeout(() => {
            this.touch.dragging = false, this.unbindEvents();
          }, 100);
        },
        onSplitterClick(e, i2) {
          "ontouchstart" in window && (e.preventDefault(), this.dblClickSplitter && (this.splitterTaps.splitter === i2 ? (clearTimeout(this.splitterTaps.timeoutId), this.splitterTaps.timeoutId = null, this.onSplitterDblClick(e, i2), this.splitterTaps.splitter = null) : (this.splitterTaps.splitter = i2, this.splitterTaps.timeoutId = setTimeout(() => {
            this.splitterTaps.splitter = null;
          }, 500)))), this.touch.dragging || this.$emit("splitter-click", this.panes[i2]);
        },
        onSplitterDblClick(e, i2) {
          let s = 0;
          this.panes = this.panes.map((n, t) => (n.size = t === i2 ? n.max : n.min, t !== i2 && (s += n.min), n)), this.panes[i2].size -= s, this.$emit("pane-maximize", this.panes[i2]), this.$emit("resized", this.panes.map((n) => ({ min: n.min, max: n.max, size: n.size })));
        },
        onPaneClick(e, i2) {
          this.$emit("pane-click", this.indexedPanes[i2]);
        },
        getCurrentMouseDrag(e) {
          const i2 = this.container.getBoundingClientRect(), { clientX: s, clientY: n } = "ontouchstart" in window && e.touches ? e.touches[0] : e;
          return {
            x: s - i2.left,
            y: n - i2.top
          };
        },
        getCurrentDragPercentage(e) {
          e = e[this.horizontal ? "y" : "x"];
          const i2 = this.container[this.horizontal ? "clientHeight" : "clientWidth"];
          return this.rtl && !this.horizontal && (e = i2 - e), e * 100 / i2;
        },
        calculatePanesSize(e) {
          const i2 = this.touch.activeSplitter;
          let s = {
            prevPanesSize: this.sumPrevPanesSize(i2),
            nextPanesSize: this.sumNextPanesSize(i2),
            prevReachedMinPanes: 0,
            nextReachedMinPanes: 0
          };
          const n = 0 + (this.pushOtherPanes ? 0 : s.prevPanesSize), t = 100 - (this.pushOtherPanes ? 0 : s.nextPanesSize), a = Math.max(Math.min(this.getCurrentDragPercentage(e), t), n);
          let r2 = [i2, i2 + 1], o2 = this.panes[r2[0]] || null, h2 = this.panes[r2[1]] || null;
          const l = o2.max < 100 && a >= o2.max + s.prevPanesSize, u = h2.max < 100 && a <= 100 - (h2.max + this.sumNextPanesSize(i2 + 1));
          if (l || u) {
            l ? (o2.size = o2.max, h2.size = Math.max(100 - o2.max - s.prevPanesSize - s.nextPanesSize, 0)) : (o2.size = Math.max(100 - h2.max - s.prevPanesSize - this.sumNextPanesSize(i2 + 1), 0), h2.size = h2.max);
            return;
          }
          if (this.pushOtherPanes) {
            const d = this.doPushOtherPanes(s, a);
            if (!d)
              return;
            ({ sums: s, panesToResize: r2 } = d), o2 = this.panes[r2[0]] || null, h2 = this.panes[r2[1]] || null;
          }
          o2 !== null && (o2.size = Math.min(Math.max(a - s.prevPanesSize - s.prevReachedMinPanes, o2.min), o2.max)), h2 !== null && (h2.size = Math.min(Math.max(100 - a - s.nextPanesSize - s.nextReachedMinPanes, h2.min), h2.max));
        },
        doPushOtherPanes(e, i2) {
          const s = this.touch.activeSplitter, n = [s, s + 1];
          return i2 < e.prevPanesSize + this.panes[n[0]].min && (n[0] = this.findPrevExpandedPane(s).index, e.prevReachedMinPanes = 0, n[0] < s && this.panes.forEach((t, a) => {
            a > n[0] && a <= s && (t.size = t.min, e.prevReachedMinPanes += t.min);
          }), e.prevPanesSize = this.sumPrevPanesSize(n[0]), n[0] === void 0) ? (e.prevReachedMinPanes = 0, this.panes[0].size = this.panes[0].min, this.panes.forEach((t, a) => {
            a > 0 && a <= s && (t.size = t.min, e.prevReachedMinPanes += t.min);
          }), this.panes[n[1]].size = 100 - e.prevReachedMinPanes - this.panes[0].min - e.prevPanesSize - e.nextPanesSize, null) : i2 > 100 - e.nextPanesSize - this.panes[n[1]].min && (n[1] = this.findNextExpandedPane(s).index, e.nextReachedMinPanes = 0, n[1] > s + 1 && this.panes.forEach((t, a) => {
            a > s && a < n[1] && (t.size = t.min, e.nextReachedMinPanes += t.min);
          }), e.nextPanesSize = this.sumNextPanesSize(n[1] - 1), n[1] === void 0) ? (e.nextReachedMinPanes = 0, this.panes[this.panesCount - 1].size = this.panes[this.panesCount - 1].min, this.panes.forEach((t, a) => {
            a < this.panesCount - 1 && a >= s + 1 && (t.size = t.min, e.nextReachedMinPanes += t.min);
          }), this.panes[n[0]].size = 100 - e.prevPanesSize - e.nextReachedMinPanes - this.panes[this.panesCount - 1].min - e.nextPanesSize, null) : { sums: e, panesToResize: n };
        },
        sumPrevPanesSize(e) {
          return this.panes.reduce((i2, s, n) => i2 + (n < e ? s.size : 0), 0);
        },
        sumNextPanesSize(e) {
          return this.panes.reduce((i2, s, n) => i2 + (n > e + 1 ? s.size : 0), 0);
        },
        findPrevExpandedPane(e) {
          return [...this.panes].reverse().find((s) => s.index < e && s.size > s.min) || {};
        },
        findNextExpandedPane(e) {
          return this.panes.find((s) => s.index > e + 1 && s.size > s.min) || {};
        },
        checkSplitpanesNodes() {
          Array.from(this.container.children).forEach((i2) => {
            const s = i2.classList.contains("splitpanes__pane"), n = i2.classList.contains("splitpanes__splitter");
            !s && !n && (i2.parentNode.removeChild(i2), console.warn("Splitpanes: Only <pane> elements are allowed at the root of <splitpanes>. One of your DOM nodes was removed."));
          });
        },
        addSplitter(e, i2, s = false) {
          const n = e - 1, t = document.createElement("div");
          t.classList.add("splitpanes__splitter"), s || (t.onmousedown = (a) => this.onMouseDown(a, n), typeof window < "u" && "ontouchstart" in window && (t.ontouchstart = (a) => this.onMouseDown(a, n)), t.onclick = (a) => this.onSplitterClick(a, n + 1)), this.dblClickSplitter && (t.ondblclick = (a) => this.onSplitterDblClick(a, n + 1)), i2.parentNode.insertBefore(t, i2);
        },
        removeSplitter(e) {
          e.onmousedown = void 0, e.onclick = void 0, e.ondblclick = void 0, e.parentNode.removeChild(e);
        },
        redoSplitters() {
          const e = Array.from(this.container.children);
          e.forEach((s) => {
            s.className.includes("splitpanes__splitter") && this.removeSplitter(s);
          });
          let i2 = 0;
          e.forEach((s) => {
            s.className.includes("splitpanes__pane") && (!i2 && this.firstSplitter ? this.addSplitter(i2, s, true) : i2 && this.addSplitter(i2, s), i2++);
          });
        },
        requestUpdate({ target: e, ...i2 }) {
          const s = this.indexedPanes[e._.uid];
          Object.entries(i2).forEach(([n, t]) => s[n] = t);
        },
        onPaneAdd(e) {
          let i2 = -1;
          Array.from(e.$el.parentNode.children).some((t) => (t.className.includes("splitpanes__pane") && i2++, t === e.$el));
          const s = parseFloat(e.minSize), n = parseFloat(e.maxSize);
          this.panes.splice(i2, 0, {
            id: e._.uid,
            index: i2,
            min: isNaN(s) ? 0 : s,
            max: isNaN(n) ? 100 : n,
            size: e.size === null ? null : parseFloat(e.size),
            givenSize: e.size,
            update: e.update
          }), this.panes.forEach((t, a) => t.index = a), this.ready && this.$nextTick(() => {
            this.redoSplitters(), this.resetPaneSizes({ addedPane: this.panes[i2] }), this.$emit("pane-add", { index: i2, panes: this.panes.map((t) => ({ min: t.min, max: t.max, size: t.size })) });
          });
        },
        onPaneRemove(e) {
          const i2 = this.panes.findIndex((n) => n.id === e._.uid), s = this.panes.splice(i2, 1)[0];
          this.panes.forEach((n, t) => n.index = t), this.$nextTick(() => {
            this.redoSplitters(), this.resetPaneSizes({ removedPane: { ...s, index: i2 } }), this.$emit("pane-remove", { removed: s, panes: this.panes.map((n) => ({ min: n.min, max: n.max, size: n.size })) });
          });
        },
        resetPaneSizes(e = {}) {
          !e.addedPane && !e.removedPane ? this.initialPanesSizing() : this.panes.some((i2) => i2.givenSize !== null || i2.min || i2.max < 100) ? this.equalizeAfterAddOrRemove(e) : this.equalize(), this.ready && this.$emit("resized", this.panes.map((i2) => ({ min: i2.min, max: i2.max, size: i2.size })));
        },
        equalize() {
          const e = 100 / this.panesCount;
          let i2 = 0;
          const s = [], n = [];
          this.panes.forEach((t) => {
            t.size = Math.max(Math.min(e, t.max), t.min), i2 -= t.size, t.size >= t.max && s.push(t.id), t.size <= t.min && n.push(t.id);
          }), i2 > 0.1 && this.readjustSizes(i2, s, n);
        },
        initialPanesSizing() {
          let e = 100;
          const i2 = [], s = [];
          let n = 0;
          this.panes.forEach((a) => {
            e -= a.size, a.size !== null && n++, a.size >= a.max && i2.push(a.id), a.size <= a.min && s.push(a.id);
          });
          let t = 100;
          e > 0.1 && (this.panes.forEach((a) => {
            a.size === null && (a.size = Math.max(Math.min(e / (this.panesCount - n), a.max), a.min)), t -= a.size;
          }), t > 0.1 && this.readjustSizes(e, i2, s));
        },
        equalizeAfterAddOrRemove({ addedPane: e, removedPane: i2 } = {}) {
          let s = 100 / this.panesCount, n = 0;
          const t = [], a = [];
          e && e.givenSize !== null && (s = (100 - e.givenSize) / (this.panesCount - 1)), this.panes.forEach((r2) => {
            n -= r2.size, r2.size >= r2.max && t.push(r2.id), r2.size <= r2.min && a.push(r2.id);
          }), !(Math.abs(n) < 0.1) && (this.panes.forEach((r2) => {
            e && e.givenSize !== null && e.id === r2.id || (r2.size = Math.max(Math.min(s, r2.max), r2.min)), n -= r2.size, r2.size >= r2.max && t.push(r2.id), r2.size <= r2.min && a.push(r2.id);
          }), n > 0.1 && this.readjustSizes(n, t, a));
        },
        readjustSizes(e, i2, s) {
          let n;
          e > 0 ? n = e / (this.panesCount - i2.length) : n = e / (this.panesCount - s.length), this.panes.forEach((t, a) => {
            if (e > 0 && !i2.includes(t.id)) {
              const r2 = Math.max(Math.min(t.size + n, t.max), t.min), o2 = r2 - t.size;
              e -= o2, t.size = r2;
            } else if (!s.includes(t.id)) {
              const r2 = Math.max(Math.min(t.size + n, t.max), t.min), o2 = r2 - t.size;
              e -= o2, t.size = r2;
            }
            t.update({
              [this.horizontal ? "height" : "width"]: `${this.indexedPanes[t.id].size}%`
            });
          }), Math.abs(e) > 0.1 && this.$nextTick(() => {
            this.ready && console.warn("Splitpanes: Could not resize panes correctly due to their constraints.");
          });
        }
      },
      watch: {
        panes: {
          deep: true,
          immediate: false,
          handler() {
            this.updatePaneComponents();
          }
        },
        horizontal() {
          this.updatePaneComponents();
        },
        firstSplitter() {
          this.redoSplitters();
        },
        dblClickSplitter(e) {
          [...this.container.querySelectorAll(".splitpanes__splitter")].forEach((s, n) => {
            s.ondblclick = e ? (t) => this.onSplitterDblClick(t, n) : void 0;
          });
        }
      },
      beforeUnmount() {
        this.ready = false;
      },
      mounted() {
        this.container = this.$refs.container, this.checkSplitpanesNodes(), this.redoSplitters(), this.resetPaneSizes(), this.$emit("ready"), this.ready = true;
      },
      render() {
        return h(
          "div",
          {
            ref: "container",
            class: [
              "splitpanes",
              `splitpanes--${this.horizontal ? "horizontal" : "vertical"}`,
              {
                "splitpanes--dragging": this.touch.dragging
              }
            ]
          },
          this.$slots.default()
        );
      }
    }, S = (e, i2) => {
      const s = e.__vccOpts || e;
      for (const [n, t] of i2)
        s[n] = t;
      return s;
    }, x = {
      name: "pane",
      inject: ["requestUpdate", "onPaneAdd", "onPaneRemove", "onPaneClick"],
      props: {
        size: { type: [Number, String], default: null },
        minSize: { type: [Number, String], default: 0 },
        maxSize: { type: [Number, String], default: 100 }
      },
      data: () => ({
        style: {}
      }),
      mounted() {
        this.onPaneAdd(this);
      },
      beforeUnmount() {
        this.onPaneRemove(this);
      },
      methods: {
        update(e) {
          this.style = e;
        }
      },
      computed: {
        sizeNumber() {
          return this.size || this.size === 0 ? parseFloat(this.size) : null;
        },
        minSizeNumber() {
          return parseFloat(this.minSize);
        },
        maxSizeNumber() {
          return parseFloat(this.maxSize);
        }
      },
      watch: {
        sizeNumber(e) {
          this.requestUpdate({ target: this, size: e });
        },
        minSizeNumber(e) {
          this.requestUpdate({ target: this, min: e });
        },
        maxSizeNumber(e) {
          this.requestUpdate({ target: this, max: e });
        }
      }
    };
    function P(e, i2, s, n, t, a) {
      return openBlock(), createElementBlock("div", {
        class: "splitpanes__pane",
        onClick: i2[0] || (i2[0] = (r2) => a.onPaneClick(r2, e._.uid)),
        style: normalizeStyle(e.style)
      }, [
        renderSlot(e.$slots, "default")
      ], 4);
    }
    const g = /* @__PURE__ */ S(x, [["render", P]]);
    const _sfc_main = /* @__PURE__ */ defineComponent$1({
      components: {
        EvConfigCanvas,
        EvModuleList,
        EvModuleInfo,
        Splitpanes: M,
        Pane: g
      },
      methods: {
        on_splitpanes_resize() {
          window.dispatchEvent(new Event("resize"));
        }
      }
    });
    function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ev_module_list = resolveComponent("ev-module-list");
      const _component_pane = resolveComponent("pane");
      const _component_ev_config_canvas = resolveComponent("ev-config-canvas");
      const _component_ev_module_info = resolveComponent("ev-module-info");
      const _component_splitpanes = resolveComponent("splitpanes");
      return openBlock(), createBlock(VContainer, {
        fluid: "",
        class: "fill-height px-0 py-0"
      }, {
        default: withCtx(() => [
          createVNode(_component_splitpanes, {
            class: "default-theme",
            style: { "height": "calc(100vh - 64px)" },
            onResize: _ctx.on_splitpanes_resize
          }, {
            default: withCtx(() => [
              createVNode(_component_pane, { size: "15" }, {
                default: withCtx(() => [
                  createVNode(_component_ev_module_list)
                ]),
                _: 1
              }),
              createVNode(_component_pane, { size: "70" }, {
                default: withCtx(() => [
                  createVNode(_component_ev_config_canvas)
                ]),
                _: 1
              }),
              createVNode(_component_pane, { size: "15" }, {
                default: withCtx(() => [
                  createVNode(_component_ev_module_info)
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["onResize"])
        ]),
        _: 1
      });
    }
    const ConfigPage = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__scopeId", "data-v-a690e077"]]);
    const routes = [
      {
        path: "/connect",
        name: "connect",
        component: ConnectPage
      },
      {
        path: "/",
        name: "main",
        component: MainPanel,
        children: [
          {
            path: "config",
            component: ConfigPage
          }
        ],
        meta: { requiresConnection: true }
      }
    ];
    const router = createRouter({
      history: createWebHashHistory("/everest-admin-panel/pr-181"),
      routes
    });
    router.beforeEach((to, from, next2) => {
      const evbc2 = inject$1("evbc");
      const userIsConnected = evbc2 == null ? void 0 : evbc2.initialized;
      if (to.path === "/" && userIsConnected) {
        next2("/config");
      } else if (to.matched.some((record) => record.meta.requiresConnection)) {
        if (userIsConnected) {
          next2();
        } else {
          next2("/connect");
        }
      } else {
        next2();
      }
    });
    function generate_interface_parents_map(interface_definitions) {
      const interface_parents = {};
      Object.keys(interface_definitions).forEach((interface_name) => {
        const parents = /* @__PURE__ */ new Set();
        function recurse(name) {
          const parent = interface_definitions[name].parent;
          if (parent) {
            parents.add(parent);
            recurse(parent);
          }
        }
        recurse(interface_name);
        interface_parents[interface_name] = parents;
      });
      return interface_parents;
    }
    function default_terminals(module_definition) {
      const left_terminals = [];
      if (module_definition.requires) {
        Object.entries(module_definition.requires).forEach(
          ([key, value]) => left_terminals.push(
            Object.freeze({
              id: key,
              interface: value.interface,
              type: "requirement"
            })
          )
        );
      }
      const right_terminals = [];
      if (module_definition.provides) {
        Object.entries(module_definition.provides).forEach(
          ([key, value]) => right_terminals.push(
            Object.freeze({
              id: key,
              interface: value.interface,
              type: "provide"
            })
          )
        );
      }
      return {
        top: [],
        right: right_terminals,
        bottom: [],
        left: left_terminals
      };
    }
    var collectionClone = clone;
    function clone(obj) {
      let result = obj;
      var type2 = {}.toString.call(obj).slice(8, -1);
      if (type2 == "Set") {
        return new Set([...obj].map((value) => clone(value)));
      }
      if (type2 == "Map") {
        return new Map([...obj].map((kv) => [clone(kv[0]), clone(kv[1])]));
      }
      if (type2 == "Date") {
        return new Date(obj.getTime());
      }
      if (type2 == "RegExp") {
        return RegExp(obj.source, getRegExpFlags(obj));
      }
      if (type2 == "Array" || type2 == "Object") {
        result = Array.isArray(obj) ? [] : {};
        for (var key in obj) {
          result[key] = clone(obj[key]);
        }
      }
      return result;
    }
    function getRegExpFlags(regExp) {
      if (typeof regExp.source.flags == "string") {
        return regExp.source.flags;
      } else {
        var flags = [];
        regExp.global && flags.push("g");
        regExp.ignoreCase && flags.push("i");
        regExp.multiline && flags.push("m");
        regExp.sticky && flags.push("y");
        regExp.unicode && flags.push("u");
        return flags.join("");
      }
    }
    function get_next_available_name(prefix, name_list) {
      const valid_integral_endings = name_list.filter((item) => item.startsWith(prefix)).map((item) => Number(item.slice(prefix.length))).filter((item) => Number.isInteger(item) && item >= 0).sort((a, b) => a - b);
      const count = valid_integral_endings.length;
      const next_number = count === 0 ? 0 : valid_integral_endings[count - 1] + 1;
      return `${prefix}${next_number}`;
    }
    function config_set_with_schema_to_config_set(config_set) {
      const entries = config_set.filter((item) => item.model !== void 0).map((item) => [item.schema.title, item.model]);
      return Object.fromEntries(entries);
    }
    class EVConfigModel {
      constructor(definitions2, name, config2) {
        __publicField(this, "_module_definitions");
        __publicField(this, "_interface_parents");
        __publicField(this, "_next_instance_id", 0);
        __publicField(this, "_next_connection_id", 0);
        __publicField(this, "_name");
        __publicField(this, "_instances", {});
        __publicField(this, "_connections", {});
        // FIXME (aw): refactor this functionality like a mixin or something similar
        __publicField(this, "_event_handlers", []);
        this._module_definitions = definitions2.modules;
        this._interface_parents = generate_interface_parents_map(definitions2.interfaces);
        this._name = name;
        if (!config2) {
          return;
        }
        Object.entries(config2.active_modules).forEach(([module_id, module_config]) => {
          var _a2;
          this._add_module_instance(module_config.module, module_id, module_config, (_a2 = config2["x-module-layout"]) == null ? void 0 : _a2[module_id]);
        });
        Object.entries(this._instances).forEach(([_instance_id, module_instance]) => {
          const instance_connections = config2.active_modules[module_instance.id].connections;
          if (!instance_connections)
            return;
          Object.entries(instance_connections).forEach(([requirement_name, requirement_connections]) => {
            requirement_connections.forEach((provider) => {
              const providing_instance_id = this._module_instance_id_from_module_id(provider.module_id);
              this.add_connection({
                providing_impl_name: provider.implementation_id,
                providing_instance_id,
                requirement_name,
                requiring_instance_id: Number(_instance_id)
              });
            });
          });
        });
      }
      _module_instance_id_from_module_id(module_id) {
        const pair = Object.entries(this._instances).find(([, instance]) => instance.id === module_id);
        return pair ? Number(pair[0]) : null;
      }
      add_observer(handler) {
        this._event_handlers.push(handler);
      }
      _notify(event) {
        this._event_handlers.forEach((handler) => {
          handler(event);
        });
      }
      add_new_module_instance(module_type, module_id) {
        module_id = module_id || get_next_available_name(
          module_type,
          Object.values(this._instances).map((item) => item.id)
        );
        return this._add_module_instance(module_type, module_id);
      }
      delete_module_instance(id2) {
        if (!(id2 in this._instances)) {
          throw Error(`Module instance with instance id "${id2}" does not exist`);
        }
        const cxns = Object.entries(this._connections).filter(
          ([, cxn]) => cxn.providing_instance_id === id2 || cxn.requiring_instance_id === id2
        );
        cxns.forEach(([cxn_id]) => {
          this.delete_connection(parseInt(cxn_id));
        });
        delete this._instances[id2];
        this._notify({ type: "MODULE_INSTANCE_DELETED", id: id2 });
      }
      add_connection(conn) {
        this._validate_connection(conn);
        this._connection_exists(conn);
        const new_connection_id = this._next_connection_id;
        this._next_connection_id++;
        const new_connection = Object.assign({}, conn);
        this._connections[new_connection_id] = new_connection;
        this._add_connection_to_instance(conn.requiring_instance_id, new_connection_id);
        this._notify({ type: "CONNECTION_ADDED", id: new_connection_id });
        return new_connection_id;
      }
      // FIXME (aw): all these update module things need to factored out in a module instance model class
      update_module_id(module_instance_id, new_module_id) {
        const module_instance = this.get_module_instance(module_instance_id);
        if (module_instance.id == new_module_id) {
          return true;
        }
        if (Object.values(this._instances).filter((config2) => config2.id == new_module_id).length) {
          return false;
        }
        module_instance.id = new_module_id;
        this._notify({ type: "MODULE_INSTANCE_UPDATED", id: module_instance_id });
        return true;
      }
      update_module_view_position(module_instance_id, pos) {
        const module_instance = this.get_module_instance(module_instance_id);
        module_instance.view_config.position = collectionClone(pos);
      }
      update_module_view_terminals(module_instance_id, arrangement) {
        const module_instance = this.get_module_instance(module_instance_id);
        for (const _alignment in arrangement) {
          const alignment = _alignment;
          module_instance.view_config.terminals[alignment] = collectionClone(arrangement[alignment]);
        }
      }
      get_connection(connection_id) {
        return this._connections[connection_id];
      }
      delete_connection(connection_id) {
        if (!(connection_id in this._connections)) {
          throw Error(`Connection with id "${connection_id}" unknown`);
        }
        const conn = this._connections[connection_id];
        this._remove_connection_from_instance(conn.requiring_instance_id, connection_id);
        delete this._connections[connection_id];
        this._notify({ type: "CONNECTION_DELETED", id: connection_id });
      }
      get module_definitions() {
        return this._module_definitions;
      }
      get_module_instance(id2) {
        return this._instances[id2];
      }
      interfaces_match(provide2, requirement) {
        var _a2;
        return provide2 === requirement || (((_a2 = this._interface_parents[provide2]) == null ? void 0 : _a2.has(requirement)) ?? false);
      }
      serialize() {
        const config2 = { active_modules: {}, "x-module-layout": {} };
        Object.entries(this._instances).forEach(([, instance]) => {
          const modules_config = config2.active_modules;
          const connections = {};
          instance.connections.map((id2) => this._connections[id2]).forEach((cxn) => {
            const fullfilment = {
              module_id: this._instances[cxn.providing_instance_id].id,
              implementation_id: cxn.providing_impl_name
            };
            if (cxn.requirement_name in connections) {
              connections[cxn.requirement_name].push(fullfilment);
            } else {
              connections[cxn.requirement_name] = [fullfilment];
            }
          });
          modules_config[instance.id] = {
            module: instance.type,
            connections
          };
          config2["x-module-layout"][instance.id] = instance.view_config;
          if (instance.module_config && Object.keys(instance.module_config).length !== 0) {
            modules_config[instance.id].config_module = config_set_with_schema_to_config_set(instance.module_config);
          }
          if (instance.implementation_config) {
            const implementation_config = {};
            Object.entries(instance.implementation_config).forEach(([impl_name, config_set_with_schema]) => {
              const config_set = config_set_with_schema_to_config_set(config_set_with_schema);
              if (Object.keys(config_set).length != 0) {
                implementation_config[impl_name] = config_set;
              }
            });
            if (Object.keys(implementation_config).length !== 0) {
              modules_config[instance.id].config_implementation = implementation_config;
            }
          }
        });
        return config2;
      }
      _setup_config_set(schema2, config2) {
        if (schema2 === void 0) {
          return void 0;
        }
        return Object.entries(schema2).map(([key, value]) => {
          const config_value = config2 !== void 0 && key in config2 ? config2[key] : value.default;
          return { schema: { ...value, title: key }, model: config_value };
        });
      }
      _add_module_instance(type2, id2, config2, view_config) {
        if (!(type2 in this._module_definitions)) {
          throw Error(`Invalid module type: ${type2}`);
        }
        if (Object.values(this._instances).filter((value) => value.id === id2).length) {
          throw Error(`Module instance with id: ${module.id} already exists`);
        }
        const manifest = this._module_definitions[type2];
        const impl_configs = {};
        Object.entries(manifest.provides).forEach(([impl_name, impl_def]) => {
          const impl_config = (config2 == null ? void 0 : config2.config_implementation) !== void 0 && impl_name in config2.config_implementation ? config2.config_implementation[impl_name] : void 0;
          if (impl_def.config !== void 0) {
            impl_configs[impl_name] = this._setup_config_set(impl_def.config, impl_config);
          }
        });
        const instance_id = this._next_instance_id;
        this._next_instance_id++;
        this._instances[instance_id] = {
          id: id2,
          type: type2,
          module_config: this._setup_config_set(manifest.config, config2 == null ? void 0 : config2.config_module),
          implementation_config: Object.keys(impl_configs).length ? impl_configs : void 0,
          connections: [],
          view_config: view_config ? view_config : {
            position: null,
            terminals: default_terminals(manifest)
          }
        };
        this._notify({ type: "MODULE_INSTANCE_ADDED", id: instance_id });
        return instance_id;
      }
      _validate_connection(conn) {
        const prov_id = conn.providing_instance_id;
        if (!(prov_id in this._instances)) {
          throw Error(`Providing instance with instance id ${prov_id} does not exist`);
        }
        const req_id = conn.requiring_instance_id;
        if (!(req_id in this._instances)) {
          throw Error(`Requiring instance with instance id ${req_id} does not exist`);
        }
        const prov_module = this._instances[prov_id].type;
        const prov_manifest = this._module_definitions[prov_module];
        const req_module = this._instances[req_id].type;
        const req_manifest = this._module_definitions[req_module];
        if (!(conn.providing_impl_name in prov_manifest.provides)) {
          throw Error(
            `Providing module of type "${prov_module}" does not provide an implementation named "${conn.providing_impl_name}"`
          );
        }
        if (!(conn.requirement_name in req_manifest.requires)) {
          throw Error(
            `Requiring module of type "${req_module}" does not have an requirement called "${conn.requirement_name}"`
          );
        }
        const prov_interface = prov_manifest.provides[conn.providing_impl_name].interface;
        const req_interface = req_manifest.requires[conn.requirement_name].interface;
        if (!this.interfaces_match(prov_interface, req_interface)) {
          throw Error(
            `The interface for the provide (${prov_interface}) and the requirement (${req_interface}) do not match`
          );
        }
      }
      _connection_exists(conn) {
        for (const [, other_conn] of Object.entries(this._connections)) {
          if (conn.providing_impl_name === other_conn.providing_impl_name && conn.providing_instance_id === other_conn.providing_instance_id && conn.requirement_name === other_conn.requirement_name && conn.requiring_instance_id === other_conn.requiring_instance_id) {
            throw Error(`The connection "${JSON.stringify(conn, null, 2)}" already exists`);
          }
        }
      }
      _add_connection_to_instance(instance_id, connection_id) {
        this._instances[instance_id].connections.push(connection_id);
      }
      _remove_connection_from_instance(instance_id, connection_id) {
        const connection_list = this._instances[instance_id].connections;
        const index = connection_list.indexOf(connection_id);
        if (index > -1) {
          connection_list.splice(index, 1);
        }
      }
    }
    const SampleManifestList = {
      "API": {
        "config": {
          "charger_information_file": {
            "default": "",
            "description": "Path to a file containing information about the charger like its serial number",
            "type": "string"
          },
          "hw_caps_max_current_export_decimal_places": {
            "default": 2,
            "description": "Maximum number of decimal places for maximum export current in the hardware capabilities",
            "minimum": 0,
            "type": "integer"
          },
          "hw_caps_max_current_export_round_to": {
            "default": 0,
            "description": "Round maximum export current in hardware limits to the nearest step. Ignored if value is 0",
            "type": "number"
          },
          "hw_caps_max_current_import_decimal_places": {
            "default": 2,
            "description": "Maximum number of decimal places for maximum import current in the hardware capabilities",
            "minimum": 0,
            "type": "integer"
          },
          "hw_caps_max_current_import_round_to": {
            "default": 0,
            "description": "Round maximum import current in hardware limits to the nearest step. Ignored if value is 0",
            "type": "number"
          },
          "hw_caps_max_plug_temperature_C_decimal_places": {
            "default": 2,
            "description": "Maximum number of decimal places for max_plug_temperature_C in the hardware capabilities",
            "minimum": 0,
            "type": "integer"
          },
          "hw_caps_max_plug_temperature_C_round_to": {
            "default": 0,
            "description": "Round max_plug_temperature_C in hardware limits to the nearest step. Ignored if value is 0",
            "type": "number"
          },
          "hw_caps_min_current_export_decimal_places": {
            "default": 2,
            "description": "Maximum number of decimal places for minimum export current in the hardware capabilities",
            "minimum": 0,
            "type": "integer"
          },
          "hw_caps_min_current_export_round_to": {
            "default": 0,
            "description": "Round minimum export current in hardware limits to the nearest step. Ignored if value is 0",
            "type": "number"
          },
          "hw_caps_min_current_import_decimal_places": {
            "default": 2,
            "description": "Maximum number of decimal places for minimum import current in the hardware capabilities",
            "minimum": 0,
            "type": "integer"
          },
          "hw_caps_min_current_import_round_to": {
            "default": 0,
            "description": "Round minimum import current in hardware limits to the nearest step. Ignored if value is 0",
            "type": "number"
          },
          "limits_max_current_decimal_places": {
            "default": 2,
            "description": "Maximum number of decimal places for maximum current in the limits",
            "minimum": 0,
            "type": "integer"
          },
          "limits_max_current_round_to": {
            "default": 0,
            "description": "Round maximum current in limits to the nearest step. Ignored if value is 0",
            "type": "number"
          },
          "powermeter_VAR_decimal_places": {
            "default": 2,
            "description": "Maximum number of decimal places for VAR in the power meter",
            "minimum": 0,
            "type": "integer"
          },
          "powermeter_VAR_round_to": {
            "default": 0,
            "description": "Round VAR to the nearest step. Ignored if value is 0",
            "type": "number"
          },
          "powermeter_current_decimal_places": {
            "default": 2,
            "description": "Maximum number of decimal places for current in the power meter",
            "minimum": 0,
            "type": "integer"
          },
          "powermeter_current_round_to": {
            "default": 0,
            "description": "Round current to the nearest step. Ignored if value is 0",
            "type": "number"
          },
          "powermeter_energy_export_decimal_places": {
            "default": 2,
            "description": "Maximum number of decimal places for export energy in the power meter",
            "minimum": 0,
            "type": "integer"
          },
          "powermeter_energy_export_round_to": {
            "default": 0,
            "description": "Round export energy to the nearest step. Ignored if value is 0",
            "type": "number"
          },
          "powermeter_energy_import_decimal_places": {
            "default": 2,
            "description": "Maximum number of decimal places for import energy in the power meter",
            "minimum": 0,
            "type": "integer"
          },
          "powermeter_energy_import_round_to": {
            "default": 0,
            "description": "Round import energy to the nearest step. Ignored if value is 0",
            "type": "number"
          },
          "powermeter_frequency_decimal_places": {
            "default": 2,
            "description": "Maximum number of decimal places for frequency in the power meter",
            "minimum": 0,
            "type": "integer"
          },
          "powermeter_frequency_round_to": {
            "default": 0,
            "description": "Round frequency to the nearest step. Ignored if value is 0",
            "type": "number"
          },
          "powermeter_power_decimal_places": {
            "default": 2,
            "description": "Maximum number of decimal places for power in the power meter",
            "minimum": 0,
            "type": "integer"
          },
          "powermeter_power_round_to": {
            "default": 0,
            "description": "Round power to the nearest step. Ignored if value is 0",
            "type": "number"
          },
          "powermeter_voltage_decimal_places": {
            "default": 2,
            "description": "Maximum number of decimal places for voltage in the power meter",
            "minimum": 0,
            "type": "integer"
          },
          "powermeter_voltage_round_to": {
            "default": 0,
            "description": "Round voltage to the nearest step. Ignored if value is 0",
            "type": "number"
          },
          "telemetry_evse_temperature_C_decimal_places": {
            "default": 2,
            "description": "Maximum number of decimal places for evse_temperature_C in telemetry",
            "minimum": 0,
            "type": "integer"
          },
          "telemetry_evse_temperature_C_round_to": {
            "default": 0,
            "description": "Round evse_temperature_C in telemetry to the nearest step. Ignored if value is 0",
            "type": "number"
          },
          "telemetry_fan_rpm_decimal_places": {
            "default": 2,
            "description": "Maximum number of decimal places for fan RPM in telemetry",
            "minimum": 0,
            "type": "integer"
          },
          "telemetry_fan_rpm_round_to": {
            "default": 0,
            "description": "Round fan RPM in telemetry to the nearest step. Ignored if value is 0",
            "type": "number"
          },
          "telemetry_plug_temperature_C_decimal_places": {
            "default": 2,
            "description": "Maximum number of decimal places for RCD current in telemetry",
            "minimum": 0,
            "type": "integer"
          },
          "telemetry_plug_temperature_C_round_to": {
            "default": 0,
            "description": "Round plug_temperature_C in telemetry to the nearest step. Ignored if value is 0",
            "type": "number"
          },
          "telemetry_supply_voltage_12V_decimal_places": {
            "default": 2,
            "description": "Maximum number of decimal places for supply voltage 12V in telemetry",
            "minimum": 0,
            "type": "integer"
          },
          "telemetry_supply_voltage_12V_round_to": {
            "default": 0,
            "description": "Round supply voltage 12V in telemetry to the nearest step. Ignored if value is 0",
            "type": "number"
          },
          "telemetry_supply_voltage_minus_12V_decimal_places": {
            "default": 2,
            "description": "Maximum number of decimal places for supply voltage -12V in telemetry",
            "minimum": 0,
            "type": "integer"
          },
          "telemetry_supply_voltage_minus_12V_round_to": {
            "default": 0,
            "description": "Round supply voltage -12V in telemetry to the nearest step. Ignored if value is 0",
            "type": "number"
          }
        },
        "description": "The EVerest API module, exposing some internal functionality on an external MQTT connection.",
        "enable_external_mqtt": true,
        "metadata": {
          "authors": [
            "Kai-Uwe Hermann"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "main": {
            "description": "EVerest API",
            "interface": "empty"
          }
        },
        "requires": {
          "evse_manager": {
            "interface": "evse_manager",
            "max_connections": 128,
            "min_connections": 1
          },
          "ocpp": {
            "interface": "ocpp",
            "max_connections": 1,
            "min_connections": 0
          },
          "random_delay": {
            "interface": "uk_random_delay",
            "max_connections": 128,
            "min_connections": 0
          }
        }
      },
      "Auth": {
        "config": {
          "connection_timeout": {
            "description": "Defines how many seconds an authorization is valid before it is discarded. Defines how many seconds a user can provide authorization after the plug in of a car",
            "type": "integer"
          },
          "ignore_connector_faults": {
            "default": false,
            "description": "Boolean value to describe the handling of faults on connectors.\nIf true, faults reported on connectors are ignored, i.e. they can still be authorized. This should be disabled in most use cases, but e.g. in free charging applications it may be useful to allow a charging session in the following case: A connector e.g. has an overtemperature fault that at some point will clear once it is cooled down. A car is plugged in before  the error is cleared. The user would expect that the charging starts once it is cooled down. When this option is set to false,  it will not be authorized on plug in as the connector is in fault state and it will never recover until the car is replugged. If it is set to true, the authorization happens on the faulty connector and charging will start once the fault is cleared.\nIf false, faulty connectors are treated as not available and will not be authorized. This is a good setting for e.g. public chargers.",
            "type": "boolean"
          },
          "master_pass_group_id": {
            "default": "",
            "description": "IdTokens that have this id as groupId belong to the Master Pass Group. Meaning they can stop any ongoing transaction, but cannot start transactions. This can, for example, be used by law enforcement personal to stop any ongoing transaction when an EV has to be towed away. If left empty, master_pass_group_id is not used.",
            "type": "string"
          },
          "prioritize_authorization_over_stopping_transaction": {
            "default": true,
            "description": "Boolean value to describe the handling of parent id tokens.\nIf true, a new token will be preferably used for authorization of a new connector if a connector is available. It will not be used to finish a transaction using its parent_id_token. parent_id_token will only be used to finish transaction if no connector is available for authorization anymore.\nIf false, a new token will be used to finish a transaction if the parent_id_token of a present transaction matches the parent_id_token of the provided_token. Authorization to available connectors will only be provided if no transaction can be stopped using the given parent_id_token",
            "type": "boolean"
          },
          "selection_algorithm": {
            "default": "FindFirst",
            "description": "The algorithm that is used to map an incoming token to a connector",
            "type": "string"
          }
        },
        "description": "This module implements the authentication handling for the EVerest. It is responsible for providing authorization to the connected evse managers. In addition to that, it handles the reservation management.",
        "metadata": {
          "authors": [
            "Piet Gömpel"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "main": {
            "description": "This implements the auth interface for EVerest",
            "interface": "auth"
          },
          "reservation": {
            "description": "This implements the reservation interface for EVerest.",
            "interface": "reservation"
          }
        },
        "requires": {
          "evse_manager": {
            "interface": "evse_manager",
            "max_connections": 128,
            "min_connections": 1
          },
          "token_provider": {
            "interface": "auth_token_provider",
            "max_connections": 128,
            "min_connections": 1
          },
          "token_validator": {
            "interface": "auth_token_validator",
            "max_connections": 128,
            "min_connections": 1
          }
        }
      },
      "DCSupplySimulator": {
        "description": "Implementation of a programmable power supply for DC charging",
        "metadata": {
          "authors": [
            "Cornelius Claussen (Pionix GmbH)",
            "Fabian Hartung (chargebyte GmbH)",
            "Mohannad Oraby (chargebyte GmbH)"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "main": {
            "config": {
              "bidirectional": {
                "default": true,
                "description": "Set to true for bidirectional supply",
                "type": "boolean"
              },
              "max_current": {
                "default": 200,
                "description": "Max supported current",
                "type": "number"
              },
              "max_power": {
                "default": 15e4,
                "description": "Max supported power in watt",
                "type": "number"
              },
              "max_voltage": {
                "default": 900,
                "description": "Max supported voltage",
                "type": "number"
              },
              "min_current": {
                "default": 1,
                "description": "Min supported current",
                "type": "number"
              },
              "min_voltage": {
                "default": 200,
                "description": "Min supported voltage",
                "type": "number"
              }
            },
            "description": "Main interface for the power supply",
            "interface": "power_supply_DC"
          }
        }
      },
      "DPM1000": {
        "config": {
          "current_limit_A": {
            "default": 100,
            "description": "Maximum Current Limit in Ampere",
            "maximum": 100,
            "type": "number"
          },
          "debug_print_all_telemetry": {
            "default": false,
            "description": "Read and print all telemetry from the power module. Helpful while debugging.",
            "type": "boolean"
          },
          "device": {
            "default": "can0",
            "description": "Interface name for can device",
            "type": "string"
          },
          "device_address": {
            "default": 0,
            "description": "Device address (as selected on front LED panel)",
            "type": "integer"
          },
          "discharge_gpio_chip": {
            "default": "",
            "description": "GPIO chip to use to switch external discharge load on and off. An empty string disables discharging. Note that the hardware load must be designed to allow permanent discharge from the highest voltage (e.g. 1000V)",
            "type": "string"
          },
          "discharge_gpio_line": {
            "default": 0,
            "description": "GPIO line to use to switch discharge load",
            "type": "integer"
          },
          "discharge_gpio_polarity": {
            "default": true,
            "description": "GPIO polarity, false means active low, true means active high",
            "type": "boolean"
          },
          "power_limit_W": {
            "default": 3e4,
            "description": "Maximum Power Limit in Watt",
            "maximum": 3e4,
            "type": "number"
          },
          "series_parallel_mode": {
            "default": "Series",
            "description": "Select series (300-1000V), parallel (50-500) or automatic switching mode (50-1000). This switches the internal configuration of one module and should not be confused with parallel operation of multiple modules.",
            "enum": [
              "Series",
              "Parallel",
              "Automatic"
            ],
            "type": "string"
          },
          "voltage_limit_V": {
            "default": 1e3,
            "description": "Maximum Voltage Limit in Volt. Will be limited by series parallel setting as well.",
            "maximum": 1e3,
            "type": "number"
          }
        },
        "description": "DC Power Supply Driver",
        "metadata": {
          "authors": [
            "aw@pionix.de"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "main": {
            "description": "Power supply driver for DPM 1000-30 from SCU Power. Currently supports only one module.",
            "interface": "power_supply_DC"
          }
        }
      },
      "DummyTokenProvider": {
        "description": "Dummy token provider that listens to AuthRequired event from evse_manager and then publishes one token",
        "metadata": {
          "authors": [
            "Thilo Molitor",
            "Cornelius Claussen"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "main": {
            "config": {
              "connector_id": {
                "default": 0,
                "description": "If >0, the generated token is only valid for this connector_id",
                "minimum": 0,
                "type": "integer"
              },
              "timeout": {
                "default": 10,
                "description": "Time our dummy token is valid (in s)",
                "maximum": 120,
                "minimum": 0,
                "type": "number"
              },
              "token": {
                "default": "DEADBEEF",
                "description": "Dummy token string to return",
                "maxLength": 20,
                "minLength": 1,
                "type": "string"
              },
              "type": {
                "default": "RFID",
                "description": "Type to report for our dummy token",
                "maxLength": 32,
                "minLength": 2,
                "type": "string"
              }
            },
            "description": "Main implementation of dummy token provider always returning one configured token",
            "interface": "auth_token_provider"
          }
        },
        "requires": {
          "evse": {
            "interface": "evse_manager"
          }
        }
      },
      "DummyTokenProviderManual": {
        "description": "Dummy token provider that manually publishes one token",
        "enable_external_mqtt": true,
        "metadata": {
          "authors": [
            "Kai-Uwe Hermann",
            "Cornelius Claussen"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "main": {
            "config": {
              "timeout": {
                "default": 10,
                "description": "Time our dummy token is valid (in s)",
                "maximum": 120,
                "minimum": 0,
                "type": "number"
              },
              "token": {
                "default": "DEADBEEF",
                "description": "Dummy token string to return",
                "maxLength": 20,
                "minLength": 1,
                "type": "string"
              },
              "type": {
                "default": "RFID",
                "description": "Type to report for our dummy token",
                "maxLength": 32,
                "minLength": 2,
                "type": "string"
              }
            },
            "description": "Main implementation of dummy token provider always returning one configured token",
            "interface": "auth_token_provider"
          }
        },
        "requires": {}
      },
      "DummyTokenValidator": {
        "description": "Dummy token validator always returning the same configured token validation result for every token",
        "metadata": {
          "authors": [
            "Thilo Molitor",
            "Cornelius Claussen"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "main": {
            "config": {
              "sleep": {
                "default": 0.5,
                "description": "Time to wait before returning the dumy validation result (in s)",
                "maximum": 120,
                "minimum": 0,
                "type": "number"
              },
              "validation_reason": {
                "default": "Token valid",
                "description": "Dummy validation reason to return",
                "minLength": 5,
                "type": "string"
              },
              "validation_result": {
                "default": "Accepted",
                "description": "Dummy validation result to return",
                "enum": [
                  "Accepted",
                  "Blocked",
                  "Expired",
                  "Invalid"
                ],
                "type": "string"
              }
            },
            "description": "Main implementation of dummy token validator always returning the same configured token validation result for every token",
            "interface": "auth_token_validator"
          }
        }
      },
      "DummyV2G": {
        "description": "This module implements an empty dummy for HLC. It does not actually communicate with the car.",
        "metadata": {
          "authors": [
            "Cornelius Claussen"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "main": {
            "description": "This module implements the ISO15118-2 implementation of an AC or DC charger",
            "interface": "ISO15118_charger"
          }
        }
      },
      "EnergyManager": {
        "config": {
          "debug": {
            "default": false,
            "description": "Show debug output on command line.",
            "type": "boolean"
          },
          "nominal_ac_voltage": {
            "default": 230,
            "description": "Nominal AC voltage to use to convert Ampere to Watt on AC",
            "type": "number"
          },
          "schedule_interval_duration": {
            "default": 60,
            "description": "Duration of the schedule interval for forecast [min]",
            "type": "integer"
          },
          "schedule_total_duration": {
            "default": 1,
            "description": "Total duration of schedule forcast [h]",
            "type": "integer"
          },
          "slice_ampere": {
            "default": 0.5,
            "description": "Ampere slice for trading. Lower values will give more even distribution but increase processing time [A].",
            "type": "number"
          },
          "slice_watt": {
            "default": 500,
            "description": "Watt slice for trading. Lower values will give more even distribution but increase processing time [A].",
            "type": "number"
          },
          "update_interval": {
            "default": 1,
            "description": "Update interval for energy distribution [s]",
            "type": "integer"
          }
        },
        "description": "This module is the global Energy Manager for all EVSE/Charging stations in this building",
        "enable_external_mqtt": false,
        "metadata": {
          "authors": [
            "Cornelius Claussen",
            "Lars Dieckmann"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "main": {
            "description": "Main interface of the energy manager",
            "interface": "energy_manager"
          }
        },
        "requires": {
          "energy_trunk": {
            "interface": "energy",
            "max_connections": 1,
            "min_connections": 1
          }
        }
      },
      "EnergyNode": {
        "config": {
          "fuse_limit_A": {
            "description": "Fuse limit in ampere for all phases",
            "minimum": 0,
            "type": "number"
          },
          "phase_count": {
            "description": "phase count limit. Omit if not limited in this fuse.",
            "maximum": 3,
            "minimum": 0,
            "type": "integer"
          }
        },
        "description": "This module is part of the Energy Tree and represents a simple current fuse.",
        "enable_external_mqtt": false,
        "metadata": {
          "authors": [
            "Cornelius Claussen"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "energy_grid": {
            "description": "This is the chain interface to build the energy supply tree",
            "interface": "energy"
          },
          "external_limits": {
            "description": "Additional external limits can be set via this interface.",
            "interface": "external_energy_limits"
          }
        },
        "requires": {
          "energy_consumer": {
            "interface": "energy",
            "max_connections": 128,
            "min_connections": 1
          },
          "powermeter": {
            "interface": "powermeter",
            "max_connections": 1,
            "min_connections": 0
          },
          "price_information": {
            "interface": "energy_price_information",
            "max_connections": 1,
            "min_connections": 0
          }
        }
      },
      "EvSlac": {
        "description": "Implementation of EV SLAC data link negotiation according to ISO15118-3.",
        "metadata": {
          "authors": [
            "aw@pionix.de"
          ],
          "base_license": "https://directory.fsf.org/wiki/License:BSD-3-Clause-Clear",
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "main": {
            "config": {
              "device": {
                "default": "eth1",
                "description": "Ethernet device used for PLC.",
                "type": "string"
              },
              "ev_id": {
                "default": "PIONIX_SAYS_HELLO",
                "description": "EVSE id - 17 octets.",
                "type": "string"
              },
              "set_key_timeout_ms": {
                "default": 500,
                "description": "Timeout for CM_SET_KEY.REQ. Default works for QCA7000/QCA7005/CG5317.",
                "type": "integer"
              }
            },
            "description": "SLAC interface implementation.",
            "interface": "ev_slac"
          }
        }
      },
      "EvseManager": {
        "config": {
          "ac_enforce_hlc": {
            "default": false,
            "description": "Combine with 5percent option to really enforce HLC even with EIM. It is not ISO15118-2/-3 compliant as it waits for matching even if EIM is available before SLAC reaches matched state. On cars that do not support ISO15118 on AC this will take a very long time to timeout and fall back to basic nominal PWM charging, but it will eventually.",
            "type": "boolean"
          },
          "ac_hlc_enabled": {
            "default": false,
            "description": "Enable or disable HLC (aka ISO15118) for AC mode",
            "type": "boolean"
          },
          "ac_hlc_use_5percent": {
            "default": false,
            "description": "Use 5 percent PWM signalling to try to enforce HLC on AC. Note that if EIM arrives before SLAC matching, we will fall back to nominal PWM charging. So most cars will never use HLC in this mode, especially on a free service where EIM is always available, but that is what ISO15118-2/-3 requires to be compliant - it wants to use HLC only for PnC and not for EIM.",
            "type": "boolean"
          },
          "ac_nominal_voltage": {
            "default": 230,
            "description": "Nominal AC voltage between phase and neutral in Volt",
            "type": "number"
          },
          "ac_with_soc": {
            "default": false,
            "description": "Special mode that switches between AC and DC charging to get SoC percentage with AC charging",
            "type": "boolean"
          },
          "autocharge_use_slac_instead_of_hlc": {
            "default": false,
            "description": "Use slac ev mac address for autocharge instead of EVCCID from HLC",
            "type": "boolean"
          },
          "charge_mode": {
            "default": "AC",
            "description": "Select charging mode",
            "enum": [
              "AC",
              "DC"
            ],
            "type": "string"
          },
          "connector_id": {
            "description": "Connector id of this evse manager",
            "type": "integer"
          },
          "country_code": {
            "default": "DE",
            "description": "Country Code",
            "type": "string"
          },
          "dbg_hlc_auth_after_tstep": {
            "default": false,
            "description": "Special mode: send HLC auth ok only after t_step_XX is finished (true) or directly when available (false)",
            "type": "boolean"
          },
          "dc_isolation_voltage_V": {
            "default": 500,
            "description": "DC voltage used to test isolation in CableCheck. Set to 500V.",
            "type": "integer"
          },
          "disable_authentication": {
            "default": false,
            "description": "Do not wait for authorization from Auth module, offer a free service. Start charging immediately after plug in. Do not use with Auth manager or OCPP, this option is only to allow charging with a standalone EvseManager that is not connected to an Auth manager. Use DummyTokenProvider/Validator when testing with Auth module and/or OCPP.",
            "type": "boolean"
          },
          "ev_receipt_required": {
            "default": false,
            "description": "Unsupported: request receipt from EV with HLC",
            "type": "boolean"
          },
          "evse_id": {
            "default": "DE*PNX*E1234567*1",
            "description": "EVSE ID",
            "type": "string"
          },
          "evse_id_din": {
            "default": "49A80737A45678",
            "description": "EVSE ID DIN after DIN SPEC 91286",
            "type": "string"
          },
          "external_ready_to_start_charging": {
            "default": false,
            "description": "Enable the external ready to start charging signal that delays charging ready until it has been received",
            "type": "boolean"
          },
          "hack_allow_bpt_with_iso2": {
            "default": false,
            "description": "Hack. Allow bidirectional power transfer with DIN spec and ISO-2. Currents communicated on HLC will always be positive but power supply may actually discharge the car.",
            "type": "boolean"
          },
          "hack_fix_hlc_integer_current_requests": {
            "default": false,
            "description": "Some cars request only integer ampere values during DC charging. For low power DC charging that  means that they charge a few hundred watts slower then needed. If enabled, this will charge at full power if the difference between EV requested current (integer) and HLC current limit is less then 1.0",
            "type": "boolean"
          },
          "hack_pause_imd_during_precharge": {
            "default": false,
            "description": "Disable IMD at the end of CableCheck and re-enable when current is flowing in CurrentDemand. Some DCDC power supplies do not start current flow when insulation measurement is active. Set to true to enable dirty workaround for some IMD hardware.",
            "type": "boolean"
          },
          "hack_present_current_offset": {
            "default": 0,
            "description": "Adds an offset [A] to the present current reported to the car on HLC. Set to 0 unless you really know what you are doing.",
            "type": "integer"
          },
          "hack_skoda_enyaq": {
            "default": false,
            "description": "Skoda Enyaq requests DC charging voltages below its battery level or even below 0 initially. Set to true to enable dirty workaround.",
            "type": "boolean"
          },
          "hack_sleep_in_cable_check": {
            "default": 0,
            "description": "Hack: Sleep for n seconds at the end of cable check.",
            "type": "integer"
          },
          "hack_sleep_in_cable_check_volkswagen": {
            "default": 0,
            "description": "Hack: Additional sleep for Volkswagen cars for n seconds at the end of cable check",
            "type": "integer"
          },
          "has_ventilation": {
            "default": true,
            "description": "Allow ventilated charging or not",
            "type": "boolean"
          },
          "logfile_suffix": {
            "default": "session_uuid",
            "description": "Use the string given for the log folder name. Special string session_uuid will be replaced with session uuid.",
            "type": "string"
          },
          "max_current_export_A": {
            "default": 32,
            "description": "User configurable current limit for this EVSE in Ampere",
            "type": "number"
          },
          "max_current_import_A": {
            "default": 32,
            "description": "User configurable current limit for this EVSE in Ampere",
            "type": "number"
          },
          "payment_enable_contract": {
            "default": true,
            "description": "Set to true to enable contract (aka plug and charge) authorization",
            "type": "boolean"
          },
          "payment_enable_eim": {
            "default": true,
            "description": "Set to true to enable EIM (e.g. RFID card or mobile app) authorization",
            "type": "boolean"
          },
          "request_zero_power_in_idle": {
            "default": false,
            "description": '"true: In Idle mode (no car connected), request 0A from energy management. In installations with many charging stations this should be set" "to allow the power to be distributed to the chargers that are connected to a car." "false: Request the normal current even if no car is connected. This speeds up the start of charging on AC BASIC charging as" "EvseManager does not need to wait for energy from the energy manager after plug in."',
            "type": "boolean"
          },
          "sae_j2847_2_bpt_enabled": {
            "default": false,
            "description": "Enable SAE J2847 2 V2G or V2H mode",
            "type": "boolean"
          },
          "sae_j2847_2_bpt_mode": {
            "default": "V2G",
            "description": "SAE J2847 2 BPT mode",
            "enum": [
              "V2H",
              "V2G"
            ],
            "type": "string"
          },
          "session_logging": {
            "default": false,
            "description": "Enable/Disable session log file output",
            "type": "boolean"
          },
          "session_logging_path": {
            "default": "/tmp",
            "description": "Output directory for session log files",
            "type": "string"
          },
          "session_logging_xml": {
            "default": true,
            "description": "Log full XML messages for HLC",
            "type": "boolean"
          },
          "soft_over_current_measurement_noise_A": {
            "default": 0.5,
            "description": "Set current measurement noise. Added to limit as an offset to avoid false triggers.",
            "type": "number"
          },
          "soft_over_current_tolerance_percent": {
            "default": 10,
            "description": "Allow for N percent over current in soft over current checking during AC charging.",
            "type": "number"
          },
          "switch_to_minimum_voltage_after_cable_check": {
            "default": false,
            "description": "When cable check is completed, switch to minimal voltage of DC output. Normally disabled.",
            "type": "boolean"
          },
          "three_phases": {
            "default": true,
            "description": "Limit to three phases (true) or one phase (false)",
            "type": "boolean"
          },
          "uk_smartcharging_random_delay_at_any_change": {
            "default": true,
            "description": '"True: use random delays on any current change during charging. False: Only use if current is reduced to zero or increased from zero."',
            "type": "boolean"
          },
          "uk_smartcharging_random_delay_enable": {
            "default": false,
            "description": '"true: enable random_delays on start up, false: disable random delays on startup." "They can also be enabled/disabled during runtime on the random_delay implementation."',
            "type": "boolean"
          },
          "uk_smartcharging_random_delay_max_duration": {
            "default": 600,
            "description": '"Start up value for the maximum duration of a random delay." "Can be modified during runtime on the random_delay implementation."',
            "type": "integer"
          }
        },
        "description": "EVSE Manager. Grid side power meter: Will be used for energy management. Will also be used for billing if no car side power meter connected. Car side powermeter: Will be used for billing if present.",
        "enable_external_mqtt": true,
        "enable_telemetry": true,
        "metadata": {
          "authors": [
            "Cornelius Claussen",
            "Anton Woellert"
          ],
          "license": "https://spdx.org/licenses/Apache-2.0.html"
        },
        "provides": {
          "energy_grid": {
            "description": "This is the tree leaf interface to build the energy supply tree",
            "interface": "energy"
          },
          "evse": {
            "description": "This is the main evsemanager interface",
            "interface": "evse_manager"
          },
          "random_delay": {
            "description": "Provides control over UK smart charging regulation random delay feature",
            "interface": "uk_random_delay"
          },
          "token_provider": {
            "description": "Provides authtokens for autocharge or plug and charge",
            "interface": "auth_token_provider"
          }
        },
        "requires": {
          "ac_rcd": {
            "interface": "ac_rcd",
            "max_connections": 1,
            "min_connections": 0
          },
          "bsp": {
            "interface": "evse_board_support"
          },
          "connector_lock": {
            "interface": "connector_lock",
            "max_connections": 1,
            "min_connections": 0
          },
          "hlc": {
            "interface": "ISO15118_charger",
            "max_connections": 1,
            "min_connections": 0
          },
          "imd": {
            "interface": "isolation_monitor",
            "max_connections": 1,
            "min_connections": 0
          },
          "powermeter_car_side": {
            "interface": "powermeter",
            "max_connections": 1,
            "min_connections": 0
          },
          "powermeter_grid_side": {
            "interface": "powermeter",
            "max_connections": 1,
            "min_connections": 0
          },
          "powersupply_DC": {
            "interface": "power_supply_DC",
            "max_connections": 1,
            "min_connections": 0
          },
          "slac": {
            "interface": "slac",
            "max_connections": 1,
            "min_connections": 0
          }
        }
      },
      "EvseSecurity": {
        "config": {
          "csms_ca_bundle": {
            "default": "ca/v2g/V2G_ROOT_CA.pem",
            "description": "Path to csms_ca_bundle file. If relative will be prefixed with everest prefix + etc/everest/certs. Otherwise absolute file path is used.",
            "type": "string"
          },
          "csms_leaf_cert_directory": {
            "default": "client/csms",
            "description": "Directory where CSMS leaf certificates are stored. If relative will be prefixed with everest prefix + etc/everest/certs. Otherwise absolute file path is used.",
            "type": "string"
          },
          "csms_leaf_key_directory": {
            "default": "client/csms",
            "description": "Directory where CSMS private keys are stored. If relative will be prefixed with everest prefix + etc/everest/certs. Otherwise absolute file path is used.",
            "type": "string"
          },
          "mf_ca_bundle": {
            "default": "ca/mf/MF_ROOT_CA.pem",
            "description": "Path to mf_ca_bundle file. If relative will be prefixed with everest prefix + etc/everest/certs. Otherwise absolute file path is used.",
            "type": "string"
          },
          "mo_ca_bundle": {
            "default": "ca/mo/MO_ROOT_CA.pem",
            "description": "Path to mo_ca_bundle file. If relative will be prefixed with everest prefix + etc/everest/certs. Otherwise absolute file path is used.",
            "type": "string"
          },
          "private_key_password": {
            "default": "",
            "description": "Password for encrypted private keys.",
            "type": "string"
          },
          "secc_leaf_cert_directory": {
            "default": "client/cso",
            "description": "Directory where SECC leaf certificates are stored. If relative will be prefixed with everest prefix + etc/everest/certs. Otherwise absolute file path is used.",
            "type": "string"
          },
          "secc_leaf_key_directory": {
            "default": "client/cso",
            "description": "Directory where SECC private keys are stored. If relative will be prefixed with everest prefix + etc/everest/certs. Otherwise absolute file path is used.",
            "type": "string"
          },
          "v2g_ca_bundle": {
            "default": "ca/v2g/V2G_ROOT_CA.pem",
            "description": "Path to v2g_ca_bundle file. If relative will be prefixed with everest prefix + etc/everest/certs. Otherwise absolute file path is used.",
            "type": "string"
          }
        },
        "description": "This module implements the evse_security interface. It uses the filesystem to store certificates and keys",
        "enable_external_mqtt": false,
        "enable_telemetry": false,
        "metadata": {
          "authors": [
            "Piet Gömpel"
          ],
          "license": "https://spdx.org/licenses/Apache-2.0.html"
        },
        "provides": {
          "main": {
            "description": "Implementation of the evse_security interface",
            "interface": "evse_security"
          }
        }
      },
      "EvseSlac": {
        "description": "Implementation of SLAC data link negotiation according to ISO15118-3.",
        "metadata": {
          "authors": [
            "aw@pionix.de",
            "Cornelius Claussen (Pionix GmbH)"
          ],
          "base_license": "https://directory.fsf.org/wiki/License:BSD-3-Clause-Clear",
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "main": {
            "config": {
              "ac_mode_five_percent": {
                "default": false,
                "description": "Use 5% mode in AC (true). Set to false for DC. The only difference is the handling of retries.",
                "type": "boolean"
              },
              "chip_reset_delay_ms": {
                "default": 100,
                "description": "Delay between SET_KEY.CNF and RS_DEV.REQ",
                "type": "integer"
              },
              "chip_reset_timeout_ms": {
                "default": 500,
                "description": "Timeout for RS_DEV.REQ (waiting for RS_DEV.CNF)",
                "type": "integer"
              },
              "debug_simulate_failed_matching": {
                "default": false,
                "description": "Only for debugging. Simulate failed matching by sending a wrong NMK to the EV.",
                "type": "boolean"
              },
              "device": {
                "default": "eth1",
                "description": "Ethernet device used for PLC.",
                "type": "string"
              },
              "do_chip_reset": {
                "default": false,
                "description": "Perform a chip reset after setting NMK using the RS_DEV.REQ Vendor MME Extension (Only works on Qualcomm chips)",
                "type": "boolean"
              },
              "evse_id": {
                "default": "PIONIX_SAYS_HELLO",
                "description": "EVSE id - 17 octets.",
                "type": "string"
              },
              "link_status_detection": {
                "default": false,
                "description": "After matching.cnf, wait for link to come up before sending out d_link_ready=connected using LINK_STATUS Vendor MME Extension (Works on Qualcomm and Lumissil chips)",
                "type": "boolean"
              },
              "link_status_retry_ms": {
                "default": 100,
                "description": "Delay between retries of LINK_STATUS requests after matching request",
                "type": "integer"
              },
              "link_status_timeout_ms": {
                "default": 1e4,
                "description": "Timeout for Link to come up after matching request",
                "type": "integer"
              },
              "nid": {
                "default": "pionix!",
                "description": "NID (Network Identification Key) - 7 octets.",
                "type": "string"
              },
              "number_of_sounds": {
                "default": 10,
                "description": "SLAC number of sounds.",
                "type": "integer"
              },
              "publish_mac_on_first_parm_req": {
                "default": false,
                "description": "Publish the EV MAC address when the first CM_SLAC_PARM.REQ. This should not be used as it is quite error prone: The MAC address might be from another car via cross talk. It is better to wait for the matching to be done.",
                "type": "boolean"
              },
              "publish_mac_on_match_cnf": {
                "default": true,
                "description": "Publish the EV MAC address on the token_provider interface when matching is confirmed (CM_SLAC_MATCH.CNF). This can be used for autocharge as an alternative to the EVCCID derived from HLC and published by EvseManager.  This can be used for AC autocharge on cars that do not support actual HLC on AC.",
                "type": "boolean"
              },
              "set_key_timeout_ms": {
                "default": 500,
                "description": "Timeout for CM_SET_KEY.REQ. Default works for QCA7000/QCA7005/CG5317.",
                "type": "integer"
              },
              "sounding_attenuation_adjustment": {
                "default": 0,
                "description": "Offset in dB that should be added to the calculated sounding attenuation",
                "type": "integer"
              }
            },
            "description": "SLAC interface implementation.",
            "interface": "slac"
          }
        }
      },
      "EvseV2G": {
        "config": {
          "auth_timeout_eim": {
            "default": 300,
            "description": "Defines how many seconds the EVSE should wait for authorization in EIM case, before the charging session is aborted. Write 0 if the EVSE should wait indefinitely for EIM authorization.",
            "type": "integer"
          },
          "auth_timeout_pnc": {
            "default": 55,
            "description": "Defines how many seconds the EVSE should wait for authorization in PnC case, before the charging session is aborted. Write 0 if the EVSE should wait indefinitely for PnC authorization.",
            "type": "integer"
          },
          "device": {
            "default": "eth0",
            "description": "Ethernet device used for HLC. Any local interface that has an ipv6 link-local and a MAC addr will work",
            "type": "string"
          },
          "supported_DIN70121": {
            "default": false,
            "description": "The EVSE supports the DIN SPEC",
            "type": "boolean"
          },
          "supported_ISO15118_2": {
            "default": true,
            "description": "The EVSE supports ISO15118-2",
            "type": "boolean"
          },
          "terminate_connection_on_failed_response": {
            "default": false,
            "description": "Controls how to handle a failed response code of the EVSE. If true the V2G connection is terminated immediately on a failed response code, otherwise the EV is responsible for closing of the V2G communication session with SessionStop.",
            "type": "boolean"
          },
          "tls_key_logging": {
            "default": false,
            "description": "Enable/Disable the export of TLS session keys (pre-master-secret) during a TLS handshake. This log file can be used to decrypt TLS sessions. Note that this option is for testing and simulation purpose only",
            "type": "boolean"
          },
          "tls_key_logging_path": {
            "default": "/tmp",
            "description": "Output directory for the TLS key log file",
            "type": "string"
          },
          "tls_security": {
            "default": "prohibit",
            "description": "Controls how to handle encrypted communication",
            "enum": [
              "prohibit",
              "allow",
              "force"
            ],
            "type": "string"
          },
          "tls_timeout": {
            "default": 15e3,
            "description": "Set the TLS timeout in ms when establishing a tls connection ",
            "type": "integer"
          },
          "verify_contract_cert_chain": {
            "default": false,
            "description": "Specifies if the EVSE should verify the contract certificate chain locally.",
            "type": "boolean"
          }
        },
        "description": "This module includes a DIN70121 and ISO15118-2 implementation provided by chargebyte GmbH",
        "enable_external_mqtt": true,
        "metadata": {
          "authors": [
            "Fabian Hartung",
            "Mohannad Oraby"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "charger": {
            "description": "This module implements the ISO15118-2 implementation of an AC or DC charger",
            "interface": "ISO15118_charger"
          }
        },
        "requires": {
          "security": {
            "interface": "evse_security"
          }
        }
      },
      "Example": {
        "description": "Simple example module written in C++",
        "enable_external_mqtt": true,
        "metadata": {
          "authors": [
            "Kai-Uwe Hermann",
            "Andreas Heinrich"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "example": {
            "config": {
              "current": {
                "description": "The current the physical connector can supply",
                "maximum": 60,
                "minimum": 1,
                "type": "number"
              },
              "enum_test": {
                "description": "A config value that tests the enum type",
                "enum": [
                  "one",
                  "two",
                  "three"
                ],
                "type": "string"
              },
              "enum_test2": {
                "description": "Another config value that tests the enum type",
                "enum": [
                  1,
                  2,
                  3
                ],
                "type": "integer"
              }
            },
            "description": "This implements an example interface that uses multiple framework features",
            "interface": "example"
          },
          "store": {
            "description": "This implements the kvs interface, mostly for testing multiple interfaces in one manifest",
            "interface": "kvs"
          }
        },
        "requires": {
          "kvs": {
            "interface": "kvs"
          }
        }
      },
      "ExampleUser": {
        "description": "Simple example module written in C++ and using the other example module",
        "metadata": {
          "authors": [
            "Kai-Uwe Hermann",
            "Andreas Heinrich"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "example_user": {
            "description": "This implements the example_user interface",
            "interface": "example_user"
          }
        },
        "requires": {
          "example": {
            "interface": "example"
          }
        }
      },
      "GenericPowermeter": {
        "description": "Powermeter driver for various powermeter hardware",
        "metadata": {
          "authors": [
            "Lars Dieckmann"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "main": {
            "config": {
              "modbus_base_address": {
                "default": 30001,
                "description": "The base address for register access",
                "maximum": 65535,
                "minimum": 0,
                "type": "integer"
              },
              "model": {
                "default": "test_dummy",
                "description": "Selector for the powermeter configuration file to be used",
                "type": "string"
              },
              "powermeter_device_id": {
                "default": 1,
                "description": "The powermeter's address on the serial bus",
                "maximum": 255,
                "minimum": 0,
                "type": "integer"
              }
            },
            "description": "Implementation of the driver functionality",
            "interface": "powermeter"
          }
        },
        "requires": {
          "serial_comm_hub": {
            "interface": "serial_communication_hub"
          }
        }
      },
      "IMDSimulator": {
        "description": "SIL Implementation of an Isolation Monitoring Device (IMD) for DC charging",
        "metadata": {
          "authors": [
            "Fabian Hartung (chargebyte GmbH)",
            "Cornelius Claussen (Pionix GmbH)"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "main": {
            "config": {
              "interval": {
                "default": 1e3,
                "description": "Measurement update interval in milliseconds",
                "type": "integer"
              },
              "resistance_F_Ohm": {
                "default": 9e5,
                "description": "Resistance to return for the simulated measurements in Ohm",
                "type": "number"
              }
            },
            "description": "Main interface for the IMD",
            "interface": "isolation_monitor"
          }
        }
      },
      "JsCarSimulator": {
        "config": {
          "auto_enable": {
            "default": false,
            "description": "Enable this simulation directly at start. Set to true for pure SIL configs, set to false for HIL.",
            "type": "boolean"
          },
          "auto_exec": {
            "default": false,
            "description": "Enable automatic execution of simulation commands at startup from auto_exec_commands config option.",
            "type": "boolean"
          },
          "auto_exec_commands": {
            "default": "",
            "description": "Simulation commands, e.g. sleep 1;iec_wait_pwr_ready;sleep 1;draw_power_regulated 16,3;sleep 30;unplug",
            "type": "string"
          },
          "connector_id": {
            "description": "Connector id of the evse manager to which this simulator is connected to",
            "type": "integer"
          },
          "dc_discharge_max_current_limit": {
            "default": 300,
            "description": "Maximum discharge current allowed by the EV",
            "type": "integer"
          },
          "dc_discharge_max_power_limit": {
            "default": 15e4,
            "description": "Maximum discharge power allowed by the EV",
            "type": "integer"
          },
          "dc_discharge_target_current": {
            "default": 5,
            "description": "Discharge target current requested by the EV",
            "type": "integer"
          },
          "dc_discharge_v2g_minimal_soc": {
            "default": 20,
            "description": "Discharge minimal soc at which the evse should shutdown",
            "type": "integer"
          },
          "dc_energy_capacity": {
            "default": 6e4,
            "description": "Energy capacity of the EV",
            "type": "integer"
          },
          "dc_max_current_limit": {
            "default": 300,
            "description": "Maximum current allowed by the EV",
            "type": "integer"
          },
          "dc_max_power_limit": {
            "default": 15e4,
            "description": "Maximum power allowed by the EV",
            "type": "integer"
          },
          "dc_max_voltage_limit": {
            "default": 900,
            "description": "Maximum voltage allowed by the EV",
            "type": "integer"
          },
          "dc_target_current": {
            "default": 5,
            "description": "Target current requested by the EV",
            "type": "integer"
          },
          "dc_target_voltage": {
            "default": 200,
            "description": "Target voltage requested by the EV",
            "type": "integer"
          },
          "support_sae_j2847": {
            "default": false,
            "description": "Supporting SAE J2847 ISO 2 bidi version",
            "type": "boolean"
          }
        },
        "description": "This module implements a Car simulator that can execute charging sessions using the yeti-simulation-control interface",
        "enable_external_mqtt": true,
        "metadata": {
          "authors": [
            "Cornelius Claussen"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "main": {
            "description": "This implements the car simulator",
            "interface": "car_simulator"
          }
        },
        "requires": {
          "ev": {
            "interface": "ISO15118_ev",
            "max_connections": 1,
            "min_connections": 0
          },
          "simulation_control": {
            "interface": "yeti_simulation_control"
          },
          "slac": {
            "interface": "slac",
            "max_connections": 1,
            "min_connections": 0
          }
        }
      },
      "JsDCSupplySimulator": {
        "description": "SIL Implementation of a programmable power supply for DC charging",
        "enable_external_mqtt": true,
        "metadata": {
          "authors": [
            "Cornelius Claussen (Pionix GmbH)"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "main": {
            "config": {
              "bidirectional": {
                "default": true,
                "description": "Set to true for bidirectional supply",
                "type": "boolean"
              },
              "max_current": {
                "default": 200,
                "description": "Max supported current",
                "type": "number"
              },
              "max_power": {
                "default": 15e4,
                "description": "Max supported power in watt",
                "type": "number"
              },
              "max_voltage": {
                "default": 900,
                "description": "Max supported voltage",
                "type": "number"
              },
              "min_current": {
                "default": 1,
                "description": "Min supported current",
                "type": "number"
              },
              "min_voltage": {
                "default": 200,
                "description": "Min supported voltage",
                "type": "number"
              }
            },
            "description": "Main interface for the power supply",
            "interface": "power_supply_DC"
          },
          "powermeter": {
            "description": "Power meter interface for simulation",
            "interface": "powermeter"
          }
        }
      },
      "JsExample": {
        "description": "Simple example module written in JS",
        "metadata": {
          "authors": [
            "Andreas Heinrich"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "example": {
            "description": "This implements an example_user interface that uses multiple framework features",
            "interface": "example_user"
          }
        }
      },
      "JsExampleUser": {
        "description": "Simple example module written in JS and using the other example module",
        "metadata": {
          "authors": [
            "Andreas Heinrich"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "example_user": {
            "description": "This implements the example_user interface",
            "interface": "example_user"
          }
        },
        "requires": {
          "example": {
            "interface": "example_user"
          }
        }
      },
      "JsSlacSimulator": {
        "description": "SIL Implementation of SLAC data link negotiation according to ISO15118-3.",
        "enable_external_mqtt": true,
        "metadata": {
          "authors": [
            "Cornelius Claussen (Pionix GmbH)"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "ev": {
            "config": {
              "ev_id": {
                "default": "PIONIX_SAYS_HELLO",
                "description": "EV id - 17 octets.",
                "type": "string"
              }
            },
            "description": "SLAC interface implementation for EV side",
            "interface": "slac"
          },
          "evse": {
            "config": {
              "evse_id": {
                "default": "PIONIX_SAYS_HELLO",
                "description": "EVSE id - 17 octets.",
                "type": "string"
              },
              "nid": {
                "default": "pionix!",
                "description": "NID (Network Identification Key) - 7 octets.",
                "type": "string"
              },
              "number_of_sounds": {
                "default": 10,
                "description": "SLAC number of sounds.",
                "type": "integer"
              }
            },
            "description": "SLAC interface implementation for EVSE side",
            "interface": "slac"
          }
        }
      },
      "JsTibber": {
        "description": "This modules fetches data from the Tibber Price Energy Forecast API and publishes it.",
        "enable_external_mqtt": false,
        "metadata": {
          "authors": [
            "Andreas Heinrich",
            "Leonardo Oliveira",
            "Cornelius Claussen"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "main": {
            "config": {
              "additional_cost_per_kwh": {
                "description": "Constant to add to the reported price. Usually 0.",
                "type": "number"
              },
              "api_key": {
                "description": "API key from Tibber developer account",
                "type": "string"
              },
              "update_interval": {
                "description": "Update interval in minutes. Typically 60 or so.",
                "type": "integer"
              }
            },
            "description": "This interface is responsible for providing the price forecast data from Tibber",
            "interface": "energy_price_information"
          }
        }
      },
      "JsYetiSimulator": {
        "config": {
          "connector_id": {
            "description": "Connector id of the evse manager to which this simulator is connected to",
            "type": "integer"
          }
        },
        "description": "SIL simulator for YETI hardware v1.0",
        "enable_external_mqtt": true,
        "enable_telemetry": true,
        "metadata": {
          "authors": [
            "Cornelius Claussen"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "board_support": {
            "description": "provides the board support Interface to low level control control pilot, relais, rcd, motor lock",
            "interface": "evse_board_support"
          },
          "connector_lock": {
            "description": "Interface for the simulated Connector lock",
            "interface": "connector_lock"
          },
          "powermeter": {
            "description": "provides the Yeti Internal Power Meter",
            "interface": "powermeter"
          },
          "rcd": {
            "description": "Interface for the simulated AC RCD",
            "interface": "ac_rcd"
          },
          "yeti_simulation_control": {
            "description": "Interface for the Yeti HIL simulator",
            "interface": "yeti_simulation_control"
          }
        }
      },
      "LemDCBM400600": {
        "config": {
          "ip_address": {
            "description": "IP Address of the power meter API.",
            "type": "string"
          },
          "meter_tls_certificate": {
            "default": "",
            "description": "The DCBM's HTTPS certificate, in PEM format. If provided, HTTPS will be used. If left empty, regular HTTP will be used. Note that this does not affect the default port - specify a port explicitly if you wish to use a port other than 80.",
            "type": "string"
          },
          "ntp_server_1_ip_addr": {
            "default": "",
            "description": "The IPv4 address (in 4-octet form W.X.Y.Z) of the first NTP server to use for time sync. If this is left empty, NTP will not be configured on the DCBM - its time will be synced with EVerest's system time instead.",
            "type": "string"
          },
          "ntp_server_1_port": {
            "default": 123,
            "description": "The port (1-65535) of the first NTP server.",
            "type": "integer"
          },
          "ntp_server_2_ip_addr": {
            "default": "",
            "description": "The IPv4 address (in 4-octet form W.X.Y.Z) of the second NTP server to use for time sync. This is ignored if ntp_server_1_ip_addr is empty.",
            "type": "string"
          },
          "ntp_server_2_port": {
            "default": 123,
            "description": "The port (1-65535) fof the second NTP server.",
            "type": "integer"
          },
          "port": {
            "default": 80,
            "description": "Port of the power meter API.",
            "type": "integer"
          },
          "resilience_initial_connection_retries": {
            "default": 25,
            "description": "For the controller resilience, the number of retries to connect to the powermeter at module initialization.",
            "type": "integer"
          },
          "resilience_initial_connection_retry_delay": {
            "default": 1e4,
            "description": "For the controller resilience, the delay in milliseconds before a retry attempt at module initialization..",
            "type": "integer"
          },
          "resilience_transaction_request_retries": {
            "default": 3,
            "description": "For the controller resilience, the number of retries to connect to the powermeter at a transaction start or stop request.",
            "type": "integer"
          },
          "resilience_transaction_request_retry_delay": {
            "default": 250,
            "description": "For the controller resilience, the delay in milliseconds before a retry attempt  at a transaction start or stop request.",
            "type": "integer"
          }
        },
        "description": "Module implementing the LEM DCBM 400/600 power meter driver adapter via HTTP.",
        "metadata": {
          "authors": [
            "Valentin Dimov, valentin.dimov@pionix.de",
            "Fabian Klemm, fabian.klemm@pionix.de"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "main": {
            "description": "This is the main unit of the module",
            "interface": "powermeter"
          }
        }
      },
      "MicroMegaWattBSP": {
        "config": {
          "baud_rate": {
            "default": 115200,
            "description": "Serial baud rate to use when communicating with Yeti hardware",
            "maximum": 230400,
            "minimum": 9600,
            "type": "integer"
          },
          "dc_max_voltage": {
            "default": 1e3,
            "description": "Maximum voltage to support",
            "maximum": 1e3,
            "minimum": 50,
            "type": "integer"
          },
          "reset_gpio": {
            "default": -1,
            "description": "Reset GPIO number to use to HW reset uMWC. If set <0 it is disabled.",
            "maximum": 1e3,
            "minimum": -1,
            "type": "integer"
          },
          "serial_port": {
            "default": "/dev/ttyUSB0",
            "description": "Serial port the Yeti hardware is connected to",
            "type": "string"
          }
        },
        "description": "Driver module for the Micro Mega Watt DC Charging Tester v1.0",
        "enable_external_mqtt": true,
        "metadata": {
          "authors": [
            "Cornelius Claussen"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "board_support": {
            "description": "provides the board support Interface to low level control control pilot, relais, rcd, motor lock",
            "interface": "evse_board_support"
          },
          "dc_supply": {
            "description": "Interface for the DC/DC output supply",
            "interface": "power_supply_DC"
          },
          "powermeter": {
            "description": "provides the Yeti Internal Power Meter",
            "interface": "powermeter"
          }
        }
      },
      "OCPP": {
        "config": {
          "ChargePointConfigPath": {
            "default": "ocpp-config.json",
            "description": "Path to the configuration file",
            "type": "string"
          },
          "DatabasePath": {
            "default": "/tmp/ocpp_1_6_charge_point",
            "description": "Path to the persistent SQLite database folder",
            "type": "string"
          },
          "EnableExternalWebsocketControl": {
            "default": false,
            "description": "If true websocket can be disconnected and connected externally",
            "type": "boolean"
          },
          "MessageLogPath": {
            "default": "/tmp/everest_ocpp_logs",
            "description": "Path to folder where logs of all OCPP messages get written to",
            "type": "string"
          },
          "MessageQueueResumeDelay": {
            "default": 0,
            "description": "Time (seconds) to delay resuming the message queue after reconnecting",
            "type": "integer"
          },
          "PublishChargingScheduleDurationS": {
            "default": 600,
            "description": "Duration in seconds that defines the duration of the requested charging schedules starting from now",
            "type": "integer"
          },
          "PublishChargingScheduleIntervalS": {
            "default": 30,
            "description": "Interval in seconds in which charging schedules received from OCPP are be published over MQTT and signalled to connected modules. If the value is set to 0, charging schedules are only published when changed by CSMS",
            "type": "integer"
          },
          "UserConfigPath": {
            "default": "user_config.json",
            "description": "Path to the file of the OCPP user config",
            "type": "string"
          }
        },
        "description": "A OCPP charge point / charging station module, currently targeting OCPP-J 1.6",
        "enable_external_mqtt": true,
        "metadata": {
          "authors": [
            "Kai-Uwe Hermann",
            "Piet Gömpel"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "auth_provider": {
            "description": "Provides auth tokens from OCPP",
            "interface": "auth_token_provider"
          },
          "auth_validator": {
            "description": "Validates the provided auth token with OCPP",
            "interface": "auth_token_validator"
          },
          "data_transfer": {
            "description": "OCPP data transfer towards the CSMS",
            "interface": "ocpp_data_transfer"
          },
          "main": {
            "description": "This is a OCPP 1.6 charge point",
            "interface": "ocpp_1_6_charge_point"
          },
          "ocpp_generic": {
            "description": "Generic OCPP interface.",
            "interface": "ocpp"
          }
        },
        "requires": {
          "auth": {
            "interface": "auth",
            "max_connections": 1,
            "min_connections": 1
          },
          "connector_zero_sink": {
            "interface": "external_energy_limits",
            "max_connections": 1,
            "min_connections": 0
          },
          "data_transfer": {
            "interface": "ocpp_data_transfer",
            "max_connections": 1,
            "min_connections": 0
          },
          "evse_manager": {
            "interface": "evse_manager",
            "max_connections": 128,
            "min_connections": 1
          },
          "reservation": {
            "interface": "reservation",
            "max_connections": 1,
            "min_connections": 1
          },
          "security": {
            "interface": "evse_security",
            "max_connections": 1,
            "min_connections": 1
          },
          "system": {
            "interface": "system",
            "max_connections": 1,
            "min_connections": 1
          }
        }
      },
      "OCPP201": {
        "config": {
          "CoreDatabasePath": {
            "default": "/tmp/ocpp201",
            "description": "Path to the persistent SQLite database folder",
            "type": "string"
          },
          "DeviceModelDatabasePath": {
            "default": "device_model_storage.db",
            "description": "Path to the SQLite database for the device model",
            "type": "string"
          },
          "EnableExternalWebsocketControl": {
            "default": false,
            "description": "If true websocket can be disconnected and connected externally",
            "type": "boolean"
          },
          "MessageLogPath": {
            "default": "/tmp/everest_ocpp_logs",
            "description": "Path to folder where logs of all OCPP messages get written to",
            "type": "string"
          },
          "MessageQueueResumeDelay": {
            "default": 0,
            "description": "Time (seconds) to delay resuming the message queue after reconnecting",
            "type": "integer"
          }
        },
        "description": "A OCPP charge point / charging station module for OCPP 2.0.1",
        "enable_external_mqtt": true,
        "metadata": {
          "authors": [
            "Piet Gömpel",
            "Kai-Uwe Hermann"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "auth_provider": {
            "description": "Provides authorization requests by CSMS",
            "interface": "auth_token_provider"
          },
          "auth_validator": {
            "description": "Validates the provided token using CSMS, AuthorizationList or AuthorizationCache",
            "interface": "auth_token_validator"
          },
          "data_transfer": {
            "description": "OCPP data transfer towards the CSMS",
            "interface": "ocpp_data_transfer"
          },
          "main": {
            "description": "This is a OCPP 2.0.1 charge point",
            "interface": "empty"
          },
          "ocpp_generic": {
            "description": "Generic OCPP interface.",
            "interface": "ocpp"
          }
        },
        "requires": {
          "auth": {
            "interface": "auth",
            "max_connections": 1,
            "min_connections": 1
          },
          "data_transfer": {
            "interface": "ocpp_data_transfer",
            "max_connections": 1,
            "min_connections": 0
          },
          "evse_manager": {
            "interface": "evse_manager",
            "max_connections": 128,
            "min_connections": 1
          },
          "security": {
            "interface": "evse_security",
            "max_connections": 1,
            "min_connections": 1
          },
          "system": {
            "interface": "system",
            "max_connections": 1,
            "min_connections": 1
          }
        }
      },
      "OCPPExtensionExample": {
        "config": {
          "keys_to_monitor": {
            "default": "HeartbeatInterval,SecurityProfile,ExampleConfigurationKey",
            "description": "Commad seperated list of keys that should be monitored",
            "type": "string"
          }
        },
        "description": "This is an example module that shows how the OCPP module of EVerest could be extended using the DataTransfer functionality and custom configuration keys",
        "metadata": {
          "authors": [
            "Piet Gömpel"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "data_transfer": {
            "description": "OCPP data transfer",
            "interface": "ocpp_data_transfer"
          }
        },
        "requires": {
          "data_transfer": {
            "interface": "ocpp_data_transfer",
            "max_connections": 1,
            "min_connections": 1
          },
          "ocpp": {
            "interface": "ocpp",
            "max_connections": 1,
            "min_connections": 1
          }
        }
      },
      "PN532TokenProvider": {
        "description": "PN532 RFID/NFC token provider returning the token as soon as the tag can be read by the reader",
        "metadata": {
          "authors": [
            "Cornelius Claussen",
            "Kai-Uwe Hermann",
            "Thilo Molitor",
            "Anton Wöllert"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "main": {
            "config": {
              "baud_rate": {
                "default": 115200,
                "description": "Serial baud rate to use when communicating with PN532 hardware",
                "maximum": 230400,
                "minimum": 9600,
                "type": "integer"
              },
              "debug": {
                "default": false,
                "description": "Show debug output on command line.",
                "type": "boolean"
              },
              "read_timeout": {
                "default": 5,
                "description": "Time between subsequent card reads (in s)",
                "maximum": 120,
                "minimum": 0,
                "type": "integer"
              },
              "serial_port": {
                "default": "/dev/ttyS0",
                "description": "Serial port the PN532 hardware is connected to",
                "type": "string"
              },
              "timeout": {
                "default": 30,
                "description": "Time a new token is valid (in s)",
                "maximum": 120,
                "minimum": 0,
                "type": "number"
              }
            },
            "description": "Implementation of PN532 RFID/NFC token provider",
            "interface": "auth_token_provider"
          }
        }
      },
      "PacketSniffer": {
        "config": {
          "device": {
            "default": "eth1",
            "description": "The ethernet device on which the messages are to be captured",
            "type": "string"
          },
          "session_logging_path": {
            "default": "/tmp",
            "description": "Output directory for session capture dump files",
            "type": "string"
          }
        },
        "description": 'Using the "PacketSniffer" EVerest module it is possible to capture and store the different packets on the PLC interface.',
        "metadata": {
          "authors": [
            "Sebastian Lukas"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "main": {
            "description": "EVerest API",
            "interface": "empty"
          }
        },
        "requires": {
          "evse_manager": {
            "interface": "evse_manager"
          }
        }
      },
      "PersistentStore": {
        "config": {
          "sqlite_db_file_path": {
            "default": "everest_persistent_store.db",
            "description": "Path to the SQLite db file.",
            "type": "string"
          }
        },
        "description": "Simple implementation of a SQLite backed persistent key-value store",
        "metadata": {
          "authors": [
            "Kai-Uwe Hermann"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "main": {
            "description": "This implements a persistent key-value store",
            "interface": "kvs"
          }
        }
      },
      "PowermeterBSM": {
        "config": {
          "baud": {
            "default": 19200,
            "description": "Baud rate on RS-485, allowed value range: 2400 115200 (19200 is default)",
            "maximum": 115200,
            "minimum": 2400,
            "type": "integer"
          },
          "meter_id": {
            "default": "no_meter_id",
            "description": "Arbitrary string id, used as power_meter_id in interface powermeter.",
            "type": "string"
          },
          "power_unit_id": {
            "description": "Modbus unit_id, mostly 1",
            "maximum": 255,
            "minimum": 1,
            "type": "integer"
          },
          "serial_device": {
            "default": "/dev/ttyUSB0",
            "description": "Serial port the BSM hardware is connected to",
            "type": "string"
          },
          "sunspec_base_address": {
            "default": 4e4,
            "description": "sunspec base address of device ( 0, 40000 or 50000 )",
            "type": "integer"
          },
          "update_interval": {
            "description": "Update interval in seconds.",
            "minimum": 1,
            "type": "integer"
          },
          "use_serial_comm_hub": {
            "default": true,
            "description": "When enabled, use a serial serial_communication_hub, otherwise use the configured serial device.",
            "type": "boolean"
          },
          "watchdog_wakeup_interval": {
            "default": 60,
            "description": "wakup interval of watchdog in seconds (default 60 seconds).",
            "minimum": 1,
            "type": "integer"
          }
        },
        "description": "Module that collects power and energy measurements from a MODBUS RTU device",
        "enable_external_mqtt": true,
        "metadata": {
          "authors": [
            "Christoph Kliemt"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "ac_meter": {
            "description": "sunspec ac meter",
            "interface": "sunspec_ac_meter"
          },
          "main": {
            "description": "This is the main unit of the module",
            "interface": "powermeter"
          }
        },
        "requires": {
          "serial_com_0_connection": {
            "interface": "serial_communication_hub",
            "max_connections": 1,
            "min_connections": 0
          }
        }
      },
      "PyEvJosev": {
        "config": {
          "device": {
            "default": "eth0",
            "description": "Ethernet device used for HLC. Any local interface that has an ipv6 link-local and a MAC addr will work.",
            "type": "string"
          },
          "enforce_tls": {
            "default": false,
            "description": "The EVCC will enforce a TLS connection",
            "type": "boolean"
          },
          "is_cert_install_needed": {
            "default": false,
            "description": "If true, the contract certificate will be installed via the evse. And any existing contract certificate will also be overwritten.",
            "type": "boolean"
          },
          "supported_DIN70121": {
            "default": false,
            "description": "The EVSE supports the DIN SPEC",
            "type": "boolean"
          },
          "supported_ISO15118_2": {
            "default": false,
            "description": "The EVSE supports ISO15118-2",
            "type": "boolean"
          },
          "supported_ISO15118_20_AC": {
            "default": false,
            "description": "The EVSE supports ISO15118-20 AC",
            "type": "boolean"
          },
          "supported_ISO15118_20_DC": {
            "default": false,
            "description": "The EVSE supports ISO15118-20 DC",
            "type": "boolean"
          },
          "tls_active": {
            "default": false,
            "description": "If true, EVCC connects to SECC as TLS client",
            "type": "boolean"
          }
        },
        "description": "This module implements an DIN70121, ISO15118-2 and ISO15118-20 EV using the Josev project.",
        "enable_external_mqtt": true,
        "metadata": {
          "authors": [
            "Sebastian Lukas"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "ev": {
            "description": "This module implements the ISO15118-2 implementation of an EV",
            "interface": "ISO15118_ev"
          }
        }
      },
      "PyExample": {
        "description": "Simple example module written in Python",
        "metadata": {
          "authors": [
            "Andreas Heinrich"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "example": {
            "description": "This implements an example_user interface that uses multiple framework features",
            "interface": "example_user"
          }
        }
      },
      "PyExampleUser": {
        "description": "Simple example module written in Python and using the other example module",
        "metadata": {
          "authors": [
            "Andreas Heinrich"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "example_user": {
            "description": "This implements the example_user interface",
            "interface": "example_user"
          }
        },
        "requires": {
          "example": {
            "interface": "example_user"
          }
        }
      },
      "SerialCommHub": {
        "description": "Hub to communicate with attached serial devices",
        "metadata": {
          "authors": [
            "Lars Dieckmann",
            "Cornelius Claussen"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "main": {
            "config": {
              "baudrate": {
                "default": 9600,
                "description": "Baudrate",
                "maximum": 230400,
                "minimum": 0,
                "type": "integer"
              },
              "ignore_echo": {
                "default": false,
                "description": "On some hardware every message that is sent is read back, this setting filters the sent message in the reply.",
                "type": "boolean"
              },
              "initial_timeout_ms": {
                "default": 500,
                "description": "Timeout in ms for the first packet.",
                "type": "integer"
              },
              "max_packet_size": {
                "default": 256,
                "description": "Maximum size of a packet to read/write in bytes. Payload exceeding the size will be chunked. The APU size according to [wikipedia](https://en.wikipedia.org/wiki/Modbus) is 256 bytes, which is used as default here.",
                "maximum": 65536,
                "minimum": 7,
                "type": "integer"
              },
              "parity": {
                "default": 0,
                "description": "Parity bit: 0: None, 1: Odd, 2: Even",
                "maximum": 2,
                "minimum": 0,
                "type": "integer"
              },
              "rxtx_gpio_chip": {
                "default": "",
                "description": "GPIO chip to use to switch between RX/TX. An empty string disables GPIO usage.",
                "type": "string"
              },
              "rxtx_gpio_line": {
                "default": 0,
                "description": "GPIO line to use to switch between RX/TX",
                "type": "integer"
              },
              "rxtx_gpio_tx_high": {
                "default": false,
                "description": "GPIO direction, false means low for TX, true means high for TX",
                "type": "boolean"
              },
              "serial_port": {
                "default": "/dev/ttyUSB0",
                "description": "Serial port the hardware is connected to",
                "type": "string"
              },
              "within_message_timeout_ms": {
                "default": 100,
                "description": "Timeout in ms for subsequent packets.",
                "type": "integer"
              }
            },
            "description": "Implementation of serial communication hub",
            "interface": "serial_communication_hub"
          }
        }
      },
      "Setup": {
        "config": {
          "ap_interface": {
            "default": "wlan0",
            "description": "Wifi interface for AP mode",
            "type": "string"
          },
          "ap_ipv4": {
            "default": "192.168.1.1/24",
            "description": "IPv4 address of the AP",
            "type": "string"
          },
          "initialized_by_default": {
            "default": true,
            "description": "Always report as if the charger was initialized",
            "type": "boolean"
          },
          "localization": {
            "default": false,
            "description": "Enable localization support",
            "type": "boolean"
          },
          "online_check_host": {
            "default": "lfenergy.org",
            "description": "Hostname or IP to use to check for internet connectivity",
            "type": "string"
          },
          "release_metadata_file": {
            "default": "release.json",
            "description": "Location of the release metadata file relative to the EVerest prefix",
            "type": "string"
          },
          "setup_simulation": {
            "default": false,
            "description": "Allow simulation setup",
            "type": "boolean"
          },
          "setup_wifi": {
            "default": false,
            "description": "Allow wifi setup",
            "type": "boolean"
          }
        },
        "description": "The EVerest Setup module for setting up a LAN or WIFI network connection. This module needs privileged access and should not run during normal operations",
        "enable_external_mqtt": true,
        "metadata": {
          "authors": [
            "Kai-Uwe Hermann"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "main": {
            "description": "EVerest Setup",
            "interface": "empty"
          }
        },
        "requires": {
          "store": {
            "interface": "kvs"
          }
        }
      },
      "Store": {
        "description": "Simple implementation of a memory-backed key-value store",
        "metadata": {
          "authors": [
            "Kai-Uwe Hermann",
            "Thilo Molitor"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "main": {
            "description": "This implements a key-value store",
            "interface": "kvs"
          }
        }
      },
      "System": {
        "config": {
          "DefaultRetries": {
            "default": 1,
            "description": "Specifies how many times Charge Point tries to upload or download files on previous failure.",
            "type": "number"
          },
          "DefaultRetryInterval": {
            "default": 1,
            "description": "Specifies in seconds after which time a retry of an upload or download on previous failure may be attempted.",
            "type": "number"
          }
        },
        "description": "This module implements system wide operations",
        "enable_external_mqtt": false,
        "metadata": {
          "authors": [
            "Piet Gömpel"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "main": {
            "description": "Implements the system interface",
            "interface": "system"
          }
        },
        "requires": {}
      },
      "YetiDriver": {
        "config": {
          "baud_rate": {
            "default": 115200,
            "description": "Serial baud rate to use when communicating with Yeti hardware",
            "maximum": 230400,
            "minimum": 9600,
            "type": "integer"
          },
          "caps_min_current_A": {
            "default": -1,
            "description": "Minimal current on AC side. For AC this is typically 6, but for HLC this can be less. -1 means use limit reported by HW.",
            "type": "integer"
          },
          "reset_gpio": {
            "default": 27,
            "description": "GPIO line to use to reset Yeti",
            "type": "integer"
          },
          "reset_gpio_chip": {
            "default": "gpiochip0",
            "description": "Reset GPIO chip to use to HW reset Yeti. If set to empty string, it is disabled.",
            "type": "string"
          },
          "serial_port": {
            "default": "/dev/ttyUSB0",
            "description": "Serial port the Yeti hardware is connected to",
            "type": "string"
          }
        },
        "description": "Driver module for the YETI hardware v1.0",
        "enable_telemetry": true,
        "metadata": {
          "authors": [
            "Cornelius Claussen",
            "Kai-Uwe Hermann",
            "Thilo Molitor",
            "Anton Wöllert"
          ],
          "license": "https://opensource.org/licenses/Apache-2.0"
        },
        "provides": {
          "board_support": {
            "description": "provides the board support Interface to low level control control pilot, relais, motor lock",
            "interface": "evse_board_support"
          },
          "connector_lock": {
            "description": "Interface for the motor lock",
            "interface": "connector_lock"
          },
          "powermeter": {
            "description": "provides the Yeti Internal Power Meter",
            "interface": "powermeter"
          },
          "rcd": {
            "description": "RCD interface of the onboard RCD",
            "interface": "ac_rcd"
          }
        }
      }
    };
    const SampleInterfaceList = {
      "ISO15118_charger": {
        "cmds": {
          "ac_contactor_closed": {
            "arguments": {
              "status": {
                "description": "Set to true when contactor is closed, false when contactor is open",
                "type": "boolean"
              }
            },
            "description": "This message is an async response to a previously published AC_Close_Contactor or AC_Open_Contactor."
          },
          "authorization_response": {
            "arguments": {
              "authorization_status": {
                "$ref": "/authorization#/AuthorizationStatus",
                "description": "Authorization status of the ID Token",
                "type": "string"
              },
              "certificate_status": {
                "$ref": "/authorization#/CertificateStatus",
                "description": "Certificate status information",
                "type": "string"
              }
            },
            "description": "This message is an async response to a previously published Require_Auth_EIM or Require_Auth_PnC. The SECC informs the EVCC whether the authorization is accecpted or not."
          },
          "cable_check_finished": {
            "arguments": {
              "status": {
                "description": "Set to true when cable check is okay",
                "type": "boolean"
              }
            },
            "description": "Cable check is finished, voltage is under 20V and insulation resistor on the cable is alright"
          },
          "certificate_response": {
            "arguments": {
              "exi_stream_status": {
                "$ref": "/iso15118_charger#/Response_Exi_Stream_Status",
                "description": "The response raw EXI stream and the status from the CSMS",
                "type": "object"
              }
            },
            "description": "This message is an async response to a previously published Certificate_Request. The new/updated Contract Certificate (including the certificate chain) and the corresponding encrypted private key are sent via the SECC to the EVCC."
          },
          "dlink_ready": {
            "arguments": {
              "value": {
                "description": "Set to true when link becomes ready, false when the link is terminated",
                "type": "boolean"
              }
            },
            "description": "Signals dlink_ready from SLAC layer according to ISO15118-3"
          },
          "receipt_is_required": {
            "arguments": {
              "receipt_required": {
                "description": "Set to true when receipt is required, set to false when not",
                "type": "boolean"
              }
            },
            "description": "This element is used by the SECC to indicate that the EVCC is required to send a MeteringReceiptReq message for the purpose of signing the meter info record."
          },
          "reset_error": {
            "description": "Reset all errors"
          },
          "send_error": {
            "arguments": {
              "error": {
                "$ref": "/iso15118_charger#/EvseError",
                "description": "The EVSE error enum",
                "type": "string"
              }
            },
            "description": "An error has happend. Send this error to inform the EV."
          },
          "session_setup": {
            "arguments": {
              "payment_options": {
                "description": "Providing a list of payment options to the EVCC",
                "items": {
                  "$ref": "/iso15118_charger#/PaymentOption",
                  "description": "These are the payment options a SECC offers to the EVCC",
                  "type": "string"
                },
                "maxItems": 2,
                "minItems": 1,
                "type": "array"
              },
              "supported_certificate_service": {
                "description": "The charger supports the certificate installation/update service and has a connection to an SA for this purpose",
                "type": "boolean"
              }
            },
            "description": "At each session start this info should be sent to the module."
          },
          "setup": {
            "arguments": {
              "debug_mode": {
                "description": "Enable/Disable debug mode",
                "type": "boolean"
              },
              "evse_id": {
                "$ref": "/iso15118_charger#/EVSEID",
                "description": "Set an ID that uniquely identifies the EVSE and the power outlet the vehicle is connected to ",
                "type": "object"
              },
              "physical_values": {
                "$ref": "/iso15118_charger#/SetupPhysicalValues",
                "description": "Set up initial physical values for a AC or DC charging session",
                "type": "object"
              },
              "sae_j2847_mode": {
                "$ref": "/iso15118_charger#/SAE_J2847_Bidi_Mode",
                "description": "Charger is supporting SAE J2847 V2G/V2H version",
                "type": "string"
              },
              "supported_energy_transfer_modes": {
                "description": "Available energy transfer modes supported by the EVSE",
                "items": {
                  "$ref": "/iso15118_charger#/EnergyTransferMode",
                  "description": "The different energy modes supported by the SECC",
                  "type": "string"
                },
                "maxItems": 6,
                "minItems": 1,
                "type": "array"
              }
            },
            "description": "At startup all necessary info should be sent to the module once."
          },
          "stop_charging": {
            "arguments": {
              "stop": {
                "description": "Set to true when to stop, set to false when to continue",
                "type": "boolean"
              }
            },
            "description": "Stops the charging process"
          },
          "update_ac_max_current": {
            "arguments": {
              "max_current": {
                "description": "Max current in A",
                "maximum": 400,
                "minimum": 0,
                "type": "number"
              }
            },
            "description": "Update the maximum allowed line current restriction per phase"
          },
          "update_dc_maximum_limits": {
            "arguments": {
              "maximum_limits": {
                "$ref": "/iso15118_charger#/DC_EVSEMaximumLimits",
                "description": "Maximum values (current, power and voltage) the EVSE can deliver",
                "type": "object"
              }
            },
            "description": "Update the maximum limits"
          },
          "update_dc_minimum_limits": {
            "arguments": {
              "minimum_limits": {
                "$ref": "/iso15118_charger#/DC_EVSEMinimumLimits",
                "description": "Minimum values (current and voltage) the EVSE can deliver",
                "type": "object"
              }
            },
            "description": "Update the minimum limits"
          },
          "update_dc_present_values": {
            "arguments": {
              "present_voltage_current": {
                "$ref": "/iso15118_charger#/DC_EVSEPresentVoltage_Current",
                "description": "Present voltage and current",
                "type": "object"
              }
            },
            "description": "Update the present values from the DC powersupply"
          },
          "update_isolation_status": {
            "arguments": {
              "isolation_status": {
                "$ref": "/iso15118_charger#/IsolationStatus",
                "description": "Result of the isolation monitoring",
                "type": "string"
              }
            },
            "description": "Update the isolation condition"
          },
          "update_meter_info": {
            "arguments": {
              "powermeter": {
                "$ref": "/powermeter#/Powermeter",
                "description": "Includes the meterInfo record containing the latest meter reading and other meter relevant data",
                "type": "object"
              }
            },
            "description": "Update meter info"
          }
        },
        "description": "This interface defines a ISO15118 charger.",
        "vars": {
          "AC_Close_Contactor": {
            "description": "The contactor should be closed",
            "type": "null"
          },
          "AC_EAmount": {
            "description": "[Wh] Amount of energy reflecting the EV's estimate how much energy is needed to fulfill the user configured charging goal for the current charging session",
            "maximum": 2e5,
            "minimum": 0,
            "type": "number"
          },
          "AC_EVMaxCurrent": {
            "description": "[A] Maximum current supported by the EV per phase",
            "maximum": 400,
            "minimum": 0,
            "type": "number"
          },
          "AC_EVMaxVoltage": {
            "description": "[V] The RMS of the maximal nominal voltage the vehicle can accept, measured between one phase and neutral",
            "maximum": 1e3,
            "minimum": 0,
            "type": "number"
          },
          "AC_EVMinCurrent": {
            "description": "[A] EVMinCurrent is used to indicate to the SECC that charging below this minimum is not energy/cost efficient for the EV",
            "maximum": 400,
            "minimum": 0,
            "type": "number"
          },
          "AC_Open_Contactor": {
            "description": "The contactor should be opened",
            "type": "null"
          },
          "Certificate_Request": {
            "$ref": "/iso15118_charger#/Request_Exi_Stream_Schema",
            "description": "The vehicle requests the SECC to deliver the certificate that belong  to the currently valid contract of the vehicle. Response will be reported async via  set_Get_Certificate_Response",
            "type": "object"
          },
          "DC_BulkChargingComplete": {
            "description": "Optional: If set to TRUE, the EV indicates that bulk charge (approx. 80% SOC) is complete",
            "type": "boolean"
          },
          "DC_BulkSOC": {
            "description": "Optional: [%] SOC at which the EV considers a fast charge process to end",
            "maximum": 100,
            "minimum": 0,
            "type": "number"
          },
          "DC_ChargingComplete": {
            "description": "Optional: If set to TRUE, the EV indicates that full charge (100% SOC) is complete",
            "type": "boolean"
          },
          "DC_EVEnergyCapacity": {
            "description": "Optional: [Wh] Energy capacity of the EV",
            "maximum": 2e5,
            "minimum": 0,
            "type": "number"
          },
          "DC_EVEnergyRequest": {
            "description": "Optional: [Wh] Amount of energy the EV requests from the EVSE",
            "maximum": 2e5,
            "minimum": 0,
            "type": "number"
          },
          "DC_EVMaximumLimits": {
            "$ref": "/iso15118_charger#/DC_EVMaximumLimits",
            "description": "Maximum Values (current, power and voltage) supported and allowed by the EV",
            "type": "object"
          },
          "DC_EVRemainingTime": {
            "$ref": "/iso15118_charger#/DC_EVRemainingTime",
            "description": "Estimated or calculated time until bulk and full charge is complete",
            "type": "object"
          },
          "DC_EVStatus": {
            "$ref": "/iso15118_charger#/DC_EVStatusType",
            "description": "Current status of the EV",
            "type": "object"
          },
          "DC_EVTargetVoltageCurrent": {
            "$ref": "/iso15118_charger#/DC_EVTargetValues",
            "description": "Target voltage and current requested by the EV",
            "type": "object"
          },
          "DC_FullSOC": {
            "description": "Optional: [%] SOC at which the EV considers the battery to be fully charged",
            "maximum": 100,
            "minimum": 0,
            "type": "number"
          },
          "DC_Open_Contactor": {
            "description": "The contactor should be opened",
            "type": "null"
          },
          "DepartureTime": {
            "description": "Optional: [RFC3339 UTC] This element is used to indicate when the vehicle intends to finish the charging process",
            "format": "date-time",
            "type": "string"
          },
          "EVCCIDD": {
            "description": "Specifies the EVs identification in a readable format. It contains the MAC address of the EVCC in uppercase",
            "pattern": "^[A-F0-9]{2}(:[A-F0-9]{2}){5}$",
            "type": "string"
          },
          "EV_AppProtocol": {
            "description": "Debug_Lite - This request message provides a list of charging protocols supported by the EVCC",
            "items": {
              "additionalProperties": false,
              "description": "This message element is used by the EVCC for transmitting the list of supported protocols",
              "properties": {
                "Priority": {
                  "description": "This message element is used by the EVCC for indicating the protocol priority of a specific protocol allowing the SECC to select a protocol based on priorities",
                  "maximum": 20,
                  "minimum": 1,
                  "type": "integer"
                },
                "ProtocolNamespace": {
                  "description": "This message element is used by the EVCC to uniquely identify the Namespace URI of a specific protocol supported by the EVCC",
                  "maxLength": 100,
                  "minLength": 1,
                  "type": "string"
                },
                "SchemaID": {
                  "description": "This message element is used by the EVCC to indicate the SchemaID assigned by the EVCC to the protocol",
                  "maximum": 255,
                  "minimum": 0,
                  "type": "integer"
                },
                "VersionNumberMajor": {
                  "description": "This message element is used by the EVCC to indicate the major version number of the protocol",
                  "minimum": 0,
                  "type": "integer"
                },
                "VersionNumberMinor": {
                  "description": "This message element is used by the EVCC to indicate the minor version number of the protocol",
                  "minimum": 0,
                  "type": "integer"
                }
              },
              "type": "object"
            },
            "maxItems": 20,
            "minItems": 1,
            "type": "array"
          },
          "RequestedEnergyTransferMode": {
            "$ref": "/iso15118_charger#/EnergyTransferMode",
            "description": "Selected energy transfer mode for charging that is requested by the EVCC.",
            "type": "string"
          },
          "Require_Auth_EIM": {
            "description": "An EIM authorization is requiered",
            "type": "null"
          },
          "Require_Auth_PnC": {
            "$ref": "/authorization#/ProvidedIdToken",
            "description": "The EVCC provides the payment details for a PnC authorization by sending the signature certificate chain and eMAID.",
            "type": "object"
          },
          "SelectedPaymentOption": {
            "$ref": "/iso15118_charger#/PaymentOption",
            "description": "This element is used for indicating the payment type",
            "type": "string"
          },
          "Selected_Protocol": {
            "description": "Debug - Contains the selected protocol",
            "type": "string"
          },
          "Start_CableCheck": {
            "description": "The charger should now start a cable check",
            "type": "null"
          },
          "V2G_Messages": {
            "$ref": "/iso15118_charger#/V2G_Messages",
            "description": "Debug - This element contains all V2G elements and should be used for debug purposes only",
            "type": "object"
          },
          "V2G_Setup_Finished": {
            "description": "V2G_Setup_Finished from ISO15118-3. Trigger when EV sends a PowerDeliveryReq message with ChargeProgess equals Start or Stop",
            "type": "null"
          },
          "currentDemand_Finished": {
            "description": "The charging process was finished",
            "type": "null"
          },
          "currentDemand_Started": {
            "description": "The charging process has started and the EV wants to be charged",
            "type": "null"
          },
          "dlink_error": {
            "description": "Terminate the data link and restart the matching process.",
            "type": "null"
          },
          "dlink_pause": {
            "description": "Request power saving mode, while staying MATCHED.",
            "type": "null"
          },
          "dlink_terminate": {
            "description": "Terminate the data link and become UNMATCHED.",
            "type": "null"
          },
          "sae_bidi_mode_active": {
            "description": "The SAE J2847 bidi mode is active",
            "type": "null"
          }
        }
      },
      "ISO15118_ev": {
        "cmds": {
          "enable_sae_j2847_v2g_v2h": {
            "description": "Enable the SAE J2847 2 V2H V2G"
          },
          "pause_charging": {
            "description": "Pause the ev charging communication process"
          },
          "set_bpt_dc_params": {
            "arguments": {
              "EV_BPT_Parameters": {
                "$ref": "/iso15118_ev#/DC_EV_BPT_Parameters",
                "description": "BPT parameters for dc charging",
                "type": "object"
              }
            },
            "description": "Set the bpt parameters for dc charging"
          },
          "set_dc_params": {
            "arguments": {
              "EV_Parameters": {
                "$ref": "/iso15118_ev#/DC_EVParameters",
                "description": "Target parameters for dc charging",
                "type": "object"
              }
            },
            "description": "Set the target parameters for a dc charging process"
          },
          "set_fault": {
            "description": "TODO_SL: Set the different ev faults to communicate these errors to the charging station"
          },
          "start_charging": {
            "arguments": {
              "EnergyTransferMode": {
                "description": "Selected energy transfer mode for charging that is requested by the EVCC",
                "enum": [
                  "AC_single_phase_core",
                  "AC_three_phase_core",
                  "DC_core",
                  "DC_extended",
                  "DC_combo_core",
                  "DC_unique"
                ],
                "type": "string"
              },
              "PaymentOption": {
                "description": "This element is used for indicating the payment type",
                "enum": [
                  "Contract",
                  "ExternalPayment"
                ],
                "type": "string"
              }
            },
            "description": "Start the ev charging process",
            "result": {
              "description": "Returns true if the evcc simulation started",
              "type": "boolean"
            }
          },
          "stop_charging": {
            "description": "Stop the ev charging communication process"
          }
        },
        "description": "This interface defines a simple ISO15118 ev.",
        "vars": {
          "AC_EVPowerReady": {
            "description": "The car is ready for power (HLC)",
            "type": "boolean"
          },
          "AC_EVSEMaxCurrent": {
            "description": "EVSE max current per phase",
            "maximum": 400,
            "minimum": 0,
            "type": "number"
          },
          "AC_StopFromCharger": {
            "description": "The charger wants to stop the charging process",
            "type": "null"
          },
          "DC_PowerOn": {
            "description": "The ev wants to close the dc contactors",
            "type": "null"
          },
          "V2G_Session_Finished": {
            "description": "The v2g session between the charger and the car is finished",
            "type": "null"
          }
        }
      },
      "ac_rcd": {
        "cmds": {
          "reset": {
            "description": "Resets the RCD after a trigger. May not be supported by actual hardware.",
            "result": {
              "description": "True: Reset successfull, False: Reset failed.",
              "type": "boolean"
            }
          },
          "self_test": {
            "description": "Executes a self test of the RCD. If it fails, an error of type Selftest should be raised."
          }
        },
        "description": "This interface provides an AC Residual Current Monitor (RCD). Actual emergency switch off is done in HW directly, but this interface allows some control and telemetry.",
        "errors": [
          {
            "reference": "/errors/ac_rcd"
          }
        ],
        "vars": {
          "rcd_current_mA": {
            "description": "Residual current in mA. Note that this does not trigger anything, it is merely for reporting.",
            "type": "number"
          }
        }
      },
      "auth": {
        "cmds": {
          "set_connection_timeout": {
            "arguments": {
              "connection_timeout": {
                "description": "Connection timeout in seconds",
                "maximum": 300,
                "minimum": 10,
                "type": "integer"
              }
            },
            "description": "Sets the connection timeout"
          },
          "set_master_pass_group_id": {
            "arguments": {
              "master_pass_group_id": {
                "description": "The master pass group id",
                "maxLength": 36,
                "type": "string"
              }
            },
            "description": "Sets the master pass group id. IdTokens that have this id as parent_id_token belong to the Master Pass Group.  This means they can stop any ongoing transaction, but cannot start transactions. This can, for example, be used by law enforcement personal to stop any ongoing transaction when an EV has to be towed away. If master_pass_group_id  is an empty string, it is not used."
          }
        },
        "description": "Interface of authentication framework",
        "vars": {
          "token_validation_status": {
            "$ref": "/authorization#/TokenValidationStatusMessage",
            "description": "Emits all events related to current token validation",
            "type": "object"
          }
        }
      },
      "auth_token_provider": {
        "description": "Interface to provide a token",
        "vars": {
          "provided_token": {
            "$ref": "/authorization#/ProvidedIdToken",
            "description": "The provided token",
            "type": "object"
          }
        }
      },
      "auth_token_validator": {
        "cmds": {
          "validate_token": {
            "arguments": {
              "provided_token": {
                "$ref": "/authorization#/ProvidedIdToken",
                "description": "Contains information about the authorization request",
                "type": "object"
              }
            },
            "description": "Validate auth token and return result (with optional reason string)",
            "result": {
              "$ref": "/authorization#/ValidationResult",
              "description": "Result object containing validation result",
              "type": "object"
            }
          }
        },
        "description": "Checks provided tokens for validity"
      },
      "bank_session_token_provider": {
        "cmds": {
          "get_bank_session_token": {
            "description": "Returns the token.",
            "result": {
              "$ref": "/bank_transaction#/BankSessionToken",
              "description": "token",
              "type": "object"
            }
          }
        },
        "description": "Provides the token that can be used to uniquely identify the session in the bank statement."
      },
      "bank_transaction_summary_provider": {
        "description": "Provides information of the session that was committed to the bank. This data may be needed for accounting purposes.",
        "vars": {
          "bank_transaction_summary": {
            "$ref": "/bank_transaction#/BankTransactionSummary",
            "description": "Summary of a bank transaction. Depends on bank and the backend. Therefore it's mostly opaque data at the moment.",
            "type": "object"
          }
        }
      },
      "car_simulator": {
        "cmds": {
          "enable": {
            "arguments": {
              "value": {
                "description": "Enable/Disable simulation mode",
                "type": "boolean"
              }
            },
            "description": "Sets the ID that uniquely identifies the EVSE. The EVSEID shall match the following structure: <EVSEID> = <Country Code> <S> <EVSE Operator ID> <S> <ID Type> <Power Outlet ID>"
          },
          "executeChargingSession": {
            "arguments": {
              "value": {
                "description": "Charging simulation string",
                "type": "string"
              }
            },
            "description": "Executes a charging simulation string"
          }
        },
        "description": "This defines a car simulator that can execute a full charging session, from plugging in to plugging out. It uses HIL or SIL simulation controllers from e.g. the Yeti HIL simulator.",
        "vars": {
          "enabled": {
            "description": "Indicates whether simulation is currently enabled or not",
            "type": "boolean"
          }
        }
      },
      "connector_lock": {
        "cmds": {
          "lock": {
            "description": "Lock connector lock"
          },
          "unlock": {
            "description": "Unlock connector lock (e.g. normal unlock or enforced by OCPP)"
          }
        },
        "description": "This interface defines one connector locking motor (e.g. for AC sockets with no fixed attached cable)",
        "errors": [
          {
            "reference": "/errors/connector_lock"
          }
        ]
      },
      "debug_json": {
        "description": "This interface defines a generic JSON object debug variable publisher for use in any module. Can be used to display debug variables e.g. in web interface.",
        "vars": {
          "debug_json": {
            "description": "Provides the debug object as a json object",
            "type": "object"
          },
          "title": {
            "description": "Title of the Debug object",
            "type": "string"
          }
        }
      },
      "empty": {
        "description": "This interface is empty and can be used for a config-only (main) implementation"
      },
      "energy": {
        "cmds": {
          "enforce_limits": {
            "arguments": {
              "value": {
                "$ref": "/energy#/EnforcedLimits",
                "description": "Limit object that will be routed through the tree.",
                "type": "object"
              }
            },
            "description": "The EnergyManager enforces a limit using this command."
          }
        },
        "description": "This interface is the internal energy management inteface between nodes.",
        "vars": {
          "energy_flow_request": {
            "$ref": "/energy#/EnergyFlowRequest",
            "description": "Request energy flow to supply/limit energy import (direction from grid to car) and/or consume/limit energy export (car to grid).",
            "type": "object"
          }
        }
      },
      "energy_manager": {
        "description": "This interface defines the global EnergyManager",
        "vars": {}
      },
      "energy_price_information": {
        "description": "This interface defines the interface for an energy price forecast",
        "vars": {
          "energy_pricing": {
            "$ref": "/energy_price_information#/EnergyPriceSchedule",
            "description": "Forecast JSON Object containing timestamps and the price forecast for both import and export.",
            "type": "object"
          }
        }
      },
      "ev_slac": {
        "cmds": {
          "reset": {
            "description": "Reset SLAC"
          },
          "trigger_matching": {
            "description": "Trigger start of matching process",
            "result": {
              "description": "True on success, returns False if transition was unexpected and cannot be handled by SLAC state machine.",
              "type": "boolean"
            }
          }
        },
        "description": "ISO15118-3 SLAC interface for EV side",
        "vars": {
          "dlink_ready": {
            "description": "Inform higher layers about a change in data link status. Emits true if link was set up and false when the link is shut down.",
            "type": "boolean"
          },
          "ev_mac_address": {
            "description": "Inform higher layers about the MAC address of the charging connector",
            "pattern": "^[A-F0-9]{2}(:[A-F0-9]{2}){5}$",
            "type": "string"
          },
          "state": {
            "description": "Provides the state enum.",
            "enum": [
              "UNMATCHED",
              "MATCHING",
              "MATCHED"
            ],
            "type": "string"
          }
        }
      },
      "evse_board_support": {
        "cmds": {
          "ac_read_pp_ampacity": {
            "description": "Read the current carrying capacity of the connected cable in ampere for AC charging with a socket. This function will be used by EvseManager to get the PP value at  a distinct time. You should also publish the var pp_ampacity whenever the PP ampacity reading changes to signal changes e.g. during the charging time. This has no meaning for DC or AC charging with a fixed attached cable, it does not  need to be implemented and the returned value is not used in those cases.",
            "result": {
              "$ref": "/board_support_common#/ProximityPilot",
              "description": "Returns the current carrying capacity of the connected cable",
              "type": "object"
            }
          },
          "ac_set_overcurrent_limit_A": {
            "arguments": {
              "value": {
                "description": "Ampere current limit value",
                "type": "number"
              }
            },
            "description": "Many chargers implement a fast over current shutdown directly in the hardware that triggers if the EV draws more current than the PWM allows. If the hardware does not have this functionality, just ignore this command. Do not use it to set the PWM duty cycle. Otherwise this command reports a value that should be used for the overcurrent detection.  A margin needs to be added to avoid false triggers. Do not use the PWM duty cycle to infer the current limit in the BSP, as this will not work with HLC."
          },
          "ac_switch_three_phases_while_charging": {
            "arguments": {
              "value": {
                "description": "True: switch to 3ph, False: switch to 1ph",
                "type": "boolean"
              }
            },
            "description": "Optional, in case of doubt do not implement. Report in hardware_capabilites if this command is supported. This command switches between one and three phase operation during an active charging session. Some cars can be permanently destroyed by that, so the bsp needs to implement a special sequence for the switching. The exact sequence can be defined by the BSP, but one example would be a C2->C1->B1->F->B1->B2->C2 or similar. Use with caution."
          },
          "allow_power_on": {
            "arguments": {
              "value": {
                "$ref": "/evse_board_support#/PowerOnOff",
                "description": "Flag and context",
                "type": "object"
              }
            },
            "description": "Sets allow_power_on flag. If false, Relais must never be switched on."
          },
          "enable": {
            "arguments": {
              "value": {
                "description": "True: enabled, false: disabled.",
                "type": "boolean"
              }
            },
            "description": "Enables or disables the charging port. Typically disabled results in control pilot state F. It must not accept cars for new charging sessions if disabled."
          },
          "evse_replug": {
            "arguments": {
              "value": {
                "description": "Time in ms for the duration of the replug sequence",
                "type": "integer"
              }
            },
            "description": "Optional, in case of doubt do not implement. Special command initiate a virtual replug sequence without restarting session. Emits a EvseReplugStarted event if supported and started. BSP will take care to not emit other events such as CarPluggedIn/Out during that time. Once finished it will emit a EvseReplugFinished. This is mainly for testing purposes, don't implement for production use."
          },
          "get_hw_capabilities": {
            "description": "Get Hardware capability/limits. For AC these are the limits of the power path (e.g. relais etc).  For DC, these are the limits for the AC input of the ACDC converter stack, i.e. the complete AC input. Note that DC output limits are reported by the DC power supply itself.",
            "result": {
              "$ref": "/evse_board_support#/HardwareCapabilities",
              "description": "Hardware capability/limits",
              "type": "object"
            }
          },
          "pwm_F": {
            "description": "Turns PWM off with Error F (constant negative voltage)"
          },
          "pwm_off": {
            "description": "Turns PWM off (constant high voltage)"
          },
          "pwm_on": {
            "arguments": {
              "value": {
                "description": "PWM duty cycle (>0, <100)",
                "maximum": 100,
                "minimum": 0,
                "type": "number"
              }
            },
            "description": "Turns PWM on with duty cycle (in percent)"
          },
          "setup": {
            "arguments": {
              "country_code": {
                "description": "A two-letter country code in ISO 3166-1 alpha-2 format",
                "type": "string"
              },
              "has_ventilation": {
                "description": "true: Allow mode D charging, false: do not allow mode D charging",
                "type": "boolean"
              },
              "three_phases": {
                "description": "true: Three phases enabled, false: only single phase",
                "type": "boolean"
              }
            },
            "description": "Setup config options"
          }
        },
        "description": "This interface defines the board support driver for AC or DC minimal power path: ControlPilot, output contactors.  Other components of the power path such as IMD(DC)/RCD(AC)/Connector Lock etc have their own interfaces.",
        "errors": [
          {
            "reference": "/errors/evse_board_support"
          }
        ],
        "vars": {
          "ac_nr_of_phases_available": {
            "description": "Instantaneous phase count available to car",
            "maximum": 3,
            "minimum": 1,
            "type": "integer"
          },
          "ac_pp_ampacity": {
            "$ref": "/board_support_common#/ProximityPilot",
            "description": "Current carrying capacity of the connected cable in ampere for AC charging with a socket. Publish whenever it changes. This has no meaning for DC or AC charging with a fixed attached cable, it does not  need to be implemented and the returned value is not used in those cases.",
            "type": "object"
          },
          "capabilities": {
            "$ref": "/evse_board_support#/HardwareCapabilities",
            "description": "Hardware capabilities/limits. Initially EvseManager will call get_hw_capabilities once to fetch the limits and caches the limits internally. The BSP module does not have to publish this variable at all, then the initially fetched capabilities will be used. The BSP may publish this variable to update limits in case they change during runtime, e.g. if the maximum current changes because the hardware gets too hot.",
            "type": "object"
          },
          "event": {
            "$ref": "/board_support_common#/BspEvent",
            "description": "Event from ControlPilot signal/output relais",
            "type": "object"
          },
          "telemetry": {
            "$ref": "/evse_board_support#/Telemetry",
            "description": "Other telemetry",
            "type": "object"
          }
        }
      },
      "evse_manager": {
        "cmds": {
          "authorize_response": {
            "arguments": {
              "provided_token": {
                "$ref": "/authorization#/ProvidedIdToken",
                "description": "The token for which authorization was requested",
                "type": "object"
              },
              "validation_result": {
                "$ref": "/authorization#/ValidationResult",
                "description": "The validation result",
                "type": "object"
              }
            },
            "description": "Reports the result of an authorization request to the EvseManager.  Contains the provided_token for which authorization was requested and the validation_result"
          },
          "cancel_reservation": {
            "description": "Call to signal that EVSE is not reserved anymore"
          },
          "disable": {
            "arguments": {
              "connector_id": {
                "description": "Specifies the ID of the connector. If 0, the whole EVSE should be disabled",
                "type": "integer"
              }
            },
            "description": "Disables the evse. EVSE is not available for charging after this operation",
            "result": {
              "description": "Returns true if evse was disabled (or was disabled before), returns false if it could not be disabled (i.e. due to communication error with hardware)",
              "type": "boolean"
            }
          },
          "enable": {
            "arguments": {
              "connector_id": {
                "description": "Specifies the ID of the connector to enable. If 0, the whole EVSE should be enabled",
                "type": "integer"
              }
            },
            "description": "Enables the evse. EVSE is available for charging after this operation",
            "result": {
              "description": "Returns true if evse was enabled (or was enabled before), returns false if enable failed e.g. due to permanent fault.",
              "type": "boolean"
            }
          },
          "external_ready_to_start_charging": {
            "description": "There are situations where another module needs to do some initialization after evse manager is in principle ready to start charging. This command can be used (optimally in combination with a configuration option) to delay charging ready until the external module is done with its initialization",
            "result": {
              "description": "Returns true if the signal was used by the evse manager implementation",
              "type": "boolean"
            }
          },
          "force_unlock": {
            "arguments": {
              "connector_id": {
                "description": "Specifies the ID of the connector that should be unlocked",
                "type": "integer"
              }
            },
            "description": "Forces connector to unlock connector now. During normal operation, connector will be locked/unlocked in the correct sequence. Do not use this function except if explicitly requested by e.g. management cloud.",
            "result": {
              "description": "Returns true if unlocking sequence was successfully executed",
              "type": "boolean"
            }
          },
          "get_evse": {
            "description": "Call to get information about the EVSE including its connectors",
            "result": {
              "$ref": "/evse_manager#/Evse",
              "description": "Object that contains information of the EVSE including its connectors",
              "type": "object"
            }
          },
          "pause_charging": {
            "description": "Call to signal EVSE to pause charging",
            "result": {
              "description": "Returns true if successfully paused or was already in paused_by_evse mode",
              "type": "boolean"
            }
          },
          "reserve": {
            "arguments": {
              "reservation_id": {
                "description": "The reservation id (should be added to the TransactionStarted event)",
                "type": "integer"
              }
            },
            "description": "Call to signal that EVSE is reserved. This can be used to e.g. change the color of the HMI LEDs to indicate reservation.",
            "result": {
              "description": "Returns true if the EVSE accepted the reservation, else false.",
              "type": "boolean"
            }
          },
          "resume_charging": {
            "description": "Call to signal EVSE to resume charging",
            "result": {
              "description": "Returns true if resume was successful, false otherwise (e.g. resuming a car pause won't work)",
              "type": "boolean"
            }
          },
          "set_external_limits": {
            "arguments": {
              "value": {
                "$ref": "/energy#/ExternalLimits",
                "description": "UUID of node that this limit applies to",
                "type": "object"
              }
            },
            "description": "Set additional external energy flow limits at this node."
          },
          "set_faulted": {
            "description": "Sets the evse manager to faulted externally. It may also switch to faulted itself if it detects an internal error."
          },
          "set_get_certificate_response": {
            "arguments": {
              "certificate_response": {
                "$ref": "/iso15118_charger#/Response_Exi_Stream_Status",
                "description": "The response raw exi stream and the status from the CSMS system",
                "type": "object"
              }
            },
            "description": "CertificateInstallationRes/CertificateUpdateRes - Set the new/updated Contract Certificate (including the certificate chain) and the corresponding encrypted private key. Should be forwared to EVCC. This is an async response to a previously published iso15118_certificate_request"
          },
          "stop_transaction": {
            "arguments": {
              "request": {
                "$ref": "/evse_manager#/StopTransactionRequest",
                "description": "Request to stop the transaction.",
                "type": "object"
              }
            },
            "description": "Stops transaction and cancels charging externally, charging can only be resumed by replugging car. EVSE will also stop transaction automatically e.g. on disconnect, so this only needs to be called if the transaction should end before.",
            "result": {
              "description": "Returns true if successful",
              "type": "boolean"
            }
          },
          "switch_three_phases_while_charging": {
            "arguments": {
              "three_phases": {
                "description": "True: switch to three phases, false: switch to single phase",
                "type": "boolean"
              }
            },
            "description": "Switch three phases while charging",
            "result": {
              "$ref": "/evse_manager#/SwitchThreePhasesWhileChargingResult",
              "description": "Returns success or error code",
              "type": "string"
            }
          },
          "withdraw_authorization": {
            "description": "Call to signals that EVSE is not further authorized to start a transaction (e.g. on a connection_timeout)"
          }
        },
        "description": "This interface defines the evse manager. An evse manager represents the charging kernel of one physical connector.",
        "errors": [
          {
            "reference": "/errors/evse_manager"
          }
        ],
        "vars": {
          "car_manufacturer": {
            "$ref": "/evse_manager#/CarManufacturer",
            "description": "Car manufacturer (if known)",
            "type": "string"
          },
          "enforced_limits": {
            "$ref": "/energy#/EnforcedLimits",
            "description": "Enforced limits for this node (coming from the EnergyManager)",
            "type": "object"
          },
          "ev_info": {
            "$ref": "/evse_manager#/EVInfo",
            "description": "More details about the EV if available",
            "type": "object"
          },
          "evse_id": {
            "description": "EVSE ID including the connector number, e.g. DE*PNX*E123456*1",
            "type": "string"
          },
          "hw_capabilities": {
            "$ref": "/evse_board_support#/HardwareCapabilities",
            "description": "Hardware capability/limits",
            "type": "object"
          },
          "iso15118_certificate_request": {
            "$ref": "/iso15118_charger#/Request_Exi_Stream_Schema",
            "description": "The vehicle requests the SECC to deliver the certificate that belong  to the currently valid contract of the vehicle. Response will be reported async via  set_get_certificate_response",
            "type": "object"
          },
          "limits": {
            "$ref": "/evse_manager#/Limits",
            "description": "Limits of this evse, published on change",
            "type": "object"
          },
          "powermeter": {
            "$ref": "/powermeter#/Powermeter",
            "description": "Measured dataset",
            "type": "object"
          },
          "ready": {
            "description": "Signals that the EVSE Manager is ready to start charging",
            "type": "boolean"
          },
          "selected_protocol": {
            "description": "Contains the selected protocol used for charging for informative purposes",
            "type": "string"
          },
          "session_event": {
            "$ref": "/evse_manager#/SessionEvent",
            "description": "Emits all events related to sessions",
            "type": "object"
          },
          "telemetry": {
            "$ref": "/evse_board_support#/Telemetry",
            "description": "Other telemetry",
            "type": "object"
          },
          "waiting_for_external_ready": {
            "description": "Signals that the EVSE Manager is in principle ready to start charging, but delays sending its ready signal waiting for the external_ready_to_start_charging command.",
            "type": "boolean"
          }
        }
      },
      "evse_security": {
        "cmds": {
          "delete_certificate": {
            "arguments": {
              "certificate_hash_data": {
                "$ref": "/evse_security#/CertificateHashData",
                "description": "Indicates the certificate that should be deleted",
                "type": "object"
              }
            },
            "description": "Command to delete a certificate",
            "result": {
              "$ref": "/evse_security#/DeleteCertificateResult",
              "description": "Result of the attempt to delete a certificate",
              "type": "string"
            }
          },
          "generate_certificate_signing_request": {
            "arguments": {
              "certificate_type": {
                "$ref": "/evse_security#/LeafCertificateType",
                "description": "Specifies the leaf certificate type",
                "type": "string"
              },
              "common": {
                "description": "Specifies the common name (CN) of the certificate",
                "type": "string"
              },
              "country": {
                "description": "Specifies the country name (C) of the certificate",
                "type": "string"
              },
              "organization": {
                "description": "Specifies the organization name (O) of the certificate",
                "type": "string"
              },
              "use_tpm": {
                "description": "Specifies if the CSR should store the private key on the TPM",
                "type": "boolean"
              }
            },
            "description": "Command to generate a certificate signing request for the given use",
            "result": {
              "description": "The certificate signing request in PEM format",
              "type": "string"
            }
          },
          "get_installed_certificates": {
            "arguments": {
              "certificate_types": {
                "description": "Types of certificates to be retrieved",
                "items": {
                  "$ref": "/evse_security#/CertificateType",
                  "minimum": 0,
                  "type": "string"
                },
                "type": "array"
              }
            },
            "description": "Command to retrieve installed certificates of the EVSE",
            "result": {
              "$ref": "/evse_security#/GetInstalledCertificatesResult",
              "description": "Indicates the result of the command and optional certificate hash data",
              "type": "object"
            }
          },
          "get_key_pair": {
            "arguments": {
              "certificate_type": {
                "$ref": "/evse_security#/LeafCertificateType",
                "description": "Specifies the leaf certificate type",
                "type": "string"
              },
              "encoding": {
                "$ref": "/evse_security#/EncodingFormat",
                "description": "Specifies the encoding of the key",
                "type": "string"
              }
            },
            "description": "Command to get the paths of the certificate and the respective key",
            "result": {
              "$ref": "/evse_security#/GetKeyPairResult",
              "description": "The response to the requested command",
              "type": "object"
            }
          },
          "get_leaf_expiry_days_count": {
            "arguments": {
              "certificate_type": {
                "$ref": "/evse_security#/LeafCertificateType",
                "description": "Indicates the type of the certificate",
                "type": "string"
              }
            },
            "description": "Command to get the days count until the given leaf certificate expires.  If no leaf certificate is installed this command will return 0",
            "result": {
              "description": "days count until given leaf certificate expires",
              "type": "integer"
            }
          },
          "get_mo_ocsp_request_data": {
            "arguments": {
              "certificate_chain": {
                "description": "Certificate chain for which the OCSP data is retrieved",
                "type": "string"
              }
            },
            "description": "Command to retrieve the OCSP request data of the given MO certificate chain. Contains OCSP data for each certificate that is present in the chain (excluding the root)",
            "result": {
              "$ref": "/evse_security#/OCSPRequestDataList",
              "description": "The OCSP request data of the given certificate chain. Contains OCSP data for each certificate in the given chain. ",
              "type": "object"
            }
          },
          "get_v2g_ocsp_request_data": {
            "description": "Command to retrieve the OCSP request data of the V2G certificates. Contains OCSP data for each certificate that is present in the chain (excluding the root). ",
            "result": {
              "$ref": "/evse_security#/OCSPRequestDataList",
              "description": "The OCSP request data of all V2G CA certificates including the Sub CAs (exluding the root)",
              "type": "object"
            }
          },
          "get_verify_file": {
            "arguments": {
              "certificate_type": {
                "$ref": "/evse_security#/CaCertificateType",
                "description": "Specifies that CA certificate type",
                "type": "string"
              }
            },
            "description": "Command to get the file path of a CA bundle that can be used for verification",
            "result": {
              "description": "The path of the CA bundle file",
              "type": "string"
            }
          },
          "install_ca_certificate": {
            "arguments": {
              "certificate": {
                "description": "A PEM encoded X.509 certificate.",
                "type": "string"
              },
              "certificate_type": {
                "$ref": "/evse_security#/CaCertificateType",
                "description": "Indicates the type of the certificate",
                "type": "string"
              }
            },
            "description": "Command to install a new CA certificate",
            "result": {
              "$ref": "/evse_security#/InstallCertificateResult",
              "description": "Result of the attempt to install a CA certificate",
              "type": "string"
            }
          },
          "is_ca_certificate_installed": {
            "arguments": {
              "certificate_type": {
                "$ref": "/evse_security#/CaCertificateType",
                "description": "Specifies that CA certificate type",
                "type": "string"
              }
            },
            "description": "Command that indicates of the given CA certificate type is installed",
            "result": {
              "description": "True if CA certificate is installed, else false",
              "type": "boolean"
            }
          },
          "update_leaf_certificate": {
            "arguments": {
              "certificate_chain": {
                "description": "Leaf certificate or certificate chain that should be installed",
                "type": "string"
              },
              "certificate_type": {
                "$ref": "/evse_security#/LeafCertificateType",
                "description": "Indicates the type of the certificate",
                "type": "string"
              }
            },
            "description": "Command to install or update SECC or CSMS leaf certificate",
            "result": {
              "$ref": "/evse_security#/InstallCertificateResult",
              "description": "Result of the attempt to install or update a leaf certificate",
              "type": "string"
            }
          },
          "update_ocsp_cache": {
            "arguments": {
              "certificate_hash_data": {
                "$ref": "/evse_security#/CertificateHashData",
                "description": "Certificate hash data that identifies the certificate for which the cache should be updated",
                "type": "object"
              },
              "ocsp_response": {
                "description": "OCSPResponse class as defined in IETF RFC 6960. DER and then base64 encoded",
                "type": "string"
              }
            },
            "description": "Command to update the OCSP cache with the given data"
          },
          "verify_certificate": {
            "arguments": {
              "certificate_chain": {
                "description": "Leaf certificate or certificate chain that is to be verified",
                "type": "string"
              },
              "certificate_type": {
                "$ref": "/evse_security#/LeafCertificateType",
                "description": "Indicates the type of the certificate",
                "type": "string"
              }
            },
            "description": "Command to verify the given certificate",
            "result": {
              "$ref": "/evse_security#/CertificateValidationResult",
              "description": "Result of the verification",
              "type": "string"
            }
          },
          "verify_file_signature": {
            "arguments": {
              "file_path": {
                "description": "Path to the file that should be verified",
                "type": "string"
              },
              "signature": {
                "description": "Base64 encoded file signature",
                "type": "string"
              },
              "signing_certificate": {
                "description": "Certificate with which the file was signed. PEM encoded X.509 certificate",
                "type": "string"
              }
            },
            "description": "Verify the file at the given path using the provided certificate and signature",
            "result": {
              "description": "True if verification succeeded, false if not",
              "type": "boolean"
            }
          }
        },
        "description": "This interface provides security related functions and access to secure storage that an EVSE needs to provide. This includes the handling of all security related functions specified within OCPP and ISO15118. The modules that implement this interface are responsible for checking the validity period of the leaf certificates and initiate certificate signing request if leaf certificates are about to expire."
      },
      "example": {
        "cmds": {
          "uses_something": {
            "arguments": {
              "key": {
                "description": "Key to check the existence for",
                "pattern": "^[A-Za-z0-9_.]+$",
                "type": "string"
              }
            },
            "description": "This command checks if something is stored under a given key",
            "result": {
              "description": "Returns 'True' if something was stored for this key",
              "type": "boolean"
            }
          }
        },
        "description": "This interface defines an example interface that uses multiple framework features",
        "errors": [
          {
            "reference": "/errors/example"
          }
        ],
        "vars": {
          "max_current": {
            "description": "Provides maximum current of this supply in ampere",
            "type": "number"
          }
        }
      },
      "example_user": {
        "description": "This interface defines an example_user interface that uses the example interface",
        "errors": [
          {
            "reference": "/errors/example#/ExampleErrorA"
          },
          {
            "reference": "/errors/example#/ExampleErrorB"
          },
          {
            "reference": "/errors/example#/ExampleErrorC"
          },
          {
            "reference": "/errors/example#/ExampleErrorD"
          }
        ]
      },
      "external_energy_limits": {
        "cmds": {
          "set_external_limits": {
            "arguments": {
              "value": {
                "$ref": "/energy#/ExternalLimits",
                "description": "External limits object",
                "type": "object"
              }
            },
            "description": "Set additional external energy flow limits at this node."
          }
        },
        "description": "This interface allows to limit energy flow at a specific node of the energy tree from the outside (e.g. from ocpp).",
        "vars": {
          "enforced_limits": {
            "$ref": "/energy#/EnforcedLimits",
            "description": "Enforced limits for this node (coming from the EnergyManager)",
            "type": "object"
          }
        }
      },
      "isolation_monitor": {
        "cmds": {
          "start": {
            "description": "Start recurring isolation measurements. The device should monitor the isolation status until stopped and publish the resistance data in regular intervals. The actual interval is device dependent."
          },
          "stop": {
            "description": "Stop recurring measurements. The device should stop to monitor the isolation resistance and stop publishing the data."
          }
        },
        "description": "This interface defines an isolation monitoring device (IMD) according to IEC 61557-8 for DC charging. This is used to verify isolation of the DC lines before starting high voltage charging and during charging.",
        "vars": {
          "IsolationMeasurement": {
            "$ref": "/isolation_monitor#/IsolationMeasurement",
            "description": "Isolation monitoring measurement results",
            "type": "object"
          }
        }
      },
      "kvs": {
        "cmds": {
          "delete": {
            "arguments": {
              "key": {
                "description": "Key to delete the value for",
                "pattern": "^[A-Za-z0-9_.]+$",
                "type": "string"
              }
            },
            "description": "This command removes the value stored under a given key"
          },
          "exists": {
            "arguments": {
              "key": {
                "description": "Key to check the existence for",
                "pattern": "^[A-Za-z0-9_.]+$",
                "type": "string"
              }
            },
            "description": "This command checks if something is stored under a given key",
            "result": {
              "description": "Returns 'True' if something was stored for this key",
              "type": "boolean"
            }
          },
          "load": {
            "arguments": {
              "key": {
                "description": "Key to load the value for",
                "pattern": "^[A-Za-z0-9_.]+$",
                "type": "string"
              }
            },
            "description": "This command loads the previously stored value for a given key (it will return null if the key does not exist)",
            "result": {
              "description": "The previously stored value",
              "type": [
                "null",
                "string",
                "number",
                "integer",
                "boolean",
                "array",
                "object"
              ]
            }
          },
          "store": {
            "arguments": {
              "key": {
                "description": "Key to store the value for",
                "pattern": "^[A-Za-z0-9_.]*$",
                "type": "string"
              },
              "value": {
                "description": "Value to store",
                "type": [
                  "null",
                  "string",
                  "number",
                  "integer",
                  "boolean",
                  "array",
                  "object"
                ]
              }
            },
            "description": "This command stores a value under a given key"
          }
        },
        "description": "This interface defines a simple key-value-store interface"
      },
      "ocpp": {
        "cmds": {
          "change_availability": {
            "arguments": {
              "request": {
                "$ref": "/ocpp#/ChangeAvailabilityRequest",
                "description": "The ChangeAvailabilityRequest as specified in OCPP2.0.1. For OCPP 1.6:",
                "type": "object"
              }
            },
            "description": "Allows to send a ChangeAvailabilityRequest internally (as can be done by the CSMS).",
            "result": {
              "$ref": "/ocpp#/ChangeAvailabilityResponse",
              "description": "Response to ChangeAvailabilityRequest as specified in OCPP 2.0.1",
              "type": "object"
            }
          },
          "get_variables": {
            "arguments": {
              "requests": {
                "description": "List of GetVariableRequest",
                "items": {
                  "$ref": "/ocpp#/GetVariableRequest",
                  "minimum": 0,
                  "type": "object"
                },
                "type": "array"
              }
            },
            "description": "Command to get a variable from OCPP. With OCPP1.6: Retrieves a configuration key. With OCPP2.0.1: Retrieves a variable with value from the device model storage",
            "result": {
              "description": "List of GetVariableResult containing the result for every requested value. Preserves the order of the input requests.",
              "items": {
                "$ref": "/ocpp#/GetVariableResult",
                "type": "object"
              },
              "type": "array"
            }
          },
          "monitor_variables": {
            "arguments": {
              "component_variables": {
                "description": "List of ComponentVariable(s) to monitor",
                "items": {
                  "$ref": "/ocpp#/ComponentVariable",
                  "type": "object"
                },
                "type": "array"
              }
            },
            "description": "Command to start monitoring the given ComponentVariable(s). Any of the provided configuration keys will be published on change by the CSMS. Consecutive calls of this operation will not override but extend the existing monitors. With OCPP1.6: This command can be used to monitor configuration keys With OCPP2.0.1: This command can be used to monitor any kind of variable in the device model storage"
          },
          "restart": {
            "description": "Connects the websocket and enables OCPP communication after a previous stop call.",
            "result": {
              "description": "Returns true if the service could be restarted successfully, else false",
              "type": "boolean"
            }
          },
          "security_event": {
            "arguments": {
              "info": {
                "description": "Additional information about the occurred security event",
                "type": "string"
              },
              "type": {
                "description": "type of the security event",
                "type": "string"
              }
            },
            "description": "Triggers a SecurityEventNotification.req at the CSMS. This event is queued with a guaranteed delivery to the CSMS."
          },
          "set_variables": {
            "arguments": {
              "requests": {
                "description": "List of SetVariableRequests",
                "items": {
                  "$ref": "/ocpp#/SetVariableRequest",
                  "minimum": 0,
                  "type": "object"
                },
                "type": "array"
              }
            },
            "description": "Command to set a variable at OCPP. With OCPP1.6: This command can be used to set custom configuration keys (others will be rejected) With OCPP2.0.1: This command can be used to set variables in the device model storage",
            "result": {
              "description": "List of SetVariableResult containing the result for every requested set operation",
              "items": {
                "$ref": "/ocpp#/SetVariableResult",
                "type": "object"
              },
              "type": "array"
            }
          },
          "stop": {
            "description": "Disconnects the websocket connection and stops the OCPP communication. No OCPP messages will be stored and sent after a restart.",
            "result": {
              "description": "Returns true if the service could be stopped successfully, else false",
              "type": "boolean"
            }
          }
        },
        "description": "This interface allows to control an OCPP service and set and get data from the OCPP service. It is designed to be used for both OCPP1.6 and OCPP2.0.1 module implementations. Therefore, the vars, commands and types are based more on the definitions of OCPP2.0.1, as this offers more flexibility and it is easier to transfer to the capabilities of OCPP1.6 than vice versa.",
        "vars": {
          "charging_schedules": {
            "description": "Object that contains OCPP charging schedules of all connectors. The object contains one composite charging schedule for each connector id starting from connector 0. Connector 0 contains a schedule for the whole charging station.",
            "type": "object"
          },
          "event_data": {
            "$ref": "/ocpp#/EventData",
            "description": "Published for a component variable combination when a variable with a monitor has been changed For OCPP1.6: The object may only contain the required properties of the EventData type because in OCPP1.6\n  there is not more information available or required.\nFor OCPP2.0.1: The object may contain all available properties",
            "type": "object"
          },
          "is_connected": {
            "description": "Indicates if chargepoint is connected to CSMS",
            "type": "boolean"
          },
          "ocpp_transaction_event": {
            "$ref": "/ocpp#/OcppTransactionEvent",
            "description": "Emits events related to OCPP transactions",
            "type": "object"
          },
          "security_event": {
            "$ref": "/ocpp#/SecurityEvent",
            "description": "Published when an internal security event occurred",
            "type": "object"
          }
        }
      },
      "ocpp_1_6_charge_point": {
        "cmds": {
          "get_configuration_key": {
            "arguments": {
              "keys": {
                "description": "List of keys for which the values are requested. If empty, all keys and values are returned",
                "items": {
                  "description": "A key",
                  "type": "string"
                },
                "type": "array"
              }
            },
            "description": "Gets the response to the requested configuration key containing a list of the values of the requested keys  and a list of the keys that are unknown",
            "result": {
              "$ref": "/ocpp#/GetConfigurationResponse",
              "description": "Response to the requested operation",
              "type": "object"
            }
          },
          "monitor_configuration_keys": {
            "arguments": {
              "keys": {
                "description": "Keys that should be monitored",
                "items": {
                  "description": "Key that should be montired",
                  "maximum": 50,
                  "type": "string"
                },
                "type": "array"
              }
            },
            "description": "Monitors the given configuration key. In case this configuration keys is changed by the CSMS the configuration key the changed configuration key will be published. Consecutive calls of this operation will not override but extend the existing monitors"
          },
          "restart": {
            "description": "Connects the websocket and enables OCPP communication after a previous stop call.",
            "result": {
              "description": "Returns true if the service could be restarted successfully, else false",
              "type": "boolean"
            }
          },
          "security_event": {
            "arguments": {
              "info": {
                "description": "Additional information about the occurred security event",
                "type": "string"
              },
              "type": {
                "description": "type of the security event",
                "type": "string"
              }
            },
            "description": "Triggers a SecurityEventNotification.req at the CSMS. This event is queued with a guaranteed delivery to the CSMS."
          },
          "set_custom_configuration_key": {
            "arguments": {
              "key": {
                "description": "Key that should be set",
                "maximum": 50,
                "type": "string"
              },
              "value": {
                "description": "Value that should be set for the given key",
                "maximum": 500,
                "type": "string"
              }
            },
            "description": "Command to set a custom configuration key. Its not possible to set standardized configuration keys externally",
            "result": {
              "$ref": "/ocpp#/ConfigurationStatus",
              "description": "Indicates the result of the requested operation",
              "type": "string"
            }
          },
          "stop": {
            "description": "Disconnects the websocket connection and stops the OCPP communication. No OCPP messages will be stored and sent after a restart.",
            "result": {
              "description": "Returns true if the service could be stopped successfully, else false",
              "type": "boolean"
            }
          }
        },
        "description": "This interface defines a OCPP 1.6 charge point",
        "vars": {
          "charging_schedules": {
            "description": "Object that contains OCPP charging schedules of all connectors. The object contains one composite charging schedule for each connector id starting from connector 0. Connector 0 contains a schedule for the whole charging station.",
            "type": "object"
          },
          "configuration_key": {
            "$ref": "/ocpp#/KeyValue",
            "description": "Published when a configuration key has been changed by the CSMS and a monitor has been registered using the command monitor_configuration_keys",
            "type": "object"
          },
          "is_connected": {
            "description": "Indicates if chargepoint is connected to CSMS",
            "type": "boolean"
          },
          "security_event": {
            "$ref": "/ocpp#/SecurityEvent",
            "description": "Published when an internal security event occured",
            "type": "object"
          }
        }
      },
      "ocpp_data_transfer": {
        "cmds": {
          "data_transfer": {
            "arguments": {
              "request": {
                "$ref": "/ocpp#/DataTransferRequest",
                "description": "Request object containing data transfer request",
                "type": "object"
              }
            },
            "description": "Performs a OCPP data transfer request and returns the response",
            "result": {
              "$ref": "/ocpp#/DataTransferResponse",
              "description": "Result object containing data transfer response",
              "type": "object"
            }
          }
        },
        "description": "This interface defines a OCPP data transfer"
      },
      "power": {
        "description": "This interface defines the interface of a power supply",
        "vars": {
          "max_current": {
            "description": "This is the maximum current of the power supply",
            "maximum": 60,
            "minimum": 1,
            "type": "number"
          }
        }
      },
      "power_supply_DC": {
        "cmds": {
          "getCapabilities": {
            "description": "Get capabilities of power supply",
            "result": {
              "$ref": "/power_supply_DC#/Capabilities",
              "description": "Capabilities",
              "type": "object"
            }
          },
          "setExportVoltageCurrent": {
            "arguments": {
              "current": {
                "description": "Output current limit in Ampere",
                "type": "number"
              },
              "voltage": {
                "description": "Output voltage in Volt",
                "type": "number"
              }
            },
            "description": "Set output target voltage limit. Must be within reported limits."
          },
          "setImportVoltageCurrent": {
            "arguments": {
              "current": {
                "description": "Input current limit in Ampere",
                "type": "number"
              },
              "voltage": {
                "description": "Current will be drawn if input is above this voltage (in Volt)",
                "type": "number"
              }
            },
            "description": "Set minimal import voltage and current limit.  Must be within reported limits."
          },
          "setMode": {
            "arguments": {
              "value": {
                "$ref": "/power_supply_DC#/Mode",
                "description": "Operation mode of power supply",
                "type": "string"
              }
            },
            "description": "Set operation mode of the bidirectional DC power supply"
          }
        },
        "description": "Interface for power supplies used for DC charging",
        "vars": {
          "fault_code": {
            "$ref": "/power_supply_DC#/FaultCode",
            "description": "Fault code. Published when fault happens.",
            "type": "string"
          },
          "mode": {
            "$ref": "/power_supply_DC#/Mode",
            "description": "Current mode. Published on change.",
            "type": "string"
          },
          "voltage_current": {
            "$ref": "/power_supply_DC#/VoltageCurrent",
            "description": "Voltage/Current at the input/output",
            "type": "object"
          }
        }
      },
      "powermeter": {
        "cmds": {
          "start_transaction": {
            "arguments": {
              "value": {
                "$ref": "/powermeter#/TransactionReq",
                "description": "All information that should be included in the signed OCMF packet",
                "type": "object"
              }
            },
            "description": "Starts a transaction on the power meter (for signed metering according to German Eichrecht)",
            "result": {
              "$ref": "/powermeter#/TransactionStartResponse",
              "description": "True on success, False if transaction could not be started in the power meter",
              "type": "object"
            }
          },
          "stop_transaction": {
            "arguments": {
              "transaction_id": {
                "description": "Transaction id",
                "type": "string"
              }
            },
            "description": "Stop the transaction on the power meter and return the signed metering information",
            "result": {
              "$ref": "/powermeter#/TransactionStopResponse",
              "description": "Response to transaction stop request including OCMF string.",
              "type": "object"
            }
          }
        },
        "description": "This interface defines a generic powermeter for 5 wire TN networks.",
        "vars": {
          "powermeter": {
            "$ref": "/powermeter#/Powermeter",
            "description": "Measured dataset",
            "type": "object"
          }
        }
      },
      "reservation": {
        "cmds": {
          "cancel_reservation": {
            "arguments": {
              "reservation_id": {
                "description": "Id of the reservation",
                "type": "integer"
              }
            },
            "description": "Cancels the reservation with the given reservation_id",
            "result": {
              "description": "Returns true if reservation was cancelled. Returns false if there was no reservation to cancel.",
              "type": "boolean"
            }
          },
          "reserve_now": {
            "arguments": {
              "connector_id": {
                "description": "The id of the connector to be reserved. A value of 0 means that the reservation is not for a specific connector",
                "type": "integer"
              },
              "reservation": {
                "$ref": "/reservation#/Reservation",
                "description": "The information about the Reservation to be placed",
                "type": "object"
              }
            },
            "description": "Reserves this evse.",
            "result": {
              "$ref": "/reservation#/ReservationResult",
              "description": "Returns Accepted if reservation was succesfull or specifies error code.",
              "type": "string"
            }
          }
        },
        "description": "Interface for reservations",
        "vars": {}
      },
      "serial_communication_hub": {
        "cmds": {
          "modbus_read_holding_registers": {
            "arguments": {
              "first_register_address": {
                "description": "Start address for read operation (16 bit address)",
                "maximum": 65535,
                "minimum": 0,
                "type": "integer"
              },
              "num_registers_to_read": {
                "description": "Number of registers to read (16 bit each)",
                "minimum": 1,
                "type": "integer"
              },
              "target_device_id": {
                "description": "ID (1 byte) of the device to send the commands to",
                "maximum": 255,
                "minimum": 0,
                "type": "integer"
              }
            },
            "description": "Send a Modbus RTU 'read holding registers' command via serial interface to the target hardware. (return value: response)",
            "result": {
              "$ref": "/serial_comm_hub_requests#/Result",
              "description": "Result of the transfer",
              "type": "object"
            }
          },
          "modbus_read_input_registers": {
            "arguments": {
              "first_register_address": {
                "description": "Start address for read operation (16 bit address)",
                "maximum": 65535,
                "minimum": 0,
                "type": "integer"
              },
              "num_registers_to_read": {
                "description": "Number of registers to read (16 bit each)",
                "minimum": 1,
                "type": "integer"
              },
              "target_device_id": {
                "description": "ID (1 byte) of the device to send the commands to",
                "maximum": 255,
                "minimum": 0,
                "type": "integer"
              }
            },
            "description": "Send a Modbus RTU 'read input registers' command via serial interface to the target hardware. (return value: response)",
            "result": {
              "$ref": "/serial_comm_hub_requests#/Result",
              "description": "Result of the transfer",
              "type": "object"
            }
          },
          "modbus_write_multiple_registers": {
            "arguments": {
              "data_raw": {
                "$ref": "/serial_comm_hub_requests#/VectorUint16",
                "description": "Data content to be written to the above selected registers (in 16 bit words)",
                "type": "object"
              },
              "first_register_address": {
                "description": "Start address for write operation (16 bit address)",
                "maximum": 65535,
                "minimum": 0,
                "type": "integer"
              },
              "target_device_id": {
                "description": "ID (1 byte) of the device to send the commands to",
                "maximum": 255,
                "minimum": 0,
                "type": "integer"
              }
            },
            "description": "Send a Modbus RTU 'write multiple registers' command via serial interface to the target hardware. (return value: response)",
            "result": {
              "$ref": "/serial_comm_hub_requests#/StatusCodeEnum",
              "description": "Status code of the transfer",
              "type": "string"
            }
          },
          "modbus_write_single_register": {
            "arguments": {
              "data": {
                "description": "Data content to be written to the above selected register",
                "maximum": 65535,
                "minimum": 0,
                "type": "integer"
              },
              "register_address": {
                "description": "Address of the register to write to (16 bit address)",
                "maximum": 65535,
                "minimum": 0,
                "type": "integer"
              },
              "target_device_id": {
                "description": "ID (1 byte) of the device to send the commands to",
                "maximum": 255,
                "minimum": 0,
                "type": "integer"
              }
            },
            "description": "Send a Modbus RTU 'write single register' command via serial interface to the target hardware. (return value: response)",
            "result": {
              "$ref": "/serial_comm_hub_requests#/StatusCodeEnum",
              "description": "Status code of the transfer",
              "type": "string"
            }
          },
          "nonstd_read": {
            "arguments": {
              "first_register_address": {
                "description": "Start address for write operation (16 bit address)",
                "maximum": 65535,
                "minimum": 0,
                "type": "integer"
              },
              "num_registers_to_read": {
                "description": "Number of registers to read (16 bit each)",
                "maximum": 65535,
                "minimum": 0,
                "type": "integer"
              },
              "target_device_id": {
                "description": "ID (1 byte) of the device to send the commands to",
                "maximum": 255,
                "minimum": 0,
                "type": "integer"
              }
            },
            "description": "Non standard mode to read registers in read coils mode, but getting a malformed reply. Used e.g. by GYDCG-UBC1 isolation monitor.",
            "result": {
              "$ref": "/serial_comm_hub_requests#/Result",
              "description": "Result of the transfer",
              "type": "object"
            }
          },
          "nonstd_write": {
            "arguments": {
              "first_register_address": {
                "description": "Start address for read operation (16 bit address)",
                "maximum": 65535,
                "minimum": 0,
                "type": "integer"
              },
              "num_registers_to_read": {
                "description": "Number of registers to read (16 bit each)",
                "minimum": 1,
                "type": "integer"
              },
              "target_device_id": {
                "description": "ID (1 byte) of the device to send the commands to",
                "maximum": 255,
                "minimum": 0,
                "type": "integer"
              }
            },
            "description": "Non standard mode to write registers in read discrete input mode without waiting for reply. Used e.g. by GYDCG-UBC1 isolation monitor."
          }
        },
        "description": "This interface provides multiplexed access to one serial port (e.g. RS485) for multiple clients."
      },
      "session_cost": {
        "description": "This interface publishes the running or finished session costs. This interface provides cost of one session. If we have more than one EVESEID, we need to  instantiate this interface for each EVSE.",
        "vars": {
          "session_cost": {
            "$ref": "/session_cost#/SessionCost",
            "description": "Session cost object containing the total cost of the session and a list of chunks",
            "type": "object"
          }
        }
      },
      "slac": {
        "cmds": {
          "dlink_error": {
            "description": "Terminate the data link and restart the matching process.",
            "result": {
              "description": "True on success.",
              "type": "boolean"
            }
          },
          "dlink_pause": {
            "description": "Request power saving mode, while staying MATCHED.",
            "result": {
              "description": "True on success.",
              "type": "boolean"
            }
          },
          "dlink_terminate": {
            "description": "Terminate the data link and become UNMATCHED.",
            "result": {
              "description": "True on success.",
              "type": "boolean"
            }
          },
          "enter_bcd": {
            "description": "Signal pilot state change to B/C/D from A/E/F.",
            "result": {
              "description": "True on success, returns False if transition was unexpected and cannot be handled by SLAC state machine.",
              "type": "boolean"
            }
          },
          "leave_bcd": {
            "description": "Signal pilot state change to A/E/F from B/C/D.",
            "result": {
              "description": "True on success, returns False if transition was unexpected and cannot be handled by SLAC state machine.",
              "type": "boolean"
            }
          },
          "reset": {
            "arguments": {
              "enable": {
                "description": "true: start SLAC after reset, false: stop SLAC",
                "type": "boolean"
              }
            },
            "description": "Reset SLAC"
          }
        },
        "description": "ISO15118-3 SLAC interface for EVSE side",
        "vars": {
          "dlink_ready": {
            "description": "Inform higher layers about a change in data link status. Emits true if link was set up and false when the link is shut down.",
            "type": "boolean"
          },
          "ev_mac_address": {
            "description": "Inform higher layers about the MAC address of the vehicle (upper case)",
            "pattern": "^[A-F0-9]{2}(:[A-F0-9]{2}){5}$",
            "type": "string"
          },
          "request_error_routine": {
            "description": "Inform the higher layer to execute the error routine for a SLAC connection retry",
            "type": "null"
          },
          "state": {
            "description": "Provides the state enum.",
            "enum": [
              "UNMATCHED",
              "MATCHING",
              "MATCHED"
            ],
            "type": "string"
          }
        }
      },
      "solar_forecast": {
        "description": "This interface defines the interface for an solar energy production forecast",
        "vars": {
          "forecast": {
            "description": "Forecast JSON Object containing a timestamp and the energy forecast in watthours.",
            "type": "object"
          }
        }
      },
      "sunspec_ac_meter": {
        "cmds": {
          "get_sunspec_ac_meter_value": {
            "arguments": {
              "auth_token": {
                "description": "Auth token",
                "maxLength": 20,
                "minLength": 1,
                "type": "string"
              }
            },
            "description": "Returns a sunspec ac meter model",
            "result": {
              "$ref": "/sunspec_ac_meter#/Result",
              "description": "Sunspec ac meter model",
              "type": "object"
            }
          }
        },
        "description": "Get sunspec ac meter measurement"
      },
      "sunspec_reader": {
        "description": "This interface defines a generic Sunspec reader, which can be used to fetch values from Sunspec devices when an implementation is given.",
        "vars": {
          "measurement": {
            "additionalProperties": true,
            "description": "Measured dataset",
            "properties": {
              "timestamp": {
                "description": "Timestamp of measurement",
                "type": "number"
              },
              "value": {
                "description": "Measurement value",
                "type": "number"
              }
            },
            "required": [
              "timestamp"
            ],
            "type": "object"
          }
        }
      },
      "sunspec_scanner": {
        "cmds": {
          "scan_device": {
            "arguments": {
              "ip_address": {
                "description": "local IP-address of the Sunspec device",
                "pattern": "^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$",
                "type": "string"
              }
            },
            "description": "Scans complete device",
            "result": {
              "description": "Returns a json overview of the scan",
              "type": "object"
            }
          },
          "scan_network": {
            "description": "Scans local network",
            "result": {
              "description": "Returns a json overview of the scan",
              "type": "object"
            }
          },
          "scan_port": {
            "arguments": {
              "ip_address": {
                "description": "local IP-address of the Sunspec device",
                "pattern": "^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$",
                "type": "string"
              },
              "port": {
                "description": "Modbus port",
                "minimum": 0,
                "type": "integer"
              }
            },
            "description": "Scans all units at a device's port",
            "result": {
              "description": "Returns a json overview of the scan",
              "type": "object"
            }
          },
          "scan_unit": {
            "arguments": {
              "ip_address": {
                "description": "local IP-address of the Sunspec device",
                "pattern": "^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$",
                "type": "string"
              },
              "port": {
                "description": "Modbus port",
                "minimum": 0,
                "type": "integer"
              },
              "unit": {
                "description": "Modbus unit id",
                "minimum": 0,
                "type": "integer"
              }
            },
            "description": "Scans specific unit at a device's port",
            "result": {
              "description": "Returns a json overview of the scan",
              "type": "object"
            }
          }
        },
        "description": "This class defines the global Sunspec scanner"
      },
      "system": {
        "cmds": {
          "allow_firmware_installation": {
            "description": "Call to allow a firmware installation to proceed"
          },
          "get_boot_reason": {
            "description": "Call to get the boot reason of the system",
            "result": {
              "$ref": "/system#/BootReason",
              "description": "Returns the boot reason of the system",
              "type": "string"
            }
          },
          "is_reset_allowed": {
            "arguments": {
              "type": {
                "$ref": "/system#/ResetType",
                "description": "Type of the reset (Soft or Hard)",
                "type": "string"
              }
            },
            "description": "Call to determine if a reset of the system is allowed",
            "result": {
              "description": "Indicates if the system can be reset",
              "type": "boolean"
            }
          },
          "reset": {
            "arguments": {
              "scheduled": {
                "description": "Indicates if this reset command was scheduled or immediately executed. A scheduled reset means that the system was waiting for all transactions to finish before this command was executed. This value is only informational.",
                "type": "boolean"
              },
              "type": {
                "$ref": "/system#/ResetType",
                "description": "Type of the reset (Soft or Hard)",
                "type": "string"
              }
            },
            "description": "Call to reset the system immediately"
          },
          "set_system_time": {
            "arguments": {
              "timestamp": {
                "description": "The new system time in RFC3339 format",
                "format": "date-time",
                "type": "string"
              }
            },
            "description": "Call to set the system time of EVerest",
            "result": {
              "description": "Returns true if the system time could be set successfully, else false",
              "type": "boolean"
            }
          },
          "update_firmware": {
            "arguments": {
              "firmware_update_request": {
                "$ref": "/system#/FirmwareUpdateRequest",
                "description": "Meta data containing information about the firmware request",
                "type": "object"
              }
            },
            "description": "Call to start a firmware update",
            "result": {
              "$ref": "/system#/UpdateFirmwareResponse",
              "description": "Returns the result of the attempt to update the firmware",
              "type": "string"
            }
          },
          "upload_logs": {
            "arguments": {
              "upload_logs_request": {
                "$ref": "/system#/UploadLogsRequest",
                "description": "Meta data containing information about the log request request",
                "type": "object"
              }
            },
            "description": "Call to start a log upload",
            "result": {
              "$ref": "/system#/UploadLogsResponse",
              "description": "Returns the result of the attempt to upload the logs",
              "type": "object"
            }
          }
        },
        "description": "Interface for system wide operations of EVerest",
        "vars": {
          "firmware_update_status": {
            "$ref": "/system#/FirmwareUpdateStatus",
            "description": "Describes the current status of a firmware update of the system",
            "type": "object"
          },
          "log_status": {
            "$ref": "/system#/LogStatus",
            "description": "Describes the current status of log upload of the system",
            "type": "object"
          }
        }
      },
      "test_control": {
        "cmds": {
          "start_charging": {
            "arguments": {
              "mode": {
                "description": "Sets charging mode (e.g. raw, iso15118)",
                "maxLength": 20,
                "minLength": 1,
                "type": "string"
              }
            },
            "description": "Enables the CarSimulator to begin charging",
            "result": {
              "description": "Charging state of the CarSimulator",
              "type": "string"
            }
          }
        },
        "description": "This interface defines the everest-testing control functions on everest-core",
        "vars": {
          "state": {
            "description": "State of the test control instance",
            "type": "string"
          }
        }
      },
      "tibber_price_forecast": {
        "description": "This interface defines the interface for an energy price forecast",
        "vars": {
          "forecast": {
            "description": "Forecast JSON Object containing a timestamp and the price forecast",
            "type": "object"
          }
        }
      },
      "uk_random_delay": {
        "cmds": {
          "cancel": {
            "description": "Cancels a running random delay. The effect is the same as if the time expired just now."
          },
          "disable": {
            "description": "Call to disable the random delay feature"
          },
          "enable": {
            "description": "Call to enable the random delay feature"
          },
          "set_duration_s": {
            "arguments": {
              "value": {
                "description": "Maximum duration in seconds",
                "type": "integer"
              }
            },
            "description": "Set the maximum duration of the random delay. Default is 600 seconds."
          }
        },
        "description": "This interface provides functions for a random delay feature as required by the UK smart charging regulations The logic whether to use a random delay or not is not included in EvseManager, a different module can use this interface to enable/disable the feature during runtime and cancel a running random delay. This always applies to all connectors of this EVSE. By default, on start up, random delays are disabled.",
        "vars": {
          "countdown": {
            "$ref": "/uk_random_delay#/CountDown",
            "description": "Countdown of the currently running random delay",
            "type": "object"
          }
        }
      },
      "yeti_simulation_control": {
        "cmds": {
          "enable": {
            "arguments": {
              "value": {
                "description": "true to enable, false to disable",
                "type": "boolean"
              }
            },
            "description": "Enable/disable the simulation"
          },
          "setSimulationData": {
            "arguments": {
              "value": {
                "$ref": "/yeti#/SimulationData",
                "description": "simulation data",
                "type": "object"
              }
            },
            "description": "Sends a new simulation data object"
          }
        },
        "description": "This defines a HIL simulation interface",
        "vars": {
          "enabled": {
            "description": "Indicates whether simulation interface is currently active or not",
            "type": "boolean"
          },
          "simulation_feedback": {
            "description": "Feedback from simulation (everything that a car can measure on the CP signal plus the indication whether relais are on or off)",
            "type": "object"
          }
        }
      }
    };
    const SampleConfigList = {
      "config-sil-dc": {
        "active_modules": {
          "api": {
            "module": "API",
            "connections": {
              "evse_manager": [
                {
                  "module_id": "evse_manager",
                  "implementation_id": "evse"
                }
              ]
            },
            "config_module": {
              "charger_information_file": "",
              "hw_caps_max_current_export_decimal_places": 2,
              "hw_caps_max_current_export_round_to": 0,
              "hw_caps_max_current_import_decimal_places": 2,
              "hw_caps_max_current_import_round_to": 0,
              "hw_caps_max_plug_temperature_C_decimal_places": 2,
              "hw_caps_max_plug_temperature_C_round_to": 0,
              "hw_caps_min_current_export_decimal_places": 2,
              "hw_caps_min_current_export_round_to": 0,
              "hw_caps_min_current_import_decimal_places": 2,
              "hw_caps_min_current_import_round_to": 0,
              "limits_max_current_decimal_places": 2,
              "limits_max_current_round_to": 0,
              "powermeter_VAR_decimal_places": 2,
              "powermeter_VAR_round_to": 0,
              "powermeter_current_decimal_places": 2,
              "powermeter_current_round_to": 0,
              "powermeter_energy_export_decimal_places": 2,
              "powermeter_energy_export_round_to": 0,
              "powermeter_energy_import_decimal_places": 2,
              "powermeter_energy_import_round_to": 0,
              "powermeter_frequency_decimal_places": 2,
              "powermeter_frequency_round_to": 0,
              "powermeter_power_decimal_places": 2,
              "powermeter_power_round_to": 0,
              "powermeter_voltage_decimal_places": 2,
              "powermeter_voltage_round_to": 0,
              "telemetry_evse_temperature_C_decimal_places": 2,
              "telemetry_evse_temperature_C_round_to": 0,
              "telemetry_fan_rpm_decimal_places": 2,
              "telemetry_fan_rpm_round_to": 0,
              "telemetry_plug_temperature_C_decimal_places": 2,
              "telemetry_plug_temperature_C_round_to": 0,
              "telemetry_supply_voltage_12V_decimal_places": 2,
              "telemetry_supply_voltage_12V_round_to": 0,
              "telemetry_supply_voltage_minus_12V_decimal_places": 2,
              "telemetry_supply_voltage_minus_12V_round_to": 0
            }
          },
          "auth": {
            "module": "Auth",
            "connections": {
              "evse_manager": [
                {
                  "module_id": "evse_manager",
                  "implementation_id": "evse"
                }
              ],
              "token_provider": [
                {
                  "module_id": "token_provider",
                  "implementation_id": "main"
                }
              ],
              "token_validator": [
                {
                  "module_id": "token_validator",
                  "implementation_id": "main"
                }
              ]
            },
            "config_module": {
              "connection_timeout": 10,
              "ignore_connector_faults": false,
              "master_pass_group_id": "",
              "prioritize_authorization_over_stopping_transaction": true,
              "selection_algorithm": "FindFirst"
            }
          },
          "car_simulator": {
            "module": "JsCarSimulator",
            "connections": {
              "ev": [
                {
                  "module_id": "iso15118_car",
                  "implementation_id": "ev"
                }
              ],
              "simulation_control": [
                {
                  "module_id": "yeti_driver",
                  "implementation_id": "yeti_simulation_control"
                }
              ],
              "slac": [
                {
                  "module_id": "slac",
                  "implementation_id": "ev"
                }
              ]
            },
            "config_module": {
              "auto_enable": true,
              "auto_exec": false,
              "auto_exec_commands": "sleep 1;iec_wait_pwr_ready;sleep 1;draw_power_regulated 16,3;sleep 30;unplug",
              "connector_id": 1,
              "dc_discharge_max_current_limit": 300,
              "dc_discharge_max_power_limit": 15e4,
              "dc_discharge_target_current": 5,
              "dc_discharge_v2g_minimal_soc": 20,
              "dc_energy_capacity": 6e4,
              "dc_max_current_limit": 300,
              "dc_max_power_limit": 15e4,
              "dc_max_voltage_limit": 900,
              "dc_target_current": 20,
              "dc_target_voltage": 400,
              "support_sae_j2847": false
            }
          },
          "energy_manager": {
            "module": "EnergyManager",
            "connections": {
              "energy_trunk": [
                {
                  "module_id": "grid_connection_point",
                  "implementation_id": "energy_grid"
                }
              ]
            },
            "config_module": {
              "debug": false,
              "nominal_ac_voltage": 230,
              "schedule_interval_duration": 60,
              "schedule_total_duration": 1,
              "slice_ampere": 0.5,
              "slice_watt": 500,
              "update_interval": 1
            }
          },
          "evse_manager": {
            "module": "EvseManager",
            "connections": {
              "bsp": [
                {
                  "module_id": "yeti_driver",
                  "implementation_id": "board_support"
                }
              ],
              "hlc": [
                {
                  "module_id": "iso15118_charger",
                  "implementation_id": "charger"
                }
              ],
              "imd": [
                {
                  "module_id": "imd",
                  "implementation_id": "main"
                }
              ],
              "powermeter_car_side": [
                {
                  "module_id": "powersupply_dc",
                  "implementation_id": "powermeter"
                }
              ],
              "powersupply_DC": [
                {
                  "module_id": "powersupply_dc",
                  "implementation_id": "main"
                }
              ],
              "slac": [
                {
                  "module_id": "slac",
                  "implementation_id": "evse"
                }
              ]
            },
            "config_module": {
              "ac_enforce_hlc": false,
              "ac_hlc_enabled": false,
              "ac_hlc_use_5percent": false,
              "ac_nominal_voltage": 230,
              "ac_with_soc": false,
              "autocharge_use_slac_instead_of_hlc": false,
              "charge_mode": "DC",
              "connector_id": 1,
              "country_code": "DE",
              "dbg_hlc_auth_after_tstep": false,
              "dc_isolation_voltage_V": 500,
              "disable_authentication": false,
              "ev_receipt_required": false,
              "evse_id": "DE*PNX*E12345*1",
              "evse_id_din": "49A80737A45678",
              "external_ready_to_start_charging": false,
              "hack_allow_bpt_with_iso2": true,
              "hack_fix_hlc_integer_current_requests": false,
              "hack_pause_imd_during_precharge": false,
              "hack_present_current_offset": 0,
              "hack_skoda_enyaq": false,
              "hack_sleep_in_cable_check": 0,
              "hack_sleep_in_cable_check_volkswagen": 0,
              "has_ventilation": true,
              "logfile_suffix": "session_uuid",
              "max_current_export_A": 32,
              "max_current_import_A": 32,
              "payment_enable_contract": true,
              "payment_enable_eim": true,
              "request_zero_power_in_idle": false,
              "sae_j2847_2_bpt_enabled": false,
              "sae_j2847_2_bpt_mode": "V2G",
              "session_logging": true,
              "session_logging_path": "/tmp/everest-logs",
              "session_logging_xml": false,
              "soft_over_current_measurement_noise_A": 0.5,
              "soft_over_current_tolerance_percent": 10,
              "switch_to_minimum_voltage_after_cable_check": false,
              "three_phases": true,
              "uk_smartcharging_random_delay_at_any_change": true,
              "uk_smartcharging_random_delay_enable": false,
              "uk_smartcharging_random_delay_max_duration": 600
            }
          },
          "evse_security": {
            "module": "EvseSecurity",
            "connections": {},
            "config_module": {
              "csms_ca_bundle": "ca/v2g/V2G_ROOT_CA.pem",
              "csms_leaf_cert_directory": "client/csms",
              "csms_leaf_key_directory": "client/csms",
              "mf_ca_bundle": "ca/mf/MF_ROOT_CA.pem",
              "mo_ca_bundle": "ca/mo/MO_ROOT_CA.pem",
              "private_key_password": "123456",
              "secc_leaf_cert_directory": "client/cso",
              "secc_leaf_key_directory": "client/cso",
              "v2g_ca_bundle": "ca/v2g/V2G_ROOT_CA.pem"
            }
          },
          "grid_connection_point": {
            "module": "EnergyNode",
            "connections": {
              "energy_consumer": [
                {
                  "module_id": "evse_manager",
                  "implementation_id": "energy_grid"
                }
              ],
              "powermeter": [
                {
                  "module_id": "yeti_driver",
                  "implementation_id": "powermeter"
                }
              ]
            },
            "config_module": {
              "fuse_limit_A": 40,
              "phase_count": 3
            }
          },
          "imd": {
            "module": "IMDSimulator",
            "connections": {},
            "config_implementation": {
              "main": {
                "interval": 1e3,
                "resistance_F_Ohm": 9e5
              }
            }
          },
          "iso15118_car": {
            "module": "PyEvJosev",
            "connections": {},
            "config_module": {
              "device": "auto",
              "enforce_tls": false,
              "is_cert_install_needed": false,
              "supported_DIN70121": true,
              "supported_ISO15118_2": true,
              "supported_ISO15118_20_AC": false,
              "supported_ISO15118_20_DC": false,
              "tls_active": false
            }
          },
          "iso15118_charger": {
            "module": "EvseV2G",
            "connections": {
              "security": [
                {
                  "module_id": "evse_security",
                  "implementation_id": "main"
                }
              ]
            },
            "config_module": {
              "auth_timeout_eim": 300,
              "auth_timeout_pnc": 55,
              "device": "auto",
              "supported_DIN70121": false,
              "supported_ISO15118_2": true,
              "terminate_connection_on_failed_response": false,
              "tls_key_logging": false,
              "tls_key_logging_path": "/tmp",
              "tls_security": "allow",
              "tls_timeout": 15e3,
              "verify_contract_cert_chain": false
            }
          },
          "powersupply_dc": {
            "module": "JsDCSupplySimulator",
            "connections": {},
            "config_implementation": {
              "main": {
                "bidirectional": true,
                "max_current": 200,
                "max_power": 15e4,
                "max_voltage": 900,
                "min_current": 1,
                "min_voltage": 200
              }
            }
          },
          "slac": {
            "module": "JsSlacSimulator",
            "connections": {},
            "config_implementation": {
              "ev": {
                "ev_id": "PIONIX_SAYS_HELLO"
              },
              "evse": {
                "evse_id": "PIONIX_SAYS_HELLO",
                "nid": "pionix!",
                "number_of_sounds": 10
              }
            }
          },
          "token_provider": {
            "module": "DummyTokenProvider",
            "connections": {
              "evse": [
                {
                  "module_id": "evse_manager",
                  "implementation_id": "evse"
                }
              ]
            },
            "config_implementation": {
              "main": {
                "connector_id": 0,
                "timeout": 10,
                "token": "TOKEN1",
                "type": "RFID"
              }
            }
          },
          "token_validator": {
            "module": "DummyTokenValidator",
            "connections": {},
            "config_implementation": {
              "main": {
                "sleep": 0.25,
                "validation_reason": "Token seems valid",
                "validation_result": "Accepted"
              }
            }
          },
          "yeti_driver": {
            "module": "JsYetiSimulator",
            "connections": {},
            "config_module": {
              "connector_id": 1
            }
          }
        },
        "x-module-layout": {
          "api": {
            "position": {
              "x": 37,
              "y": 41
            },
            "terminals": {
              "top": [],
              "right": [
                {
                  "id": "main",
                  "interface": "empty",
                  "type": "provide"
                }
              ],
              "bottom": [],
              "left": [
                {
                  "id": "evse_manager",
                  "interface": "evse_manager",
                  "type": "requirement"
                },
                {
                  "id": "ocpp",
                  "interface": "ocpp",
                  "type": "requirement"
                },
                {
                  "id": "random_delay",
                  "interface": "uk_random_delay",
                  "type": "requirement"
                }
              ]
            }
          },
          "auth": {
            "position": {
              "x": 37,
              "y": 22
            },
            "terminals": {
              "top": [],
              "right": [
                {
                  "id": "main",
                  "interface": "auth",
                  "type": "provide"
                },
                {
                  "id": "token_validator",
                  "interface": "auth_token_validator",
                  "type": "requirement"
                },
                {
                  "id": "reservation",
                  "interface": "reservation",
                  "type": "provide"
                }
              ],
              "bottom": [
                {
                  "id": "token_provider",
                  "interface": "auth_token_provider",
                  "type": "requirement"
                }
              ],
              "left": [
                {
                  "id": "evse_manager",
                  "interface": "evse_manager",
                  "type": "requirement"
                }
              ]
            }
          },
          "car_simulator": {
            "position": {
              "x": 18,
              "y": 5
            },
            "terminals": {
              "top": [
                {
                  "id": "ev",
                  "interface": "ISO15118_ev",
                  "type": "requirement"
                }
              ],
              "right": [
                {
                  "id": "main",
                  "interface": "car_simulator",
                  "type": "provide"
                }
              ],
              "bottom": [],
              "left": [
                {
                  "id": "slac",
                  "interface": "slac",
                  "type": "requirement"
                },
                {
                  "id": "simulation_control",
                  "interface": "yeti_simulation_control",
                  "type": "requirement"
                }
              ]
            }
          },
          "energy_manager": {
            "position": {
              "x": 50,
              "y": 10
            },
            "terminals": {
              "top": [],
              "right": [
                {
                  "id": "main",
                  "interface": "energy_manager",
                  "type": "provide"
                }
              ],
              "bottom": [],
              "left": [
                {
                  "id": "energy_trunk",
                  "interface": "energy",
                  "type": "requirement"
                }
              ]
            }
          },
          "evse_manager": {
            "position": {
              "x": 18,
              "y": 25
            },
            "terminals": {
              "top": [
                {
                  "id": "energy_grid",
                  "interface": "energy",
                  "type": "provide"
                }
              ],
              "right": [
                {
                  "id": "evse",
                  "interface": "evse_manager",
                  "type": "provide"
                },
                {
                  "id": "random_delay",
                  "interface": "uk_random_delay",
                  "type": "provide"
                },
                {
                  "id": "token_provider",
                  "interface": "auth_token_provider",
                  "type": "provide"
                }
              ],
              "bottom": [
                {
                  "id": "hlc",
                  "interface": "ISO15118_charger",
                  "type": "requirement"
                }
              ],
              "left": [
                {
                  "id": "slac",
                  "interface": "slac",
                  "type": "requirement"
                },
                {
                  "id": "ac_rcd",
                  "interface": "ac_rcd",
                  "type": "requirement"
                },
                {
                  "id": "bsp",
                  "interface": "evse_board_support",
                  "type": "requirement"
                },
                {
                  "id": "connector_lock",
                  "interface": "connector_lock",
                  "type": "requirement"
                },
                {
                  "id": "imd",
                  "interface": "isolation_monitor",
                  "type": "requirement"
                },
                {
                  "id": "powermeter_car_side",
                  "interface": "powermeter",
                  "type": "requirement"
                },
                {
                  "id": "powermeter_grid_side",
                  "interface": "powermeter",
                  "type": "requirement"
                },
                {
                  "id": "powersupply_DC",
                  "interface": "power_supply_DC",
                  "type": "requirement"
                }
              ]
            }
          },
          "evse_security": {
            "position": {
              "x": 2,
              "y": 37
            },
            "terminals": {
              "top": [],
              "right": [
                {
                  "id": "main",
                  "interface": "evse_security",
                  "type": "provide"
                }
              ],
              "bottom": [],
              "left": []
            }
          },
          "grid_connection_point": {
            "position": {
              "x": 18,
              "y": 16
            },
            "terminals": {
              "top": [],
              "right": [
                {
                  "id": "energy_grid",
                  "interface": "energy",
                  "type": "provide"
                },
                {
                  "id": "external_limits",
                  "interface": "external_energy_limits",
                  "type": "provide"
                }
              ],
              "bottom": [
                {
                  "id": "energy_consumer",
                  "interface": "energy",
                  "type": "requirement"
                }
              ],
              "left": [
                {
                  "id": "price_information",
                  "interface": "energy_price_information",
                  "type": "requirement"
                },
                {
                  "id": "powermeter",
                  "interface": "powermeter",
                  "type": "requirement"
                }
              ]
            }
          },
          "imd": {
            "position": {
              "x": -12,
              "y": 23
            },
            "terminals": {
              "top": [],
              "right": [
                {
                  "id": "main",
                  "interface": "isolation_monitor",
                  "type": "provide"
                }
              ],
              "bottom": [],
              "left": []
            }
          },
          "iso15118_car": {
            "position": {
              "x": 18,
              "y": -4
            },
            "terminals": {
              "top": [],
              "right": [],
              "bottom": [
                {
                  "id": "ev",
                  "interface": "ISO15118_ev",
                  "type": "provide"
                }
              ],
              "left": []
            }
          },
          "iso15118_charger": {
            "position": {
              "x": 18,
              "y": 37
            },
            "terminals": {
              "top": [
                {
                  "id": "charger",
                  "interface": "ISO15118_charger",
                  "type": "provide"
                }
              ],
              "right": [],
              "bottom": [],
              "left": [
                {
                  "id": "security",
                  "interface": "evse_security",
                  "type": "requirement"
                }
              ]
            }
          },
          "powersupply_dc": {
            "position": {
              "x": -12,
              "y": 30
            },
            "terminals": {
              "top": [],
              "right": [
                {
                  "id": "powermeter",
                  "interface": "powermeter",
                  "type": "provide"
                },
                {
                  "id": "main",
                  "interface": "power_supply_DC",
                  "type": "provide"
                }
              ],
              "bottom": [],
              "left": []
            }
          },
          "slac": {
            "position": {
              "x": -12,
              "y": 9
            },
            "terminals": {
              "top": [],
              "right": [
                {
                  "id": "ev",
                  "interface": "slac",
                  "type": "provide"
                },
                {
                  "id": "evse",
                  "interface": "slac",
                  "type": "provide"
                }
              ],
              "bottom": [],
              "left": []
            }
          },
          "token_provider": {
            "position": {
              "x": 37,
              "y": 32
            },
            "terminals": {
              "top": [
                {
                  "id": "main",
                  "interface": "auth_token_provider",
                  "type": "provide"
                }
              ],
              "right": [],
              "bottom": [],
              "left": [
                {
                  "id": "evse",
                  "interface": "evse_manager",
                  "type": "requirement"
                }
              ]
            }
          },
          "token_validator": {
            "position": {
              "x": 52,
              "y": 22
            },
            "terminals": {
              "top": [],
              "right": [],
              "bottom": [],
              "left": [
                {
                  "id": "main",
                  "interface": "auth_token_validator",
                  "type": "provide"
                }
              ]
            }
          },
          "yeti_driver": {
            "position": {
              "x": -12,
              "y": 16
            },
            "terminals": {
              "top": [],
              "right": [
                {
                  "id": "yeti_simulation_control",
                  "interface": "yeti_simulation_control",
                  "type": "provide"
                },
                {
                  "id": "connector_lock",
                  "interface": "connector_lock",
                  "type": "provide"
                },
                {
                  "id": "powermeter",
                  "interface": "powermeter",
                  "type": "provide"
                },
                {
                  "id": "rcd",
                  "interface": "ac_rcd",
                  "type": "provide"
                },
                {
                  "id": "board_support",
                  "interface": "evse_board_support",
                  "type": "provide"
                }
              ],
              "bottom": [],
              "left": []
            }
          }
        }
      },
      "config-sil-ocpp201": {
        "active_modules": {
          "api": {
            "module": "API",
            "connections": {
              "evse_manager": [
                {
                  "module_id": "evse_manager_1",
                  "implementation_id": "evse"
                }
              ]
            },
            "config_module": {
              "charger_information_file": "",
              "hw_caps_max_current_export_decimal_places": 2,
              "hw_caps_max_current_export_round_to": 0,
              "hw_caps_max_current_import_decimal_places": 2,
              "hw_caps_max_current_import_round_to": 0,
              "hw_caps_max_plug_temperature_C_decimal_places": 2,
              "hw_caps_max_plug_temperature_C_round_to": 0,
              "hw_caps_min_current_export_decimal_places": 2,
              "hw_caps_min_current_export_round_to": 0,
              "hw_caps_min_current_import_decimal_places": 2,
              "hw_caps_min_current_import_round_to": 0,
              "limits_max_current_decimal_places": 2,
              "limits_max_current_round_to": 0,
              "powermeter_VAR_decimal_places": 2,
              "powermeter_VAR_round_to": 0,
              "powermeter_current_decimal_places": 2,
              "powermeter_current_round_to": 0,
              "powermeter_energy_export_decimal_places": 2,
              "powermeter_energy_export_round_to": 0,
              "powermeter_energy_import_decimal_places": 2,
              "powermeter_energy_import_round_to": 0,
              "powermeter_frequency_decimal_places": 2,
              "powermeter_frequency_round_to": 0,
              "powermeter_power_decimal_places": 2,
              "powermeter_power_round_to": 0,
              "powermeter_voltage_decimal_places": 2,
              "powermeter_voltage_round_to": 0,
              "telemetry_evse_temperature_C_decimal_places": 2,
              "telemetry_evse_temperature_C_round_to": 0,
              "telemetry_fan_rpm_decimal_places": 2,
              "telemetry_fan_rpm_round_to": 0,
              "telemetry_plug_temperature_C_decimal_places": 2,
              "telemetry_plug_temperature_C_round_to": 0,
              "telemetry_supply_voltage_12V_decimal_places": 2,
              "telemetry_supply_voltage_12V_round_to": 0,
              "telemetry_supply_voltage_minus_12V_decimal_places": 2,
              "telemetry_supply_voltage_minus_12V_round_to": 0
            }
          },
          "auth": {
            "module": "Auth",
            "connections": {
              "evse_manager": [
                {
                  "module_id": "evse_manager_1",
                  "implementation_id": "evse"
                },
                {
                  "module_id": "evse_manager_2",
                  "implementation_id": "evse"
                }
              ],
              "token_provider": [
                {
                  "module_id": "token_provider_1",
                  "implementation_id": "main"
                },
                {
                  "module_id": "ocpp",
                  "implementation_id": "auth_provider"
                }
              ],
              "token_validator": [
                {
                  "module_id": "ocpp",
                  "implementation_id": "auth_validator"
                }
              ]
            },
            "config_module": {
              "connection_timeout": 60,
              "ignore_connector_faults": false,
              "master_pass_group_id": "",
              "prioritize_authorization_over_stopping_transaction": true,
              "selection_algorithm": "FindFirst"
            }
          },
          "car_simulator_1": {
            "module": "JsCarSimulator",
            "connections": {
              "ev": [
                {
                  "module_id": "iso15118_car",
                  "implementation_id": "ev"
                }
              ],
              "simulation_control": [
                {
                  "module_id": "yeti_driver_1",
                  "implementation_id": "yeti_simulation_control"
                }
              ],
              "slac": [
                {
                  "module_id": "slac",
                  "implementation_id": "ev"
                }
              ]
            },
            "config_module": {
              "auto_enable": true,
              "auto_exec": false,
              "auto_exec_commands": "sleep 1;iec_wait_pwr_ready;sleep 1;draw_power_regulated 16,3;sleep 30;unplug",
              "connector_id": 1,
              "dc_discharge_max_current_limit": 300,
              "dc_discharge_max_power_limit": 15e4,
              "dc_discharge_target_current": 5,
              "dc_discharge_v2g_minimal_soc": 20,
              "dc_energy_capacity": 6e4,
              "dc_max_current_limit": 300,
              "dc_max_power_limit": 15e4,
              "dc_max_voltage_limit": 900,
              "dc_target_current": 5,
              "dc_target_voltage": 200,
              "support_sae_j2847": false
            }
          },
          "car_simulator_2": {
            "module": "JsCarSimulator",
            "connections": {
              "ev": [
                {
                  "module_id": "iso15118_car",
                  "implementation_id": "ev"
                }
              ],
              "simulation_control": [
                {
                  "module_id": "yeti_driver_2",
                  "implementation_id": "yeti_simulation_control"
                }
              ],
              "slac": [
                {
                  "module_id": "slac",
                  "implementation_id": "ev"
                }
              ]
            },
            "config_module": {
              "auto_enable": true,
              "auto_exec": false,
              "auto_exec_commands": "",
              "connector_id": 2,
              "dc_discharge_max_current_limit": 300,
              "dc_discharge_max_power_limit": 15e4,
              "dc_discharge_target_current": 5,
              "dc_discharge_v2g_minimal_soc": 20,
              "dc_energy_capacity": 6e4,
              "dc_max_current_limit": 300,
              "dc_max_power_limit": 15e4,
              "dc_max_voltage_limit": 900,
              "dc_target_current": 5,
              "dc_target_voltage": 200,
              "support_sae_j2847": false
            }
          },
          "energy_manager": {
            "module": "EnergyManager",
            "connections": {
              "energy_trunk": [
                {
                  "module_id": "grid_connection_point",
                  "implementation_id": "energy_grid"
                }
              ]
            },
            "config_module": {
              "debug": false,
              "nominal_ac_voltage": 230,
              "schedule_interval_duration": 60,
              "schedule_total_duration": 1,
              "slice_ampere": 0.5,
              "slice_watt": 500,
              "update_interval": 1
            }
          },
          "evse_manager_1": {
            "module": "EvseManager",
            "connections": {
              "bsp": [
                {
                  "module_id": "yeti_driver_1",
                  "implementation_id": "board_support"
                }
              ],
              "hlc": [
                {
                  "module_id": "iso15118_charger",
                  "implementation_id": "charger"
                }
              ],
              "powermeter_grid_side": [
                {
                  "module_id": "yeti_driver_1",
                  "implementation_id": "powermeter"
                }
              ],
              "slac": [
                {
                  "module_id": "slac",
                  "implementation_id": "evse"
                }
              ]
            },
            "config_module": {
              "ac_enforce_hlc": false,
              "ac_hlc_enabled": false,
              "ac_hlc_use_5percent": false,
              "ac_nominal_voltage": 230,
              "ac_with_soc": false,
              "autocharge_use_slac_instead_of_hlc": false,
              "charge_mode": "AC",
              "connector_id": 1,
              "country_code": "DE",
              "dbg_hlc_auth_after_tstep": false,
              "dc_isolation_voltage_V": 500,
              "disable_authentication": false,
              "ev_receipt_required": false,
              "evse_id": "1",
              "evse_id_din": "49A80737A45678",
              "external_ready_to_start_charging": false,
              "hack_allow_bpt_with_iso2": false,
              "hack_fix_hlc_integer_current_requests": false,
              "hack_pause_imd_during_precharge": false,
              "hack_present_current_offset": 0,
              "hack_skoda_enyaq": false,
              "hack_sleep_in_cable_check": 0,
              "hack_sleep_in_cable_check_volkswagen": 0,
              "has_ventilation": true,
              "logfile_suffix": "session_uuid",
              "max_current_export_A": 32,
              "max_current_import_A": 32,
              "payment_enable_contract": true,
              "payment_enable_eim": true,
              "request_zero_power_in_idle": false,
              "sae_j2847_2_bpt_enabled": false,
              "sae_j2847_2_bpt_mode": "V2G",
              "session_logging": true,
              "session_logging_path": "/tmp",
              "session_logging_xml": false,
              "soft_over_current_measurement_noise_A": 0.5,
              "soft_over_current_tolerance_percent": 10,
              "switch_to_minimum_voltage_after_cable_check": false,
              "three_phases": true,
              "uk_smartcharging_random_delay_at_any_change": true,
              "uk_smartcharging_random_delay_enable": false,
              "uk_smartcharging_random_delay_max_duration": 600
            }
          },
          "evse_manager_2": {
            "module": "EvseManager",
            "connections": {
              "bsp": [
                {
                  "module_id": "yeti_driver_2",
                  "implementation_id": "board_support"
                }
              ],
              "hlc": [
                {
                  "module_id": "iso15118_charger",
                  "implementation_id": "charger"
                }
              ],
              "powermeter_grid_side": [
                {
                  "module_id": "yeti_driver_2",
                  "implementation_id": "powermeter"
                }
              ],
              "slac": [
                {
                  "module_id": "slac",
                  "implementation_id": "evse"
                }
              ]
            },
            "config_module": {
              "ac_enforce_hlc": false,
              "ac_hlc_enabled": false,
              "ac_hlc_use_5percent": false,
              "ac_nominal_voltage": 230,
              "ac_with_soc": false,
              "autocharge_use_slac_instead_of_hlc": false,
              "charge_mode": "AC",
              "connector_id": 2,
              "country_code": "DE",
              "dbg_hlc_auth_after_tstep": false,
              "dc_isolation_voltage_V": 500,
              "disable_authentication": false,
              "ev_receipt_required": false,
              "evse_id": "2",
              "evse_id_din": "49A80737A45678",
              "external_ready_to_start_charging": false,
              "hack_allow_bpt_with_iso2": false,
              "hack_fix_hlc_integer_current_requests": false,
              "hack_pause_imd_during_precharge": false,
              "hack_present_current_offset": 0,
              "hack_skoda_enyaq": false,
              "hack_sleep_in_cable_check": 0,
              "hack_sleep_in_cable_check_volkswagen": 0,
              "has_ventilation": true,
              "logfile_suffix": "session_uuid",
              "max_current_export_A": 32,
              "max_current_import_A": 32,
              "payment_enable_contract": true,
              "payment_enable_eim": true,
              "request_zero_power_in_idle": false,
              "sae_j2847_2_bpt_enabled": false,
              "sae_j2847_2_bpt_mode": "V2G",
              "session_logging": true,
              "session_logging_path": "/tmp",
              "session_logging_xml": false,
              "soft_over_current_measurement_noise_A": 0.5,
              "soft_over_current_tolerance_percent": 10,
              "switch_to_minimum_voltage_after_cable_check": false,
              "three_phases": true,
              "uk_smartcharging_random_delay_at_any_change": true,
              "uk_smartcharging_random_delay_enable": false,
              "uk_smartcharging_random_delay_max_duration": 600
            }
          },
          "evse_security": {
            "module": "EvseSecurity",
            "connections": {},
            "config_module": {
              "csms_ca_bundle": "ca/v2g/V2G_ROOT_CA.pem",
              "csms_leaf_cert_directory": "client/csms",
              "csms_leaf_key_directory": "client/csms",
              "mf_ca_bundle": "ca/mf/MF_ROOT_CA.pem",
              "mo_ca_bundle": "ca/mo/MO_ROOT_CA.pem",
              "private_key_password": "123456",
              "secc_leaf_cert_directory": "client/cso",
              "secc_leaf_key_directory": "client/cso",
              "v2g_ca_bundle": "ca/v2g/V2G_ROOT_CA.pem"
            }
          },
          "grid_connection_point": {
            "module": "EnergyNode",
            "connections": {
              "energy_consumer": [
                {
                  "module_id": "evse_manager_1",
                  "implementation_id": "energy_grid"
                },
                {
                  "module_id": "evse_manager_2",
                  "implementation_id": "energy_grid"
                }
              ],
              "powermeter": [
                {
                  "module_id": "yeti_driver_1",
                  "implementation_id": "powermeter"
                }
              ]
            },
            "config_module": {
              "fuse_limit_A": 40,
              "phase_count": 3
            }
          },
          "iso15118_car": {
            "module": "PyEvJosev",
            "connections": {},
            "config_module": {
              "device": "auto",
              "enforce_tls": false,
              "is_cert_install_needed": false,
              "supported_DIN70121": false,
              "supported_ISO15118_2": true,
              "supported_ISO15118_20_AC": false,
              "supported_ISO15118_20_DC": false,
              "tls_active": false
            }
          },
          "iso15118_charger": {
            "module": "EvseV2G",
            "connections": {
              "security": [
                {
                  "module_id": "evse_security",
                  "implementation_id": "main"
                }
              ]
            },
            "config_module": {
              "auth_timeout_eim": 300,
              "auth_timeout_pnc": 55,
              "device": "auto",
              "supported_DIN70121": false,
              "supported_ISO15118_2": true,
              "terminate_connection_on_failed_response": false,
              "tls_key_logging": false,
              "tls_key_logging_path": "/tmp",
              "tls_security": "allow",
              "tls_timeout": 15e3,
              "verify_contract_cert_chain": false
            }
          },
          "ocpp": {
            "module": "OCPP201",
            "connections": {
              "auth": [
                {
                  "module_id": "auth",
                  "implementation_id": "main"
                }
              ],
              "evse_manager": [
                {
                  "module_id": "evse_manager_1",
                  "implementation_id": "evse"
                },
                {
                  "module_id": "evse_manager_2",
                  "implementation_id": "evse"
                }
              ],
              "security": [
                {
                  "module_id": "evse_security",
                  "implementation_id": "main"
                }
              ],
              "system": [
                {
                  "module_id": "system",
                  "implementation_id": "main"
                }
              ]
            },
            "config_module": {
              "CoreDatabasePath": "/tmp/ocpp201",
              "DeviceModelDatabasePath": "device_model_storage.db",
              "EnableExternalWebsocketControl": false,
              "MessageLogPath": "/tmp/everest_ocpp_logs",
              "MessageQueueResumeDelay": 0
            }
          },
          "slac": {
            "module": "JsSlacSimulator",
            "connections": {},
            "config_implementation": {
              "ev": {
                "ev_id": "PIONIX_SAYS_HELLO"
              },
              "evse": {
                "evse_id": "PIONIX_SAYS_HELLO",
                "nid": "pionix!",
                "number_of_sounds": 10
              }
            }
          },
          "system": {
            "module": "System",
            "connections": {},
            "config_module": {
              "DefaultRetries": 1,
              "DefaultRetryInterval": 1
            }
          },
          "token_provider_1": {
            "module": "DummyTokenProviderManual",
            "connections": {},
            "config_implementation": {
              "main": {
                "timeout": 10,
                "token": "DEADBEEF",
                "type": "RFID"
              }
            }
          },
          "yeti_driver_1": {
            "module": "JsYetiSimulator",
            "connections": {},
            "config_module": {
              "connector_id": 1
            }
          },
          "yeti_driver_2": {
            "module": "JsYetiSimulator",
            "connections": {},
            "config_module": {
              "connector_id": 2
            }
          }
        },
        "x-module-layout": {
          "api": {
            "position": {
              "x": 41,
              "y": 4
            },
            "terminals": {
              "top": [],
              "right": [
                {
                  "id": "main",
                  "interface": "empty",
                  "type": "provide"
                }
              ],
              "bottom": [],
              "left": [
                {
                  "id": "evse_manager",
                  "interface": "evse_manager",
                  "type": "requirement"
                },
                {
                  "id": "ocpp",
                  "interface": "ocpp",
                  "type": "requirement"
                },
                {
                  "id": "random_delay",
                  "interface": "uk_random_delay",
                  "type": "requirement"
                }
              ]
            }
          },
          "auth": {
            "position": {
              "x": 39,
              "y": -17
            },
            "terminals": {
              "top": [],
              "right": [
                {
                  "id": "reservation",
                  "interface": "reservation",
                  "type": "provide"
                }
              ],
              "bottom": [
                {
                  "id": "main",
                  "interface": "auth",
                  "type": "provide"
                }
              ],
              "left": [
                {
                  "id": "token_provider",
                  "interface": "auth_token_provider",
                  "type": "requirement"
                },
                {
                  "id": "token_validator",
                  "interface": "auth_token_validator",
                  "type": "requirement"
                },
                {
                  "id": "evse_manager",
                  "interface": "evse_manager",
                  "type": "requirement"
                }
              ]
            }
          },
          "car_simulator_1": {
            "position": {
              "x": -60,
              "y": 17
            },
            "terminals": {
              "top": [
                {
                  "id": "ev",
                  "interface": "ISO15118_ev",
                  "type": "requirement"
                }
              ],
              "right": [
                {
                  "id": "simulation_control",
                  "interface": "yeti_simulation_control",
                  "type": "requirement"
                },
                {
                  "id": "main",
                  "interface": "car_simulator",
                  "type": "provide"
                }
              ],
              "bottom": [
                {
                  "id": "slac",
                  "interface": "slac",
                  "type": "requirement"
                }
              ],
              "left": []
            }
          },
          "car_simulator_2": {
            "position": {
              "x": -60,
              "y": 42
            },
            "terminals": {
              "top": [],
              "right": [
                {
                  "id": "ev",
                  "interface": "ISO15118_ev",
                  "type": "requirement"
                },
                {
                  "id": "simulation_control",
                  "interface": "yeti_simulation_control",
                  "type": "requirement"
                },
                {
                  "id": "slac",
                  "interface": "slac",
                  "type": "requirement"
                }
              ],
              "bottom": [
                {
                  "id": "main",
                  "interface": "car_simulator",
                  "type": "provide"
                }
              ],
              "left": []
            }
          },
          "energy_manager": {
            "position": {
              "x": 50,
              "y": 21
            },
            "terminals": {
              "top": [],
              "right": [
                {
                  "id": "main",
                  "interface": "energy_manager",
                  "type": "provide"
                }
              ],
              "bottom": [],
              "left": [
                {
                  "id": "energy_trunk",
                  "interface": "energy",
                  "type": "requirement"
                }
              ]
            }
          },
          "evse_manager_1": {
            "position": {
              "x": 2,
              "y": -1
            },
            "terminals": {
              "top": [],
              "right": [
                {
                  "id": "energy_grid",
                  "interface": "energy",
                  "type": "provide"
                },
                {
                  "id": "random_delay",
                  "interface": "uk_random_delay",
                  "type": "provide"
                },
                {
                  "id": "token_provider",
                  "interface": "auth_token_provider",
                  "type": "provide"
                },
                {
                  "id": "evse",
                  "interface": "evse_manager",
                  "type": "provide"
                }
              ],
              "bottom": [],
              "left": [
                {
                  "id": "ac_rcd",
                  "interface": "ac_rcd",
                  "type": "requirement"
                },
                {
                  "id": "bsp",
                  "interface": "evse_board_support",
                  "type": "requirement"
                },
                {
                  "id": "connector_lock",
                  "interface": "connector_lock",
                  "type": "requirement"
                },
                {
                  "id": "hlc",
                  "interface": "ISO15118_charger",
                  "type": "requirement"
                },
                {
                  "id": "imd",
                  "interface": "isolation_monitor",
                  "type": "requirement"
                },
                {
                  "id": "powermeter_car_side",
                  "interface": "powermeter",
                  "type": "requirement"
                },
                {
                  "id": "powermeter_grid_side",
                  "interface": "powermeter",
                  "type": "requirement"
                },
                {
                  "id": "powersupply_DC",
                  "interface": "power_supply_DC",
                  "type": "requirement"
                },
                {
                  "id": "slac",
                  "interface": "slac",
                  "type": "requirement"
                }
              ]
            }
          },
          "evse_manager_2": {
            "position": {
              "x": 13,
              "y": 16
            },
            "terminals": {
              "top": [
                {
                  "id": "evse",
                  "interface": "evse_manager",
                  "type": "provide"
                }
              ],
              "right": [
                {
                  "id": "energy_grid",
                  "interface": "energy",
                  "type": "provide"
                },
                {
                  "id": "random_delay",
                  "interface": "uk_random_delay",
                  "type": "provide"
                },
                {
                  "id": "token_provider",
                  "interface": "auth_token_provider",
                  "type": "provide"
                }
              ],
              "bottom": [],
              "left": [
                {
                  "id": "hlc",
                  "interface": "ISO15118_charger",
                  "type": "requirement"
                },
                {
                  "id": "ac_rcd",
                  "interface": "ac_rcd",
                  "type": "requirement"
                },
                {
                  "id": "bsp",
                  "interface": "evse_board_support",
                  "type": "requirement"
                },
                {
                  "id": "connector_lock",
                  "interface": "connector_lock",
                  "type": "requirement"
                },
                {
                  "id": "imd",
                  "interface": "isolation_monitor",
                  "type": "requirement"
                },
                {
                  "id": "powermeter_car_side",
                  "interface": "powermeter",
                  "type": "requirement"
                },
                {
                  "id": "powermeter_grid_side",
                  "interface": "powermeter",
                  "type": "requirement"
                },
                {
                  "id": "powersupply_DC",
                  "interface": "power_supply_DC",
                  "type": "requirement"
                },
                {
                  "id": "slac",
                  "interface": "slac",
                  "type": "requirement"
                }
              ]
            }
          },
          "evse_security": {
            "position": {
              "x": -40,
              "y": 3
            },
            "terminals": {
              "top": [],
              "right": [
                {
                  "id": "main",
                  "interface": "evse_security",
                  "type": "provide"
                }
              ],
              "bottom": [],
              "left": []
            }
          },
          "grid_connection_point": {
            "position": {
              "x": 32,
              "y": 23
            },
            "terminals": {
              "top": [
                {
                  "id": "energy_consumer",
                  "interface": "energy",
                  "type": "requirement"
                }
              ],
              "right": [
                {
                  "id": "energy_grid",
                  "interface": "energy",
                  "type": "provide"
                },
                {
                  "id": "external_limits",
                  "interface": "external_energy_limits",
                  "type": "provide"
                }
              ],
              "bottom": [],
              "left": [
                {
                  "id": "powermeter",
                  "interface": "powermeter",
                  "type": "requirement"
                },
                {
                  "id": "price_information",
                  "interface": "energy_price_information",
                  "type": "requirement"
                }
              ]
            }
          },
          "iso15118_car": {
            "position": {
              "x": -40,
              "y": 10
            },
            "terminals": {
              "top": [],
              "right": [],
              "bottom": [],
              "left": [
                {
                  "id": "ev",
                  "interface": "ISO15118_ev",
                  "type": "provide"
                }
              ]
            }
          },
          "iso15118_charger": {
            "position": {
              "x": -21,
              "y": -10
            },
            "terminals": {
              "top": [],
              "right": [],
              "bottom": [
                {
                  "id": "charger",
                  "interface": "ISO15118_charger",
                  "type": "provide"
                }
              ],
              "left": [
                {
                  "id": "security",
                  "interface": "evse_security",
                  "type": "requirement"
                }
              ]
            }
          },
          "ocpp": {
            "position": {
              "x": 24,
              "y": 7
            },
            "terminals": {
              "top": [
                {
                  "id": "auth_provider",
                  "interface": "auth_token_provider",
                  "type": "provide"
                },
                {
                  "id": "auth_validator",
                  "interface": "auth_token_validator",
                  "type": "provide"
                },
                {
                  "id": "auth",
                  "interface": "auth",
                  "type": "requirement"
                }
              ],
              "right": [
                {
                  "id": "data_transfer",
                  "interface": "ocpp_data_transfer",
                  "type": "provide"
                },
                {
                  "id": "main",
                  "interface": "empty",
                  "type": "provide"
                },
                {
                  "id": "ocpp_generic",
                  "interface": "ocpp",
                  "type": "provide"
                }
              ],
              "bottom": [],
              "left": [
                {
                  "id": "data_transfer",
                  "interface": "ocpp_data_transfer",
                  "type": "requirement"
                },
                {
                  "id": "evse_manager",
                  "interface": "evse_manager",
                  "type": "requirement"
                },
                {
                  "id": "security",
                  "interface": "evse_security",
                  "type": "requirement"
                },
                {
                  "id": "system",
                  "interface": "system",
                  "type": "requirement"
                }
              ]
            }
          },
          "slac": {
            "position": {
              "x": -40,
              "y": 38
            },
            "terminals": {
              "top": [],
              "right": [
                {
                  "id": "evse",
                  "interface": "slac",
                  "type": "provide"
                }
              ],
              "bottom": [],
              "left": [
                {
                  "id": "ev",
                  "interface": "slac",
                  "type": "provide"
                }
              ]
            }
          },
          "system": {
            "position": {
              "x": -40,
              "y": 31
            },
            "terminals": {
              "top": [],
              "right": [
                {
                  "id": "main",
                  "interface": "system",
                  "type": "provide"
                }
              ],
              "bottom": [],
              "left": []
            }
          },
          "token_provider_1": {
            "position": {
              "x": 12,
              "y": -21
            },
            "terminals": {
              "top": [],
              "right": [
                {
                  "id": "main",
                  "interface": "auth_token_provider",
                  "type": "provide"
                }
              ],
              "bottom": [],
              "left": []
            }
          },
          "yeti_driver_1": {
            "position": {
              "x": -40,
              "y": 17
            },
            "terminals": {
              "top": [],
              "right": [
                {
                  "id": "board_support",
                  "interface": "evse_board_support",
                  "type": "provide"
                },
                {
                  "id": "connector_lock",
                  "interface": "connector_lock",
                  "type": "provide"
                },
                {
                  "id": "powermeter",
                  "interface": "powermeter",
                  "type": "provide"
                },
                {
                  "id": "rcd",
                  "interface": "ac_rcd",
                  "type": "provide"
                }
              ],
              "bottom": [],
              "left": [
                {
                  "id": "yeti_simulation_control",
                  "interface": "yeti_simulation_control",
                  "type": "provide"
                }
              ]
            }
          },
          "yeti_driver_2": {
            "position": {
              "x": -40,
              "y": 24
            },
            "terminals": {
              "top": [],
              "right": [
                {
                  "id": "board_support",
                  "interface": "evse_board_support",
                  "type": "provide"
                },
                {
                  "id": "connector_lock",
                  "interface": "connector_lock",
                  "type": "provide"
                },
                {
                  "id": "powermeter",
                  "interface": "powermeter",
                  "type": "provide"
                },
                {
                  "id": "rcd",
                  "interface": "ac_rcd",
                  "type": "provide"
                }
              ],
              "bottom": [],
              "left": [
                {
                  "id": "yeti_simulation_control",
                  "interface": "yeti_simulation_control",
                  "type": "provide"
                }
              ]
            }
          }
        }
      },
      "config-sil": {
        "active_modules": {
          "MyEvseManager": {
            "module": "EvseManager",
            "connections": {
              "ac_rcd": [
                {
                  "module_id": "connector_1_powerpath",
                  "implementation_id": "rcd"
                }
              ],
              "bsp": [
                {
                  "module_id": "connector_1_powerpath",
                  "implementation_id": "board_support"
                }
              ],
              "connector_lock": [
                {
                  "module_id": "connector_1_powerpath",
                  "implementation_id": "connector_lock"
                }
              ],
              "hlc": [
                {
                  "module_id": "iso15118_charger",
                  "implementation_id": "charger"
                }
              ],
              "powermeter_grid_side": [
                {
                  "module_id": "connector_1_powerpath",
                  "implementation_id": "powermeter"
                }
              ],
              "slac": [
                {
                  "module_id": "slac",
                  "implementation_id": "evse"
                }
              ]
            },
            "config_module": {
              "ac_enforce_hlc": false,
              "ac_hlc_enabled": true,
              "ac_hlc_use_5percent": false,
              "ac_nominal_voltage": 230,
              "ac_with_soc": false,
              "autocharge_use_slac_instead_of_hlc": false,
              "charge_mode": "AC",
              "connector_id": 1,
              "country_code": "DE",
              "dbg_hlc_auth_after_tstep": false,
              "dc_isolation_voltage_V": 500,
              "disable_authentication": false,
              "ev_receipt_required": false,
              "evse_id": "DE*PNX*E12345*1",
              "evse_id_din": "49A80737A45678",
              "external_ready_to_start_charging": false,
              "hack_allow_bpt_with_iso2": false,
              "hack_fix_hlc_integer_current_requests": false,
              "hack_pause_imd_during_precharge": false,
              "hack_present_current_offset": 0,
              "hack_skoda_enyaq": false,
              "hack_sleep_in_cable_check": 0,
              "hack_sleep_in_cable_check_volkswagen": 0,
              "has_ventilation": true,
              "logfile_suffix": "session_uuid",
              "max_current_export_A": 32,
              "max_current_import_A": 32,
              "payment_enable_contract": true,
              "payment_enable_eim": true,
              "request_zero_power_in_idle": false,
              "sae_j2847_2_bpt_enabled": false,
              "sae_j2847_2_bpt_mode": "V2G",
              "session_logging": true,
              "session_logging_path": "/tmp/everest-logs",
              "session_logging_xml": false,
              "soft_over_current_measurement_noise_A": 0.5,
              "soft_over_current_tolerance_percent": 10,
              "switch_to_minimum_voltage_after_cable_check": false,
              "three_phases": true
            }
          },
          "api": {
            "module": "API",
            "connections": {
              "evse_manager": [
                {
                  "module_id": "MyEvseManager",
                  "implementation_id": "evse"
                }
              ]
            },
            "config_module": {
              "charger_information_file": "",
              "hw_caps_max_current_export_decimal_places": 2,
              "hw_caps_max_current_export_round_to": 0,
              "hw_caps_max_current_import_decimal_places": 2,
              "hw_caps_max_current_import_round_to": 0,
              "hw_caps_max_plug_temperature_C_decimal_places": 2,
              "hw_caps_max_plug_temperature_C_round_to": 0,
              "hw_caps_min_current_export_decimal_places": 2,
              "hw_caps_min_current_export_round_to": 0,
              "hw_caps_min_current_import_decimal_places": 2,
              "hw_caps_min_current_import_round_to": 0,
              "limits_max_current_decimal_places": 2,
              "limits_max_current_round_to": 0,
              "powermeter_VAR_decimal_places": 2,
              "powermeter_VAR_round_to": 0,
              "powermeter_current_decimal_places": 2,
              "powermeter_current_round_to": 0,
              "powermeter_energy_export_decimal_places": 2,
              "powermeter_energy_export_round_to": 0,
              "powermeter_energy_import_decimal_places": 2,
              "powermeter_energy_import_round_to": 0,
              "powermeter_frequency_decimal_places": 2,
              "powermeter_frequency_round_to": 0,
              "powermeter_power_decimal_places": 2,
              "powermeter_power_round_to": 0,
              "powermeter_voltage_decimal_places": 2,
              "powermeter_voltage_round_to": 0,
              "telemetry_evse_temperature_C_decimal_places": 2,
              "telemetry_evse_temperature_C_round_to": 0,
              "telemetry_fan_rpm_decimal_places": 2,
              "telemetry_fan_rpm_round_to": 0,
              "telemetry_plug_temperature_C_decimal_places": 2,
              "telemetry_plug_temperature_C_round_to": 0,
              "telemetry_supply_voltage_12V_decimal_places": 2,
              "telemetry_supply_voltage_12V_round_to": 0,
              "telemetry_supply_voltage_minus_12V_decimal_places": 2,
              "telemetry_supply_voltage_minus_12V_round_to": 0
            }
          },
          "auth": {
            "module": "Auth",
            "connections": {
              "evse_manager": [
                {
                  "module_id": "MyEvseManager",
                  "implementation_id": "evse"
                }
              ],
              "token_provider": [
                {
                  "module_id": "token_provider",
                  "implementation_id": "main"
                }
              ],
              "token_validator": [
                {
                  "module_id": "token_validator",
                  "implementation_id": "main"
                }
              ]
            },
            "config_module": {
              "connection_timeout": 10,
              "ignore_connector_faults": true,
              "master_pass_group_id": "",
              "prioritize_authorization_over_stopping_transaction": true,
              "selection_algorithm": "FindFirst"
            }
          },
          "car_simulator": {
            "module": "JsCarSimulator",
            "connections": {
              "ev": [
                {
                  "module_id": "iso15118_car",
                  "implementation_id": "ev"
                }
              ],
              "simulation_control": [
                {
                  "module_id": "connector_1_powerpath",
                  "implementation_id": "yeti_simulation_control"
                }
              ],
              "slac": [
                {
                  "module_id": "slac",
                  "implementation_id": "ev"
                }
              ]
            },
            "config_module": {
              "auto_enable": true,
              "auto_exec": false,
              "auto_exec_commands": "sleep 1;iec_wait_pwr_ready;sleep 1;draw_power_regulated 16,3;sleep 30;unplug",
              "connector_id": 1,
              "dc_discharge_max_current_limit": 300,
              "dc_discharge_max_power_limit": 15e4,
              "dc_discharge_target_current": 5,
              "dc_discharge_v2g_minimal_soc": 20,
              "dc_energy_capacity": 6e4,
              "dc_max_current_limit": 300,
              "dc_max_power_limit": 15e4,
              "dc_max_voltage_limit": 900,
              "dc_target_current": 5,
              "dc_target_voltage": 200,
              "support_sae_j2847": false
            }
          },
          "connector_1_powerpath": {
            "module": "JsYetiSimulator",
            "connections": {},
            "config_module": {
              "connector_id": 1
            }
          },
          "energy_manager": {
            "module": "EnergyManager",
            "connections": {
              "energy_trunk": [
                {
                  "module_id": "grid_connection_point",
                  "implementation_id": "energy_grid"
                }
              ]
            },
            "config_module": {
              "debug": false,
              "nominal_ac_voltage": 230,
              "schedule_interval_duration": 60,
              "schedule_total_duration": 1,
              "slice_ampere": 0.5,
              "slice_watt": 500,
              "update_interval": 1
            }
          },
          "evse_security": {
            "module": "EvseSecurity",
            "connections": {},
            "config_module": {
              "csms_ca_bundle": "ca/v2g/V2G_ROOT_CA.pem",
              "csms_leaf_cert_directory": "client/csms",
              "csms_leaf_key_directory": "client/csms",
              "mf_ca_bundle": "ca/mf/MF_ROOT_CA.pem",
              "mo_ca_bundle": "ca/mo/MO_ROOT_CA.pem",
              "private_key_password": 123456,
              "secc_leaf_cert_directory": "client/cso",
              "secc_leaf_key_directory": "client/cso",
              "v2g_ca_bundle": "ca/v2g/V2G_ROOT_CA.pem"
            }
          },
          "grid_connection_point": {
            "module": "EnergyNode",
            "connections": {
              "energy_consumer": [
                {
                  "module_id": "MyEvseManager",
                  "implementation_id": "energy_grid"
                }
              ]
            },
            "config_module": {
              "fuse_limit_A": 40,
              "phase_count": 3
            }
          },
          "iso15118_car": {
            "module": "PyEvJosev",
            "connections": {},
            "config_module": {
              "device": "auto",
              "enforce_tls": false,
              "is_cert_install_needed": false,
              "supported_DIN70121": false,
              "supported_ISO15118_2": true,
              "supported_ISO15118_20_AC": false,
              "supported_ISO15118_20_DC": false,
              "tls_active": false
            }
          },
          "iso15118_charger": {
            "module": "EvseV2G",
            "connections": {
              "security": [
                {
                  "module_id": "evse_security",
                  "implementation_id": "main"
                }
              ]
            },
            "config_module": {
              "auth_timeout_eim": 300,
              "auth_timeout_pnc": 55,
              "device": "auto",
              "supported_DIN70121": false,
              "supported_ISO15118_2": true,
              "terminate_connection_on_failed_response": false,
              "tls_key_logging": false,
              "tls_key_logging_path": "/tmp",
              "tls_security": "allow",
              "tls_timeout": 15e3,
              "verify_contract_cert_chain": false
            }
          },
          "persistent_store": {
            "module": "PersistentStore",
            "connections": {},
            "config_module": {
              "sqlite_db_file_path": "everest_persistent_store.db"
            }
          },
          "setup": {
            "module": "Setup",
            "connections": {
              "store": [
                {
                  "module_id": "persistent_store",
                  "implementation_id": "main"
                }
              ]
            },
            "config_module": {
              "ap_interface": "wlan0",
              "ap_ipv4": "192.168.1.1/24",
              "initialized_by_default": true,
              "localization": true,
              "online_check_host": "lfenergy.org",
              "release_metadata_file": "release.json",
              "setup_simulation": true,
              "setup_wifi": false
            }
          },
          "slac": {
            "module": "JsSlacSimulator",
            "connections": {},
            "config_implementation": {
              "ev": {
                "ev_id": "PIONIX_SAYS_HELLO"
              },
              "evse": {
                "evse_id": "PIONIX_SAYS_HELLO",
                "nid": "pionix!",
                "number_of_sounds": 10
              }
            }
          },
          "token_provider": {
            "module": "DummyTokenProvider",
            "connections": {
              "evse": [
                {
                  "module_id": "MyEvseManager",
                  "implementation_id": "evse"
                }
              ]
            },
            "config_implementation": {
              "main": {
                "timeout": 10,
                "token": "DEADBEEF",
                "type": "RFID"
              }
            }
          },
          "token_validator": {
            "module": "DummyTokenValidator",
            "connections": {},
            "config_implementation": {
              "main": {
                "sleep": 0.25,
                "validation_reason": "Token seems valid",
                "validation_result": "Accepted"
              }
            }
          }
        },
        "x-module-layout": {
          "MyEvseManager": {
            "position": {
              "x": 13,
              "y": 23
            },
            "terminals": {
              "bottom": [
                {
                  "id": "powersupply_DC",
                  "interface": "power_supply_DC",
                  "type": "requirement"
                },
                {
                  "id": "imd",
                  "interface": "isolation_monitor",
                  "type": "requirement"
                },
                {
                  "id": "powermeter_car_side",
                  "interface": "powermeter",
                  "type": "requirement"
                },
                {
                  "id": "token_provider",
                  "interface": "auth_token_provider",
                  "type": "provide"
                },
                {
                  "id": "slac",
                  "interface": "slac",
                  "type": "requirement"
                }
              ],
              "left": [
                {
                  "id": "hlc",
                  "interface": "ISO15118_charger",
                  "type": "requirement"
                }
              ],
              "right": [
                {
                  "id": "bsp",
                  "interface": "board_support_AC",
                  "type": "requirement"
                },
                {
                  "id": "powermeter_grid_side",
                  "interface": "powermeter",
                  "type": "requirement"
                }
              ],
              "top": [
                {
                  "id": "energy_grid",
                  "interface": "energy",
                  "type": "provide"
                },
                {
                  "id": "evse",
                  "interface": "evse_manager",
                  "type": "provide"
                }
              ]
            }
          },
          "api": {
            "position": {
              "x": 33,
              "y": 13
            },
            "terminals": {
              "bottom": [],
              "left": [
                {
                  "id": "evse_manager",
                  "interface": "evse_manager",
                  "type": "requirement"
                }
              ],
              "right": [
                {
                  "id": "main",
                  "interface": "empty",
                  "type": "provide"
                }
              ],
              "top": []
            }
          },
          "auth": {
            "position": {
              "x": 33,
              "y": 2
            },
            "terminals": {
              "bottom": [
                {
                  "id": "main",
                  "interface": "auth",
                  "type": "provide"
                },
                {
                  "id": "reservation",
                  "interface": "reservation",
                  "type": "provide"
                }
              ],
              "left": [
                {
                  "id": "evse_manager",
                  "interface": "evse_manager",
                  "type": "requirement"
                }
              ],
              "right": [
                {
                  "id": "token_validator",
                  "interface": "auth_token_validator",
                  "type": "requirement"
                }
              ],
              "top": [
                {
                  "id": "token_provider",
                  "interface": "auth_token_provider",
                  "type": "requirement"
                }
              ]
            }
          },
          "car_simulator": {
            "position": {
              "x": 53,
              "y": 33
            },
            "terminals": {
              "bottom": [],
              "left": [
                {
                  "id": "simulation_control",
                  "interface": "yeti_simulation_control",
                  "type": "requirement"
                },
                {
                  "id": "slac",
                  "interface": "slac",
                  "type": "requirement"
                }
              ],
              "right": [
                {
                  "id": "main",
                  "interface": "car_simulator",
                  "type": "provide"
                }
              ],
              "top": [
                {
                  "id": "ev",
                  "interface": "ISO15118_ev",
                  "type": "requirement"
                }
              ]
            }
          },
          "connector_1_powerpath": {
            "position": {
              "x": 33,
              "y": 23
            },
            "terminals": {
              "bottom": [
                {
                  "id": "debug_keepalive",
                  "interface": "debug_json",
                  "type": "provide"
                },
                {
                  "id": "debug_powermeter",
                  "interface": "debug_json",
                  "type": "provide"
                },
                {
                  "id": "debug_yeti",
                  "interface": "debug_json",
                  "type": "provide"
                },
                {
                  "id": "yeti_extras",
                  "interface": "yeti_extras",
                  "type": "provide"
                },
                {
                  "id": "debug_state",
                  "interface": "debug_json",
                  "type": "provide"
                }
              ],
              "left": [
                {
                  "id": "board_support",
                  "interface": "board_support_AC",
                  "type": "provide"
                },
                {
                  "id": "powermeter",
                  "interface": "powermeter",
                  "type": "provide"
                }
              ],
              "right": [
                {
                  "id": "yeti_simulation_control",
                  "interface": "yeti_simulation_control",
                  "type": "provide"
                }
              ],
              "top": []
            }
          },
          "energy_manager": {
            "position": {
              "x": -5,
              "y": 2
            },
            "terminals": {
              "bottom": [
                {
                  "id": "energy_trunk",
                  "interface": "energy",
                  "type": "requirement"
                }
              ],
              "left": [],
              "right": [
                {
                  "id": "main",
                  "interface": "energy_manager",
                  "type": "provide"
                }
              ],
              "top": []
            }
          },
          "evse_security": {
            "position": {
              "x": 9,
              "y": 2
            },
            "terminals": {
              "bottom": [],
              "left": [],
              "right": [
                {
                  "id": "main",
                  "interface": "evse_security",
                  "type": "provide"
                }
              ],
              "top": []
            }
          },
          "grid_connection_point": {
            "position": {
              "x": -5,
              "y": 13
            },
            "terminals": {
              "bottom": [],
              "left": [
                {
                  "id": "price_information",
                  "interface": "energy_price_information",
                  "type": "requirement"
                },
                {
                  "id": "powermeter",
                  "interface": "powermeter",
                  "type": "requirement"
                }
              ],
              "right": [
                {
                  "id": "external_limits",
                  "interface": "external_energy_limits",
                  "type": "provide"
                },
                {
                  "id": "energy_consumer",
                  "interface": "energy",
                  "type": "requirement"
                }
              ],
              "top": [
                {
                  "id": "energy_grid",
                  "interface": "energy",
                  "type": "provide"
                }
              ]
            }
          },
          "iso15118_car": {
            "position": {
              "x": 53,
              "y": 23
            },
            "terminals": {
              "bottom": [
                {
                  "id": "ev",
                  "interface": "ISO15118_ev",
                  "type": "provide"
                }
              ],
              "left": [],
              "right": [
                {
                  "id": "main",
                  "interface": "empty",
                  "type": "provide"
                }
              ],
              "top": []
            }
          },
          "iso15118_charger": {
            "position": {
              "x": -5,
              "y": 23
            },
            "terminals": {
              "bottom": [],
              "left": [],
              "right": [
                {
                  "id": "charger",
                  "interface": "ISO15118_charger",
                  "type": "provide"
                }
              ],
              "top": []
            }
          },
          "persistent_store": {
            "position": {
              "x": -5,
              "y": 40
            },
            "terminals": {
              "bottom": [],
              "left": [],
              "right": [
                {
                  "id": "main",
                  "interface": "kvs",
                  "type": "provide"
                }
              ],
              "top": []
            }
          },
          "setup": {
            "position": {
              "x": 13,
              "y": 40
            },
            "terminals": {
              "bottom": [],
              "left": [
                {
                  "id": "store",
                  "interface": "kvs",
                  "type": "requirement"
                }
              ],
              "right": [
                {
                  "id": "main",
                  "interface": "empty",
                  "type": "provide"
                }
              ],
              "top": []
            }
          },
          "slac": {
            "position": {
              "x": 33,
              "y": 33
            },
            "terminals": {
              "bottom": [],
              "left": [
                {
                  "id": "evse",
                  "interface": "slac",
                  "type": "provide"
                }
              ],
              "right": [
                {
                  "id": "ev",
                  "interface": "slac",
                  "type": "provide"
                }
              ],
              "top": []
            }
          },
          "token_provider": {
            "position": {
              "x": 33,
              "y": -9
            },
            "terminals": {
              "bottom": [
                {
                  "id": "main",
                  "interface": "auth_token_provider",
                  "type": "provide"
                }
              ],
              "left": [
                {
                  "id": "evse",
                  "interface": "evse_manager",
                  "type": "requirement"
                }
              ],
              "right": [],
              "top": []
            }
          },
          "token_validator": {
            "position": {
              "x": 51,
              "y": 2
            },
            "terminals": {
              "bottom": [],
              "left": [
                {
                  "id": "main",
                  "interface": "auth_token_validator",
                  "type": "provide"
                }
              ],
              "right": [],
              "top": []
            }
          }
        }
      }
    };
    class RpcIssuer {
      async get_modules() {
        return this.issue_rpc("get_modules", null, false);
      }
      async get_interfaces() {
        return this.issue_rpc("get_interfaces", null, false);
      }
      async get_configs() {
        return this.issue_rpc("get_configs", null, false);
      }
      async save_config(params, notification) {
        return this.issue_rpc("save_config", params, notification);
      }
      async restart_modules() {
        return this.issue_rpc("restart_modules", null, false);
      }
      async get_rpc_timeout() {
        return this.issue_rpc("get_rpc_timeout", null, false);
      }
    }
    class LoopbackRpcIssuer extends RpcIssuer {
      random_wait_resolve(returnValue) {
        if (returnValue) {
          return new Promise((resolve2) => {
            setTimeout(() => resolve2(returnValue), Math.random() * 4 * LOOPBACK_WAIT_MS);
          });
        } else {
          return new Promise((resolve2) => {
            setTimeout(() => resolve2(), Math.random() * 4 * LOOPBACK_WAIT_MS);
          });
        }
      }
      async get_modules() {
        return this.random_wait_resolve(SampleManifestList);
      }
      async get_interfaces() {
        return this.random_wait_resolve(SampleInterfaceList);
      }
      async get_configs() {
        const configs = LoopbackRpcIssuer.getConfigsFromLocalStorageOrDefault();
        return this.random_wait_resolve(configs);
      }
      static getConfigsFromLocalStorageOrDefault() {
        const configsString = localStorage.getItem("configs");
        if (configsString) {
          return Object.assign({}, SampleConfigList, JSON.parse(configsString));
        } else {
          return SampleConfigList;
        }
      }
      async save_config(params) {
        const configs = LoopbackRpcIssuer.getConfigsFromLocalStorageOrDefault();
        configs[params.name] = params.config;
        localStorage.setItem("configs", JSON.stringify(configs));
        return this.random_wait_resolve();
      }
      async restart_modules() {
        return this.random_wait_resolve();
      }
      async get_rpc_timeout() {
        return this.random_wait_resolve(5e3);
      }
      async issue_rpc() {
        throw new Error("Method not implemented in LoopbackRpcIssuer.");
      }
      async disconnect() {
        return this.random_wait_resolve();
      }
    }
    class WebsocketRpcIssuer extends RpcIssuer {
      constructor(_url, publish_connection_state) {
        super();
        __publicField(this, "_pending_commands", /* @__PURE__ */ new Map());
        __publicField(this, "_socket");
        __publicField(this, "_rpc_timeout_ms", INITIAL_RPC_TIMEOUT_VALUE);
        this._url = _url;
        this.publish_connection_state = publish_connection_state;
        this._socket = new WebSocket(this._url);
        this._socket.onopen = this._handle_socket_opened.bind(this);
        this._socket.onmessage = this.handle_backend_message.bind(this);
        this._socket.onerror = this._handle_socket_error.bind(this);
        this._socket.onclose = this._handle_socket_close.bind(this);
      }
      _handle_socket_opened() {
        this.publish_connection_state({ type: "OPENED" });
        this.get_rpc_timeout().then((timeout) => {
          this._rpc_timeout_ms = timeout;
        });
      }
      _handle_socket_error() {
        this.publish_connection_state({
          type: "ERROR",
          error: `Could not connect to ${this._socket.url}.`
        });
      }
      _handle_socket_close() {
        this.publish_connection_state({
          type: "CLOSED"
        });
      }
      async disconnect() {
        this._socket.close();
      }
      async issue_rpc(method, params, notification) {
        const id2 = notification ? void 0 : Math.floor(Math.random() * 1024 * 1024);
        const rpc_request = {
          method,
          ...params !== void 0 && { params },
          ...!notification && { id: id2 }
        };
        this._socket.send(JSON.stringify(rpc_request));
        if (notification) {
          return null;
        }
        return new Promise((resolve2, reject) => {
          const timeout_id = setTimeout(() => {
            this._pending_commands.delete(id2);
            reject(`RPC communication timeout to everest controller process after '${this._rpc_timeout_ms}'ms`);
          }, this._rpc_timeout_ms);
          this._pending_commands.set(id2, { resolve: resolve2, reject, timeout_id });
        });
      }
      handle_backend_message(ev) {
        const payload = JSON.parse(ev.data);
        if (payload.id !== void 0) {
          const id2 = payload.id;
          const pending_command = this._pending_commands.get(id2);
          if (pending_command === void 0) {
            console.log("Received an unknown JSON RPC command id");
            return;
          }
          this._pending_commands.delete(id2);
          clearTimeout(pending_command.timeout_id);
          if (payload.result !== void 0) {
            pending_command.resolve(payload.result);
          } else if (payload.error !== void 0) {
            pending_command.reject(payload.error.message);
          } else {
            console.log("Received an invalid JSON RPC response from backend");
          }
        }
      }
    }
    const LOOPBACK_WAIT_MS = 0;
    class EVBackendConnection {
      constructor(_url, _listener) {
        __publicField(this, "_socket");
        __publicField(this, "_last_message");
        __publicField(this, "_loopback", false);
        __publicField(this, "rpc_issuer");
        this._url = _url;
        this._listener = _listener;
        this._publish_connection_state({ type: "OPEN", url: this._url });
        if (this._url === "ws://loopback:8849") {
          this._connect_loopback_mode();
        } else {
          this._connect_websocket_mode();
        }
      }
      _connect_websocket_mode() {
        this.rpc_issuer = new WebsocketRpcIssuer(this._url, this._publish_connection_state.bind(this));
      }
      _connect_loopback_mode() {
        this.rpc_issuer = new LoopbackRpcIssuer();
        this._loopback = true;
        setTimeout(() => {
          this._publish_connection_state({ type: "OPENED" });
        }, LOOPBACK_WAIT_MS);
      }
      async _disconnect() {
        await this.rpc_issuer.disconnect();
        this._publish_connection_state({ type: "DISCONNECTED" });
        this._listener = () => {
        };
      }
      _publish_connection_state(status) {
        this._listener(status);
      }
    }
    class EVBackendClient {
      constructor() {
        __publicField(this, "initialized", false);
        __publicField(this, "_cxn", null);
        __publicField(this, "_event_handler_map", {});
        __publicField(this, "_last_event_map", {});
        __publicField(this, "evbcStore", useEvbcStore());
        __publicField(this, "everest_definitions", {
          modules: null,
          interfaces: null
        });
      }
      async connect(url) {
        if (this._cxn) {
          await this._cxn._disconnect();
        }
        this._cxn = new EVBackendConnection(url, (msg) => this._connection_state_listener(msg));
      }
      async disconnect() {
        this.initialized = false;
        await this._cxn._disconnect();
        this._cxn = null;
      }
      on(event_name, handler) {
        if (!(event_name in this._event_handler_map)) {
          this._event_handler_map[event_name] = [];
        }
        this._event_handler_map[event_name].push(handler);
        if (event_name in this._last_event_map) {
          handler(this._last_event_map[event_name]);
        }
        return () => {
          this._event_handler_map[event_name] = this._event_handler_map[event_name].filter((o2) => o2 !== handler);
        };
      }
      // FIXME (aw):
      // - these shouldn't be callable, until we're successfully connected
      // - it would be nice, if we got an object after successful connection, that contains that
      load_config(name) {
        if (!(name in this.evbcStore.available_configs)) {
          throw Error(`Configuration "${name}" not found`);
        }
        const config2 = this.evbcStore.available_configs[name];
        return new EVConfigModel(this.everest_definitions, name, config2);
      }
      create_config_model(name, config2) {
        return new EVConfigModel(this.everest_definitions, name, config2 ?? void 0);
      }
      async save_config(config2) {
        await this._cxn.rpc_issuer.save_config({
          name: `${config2._name}`,
          config: config2.serialize()
        }, false);
        await this._reload_configs();
      }
      _connection_state_listener(status) {
        let event = null;
        if (status.type === "OPEN") {
          event = { type: "INFO", text: `Opening WebSocket connection to ${status.url}` };
        } else if (status.type === "OPENED") {
          if (!this.initialized) {
            event = { type: "INFO", text: `Successfully opened WebSocket connection` };
            this._on_connected();
          } else {
            event = { type: "INITIALIZED", text: "Successfully reconnected" };
          }
        } else if (status.type === "ERROR") {
          event = { type: "FAILED", text: `Connection failed. Trying to reconnect.` };
        } else if (status.type === "CLOSED") {
          event = { type: "RECONNECT", text: "Trying to reconnect" };
        } else if (status.type === "DISCONNECTED") {
          event = { type: "IDLE", text: "Disconnected" };
        }
        if (event) {
          this._publish("connection_state", event);
        }
      }
      _on_connected() {
        this._reload_instance_data().then(() => {
          this.initialized = true;
          this._publish("connection_state", { type: "INITIALIZED", text: "Done initializing" });
        });
      }
      async _reload_modules() {
        this.everest_definitions.modules = await this._cxn.rpc_issuer.get_modules();
        this._publish("connection_state", { type: "INFO", text: `Received ${Object.keys(this.everest_definitions.modules).length} module files` });
      }
      async _reload_interfaces() {
        this.everest_definitions.interfaces = await this._cxn.rpc_issuer.get_interfaces();
        this._publish("connection_state", {
          type: "INFO",
          text: `Received ${Object.keys(this.everest_definitions.interfaces).length} interfaces definitions`
        });
      }
      async _reload_configs() {
        const cfgs = await this._cxn.rpc_issuer.get_configs();
        Object.assign(this.evbcStore.available_configs, cfgs);
        this._publish("connection_state", { type: "INFO", text: `Received ${Object.keys(cfgs).length} config files` });
      }
      _reload_instance_data() {
        return Promise.all([this._reload_interfaces(), this._reload_configs(), this._reload_modules()]);
      }
      _publish(event_name, message) {
        this._last_event_map[event_name] = message;
        if (!(event_name in this._event_handler_map)) {
          return;
        }
        this._event_handler_map[event_name].forEach((handler) => {
          handler(message);
        });
      }
    }
    const evbcPlugin = {
      install(app2) {
        const evbc2 = new EVBackendClient();
        app2.provide("evbc", evbc2);
      }
    };
    const pinia = createPinia();
    function yaml(hljs) {
      const LITERALS = "true false yes no null";
      const URI_CHARACTERS = "[\\w#;/?:@&=+$,.~*'()[\\]]+";
      const KEY = {
        className: "attr",
        variants: [
          // added brackets support 
          { begin: /\w[\w :()\./-]*:(?=[ \t]|$)/ },
          {
            // double quoted keys - with brackets
            begin: /"\w[\w :()\./-]*":(?=[ \t]|$)/
          },
          {
            // single quoted keys - with brackets
            begin: /'\w[\w :()\./-]*':(?=[ \t]|$)/
          }
        ]
      };
      const TEMPLATE_VARIABLES = {
        className: "template-variable",
        variants: [
          {
            // jinja templates Ansible
            begin: /\{\{/,
            end: /\}\}/
          },
          {
            // Ruby i18n
            begin: /%\{/,
            end: /\}/
          }
        ]
      };
      const STRING = {
        className: "string",
        relevance: 0,
        variants: [
          {
            begin: /'/,
            end: /'/
          },
          {
            begin: /"/,
            end: /"/
          },
          { begin: /\S+/ }
        ],
        contains: [
          hljs.BACKSLASH_ESCAPE,
          TEMPLATE_VARIABLES
        ]
      };
      const CONTAINER_STRING = hljs.inherit(STRING, { variants: [
        {
          begin: /'/,
          end: /'/
        },
        {
          begin: /"/,
          end: /"/
        },
        { begin: /[^\s,{}[\]]+/ }
      ] });
      const DATE_RE = "[0-9]{4}(-[0-9][0-9]){0,2}";
      const TIME_RE = "([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?";
      const FRACTION_RE = "(\\.[0-9]*)?";
      const ZONE_RE = "([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?";
      const TIMESTAMP = {
        className: "number",
        begin: "\\b" + DATE_RE + TIME_RE + FRACTION_RE + ZONE_RE + "\\b"
      };
      const VALUE_CONTAINER = {
        end: ",",
        endsWithParent: true,
        excludeEnd: true,
        keywords: LITERALS,
        relevance: 0
      };
      const OBJECT = {
        begin: /\{/,
        end: /\}/,
        contains: [VALUE_CONTAINER],
        illegal: "\\n",
        relevance: 0
      };
      const ARRAY = {
        begin: "\\[",
        end: "\\]",
        contains: [VALUE_CONTAINER],
        illegal: "\\n",
        relevance: 0
      };
      const MODES2 = [
        KEY,
        {
          className: "meta",
          begin: "^---\\s*$",
          relevance: 10
        },
        {
          // multi line string
          // Blocks start with a | or > followed by a newline
          //
          // Indentation of subsequent lines must be the same to
          // be considered part of the block
          className: "string",
          begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
        },
        {
          // Ruby/Rails erb
          begin: "<%[%=-]?",
          end: "[%-]?%>",
          subLanguage: "ruby",
          excludeBegin: true,
          excludeEnd: true,
          relevance: 0
        },
        {
          // named tags
          className: "type",
          begin: "!\\w+!" + URI_CHARACTERS
        },
        // https://yaml.org/spec/1.2/spec.html#id2784064
        {
          // verbatim tags
          className: "type",
          begin: "!<" + URI_CHARACTERS + ">"
        },
        {
          // primary tags
          className: "type",
          begin: "!" + URI_CHARACTERS
        },
        {
          // secondary tags
          className: "type",
          begin: "!!" + URI_CHARACTERS
        },
        {
          // fragment id &ref
          className: "meta",
          begin: "&" + hljs.UNDERSCORE_IDENT_RE + "$"
        },
        {
          // fragment reference *ref
          className: "meta",
          begin: "\\*" + hljs.UNDERSCORE_IDENT_RE + "$"
        },
        {
          // array listing
          className: "bullet",
          // TODO: remove |$ hack when we have proper look-ahead support
          begin: "-(?=[ ]|$)",
          relevance: 0
        },
        hljs.HASH_COMMENT_MODE,
        {
          beginKeywords: LITERALS,
          keywords: { literal: LITERALS }
        },
        TIMESTAMP,
        // numbers are any valid C-style number that
        // sit isolated from other words
        {
          className: "number",
          begin: hljs.C_NUMBER_RE + "\\b",
          relevance: 0
        },
        OBJECT,
        ARRAY,
        STRING
      ];
      const VALUE_MODES = [...MODES2];
      VALUE_MODES.pop();
      VALUE_MODES.push(CONTAINER_STRING);
      VALUE_CONTAINER.contains = VALUE_MODES;
      return {
        name: "YAML",
        case_insensitive: true,
        aliases: ["yml"],
        contains: MODES2
      };
    }
    function json(hljs) {
      const ATTRIBUTE = {
        className: "attr",
        begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
        relevance: 1.01
      };
      const PUNCTUATION = {
        match: /[{}[\],:]/,
        className: "punctuation",
        relevance: 0
      };
      const LITERALS = [
        "true",
        "false",
        "null"
      ];
      const LITERALS_MODE = {
        scope: "literal",
        beginKeywords: LITERALS.join(" ")
      };
      return {
        name: "JSON",
        aliases: ["jsonc"],
        keywords: {
          literal: LITERALS
        },
        contains: [
          ATTRIBUTE,
          PUNCTUATION,
          hljs.QUOTE_STRING_MODE,
          LITERALS_MODE,
          hljs.C_NUMBER_MODE,
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ],
        illegal: "\\S"
      };
    }
    HighlightJS.registerLanguage("yaml", yaml);
    HighlightJS.registerLanguage("json", json);
    function registerPlugins(app2) {
      app2.use(pinia).use(evbcPlugin).use(vuetify).use(router).use(o);
    }
    const app = createApp(App);
    registerPlugins(app);
    app.provide("notyf", new Notyf({
      duration: 3e3,
      // default duration for notifications
      ripple: true,
      // adds a material design ripple effect to the notifications
      position: {
        x: "right",
        y: "top"
      },
      types: [
        {
          type: "info",
          background: currentTheme.colors.info
        },
        {
          type: "success",
          background: currentTheme.colors.success
        },
        {
          type: "warning",
          background: currentTheme.colors.warning
        },
        {
          type: "error",
          background: currentTheme.colors.error
        }
      ]
    }));
    app.mount("#app");
  }
});
export default require_index_001();
